  eax,[esi].yBottom
        dec     eax                     ;rectangle definition is non-inclusive,
                                        ; so advance to first scan we'll copy
        sub     edx,eax                 ;-(offset from rect top to bottom)
        push    edx                     ;remember for use with source
        mov     ulCurrentDestScan,eax   ;start at bottom of dest copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan (first scan to which to copy)
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first dest byte
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        pop     edx                     ;retrieve -(offset from top to bottom)
        sub     eax,edx                 ;advance to bottom of source rect
                                        ; (inclusive; this is first scan from
                                        ; which to copy)
        mov     ulCurrentSrcScan,eax    ;start at bottom of source copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftSrcWidthMinus1 ;the first whole byte includes the
        dec     eax                      ; last (leftmost) left edge byte, so
        add     eax,ulLeftEdgeAdjust     ; add a byte if the left edge is 2
                                         ; wide, except when the left dest byte
                                         ; is solid so the left edge is part of
                                         ; the whole bytes
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeSrc,eax      ;where the right src edge starts,
                                        ; because the whole bytes and the right
                                        ; source edge share a byte, and we
                                        ; always point to the leftmost byte in
                                        ; the right source edge

; Branch to the appropriate bottom-to-top bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     BottomToTopLoopTable[eax*4]


;-----------------------------------------------------------------------;
; Set-up code for right-to-left, bottom-to-top copies.
;-----------------------------------------------------------------------;

right_to_left_bottom_to_top::

        std                             ;we'll copy right to left

; Byte-combining mask, in preparation for ORing and letting the VGA's rotator
; rotate, assuming the left-hand source byte is in AL and the right-hand source
; byte is in AH (always true except for left-to-right whole bytes).

        mov     eax,ulCombineMask
        mov     ulCombineMaskWhole,eax

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_lNextScan
        neg     eax
        mov     ulNextScan,eax          ;copy bottom to top
        add     eax,culWholeBytesWidth  ;offset from end of one whole byte scan
        mov     ulWholeScanDelta,eax    ; to start of next
        inc     eax                     ;offset from end of one src whole byte
        mov     ulWholeScanSrcDelta,eax ; scan to start of next, accounting for
                                        ; leading byte used to prime the
                                        ; rotation pipeline

        mov     esi,ulLWRType           ;3-bit flag field for left, whole, and
                                        ; right involvement in operation
                                        ;leave left-to-right field cleared, so
                                        ; we look up right-to-left entries
        mov     eax,MasterThreadTable[esi*4]
        mov     pCurrentThread,eax      ;threading when no buffering is needed
        mov     edx,ulAdapterType
        shl     edx,ADAPTER_FIELD_SHIFT
        or      esi,edx                 ;factor adapter type into the index
        mov     eax,MasterThreadTableViaBuffer[esi*4]
        mov     pCurrentThreadViaBuffer,eax ;threading when buffering is needed

        mov     ulCurrentJustification,JustifyBottom ;copy bottom to top

        mov     esi,prcldest
        mov     edx,[esi].yTop
        mov     ulLastDestScan,edx      ;end at top of dest copy rect
        mov     eax,[esi].yBottom
        dec     eax                     ;rectangle definition is non-inclusive,
                                        ; so advance to first scan we'll copy
        sub     edx,eax                 ;-(offset from rect top to bottom)
        push    edx                     ;remember for use with source
        mov     ulCurrentDestScan,eax   ;start at bottom of dest copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan (first scan to which to copy)
        mov     edx,[esi].xLeft
        shr     edx,3                   ;byte X address
        add     eax,edx
        mov     ulLeftEdgeDest,eax      ;that's where the left dest edge is
        add     eax,ulLeftEdgeAdjust    ;the whole bytes start at the next
                                        ; byte, unless the left edge is a whole
                                        ; byte and is thus part of the whole
                                        ; bytes already
        add     eax,culWholeBytesWidth  ;point to the right edge
        mov     ulRightEdgeDest,eax     ;where the right dest edge starts
        dec     eax                     ;back up to the last whole byte
        mov     ulWholeBytesDest,eax    ;where the whole dest bytes start

        mov     esi,pptlsrc
        mov     eax,[esi].ptl_y
        pop     edx                     ;retrieve -(offset from top to bottom)
        sub     eax,edx                 ;advance to bottom of source rect
                                        ; (inclusive; this is first scan from
                                        ; which to copy)
        mov     ulCurrentSrcScan,eax    ;start at bottom of source copy rect
        mul     [edi].dsurf_lNextScan   ;offset in bitmap of bottom dest rect
                                        ; scan
        mov     edx,[esi].ptl_x
        shr     edx,3                   ;byte X address
        add     eax,edx                 ;offset in bitmap of first source byte
        mov     ulLeftEdgeSrc,eax       ;that's where the left src edge is
        add     eax,ulLeftSrcWidthMinus1 ;the first whole byte includes the
        dec     eax                      ; last (leftmost) left edge byte, so
        add     eax,ulLeftEdgeAdjust     ; add a byte if the left edge is 2
                                         ; wide, except when the left dest byte
                                         ; is solid so the left edge is part of
                                         ; the whole bytes
        add     eax,culWholeBytesWidth  ;point to the right edge of the whole
                                        ; src bytes, accounting for the extra
                                        ; source byte needed to prime the
                                        ; rotation pipeline
        mov     ulWholeBytesSrc,eax     ;where the src whole bytes start
        mov     ulRightEdgeSrc,eax      ;that's also where the right src edge
                                        ; starts, because the whole bytes and
                                        ; the right source edge share a byte,
                                        ; and we always point to the leftmost
                                        ; byte in the right source edge

; Branch to the appropriate bottom-to-top bank enumeration loop.

        mov     eax,ulAdapterType
        jmp     BottomToTopLoopTable[eax*4]


;***********************************************************************;
;
; The following routines are the banking loops.
;
;***********************************************************************;


;-----------------------------------------------------------------------;
; Banking for 2 R/W and unbanked adapters, top to bottom.
;-----------------------------------------------------------------------;
top_to_bottom_2RW::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source top less than
                                                     ; current source bank?
        jl      short top_2RW_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source top greater than
                                                        ; current source bank?
        jl      short top_2RW_init_src_bank_mapped
                                                ;no, proper bank already mapped
top_2RW_map_init_src_bank:

; Map bank containing the top source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapSourceBank>

top_2RW_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest top less than
                                                     ; current dest bank?
        jl      short top_2RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest top greater than
                                                        ; current dest bank?
        jl      short top_2RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
top_2RW_map_init_dest_bank:

; Map bank containing the top dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank>

top_2RW_init_dest_bank_mapped:

; Bank-by-bank top-to-bottom copy loop.

top_2RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom
        jl      short @F        ;copy rectangle bottom is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest extends to end
                                                        ; of bank, at least
@@:
        sub     edx,ulCurrentDestScan   ;# of scans we can and want to do in
                                        ; the dest bank
        mov     eax,[ebx].dsurf_rcl2WindowClipS.yBottom
        sub     eax,ulCurrentSrcScan    ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.

        THREAD_AND_START

; Any more scans to copy?

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        add     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we at the dest rect bottom?
        jz      short top_2RW_done      ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest scan greater than
                                                        ; current dest bank?
        jl      short top_2RW_dest_bank_mapped    ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyTop,MapDestBank>

top_2RW_dest_bank_mapped:

        add     esi,ulCurrentSrcScan    ;we've copied from source up to here
        mov     ulCurrentSrcScan,esi

        cmp     esi,[ebx].dsurf_rcl2WindowClipS.yBottom ;src scan greater than
                                                        ; current src bank?
        jl      short top_2RW_src_bank_mapped     ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_2RW_src_bank_mapped:

        jmp     top_2RW_bank_loop

top_2RW_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 2 R/W and unbanked adapters, bottom to top.
;-----------------------------------------------------------------------;
bottom_to_top_2RW::

; We're going bottom to top. Map in the source and dest, bottom-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source bottom less than
                                                     ; current source bank?
        jl      short bot_2RW_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source bottom greater
                                                        ; than current src bank?
        jl      short bot_2RW_init_src_bank_mapped
                                                ;no, proper bank already mapped
bot_2RW_map_init_src_bank:

; Map bank containing the bottom source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapSourceBank>

bot_2RW_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest bottom less than
                                                     ; current dest bank?
        jl      short bot_2RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest bottom greater
                                                        ; than current dst bank?
        jl      short bot_2RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
bot_2RW_map_init_dest_bank:

; Map bank containing the bottom dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapDestBank>

bot_2RW_init_dest_bank_mapped:

; Bank-by-bank bottom-to-top copy loop.

bot_2RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop
        jg      short @F        ;copy rectangle top is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;dest extends to end
                                                     ; of bank, at least
@@:
        neg     edx
        add     edx,ulCurrentDestScan   ;# of scans we can and want to do in
        inc     edx                     ; the dest bank

        mov     eax,ulCurrentSrcScan
        sub     eax,[ebx].dsurf_rcl2WindowClipS.yTop
        inc     eax                     ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.

        THREAD_AND_START

; Any more scans to copy?

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        sub     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we past the dest rect top?
        jg      short bot_2RW_done      ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yTop ;dest scan less than
                                                     ; current dest bank?
        jge     short bot_2RW_dest_bank_mapped    ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapDestBank>

bot_2RW_dest_bank_mapped:

        mov     eax,ulCurrentSrcScan
        sub     eax,esi         ;we've copied from source up to here
        mov     ulCurrentSrcScan,eax

        cmp     eax,[ebx].dsurf_rcl2WindowClipS.yTop ;src scan less than
                                                     ; current src bank?
        jge     short bot_2RW_src_bank_mapped     ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapSourceBank>

bot_2RW_src_bank_mapped:

        jmp     bot_2RW_bank_loop

bot_2RW_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1R/1W adapters, top to bottom.
;-----------------------------------------------------------------------;
top_to_bottom_1R1W::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source top less than
                                                     ; current source bank?
        jl      short top_1R1W_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source top greater than
                                                        ; current source bank?
        jl      short top_1R1W_init_src_bank_mapped
                                                ;no, proper bank already mapped
top_1R1W_map_init_src_bank:

; Map bank containing the top source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapSourceBank>

top_1R1W_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest top less than
                                                     ; current dest bank?
        jl      short top_1R1W_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest top greater than
                                                        ; current dest bank?
        jl      short top_1R1W_init_dest_bank_mapped
                                                ;no, proper bank already mapped
top_1R1W_map_init_dest_bank:

; Map bank containing the top dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank>

top_1R1W_init_dest_bank_mapped:

; Bank-by-bank top-to-bottom copy loop.

top_1R1W_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom
        jl      short @F        ;copy rectangle bottom is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest extends to end
                                                        ; of bank, at least
@@:
        sub     edx,ulCurrentDestScan   ;# of scans we can and want to do in
                                        ; the dest bank
        mov     eax,[ebx].dsurf_rcl2WindowClipS.yBottom
        sub     eax,ulCurrentSrcScan    ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can do edges faster if they are.

        mov     eax,[ebx].dsurf_ulWindowBank
        cmp     eax,[ebx].dsurf_ulWindowBank[4]
        jz      short top_1R1W_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,top_1R1W_check_more_scans

; Source and dest are currently in the same bank.

top_1R1W_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

top_1R1W_check_more_scans:

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        add     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we at the dest rect bottom?
        jz      short top_1R1W_done     ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest scan greater than
                                                        ; current dest bank?
        jl      short top_1R1W_dest_bank_mapped   ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyTop,MapDestBank>

top_1R1W_dest_bank_mapped:

        add     esi,ulCurrentSrcScan    ;we've copied from source up to here
        mov     ulCurrentSrcScan,esi

        cmp     esi,[ebx].dsurf_rcl2WindowClipS.yBottom ;src scan greater than
                                                        ; current src bank?
        jl      short top_1R1W_src_bank_mapped     ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_1R1W_src_bank_mapped:

        jmp     top_1R1W_bank_loop

top_1R1W_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1R/1W adapters, bottom to top.
;-----------------------------------------------------------------------;
bottom_to_top_1R1W::

; We're going bottom to top. Map in the source and dest, bottom-justified.

        mov     ebx,pdsurf
        mov     edx,ulCurrentSrcScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is source bottom less than
                                                     ; current source bank?
        jl      short bot_1R1W_map_init_src_bank      ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;source bottom greater
                                                        ; than current src bank?
        jl      short bot_1R1W_init_src_bank_mapped
                                                ;no, proper bank already mapped
bot_1R1W_map_init_src_bank:

; Map bank containing the bottom source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapSourceBank>

bot_1R1W_init_src_bank_mapped:

        mov     edx,ulCurrentDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is dest bottom less than
                                                     ; current dest bank?
        jl      short bot_1R1W_map_init_dest_bank     ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;dest bottom greater
                                                        ; than current dst bank?
        jl      short bot_1R1W_init_dest_bank_mapped
                                                ;no, proper bank already mapped
bot_1R1W_map_init_dest_bank:

; Map bank containing the bottom dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapDestBank>

bot_1R1W_init_dest_bank_mapped:

; Bank-by-bank bottom-to-top copy loop.

bot_1R1W_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edx,ulLastDestScan
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop
        jg      short @F        ;copy rectangle top is in this bank
        mov     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;dest extends to end
                                                     ; of bank, at least
@@:
        neg     edx
        add     edx,ulCurrentDestScan   ;# of scans we can and want to do in
        inc     edx                     ; the dest bank

        mov     eax,ulCurrentSrcScan
        sub     eax,[ebx].dsurf_rcl2WindowClipS.yTop
        inc     eax                     ;# of scans we can do in the src bank

        cmp     edx,eax
        jb      short @F        ;source bank isn't limiting
        mov     edx,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edx ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can do edges faster if they are.

        mov     al,byte ptr [ebx].dsurf_ulWindowBank
        cmp     al,byte ptr [ebx].dsurf_ulWindowBank[4]
        jz      short bot_1R1W_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,bot_1R1W_check_more_scans

; Source and dest are currently in the same bank.

bot_1R1W_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

bot_1R1W_check_more_scans:

        mov     eax,ulCurrentDestScan
        mov     esi,ulBlockHeight
        sub     eax,esi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,eax      ;are we past the dest rect top?
        jg      short bot_1R1W_done     ;yes, we're done
        mov     ulCurrentDestScan,eax

; Now advance either or both banks, as needed.

        mov     ebx,pdsurf
        cmp     eax,[ebx].dsurf_rcl2WindowClipD.yTop ;dest scan less than
                                                     ; current dest bank?
        jge     short bot_1R1W_dest_bank_mapped   ;no, proper bank still mapped

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapDestBank>

bot_1R1W_dest_bank_mapped:

        mov     eax,ulCurrentSrcScan
        sub     eax,esi         ;we've copied from source up to here
        mov     ulCurrentSrcScan,eax

        cmp     eax,[ebx].dsurf_rcl2WindowClipS.yTop ;src scan less than
                                                     ; current src bank?
        jge     short bot_1R1W_src_bank_mapped    ;no, proper bank still mapped

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,eax,JustifyBottom,MapSourceBank>

bot_1R1W_src_bank_mapped:

        jmp     bot_1R1W_bank_loop

bot_1R1W_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, top to bottom.
;-----------------------------------------------------------------------;
top_to_bottom_1RW::

; We're going top to bottom. Map in the dest, top-justified.

        mov     ebx,pdsurf
        mov     esi,ulCurrentDestScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop  ;is dest top less than
                                                     ; current bank?
        jl      short top_1RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest top greater than
                                                        ; current bank?
        jl      short top_1RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
top_1RW_map_init_dest_bank:

; Map bank containing the top dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyTop>

top_1RW_init_dest_bank_mapped:

; Bank-by-bank top-to-bottom copy loop.

top_1RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edi,ulLastDestScan
        cmp     edi,[ebx].dsurf_rcl1WindowClip.yBottom
        jl      short @F        ;copy rectangle bottom is in this bank
        mov     edi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest extends to end
                                                       ; of bank, at least
@@:
        sub     edi,esi   ;# of scans we can and want to do in the dest bank

; Now make sure source is mapped in. This is the condition the copying routines
; expect, and we need to figure out how far we can go in the source.

        sub     edx,edx                 ;assume source and dest are in the same
                                        ; bank
        mov     esi,ulCurrentSrcScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;src scan less than
                                                    ; current bank?
        jl      short top_1RW_map_src_Bank          ;yes, must map in
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;src scan greater than
                                                       ; current bank?
        jl      short top_1RW_src_bank_mapped     ;no, proper bank still mapped

top_1RW_map_src_Bank:

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyTop>

        mov     edx,1                   ;mark that source and dest are not in
                                        ; the same bank
top_1RW_src_bank_mapped:

        mov     eax,[ebx].dsurf_rcl1WindowClip.yBottom
        sub     eax,esi         ;# of scans we can do in the src bank

        cmp     edi,eax
        jb      short @F        ;source bank isn't limiting
        mov     edi,eax         ;source bank is limiting
@@:
        mov     ulBlockHeight,edi ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can do edges faster if they are.

        and     edx,edx
        jz      short top_1RW_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,top_1RW_check_more_scans

; Source and dest are currently in the same bank.

top_1RW_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

top_1RW_check_more_scans:

        mov     esi,ulCurrentDestScan
        mov     edi,ulBlockHeight
        add     esi,edi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,esi      ;are we at the dest rect bottom?
        jz      short top_1RW_done      ;yes, we're done
        mov     ulCurrentDestScan,esi

; Now make sure the dest bank is mapped in.

        mov     ebx,pdsurf
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;dest scan less than
                                                    ; current bank?
        jl      short top_1RW_map_dest_bank         ;yes, map in dest bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest scan greater than
                                                        ; current bank?
        jl      short top_1RW_dest_bank_mapped   ;no, proper bank mapped

top_1RW_map_dest_bank:

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyTop>

top_1RW_dest_bank_mapped:

        add     ulCurrentSrcScan,edi    ;we've copied from source up to here

        jmp     top_1RW_bank_loop

top_1RW_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, bottom to top.
;-----------------------------------------------------------------------;
bottom_to_top_1RW::

; We're going bottom to top. Map in the dest, bottom-justified.

        mov     ebx,pdsurf
        mov     esi,ulCurrentDestScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop  ;is dest bottom less than
                                                     ; current dest bank?
        jl      short bot_1RW_map_init_dest_bank     ;yes, map in proper bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest bottom greater
                                                       ; than current dst bank?
        jl      short bot_1RW_init_dest_bank_mapped
                                                ;no, proper bank already mapped
bot_1RW_map_init_dest_bank:

; Map bank containing the bottom dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyBottom>

bot_1RW_init_dest_bank_mapped:

; Bank-by-bank bottom-to-top copy loop.

bot_1RW_bank_loop:

; Decide how far we can go before we run out of bank or rectangle to copy.

        mov     edi,ulLastDestScan
        cmp     edi,[ebx].dsurf_rcl1WindowClip.yTop
        jg      short @F        ;copy rectangle top is in this bank
        mov     edi,[ebx].dsurf_rcl1WindowClip.yTop ;dest extends to end
                                                    ; of bank, at least
@@:
        neg     edi
        add     edi,esi                 ;# of scans we can and want to do in
        inc     edi                     ; the dest bank

; Now make sure source is mapped in. This is the condition the copying routines
; expect, and we need to figure out how far we can go in the source.

        sub     edx,edx                 ;assume source and dest are in the same
                                        ; bank
        mov     esi,ulCurrentSrcScan
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;src scan less than
                                                    ; current bank?
        jl      short bot_1RW_map_src_Bank          ;yes, must map in
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;src scan greater than
                                                       ; current bank?
        jl      short bot_1RW_src_bank_mapped     ;no, proper bank still mapped

bot_1RW_map_src_Bank:

; Map bank containing the current source scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyBottom>

        mov     edx,1                   ;mark that source and dest are not in
                                        ; the same bank
bot_1RW_src_bank_mapped:

        sub     esi,[ebx].dsurf_rcl1WindowClip.yTop
        inc     esi                     ;# of scans we can do in the src bank

        cmp     edi,esi
        jb      short @F        ;source bank isn't limiting
        mov     edi,esi         ;source bank is limiting
@@:
        mov     ulBlockHeight,edi ;# of scans we'll do in this bank

; We're ready to copy this block.
; Select different threading, depending on whether the source and destination
; are currently in the same bank; we can copy much faster if they are.

        and     edx,edx
        jz      short bot_1RW_copy_same_bank

; Source and dest are currently in different banks, must go through temp buffer.

        THREAD_AND_START pCurrentThreadViaBuffer,bot_1RW_check_more_scans

; Source and dest are currently in the same bank.

bot_1RW_copy_same_bank:
        THREAD_AND_START

; Any more scans to copy?

bot_1RW_check_more_scans:

        mov     esi,ulCurrentDestScan
        mov     edi,ulBlockHeight
        sub     esi,edi                 ;we've copied to dest up to here
        cmp     ulLastDestScan,esi      ;are we past the dest rect top?
        jg      short bot_1RW_done      ;yes, we're done
        mov     ulCurrentDestScan,esi

; Now make sure the dest bank is mapped in.

        mov     ebx,pdsurf
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yTop ;dest scan less than
                                                    ; current bank?
        jl      short bot_1RW_map_dest_bank         ;yes, map in dest bank
        cmp     esi,[ebx].dsurf_rcl1WindowClip.yBottom ;dest scan greater than
                                                        ; current bank?
        jl      short bot_1RW_dest_bank_mapped   ;no, proper bank mapped

bot_1RW_map_dest_bank:

; Map bank containing the current dest scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,esi,JustifyBottom>

bot_1RW_dest_bank_mapped:

        sub     ulCurrentSrcScan,edi    ;we've copied from source up to here

        jmp     bot_1RW_bank_loop

bot_1RW_done:
        PLAIN_RET


;***********************************************************************;
;
; The following routines are the low-level copying routines. They know
; almost nothing about banks (the routines that copy through a temp
; buffer know how to switch banks after filling the temp buffer, but
; that's it). Banking should be taken care of at a higher level.
;
;***********************************************************************;

;-----------------------------------------------------------------------;
; Copies a block of solid bytes directly from the source to the
; destination, without using a temp buffer. We can't use the latches,
; though, because this is a rotated copy. Can only be used by 2 R/W or
; 1R/1W window banking, or by unbanked modes, or by 1 R/W adapters when
; the source and dest are in the same bank. 1 R/W adapters must go
; through an intermediate local buffer when the source and the destination
; aren't in the same bank.
;
; Input:
;       Direction Flag set for desired direction of copy
;       culWholeBytesWidth = # of bytes to copy across each scan line
;       ulWholeScanDelta = distance to start of next dest scan from end of
;               current
;       ulWholeScanSrcDelta = distance to start of next source scan from end of
;               current
;       ulBlockHeight = # of scans to copy
;       ulWholeBytesSrc = start source offset in bitmap
;       ulWholeBytesDest = start dest offset in bitmap
;       ulCombineMaskWhole = masking to be applied before ORing the two source
;               bytes together, to keep only the data needed in preparation
;               for the VGA rotator doing its stuff
;
; Output:
;       Advances ulWholeBytesSrc and ulWholeBytesDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_whole_bytes::

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     eax,ulWholeBytesSrc
        add     eax,[ecx].dsurf_pvBitmapStart2WindowS
        mov     pSrcAddr,eax
        mov     eax,ulWholeBytesDest
        add     eax,[ecx].dsurf_pvBitmapStart2WindowD
        mov     pDestAddr,eax

; Set the bit mask to enable all bits.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Leave GC Index pointing to the Read Map register.

        mov     al,GRAF_READ_MAP
        out     dx,al

; Set up to copy the whole bytes from the buffer.

        mov     eax,ulBlockHeight
        mov     ulTempScanCount,eax

copy_whole_scan_loop:

        mov     cl,MM_C3        ;start by copying plane 3 (for Map Mask)

copy_whole_plane_loop:

; Set Map Mask to enable writes to the plane we're copying.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,cl
        out     dx,al

; Set Read Map to enable reads from the plane we're copying.

        mov     dl,GRAF_DATA
        shr     al,1                    ;map plane into ReadMask
        cmp     al,100b                 ;set Carry if not C3 (plane 3)
        adc     al,-1                   ;sub 1 only if C3
        out     dx,al

; Select the corresponding plane from the temp buffer.

        mov     esi,pSrcAddr       ;source offset in screen
        mov     edi,pDestAddr      ;point to destination start

        lodsb                   ;prime the rotation pipeline
        mov     ah,al           ;for combining with the next byte

        mov     edx,ulCombineMaskWhole
        mov     ebx,culWholeBytesWidth

;  AH = rotation pipeline-priming byte
;  EDX = mask to preserve desired portions of AH and AL before combining
;  ESI = source address to copy from
;  EDI = target address to copy to
;  Map Mask set to enable the desired plane for write
;  Bit Mask set to enable all bits

copy_whole_loop:
        lodsb                   ;get byte to copy
        mov     ch,al           ;set aside for next time
        and     eax,edx         ;mask the bytes in preparation for combining
                                ; and rotating them
        or      al,ah           ;combine them
        stosb                   ;write the composite byte
                                ; VGA rotates during write
        mov     ah,ch           ;prepare byte for combining next time

        dec     ebx
        jnz     copy_whole_loop

; Do next plane, if any.

        shr     cl,1                    ;advance to next plane
        jnz     copy_whole_plane_loop

; Remember where we left off, for next scan.

        add     edi,ulWholeScanDelta    ;point to next dest scan
        mov     pDestAddr,edi
        add     esi,ulWholeScanSrcDelta ;point to next source scan
        mov     pSrcAddr,esi

; Count down scan lines.

        dec     ulTempScanCount
        jnz     copy_whole_scan_loop

; Remember where we left off, for next time.

        mov     ecx,pdsurf
        sub     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     ulWholeBytesSrc,esi
        sub     edi,[ecx].dsurf_pvBitmapStart2WindowD
        mov     ulWholeBytesDest,edi

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a block of solid bytes from the source to the destination via
; the temp buffer. This should only be used by 1 R/W adapters, and then
; only when the source and dest are in different banks.
;
; All relevant bytes are first copied from the source to a temp buffer that's
; an image of the source. Then, we copy each of the four planes for one scan
; line from the temp buffer to the screen before going on to the next scan
; line. See ALIGNBLT.ASM for comments about why this is done.
;
; Input:
;       Direction Flag set for desired direction of copy
;       culWholeBytesWidth = # of bytes to copy across each scan line
;       ulWholeScanDelta = distance to start of next scan from end of current
;       ulNextScan = width of a scan line
;       ulBlockHeight = # of scans to copy
;       ulWholeBytesSrc = start source offset in bitmap
;       ulWholeBytesDest = start dest offset in bitmap
;       ppTempPlane0 = pointer to pointer to plane 0 storage in temp buffer
;       ppTempPlane3 = pointer to pointer to plane 3 storage in temp buffer
;       ulCombineMaskWhole = masking to be applied before ORing the two source
;               bytes together, to keep only the data needed in preparation
;               for the VGA rotator doing its stuff
;       Expects the source bank to be mapped in; source bank is mapped in on
;               exit
;
; Output:
;       Advances ulWholeBytesSrc and ulWholeBytesDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_whole_bytes_via_buffer::

; Calculate start source address from bitmap start address and offset within
; bitmap.

        mov     ecx,pdsurf
        mov     eax,ulWholeBytesSrc
        add     eax,[ecx].dsurf_pvBitmapStart
        mov     pSrcAddr,eax
        sub     eax,[ecx].dsurf_pvStart
        mov     ulOffsetInBank,eax ;will come in handy because we treat the
                                   ; temp buffer as an image of the current
                                   ; bank

; First, copy all the bytes into the temporary buffer.

; Leave the GC Index pointing to the Read Map.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     eax,3           ;start by copying plane 3
copy_whole_to_buffer_plane_loop:
        mov     ebx,ulBlockHeight  ;# of scans to copy
        mov     esi,pSrcAddr       ;source offset in screen
        mov     edi,ppTempPlane0
        mov     edi,[edi+eax*4]    ;pointer to current plane in temp buffer
        add     edi,ulOffsetInBank ;dest for plane in temp buffer

        mov     edx,VGA_BASE + GRAF_DATA
        out     dx,al            ;set Read Map to plane we're copying from.

        push    eax             ;remember plane index
        mov     eax,ulWholeScanSrcDelta ;offset to next scan
        mov     edx,culWholeBytesWidth ;# of bytes per scan
        inc     edx             ;always one more source byte than dest byte
copy_whole_to_buffer_scan_loop:
        mov     ecx,edx         ;# of bytes per scan
        rep     movsb           ;copy the scan line to the temp buffer
        add     esi,eax         ;point to next source scan
        add     edi,eax         ;point to next dest scan

        dec     ebx              ;count down scan lines
        jnz     copy_whole_to_buffer_scan_loop

        pop     eax             ;get back plane index
        dec     eax             ;count down planes
        jns     copy_whole_to_buffer_plane_loop

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     esi,[ebx].dsurf_pvBitmapStart
        mov     ulWholeBytesSrc,esi


; Now copy the temp buffer to the screen.

; Map in the destination bank, so we can read/write to it and let the Bit Mask
; work.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>, \
                <ebx,ulCurrentDestScan,ulCurrentJustification>

; Calculate dest start address (if this is a 1 R/W adapter, we had to wait
; until now to calculate this, because the dest bank wasn't mapped earlier).

        mov     eax,ulWholeBytesDest
        add     eax,[ebx].dsurf_pvBitmapStart
        mov     pDestAddr,eax

; Set the bit mask to enable all bits.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Set up to copy the whole bytes from the buffer.

        mov     eax,ulBlockHeight
        mov     ulTempScanCount,eax

copy_whole_from_buffer_scan_loop:

        mov     ebx,ppTempPlane3  ;point to plane 3's temp buffer offset
        mov     cl,MM_C3        ;start by copying plane 3

copy_whole_from_buffer_plane_loop:

; Set Map Mask to enable writes to the plane we're copying.

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,cl
        out     dx,al

; Select the corresponding plane from the temp buffer.

        mov     esi,[ebx]       ;point to plane start in temp buffer
        sub     ebx,4           ;point to next temp buffer plane ptr
        push    ebx             ;preserve pointer to plane pointer

        add     esi,ulOffsetInBank ;point to current scan start in temp buffer
        mov     edi,pDestAddr      ;point to destination start

        lodsb                   ;prime the rotation pipeline
        mov     ah,al           ;for combining with the next byte

        mov     edx,ulCombineMaskWhole
        mov     ebx,culWholeBytesWidth

;  AH = rotation pipeline-priming byte
;  EDX = mask to preserve desired portions of AH and AL before combining
;  ESI = source address to copy from
;  EDI = target address to copy to
;  Map Mask set to enable the desired plane for write
;  Bit Mask set to enable all bits

copy_whole_from_buffer_loop:
        lodsb                   ;get byte to copy
        mov     ch,al           ;set aside for next time
        and     eax,edx         ;mask the bytes in preparation for combining
                                ; and rotating them
        or      al,ah           ;combine them
        stosb                   ;write the composite byte
                                ; VGA rotates during write
        mov     ah,ch           ;prepare byte for combining next time

        dec     ebx
        jnz     copy_whole_from_buffer_loop

; Do next plane, if any.

        pop     ebx             ;retrieve pointer to plane pointer
        shr     cl,1            ;advance to next plane
        jnz     copy_whole_from_buffer_plane_loop

; Remember where we left off, for next scan.

        add     edi,ulWholeScanDelta    ;point to next dest scan
        mov     pDestAddr,edi
        mov     eax,ulNextScan
        add     ulOffsetInBank,eax      ;next scan's start in temp buffer,
                                        ; relative to start of plane's storage

; Count down scan lines.

        dec     ulTempScanCount
        jnz     copy_whole_from_buffer_scan_loop

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     edi,[ebx].dsurf_pvBitmapStart
        mov     ulWholeBytesDest,edi

; Put back the original source bank.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl>, \
                <ebx,ulCurrentSrcScan,ulCurrentJustification>

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of left edge bytes from the source to the destination,
; assuming both the source and the destination are both readable and
; writable. Can only be used by 2 R/W window banking, or by unbanked
; modes. 1 R/W and 1R/1W adapters must go through an intermediate local
; buffer when the source and dest are in different banks. Processes up to
; EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might cause
; flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulLeftEdgeSrc = start source offset in bitmap
;       ulLeftEdgeDest = start dest offset in bitmap
;       ulLeftSrcWidthMinus1 = width of left source edge minus 1 (0 or 1)
;       jLeftMask = left edge clip mask
;
; Output:
;       Advances ulLeftEdgeSrc and ulLeftEdgeDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_left_edge::

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulLeftEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     edi,ulLeftEdgeDest
        add     edi,[ecx].dsurf_pvBitmapStart2WindowD

; Copy the edge.

        mov     ah,byte ptr jLeftMask   ;clip mask for this edge
        mov     ebx,ulLeftSrcWidthMinus1
        call    copy_edge_table[ebx*4]

; Remember where we left off, for next time.

        mov     ecx,pdsurf
        sub     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     ulLeftEdgeSrc,esi
        sub     edi,[ecx].dsurf_pvBitmapStart2WindowD
        mov     ulLeftEdgeDest,edi

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of right edge bytes from the source to the destination,
; assuming both the source and the destination are both readable and
; writable. Can only be used by 2 R/W window banking, or by unbanked
; modes. 1 R/W and 1R/1W adapters must go through an intermediate local
; buffer when the source and dest are in different banks. Processes up to
; EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might cause
; flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulRightEdgeSrc = start source offset in bitmap
;       ulRightEdgeDest = start dest offset in bitmap
;       ulRightSrcWidthMinus1 = width of right source edge minus 1 (0 or 1)
;       jRightMask = right edge clip mask
;
; Output:
;       Advances ulRightEdgeSrc and ulRightEdgeDest to scan after last
;               scan processed
;-----------------------------------------------------------------------;

copy_right_edge::

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulRightEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     edi,ulRightEdgeDest
        add     edi,[ecx].dsurf_pvBitmapStart2WindowD

; Copy the edge.

        mov     ah,byte ptr jRightMask  ;clip mask for this edge
        mov     ebx,ulRightSrcWidthMinus1
        call    copy_edge_table[ebx*4]

; Remember where we left off, for next time

        mov     ecx,pdsurf
        sub     esi,[ecx].dsurf_pvBitmapStart2WindowS
        mov     ulRightEdgeSrc,esi
        sub     edi,[ecx].dsurf_pvBitmapStart2WindowD
        mov     ulRightEdgeDest,edi

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from a 1-wide source to the destination on the screen.
; Entry:
;       AH = bit mask setting for edge
;       ESI = source address
;       EDI = destination address
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source readable, and destination readable and writable
; Exit:
;       ESI = next source address
;       EDI = next destination address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_edge_1ws::
        mov     pSrcAddr,esi
        mov     pDestAddr,edi

; Set the clip mask for this edge.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_BIT_MASK
        out     dx,ax

; Leave the GC Index pointing to the Read Map.

        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     ecx,offset copy_edge_rw_1ws_full_chunk
                                ;entry point into unrolled loop to copy first
                                ; chunk, assuming it's a full chunk
        mov     ebx,ulBlockHeight

; Copy the edge in a series of chunks.

copy_edge_chunk_loop_1ws:

        sub     ebx,EDGE_CHUNK_SIZE ;scans remaining after this chunk, assuming
                                    ; a full chunk
        jge     short @F            ;do a full chunk
        add     ebx,EDGE_CHUNK_SIZE ;not a full chunk; process all remaining
                                    ; scans
        mov     ecx,pfnCopyEdgeRWEntry_1ws[-4][ebx*4]
                                ;entry point into unrolled loop to copy desired
                                ; chunk size
        sub     ebx,ebx         ;no scans after this
@@:
        push    ebx             ;remember remaining scan count

        mov     ah,MM_C3        ;start by copying plane 3
        mov     ebx,ulNextScan

copy_edge_plane_loop_1ws::

; Set Map Mask to enable writes to plane we're copying.

        mov     al,ah
        mov     dl,SEQ_DATA
        out     dx,al

; Set Read Map to same plane.

        shr     al,1                    ;map plane into ReadMask
        cmp     al,100b                 ;set Carry if not C3 (plane 3)
        adc     al,-1                   ;sub 1 only if C3
        mov     dl,GRAF_DATA
        out     dx,al

        mov     esi,pSrcAddr
        mov     edi,pDestAddr

        jmp     ecx                     ;copy the left edge


;-----------------------------------------------------------------------;
; Table of unrolled edge loop entry points. First entry point is to copy
; 1 byte, last entry point is to copy EDGE_CHUNK_SIZE bytes.
;-----------------------------------------------------------------------;

pfnCopyEdgeRWEntry_1ws label dword
INDEX = 1
        rept    EDGE_CHUNK_SIZE
        DEFINE_DD       EDGE_RW_1WS,%INDEX
INDEX = INDEX+1
        endm


;-----------------------------------------------------------------------;
; Unrolled loop for copying a strip of edge bytes, with 1-wide source and
; destination both readable and writable.
;-----------------------------------------------------------------------;

COPY_EDGE_RW_1WS macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     al,[esi]        ;get byte to copy
        add     esi,ebx         ;point to next source scan
        mov     dl,[edi]        ;read to load latches (value doesn't matter)
        mov     [edi],al        ;write, with the Bit Mask clipping
                                ; VGA rotates during write
        add     edi,ebx         ;point to next dest scan
        endm    ;-----------------------------------;

;  EBX = scan line width
;  ESI = source address to copy from
;  EDI = target address to copy to
;  Bit Mask set to desired clipping
;  Read Map and Map Mask set to enable the desired plane for read and write

copy_edge_rw_1ws_full_chunk:
        UNROLL_LOOP COPY_EDGE_RW_1WS,EDGE_RW_1WS,EDGE_CHUNK_SIZE

; Do next plane within this chunk, if any.

        shr     ah,1                    ;advance to next plane
        jnz     copy_edge_plane_loop_1ws

; Remember where we left off, for the next chunk.

        mov     pSrcAddr,esi
        mov     pDestAddr,edi

; Do next chunk within this bank block, if any.

        pop     ebx                     ;retrieve remaining scan count
        and     ebx,ebx                 ;any scans left?
        jnz     copy_edge_chunk_loop_1ws ;more scans to do

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of left edge bytes from the source to the destination
; through an intermediate RAM buffer. This is the approach required by
; 1 R/W and 1R/1W adapters when the source and dest are in different banks.
; Writes up to EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might
; cause flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulLeftEdgeSrc = start source offset in bitmap
;       ulLeftEdgeDest = start dest offset in bitmap
;       jLeftMask = left edge clip mask
;       pTempPlane = pointer to temp storage buffer
;       ulCurrentSrcScan = scan used to map in source bank
;       ulCurrentDestScan = scan used to map in dest bank
;       ulCurrentJustification = justification used to map in current bank
;       ulLeftSrcWidthMinus1 = width of left source edge minus 1 (0 or 1)
;       For 1 R/W adapters, expects the source bank to be mapped in; banking
;               is the same at exit as it was at entry
;
; Output:
;       Advances ulLeftEdgeSrc and ulLeftEdgeDest to scan after last
;               scan processed
;
; Note that this should never be called for an unbanked or 2 R/W adapter,
; because the source and dest are always both addressable simultaneously then.
;-----------------------------------------------------------------------;

copy_left_edge_via_buffer::

; First, copy all the bytes into the temporary buffer.

; Calculate start source and dest addresses from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulLeftEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS

; Copy the edge from the source to the temp buffer.

        mov     eax,ulLeftSrcWidthMinus1
        call    copy_edge_from_screen_to_buffer[eax*4]

; Remember where we left off, for next time

        mov     ebx,pdsurf
        sub     esi,[ebx].dsurf_pvBitmapStart2WindowS
        mov     ulLeftEdgeSrc,esi

; Now copy the temp buffer to the screen.

; Map in the source bank to match the destination, so we can read/write to it
; and let the Bit Mask work. Note that on a 1 R/W adapter, both banks will be
; mapped by this call, which is fine.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentDestScan,ulCurrentJustification,MapSourceBank>

; Calculate dest start address (if this is a 1 R/W adapter, we had to wait
; until now to calculate this, because the dest bank wasn't mapped earlier).

        mov     edi,ulLeftEdgeDest
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD

; Do the copy.

        mov     ah,byte ptr jLeftMask           ;clip mask for this edge
        mov     ebx,ulLeftSrcWidthMinus1
        call    copy_edge_from_buffer_to_screen[ebx*4]

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     edi,[ebx].dsurf_pvBitmapStart2WindowD
        mov     ulLeftEdgeDest,edi

; Put back the original source bank.  Note that on a 1 R/W adapter, both banks
; will be mapped by this call, which is fine.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentSrcScan,ulCurrentJustification,MapSourceBank>

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies a strip of right edge bytes from the source to the destination
; through an intermediate RAM buffer. This is the approach required by
; 1 R/W and 1R/1W adapters when the source and dest are in different banks.
; Writes up to EDGE_CHUNK_SIZE bytes in each plane at a pop; more bytes might
; cause flicker.
;
; Input:
;       ulNextScan = width of scan, in bytes
;       ulBlockHeight = # of scans to copy
;       ulRightEdgeSrc = start source offset in bitmap
;       ulRightEdgeDest = start dest offset in bitmap
;       jRightMask = right edge clip mask
;       pTempPlane = pointer to temp storage buffer
;       ulCurrentSrcScan = scan used to map in source bank
;       ulCurrentDestScan = scan used to map in dest bank
;       ulCurrentJustification = justification used to map in current bank
;       ulRightSrcWidthMinus1 = width of right source edge minus 1 (0 or 1)
;       For 1 R/W adapters, expects the source bank to be mapped in; banking
;               is the same at exit as it was at entry
;
; Output:
;       Advances ulRightEdgeSrc and ulRightEdgeDest to scan after last
;               scan processed
;
; Note that this should never be called for an unbanked or 2 R/W adapter,
; because the source and dest are always both addressable simultaneously then.
;-----------------------------------------------------------------------;

copy_right_edge_via_buffer::

; First, copy all the bytes into the temporary buffer.

; Calculate start source address from bitmap start addresses and
; offsets within bitmap.

        mov     ecx,pdsurf
        mov     esi,ulRightEdgeSrc
        add     esi,[ecx].dsurf_pvBitmapStart2WindowS

; Copy the edge from the source to the temp buffer.

        mov     eax,ulRightSrcWidthMinus1
        call    copy_edge_from_screen_to_buffer[eax*4]

; Remember where we left off, for next time

        mov     ebx,pdsurf
        sub     esi,[ebx].dsurf_pvBitmapStart2WindowS
        mov     ulRightEdgeSrc,esi

; Now copy the temp buffer to the screen.

; Map in the source bank to match the destination, so we can read/write to it
; and let the Bit Mask work. Note that on a 1 R/W adapter, both banks will be
; mapped by this call, which is correct.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentDestScan,ulCurrentJustification,MapSourceBank>

; Calculate dest start address (if this is a 1 R/W adapter, we had to wait
; until now to calculate this, because the dest bank wasn't mapped earlier).

        mov     edi,ulRightEdgeDest
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD

; Do the copy.

        mov     ah,byte ptr jRightMask          ;clip mask for this edge
        mov     ebx,ulRightSrcWidthMinus1
        call    copy_edge_from_buffer_to_screen[ebx*4]

; Remember where we left off, for next time.

        mov     ebx,pdsurf
        sub     edi,[ebx].dsurf_pvBitmapStart2WindowD
        mov     ulRightEdgeDest,edi

; Put back the original source bank.  Note that on a 1 R/W adapter, both banks
; will be mapped by this call, which is fine.

        ptrCall   <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,ulCurrentSrcScan,ulCurrentJustification,MapSourceBank>

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the temp buffer (1 wide) to the screen.
; Entry:
;       AH = bit mask setting for edge
;       EDI = destination address
;       pTempPlane = temp buffer from which to copy
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source and dest banks both pointing to destination
; Exit:
;       EDI = next destination address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_buffered_edge_to_screen_1ws::

        mov     pDestAddr,edi

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_BIT_MASK
        out     dx,ax

        mov     pTempEntry,offset copy_edge_from_buf_full_chunk_1ws
                                ;entry point into unrolled loop to copy first
                                ; chunk, assuming it's a full chunk
        mov     ecx,pTempPlane  ;temp buffer start (copy from here)
        mov     ebx,ulBlockHeight ;total # of scans to copy

; Copy the edge in a series of chunks, to avoid flicker.

copy_from_buffer_chunk_loop_1ws:

        sub     ebx,EDGE_CHUNK_SIZE ;scans remaining after this chunk, assuming
                                    ; a full chunk
        jge     short @F            ;do a full chunk
        add     ebx,EDGE_CHUNK_SIZE ;not a full chunk; process all remaining
                                    ; scans
        mov     ebx,pfnCopyEdgesFromBufferEntry_1ws[-4][ebx*4]
        mov     pTempEntry,ebx  ;entry point into unrolled loop to copy desired
                                ; chunk size
        sub     ebx,ebx         ;no scans after this
@@:
        push    ebx             ;remember remaining scan count

        mov     al,MM_C3        ;start by copying plane 3
        mov     ebx,ulNextScan

        push    ecx             ;remember current temp buffer start

copy_from_buffer_plane_loop_1ws:

; Set Map Mask to enable writes to plane we're copying.

        mov     dl,SEQ_DATA     ;leave DX pointing to the Sequencer Data reg
        out     dx,al

        mov     esi,ecx                 ;point to current plane's source byte
        add     ecx,ulBlockHeight       ;point to next plane's source byte

        mov     edi,pDestAddr

        jmp     pTempEntry              ;copy the left edge


;-----------------------------------------------------------------------;
; Table of unrolled edge copy-from-buffer loop entry points. First entry
; point is to copy 1 byte, last entry point is to copy EDGE_CHUNK_SIZE
; bytes.
;-----------------------------------------------------------------------;

pfnCopyEdgesFromBufferEntry_1ws label dword
INDEX = 1
        rept    EDGE_CHUNK_SIZE
        DEFINE_DD       EDGE_FROM_BUFFER_1WS,%INDEX
INDEX = INDEX+1
        endm


;-----------------------------------------------------------------------;
; Unrolled loop for copying a strip of edge bytes (1 wide) from the temp
; buffer.
;-----------------------------------------------------------------------;

COPY_EDGE_FROM_BUFFER_1WS macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     ah,[esi]        ;get byte to copy
        inc     esi             ;point to next source (temp buffer) byte
        mov     dl,[edi]        ;read to load latches (value doesn't matter)
        mov     [edi],ah        ;write, with the Bit Mask clipping
                                ; VGA rotates during write
        add     edi,ebx         ;point to next dest (screen) scan
        endm    ;-----------------------------------;

;  EBX = scan line width
;  ESI = source address to copy from (temp buffer)
;  EDI = target address to copy to (screen)
;  Bit Mask set to desired clipping
;  Map Mask set to enable the desired plane for write

copy_edge_from_buf_full_chunk_1ws:
        UNROLL_LOOP     COPY_EDGE_FROM_BUFFER_1WS, \
                        EDGE_FROM_BUFFER_1WS,EDGE_CHUNK_SIZE

; Do next plane within this chunk, if any.

        shr     al,1                    ;advance to next plane
        jnz     copy_from_buffer_plane_loop_1ws

; Remember where we left off, for next chunk.

        mov     pDestAddr,edi
        pop     ecx                     ;get back current temp buffer start
        add     ecx,EDGE_CHUNK_SIZE     ;point to next chunk's start

; Do next chunk within this bank block, if any.

        pop     ebx                     ;retrieve remaining scan count
        and     ebx,ebx                 ;any scans left?
        jnz     copy_from_buffer_chunk_loop_1ws ;more scans to do

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the screen (1 wide) to the temp buffer.
; Entry:
;       ESI = source address
;       pTempPlane = temp buffer from which to copy
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source bank pointing to source
; Exit:
;       DH = VGA_BASE SHR 8
;       ESI = next source address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_screen_to_buffered_edge_1ws::

        mov     pSrcAddr,esi

; Leave the GC Index pointing to the Read Map.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     ecx,ulNextScan
        mov     edi,pTempPlane  ;dest offset in temp buffer for plane 3 bytes.
                                ;The rest of the planes are stored
                                ; consecutively
        mov     al,3            ;start by copying plane 3
        mov     dl,GRAF_DATA    ;leave DX pointing to the GC Data reg
copy_edge_to_buffer_plane_loop_1ws:
        mov     esi,pSrcAddr ;source pointer

        out     dx,al            ;set Read Map to plane we're copying from.

        mov     ebx,ulBlockHeight

;  EBX = count of unrolled loop iterations
;  ECX = offset from end of one scan's fill to start of next
;  ESI = source address to copy from (screen)
;  EDI = target address to copy to (temp buffer)
;  Read Map set to enable the desired plane for read

edge_to_buffer_loop_1ws:
        mov     ah,[esi]        ;get byte to copy
        add     esi,ecx         ;point to next source scan
        mov     [edi],ah        ;copy byte to temp buffer
        inc     edi             ;point to next temp buffer byte

        dec     ebx
        jnz     edge_to_buffer_loop_1ws

        dec     al              ;count down planes
        jns     copy_edge_to_buffer_plane_loop_1ws

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from a 2-wide source to the destination on the screen.
; Entry:
;       AH = bit mask setting for edge
;       ESI = source address
;       EDI = destination address
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       ulCombineMask = masking to be applied before ORing the two source
;               bytes together, to keep only the data needed in preparation
;               for the VGA rotator doing its stuff
;       Source readable, and destination readable and writable
; Exit:
;       ESI = next source address
;       EDI = next destination address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_edge_2ws::
        mov     pSrcAddr,esi
        mov     pDestAddr,edi

; Set the clip mask for this edge.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_BIT_MASK
        out     dx,ax

; Leave the GC Index pointing to the Read Map.

        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     ebx,ulBlockHeight

        mov     ecx,offset copy_edge_rw_2ws_full_chunk
                                ;entry point into unrolled loop assuming we do
                                ; a full chunk the first time

; Copy the edge in a series of chunks.

copy_edge_chunk_loop_2ws:

        sub     ebx,EDGE_CHUNK_SIZE ;scans remaining after this chunk, assuming
                                    ; a full chunk
        jge     short @F            ;do a full chunk
        add     ebx,EDGE_CHUNK_SIZE ;not a full chunk; process all remaining
                                    ; scans
        mov     ecx,pfnCopyEdgeRWEntry_2ws[-4][ebx*4]
                                ;entry point into unrolled loop to copy desired
                                ; chunk size
        sub     ebx,ebx         ;no scans after this
@@:
        push    ebx             ;remember remaining scan count

        mov     eax,(MM_C3 SHL 8) + 3 ;start by copying plane 3
        mov     ebx,ulNextScan

copy_edge_plane_loop_2ws:

        push    eax                     ;preserve plane info

; Set Read Map to enable reads from plane we're copying from.

        mov     edx,VGA_BASE + GRAF_DATA
        out     dx,al

; Set Map Mask to enable writes to plane we're copying.

        mov     dl,SEQ_DATA
        mov     al,ah
        out     dx,al

        mov     esi,pSrcAddr
        mov     edi,pDestAddr
        mov     edx,ulCombineMask

        jmp     ecx                     ;copy the left edge


;-----------------------------------------------------------------------;
; Table of unrolled edge loop entry points. First entry point is to copy
; 1 byte, last entry point is to copy EDGE_CHUNK_SIZE bytes.
;-----------------------------------------------------------------------;

pfnCopyEdgeRWEntry_2ws label dword
INDEX = 1
        rept    EDGE_CHUNK_SIZE
        DEFINE_DD       EDGE_RW_2WS,%INDEX
INDEX = INDEX+1
        endm


;-----------------------------------------------------------------------;
; Unrolled loop for copying a strip of edge bytes, with 2-wide source and
; destination both readable and writable.
;-----------------------------------------------------------------------;

COPY_EDGE_RW_2WS macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     ax,[esi]        ;get word to copy
        add     esi,ebx         ;point to next source scan
        and     eax,edx         ;mask in preparation for combining bytes
        or      al,ah           ;combine the desired parts of the bytes
        mov     ah,[edi]        ;read to load latches (value doesn't matter)
        mov     [edi],al        ;write, with the Bit Mask clipping
                                ; VGA rotates during write
        add     edi,ebx         ;point to next dest scan
        endm    ;-----------------------------------;

;  EBX = scan line width
;  EDX = mask to preserve desired portions of AH and AL before combining
;  ESI = source address to copy from
;  EDI = target address to copy to
;  Bit Mask set to desired clipping
;  Read Map and Map Mask set to enable the desired plane for read and write

copy_edge_rw_2ws_full_chunk:
        UNROLL_LOOP COPY_EDGE_RW_2WS,EDGE_RW_2WS,EDGE_CHUNK_SIZE

; Do next plane within this chunk, if any.

        pop     eax                     ;retrieve plane info

        shr     ah,1                    ;advance to next plane
        dec     eax                     ;count down planes
        jns     copy_edge_plane_loop_2ws

; Remember where we left off, for the next chunk.

        mov     pSrcAddr,esi
        mov     pDestAddr,edi

; Do next chunk within this bank block, if any.

        pop     ebx                     ;retrieve remaining scan count
        and     ebx,ebx                 ;any scans left?
        jnz     copy_edge_chunk_loop_2ws ;more scans to do

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the temp buffer (2 wide) to the screen.
; Entry:
;       AH = bit mask setting for edge
;       EDI = destination address
;       pTempPlane = temp buffer from which to copy
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source and dest banks both pointing to destination
;       ulCombineMask = masking to be applied before ORing the two source
;               bytes together, to keep only the data needed in preparation
;               for the VGA rotator doing its stuff
; Exit:
;       EDI = next destination address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_buffered_edge_to_screen_2ws::

        mov     pDestAddr,edi

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_BIT_MASK
        out     dx,ax

        mov     pTempEntry,offset copy_edge_from_buf_full_chunk_2ws
                                ;entry point into unrolled loop, assuming the
                                ; first chunk is full size
        mov     ecx,pTempPlane  ;temp buffer start (copy from here)
        mov     ebx,ulBlockHeight

; Copy the edge in a series of chunks, to avoid flicker.

copy_from_buffer_chunk_loop_2ws:

        sub     ebx,EDGE_CHUNK_SIZE ;scans remaining after this chunk, assuming
                                    ; a full chunk
        jge     short @F            ;do a full chunk
        add     ebx,EDGE_CHUNK_SIZE ;not a full chunk; process all remaining
                                    ; scans
        mov     ebx,pfnCopyEdgesFromBufferEntry_2ws[-4][ebx*4]
        mov     pTempEntry,ebx  ;entry point into unrolled loop to copy final
                                ; chunk size
        sub     ebx,ebx         ;no scans after this
@@:
        push    ebx             ;remember remaining scan count

        mov     al,MM_C3        ;start by copying plane 3
        mov     ebx,ulNextScan

        push    ecx             ;remember current temp buffer start

copy_from_buffer_plane_loop_2ws:

; Set Map Mask to enable writes to plane we're copying.

        mov     edx,VGA_BASE + SEQ_DATA
        out     dx,al

        push    eax                     ;preserve plane info

        mov     esi,ecx                 ;point to current plane's source word
        mov     eax,ulBlockHeight
        lea     ecx,[ecx+eax*2]         ;point to next plane's source word

        mov     edi,pDestAddr
        mov     edx,ulCombineMask

        jmp     pTempEntry              ;copy the left edge


;-----------------------------------------------------------------------;
; Table of unrolled edge copy-from-buffer loop entry points. First entry
; point is to copy 1 byte, last entry point is to copy EDGE_CHUNK_SIZE
; bytes.
;-----------------------------------------------------------------------;

pfnCopyEdgesFromBufferEntry_2WS label dword
INDEX = 1
        rept    EDGE_CHUNK_SIZE
        DEFINE_DD       EDGE_FROM_BUFFER_2WS,%INDEX
INDEX = INDEX+1
        endm


;-----------------------------------------------------------------------;
; Unrolled loop for copying a strip of edge bytes (1 wide) from the temp
; buffer.
;-----------------------------------------------------------------------;

COPY_EDGE_FROM_BUFFER_2WS macro ENTRY_LABEL,ENTRY_INDEX
&ENTRY_LABEL&ENTRY_INDEX&:
        mov     ax,[esi]        ;get word to copy
        add     esi,2           ;point to next source (temp buffer) word
        and     eax,edx         ;mask in preparation for combining bytes
        or      al,ah           ;combine the desired parts of the bytes
        mov     ah,[edi]        ;latch the destination (value doesn't matter)
        mov     [edi],al        ;write, with the Bit Mask clipping
                                ; VGA rotates during write
        add     edi,ebx         ;point to next dest (screen) scan
        endm    ;-----------------------------------;

;  EBX = scan line width
;  EDX = mask to preserve desired portions of AH and AL before combining
;  ESI = source address to copy from (temp buffer)
;  EDI = target address to copy to (screen)
;  Bit Mask set to desired clipping
;  Map Mask set to enable the desired plane for write

copy_edge_from_buf_full_chunk_2ws:
        UNROLL_LOOP     COPY_EDGE_FROM_BUFFER_2WS, \
                        EDGE_FROM_BUFFER_2WS,EDGE_CHUNK_SIZE

; Do next plane within this chunk, if any.

        pop     eax                     ;retrieve plane info
        shr     al,1                    ;advance to next plane
        jnz     copy_from_buffer_plane_loop_2ws

; Remember where we left off, for next chunk.

        mov     pDestAddr,edi
        pop     ecx                     ;get back current temp buffer start
        add     ecx,EDGE_CHUNK_SIZE*2   ;point to next chunk's start word

; Do next chunk within this bank block, if any.

        pop     ebx                     ;retrieve remaining scan count
        and     ebx,ebx                 ;any scans left?
        jnz     copy_from_buffer_chunk_loop_2ws ;more scans to do

        PLAIN_RET


;-----------------------------------------------------------------------;
; Copies an edge from the screen (2 wide) to the temp buffer.
; Entry:
;       ESI = source address
;       pTempPlane = temp buffer from which to copy
;       ulBlockHeight = # of bytes to copy per plane
;       ulNextScan = scan width
;       Source bank pointing to source
; Exit:
;       ESI = next source address
;
; Preserved: EBP
;-----------------------------------------------------------------------;

copy_screen_to_buffered_edge_2ws::

        mov     pSrcAddr,esi

; Leave the GC Index pointing to the Read Map.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

        mov     ecx,ulNextScan
        mov     edi,pTempPlane  ;dest offset in temp buffer for plane 3 bytes.
                                ;The rest of the planes are stored
                                ; consecutively
        mov     eax,3           ;start by copying plane 3
copy_edge_to_buf_pl_loop_2ws:
        mov     esi,pSrcAddr    ;source pointer

        mov     edx,VGA_BASE + GRAF_DATA
        out     dx,al           ;set Read Map to plane from which we're copying

        mov     ebx,ulBlockHeight

;  EBX = count of unrolled loop iterations
;  ECX = offset from end of one scan's fill to start of next
;  ESI = source address to copy from (screen)
;  EDI = target address to copy to (temp buffer)
;  Read Map set to enable the desired plane for read

edge_to_buffer_loop_2ws:
        mov     dx,[esi]        ;get byte to copy
        add     esi,ecx         ;point to next source scan
        mov     [edi],dx        ;copy byte to temp buffer
        add     edi,2           ;point to next temp buffer byte

        dec     ebx
        jnz     edge_to_buffer_loop_2ws

        dec     eax              ;count down planes
        jns     copy_edge_to_buf_pl_loop_2ws

        PLAIN_RET


;-----------------------------------------------------------------------;

endProc vNonAlignedSrcCopy

_TEXT$04   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\lines.inc ===
;---------------------------- Include File Header ---------------------------;
; lines.inc
;
; Line drawing constants and structures.
;
; NOTE: This file mirrors LINES.H.  Changes here must be reflected in
; the .h file!
;
;----------------------------------------------------------------------------;

STYLE_MAX_COUNT         equ 16
STYLE_MAX_VALUE         equ 3fffh
RUN_MAX                 equ 20
STRIP_MAX               equ 100
STYLE_DENSITY           equ 3

; Flip and round flags:

FL_H_ROUND_DOWN         equ 00000080h
FL_V_ROUND_DOWN         equ 00008000h

FL_FLIP_D               equ 00000005h
FL_FLIP_V               equ 00000008h
FL_FLIP_SLOPE_ONE       equ 00000010h
FL_FLIP_HALF            equ 00000002h
FL_FLIP_H               equ 00000200h

FL_ROUND_MASK           equ 0000001ch
FL_ROUND_SHIFT          equ 2

FL_RECTLCLIP_MASK       equ 0000000ch
FL_RECTLCLIP_SHIFT      equ 2

FL_STRIP_MASK           equ 00000003h
FL_STRIP_SHIFT          equ 0

FL_SIMPLE_CLIP          equ 00000020h
FL_COMPLEX_CLIP         equ 00000040h
FL_CLIP                 equ (FL_SIMPLE_CLIP + FL_COMPLEX_CLIP)

FL_ARBITRARYSTYLED      equ 00000400h
FL_MASKSTYLED           equ 00000800h
FL_STYLED               equ (FL_ARBITRARYSTYLED + FL_MASKSTYLED)
FL_ALTERNATESTYLED      equ 00001000h

FL_STYLE_MASK           equ 00000C00h
FL_STYLE_SHIFT          equ 10

; Simple flag bits in high byte:

FL_DONT_DO_HALF_FLIP    equ 00002000h
FL_PHYSICAL_DEVICE      equ 00004000h

; Miscellaneous DDA defines:

F                       equ 16
FLOG2                   equ 4

STRIPS struc

; Updated by strip drawers:

    ST_pjScreen         dd  ?
    ST_jBitMask	        db  ?
    ST_jFiller1         db  3 dup(?) ; jBitMask sometimes treated as a dword
    ST_jStyleMask       db  ?
    ST_jFiller2         db  3 dup(?) ; jStyleMask sometimes treated as a dword

    ST_psp              dd  ?
    ST_spRemaining      dd  ?

; Not modified by strip drawers:

    ST_lNextScan        dd  ?
    ST_plStripEnd       dd  ?       ; usually won't be valid
    ST_flFlips          dd  ?
    ST_pspStart         dd  ?
    ST_pspEnd           dd  ?
    ST_ulBitmapROP      dd  ?
    ST_xyDensity        dd  ?

; We leave room for a couple of extra dwords at the end of the strips
; array that can be used by the strip drawers:

    ST_alStrips	        dd  (STRIP_MAX + 2) dup (?)
STRIPS ends

LINESTATE struc
    LS_spTotal          dd  ?
    LS_spTotal2         dd  ?
    LS_spNext           dd  ?
    LS_spComplex        dd  ?

    LS_aspRtoL          dd  ?
    LS_aspLtoR          dd  ?

    LS_xyDensity        dd  ?
    LS_cStyle           dd  ?

    LS_ulStyleMaskLtoR  dd  ?
    LS_ulStyleMaskRtoL  dd  ?

    LS_jStartMask       db  ?
    LS_filler3          db  3 dup (?)

    LS_apfnStrip        dd  ?

; Used for 2 pass ROPs and/or DFBs:

    LS_iColor           dd  ?
    LS_ulVgaMode        dd  ?

    LS_ulDrawModeIndex  dd  ?
    LS_ulBitmapROP      dd  ?
    LS_lNextPlane       dd  ?
LINESTATE ends

RUN struc
    RUN_iStart          dd  ?
    RUN_iStop           dd  ?
RUN ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\patblt.asm ===
;-----------------------------------------------------------------------;

; This delay is necessitated by a bug in the ATI Ultra when running in
; VGA mode.

SLOW_OUT macro
        push    ecx
        pop     ecx
        out     dx,ax
        endm

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\ropdefs.inc
        include i386\display.inc         ; Display specific structures

        .list

;-----------------------------------------------------------------------;

        .data

;
; We share some tables with vgablts.asm
;

extrn   jALUFuncTable :byte
extrn   jLeftMask  :byte
extrn   jRightMask :byte
extrn   jForceOnTable :byte
extrn   jNotTable :byte
extrn   jInvertDest :byte
extrn   jForceOffTable :byte
extrn   vTrgBlt@20 :dword

;-----------------------------------------------------------------------;
; Table of routines to be called to draw edges, according to which edges are
; partial and which edges are whole bytes.
        align   4
        public pfnEdgeDrawing
pfnEdgeDrawing  label   dword
        dd      edge_byte_setup
        dd      edge_byte_setup
        dd      check_next_bank
        dd      edge_byte_setup

;-----------------------------------------------------------------------;
; Table of pointers to wide whole byte drawing loops.

        align   4
        public pfnWideWholeRep
pfnWideWholeRep label   dword
        dd      draw_wide_00_loop
        dd      draw_wide_01_loop
        dd      draw_wide_10_loop
        dd      draw_wide_11_loop

;-----------------------------------------------------------------------;
; Table of pointers to replace whole byte drawing loops.

; Note: The breakpoint where one should switch from special-casing to
;  REP STOS is purely a guess on my part. 8 seemed reasonable.

; Start address MOD 2 is 0.
        align   4
        public pfnWholeBytesMod0Entries
pfnWholeBytesMod0Entries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_even_loop
        dd      draw_2_wide_even_loop
        dd      draw_3_wide_even_loop
        dd      draw_4_wide_even_loop
        dd      draw_5_wide_even_loop
        dd      draw_6_wide_even_loop
        dd      draw_7_wide_even_loop
        dd      draw_8_wide_even_loop
MAX_REPLACE_SPECIAL equ     ($-pfnWholeBytesMod0Entries)/4

; Start address MOD 2 is 1.
        align   4
        public pfnWholeBytesMod1Entries
pfnWholeBytesMod1Entries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_odd_loop
        dd      draw_2_wide_odd_loop
        dd      draw_3_wide_odd_loop
        dd      draw_4_wide_odd_loop
        dd      draw_5_wide_odd_loop
        dd      draw_6_wide_odd_loop
        dd      draw_7_wide_odd_loop
        dd      draw_8_wide_odd_loop


;-----------------------------------------------------------------------;
; Table of pointers to non-replace whole byte drawing loops.

; Note: The breakpoint where one should switch from special-casing to
;  REP MOVSB is purely a guess on my part. 5 seemed reasonable.

        align   4
pfnWholeBytesNonReplace  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_rop_loop
        dd      draw_2_wide_rop_loop
        dd      draw_3_wide_rop_loop
        dd      draw_4_wide_rop_loop
MAX_NON_REPLACE_SPECIAL equ     ($-pfnWholeBytesNonReplace)/4

; Master MOD 2 alignment look-up table for entry tables for two possible
; alignments for narrow, special-cased replace whole byte drawing loops.
        align   4
        public pfnWholeBytesSpecial
pfnWholeBytesSpecial      label   dword
        dd      pfnWholeBytesMod0Entries
        dd      pfnWholeBytesMod1Entries

        .code

;=============================================================================

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cProc   vMonoPatBlt,24,<    \
        uses esi edi ebx, \
        pdsurf: ptr DEVSURF, \
        culRcl: dword,       \
        prcl:   ptr RECTL,   \
        ulMix:  dword,       \
        pBrush: ptr oem_brush_def, \
        pBrushOrg: ptr POINTL >

        local   ulRowOffset :dword      ;Offset from start of scan line
                                        ; first byte to fill
        local   ulWholeBytes :dword     ;# of whole bytes to fill
        local   ulWholeWords :dword     ;# of whole words to fill excluding
                                        ;leading and/or trailing bytes
        local   pfnWholeFn  :dword      ;pointer to routine used to draw
                                        ; whole bytes
        local   ulScanWidth :dword      ;offset from start of one scan to start
                                        ; of next
        local   ulNextScan  :dword      ;offset from end of one scan line's
                                        ; fill to start of next
        local   ulCurrentTopScan :dword ;top scan line to fill in current bank
        local   ulMasks     :dword      ;low byte = right mask, high byte =
                                        ; left mask
        local   ulBottomScan :dword     ;bottom scan line of fill rectangle

        local   jALUFunc   :dword       ;VGA ALU logical operation (SET, AND,
                                        ; OR, or XOR)
        local   pfnStartDrawing :dword  ;pointer to function to call to start
                                        ; drawing
        local   pfnContinueDrawing :dword ;pointer to function to call to
                                        ; continue drawing after doing whole
                                        ; bytes
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial
        local   pfnWholeBytes :dword    ;pointer to whole byte filling loop
        local   ulSpecialBytes          ;If we are doing a special case wide
                                        ; fill, this will be the width of the
                                        ; fill. We need this so we can properly
                                        ; increment to the next line.
        local   ulVbNextScan :dword     ;Offset from the end of the current
                                        ; wide fill drawing operation to the
                                        ; top of the next venetian blind line
        local   fdInvertDestFirst :dword;1 if the rop requires a pass to invert
                                        ; the destination before the normal
                                        ; pass

        local   ulPatternOrgY: dword    ;Local copy of the pattern offset Y

        local   ulVbBlindCount :dword   ;Temp Height of pattern.

        local   ulVbTopScan :dword      ;slats in our blinds

        local   ulVbStartScan :dword    ;Current to slat

        local   pUlVbPattern:dword      ;inner loop pattern pointer

        local   pUlPattern:dword        ;current pattern with proper Y offset

        local   ulVbMask                ;Inversion mask for partial edges

        local   ulVbYRound              ;

        local   ulVbYShift              ;

        local   RotatedPat[32]:byte     ;Aligned pattern buffer

        local   ulFgClr:dword           ;Local copy of the foreground color

        local   ulBkClr:dword           ;Local copy of the background color

        local   pfnWesTrick:dword       ;Pointer to the desired inner loop
                                        ; wes trick code. While we are doing
                                        ; a ROP to full bytes, this will point
                                        ; to do_wide_wes_trick otherwise it
                                        ; will point to do_edge_wes_trick for
                                        ; the edge cases
        cld

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     culRcl,0                ;any rects to fill?
        jz      vMonoPatBlts_done         ;no, we're done

        mov     esi,pBrush              ;point to the brush

        xor     eax,eax
        mov     al,[esi + oem_brush_fg]
        mov     ulFgClr,eax             ;Make local copy of the fg color

        mov     al,[esi + oem_brush_bg]
        mov     ulBkClr,eax             ;Make local copy of the bk color

;-----------------------------------------------------------------------;
; Set up for the desired raster op.
;-----------------------------------------------------------------------;
        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      vMonoPatBlts_done       ;yes, we're done
        sub     eax,eax                 ;we want a dword
        mov     al,jInvertDest[ebx]     ;remember whether we need to invert the
        mov     fdInvertDestFirst,eax   ; destination before finishing the rop
        mov     eax,ulFgClr
        and     al,jForceOffTable[ebx]  ;force color to 0 if necessary
                                        ; (R2_BLACK)
        or      al,jForceOnTable[ebx]   ;force color to 0ffh if necessary
                                        ; (R2_WHITE, R2_NOT)
        xor     al,jNotTable[ebx]       ;invert color if necessary (any Pn mix)
                                        ;at this point, CH has the color we
                                        ; want to draw with; set up the VGA
                                        ; hardware to draw with that color
        mov     ulFgClr,eax

        mov     eax,ulBkClr
        and     al,jForceOffTable[ebx]  ;force color to 0 if necessary
                                        ; (R2_BLACK)
        or      al,jForceOnTable[ebx]   ;force color to 0ffh if necessary
                                        ; (R2_WHITE, R2_NOT)
        xor     al,jNotTable[ebx]       ;invert color if necessary (any Pn mix)
                                        ;at this point, CH has the color we
                                        ; want to draw with; set up the VGA
                                        ; hardware to draw with that color
        mov     ulBkClr,eax

        mov     ah,jALUFuncTable[ebx]   ;get the ALU logical function
        and     ah,ah                   ;is the logical function DR_SET?
        .errnz  DR_SET
        jz      short skip_ALU_set      ;yes, don't have to set because that's
                                        ; the VGA's default state
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        SLOW_OUT                        ;set the ALU logical function
skip_ALU_set:
        mov     byte ptr jALUFunc,ah    ;remember the ALU logical function

;-----------------------------------------------------------------------;
; Set up variables that are constant for the entire time we're in this
; module.
;-----------------------------------------------------------------------;
        mov     edx,pBrushOrg           ;point to the brush origin

        mov     ecx,[edx].ptl_x
        and     ecx,15                  ;eax mod 16

        mov     eax,[edx].ptl_y
        mov     ulPatternOrgY,eax

        ;We are now going to make a copy of our rotated copy of our pattern.
        ;The reason that we do this is because we may be called with several
        ;rectangles and we don't really want to rotate the pattern data for
        ;each rectangle. We copy this rectangle to be double high so that
        ;we can incorperate our Y offest later without having to worry
        ;about running off the end of the pattern.

        lea     edi,RotatedPat          ;Pattern Dest
        mov     esi,[esi + oem_brush_pmono] ;Pattern Src
        or      cl,cl
        jnz     rotate_and_expand

INDEX=0
        rept    4                       ;patterns are 16x8
        mov     eax,[esi+INDEX]
        mov     [edi+INDEX],eax
        mov     [edi+16+INDEX],eax
INDEX=INDEX+4
        endm    ;-----------------
        jmp     fill_rect_loop

rotate_and_expand:
INDEX=0
        rept    8                       ;patterns are 16x8
        mov     ah,[esi+INDEX]          ;load bytes for shift
        mov     al,[esi+1+INDEX]        ;convert from little to big endian
        ror     ax,cl                   ;shift into position
        mov     [edi+INDEX],ah          ;save result
        mov     [edi+1+INDEX],al
        mov     [edi+16+INDEX],ah       ;save result to second copy
        mov     [edi+17+INDEX],al
INDEX=INDEX+2
        endm    ;-----------------


fill_rect_loop:
;-----------------------------------------------------------------------;
; Set up masks and widths.
;-----------------------------------------------------------------------;
        mov     edi,prcl                ;point to rectangle to fill

        sub     eax,eax
        mov     ulLeftEdgeAdjust,eax    ;initalize variable
        mov     ulSpecialBytes,eax      ;initalize variable

        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;remember the bottom scan line of fill

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,0111b               ;intrabyte address of right edge
        mov     ah,jRightMask[ecx]      ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,3                   ;/8 for start offset from left edge
                                        ; of scan line
        mov     ulRowOffset,ecx         ;remember offset from start of scan
                                        ; line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,0111b               ;intrabyte address of left edge
        mov     al,jLeftMask[esi]       ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,3                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count and clear the first byte mask, because we can handle solid
; edge bytes faster as part of the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
        mov     ah,0                    ;
        add     ecx,2                   ;bit 1 of ECX=0 if right edge partial,
                                        ; 1 if whole;
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
save_masks:
        mov     ulMasks,eax             ;save left and right clip masks
        mov     ulWholeBytes,ebx        ;save # of whole bytes

        mov     ecx,pfnEdgeDrawing[ecx*4] ;set address of routine to draw
        mov     pfnContinueDrawing,ecx    ; all partial (non-whole) edges

        and     ebx,ebx                 ;any whole bytes?
        jz      start_vec_set           ;no
                                        ;yes, so draw the whole bytes before
                                        ; the edge bytes

; The whole bytes loop depends on the type of operation being done. If the
; operation is one which uses DR_SET, then we can use a STOS-type operation,
; else we have to use a MOVSB-type operation (to load the latches with the
; existing contents of display memory to allow the ALUs to work).
        cmp     byte ptr jALUFunc,DR_SET ;is it a replace-type rop?
        jz      short is_replace_type   ;yes
                                        ;no, set up for non-replace whole bytes
        mov     ecx,offset non_replace_wide

        cmp     ebx,MAX_NON_REPLACE_SPECIAL ;too wide to special case?
        jb      short non_replace_spec     ;nope

        mov     pfnWholeBytes,offset draw_wide_rop_loop
                                        ;assume too wide to special-case
        jmp     short start_vec_set

non_replace_spec:

        mov     eax,pfnWholeBytesNonReplace[ebx*4] ;no, point to entry
        mov     pfnWholeBytes,eax       ; table for width
        mov     ulSpecialBytes,ebx
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment

        jmp     short start_vec_set

is_replace_type:                        ;set up for replace-type rop
        cmp     ebx,MAX_REPLACE_SPECIAL ;too wide to special case?
        jnb     short is_wide_replace   ;yes

        mov     ulSpecialBytes,ebx
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        and     ecx,01b                 ;left edge whole bytes start alignment
                                        ; MOD 2
        mov     ecx,pfnWholeBytesSpecial[ecx*4] ;look up table of entry
                                                      ; tables for alignment
        mov     ecx,[ecx+ebx*4]         ;look up entry table for width
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_rep_wide

        jmp     short start_vec_set

is_wide_replace:                        ;set up for wide replace-type op
                                        ;Note: assumes there is at least one
                                        ; full word involved!
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        neg     ecx
        and     ecx,01b
        mov     edx,ebx
        sub     edx,ecx                 ;ignore odd leading bytes
        mov     eax,edx
        shr     edx,1                   ;# of whole words across (not counting
                                        ; odd leading & trailing bytes)
        mov     ulWholeWords,edx
        and     eax,01b                 ;# of odd (fractional) trailing bytes
        add     ecx,ecx
        or      ecx,eax                 ;build a look-up index from the number
                                        ; of leading and trailing bytes
        mov     ecx,pfnWideWholeRep[ecx*4] ;proper drawing handler for front/
        mov     pfnWholeBytes,ecx          ; back alignment
        mov     ecx,offset whole_bytes_rep_wide
                                        ;set up to call routine to perform wide
                                        ; whole bytes fill

start_vec_set:
        mov     pfnStartDrawing,ecx     ; all partial (non-whole) edges

        mov     ecx,pdsurf
        mov     eax,[ecx].dsurf_lNextScan
        mov     ulScanWidth,eax         ;local copy of scan line width
        sub     eax,ebx                 ;EAX = delta to next scan
        mov     ulNextScan,eax

        mov     esi,pBrush
        mov     eax,[esi+oem_brush_height]
        dec     eax
        mov     ulVbYRound,eax
        mov     al,[esi + oem_brush_yshft] ; blind to the next.
        mov     ulVbYShift,eax

        mov     cl,al
        mov     eax,UlScanWidth
        shl     eax,cl                  ;ulNextScan * 8
        mov     ulVbNextScan,eax        ;

        cmp     fdInvertDestFirst,1     ;is this an invert-dest-plus-something-
                                        ; else rop that requires two passes?
        jnz     short do_single_pass

        lea     eax,vTrgBlt@20
        ptrCall <eax>,<pdsurf, culRcl, prcl, R2_NOT, -1>

        mov     ah,byte ptr jALUFunc    ;reset the ALU logical function
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        SLOW_OUT                        ;set the ALU logical function

do_single_pass:
        call    draw_banks

;-----------------------------------------------------------------------;
; See if there are any more rectangles to fill.
;-----------------------------------------------------------------------;

        add     prcl,(size RECTL) ;point to the next rectangle, if there is one
        dec     culRcl            ;count down the rectangles to fill
        jnz     fill_rect_loop


;-----------------------------------------------------------------------;
; We have filled all rectangles.  Restore the VGA to its default state.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,0000h + GRAF_ENAB_SR ;disable set/reset
        out     dx,ax
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax                   ;restore read mode 0 and write mode 0
        mov     eax,(DR_SET shl 8) + GRAF_DATA_ROT ;set the logical function to
        out     dx,ax                             ; SET
vMonoPatBlts_done:
        cRet    vMonoPatBlt

;-----------------------------------------------------------------------;
; Fills all banks in the current fill rectangle. Called once per fill
; rectangle, except for destination-inversion-plus-something-else rops.
;-----------------------------------------------------------------------;

draw_banks:

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to fill, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     ecx,pdsurf              ;point to surface
        mov     eax,[edi].yTop          ;top scan line of fill
        mov     ulCurrentTopScan,eax    ;this will be the fill top in 1st bank

        cmp     eax,[ecx].dsurf_rcl1WindowClip.yTop ;is fill top less than
                                                    ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[ecx].dsurf_rcl1WindowClip.yBottom ;fill top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the fill.

        ptrCall <dword ptr [ecx].dsurf_pfnBankControl>,<ecx,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;-----------------------------------------------------------------------;

; Compute the starting address and scan line count for the initial bank.

        mov     eax,pdsurf              ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet     ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].dsurf_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        mov     esi,pBrush              ;edx = min(PatternHeight,BltHeight)
        mov     ecx,[esi + oem_brush_height]
        sub     ecx,ebx
        sbb     edx,edx
        and     edx,ecx
        add     edx,ebx
        mov     ulVbBlindCount,edx

; Brush alignment. We need to look at pptlBrush

        mov     eax,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     eax,ulPatternOrgY       ;

        jns     short pos_y_offset      ;
        neg     eax                     ;
        and     eax,7                   ;-eax mod 8
        neg     eax                     ;
        add     eax,8                   ;
        jmp     short save_pat_pointer
pos_y_offset:
        and     eax,7                   ;eax mod 8
save_pat_pointer:
        add     eax,eax                 ;Y Offset * PatternWidth (2 bytes)

        lea     edx,RotatedPat          ;Pattern Dest
        add     eax,edx
        mov     pulPattern,eax          ;Drawing code uses this as the
                                        ;source for the pattern

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Whole byte fills.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special
; case width.
;
; The destination is not involved, so a STOS (or equivalent) can be used
; (no read needed before write).
;-----------------------------------------------------------------------;

        public whole_bytes_rep_wide
whole_bytes_rep_wide::
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_COLOR_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                   ;write mode 2
        mov     eax,ulBkClr             ;Set the write mode to write mode
        mov     [edi],al                ; three after we load the latches
        mov     al,[edi]                ; with our background color

        mov     al,GRAF_SET_RESET       ;Set the foreground color
        out     dx,al                   ; into set/reset
        inc     edx
        in      al,dx
        and     eax,0f0h
        or      eax,ulFgClr
        out     dx,al
        dec     edx

        mov     eax,GRAF_MODE + ((M_AND_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                   ;write mode 3 so we can do the masking
                                        ; without OUTs, read mode 1 so we can
                                        ; read 0xFF from memory always, for
                                        ; ANDing (because Color Don't Care is
                                        ; all zeros)

        mov     esi,pulPattern          ; pointer to pattern bits
        mov     ax,[esi]                ; into place
        add     esi,2
        mov     pulVbPattern,esi


        mov     ulVbTopScan,ebx         ;our pattern is 8 high so we don't
        add     ebx,ulVbYRound          ;Calc the number of lines to do
        mov     ecx,ulVbyShift
        shr     ebx,cl                  ;only need to go through the code
                                        ; count/8 times. We will handle any
                                        ; extra lines at the bottom
                                        ; (ulVbTopScan mod 8) in our loops.
        push    ulVbBlindCount

        public wide_bytes_loop
wide_bytes_loop::

        mov     esi,ulWholeWords        ;number of aligned word writes
        mov     edx,ulVbNextScan        ;offset from end of one scan line to
                                        ; start of next the same scan line
                                        ; in the next pattern.
        sub     edx,ulWholeBytes
        add     edx,ulSpecialBytes


        ; eax = rotated pattern
        ; ebx = count
        ; ecx = routine address
        ; edx = ulVbNextScan
        ; esi = ulFvWholeWords
        ; edi = pDest
        ;
        push    edi                     ;save out dest pointer
        call    pfnWholeBytes           ;draw the wide whole bytes
        pop     edi                     ;restore out dest pointer

        add     edi,ulScanWidth         ;advance to next scan line

        dec     ulVbBlindCount
        jz      short wide_bytes_end

        mov     eax,ulVbTopScan           ;restore scan count
        dec     eax                     ;Subtract off completed top line
        mov     ulVbTopScan,eax
        add     eax,ulVbYRound          ;Calc the number of lines to do
        mov     ecx,ulVbyShift
        shr     eax,cl                  ;for this venetian blind pass
        mov     ebx,eax                 ;including any partial patterns
                                        ; at the bottom

        mov     esi,pulVbPattern        ;Pattern data
        mov     ax,[esi]                ;get pattern word
        add     esi,2
        mov     pulVbPattern,esi        ;save pattern pointer for later

        jmp     short wide_bytes_loop

wide_bytes_end:
        pop     ulVbBlindCount
        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count

        mov     edx,VGA_BASE + GRAF_ADDR ;restore proper read/write modes
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax

        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes.
;-----------------------------------------------------------------------;

        public  non_replace_wide
non_replace_wide::
        push    ebx                     ;Save line count
        push    edi                     ;Save Dest Addr

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill

        mov     pfnWesTrick,offset do_wide_wes_trick

        mov     ecx,ulFgClr
        xor     ecx,ulBkClr             ;mask = ulBkClr ^ ulFgClr

        mov     ah,cl                   ;sre = !mask
        not     ah                      ;Set/Reset Enable
        mov     edx,EGA_BASE+GRAF_ADDR
        mov     al,GRAF_ENAB_SR
        out     dx,ax                   ;Set Set/Reset Enable bits

        mov     ah,byte ptr ulBkClr     ;Set/Reset = background color
        mov     al,GRAF_SET_RESET
        out     dx,ax

        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                   ; Set Read Mode 0

;save the width count and pfn here

        call    wes_trick

        mov     edx,EGA_BASE+SEQ_DATA
        mov     eax,0fh
        out     dx,al

        mov     edx,EGA_BASE+GRAF_ADDR
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax

        mov     eax,GRAF_ENAB_SR
        out     dx,ax                   ;Reset Set/Reset Enable bits

        pop     edi
        pop     ebx

        jmp     pfnContinueDrawing      ;either keep drawing or we're done

;-----------------------------------------------------------------------;
; Process any left/right columns that that have to be done.
;
;   Currently:
;       EBX =   height to fill, in scans
;       EDI --> first byte of left edge
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes.
;-----------------------------------------------------------------------;

        public  edge_byte_setup
edge_byte_setup::
        mov     pfnWesTrick,offset do_edge_wes_trick

        mov     ecx,ulFgClr
        xor     ecx,ulBkClr             ;mask = ulBkClr ^ ulFgClr

        mov     ah,cl                   ;sre = !mask
        not     ah                      ;Set/Reset Enable
        mov     edx,EGA_BASE+GRAF_ADDR
        mov     al,GRAF_ENAB_SR
        out     dx,ax                   ;Set Set/Reset Enable bits

        mov     ah,byte ptr ulBkClr     ;Set/Reset = foreground color
        mov     al,GRAF_SET_RESET
        out     dx,ax

        mov     eax,ulLeftEdgeAdjust
        or      eax,eax
        jz      short do_right_edge

        mov     eax,ulMasks             ;Get Left/Right edge Masks
        mov     ah,al
        mov     al,GRAF_BIT_MASK
        mov     edx,EGA_BASE+GRAF_ADDR
        out     dx,ax

        inc     pulPattern              ;Adjust Pattern rotation

        push    ebx                     ;Save line count
        push    edi                     ;Save Dest Addr
        call    wes_trick
        pop     edi
        pop     ebx

        mov     eax,ulMasks             ;restore Left/Right edge Masks
        dec     pulPattern              ;Adjust Pattern rotation

do_right_edge:
        mov     eax,ulMasks             ;Get Left/Right edge Masks
        and     ah,0ffh
        jz      edge_done

        mov     al,GRAF_BIT_MASK
        mov     edx,EGA_BASE+GRAF_ADDR
        out     dx,ax

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        add     edi,ulWholeBytes        ;point to right edge byte to fill
        call    wes_trick

edge_done:
        mov     edx,EGA_BASE+SEQ_DATA
        mov     eax,0fh
        out     dx,al

        mov     edx,EGA_BASE+GRAF_ADDR
        mov     eax,GRAF_BIT_MASK+0ff00h
        out     dx,ax

        mov     eax,GRAF_ENAB_SR
        out     dx,ax                   ;Reset Set/Reset Enable bits


;-----------------------------------------------------------------------;
; See if there are any more banks to process.
;-----------------------------------------------------------------------;

        public check_next_bank
check_next_bank::

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_rcl1WindowClip.yBottom ;is the fill bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jle     short banks_done        ;yes, so we're done
                                        ;no, map in the next bank and fill it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address and scan line count in this bank.

        mov     eax,pdsurf              ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet2    ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet2:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].dsurf_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        mov     esi,pBrush              ;edx = min(PatternHeight,BltHeight)
        mov     ecx,[esi + oem_brush_height]
        sub     ecx,ebx
        sbb     edx,edx
        and     edx,ecx
        add     edx,ebx
        mov     ulVbBlindCount,edx

; Brush alignment. We need to look at pptlBrush

        mov     eax,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     eax,ulPatternOrgY       ;

        jns     short pos_y_offset1     ;
        neg     eax                     ;
        and     eax,7                   ;-eax mod 8
        neg     eax                     ;
        add     eax,8                   ;
        jmp     short save_pat_pointer1
pos_y_offset1:
        and     eax,7                   ;eax mod 8
save_pat_pointer1:
        add     eax,eax                 ;Y Offset * PatternWidth (2 bytes)

        lea     edx,RotatedPat          ;Pattern Dest
        add     eax,edx
        mov     pulPattern,eax          ;Drawing code uses this as the
                                        ;source for the pattern

; Draw in the new bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Done with all banks in this fill.

        public banks_done
banks_done::
        PLAIN_RET

;----------------------------------------------------------------------------
; Wes Trick Setup code. This code decides if this is a one or a two pass
; operation.
;----------------------------------------------------------------------------
        public  wes_trick
wes_trick::

        mov     ecx,ulFgClr             ;
        mov     eax,ecx                 ;
        xor     ecx,ulBkClr             ;mask = ulBkClr ^ ulFgClr

        mov     edx,EGA_BASE+SEQ_DATA   ;Index should be pointing to the
                                        ; plane mask (2)
        mov     ch,cl
        not     ch                      ;Set/Reset Enable bits
        and     cl,al                   ;ulFgdColor & mask
        or      cl,al
        jz      short check_bk_bits     ;if zero - one background pass

        mov     ulVbMask,0              ;We do not want to invert the
                                        ;foreground pass
        or      ch,cl
        mov     al,ch
        out     dx,al                   ;Enable Planes for First Pass

        push    ecx
        push    edi                     ;Save our Dest pointer
        push    ebx                     ;Save our count
        call    pfnWesTrick             ;Draw the foreground pass
        pop     ebx                     ;restore the line count
        pop     edi                     ;restore the dest pointer
        pop     eax                     ;Restore bk mask


check_bk_bits:
        not     al
        and     al,MM_ALL
        jnz     short @f
        PLAIN_RET
@@:
        mov     ulVbMask,-1             ;We do not want to invert the
        mov     edx,EGA_BASE+SEQ_DATA   ;Index should be pointing to the
                                        ; plane mask (2)
        out     dx,al
        jmp     pfnWesTrick

;--------------------------------------------------------------------------
; Do the edges here.
;--------------------------------------------------------------------------

        public do_edge_wes_trick
do_edge_wes_trick::
        ;       ebx = line count
        ;       edi = dest

        mov     ulVbTopScan,ebx         ;Mod 8 our count for the venetian blind
        add     ebx,ulVbYRound          ;Calc the number of lines to do
        mov     ecx,ulVbyShift
        shr     ebx,cl

        mov     esi,pulPattern
        mov     ax,[esi]                ;get pattern into place
        add     esi,2                   ;patterns stored as words
        xor     eax,ulVbMask            ;Invert the pattern if we are doing
                                        ; a background pass

        push    ulVbBlindCount

        ; Set up variables for entering loop.
wes_trick_loop:
        mov     ecx,ulVbNextScan        ;offset from one scan to next

        push    edi                     ;save dest pointer
        call    draw_1_wide_loop        ;jump into the loop to draw
        pop     edi                     ;restore dest pointer

        add     edi,ulScanWidth         ;move to next scan line

        dec     ulVbBlindCount
        jz      short wes_trick_loop_done  ;jz if we are finished

        mov     eax,ulVbTopScan         ;restore scan count
        dec     eax                     ;Subtract off completed top line
        mov     ulVbTopScan,eax         ;save for next loop
        add     eax,ulVbYRound          ;Calc the number of lines to do
        mov     ecx,ulVbyShift          ;for this venetian blind pass
        shr     eax,cl                  ;including any partial patterns
        mov     ebx,eax                 ;at the bottom


        mov     ax,[esi]
        add     esi,2                   ;point to the next pattern line
        xor     eax,ulVbMask            ;Invert the pattern if we are doing
                                        ; a background pass

        jmp     short wes_trick_loop

wes_trick_loop_done:
        pop     ulVbBlindCount
        PLAIN_RET

;--------------------------------------------------------------------------
; Do the middle bytes here for blts with rops.
;--------------------------------------------------------------------------

        public  do_wide_wes_trick
do_wide_wes_trick::
        ;       ebx = line count
        ;       edi = dest

        mov     ulVbTopScan,ebx         ;Mod 8 our count for the venetian blind
        add     ebx,ulVbYRound          ;Calc the number of lines to do
        mov     ecx,ulVbyShift
        shr     ebx,cl

        mov     esi,pulPattern
        mov     al,[esi]                ;get pattern into place
        add     esi,2                   ;patterns stored as words
        mov     pulVbPattern,esi
        xor     eax,ulVbMask            ;Invert the pattern if we are doing
                                        ; a background pass

        push    ulVbBlindCount

        ; Set up variables for entering loop.
wide_wes_trick_loop:

        mov     esi,ulWholeBytes
        mov     edx,ulVbNextScan        ;offset from one scan to next
        sub     edx,esi
        add     edx,ulSpecialBytes

        push    edi                     ;save dest pointer
        call    pfnWholeBytes           ;draw
        pop     edi                     ;restore dest pointer

        add     edi,ulScanWidth         ;move to next scan line

        dec     ulVbBlindCount
        jz      short wide_wes_trick_loop_done  ;jz if we are finished

        mov     eax,ulVbTopScan         ;restore scan count
        dec     eax                     ;Subtract off completed top line
        mov     ulVbTopScan,eax         ;save for next loop
        add     eax,ulVbYRound          ;Calc the number of lines to do
        mov     ecx,ulVbyShift          ;for this venetian blind pass
        shr     eax,cl                  ;including any partial patterns
        mov     ebx,eax                 ;at the bottom


        mov     esi,pulVbPattern
        mov     al,[esi]                ;get pattern word
        add     esi,2                   ;point to the next pattern line
        mov     pulVbPattern,esi
        xor     eax,ulVbMask            ;Invert the pattern if we are doing
                                        ; a background pass

        jmp     short wide_wes_trick_loop

wide_wes_trick_loop_done:
        pop     ulVbBlindCount
        PLAIN_RET

endProc vMonoPatBlt

;-----------------------------------------------------------------------;
; Drawing loops.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_00_loop     proc    near
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_00_loop

        ret

draw_wide_00_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_01_loop     proc    near
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        mov     [edi],al        ;trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_01_loop
        ret

draw_wide_01_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_10_loop     proc    near
        mov     [edi],ah        ;do leading byte
        inc     edi             ;advance poitner
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_10_loop
        ret

draw_wide_10_loop     endp

;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = Pattern Byte
;  EBX = count of scans to fill ((total scans/ pattern height) + partial)
;  EDX = offset from end of one scan's fill to start of next similar line
;  ESI = pattern data
;  EDI = target address to fill

draw_wide_11_loop     proc    near
        mov     [edi],ah        ;do leading byte
        inc     edi             ;advance poitner
        mov     ecx,esi         ;# of whole words
        rep     stosw           ;fill all whole bytes as dwords
        mov     [edi],al        ;trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_11_loop
        ret

draw_wide_11_loop     endp

;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is NOT required.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide write-only edge-drawing loops.
;
; Entry:
;       AL/AX/EAX = pixel mask (if AX or EAX, then 0xFFFF or 0xFFFFFFFF)
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide write-only.

draw_1_wide_even_loop     proc    near
        mov     [edi],al                ;we always read 0xFF, so AL is written
                                        ; as-is; because we're in write mode 3,
                                        ; AL becomes the Bit Mask
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_even_loop

        ret

draw_1_wide_even_loop     endp

; 1-wide write-only.

draw_1_wide_odd_loop     proc    near
        mov     [edi],ah                ;we always read 0xFF, so AL is written
                                        ; as-is; because we're in write mode 3,
                                        ; AL becomes the Bit Mask
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_odd_loop

        ret

draw_1_wide_odd_loop     endp

;-----------------------------------------------------------------------;

; 2-wide write-only.

draw_2_wide_even_loop     proc    near
        mov     [edi],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_even_loop

        ret

draw_2_wide_even_loop     endp

; 2-wide write-only.

draw_2_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_odd_loop

        ret

draw_2_wide_odd_loop     endp

;-----------------------------------------------------------------------;

; 3-wide write-only, starting at an even address.

draw_3_wide_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_even_loop

        ret

draw_3_wide_even_loop     endp

;-----------------------------------------------------------------------;

; 3-wide write-only, starting at an odd address.

draw_3_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_odd_loop

        ret

draw_3_wide_odd_loop     endp


;-----------------------------------------------------------------------;

; 4-wide write-only, starting at an even address.

draw_4_wide_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_even_loop

        ret

draw_4_wide_even_loop     endp

;-----------------------------------------------------------------------;

; 4-wide write-only, starting at an odd address.

draw_4_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_odd_loop

        ret

draw_4_wide_odd_loop     endp

;-----------------------------------------------------------------------;

; 5-wide write-only, starting at an even address.

draw_5_wide_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_even_loop

        ret

draw_5_wide_even_loop     endp

;-----------------------------------------------------------------------;

; 5-wide write-only, starting at an odd address.

draw_5_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_odd_loop

        ret

draw_5_wide_odd_loop     endp

;-----------------------------------------------------------------------;

; 6-wide write-only, starting at an even address.

draw_6_wide_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_even_loop

        ret

draw_6_wide_even_loop     endp

;-----------------------------------------------------------------------;

; 6-wide write-only, starting at an odd address.

draw_6_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_odd_loop

        ret

draw_6_wide_odd_loop     endp

;-----------------------------------------------------------------------;

; 7-wide write-only, starting at an even address.

draw_7_wide_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_even_loop

        ret

draw_7_wide_even_loop     endp

;-----------------------------------------------------------------------;

; 7-wide write-only, starting at an odd address.

draw_7_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_odd_loop

        ret

draw_7_wide_odd_loop     endp

;-----------------------------------------------------------------------;

; 8-wide write-only, starting at an even address.

draw_8_wide_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],ax
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_even_loop

        ret

draw_8_wide_even_loop     endp

;-----------------------------------------------------------------------;

; 8-wide write-only, starting at an odd address.

draw_8_wide_odd_loop     proc    near
        mov     [edi],ah
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        mov     [edi+7],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_odd_loop

        ret

draw_8_wide_odd_loop     endp

;-----------------------------------------------------------------------;
; 1-wide read before write drawing loop; variant for Wes trick.
;
; Entry:
;       AL = pixel mask
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide read/write.

draw_1_wide_loop     proc    near
        mov     dh,[edi]                ;load latches w/o destroying our data
        mov     [edi],al                ;write out our byte
        add     edi,ecx                 ;move to the next blind

        dec     ebx
        jnz     draw_1_wide_loop

        ret

draw_1_wide_loop     endp

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide read before write drawing loops.
;
; Entry:
;       AL = pixel mask
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide read/write.

draw_1_wide_rop_loop     proc    near
        mov     ah,[edi]
        mov     [edi],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_rop_loop

        ret

draw_1_wide_rop_loop     endp

;-----------------------------------------------------------------------;

; 2-wide read/write.

draw_2_wide_rop_loop     proc    near
        mov     ah,[edi]
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_rop_loop

        ret

draw_2_wide_rop_loop     endp

;-----------------------------------------------------------------------;

; 3-wide read/write.

draw_3_wide_rop_loop     proc    near
        mov     ah,[edi]
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        mov     ah,[edi+2]
        mov     [edi+2],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_rop_loop

        ret

draw_3_wide_rop_loop     endp

;-----------------------------------------------------------------------;

; 4-wide read/write.

draw_4_wide_rop_loop     proc    near
        mov     ah,[edi]
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        mov     ah,[edi+2]
        mov     [edi+2],al
        mov     ah,[edi+3]
        mov     [edi+3],al
        add     edi,edx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_rop_loop

        ret

draw_4_wide_rop_loop     endp

;-----------------------------------------------------------------------;
; 5-or-wider read before write loop.
;
; Entry:
;       EAX = # of bytes to fill across scan line (needed only by 5-or-wider
;               handler)
;       EBX = loop count
;       EDX = offset from end of one scan line to the start of the next next
;       EDI = start offset
;
; EBX, ECX, ESI, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 5-or-wider read/write.

draw_wide_rop_loop proc  near
        mov     ecx,esi
@@:     mov     ah,[edi]
        mov     [edi],al
        inc     edi
        dec     ecx
        jnz     @b
        add     edi,edx

        dec     ebx
        jnz     draw_wide_rop_loop

        ret

draw_wide_rop_loop endp

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\ppc.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: ppc.inc
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Packed Pel Conversion Data
;
; The following structure will contain the information necessary
; for converting a source bitmap in a packed pel format into a
; planer format.
;
;-----------------------------------------------------------------------;

PACKEDPELCONV   struc
pfnConvert      dd      ?               ;Pointer to conversion function
pulXlate        dd      ?               ;Pointer to color translation table
pulConvert      dd      ?               ;Pointer to bit conversion table
pSrc            dd      ?               ;Pointer to next source scan
iNextScan       dd      ?               ;Index to next scan
cLeftMiddle     dd      ?               ;# of left/middle bytes to convert
pfnLeftMiddle   dd      ?               ;Processor for left/middle pels
pfnRight        dd      ?               ;Processor for right pels
pjConverted     dd      ?               ;Pointer to first converted byte to use
cLeftShift      db      ?               ;Right hand side shift adjustment
fb              db      ?               ;Control flags
iFormat         db      ?               ;Source format
                db      ?
PACKEDPELCONV   ends

; Constants for use in the fb field

PPC_NEEDED      equ     10000000b       ;Packed pel conversion needed


DIB_FORMAT8     equ     3               ;!!! these should be defined in some
DIB_FORMAT4     equ     2               ;!!! global include file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\pointer.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	POINTER.INC
;
; This file contains definitions relating to the pointer shape.
;
; Copyright (c) 1992 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:	none
;
; Public Data:		PTR_ROUND_RIGHT
;			PTR_ROUND_LEFT
; General Description:
;
;   Constants are defined for the pointer drawing routine describing
;   the size of the poinetr shape.  Some of these constants are also
;   required for memory allocation in EGA/VGA VRAM.
;
; Restrictions:
;
;-----------------------------------------------------------------------;

	public	PTR_ROUND_RIGHT 	;Pointer exclusion needs these
	public	PTR_ROUND_LEFT
	public	PTR_WIDTH_BITS
	public	PTR_HEIGHT


;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT	equ	32                      ;Height of pointer in scanlines
PTR_WIDTH	equ	4			;Width in bytes of pointer
PTR_WIDTH_BITS	equ	PTR_WIDTH*8		;Width in bits of pointer


;-----------------------------------------------------------------------;
; The work width/height is the size of a pointer as manipulated by
; the pointer drawing code.
;-----------------------------------------------------------------------;

WORK_WIDTH	equ	PTR_WIDTH+1		;Width of mask, work area
uWORK_HEIGHT	equ	PTR_HEIGHT+0		;Height of mask, work area
MASK_LENGTH	equ	WORK_WIDTH*WORK_HEIGHT	;#bytes in mask, work area
CLR_MASK_LENGTH	equ	WORK_WIDTH*WORK_HEIGHT*BITS_PEL	;#bytes in color mask
	.errnz	BITS_PEL-4


;-----------------------------------------------------------------------;
; The save area parameters control the size of the buffer used for
; saveing the bits underneath the pointer image.  It should be a
; power of two to allow for easy wrap calculations.
;-----------------------------------------------------------------------;

SAVE_BUFFER_WIDTH  equ	  8			  ;Width  of the save area
SAVE_BUFFER_HEIGHT equ	  32			  ;Height of the save area
		   .errnz  PTR_WIDTH  GT SAVE_BUFFER_WIDTH
		   .errnz  PTR_HEIGHT GT SAVE_BUFFER_HEIGHT


;-----------------------------------------------------------------------;
; The following values allow us to set rounding for cursor exclusion.
; These values are applied as an AND mask (for rounding left) and as
; an OR mask (for rounding right).
;-----------------------------------------------------------------------;

ROUNDING_SIZE	equ	8			;Round to byte boundaries
		.errnz	ROUNDING_SIZE and 111b	;Must be at least byte boundary
PTR_ROUND_RIGHT equ	ROUNDING_SIZE-1
PTR_ROUND_LEFT	equ	-ROUNDING_SIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\pointer.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  POINTER.ASM
;
; This file contains the pointer shape routines required to draw the
; pointer shape on the EGA.
;
; Copyright (c) 1992 Microsoft Corporation
;
; Exported Functions:   none
;
; Public Functions:     xyCreateMasks
;                       vDrawPointer
;                       vYankPointer
;
; General Description:
;
;   All display drivers must support a "pointer" for the pointing
;   device.  The pointer is a small graphics image which is allowed
;   to move around the screen independantly of all other operations
;   to the screen, and is normally bound to the location of the
;   pointing device.  The pointer is non-destructive in nature, i.e.
;   the bits underneath the pointer image are not destroyed by the
;   presence of the pointer image.
;
;   A pointer consists of an AND mask and an XOR mask, which give
;   combinations of 0's, 1's, display, or inverse display.
;
;                   AND XOR | DISPLAY
;                   ----------------------
;                    0   0  |     0
;                    0   1  |     1
;                    1   0  |   Display
;                    1   1  | Not Display
;
;   The pointer also has a "hot spot", which is the pixel of the
;   pointer image which is to be aligned with the actual pointing
;   device location.
;
;
;                 |         For a pointer like this, the hot spot
;                 |         would normally be the *, which would
;              ---*---      be aligned with the pointing device
;                 |         position
;                 |
;
;   The pointer may be moved to any location on the screen, be
;   restricted to only a section of the screen, or made invisible.
;   Part of the pointer may actually be off the edge of the screen,
;   and in such a case only the visible portion of the pointer
;   image is displayed.
;
;
;
;   Logically, the pointer image isn't part of the physical display
;   surface.  When a drawing operation coincides with the pointer
;   image, the result is the same as if the pointer image wasn't
;   there.  In reality, if the pointer image is part of the display
;   surface it must be removed from memory before the drawing
;   operation may occur, and redrawn at a later time.
;
;   This exclusion of the pointer image is the responsibility of
;   the display driver.  If the pointer image is part of physical
;   display memory, then all output operations must perform a hit
;   test to determine if the pointer must be removed from display
;   memory, and set a protection rectangle wherein the pointer must
;   not be displayed.  The actual pointer image drawing routine
;   must honor this protection rectangle by never drawing the
;   pointer image within its boundary.
;
;   This code doesn't distinguish between pointers and icons,
;   they both are the same size, 32 x 32, which comes out square.
;
; Restrictions:
;
;   All routines herein assume protection either via cli/sti
;   or a semephore at higher level code.
;
;-----------------------------------------------------------------------;

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        ASSUME   DS: FLAT, SS: FLAT, ES: FLAT
        assume   FS: NOTHING, GS: NOTHING

        .xlist
        include stdcall.inc
        include i386\egavga.inc
        include i386\strucs.inc
        .list

        PUBLIC  PTR_ROUND_RIGHT         ;Pointer exclusion needs these
        PUBLIC  PTR_ROUND_LEFT
        PUBLIC  PTR_WIDTH_BITS
        PUBLIC  PTR_HEIGHT


;-----------------------------------------------------------------------;
; The following values allow us to set rounding for cursor exclusion.
; These values are applied as an AND mask (for rounding left) and as
; an OR mask (for rounding right).
;-----------------------------------------------------------------------;

ROUNDING_SIZE   EQU     8                       ;Round to byte boundaries
                .ERRNZ  ROUNDING_SIZE AND 111b  ;Must be at least byte boundary
PTR_ROUND_RIGHT EQU     ROUNDING_SIZE-1
PTR_ROUND_LEFT  EQU     -ROUNDING_SIZE

;-----------------------------------------------------------------------;
; The RECT_DATA structure is used for describing the rectangles
; which will be manipulated by this code.  The fields are:
;
; rd_ptbSave    This is the (X,Y) origin of the given rectangle in
;               the save area.
;
; rd_ptlScreen  This is the (X,Y) origin of the given rectangle on
;               the screen.
;
; rd_sizb       This is the extents of the rectangle.
;
; rd_ptbWork    This is the (X,Y) origin of the given rectangle in
;               the work area.
;-----------------------------------------------------------------------;

ifdef DUPS_ARE_LEGAL

RECT_DATA       STRUC
rd_ptbSave      DW      ((SIZE POINTB)/2) DUP (0)
rd_ptlScreen    DW      ((SIZE POINTL)/2) DUP (0)
rd_sizb         DW      ((SIZE SIZEB)/2)  DUP (0)
rd_ptbWork      DW      ((SIZE POINTB)/2) DUP (0)
RECT_DATA       ENDS
                .ERRNZ  SIZE POINTB AND 1
                .ERRNZ  SIZE POINTL AND 1
                .ERRNZ  SIZE SIZEB  AND 1

else

RECT_DATA       STRUC
rd_ptbSave      dw      0                   ; POINTB
rd_ptlScreen    dd      0,0                 ; POINTL
rd_sizb         dw      0                   ; SIZEB
rd_ptbWork      dw      0                   ; POINTB
RECT_DATA       ENDS
                .ERRNZ  (SIZE POINTB) - 2
                .ERRNZ  (SIZE POINTL) - 8
                .ERRNZ  (SIZE SIZEB)  - 2

endif



;-----------------------------------------------------------------------;
; The POINTER_DATA structure is used for describing the actual pointer's
; rectangle.  It also contains clipping information and control flags.
; The fields are:
;
; pd_rd         RECT_DATA structure as defined above
;
; pd_fb         Flags as follows:
;
; PD_VALID        1 The rectangle contains valid data.
;                 0 The rectangle data is invalid.
;
; PD_CLIP_BOTTOM  1 Clip the bottom
;                 0 No bottom clipping needed
;
; PD_CLIP_TOP     1 Clip the top
;                 0 No top clipping needed
;
; PD_CLIP_LEFT    1 Clip the lhs
;                 0 No lhs clipping needed
;
; PD_CLIP_RIGHT   1 Clip the rhs
;                 0 No rhs clipping needed
;-----------------------------------------------------------------------;

ifdef DUPS_ARE_LEGAL

POINTER_DATA    STRUC
pd_rd           DW      ((SIZE RECT_DATA)/2) DUP (0)
pd_fb           DB      0
                DB      0
POINTER_DATA    ENDS
                .ERRNZ  SIZE RECT_DATA AND 1

else

POINTER_DATA    struc
pd_rd           dw      0,0,0,0,0,0,0       ; RECT_DATA
pd_fb           db      0
                db      0
POINTER_DATA    ends
                .ERRNZ  (size POINTER_DATA) - (SIZE RECT_DATA) - 2

endif


PD_CLIP_BOTTOM  EQU     10000000b
PD_CLIP_TOP     EQU     01000000b
PD_CLIP_RIGHT   EQU     00100000b
PD_CLIP_LEFT    EQU     00010000b
PD_VALID        EQU     00001000b
;               EQU     00000100b
;               EQU     00000010b
;               EQU     00000001b

PD_CLIPPED      EQU     PD_CLIP_BOTTOM OR PD_CLIP_TOP OR PD_CLIP_RIGHT OR PD_CLIP_LEFT


        .DATA

        PUBLIC  pdPtr1
        PUBLIC  pdPtr2
        PUBLIC  rdFlushX
        PUBLIC  rdFlushY
        PUBLIC  rdOverlap
        PUBLIC  rdReadX
        PUBLIC  rdReadY
        PUBLIC  rdWork


;       Offsets of locations in the EGA/VGA's address
;       space used both to determine and save the state of the EGA/VGA.
;
;       The actual address within the EGA/VGA's Regen RAM is determined
;       at init time, and is based on the number of vertical scans.

        EXTRN pPtrSave     : DWORD      ;offset from bitmap start of pointer
        EXTRN pPtrWork     : DWORD      ; work areas

; !!! This temp flag is a hack to know if the pointer is color or
; !!! mono.  Fix it up


flPointer   dd      0



pdPtr1          POINTER_DATA <>         ;Old/New pointer's data
pdPtr2          POINTER_DATA <>         ;Old/New pointer's data
rdFlushX        RECT_DATA <>            ;Flush from save area to screen
rdFlushY        RECT_DATA <>            ;Flush from save area to screen
rdOverlap       RECT_DATA <>            ;And from save area to work area
rdReadX         RECT_DATA <>            ;Read from screen to save, xor to work
rdReadY         RECT_DATA <>            ;Read from screen to save, xor to work
rdWork          RECT_DATA <>            ;Xor from work to screen


;-----------------------------------------------------------------------;
; siz?Mask contains the width and height of the working portion of
; the current AND and XOR mask.  Use of this allows us to manipulate
; less memory when parts of the pointer won't alter the screen image.
;-----------------------------------------------------------------------;

sizbMask        SIZEB   <WORK_WIDTH,PTR_HEIGHT>
sizlMask        SIZEL   <WORK_WIDTH,PTR_HEIGHT>


;-----------------------------------------------------------------------;
; sizsMaxDelta is the maximum distance the old and new pointers may
; be before they are considered disjoint.
;-----------------------------------------------------------------------;

sizlMaxDelta    SIZEL   <WORK_WIDTH,WORK_HEIGHT>


;-----------------------------------------------------------------------;
; ptlBotRightClip is the coordinate where rhs or bottom clipping
; will first occur.  It is basically the screen width - pointer width.
;-----------------------------------------------------------------------;

ptlBotRightClip POINTL  <0,0>


;-----------------------------------------------------------------------;
; This is the initial origin in the save buffer.
;-----------------------------------------------------------------------;

ptbInitOrigin   POINTB  <0,0>


;-----------------------------------------------------------------------;
; ppdOld is the pointer to the old pointer's POINTER_DATA structure
;-----------------------------------------------------------------------;

ppdOld          DD      offset FLAT:pdPtr1


;-----------------------------------------------------------------------;
; ppdNew is the pointer to the new pointer's POINTER_DATA structure
;-----------------------------------------------------------------------;

ppdNew          DD      offset FLAT:pdPtr2


;-----------------------------------------------------------------------;
; pAndXor is the pointer to which AND/XOR mask is to be used.   It is
; based on the 3 least significant bits of the pointer's X coordinate.
; pColor is the pointer to which COLOR mask is to be used.
;-----------------------------------------------------------------------;

pAndXor         DD      -1
pColor          DD      -1


;-----------------------------------------------------------------------;
; The following are the masks which make up the pointer image.  There
; will be one AND/XOR/COLOR mask pair for each possible alignment.  On
; move_pointers call, all the alignments will be generated to save time.
;-----------------------------------------------------------------------;

        public  base_and_masks
        public  base_xor_masks
        public  base_clr_masks

base_and_masks  label   byte
                REPT    (MASK_LENGTH * 8)
                DB      ?
                ENDM

base_xor_masks  label   byte
                REPT    (MASK_LENGTH * 8)
                DB      ?
                ENDM

base_clr_masks  label   byte
                REPT    (CLR_MASK_LENGTH * 8)
                DB      ?
                ENDM

;-----------------------------------------------------------------------;
; pabAndMasks is an array which points to the start of the mask for
; each X rotation.  It is indexed into using the low 3 bits of the
; pointer's X coordinate.
;-----------------------------------------------------------------------;

pabAndMasks     label   dword
                DD      offset FLAT:base_and_masks+(0*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(1*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(2*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(3*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(4*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(5*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(6*MASK_LENGTH)
                DD      offset FLAT:base_and_masks+(7*MASK_LENGTH)

;-----------------------------------------------------------------------;
; pabClrMasks is an array which points to the start of the mask for
; each X rotation.  It is indexed into using the low 3 bits of the
; pointer's X coordinate.
;-----------------------------------------------------------------------;

pabClrMasks     label   dword
                DD      offset FLAT:base_clr_masks+(0*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(1*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(2*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(3*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(4*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(5*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(6*CLR_MASK_LENGTH)
                DD      offset FLAT:base_clr_masks+(7*CLR_MASK_LENGTH)

;-----------------------------------------------------------------------;
; The following flags and flag bytes are used to control which
; rectangles are used for what.
;
; fbFlush controls which rectangles are to be copied from the save
; area to the screen.  Valid flags are:
;
;   FB_OLD_PTR, FB_FLUSH_X, FB_FLUSH_Y
;
;   FB_OLD_PTR is mutually exclusive of all other flags
;
;
; fbAndRead controls which rectangles are to be ANDed into the work
; area from the screen or save area, and which rectangles are to be
; copied from the screen to the save area.  Valid flags are:
;
;   FB_NEW_PTR, FB_OVERLAP, FB_READ_X, FB_READ_Y, FB_WORK_RECT,
;
;   FB_NEW_PTR and FB_WORK_RECT are mutually exclusive of all other
;   flags.  Note that FB_OVERLAP doesn't apply when coping into the
;   save area.
;
;
; fbXor describes which rectangle is to be XORed from the work area
; into the screen.  Valid flags are:
;
;   FB_NEW_PTR, FB_WORK_RECT
;
;   FB_NEW_PTR and FB_WORK_RECT are mutually exclusive
;-----------------------------------------------------------------------;

fbFlush         DB      0
fbAndRead       DB      0
fbXor           DB      0
FB_OLD_PTR      EQU     10000000b
FB_NEW_PTR      EQU     01000000b
FB_FLUSH_X      EQU     00100000b
FB_FLUSH_Y      EQU     00010000b
FB_OVERLAP      EQU     00001000b
FB_READ_X       EQU     00000100b
FB_READ_Y       EQU     00000010b
FB_WORK_RECT    EQU     00000001b

; Temporary work buffer.  We copy the masks and color data here before
; we decide how to flip them.  !!! Costly use of static space.  Use frame

                public  alWorkBuff


alWorkBuff      label   dword
                REPT    (2 * PTR_HEIGHT)
                DD      ?
                ENDM


; Table of entry points into and_from_screen inner loop

        align   4
and_from_screen_entry_table label dword
        dd      and_from_screen_width_0
        dd      and_from_screen_width_1
        dd      and_from_screen_width_2
        dd      and_from_screen_width_3
        dd      and_from_screen_width_4
        dd      and_from_screen_width_5


; Table of entry points into and_from_save inner loop

        align   4
and_from_save_entry_table label dword
        dd      and_from_save_width_0
        dd      and_from_save_width_1
        dd      and_from_save_width_2
        dd      and_from_save_width_3
        dd      and_from_save_width_4
        dd      and_from_save_width_5


; Table of entry points into cps_do_a_pass inner loop

        align   4
color_to_screen_entry_table label dword
        dd      color_to_screen_width_0
        dd      color_to_screen_width_1
        dd      color_to_screen_width_2
        dd      color_to_screen_width_3
        dd      color_to_screen_width_4
        dd      color_to_screen_width_5

;------------------------------------------------------------------------;

        .CODE

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;--------------------------Public-Routine-------------------------------;
; xyCreateMasks
;
;   The AND, XOR and COLOR pointer masks are stored in the pointer work
;   areas.  The original mask will be pre-rotated for all eight
;   possible alignments within a byte.
;
;   As the pointer is copied, it will be processed to see if it
;   can be made narrower.  After it has been copied, it will be
;   processed to see if it can be made shorter.
;
;   The following table indicates how the XOR/AND bitmap interacts with
;   the COLOR bitmap for a color system:
;
;       XOR     AND     COLOR   Result
;       1       1       x       invert screen
;       0       0       x       use x
;       0       1       x       transparent
;       1       0       x       use x
;
;   From the table, we observe that when the AND bits are on, the
;   corresponding COLOR bits are irrelevant.  We preprocess the
;   COLOR bitmap to mask off these bits.
;
;   When drawing the color pointer, we do the following steps:
;       1. XOR the destination with XOR mask.
;       2. AND the destination with AND mask.  Note the zero bits
;          would mask off the destination to prepare for the COLOR mask.
;       3. OR the destination with the COLOR mask.  Note it does not
;          affect the inverted or transparent bits since we have masked
;          off the corresponding COLOR bits during preprocessing.
;
; Entry:
;
; Returns:
;       AX = width in pels for exclusion hit test
;       DX = height in scans for exclusion hit test
; Error Returns:
;       None
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       create_masks_1_thru_7
;
;-----------------------------------------------------------------------;

cProc   xyCreateMasks,28,<  \
        USES esi edi ebx,   \
        ppdev:PTR,          \
        pBitsAndXor:PTR,    \
        pBitsColor:PTR,     \
        cyHeight:DWORD,     \
        pulXlate:DWORD,     \
        wFlags:WORD,        \
        fIsDFB:DWORD        >

        local   cyScreen:dword          ;height of bitmap in scans
        local   lNextScan:dword         ;width of bitmap in bytes
        local   ajColorBits[PTR_WIDTH*PTR_HEIGHT*4]:byte
        local   aulXlate[16]:dword

        cld

        mov     ecx,ppdev
        mov     eax,[ecx].PDEV_sizlSurf.sizl_cy
        mov     cyScreen,eax
        mov     ecx,[ecx].PDEV_pdsurf
        mov     eax,[ecx].dsurf_lNextScan
        mov     lNextScan,eax

        cmp     pBitsColor,0
        jne     short xycm_have_color
; Copy the AND/XOR mask into the work buffer

        mov     esi,pBitsAndXor
        mov     ecx,cyHeight
        mov     bx,wFlags
        shl     ecx,1
        mov     edi,offset FLAT:alWorkBuff
        rep movsd                       ;copy AND mask
        jmp     short xycm_continue

xycm_have_color:

; If a color translation vector was given, generate the new bit
; conversion array

        mov     eax,offset FLAT:aulDefBitMapping
        cld
        mov     esi,pulXlate
        or      esi,esi
        jz      short have_mapping_array
        lea     edi,aulXlate
        mov     ecx,16
create_next_bit_mapping:
        lodsd
        mov     eax,aulDefBitMapping[eax*4]
        stosd
        dec     ecx
        jnz     short create_next_bit_mapping
        lea     eax,[edi][-16*4]
have_mapping_array:
        mov     pulXlate,eax

; Copy the AND mask into the work buffer

        mov     edi,offset FLAT:alWorkBuff
        test    wFlags,PTRI_INVERT      ;are masks backwards?
        jz      short @F                ;  NO
        mov     edi,offset FLAT:alWorkBuff + (4*PTR_HEIGHT)
@@:
        mov     esi,pBitsAndXor
        mov     ecx,cyHeight
        rep movsd                       ;copy AND mask

; later on we will flip the AND and XOR masks, so we have to mix them
; up now else there will be problems later.

        mov     esi,pBitsColor                  ;Source color bits
        lea     edi,ajColorBits                 ;Where to store color
        mov     ecx,cyHeight
        mov     dx,wFlags

        mov     eax,fIsDFB

        push    ebp
        mov     ebp,pulXlate

        call    vConvertDIBPointer

        pop     ebp

xycm_continue:
        mov     ebx,cyHeight
        mov     dx,wFlags
        cCall   vCopyMasks              ;Pad and maybe flip masks

;-----------------------------------------------------------------------;
; The image we are copying is PTR_WIDTH bytes wide.  We must add an
; extra byte to make it WORK_WIDTH wide.  The byte we add will depends
; on whether this is the AND or the XOR mask.  For an AND mask, we add
; an FF byte on the end of each scan.  For an XOR mask, we add a 00
; byte on the end of each scan.  For the COLOR mask, we add a 00 byte on
; the end of each scan of all planes.  These bytes won't alter anything
; on the screen.
;-----------------------------------------------------------------------;

        mov     esi,offset FLAT:alWorkBuff ;ESI --> AND/XOR mask

;-----------------------------------------------------------------------;
; Copy the AND mask over.  As we copy it, accumulate the value of
; each column of the mask.  If the entire column is FF, we may be
; able to discard it.
;-----------------------------------------------------------------------;

        mov     edi, offset FLAT:base_and_masks
        mov     ecx, PTR_HEIGHT         ;Set height for move
        mov     ebx, 0FFFFFFFFh         ;Accumulate mask columns

move_next_and_mask_scan:
        lodsd                           ;Move explicit part
        stosd
        and     ebx, eax
        mov     al, 0FFh
        stosb
        .ERRNZ  PTR_WIDTH-4
        .ERRNZ  WORK_WIDTH-5
        loop    move_next_and_mask_scan
        push    ebx                     ;Save AND column mask
        mov     edx, offset FLAT:base_and_masks
        mov     ecx, (MASK_LENGTH*7)/(WORK_WIDTH*2)
        .ERRNZ  (MASK_LENGTH*7) mod (WORK_WIDTH*2)
        cCall   create_masks_1_thru_7

;-----------------------------------------------------------------------;
; Copy the XOR mask over.  As we copy it, accumulate the value of
; each column of the mask.  If the entire column is 00, we may be
; able to discard it.
;-----------------------------------------------------------------------;

        mov     edi, offset FLAT:base_xor_masks
        mov     ecx, PTR_HEIGHT         ;Set height for move
        xor     ebx, ebx                ;Accumulate columns of the mask

move_next_xor_mask_scan:
        lodsd                           ;Move explicit part
        stosd
        or      ebx, eax
        xor     al, al
        stosb
        .ERRNZ  PTR_WIDTH-4
        .ERRNZ  WORK_WIDTH-5
        loop    move_next_xor_mask_scan
        push    ebx
        mov     edx, offset FLAT:base_xor_masks
        mov     ecx, (MASK_LENGTH*7)/(WORK_WIDTH*2)
        .ERRNZ  (MASK_LENGTH*7) mod (WORK_WIDTH*2)
        cCall   create_masks_1_thru_7

;-----------------------------------------------------------------------;
; The masks have been copied.  Compute the number of columns which can
; be discarded.  To discard a column, all bits of the AND mask for that
; column must be 1, and all bits of the XOR mask for the column must be
; 0.  Since we work with bytes in this code, this must be true for an
; entire byte.
;
; Also note that the columns must be processed right to left.  We cannot
; throw out a middle column if its neighbors contain data.
;-----------------------------------------------------------------------;

        ;AND mask, EAX[0] = byte 1, EAX[1] = byte 2
        ;AND mask, EAX[2] = byte 3, EAX[3] = byte 4
        ;XOR mask, EBX[0] = byte 1, EBX[1] = byte 2
        ;XOR mask, EBX[2] = byte 3, EBX[3] = byte 4

        pop     ebx                     ;EBX XOR mask
        pop     eax                     ;EAX AND mask

        not     eax
        or      eax, ebx                ;Discard only if both are zero!

        mov     ebx, WORK_WIDTH
        mov     edx, PTR_HEIGHT         ;assume full mask
        xor     ecx, ecx
                                        ;check wFlags
        test    wFlags, PTRI_ANIMATE
        jnz     short mp_have_sizes

; !!! Until conversion of pointer images is handled via bitblt, always
; !!! treat color cursors as full size
        cmp     pBitsColor,0            ;!!!
        jne     short mp_have_sizes           ;!!!

        mov     edx,eax                 ;DX = bytes 1 and 2
        shr     eax,16                  ;AX = bytes 3 and 4
        or      ah,ah                   ;Discard 4th byte of mask?
        jnz     short @F                      ;  No
        dec     ebx
        or      al,al
        jnz     short @F
        dec     ebx
        or      dh,dh
        jnz     short @F
        dec     ebx
        or      dl,dl
        jz      move_pointers_done      ;AX = DX = 0 for return codes
@@:

;-----------------------------------------------------------------------;
; Compute the number of rows which can be discarded off the bottom.
; To discard a row, all bits of the AND mask for that row must be a
; 1, and all bits of the XOR mask for that row must be 0.
;-----------------------------------------------------------------------;

        .ERRNZ  PTR_WIDTH AND 1         ;Must be a word multiple

        dec     esi                     ;Post decremnent, not pre decrement
        dec     esi
        lea     edi, [esi][-PTR_WIDTH*PTR_HEIGHT] ;Last word of AND mask
        mov     ecx, (PTR_WIDTH/2)*PTR_HEIGHT
        mov     ax, 0FFFFh              ;Processing AND mask
        std
        repe    scasw
        mov     edx, ecx                ;Save count
        mov     edi, esi                ;--> XOR mask
        mov     ecx, (PTR_WIDTH/2)*PTR_HEIGHT
        xor     eax, eax                ;Processing XOR mask
        repe    scasw
        cld                             ;Take care of this while we remember
        cmp     ecx, edx                ;Want |cx| to be the largest
        ja      short @F
        xchg    ecx, edx
@@:
;-----------------------------------------------------------------------;
;  CX   >> 1   +1
;
;  63    31    32    1st word did not match, don't chop any scans
;  62    31    32    2nd word did not match, don't chop any scans
;  61    30    31    3rd word did not match, chop 1 scan
;  60    30    31    4th word did not match, chop 1 scan
;-----------------------------------------------------------------------;

        .ERRNZ  PTR_WIDTH-4

        shr     ecx, 1
        inc     ecx                     ;ECX = working height
        mov     edx, PTR_HEIGHT
        sub     edx, ecx                ;EDX = # scans chopped off bottom
        xchg    ecx, edx                ;Height in DX for returning

; EBX = working width of the pointer image in bytes.  ECX = amount to
; chop of the bottom of the pointer image.  EDX = working height of
; the pointer image.

mp_have_sizes:
        mov     eax, ebx
        mov     sizlMask.sizl_cx, eax
        mov     sizlMaxDelta.sizl_cx, eax
        mov     ah, dl
        mov     sizbMask, ax

        .ERRNZ  sizb_cy-sizb_cx-1

        mov     eax, edx
        mov     sizlMask.sizl_cy, eax
        mov     sizlMaxDelta.sizl_cy, eax
        neg     eax
        add     eax, cyScreen
        mov     ptlBotRightClip.ptl_y, eax
        mov     eax, lNextScan
        sub     eax, ebx
        mov     ptlBotRightClip.ptl_x, eax
        shr     ecx, 1
        mov     eax, WORK_WIDTH
        sub     eax, ebx
        shr     eax, 1
        mov     ah, cl
        mov     ptbInitOrigin, ax

        .ERRNZ  ptb_y-ptb_x-1

        mov     eax, ebx
        dec     eax
        shl     eax, 3                  ;Bit count is needed

        shl     edx, 16                 ;Return value in upper word of EAX
        or      eax, edx                ; is cyPointer, lower word of EAX
        push    eax                     ; is cxPointer.

;-----------------------------------------------------------------------;
; Finally, copy the COLOR mask over.  As we copy it, mask off the
; corresponding AND bits in the COLOR mask since we do not use that
; color bit if the AND bit is on.
;
;       XOR     AND     COLOR
;       1       1       invert screen
;       0       0       use color
;       0       1       transparent
;       1       0       use color
;
;-----------------------------------------------------------------------;

        mov     ecx, pBitsColor
        jecxz   move_color_pointer_done ;pBitsColor was set to null
        lea     esi, ajColorBits
        mov     edi, offset FLAT:base_clr_masks
        push    ebp                     ;Need extra loop counter
        mov     ebp, BITS_PEL

move_next_color_mask_plane:
        mov     ecx, PTR_HEIGHT         ;Set height for move
        mov     ebx, offset FLAT:base_and_masks
        sub     ebx, edi                ;make it relative

move_next_color_mask_scan:
ifdef WITH_AND_MASK
        lodsw                           ;Copy a scan from the current plane
        mov     dx, [ebx][edi]          ;Mask off the corresponding AND bits
        not     dx
        and     ax, dx
        stosw
        lodsw
        mov     dx,  [ebx][edi]
        not     dx
        and     ax, dx
        stosw
else
        movsd
endif
        xor     al, al
        stosb

        .ERRNZ  PTR_WIDTH-4
        .ERRNZ  WORK_WIDTH-5

        add     esi, (BITS_PEL-1)*PTR_WIDTH
        loop    move_next_color_mask_scan
        sub     esi, (BITS_PEL*PTR_WIDTH*PTR_HEIGHT)-PTR_WIDTH
        dec     ebp
        jnz     short move_next_color_mask_plane
        pop     ebp                     ;Restore register

        mov     edx, offset FLAT:base_clr_masks
        mov     ecx, (CLR_MASK_LENGTH*7)/(WORK_WIDTH*2)

        .ERRNZ  (CLR_MASK_LENGTH*7) MOD (WORK_WIDTH*2)

        cCall   create_masks_1_thru_7

move_color_pointer_done:

        pop     eax                     ;return results in EAX

move_pointers_done:
mp_exit:
        cRet    xyCreateMasks

endProc xyCreateMasks

;-------------------------Private-Routine-------------------------------;
; Copy the masks to the work buffer and adjust for use.  Two things may
; need to be done:
;
;   1) The masks could be inverted.
;   2) The masks may need to be padded out
;
; Entry:
;       EBX     = number of scan lines in each mask
;        DX     = flags (PTRI_INVERT)
;
; Returns:
;       None
;
; Error Returns:
;       None
;
;-----------------------------------------------------------------------;

cProc   vCopyMasks
        mov     ecx,ebx                 ;Needed for padding calculations
        test    dx,PTRI_INVERT          ;are masks backwards?
        jz      short copy_no_flip

; This is really annoying.  Not only are the masks inverted, but they
; are stored in the wrong order.  First get the AND and XOR masks into
; the correct order.

        mov     ecx,PTR_HEIGHT
        mov     esi,offset FLAT:alWorkBuff
        mov     edi,offset FLAT:alWorkBuff + PTR_HEIGHT * 4

@@:
        mov     eax,[esi]
        mov     edx,[edi]
        mov     [edi],eax
        mov     [esi],edx
        add     esi,4
        add     edi,4
        loop    @B

; Next, flip them so they are right-side up.

        mov     ecx,ebx
        mov     esi,offset FLAT:alWorkBuff
        cCall   vFlipMask               ;flip AND mask

        mov     ecx,ebx
        mov     esi,offset FLAT:alWorkBuff + PTR_HEIGHT * 4
        cCall   vFlipMask               ;flip XOR mask

; Now pad out the masks so no junk appears on the screen

copy_no_flip:

        mov     eax,0FFFFFFFFh          ;pad AND mask
        mov     ecx,PTR_HEIGHT
        sub     ecx,ebx
        mov     edi,offset FLAT:alWorkBuff
        lea     edi,[edi+4*ebx]
        rep stosd

        xor     eax,eax                 ;pad XOR mask
        mov     ecx,PTR_HEIGHT
        sub     ecx,ebx
        mov     edi,offset FLAT:alWorkBuff + PTR_HEIGHT * 4
        lea     edi,[edi+4*ebx]
        rep stosd

        cRet    vCopyMasks

endProc vCopyMasks

;-------------------------Private-Routine-------------------------------;
; Flip the scans in the buffer
;
; Entry:
;       ESI --> start of first scan line
;       ECX     = number of scan lines
;
; Returns:
;       None
;
; Error Returns:
;       None
;
;-----------------------------------------------------------------------;

cProc   vFlipMask
        lea     edi,[esi+4*ecx]
        shr     ecx,1

flip_next_scan:
        sub     edi,4                   ;decrement target pointer

        mov     eax,[esi]               ;Load
        mov     edx,[edi]
        mov     [edi],eax               ;Swap
        mov     [esi],edx               ;Save

        add     esi,4                   ;increment source pointer

        loop    flip_next_scan

        cRet    vFlipMask

endProc vFlipMask

page

;--------------------------Public-Routine-------------------------------;
; create_masks_1_thru_7
;
; The pointer shape has been copied into our memory.  Now pre-rotate
; the pointer for all the different alignments.  Simply put:
;
;                 pointer image              fill byte
;
;       |ABCDEFGH|IJKLMNOP|QRSTUVWX|YZabcdef|00000000|
;
;  becomes this for (x mod 8) = 1
;
;       |0ABCDEFG|HIJKLMNO|PQRSTUVW|XYZabcde|f0000000|
;
;  and this for (x mod 8) = 2
;
;       |00ABCDEF|GHIJKLMN|OPQRSTUV|WXYZabcd|ef000000|
;
; Entry:
;       EDI --> first byte of mask for phase alignment 1
;       EDX --> first byte of mask for phase alignment 0
;       ECX     =  (mask length * 7) / (WORK_WIDTH * 2)
;       AL      =  fill value (00 or FF)
; Returns:
;       None
; Error Returns:
;       None
; Registers Preserved:
;       BX,SI,BP
; Registers Destroyed:
;       AX,CX,DX,DI
; Calls:
;       none
;
;-----------------------------------------------------------------------;

cProc   create_masks_1_thru_7

; Since the masks are contiguous, we can do it as one very long loop,
; where the results of rotating the previous mask by one becomes the
; source for the next rotate by one.

        xchg    esi, edx
        add     al, al                  ;Set initial 'C' value

rotate_next_two_scans:
        lodsw
        rcr     al, 1
        rcr     ah, 1
        stosw

        lodsw
        rcr     al, 1
        rcr     ah, 1
        stosw

        lodsw
        rcr     al, 1
        rcr     ah, 1
        stosw

        lodsw
        rcr     al, 1
        rcr     ah, 1
        stosw

        lodsw
        rcr     al, 1
        rcr     ah, 1
        stosw

        loop    rotate_next_two_scans

        .ERRNZ  (WORK_WIDTH*2)-10

        xchg    esi, edx

        cRet    create_masks_1_thru_7

endProc create_masks_1_thru_7
page

;--------------------------Public-Routine-------------------------------;
; vYankPointer
;
;   Move the pointer off the right edge of the screen
;
; Returns:
;       per vDrawPointer
; Error Returns:
;       per vDrawPointer
; Registers Preserved:
;       per vDrawPointer
; Registers Destroyed:
;       per vDrawPointer
; Calls:
;       per vDrawPointer
; Restrictions:
;       per vDrawPointer
;
;-----------------------------------------------------------------------;

cProc   vYankPointer,8,<    \
        ppdev:ptr PDEV,     \
        flPtr:DWORD         >

        mov     eax,ppdev
        cCall   vDrawPointer,<eax,[eax].PDEV_sizlsurf.sizl_cx, \
                              [eax].PDEV_sizlsurf.sizl_cy,flPtr>
yp_exit:
        cRet    vYankPointer

endProc vYankPointer

page

;--------------------------Public-Routine-------------------------------;
; vDrawPointer
;
;   The pointer shape is drawn on the screen at the given coordinates.
;   If it currently is displayed on the screen, it will be removed
;   from the old location first.
;
; Entry:
; Returns:
;       None
; Error Returns:
;       None
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       compute_rects
;       clip_rects
;       and_into_work
;       copy_things_around
;       xor_to_screen
;       color_pointer_to_screen
; Restrictions:
;       None
;
;-----------------------------------------------------------------------;

cProc   vDrawPointer,16,<   \
        USES esi edi ebx,   \
        ppdev:ptr PDEV,     \
        ptlX:DWORD,         \
        ptlY:DWORD,         \
        flPtr:DWORD         >

        local   lNextScan :dword        ;width of bitmap in bytes
        local   ulNextSrcScan :dword    ;offset to next source scan line
        local   jPostWrapWidth :dword   ;post-wrap width
        local   pSaveAddr :dword        ;virtual address of save area
        local   jSaveSourceXY :dword    ;X and Y coordinates of source point in
                                        ; save area
        local   jWorkSourceXY :dword    ;X and Y coordinates of source point in
                                        ; work area
        local   jNextSaveSourceY :dword ;Y coordinate of start source point in
                                        ; save area for next bank
        local   jNextWorkSourceY :dword ;Y coordinate of start source point in
                                        ; work area for next bank
        local   pWorkingSave :dword     ;save area virtual address
        local   ulScanMinusWorkWidth :dword ;distance to next scan, minus the
                                            ; width of the work area
        local   ulCurrentTopScan :dword ;top scan line to which to draw in
                                        ; current bank
        local   jScansInBank :dword     ;# of scan to do in current bank
        local   cjTotalScans :dword     ;# of scans left in operation
        local   ulPtrBankScan :dword    ;last scan line in pointer work bank
        local   pdsurf :ptr DEVSURF     ;pointer to surface structure to which
                                        ; we're drawing
                                        ;variables used by cps_do_a_pass
        local   ulDeltaScreen :dword    ;offset from one scan to next
        local   ulOffsetSave :dword     ;offset in save area
        local   ulOffsetMask :dword     ;offset within mask
        local   iPlaneMask :dword
                                        ;variables used by
                                        ; color_pointer_to_screen
        local   pDest :dword            ;pointer to destination address
        local   prclSource :dword       ;pointer to source rectangle
        local   cyScreen :dword         ;height of screen in scan lines

;-----------------------------------------------------------------------;

        cld

        mov     ecx,ppdev
        mov     eax,[ecx].PDEV_sizlSurf.sizl_cy
        mov     cyScreen,eax

        mov     ecx,[ecx].PDEV_pdsurf
        mov     pdsurf,ecx              ;pointer to target surface

        mov     eax,[ecx].dsurf_ulPtrBankScan
        mov     ulPtrBankScan,eax       ;last scan line in pointer work bank

        mov     eax,[ecx].dsurf_lNextScan
        mov     lNextScan,eax           ;width of bitmap

        mov     eax, flPtr
        mov     flPointer,eax           ;save flags
        mov     edi, ppdNew             ;--> new pointer's data goes here
        mov     esi, ppdOld             ;--> old pointer's data
        mov     eax, ptlX               ;EAX = ptlX
        mov     ebx, eax
        and     ebx, 7
        mov     edx, pabAndMasks[ebx * 4]
        mov     pAndXor, edx
        mov     edx, pabClrMasks[ebx * 4]
        mov     pColor, edx
        mov     ebx, PD_VALID           ;Assume visible
        sar     eax, 3                  ;Compute starting byte address (set 'S')
        mov     [edi].pd_rd.rd_ptlScreen.ptl_x, eax

;-----------------------------------------------------------------------;
; Compute any X clipping parameters for the new pointer image.
;-----------------------------------------------------------------------;

        js      short clip_lhs_of_pointer     ;If X is negative, lhs clipping needed
        sub     eax, ptlBotRightClip.ptl_x
        jle     short done_x_clipping
        mov     bh,PD_CLIP_RIGHT        ;EAX = amount to clip off rhs
        jmp     short finish_x_clip

clip_lhs_of_pointer:
        neg     eax                     ;Want |eax|
        mov     bh, PD_CLIP_LEFT

finish_x_clip:
        cmp     eax, sizlMask.sizl_cx   ;Width of pointer in bytes
        jge     short not_visible             ;Clipped away too much
        or      bl, bh
done_x_clipping:

;-----------------------------------------------------------------------;
; Compute any Y clipping parameters for the new pointer image.
;-----------------------------------------------------------------------;

        mov     eax, ptlY
        mov     [edi].pd_rd.rd_ptlScreen.ptl_y, eax
        or      eax, eax
        js      short clip_top_of_pointer     ;If Y is negative, top clipping needed
        sub     eax, ptlBotRightClip.ptl_y
        jle     short done_y_clipping
        mov     bh, PD_CLIP_BOTTOM      ;AX = amount to clip off bottom
        jmp     short finish_y_clip


;-----------------------------------------------------------------------;
; not_visible - the pointer will be totally off the screen.  All we
; have to do is to determine if any part of the old pointer is visible
; and remove it if so.
;-----------------------------------------------------------------------;

not_visible:
        test    [esi].pd_fb, PD_VALID
        jz      draw_pointer_exit       ;No new, no old
        xor     eax, eax
        mov     [edi].pd_fb, al         ;Clear PD_VALID flag, clipping flags
        mov     WORD PTR fbAndRead, ax  ;Nothing to read/and/xor

        .ERRNZ  fbXor-fbAndRead-1

        mov     fbFlush, FB_OLD_PTR     ;Write old to screen
        jmp     short rectangles_been_computed


;-----------------------------------------------------------------------;
; Continue with Y clipping
;-----------------------------------------------------------------------;

clip_top_of_pointer:
        neg     eax                     ;Want |eax|
        mov     bh,PD_CLIP_TOP

finish_y_clip:
        cmp     eax, sizlMask.sizl_cy   ;Height of pointer in scans
        jge     short not_visible             ;Clipped away too much
        or      bl, bh

done_y_clipping:
        mov     [edi].pd_fb, bl         ;Set clipping flags and show valid

;-----------------------------------------------------------------------;
; It looks like some portion of the pointer image will be visible.
; Initialize some of the new pointer's POINTER_DATA structure.
;-----------------------------------------------------------------------;

        mov     ax, sizbMask            ;ptbSave will be set by compute_rects
        mov     [edi].pd_rd.rd_sizb, ax

        .ERRNZ  (SIZE SIZEB) - 2

        xor     ax, ax
        mov     [edi].pd_rd.rd_ptbWork, ax

        .ERRNZ  (SIZE POINTB) - 2

;-----------------------------------------------------------------------;
; Compute the rectangles describing how things overlap and then clip
; them.
;-----------------------------------------------------------------------;

        call    compute_rects
rectangles_been_computed:

;-----------------------------------------------------------------------;
; Set WRITE mode of EGA/VGA
;-----------------------------------------------------------------------;

        mov     dx, EGA_BASE + GRAF_ADDR
        mov     ax, DR_SET SHL 8 + GRAF_DATA_ROT
        out     dx, ax

        mov     ax, M_PROC_WRITE SHL 8 + GRAF_MODE
        out     dx, ax

        mov     ax, 0FF00h + GRAF_BIT_MASK
        out     dx, ax

        mov     ax, GRAF_ENAB_SR
        out     dx, ax

        mov     dl, SEQ_ADDR
        mov     ax, MM_ALL SHL 8 + SEQ_MAP_MASK
        out     dx, ax

        call    clip_rects

        mov     eax,flPointer           ;lousy hack
        or      eax,eax
        jnz     short draw_color_pointer      ;Color pointer?

;-----------------------------------------------------------------------;
;                       Draw B/W Pointer
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; AND from the save area and the screen into the work area
;-----------------------------------------------------------------------;

        mov     al, fbAndRead
        or      al, al
        jz      short done_and_portion
        call    and_into_work
done_and_portion:

;-----------------------------------------------------------------------;
; Copy from save area to the screen and from the screen to the save
; area.
;-----------------------------------------------------------------------;

        mov     ax, WORD PTR fbFlush    ;Assume nothing to copy to/from save

        .ERRNZ  fbAndRead-fbFlush-1

        or      ah, al
        jz      short copied_things_around
        call    copy_things_around
copied_things_around:


;-----------------------------------------------------------------------;
; XOR from the work area to the screen
;-----------------------------------------------------------------------;

        mov     al, fbXor
        or      al, al
        jz      short pointer_drawn
        call    xor_to_screen
        jmp     short pointer_drawn

;-----------------------------------------------------------------------;
;                       Draw Color Pointer
;-----------------------------------------------------------------------;

draw_color_pointer:

;-----------------------------------------------------------------------;
; Copy from save area to the screen and from the screen to the save area.
;-----------------------------------------------------------------------;

        mov     ax, WORD PTR fbFlush    ;Assume nothing to copy to/from save

        .ERRNZ  fbAndRead-fbFlush-1

        or      ah, al
        jz      short things_copied_around
        call    copy_things_around
things_copied_around:

;-----------------------------------------------------------------------;
; Draw color pointer to screen
;-----------------------------------------------------------------------;

        test    fbXor, 0FFh
        jz      short pointer_drawn
        call    color_pointer_to_screen ;Planes must all be enabled

pointer_drawn:
        mov     eax,ppdNew
        mov     edx,ppdOld
        mov     ppdOld,eax
        mov     ppdNew,edx
draw_pointer_exit:

;-----------------------------------------------------------------------;
; Reset WRITE mode of EGA/VGA to WRITE MODE 0, READ MODE 1
;-----------------------------------------------------------------------;

        mov     al, MM_ALL              ;Set Map Mask for all write
        mov     dx, EGA_BASE + SEQ_DATA
        out     dx, al

        mov     dx, EGA_BASE + GRAF_ADDR
        mov     ax, DR_SET SHL 8 + GRAF_DATA_ROT
        out     dx, ax

        mov     ax, M_PROC_WRITE SHL 8 + GRAF_MODE
        out     dx, ax

        mov     ax, 0FF00h + GRAF_BIT_MASK
        out     dx, ax

        mov     ax, GRAF_ENAB_SR
        out     dx, ax

        cRet    vDrawPointer

;-----------------------------------------------------------------------;
; The following routines would be procs, outside the scope of
; vDrawPointer, but then they couldn't access vDrawPointer's stack
; frame, which they need to.
;-----------------------------------------------------------------------;

page

;--------------------------Private-Routine------------------------------;
; compute_rects
;
; This routine computes the rectangles which describe what needs to be
; read/ANDed/XORed/written.  The rectangles are unclipped.  Clipping
; must be performed by a different routine.
;
; Entry:
;       AX  =  0
;       SI --> currently displayed pointer's rectangle data
;       DI --> new pointer's rectangle data
; Returns:
;       None
; Error Returns:
;       None
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

compute_rects:

        push    ebp

        mov     WORD PTR fbFlush, ax    ;Assume nothing to restore to screen

        .ERRNZ  fbAndRead-fbFlush-1     ;Assume nothing to read/And to work

        mov     fbXor, FB_NEW_PTR       ;Assume new pointer is XORed to screen
        test    [esi].pd_fb, PD_VALID
        jz      short old_pointer_is_invalid

;-----------------------------------------------------------------------;
; There is a pointer currently displayed on the screen.  If the new
; pointer is far enough away from the old pointer, then we won't have
; to deal with overlap.
;-----------------------------------------------------------------------;

old_pointer_is_valid:
        mov     eax, [edi].pd_rd.rd_ptlScreen.ptl_x
        sub     eax, [esi].pd_rd.rd_ptlScreen.ptl_x
        mov     bl, al                  ;BL = delta x
        or      eax, eax                ;EAX = |EAX|
        jns     short @F
        neg     eax
@@:
        cmp     eax, sizlMaxDelta.sizl_cx
        jae     rects_are_disjoint
        mov     eax, [edi].pd_rd.rd_ptlScreen.ptl_y
        sub     eax, [esi].pd_rd.rd_ptlScreen.ptl_y
        mov     bh, al                  ;BH = delta y
        or      eax, eax                ;EAX = |EAX|
        jns     short @F
        neg     eax
@@:
        cmp     eax, sizlMaxDelta.sizl_cy
        jb      short rects_overlap           ;(or are identical)

;-----------------------------------------------------------------------;
; The rectangles will be disjoint.  Set up to restore under the old
; pointer, copy the new rectangle to the save area, and AND it into
; the work area.
;-----------------------------------------------------------------------;

rects_are_disjoint:
        mov     fbFlush, FB_OLD_PTR

;-----------------------------------------------------------------------;
; The save area image is invalid, so we won't have to copy it to the
; screen or AND some part of it into the work area.  We'll simply want
; to copy the new area to the save area and AND it into the work area.
; This can be treated the same as if the rectangles are identical,
; except we want to reset the origin within the save buffer.
;-----------------------------------------------------------------------;

old_pointer_is_invalid:
        mov     ax, ptbInitOrigin       ;Reset origin within the save area
        mov     [edi].pd_rd.rd_ptbSave,ax

        .ERRNZ  (SIZE POINTB) - 2

        mov     fbAndRead, FB_NEW_PTR   ;Copy new ptr to save and XOR to work
        jmp     compute_rects_exit


;-----------------------------------------------------------------------;
; The rectangles overlap in some manner.  Compute how the rectangles,
; will overlap, setting up the various needed rectangle structures as
; we go.
;
; The only hope we have of computing the overlap rectangle is to
; initialize it to some known state and adjusting it as we process
; dx and dy.  We will initialize it to be the upper left hand corner
; of the old pointer rectangle.
;
; Currently:
;       AX     =  old pointer's pd_rd.rd_ptbSave
;       BH     =  dy
;       BL     =  dx (negative)
;       SI     --> old pointer's rd_ptlScreen
;       DI     --> new pointer rectangle
;-----------------------------------------------------------------------;

rects_overlap:

; Set old pointer's save buffer (X,Y) into the overlap rectangle.
; Also set this as the save buffer origin for the new pointer rectangle.

        lodsw

        .ERRNZ  pd_rd.rd_ptbSave

        mov     rdOverlap.rd_ptbSave, ax
        mov     [edi].pd_rd.rd_ptbSave, ax
        mov     dx, ax

; Set old pointer's screen (X,Y) into the overlap rectangle as the
; screen origin.

        lodsd

        .ERRNZ  rd_ptlScreen-rd_ptbSave-2
        .ERRNZ  ptl_x

        mov     rdOverlap.rd_ptlScreen.ptl_x, eax
        mov     ebp, eax
        lodsd

        .ERRNZ  ptl_y-ptl_x-4

        mov     rdOverlap.rd_ptlScreen.ptl_y, eax
        mov     esi, eax

; Set the mask width and height into the overlap rectangle

        mov     ax, sizbMask
        mov     rdOverlap.rd_sizb, ax

        .ERRNZ  sizb_cy-sizb_cx-1
        .ERRNZ  (SIZE SIZEB) - 2

        mov     ecx, eax

        .ERRNZ  sizb_cy-sizb_cx-1

; Set the work buffer origin to be zero

        xor     eax, eax
        mov     rdOverlap.rd_ptbWork, ax

; Show that the overlap rectangle exists and should be ANDed into the
; work area, then dispatch based on dx,dy.

        mov     fbAndRead, FB_OVERLAP
        or      bl, bl                  ; Dispatch based on dx
        jg      short moved_right
        jl      short moved_left
        jmp     processed_x_overlap


;-----------------------------------------------------------------------;
; The starting X of the new rectangle is to be set as the new lhs.
;
;      * nnnnn $ onononono oooooooo     * = start of new rectangle
;                         o       o     $ = start of old rectangle
;      n   |   o    |     n   |   o
;      n   |   n          o   |   o
;      n   |   o    O     n       o
;      n       n    v     o   F   o
;      n   R   o    e     n   l   o
;      n   e   n    r     o   u   o
;      n   a   o    l     n   s   o
;      n   d   n    a     o   h   o
;      n       o    p     n       o
;      n   |   n          o   |   o
;      n   |   o    |     n   |   o
;      n   |   n    |     o   |   o
;      n       o          n       o
;      nnnnnnnn nonononono oooooooo
;
;      |-- dx -|          |-- dx -|
;      |-sizbMask.sizb_cx-|
;
;
; Currently:
;       AX =    0
;       BH =    dy
;       BL =    dx (negative)
;       CH =    buffer height
;       CL =    buffer width
;       DH =    old pointer's Y coordinate in save area
;       DL =    old pointer's X coordinate in save area
;       SI =    old pointer's Y screen coordinate
;       BP =    old pointer's X screen coordinate
;       DI =    --> new pointer's RECT_DATA
;-----------------------------------------------------------------------;

moved_left:

; The Read buffer will map into the work area at (0,0).

        mov     rdReadX.rd_ptbWork, ax

; The width of the overlap area is sizbMask.sizb_cx - |dx|.

        mov     al, bl                  ;BL = dx (which is negative)
        add     al, cl                  ;CL = sizbMask.sizb_cx
        mov     rdOverlap.rd_sizb.sizb_cx, al

; The flush rectangle's X is ptlScreen.ptl_x + sizbMask.sizb_cx - |dx|.

        add     eax, ebp                ;AX = sizbMask.sizb_cx - |dx|
        mov     rdFlushX.rd_ptlScreen.ptl_x, eax

; Compute where in the save buffer the new lhs will map to.  We must
; update the new pointer's rectangle to reflect where this origin is.

        mov     eax, edx                ;DX = old ptbSave
        add     al, bl                  ;BL = dx (negative)
        add     ah, bh                  ;BH = dy
        and     eax, ((SAVE_BUFFER_HEIGHT-1) SHL 8) + SAVE_BUFFER_WIDTH-1
        mov     [edi].pd_rd.rd_ptbSave.ptb_x, al
        mov     rdReadX.rd_ptbSave, ax

        .ERRNZ  ptb_y-ptb_x-1

; The origin of the flush rectangle is sizbMask.sizb_cx bytes away
; from the origin of the read rectangle.

        add     al, cl
        and     al, SAVE_BUFFER_WIDTH-1 ;Handle any wrap
        mov     ah, dh
        mov     rdFlushX.rd_ptbSave, ax

; Compute |dx|.  This is the width of the read and flush rectangles.
; The height will be set to the working height.  |dx| is also the
; overlap rectangle's work area X coordinate.

        mov     al, bl                  ;BL = dx (negative)
        neg     al                      ;AL = |dx|
        mov     ah, ch                  ;CH = sizbMask.sizb_cy
        mov     rdFlushX.rd_sizb, ax
        mov     rdReadX.rd_sizb, ax

        .ERRNZ  sizb_cy-sizb_cx-1

        mov     rdOverlap.rd_ptbWork.ptb_x, al

; The Read buffer's screen address is the ptlScreen stored in the new
; pointer's RECT_DATA.

        mov     eax, [edi].pd_rd.rd_ptlScreen.ptl_x
        jmp     short finish_x_overlap



;-----------------------------------------------------------------------;
; The starting X of the new rectangle is somewhere in the middle
; of the old rectangle.
;
;      $ ooooo * onononono nnnnnnn     * = start of new rectangle
;      o       n          o      n     $ = start of old rectangle
;      o   |   o    |     n   |  n
;      o   |   n          o   |  n
;      o       o    O     n   |  n
;      o   F   n    v     o      n
;      o   l   o    e     n   R  n
;      o   u   n    r     o   e  n
;      o   s   o    l     n   a  n
;      o   h   n    a     o   d  n
;      o       o    p     n      n
;      o   |   n          o   |  n
;      o   |   o    |     n   |  n
;      o   |   n    |     o   |  n
;      o       o          n      n
;      oooooooo nonononono nnnnnnn
;
;      |-- dx -|          |-- dx -|
;      |-sizbMask.sizb_cx-|
;
;
; Currently:
;       AX =    0
;       BH =    dy
;       BL =    dx (positive)
;       CH =    buffer height
;       CL =    buffer width
;       DH =    old pointer's Y coordinate in save area
;       DL =    old pointer's X coordinate in save area
;       SI =    old pointer's Y screen coordinate
;       BP =    old pointer's X screen coordinate
;       DI =    --> new pointer's RECT_DATA
;-----------------------------------------------------------------------;

moved_right:

; The screen X origin of the overlap rectangle is the new rectangle's
; X coordinate, or the old rectangle's X coordinate + |dx|.

        mov     al, bl
        add     rdOverlap.rd_ptlScreen.ptl_x, eax

; The width of the read and flush buffers is |dx|.  The height is
; just the working height.

        mov     ah, ch                  ;CH = sizbMask.sizb_cy
        mov     rdFlushX.rd_sizb, ax
        mov     rdReadX.rd_sizb, ax

        .ERRNZ  sizb_cy-sizb_cx-1

; Compute where the new lhs is in the save area.  This will be the lhs
; of both the new rectangle and the overlap area.

        add     al, dl                  ;DL = ptbSave.ptb_x
        and     al, SAVE_BUFFER_WIDTH-1 ;Handle any wrap
        mov     [edi].pd_rd.rd_ptbSave.ptb_x, al
        mov     rdOverlap.rd_ptbSave.ptb_x, al

; The data to be flushed will come from the lhs of the old rectangle

        mov     eax, edx
        mov     rdFlushX.rd_ptbSave, ax

; The data to be read will go at the old lhs + sizbMask.sizb_cx.  The
; Y component will be the new Y.

        add     al, cl
        add     ah, bh
        and     eax, ((SAVE_BUFFER_HEIGHT-1) SHL 8) + SAVE_BUFFER_WIDTH-1
        mov     rdReadX.rd_ptbSave, ax

        .ERRNZ  ptb_y-ptb_x-1

; The X screen origin of the flush buffer is the old ptlScreen.ptl_x

        mov     rdFlushX.rd_ptlScreen.ptl_x, ebp

; The width of the overlap rectangle is sizbMask.sizb_cx - |dx|.  This
; is also the X offset into the work area of the read rectangle.
; The Y offset is zero.

        mov     al, cl
        sub     al, bl
        mov     rdOverlap.rd_sizb.sizb_cx, al
        movsx   eax, al
        mov     rdReadX.rd_ptbWork, ax

        .ERRNZ  ptb_y-ptb_x-1

; The screen Y origin of the read rectangle is the new rectangle's Y
; coordinate.  The X coordinate can be computed as the old rectangles
; X coordinate + the save width

        mov     al, cl
        add     eax, ebp

finish_x_overlap:
        mov     rdReadX.rd_ptlScreen.ptl_x, eax
        mov     eax, [edi].pd_rd.rd_ptlScreen.ptl_y
        mov     rdReadX.rd_ptlScreen.ptl_y, eax

; The Y address of the flush rectangle on the screen is ptlScreen.ptl_y.

        mov     rdFlushX.rd_ptlScreen.ptl_y, esi

; Set the flags to show that there is some form of X overlap.  We want
; to show that there is some X rectangle to be read/flushed, and that
; there is some overlap rectangle to be processed.

        or      WORD PTR fbFlush, (FB_READ_X SHL 8) + FB_FLUSH_X

        .ERRNZ  fbAndRead-fbFlush-1

        xor     eax, eax

processed_x_overlap:
        or      bh, bh
        jg      short moved_down
        jz      short processed_y_overlap_relay


;-----------------------------------------------------------------------;
; The starting Y of the new rectangle is to be set as the new top.
;
;   * = start of new rectangle
;   $ = start of old rectangle
;
;      $ oooooooooooooooooooooooooo   ---  ---
;      o                          o    |    |
;      o -------- Read ---------- o    dy   |
;                                 o    |    |
;      * onononononononononononono    ---
;                                 n       sizbMask.sizb_cy - dy
;      n                          o
;      o ------- Overlap -------- n         |
;      n                          o         |
;      o                          n         |
;       ononononononononononononon    ---  ---
;      n                          n    |
;      n -------- Write --------- n    dy
;      n                          n    |
;      nnnnnnnnnnnnnnnnnnnnnnnnnnnn   ---
;
;
;
; Currently:
;       AX =    0
;       BH =    dy (negative)
;       BL =    dx
;       CH =    buffer height
;       CL =    buffer width
;       DH =    old pointer's Y coordinate in save area
;       DL =    old pointer's X coordinate in save area
;       SI =    old pointer's Y screen coordinate
;       BP =    old pointer's X screen coordinate
;       DI =    --> new pointer's RECT_DATA
;-----------------------------------------------------------------------;

moved_up:

; The Read buffer will map into the work area at (0,0).

        mov     rdReadY.rd_ptbWork, ax

; The height of the overlap area is sizbMask.sizb_cy - |dy|.

        mov     al, bh                  ;BH = dy (which is negative)
        add     al, ch                  ;CH = sizbMask.sizb_cy
        mov     rdOverlap.rd_sizb.sizb_cy, al

; The flush rectangle's Y is ptlScreen.ptl_y + sizbMask.sizb_cy - |dy|.

        add     eax, esi                ;EAX = sizbMask.sizb_cy - |dy|
        mov     rdFlushY.rd_ptlScreen.ptl_y, eax

; Compute where in the save buffer the new top will map to.  We must
; update the new pointer's rectangle to reflect where this origin is.

        mov     eax, edx                ;DX = old ptbSave
        add     ah, bh                  ;BH = dy (negative)
        add     al, bl
        and     eax, ((SAVE_BUFFER_HEIGHT-1) SHL 8) + SAVE_BUFFER_WIDTH-1
        mov     [edi].pd_rd.rd_ptbSave.ptb_y, ah
        mov     rdReadY.rd_ptbSave, ax

        .ERRNZ  ptb_y-ptb_x-1

; The origin of the flush rectangle is sizbMask.sizb_cy scans away
; from the origin of the read rectangle.

        add     ah, ch
        and     ah, SAVE_BUFFER_HEIGHT-1 ;Handle any wrap
        mov     al, dl
        mov     rdFlushY.rd_ptbSave, ax

; Compute |dy|.  This is the height of the read and flush rectangles.
; The width will be set to the working width.  |dy| is also the
; overlap rectangle's work area Y coordinate.

        mov     ah, bh                  ;BH = dy
        neg     ah                      ;Make it |dy|
        mov     al, cl                  ;CL = sizbMask.sizb_cx
        mov     rdFlushY.rd_sizb, ax
        mov     rdReadY.rd_sizb, ax

        .ERRNZ  sizb_cy-sizb_cx-1

        mov     rdOverlap.rd_ptbWork.ptb_y, ah

; The Read buffer's screen address is the ptlScreen stored in the new
; pointer's RECT_DATA.

        mov     eax, [edi].pd_rd.rd_ptlScreen.ptl_y
        jmp     short finish_y_overlap

processed_y_overlap_relay:
        jmp     processed_y_overlap



;-----------------------------------------------------------------------;
; The starting Y of the new rectangle is somewhere in the middle
; of the old rectangle.
;
;   * = start of new rectangle
;   $ = start of old rectangle
;
;      $ oooooooooooooooooooooooooo   ---  ---
;      o                          o    |    |
;      o -------- Write --------- o    dy   |
;                                 o    |    |
;      * onononononononononononono    ---
;                                 n       sizbMask.sizb_cy - dy
;      n                          o
;      o ------- Overlap -------- n         |
;      n                          o         |
;      o                          n         |
;       ononononononononononononon    ---  ---
;      n                          n    |
;      n -------- Read ---------- n    dy
;      n                          n    |
;      nnnnnnnnnnnnnnnnnnnnnnnnnnnn   ---
;
;
; Currently:
;       AX =    0
;       BH =    dy (positive)
;       BL =    dx
;       CH =    buffer height
;       CL =    buffer width
;       DH =    old pointer's Y coordinate in save area
;       DL =    old pointer's X coordinate in save area
;       SI =    old pointer's Y screen coordinate
;       BP =    old pointer's X screen coordinate
;       DI =    --> new pointer's RECT_DATA
;-----------------------------------------------------------------------;

moved_down:

; The screen Y origin of the overlap rectangle is the new rectangle's
; Y coordinate, or the old rectangle's Y coordinate + |dy|.

        mov     al, bh
        add     rdOverlap.rd_ptlScreen.ptl_y, eax

; Compute where the new top is.  This will be both the top of the new
; rectangle and the overlap area.

;       mov     al, bh                  ;BH = |dy|
        add     al, dh                  ;DH = ptbSave.ptb_y
        and     al, SAVE_BUFFER_HEIGHT-1 ;CH = sizbMask.sizb_cy
        mov     [edi].pd_rd.rd_ptbSave.ptb_y, al
        mov     rdOverlap.rd_ptbSave.ptb_y, al

; The height of the read and flush buffers is |dy|.  The width is
; just the working width.

        mov     ah, bh
        mov     al, cl                  ;CL = sizbMask.sizb_cx
        mov     rdFlushY.rd_sizb, ax
        mov     rdReadY.rd_sizb, ax

        .ERRNZ  sizb_cy-sizb_cx-1

; The data to be flushed will come from the top of the old rectangle

        mov     eax, edx
        mov     rdFlushY.rd_ptbSave, dx

; The data to be read will go at the old top + sizbMask.sizb_cy

        add     ah, ch
        add     al, bl
        and     eax, ((SAVE_BUFFER_HEIGHT-1) SHL 8) + SAVE_BUFFER_WIDTH-1
        mov     rdReadY.rd_ptbSave, ax

        .ERRNZ  ptb_y-ptb_x-1

; The Y screen origin of the flush buffer is the old ptlScreen.ptl_y

        mov     rdFlushY.rd_ptlScreen.ptl_y, esi

; The height of the overlap rectangle is sizbMask.sizb_cy - |dy|.
; This is also the Y offset into the work area of the read rectangle.
; The X offset is zero.

        mov     ah, ch
        sub     ah, bh
        mov     rdOverlap.rd_sizb.sizb_cy, ah
        xor     al, al
        mov     rdReadY.rd_ptbWork, ax

        .ERRNZ  ptb_y-ptb_x-1

; The screen X origin of the read rectangle is the new rectangle's X
; coordinate.  The Y coordinate can be computed as the old
; rectangle's Y coordinate + the save height

        mov     al, ch
        xor     ah, ah
        add     eax, esi

finish_y_overlap:
        mov     rdReadY.rd_ptlScreen.ptl_y, eax
        mov     eax, [edi].pd_rd.rd_ptlScreen.ptl_x
        mov     rdReadY.rd_ptlScreen.ptl_x, eax

; The X address of the flush rectangle on the screen is ptlScreen.ptl_x.

        mov     rdFlushY.rd_ptlScreen.ptl_x, ebp

; Set the flags to show that there is some form of Y overlap.  We want
; to show that there is some Y rectangle to be read/flushed, and that
; there is some overlap rectangle to be processed.

        or      WORD PTR fbFlush, ((FB_READ_Y OR FB_OVERLAP) SHL 8) + FB_FLUSH_Y

        .ERRNZ  fbAndRead-fbFlush-1


;-----------------------------------------------------------------------;
; We have computed the seperate X and Y componets of the overlap.  If
; there was both dx and dy, then we have an L shaped area which we'll
; be reading/writing.  In this case, we want to remove the overlapping
; portion of the L.
;-----------------------------------------------------------------------;

        or      bl, bl
        jz      short processed_y_overlap

;-----------------------------------------------------------------------;
; We have something which looks like one of the following:
;
;   ----------               ----------
;  |  flush   |             |  flush   |    dy > 0
;  | f        |             |        f |
;  | l  ----------       ----------  l |    -----
;  | u |      |   |     |   |      | u |      |
;  | s |      |   |     |   |      | s |    limit the "x" rectangles to
;  | h |  1   | r |     | r |   2  | h |    this height
;  |   |      | e |     | e |      |   |      |
;   ---|------  a |     | a  ------|---     -----
;      |        d |     | d        |  \
;      |   read   |     |   read   |\  \
;       ----------       ----------  \  \
;                                     \  \_____ The "x" overlap rectangle
;                                      \
;                                       \______ The "y" overlap rectangle
;
;
;
;   ----------               ----------     dy < 0
;  |   read   |             |   read   |
;  | r        |             |        r |
;  | e  ------|---       ---|------  e |    -----
;  | a |      |   |     |   |      | a |      |
;  | d |      | f |     | f |      | d |    limit the "x" rectangles to
;  |   |  3   | l |     | l |   4  |   |    this height
;  |   |      | u |     | u |      |   |      |
;   ----------  s |     | s  ----------     -----
;      |        h |     | h        |
;      |  flush   |     |   flush  |
;       ----------       ----------
;
;
; The corners of the L shape are contained in both the X and Y
; rectangles we just created.  We'll remove the overlap from the
; X rectangles.  To do this, we must subtract |dy| from the height
; stored in the rectangles (which is sizbMask.sizb_cy) and adjust
; X parameters of either the read or flush rectangles.
;
; For cases 1 and 2, we want to adjust X parameters of the flush
; rectangle.  For cases 3 and 4, we want to adjust X parameters
; of the read rectangle.
;
; Currently:
;       BH =    dy
;       BL =    dx
;       CH =    buffer height
;       CL =    buffer width
;       DH =    old pointer's Y coordinate in save area
;       DL =    old pointer's X coordinate in save area
;       SI =    old pointer's Y screen coordinate
;       BP =    old pointer's X screen coordinate
;       DI =    --> new pointer's RECT_DATA
;-----------------------------------------------------------------------;

        mov     al, bh
        mov     ebx, offset FLAT:rdFlushX  ;Assume cases 1 and 2
        or      al, al
        jns     short @F
        mov     ebx, offset FLAT:rdReadX   ;Its cases 3 and 4
        neg     al                      ;|dy|
        add     [ebx].rd_ptbWork.ptb_y, al;Move down in the work area too!
@@:
        mov     cl, [ebx].rd_ptbSave.ptb_y
        add     cl, al
        and     cl, SAVE_BUFFER_HEIGHT-1
        mov     [ebx].rd_ptbSave.ptb_y, cl
        movsx   eax, al

        .ERRNZ  (SAVE_BUFFER_HEIGHT-1) AND 80h

        add     [ebx].rd_ptlScreen.ptl_y, eax
        neg     al
        add     al, ch                  ;sizbMask.sizb_cy - |dy|
        mov     rdFlushX.rd_sizb.sizb_cy, al
        mov     rdReadX.rd_sizb.sizb_cy, al

processed_y_overlap:
compute_rects_exit:

        pop     ebp

        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; clip_rects
;
; This routine clips the rectangles computed by compute_rects.
;
; Entry:
;       None
; Returns:
;       None
; Error Returns:
;       None
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       do_clipping
;
;-----------------------------------------------------------------------;

clip_rects:

        mov     esi, ppdOld             ;--> old POINTER_DATA structure
        mov     dl, [esi].pd_fb
        test    dl, PD_CLIPPED          ;Won't be set if PD_VALID isn't set
        jz      short old_been_clipped

;-----------------------------------------------------------------------;
; The old pointer needs some form of clipping.  This can affect either
; the old pointer's rectangle or rdFlushX and rdFlushY.  Since the old
; pointer's rectangle will be discarded after it is restored, we don't
; care if we write over it's contents.
;-----------------------------------------------------------------------;

        mov     edi, esi                        ;EDI --> rectangle to clip
        mov     bl, fbFlush             ;fbFlush tells us which rects to use
        mov     bh, FB_OLD_PTR
        test    bl, bh
        jnz     short call_do_clip            ;Only have to clip old pointer's rect
        mov     edi, offset FLAT:rdFlushX
        mov     bh, FB_FLUSH_X
        test    bl, bh
        jz      short @F
        call    do_clipping
@@:
        mov     edi, offset FLAT:rdFlushY
        mov     bh, FB_FLUSH_Y
        test    bl, bh
        jz      short @F
call_do_clip:
        call    do_clipping
@@:
        mov     fbFlush, bl

        mov     edi, offset FLAT:rdOverlap
        mov     bl, fbAndRead
        mov     bh, FB_OVERLAP
        test    bl, bh
        jz      short @F
        call    do_clipping
        mov     fbAndRead, bl
@@:
old_been_clipped:


;-----------------------------------------------------------------------;
; The old pointer rectangle has been clipped.  Now see about clipping
; the new pointer rectangle.
;-----------------------------------------------------------------------;

        mov     esi, ppdNew             ;--> new POINTER_DATA structure
        mov     dl, [esi].pd_fb
        test    dl, PD_CLIPPED          ;Won't be set if PD_VALID isn't set
        jz      short new_been_clipped

;-----------------------------------------------------------------------;
; The new rectangle structure needs to be clipped.  This presents a
; minor problem in that we don't want to destroy the screen X,Y and
; buffer X,Y of the pointer's POINTER_DATA structure.  What we'll do
; instead is to copy it to the rdWork structure and update it there.
; We'll also set up to XOR this to the screen instead of the
; POINTER_DATA structure.
;-----------------------------------------------------------------------;

        lodsw
        mov     rdWork.rd_ptbSave, ax

        .ERRNZ  rd_ptbSave
        .ERRNZ  (SIZE POINTB) - 2

        lodsd
        mov     rdWork.rd_ptlScreen.ptl_x, eax

        .ERRNZ  rd_ptlScreen-rd_ptbSave-2
        .ERRNZ  ptl_x

        lodsd
        mov     rdWork.rd_ptlScreen.ptl_y, eax

        .ERRNZ  ptl_y-ptl_x-4

        lodsw
        mov     rdWork.rd_sizb, ax

        .ERRNZ  (SIZE SIZEB) - 2

        lodsw
        mov     rdWork.rd_ptbWork, ax

        .ERRNZ  (SIZE POINTB) - 2

        sub     esi,SIZE RECT_DATA      ;--> to start of POINTER_DATA

        .ERRNZ  (rd_ptbWork+2)-(SIZE RECT_DATA)

; Perform the clipping for the work area.  We know that some part of the
; work area exists, else we wouldn't be here with a valid rectangle.
; If FB_NEW_PTR is set in fbAndRead, then we want to replace it with
; FB_WORK_RECT, else we'll want to process any overlap rectangles.

        mov     edi,offset FLAT:rdWork
        call    do_clipping
        mov     bh,FB_WORK_RECT
        mov     fbXor,bh
        mov     bl,fbAndRead
        mov     fbAndRead,bh    ;assume only work rect to and/read
        test    bl,FB_NEW_PTR
        jnz     short new_been_clipped

        mov     edi, offset FLAT:rdReadX
        mov     bh, FB_READ_X
        test    bl, bh
        jz      short @F
        call    do_clipping
@@:
        mov     edi, offset FLAT:rdReadY
        mov     bh, FB_READ_Y
        test    bl, bh
        jz      short @F
        call    do_clipping
@@:
        mov     fbAndRead, bl

new_been_clipped:

        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; do_clipping
;
; This routine performs the actual clipping of a rectangle using the
; passed POINTER_DATA and RECT_DATA structures.
;
; Entry:
;       BL  =  flag byte
;       BH  =  bit to clear in BL if rectangle is invisible
;       DL  =  pd_fb for [si]
;       SI --> POINTER_DATA structure
;       DI --> RECT_DATA structure
; Returns:
;       BL updated
; Error Returns:
;       None
; Registers Preserved:
;       DX,SI,DI,BP
; Registers Destroyed:
;       AX,BH,CX
; Calls:
;       None
;
;-----------------------------------------------------------------------;


do_clipping:

        .ERRNZ  pd_rd                   ;Must be at offset 0

        xor     eax, eax
        test    dl, PD_CLIP_BOTTOM OR PD_CLIP_TOP
        jz      short y_clipping_done
        mov     ecx, [edi].rd_ptlScreen.ptl_y
        js      short clip_on_bottom_eh?

        .ERRNZ  PD_CLIP_BOTTOM-10000000b

;-----------------------------------------------------------------------;
; Top clipping may have to be performed for this rectangle.
;-----------------------------------------------------------------------;

clip_on_top:
        neg     ecx                        ;If it was negative, then must clip
        jle     short y_clipping_done            ;Was positive, no clipping needed
        sub     [edi].rd_sizb.sizb_cy, cl  ;Compute new height
        jle     short clear_visible_bit          ;Clipped away, nothing visible
        add     [edi].rd_ptbWork.ptb_y, cl ;Move down in work area
        add     cl, [edi].rd_ptbSave.ptb_y ;Move down in save area
        and     cl, SAVE_BUFFER_HEIGHT-1
        mov     [edi].rd_ptbSave.ptb_y, cl
        mov     [edi].rd_ptlScreen.ptl_y, eax
        jmp     short finish_y_clipping


;-----------------------------------------------------------------------;
; Bottom clipping may have to be performed for this rectangle.
;-----------------------------------------------------------------------;

clip_on_bottom_eh?:
        mov     al, [edi].rd_sizb.sizb_cy
        add     ecx, eax
        sub     ecx, cyScreen
        jle     short finish_y_clipping       ;EAX = amount to clip if positive
        sub     al, cl                  ;Compute new height
        jle     short clear_visible_bit       ;Clipped away, nothing visible
        mov     [edi].rd_sizb.sizb_cy, al
finish_y_clipping:
        xor     eax, eax
y_clipping_done:


        test    dl, PD_CLIP_LEFT OR PD_CLIP_RIGHT
        jz      short x_clipping_done
        mov     ecx, [edi].rd_ptlScreen.ptl_x
        test    dl, PD_CLIP_RIGHT
        jnz     short clip_on_rhs

;-----------------------------------------------------------------------;
; lhs clipping may have to be performed for this rectangle.
;-----------------------------------------------------------------------;

clip_on_lhs:
        neg     ecx                     ;If it was negative, then must clip
        jle     short x_clipping_done         ;Was positive, no clipping needed
        sub     [edi].rd_sizb.sizb_cx, cl ;Compute new width
        jle     short clear_visible_bit       ;Clipped away, nothing visible
        add     [edi].rd_ptbWork.ptb_x, cl;Move right in work area
        add     cl, [edi].rd_ptbSave.ptb_x;Move right in save area
        and     cl, SAVE_BUFFER_WIDTH-1
        mov     [edi].rd_ptbSave.ptb_x, cl
        mov     [edi].rd_ptlScreen.ptl_x, eax
        jmp     short x_clipping_done


;-----------------------------------------------------------------------;
; rhs clipping may have to be performed for this rectangle.
;-----------------------------------------------------------------------;

clip_on_rhs:
        mov     al,[edi].rd_sizb.sizb_cx
        add     ecx,eax
        sub     ecx,lNextScan
        jle     short x_clipping_done         ;EAX = amount to clip if positive
        sub     al,cl                   ;Compute new height
        jle     short clear_visible_bit       ;Clipped away, nothing visible
        mov     [edi].rd_sizb.sizb_cx, al
x_clipping_done:
        xor     bh,bh                   ;0 to cancel following XOR

clear_visible_bit:
        xor     bl,bh                   ;Update visible bit
        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; xor_to_screen
;
;   The work area is XORed with the XOR mask and placed on the screen
;
; Entry:
;       AL = fbXor
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

        .ERRNZ  pd_rd                   ;Must be at offset 0

xor_to_screen:
        xor     ebx, ebx                ;Zero will be useful soon
        shr     al, 1                   ;Set 'C' to FB_WORK_RECT bit

        .ERRNZ  FB_WORK_RECT-00000001b

;-----------------------------------------------------------------------;
; Program the EGA for XOR mode.  This will be done using M_PROC_WRITE,
; M_DATA_READ, DR_XOR, and setting GRAF_BIT_MASK to FF.  The normal
; sequence of events will have left the bitmask register with 00h and
; the mode register in AND mode.
;-----------------------------------------------------------------------;

        mov     dx, EGA_BASE + GRAF_ADDR
        mov     ax, 0FF00h + GRAF_BIT_MASK
        out     dx, ax                  ;Enable all bits
        mov     ax, DR_XOR SHL 8 + GRAF_DATA_ROT
        out     dx, ax

;-----------------------------------------------------------------------;
; Compute the offset from the start of the work area and the XOR mask
; (its the same value).  If we're to use the new pointer's rectangle,
; then this offset is zero.
;-----------------------------------------------------------------------;

        mov     esi,ppdNew              ;assume new pointer is in use
        jnc     short have_xor_mask_offset    ;EBX = 0 is offset

        .ERRNZ  FB_WORK_RECT-00000001b
        .ERRE   FB_NEW_PTR-00000001b

        mov     esi,offset FLAT:rdWork          ;The work area (we be clipping)
        movzx   eax,WORD PTR [esi].rd_ptbWork   ;Get origin in work area
        xchg    ah, bl                  ;BX = ptbWork.ptb_y, AX = ptbWork.ptb_x
        add     eax,ebx                         ;*1 + X component
        add     ebx,ebx                         ;*2
        add     ebx,ebx                         ;*4
        add     ebx,eax                         ;*5 + X = start from work/mask

        .ERRNZ  WORK_WIDTH-5

have_xor_mask_offset:


; Map the proper bank into the destination window for the top destination
; scan line.

        mov     edi,pdsurf
        mov     edx,[esi].rd_ptlScreen.ptl_y
        mov     ulCurrentTopScan,edx    ;remember where the top dest scan is
        cmp     edx,[edi].dsurf_rcl2WindowClipD.yTop ;is xor top less than
                                                     ; current dest bank?
        jl      short xts_map_init_bank              ;yes, map in proper bank
        cmp     edx,[edi].dsurf_rcl2WindowClipD.yBottom ;xor top greater than
                                                        ; current dest bank?
        jl      short xts_init_bank_mapped      ;no, proper bank already mapped
xts_map_init_bank:

; Map bank containing the top destination (screen) scan line into dest window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl2Window>, \
                <edi,edx,JustifyTop,MapDestBank>

xts_init_bank_mapped:


; Map the cursor bank into the source window.

        mov     edx,ulPtrBankScan       ;scan line at end of cursor work bank
        cmp     edx,[edi].dsurf_rcl2WindowClipS.yTop ;is cursor scan less than
                                                     ; current source bank?
        jl      short xts_map_ptr_bank               ;yes, map in proper bank
        cmp     edx,[edi].dsurf_rcl2WindowClipS.yBottom ;cursor scan greater
                                                        ; than current source
                                                        ; bank?
        jl      short xts_ptr_bank_mapped       ;no, proper bank already mapped
xts_map_ptr_bank:

; Map cursor work bank into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl2Window>, \
                <edi,edx,JustifyBottom,MapSourceBank>

xts_ptr_bank_mapped:


; Compute the screen address of this rectangle and get its size

        mov     ecx,[edi].dsurf_pvBitmapStart2WindowD ;start of screen bitmap
        mov     edi,lNextScan                   ;width of screen bitmap
        imul    edi,[esi].rd_ptlScreen.ptl_y    ;offset of dest start in screen
        add     edi,[esi].rd_ptlScreen.ptl_x    ; buffer
        add     edi,ecx                         ;virtual address of dest start

        mov     cx,[esi].rd_sizb                ;CH = scans to copy
                                                ; CL = bytes across to copy

        .ERRNZ  sizb_cy-sizb_cx-1

;-----------------------------------------------------------------------;
; To save incrementing the work area pointer (BX), subtract the XOR
; mask pointer off of it.  Then use [BX][SI] for addressing into the
; XOR mask.  As SI is incremented, BX will effectively be incremented.
; We could not do this if the XOR mask and the work area were different
; widths.
;
; Finish computing the pointer to the XOR mask and the delta from the
; XOR mask to the work area.
;-----------------------------------------------------------------------;

        mov     esi,pAndXor             ;set address of XOR mask
        lea     esi,[esi][ebx][base_xor_masks-base_and_masks]
        add     ebx,pPtrWork            ;start src offset in bitmap
        mov     eax,pdsurf
        add     ebx,[eax].dsurf_pvBitmapStart2WindowS ;start src virtual addr
        sub     ebx,esi                 ;fudge back so we get away with one
                                        ; increment

; Calculate the number of scans we'll do in this bank.

        mov     edx,[eax].dsurf_rcl2WindowClipD.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the initial bank
        sub     eax,eax
        mov     al,ch                   ;total # of scans to copy
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     ch,al                   ;count this bank's scans off total
        mov     byte ptr cjTotalScans,ch ;remember # of scans after this bank
        mov     ch,al                   ;# of scans to do in this bank

; Compute the delta to the start of the next scanline of the XOR mask
; and the work area, and the next scan of the screen

        sub     eax,eax
        mov     al,cl                   ;width to copy in bytes
        mov     edx,WORK_WIDTH
        sub     edx,eax                 ;offset from end of one source scan to
        mov     ulNextSrcScan,edx       ; start of next
        add     edx,lNextScan           ;offset from end of one dest scan to
        sub     edx,WORK_WIDTH          ; start of next

        lea     eax,[eax*4]
        neg     eax
        add     eax,offset FLAT:xor_to_screen_width_0

        push    ebp                     ;remember stack frame pointer
        mov     ebp,ulNextSrcScan       ;offset to next XOR scan
        jmp     eax

        .ERRNZ  WORK_WIDTH-5
;-----------------------------------------------------------------------;
; Register usage for the loop will be:
;
;       AX    = loop starting address
;       BX    = offset off [si] to the work area
;       CH    = height
;       DX    = delta to next scan of the destination
;       SI    --> XOR mask
;       DI    --> Destination
;       BP    = offset to next byte of XOR mask, next scan of work area
;-----------------------------------------------------------------------;

xor_to_screen_width_5:
        cmp     al, [ebx][esi]          ;Load latches from work area
        movsb                           ;XOR to the screen
xor_to_screen_width_4:
        cmp     al, [ebx][esi]
        movsb
xor_to_screen_width_3:
        cmp     al, [ebx][esi]
        movsb
xor_to_screen_width_2:
        cmp     al, [ebx][esi]
        movsb
xor_to_screen_width_1:
        cmp     al, [ebx][esi]
        movsb
xor_to_screen_width_0:

        .ERRNZ  xor_to_screen_width_0-xor_to_screen_width_1-4
        .ERRNZ  xor_to_screen_width_1-xor_to_screen_width_2-4
        .ERRNZ  xor_to_screen_width_2-xor_to_screen_width_3-4
        .ERRNZ  xor_to_screen_width_3-xor_to_screen_width_4-4
        .ERRNZ  xor_to_screen_width_4-xor_to_screen_width_5-4

        add     esi, ebp                ;--> next scan's XOR mask, work addr
        add     edi, edx                ;--> next scan's destination
        dec     ch                      ;count down lines in this bank
        jz      short @F                ;no more lines in this bank
        jmp     eax                     ;do the next line in this bank

@@:                                     ;done with bank
        pop     ebp                     ;retrieve stack frame pointer
        cmp     byte ptr cjTotalScans,0 ;more lines (in next dest bank)?
        jz      short xts_done          ;no, we're done
                                        ;advance to next dest bank and continue
                                        ; XORing
        push    eax                     ;preserve entry vector
        push    edx                     ;preserve dest next scan
        mov     eax,pdsurf
        sub     edi,[eax].dsurf_pvBitmapStart2WindowD
                                        ;calculate the destination offset
                                        ; within the bitmap, because the start
                                        ; address is about to move
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [eax].dsurf_pfnBankControl2Window>, \
                <eax,edx,JustifyTop,MapDestBank> ;map in the next dest bank

        mov     eax,pdsurf
        add     edi,[eax].dsurf_pvBitmapStart2WindowD
                                        ;add back in the bitmap start address
                                        ; to yield the virtual dest address
        mov     edx,[eax].dsurf_rcl2WindowClipD.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        mov     ch,al                   ;# of scans to do in this bank

        pop     edx                     ;restore dest next scan
        pop     eax                     ;restore entry vector

        push    ebp                     ;remember stack frame pointer
        mov     ebp,ulNextSrcScan       ;offset to next XOR scan
        jmp     eax                     ;do the next block of scans

xts_done:
        PLAIN_RET

page
;--------------------------Private-Routine------------------------------;
; color_pointer_to_screen
;
;   The color pointer is output to the screen using AND/XOR/COLOR masks.
;
; Entry:
;       None
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

color_pointer_to_screen:

        .ERRNZ  pd_rd                   ;Must be at offset 0

; Set up variables that don't change from plane to plane in the outer loop

        mov     esi,ppdNew
        test    fbXor,FB_WORK_RECT
        jz      short cps_have_pointer_rect
        mov     esi,offset FLAT:rdWork  ;the work area (we be clipping)
cps_have_pointer_rect:
        mov     prclSource,esi

; Map the proper bank into the destination window for the top destination
; scan line.

        mov     ebx,pdsurf
        mov     edx,[esi].rd_ptlScreen.ptl_y
        mov     ulCurrentTopScan,edx    ;remember where the top dest scan is
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is copy top less than
                                                     ; current dest bank?
        jl      short cpts_map_init_bank             ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;copy top greater than
                                                        ; current dest bank?
        jl      short cpts_init_bank_mapped     ;no, proper bank already mapped
cpts_map_init_bank:

; Map bank containing the top destination (screen) scan line into dest window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank>

cpts_init_bank_mapped:


; Map the cursor bank into the source window.

        mov     edx,ulPtrBankScan       ;scan line at end of cursor work bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is cursor scan less than
                                                     ; current source bank?
        jl      short cpts_map_ptr_bank              ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;cursor scan greater
                                                        ; than current source
                                                        ; bank?
        jl      short cpts_ptr_bank_mapped      ;no, proper bank already mapped
cpts_map_ptr_bank:

; Map cursor work bank into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapSourceBank>

cpts_ptr_bank_mapped:


; Offset to next screen scan, minus the width of the work area, will
; come in handy in the inner loop.

        mov     eax,lNextScan   ;width of screen bitmap
        mov     edi,eax         ;set aside for computing the screen address
        sub     eax,WORK_WIDTH
        mov     ulScanMinusWorkWidth,eax

; Compute the screen address of the rectangle in this bank

        imul    edi,[esi].rd_ptlScreen.ptl_y    ;offset of dest start in screen
        add     edi,[esi].rd_ptlScreen.ptl_x    ; buffer
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD ;virtual address of dest
                                                      ; start
        mov     pDest,edi

; Remember the save source point.

        sub     eax,eax
        mov     ax,word ptr [esi].rd_ptbSave
        mov     jSaveSourceXY,eax
        mov     byte ptr jNextSaveSourceY,ah


; Remember the work source point.

        mov     ax,word ptr [esi].rd_ptbWork
        mov     jWorkSourceXY,eax
        mov     byte ptr jNextWorkSourceY,ah


; Calculate the number of scans we'll do in this bank.

        mov     edx,[ebx].dsurf_rcl2WindowClipD.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the initial bank
        mov     ch,byte ptr [esi].rd_sizb+1 ;total # of scans to copy
        sub     eax,eax
        mov     al,ch
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        add     byte ptr jNextSaveSourceY,al ;top save source scan for next bank
        add     byte ptr jNextWorkSourceY,al ;top work source scan for next bank
        sub     ch,al                   ;count this bank's scans off total
        mov     byte ptr cjTotalScans,ch ;remember # of scans after this bank
        mov     byte ptr jScansInBank,al ;# of scans to do in this bank

; Set the virtual address of the save area

        mov     eax,[ebx].dsurf_pvBitmapStart2WindowS ;start of source bitmap
        add     eax,pPtrSave            ;virtual address of save area
        mov     pWorkingSave,eax

; Loop through banks that this cursor spans

cpts_bank_loop:

; Initial plane is plane 3

        mov     iPlaneMask,MM_C3

;-----------------------------------------------------------------------;
; Program the VGA for SET mode.  This will be done using M_PROC_WRITE,
; M_DATA_READ, DR_SET, and setting GRAF_BIT_MASK to FF.  The normal
; sequence of events will have left the bitmask register with 00h and
; the mode register in AND mode.
;-----------------------------------------------------------------------;

        mov     dx,EGA_BASE + GRAF_ADDR
        mov     ax,0FF00h + GRAF_BIT_MASK
        out     dx,ax                   ;enable all bits
        mov     ax,DR_SET SHL 8 + GRAF_DATA_ROT
        out     dx,ax
        mov     al,GRAF_READ_MAP
        out     dx,al   ;leave the GC Index pointing to the Read Map reg

cps_do_next_plane:

; Set write plane enable register to the ONE plane we will alter

        mov     al,byte ptr iPlaneMask          ;set Map Mask
        mov     dx,EGA_BASE + SEQ_DATA
        out     dx,al

; Set read plane to plane to read from

        shr     al,1                    ;map plane into ReadMask
        cmp     al,100b                 ;set Carry if not C3 (plane 3)
        adc     al,-1                   ;sub 1 only if C3
        mov     dl,GRAF_DATA
        out     dx,al

        mov     esi,prclSource          ;point to source rect
        mov     edi,pDest               ;point to initial dest byte

        mov     eax,jSaveSourceXY
        mov     edx,jWorkSourceXY

        .ERRNZ  ptb_y-ptb_x-1

        mov     cl,byte ptr [esi].rd_sizb

        .ERRNZ  sizb_cy-sizb_cx-1

        mov     bl,al                   ;see if save area is contiguous
        add     bl,cl
        sub     bl,SAVE_BUFFER_WIDTH    ;BL = is overhang
        jle     short call_cps_do_a_pass ;no overhang

        sub     cl,bl                   ;set X extent for pass 1
        mov     bh,cl                   ;need it for pass 2
        mov     ch,byte ptr jScansInBank ;# of scans to do in this bank
        push    ebx
        call    cps_do_a_pass           ;process first half
        pop     ebx

        mov     esi,prclSource          ;point to source rect
        mov     edi,pDest               ;point to initial dest byte

        mov     eax,jSaveSourceXY
        mov     edx,jWorkSourceXY

        .ERRNZ  ptb_y-ptb_x-1

        mov     cl,byte ptr [esi].rd_sizb

        .ERRNZ  sizb_cy-sizb_cx-1

        add     dl,bh                   ;move right in work area
        mov     cl,bl                   ;set new extent
        xor     al,al                   ;X origin in save area is 0
        movzx   ebx,bh                  ;move right in destination area
        add     edi,ebx

call_cps_do_a_pass:
        mov     ch,byte ptr jScansInBank ;# of scans to do in this bank
        call    cps_do_a_pass           ;process second half (or the whole
                                        ; color cursor, if no overhang)

        shr     iPlaneMask,1
        jnc     short cps_do_next_plane

        .ERRNZ  MM_C0-00000001b
        .ERRNZ  MM_C1-00000010b
        .ERRNZ  MM_C2-00000100b
        .ERRNZ  MM_C3-00001000b

                                        ;we've done all planes in this bank
        cmp     byte ptr cjTotalScans,0 ;more lines (in next dest bank)?
        jz      short cpts_done         ;no, we're done
                                        ;advance to next dest bank and continue
                                        ; XORing

; Advance the source Y coordinates to match the bank advance we're about to do.

        mov     al,byte ptr jNextSaveSourceY
        mov     byte ptr jSaveSourceXY+1,al
        mov     al,byte ptr jNextWorkSourceY
        mov     byte ptr jWorkSourceXY+1,al

; Advance to the next dest bank.

        mov     ebx,pdsurf
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank> ;map in the next dest bank

; Compute the screen start address of the rectangle in this bank

        mov     esi,prclSource                  ;point to source rect
        mov     edi,lNextScan                   ;width of screen bitmap
        imul    edi,ulCurrentTopScan            ;offset of dest start in screen
        add     edi,[esi].rd_ptlScreen.ptl_x    ; buffer
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD ;virtual address of dest
                                                      ; start
        mov     pDest,edi

        mov     edx,[ebx].dsurf_rcl2WindowClipD.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        add     byte ptr jNextSaveSourceY,al ;top save source scan for next bank
        add     byte ptr jNextWorkSourceY,al ;top work source scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        mov     byte ptr jScansInBank,al ;# of scans to do in this bank

        jmp     cpts_bank_loop          ;do the next block of scans

cpts_done:
        PLAIN_RET

page
;--------------------------Private-Routine------------------------------;
; cps_do_a_pass
;
; Output one plane of the color pointer to the screen using
; AND/XOR/COLOR masks. Does not handle bank spanning; that is taken care
; of in color_pointer_to_screen.
;
; Entry:
;       AH  = ptbSave.ptb_y, AL = ptbSave.ptb_x
;       DH  = ptbWork.ptb_y, DL = ptbWork.ptb_x
;       CL  = x bytes to process
;       CH  = y scans to process
;       EDI --> Destination   (screen area)
;       EBP = stack frame
;       VGA set up to enable writes to proper plane
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       EAX,EBX,ECX,EDX,ESI,EDI,EFLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

cps_do_a_pass:

;-----------------------------------------------------------------------;
; Compute the offset within the save area.  Note that this is relative
; to screen_buf.
; AH = ptbSave.ptb_y, AL = ptbSave.ptb_x
;-----------------------------------------------------------------------;

        shl     ah,3
        add     al,ah                   ;y * 8 + x
        xor     ah,ah
        cwde
        mov     ulOffsetSave,eax

        .ERRNZ  SAVE_BUFFER_WIDTH-8
        .ERRNZ  SAVE_BUFFER_HEIGHT-32

        mov     esi,pWorkingSave        ;point to the save area
        add     esi,eax                 ;ESI --> start address in save area


;-----------------------------------------------------------------------;
; Compute the offset within the AND/XOR masks.
; DH = ptbWork.ptb_y, DL = ptbWork.ptb_x
;-----------------------------------------------------------------------;

        xor     ebx,ebx
        xchg    dh,bl
        add     edx,ebx                 ;y * 1 + x
        add     ebx,ebx                 ;y * 2
        add     ebx,ebx                 ;y * 4
        add     ebx,edx                 ;y * 5 + x
        mov     ulOffsetMask,ebx
        add     ebx,pAndXor             ;EBX --> start address of AND mask
        sub     ebx,edi                 ;make EBX relative to EDI

;-----------------------------------------------------------------------;
; Compute the delta to the start of the next scanline of destination
; screen area
;-----------------------------------------------------------------------;

        mov     al, cl
        movsx   eax, al
        mov     edx,lNextScan
        sub     edx,eax
        mov     ulDeltaScreen,edx       ;delta to next scan of screen area

;-----------------------------------------------------------------------;
; Calculate EDX = jump table address
;-----------------------------------------------------------------------;

        mov     edx,color_to_screen_entry_table[eax*4]

        .ERRNZ  WORK_WIDTH-5

;-----------------------------------------------------------------------;
; Compute the offset within the COLOR mask.
;-----------------------------------------------------------------------;

        push    ebp                     ;need an extra register
        mov     al,byte ptr iPlaneMask  ;AL --> iPlaneMask
        mov     ebp,ulOffsetMask        ;EBP --> usoffset_mask
        add     ebp,pColor              ;EBP --> start address of COLOR mask
        shr     al,1
        jz      short @F
        add     ebp,MASK_LENGTH
        shr     al,1
        jz      short @F
        add     ebp,MASK_LENGTH
        shr     al,1
        jz      short @F
        add     ebp,MASK_LENGTH
@@:
        sub     ebp,edi                 ;make BP relative

        jmp     edx

;-----------------------------------------------------------------------;
; Register usage for the loop will be:
;
;       EBX   = offset off EDI to the AND mask
;       CH    = height
;       EDX   = loop starting address
;       ESI   --> Source        (save area)
;       EDI   --> Destination   (screen area)
;       EBP   = offset off EDI to the COLOR mask
;-----------------------------------------------------------------------;

color_to_screen_width_5::
        lodsb
        and     al,[ebx][edi]
        xor     al,[ebp][edi]
        stosb
color_to_screen_width_4::
        lodsb
        and     al,[ebx][edi]
        xor     al,[ebp][edi]
        stosb
color_to_screen_width_3::
        lodsb
        and     al,[ebx][edi]
        xor     al,[ebp][edi]
        stosb
color_to_screen_width_2::
        lodsb
        and     al,[ebx][edi]
        xor     al,[ebp][edi]
        stosb
color_to_screen_width_1::
        lodsb
        and     al,[ebx][edi]
        xor     al,[ebp][edi]
        stosb
color_to_screen_width_0::

        mov     eax,ebp                 ;EAX --> next scan's COLOR mask
        pop     ebp
        sub     eax,ulScanMinusWorkWidth

; WE HAVE NO SPARE REGISTERS HERE

        push    eax
        mov     eax,ulOffsetSave
        add     al,SAVE_BUFFER_WIDTH    ;Take into account wrap around
        mov     esi,pWorkingSave        ;point to the save area
        add     esi,eax                 ;ESI --> next scan's save area
        mov     ulOffsetSave,eax
        pop     eax

        add     edi,ulDeltaScreen       ;EDI --> next scan's screen area
        sub     ebx,ulScanMinusWorkWidth
                                        ;EBX --> next scan's AND mask
        dec     ch
        jz      cps_exit

        push    ebp
        mov     ebp,eax                 ;EBP --> next scan's COLOR mask
        jmp     edx                     ;do the next scan line

cps_exit:
        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; and_into_work
;
;   All rectangles which are to be ANDed into the work area are
;   dispatched to the routine which will do the actual ANDing.
;
; Entry:
;       AL = fbAndRead
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       and_from_screen
;       and_from_save
;
;-----------------------------------------------------------------------;

and_into_work:

        push    ebp

;-----------------------------------------------------------------------;
; Program the EGA for AND mode.  This will be done using M_PROC_WRITE,
; M_DATA_READ, DR_AND, and setting GRAF_BIT_MASK to FF.  All but setting
; DR_AND was set by save_hw_regs.  All planes were also enabled for
; writing by save_hw_regs.
;-----------------------------------------------------------------------;

        mov     ecx, eax
        mov     dx, EGA_BASE + GRAF_ADDR
        mov     ax, DR_AND SHL 8 + GRAF_DATA_ROT
        out     dx, ax
        mov     eax, ecx

;-----------------------------------------------------------------------;
; If FB_NEW_PTR or FB_WORK_AREA is set, then we only have a single
; rectangle to deal with, located on the screen.
;-----------------------------------------------------------------------;

        mov     esi, ppdNew
        test    al, FB_NEW_PTR
        jnz     short aiw_source_is_screen
        mov     esi, offset FLAT:rdWork
        test    al, FB_WORK_RECT
        jnz     short aiw_source_is_screen

; Some combination of FB_READ_X, FB_READ_Y, FB_OVERLAP exists

        test    al, FB_READ_Y
        jz      short @F
        mov     esi, offset FLAT:rdReadY
        call    and_from_screen
        mov     al, fbAndRead
@@:

        test    al, FB_READ_X
        jz      short @F
        mov     esi, offset FLAT:rdReadX
aiw_source_is_screen:
        call    and_from_screen
        mov     al, fbAndRead
@@:

        test    al, FB_OVERLAP
        jz      short @F
        mov     esi, offset FLAT:rdOverlap
        call    and_from_save
@@:

        pop     ebp

        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; and_from_screen
;
;   The screen is ANDed with the AND mask and placed into the work area
;
; Entry:
;       ESI --> RECT_DATA structure to use
;       EGA programmed for AND mode
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

and_from_screen:

        .ERRNZ  pd_rd                   ;Must be at offset 0

        mov     eax,lNextScan
        sub     eax,WORK_WIDTH
        mov     ulNextSrcScan,eax       ;set the source advance offset

;-----------------------------------------------------------------------;
; Map in the source and destination banks.
;-----------------------------------------------------------------------;

; Map the proper bank into the source window for the top source scan line.

        mov     edi,pdsurf
        mov     edx,[esi].rd_ptlScreen.ptl_y
        mov     ulCurrentTopScan,edx    ;remember where the top source scan is
        cmp     edx,[edi].dsurf_rcl2WindowClipS.yTop ;is AND top less than
                                                     ; current source bank?
        jl      short afscr_map_init_bank            ;yes, map in proper bank
        cmp     edx,[edi].dsurf_rcl2WindowClipS.yBottom ;AND top greater than
                                                        ; current source bank?
        jl      short afscr_init_bank_mapped    ;no, proper bank already mapped
afscr_map_init_bank:

; Map bank containing the top destination (screen) scan line into dest window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl2Window>, \
                <edi,edx,JustifyTop,MapSourceBank>

afscr_init_bank_mapped:


; Map the cursor bank into the destination window.

        mov     edx,ulPtrBankScan       ;scan line at end of cursor work bank
        cmp     edx,[edi].dsurf_rcl2WindowClipD.yTop ;is cursor scan less than
                                                     ; current dest bank?
        jl      short afscr_map_ptr_bank             ;yes, map in proper bank
        cmp     edx,[edi].dsurf_rcl2WindowClipD.yBottom ;cursor scan greater
                                                        ; than current dest
                                                        ; bank?
        jl      short afscr_ptr_bank_mapped     ;no, proper bank already mapped
afscr_map_ptr_bank:

; Map cursor work bank into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl2Window>, \
                <edi,edx,JustifyBottom,MapDestBank>

afscr_ptr_bank_mapped:


;-----------------------------------------------------------------------;
; Compute the screen address of this rectangle and get its size
;-----------------------------------------------------------------------;

        mov     ebx,lNextScan
        imul    ebx,[esi].rd_ptlScreen.ptl_y
        add     ebx,[esi].rd_ptlScreen.ptl_x    ;start source offset in bitmap
        movzx   ecx,WORD PTR [esi].rd_sizb      ;CH = scans to copy
                                                ; CL = bytes across to copy

        .ERRNZ  sizb_cy-sizb_cx-1

;-----------------------------------------------------------------------;
; Compute the offset from the start of the work area and the AND mask
; (it's the same value).
;-----------------------------------------------------------------------;

        xor     eax,eax
        movzx   edx,WORD PTR [esi].rd_ptbWork  ;Get origin in work area
        xchg    al,dh                   ;AX = ptbWork.ptb_y, DX = ptbWork.ptb_x
        add     edx,eax                 ;*1 + X component
        add     eax,eax                 ;*2
        add     eax,eax                 ;*4
        add     eax,edx                 ;*5 + X = start from work/mask
        mov     edi,eax

        .ERRNZ  WORK_WIDTH-5

;-----------------------------------------------------------------------;
; To save incrementing the source pointer (BX), subtract the AND
; mask pointer off of it.  Then use [BX][SI] for addressing into the
; source.  As SI is incremented, BX will effectively be incremented.
;
; The source pointer will have to be adjusted by lNextScan-sizb_cx.
;-----------------------------------------------------------------------;

        mov     esi,pAndXor             ;Set address of AND mask
        add     esi,edi
        add     edi,pPtrWork            ;start dest offset in bitmap
        mov     eax,pdsurf
        add     edi,[eax].dsurf_pvBitmapStart2WindowD ;start dest virtual addr
        add     ebx,[eax].dsurf_pvBitmapStart2WindowS ;start src virtual addr
        sub     ebx,esi                 ;fudge back so we get away with one
                                        ; increment

; Calculate the number of scans we'll do in this bank.

        mov     edx,[eax].dsurf_rcl2WindowClipS.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the initial bank
        sub     eax,eax
        mov     al,ch                   ;total # of scans to copy
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     ch,al                   ;count this bank's scans off total
        mov     byte ptr cjTotalScans,ch ;remember # of scans after this bank
        mov     ch,al                   ;# of scans to do in this bank

; Compute the delta to the start of the next scanline of the AND mask
; and the work area, and the next scan of the screen

        sub     eax,eax
        mov     al,cl
        mov     edx,WORK_WIDTH
        sub     edx,eax

; Look up the loop entry point, and start ANDing.

        mov     eax,and_from_screen_entry_table[eax*4] ;look up the loop entry
        push    ebp                     ;preserve stack frame pointer
        mov     ebp,ulNextSrcScan       ;source offset to next scan
        jmp     eax                     ;enter the ANDing loop

        .ERRNZ  WORK_WIDTH-5
;-----------------------------------------------------------------------;
; Register usage for the loop will be:
;
;       EAX     =  loop entry address
;       EBX     =  offset off of SI to the screen source
;       CH      =  height
;       EDX     =  offset to next scan of AND mask & work area
;       ESI     --> AND mask
;       EDI     --> Destination in work area
;-----------------------------------------------------------------------;

and_from_screen_width_5::
        cmp     al, [ebx][esi]          ;Load latches from work area
        movsb                           ;AND from screen into work area
and_from_screen_width_4::
        cmp     al, [ebx][esi]
        movsb
and_from_screen_width_3::
        cmp     al, [ebx][esi]
        movsb
and_from_screen_width_2::
        cmp     al, [ebx][esi]
        movsb
and_from_screen_width_1::
        cmp     al, [ebx][esi]
        movsb
and_from_screen_width_0::

        add     esi,edx                 ;--> next AND mask
        add     edi,edx                 ;--> next destination
        add     ebx,ebp                 ;--> next source

        dec     ch                      ;count down scans in this bank
        jz      short @F                ;bank is finished
        jmp     eax                     ;do next scan in this bank

@@:
        pop     ebp                     ;restore stack frame pointer
        cmp     byte ptr cjTotalScans,0 ;more lines (in next dest bank)?
        jz      short afscr_done        ;no, we're done
                                        ;advance to next dest bank and continue
                                        ; ANDing
        push    eax                     ;preserve entry vector
        push    edx                     ;preserve dest next scan
        mov     eax,pdsurf
        sub     ebx,[eax].dsurf_pvBitmapStart2WindowS
                                        ;calculate the source offset within the
                                        ; bitmap, because the start address is
                                        ; about to move
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [eax].dsurf_pfnBankControl2Window>, \
                <eax,edx,JustifyTop,MapSourceBank> ;map in the next source bank

        mov     eax,pdsurf
        add     ebx,[eax].dsurf_pvBitmapStart2WindowS
                                        ;add back in the bitmap start address
                                        ; to yield the virtual source address
        mov     edx,[eax].dsurf_rcl2WindowClipS.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        mov     ch,al                   ;# of scans to do in this bank

        pop     edx                     ;restore dest next scan
        pop     eax                     ;restore entry vector

        push    ebp                     ;preserve stack frame pointer
        mov     ebp,ulNextSrcScan       ;source offset to next scan
        jmp     eax                     ;do the next block of scans

afscr_done:
        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; and_from_save
;
;   The given area of the save buffer is ANDed into the work buffer
;
; Entry:
;       ESI --> RECT_DATA structure to use
;       EGA programmed for AND mode
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       EAX,EBX,ECX,EDX,ESI,EDI,EFLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; This is the key to wrapping in the buffer.  It is a power of two, and
; in this case the entire size is 256 bytes.  If it wasn't 256 bytes, an
; and mask could be used for wrapping.
;-----------------------------------------------------------------------;

        .ERRNZ  SAVE_BUFFER_WIDTH-8
        .ERRNZ  SAVE_BUFFER_HEIGHT-32
        .ERRNZ  SAVE_BUFFER_WIDTH*SAVE_BUFFER_HEIGHT-256

and_from_save:

        .ERRNZ  pd_rd

; See if we'll wrap in X.  If so, split the operation into two parts

        movzx   eax, WORD PTR [esi].rd_ptbWork
        movzx   ecx, WORD PTR [esi].rd_ptbSave

        .ERRNZ  ptb_y-ptb_x-1

        movzx   edx, WORD PTR [esi].rd_sizb

        .ERRNZ  sizb_cy-sizb_cx-1

        mov     bl, cl
        add     bl, dl
        sub     bl, SAVE_BUFFER_WIDTH   ;BL = is overhang
        jle     short and_from_save_do_last_pass ;No overhang

        sub     dl, bl                  ;Set X extent for pass 1
        mov     bh, dl                  ;Need it for pass 2
        push    esi                     ;Must keep rectangle pointer around
        push    ebx
        call    and_from_save_do_a_pass ;Process first half
        pop     ebx
        pop     esi
        movzx   eax, WORD PTR [esi].rd_ptbWork
        movzx   ecx, WORD PTR [esi].rd_ptbSave

        .ERRNZ  ptb_y-ptb_x-1

        movzx   edx, WORD PTR [esi].rd_sizb

        .ERRNZ  sizb_cy-sizb_cx-1

        add     al, bh                  ;Move right in work area
        mov     dl, bl                  ;Set new extent
        xor     cl, cl                  ;X origin in save area is 0

and_from_save_do_last_pass:

        call    and_from_save_do_a_pass

        PLAIN_RET


;--------------------------Private-Routine------------------------------;
;  and_from_save
;
; Inner loop subroutine for and_from_save.
;
; Entry:
;       AL = X dest start offset in work area (in bytes)
;       AH = Y dest start offset in work area (in scans)
;       CL = X source start offset in save area (in bytes)
;       CH = Y source start offset in save area (in scans)
;       Upper word of ECX *must* be 0!
;       DL = width to AND (in bytes)
;       DH = height to AND (in scans)
;       EGA programmed for AND mode
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       EAX,EBX,ECX,EDX,ESI,EDI,EFLAGS
; Calls:
;       None
;
;------------------------------------------------------------------------;

and_from_save_do_a_pass:

        push    ebp                     ;save stack frame pointer

        push    eax
        push    ecx
        push    edx

; Map the cursor bank in as both the read window and the write window, because
; both the save and work areas are in the cursor bank. Note that we always know
; that the operation fits in a single bank, which simplifies things
; considerably.

        mov     esi,pdsurf
        mov     edx,ulPtrBankScan       ;scan line at end of cursor work bank
        cmp     edx,[esi].dsurf_rcl1WindowClip.yTop ;is cursor scan less than
                                                     ; current bank?
        jl      short afsav_map_ptr_bank             ;yes, map in proper bank
        cmp     edx,[esi].dsurf_rcl1WindowClip.yBottom ;cursor scan greater
                                                        ; than current bank?
        jl      short afsav_ptr_bank_mapped     ;no, proper bank already mapped
afsav_map_ptr_bank:

; Map cursor work bank into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [esi].dsurf_pfnBankControl>,<esi,edx,JustifyBottom>

afsav_ptr_bank_mapped:

        pop     edx
        pop     ecx
        pop     eax

; Compute the offset within the work area, which is also the offset from
; the start of the AND mask.

        xor     ebx,ebx
        xchg    bl,ah
        add     eax,ebx                 ;*1 + X
        add     ebx,ebx                 ;*2
        add     ebx,ebx                 ;*4
        add     ebx,eax                 ;*5 + X
        mov     edi,pPtrWork
        add     edi,ebx                 ;--> destination in work area relative
                                        ;    to start of bitmap
        mov     esi,[esi].dsurf_pvBitmapStart ;bitmap start virtual address
        push    esi                     ;remember bitmap start for calculating
                                        ; save area pointer
        add     edi,esi                 ;virtual addresss of work area
                                        ; destination start
        mov     esi,pAndXor
        add     esi,ebx                 ;--> AND mask
                                        ; Compute the offset within the save
                                        ; area. Note that this is relative to
                                        ; screen_buf
        xor     ebx,ebx
        xchg    bl,ch                   ;EBX = ptbSave.ptb_y,
                                        ; ECX = ptbSave.ptb_x
        lea     ebx,[ebx*8+ecx]         ;EBX = offset in save area

        .ERRNZ  SAVE_BUFFER_WIDTH-8

; Compute the adjustment to each scanline.

        mov     cl,dl                   ;width in bytes to AND
        mov     eax,WORK_WIDTH
        sub     eax,ecx                 ;width in bytes to skip from end of one
                                        ; mask/work buffer scan to start of
                                        ; next

; Look up the address at which to enter the AND loop.

        mov     ecx,and_from_save_entry_table[ecx*4]

; Now get things into the correct registers and enter the loop

        pop     ebp                     ;get back bitmap start virtual address
        add     ebp,pPtrSave            ;point to the save area
        push    ebp                     ;remember save area virtual address
        add     ebp,ebx                 ;set correct save buffer address
        sub     ebp,esi                 ;want to use [SI][BP]
        jmp     ecx                     ;enter following code

;-----------------------------------------------------------------------;
; Register usage for the loop will be:
;
;       EAX    =  delta to next scan of AND mask and work area
;       EBX    =  offset in save area of scan start
;       ECX    =  loop address
;       DH     =  height in scans
;       ESI    --> AND mask
;       EDI    --> Destination in work area
;       EBP    =  delta from SI to next byte of save buffer
;-----------------------------------------------------------------------;

and_from_save_width_5::
        cmp     al, [ebp][esi]          ;Load latches from screen
        movsb                           ;AND to the work area
and_from_save_width_4::
        cmp     al, [ebp][esi]
        movsb
and_from_save_width_3::
        cmp     al, [ebp][esi]
        movsb
and_from_save_width_2::
        cmp     al, [ebp][esi]
        movsb
and_from_save_width_1::
        cmp     al, [ebp][esi]
        movsb
and_from_save_width_0::

        dec     dh
        jz      short and_from_save_done
        add     esi,eax                 ;--> next AND mask
        add     edi,eax                 ;--> next work buffer scan
        add     bl,SAVE_BUFFER_WIDTH    ;--> compute address of next
                                        ;    scan in the work area
        pop     ebp                     ;restore save area pointer
        push    ebp                     ;push it again, for next time
        add     ebp,ebx
        sub     ebp,esi                 ;Want to use SI for incrementing

        jmp     ecx

and_from_save_done:
        pop     ebp                     ;clear pushed save area pointer

        pop     ebp                     ;restore stack frame pointer

        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; copy_things_around
;
;   Rectangles to be copied from the save area to the screen are
;   processed, followed by the rectangles to be copied from the
;   screen to the save area.
;
; Entry:
;       AL = fbFlush
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,BP,FLAGS
; Calls:
;       copy_save_to_screen
;       copy_screen_to_save
;
;-----------------------------------------------------------------------;

copy_things_around:

;-----------------------------------------------------------------------;
; Program the EGA for COPY mode.  This will be done using M_PROC_WRITE,
; M_DATA_READ, DR_???, and setting GRAF_BIT_MASK to 00.  All but setting
; GRAF_BIT_MASK was done by save_hw_regs.  All planes were also enabled
; for writing by save_hw_regs.
;-----------------------------------------------------------------------;

        mov     ecx, eax
        mov     dx, EGA_BASE + GRAF_ADDR
        mov     ax, GRAF_BIT_MASK
        out     dx, ax                  ;Disable all bits
        mov     eax, ecx

;-----------------------------------------------------------------------;
; Process any copying from the save area to the screen.  If FB_OLD_PTR
; is set, then there cannot be a FB_FLUSH_X or FB_FLUSH_Y.
;-----------------------------------------------------------------------;

        mov     esi, ppdOld
        test    al, FB_OLD_PTR
        jnz     short cta_copy_from_save      ;The old rectangle goes
        test    al, FB_FLUSH_X
        jz      short @F
        mov     esi, offset FLAT:rdFlushX
        call    copy_save_to_screen
        mov     al, fbFlush
@@:
        test    al, FB_FLUSH_Y
        jz      short @F
        mov     esi, offset FLAT:rdFlushY
cta_copy_from_save:
        call    copy_save_to_screen
@@:

;-----------------------------------------------------------------------;
; Process any copying from the screen to the save area.  If FB_NEW_PTR
; or FB_WORK_RECT is set, then there can't be a FB_FLUSH_X or FB_FLUSH_Y
;-----------------------------------------------------------------------;

        mov     al, fbAndRead
        mov     esi, ppdNew
        test    al, FB_NEW_PTR
        jnz     short cta_copy_to_save
        mov     esi, offset FLAT:rdWork
        test    al, FB_WORK_RECT
        jnz     short cta_copy_to_save

; Some combination of FB_READ_X, FB_READ_Y

        test    al, FB_READ_X
        jz      short @F
        mov     esi, offset FLAT:rdReadX
        call    copy_screen_to_save
        mov     al, fbAndRead
@@:
        test    al, FB_READ_Y
        jz      short @F
        mov     esi, offset FLAT:rdReadY
cta_copy_to_save:
        call    copy_screen_to_save
@@:
        PLAIN_RET

page

;--------------------------Private-Routine------------------------------;
; copy_save_to_screen
;
;   The given rectangle is copied from the save area to the screen
;
; Entry:
;       ESI --> RECT_DATA structure to use
;       EGA programmed for COPY mode
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       EAX,EBX,ECX,EDX,ESI,EDI,EFLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; This is the key to wrapping in the buffer.  It is a power of two, and
; in this case the entire size is 256 bytes.  If it wasn't 256 bytes, an
; and mask could be used for wrapping.
;-----------------------------------------------------------------------;

        .ERRNZ  SAVE_BUFFER_WIDTH-8
        .ERRNZ  SAVE_BUFFER_HEIGHT-32
        .ERRNZ  SAVE_BUFFER_WIDTH*SAVE_BUFFER_HEIGHT-256

copy_save_to_screen:

        .ERRNZ  pd_rd

; Map the proper bank into the destination window for the top destination
; scan line.

        mov     ebx,pdsurf
        mov     edx,[esi].rd_ptlScreen.ptl_y
        mov     ulCurrentTopScan,edx    ;remember where the top dest scan is
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is copy top less than
                                                     ; current dest bank?
        jl      short sts_map_init_bank              ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;copy top greater than
                                                        ; current dest bank?
        jl      short sts_init_bank_mapped      ;no, proper bank already mapped
sts_map_init_bank:

; Map bank containing the top destination (screen) scan line into dest window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapDestBank>

sts_init_bank_mapped:


; Map the cursor bank into the source window.

        mov     edx,ulPtrBankScan       ;scan line at end of cursor work bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is cursor scan less than
                                                     ; current source bank?
        jl      short sts_map_ptr_bank              ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;cursor scan greater
                                                        ; than current source
                                                        ; bank?
        jl      short sts_ptr_bank_mapped       ;no, proper bank already mapped
sts_map_ptr_bank:

; Map cursor work bank into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapSourceBank>

sts_ptr_bank_mapped:


; Compute the virtual address of the save area.

        mov     eax,pPtrSave
        add     eax,[ebx].dsurf_pvBitmapStart2WindowS ;save area virtual addr
        mov     pSaveAddr,eax

; Compute the screen address and delta to next scan of the screen.

        mov     edi,lNextScan
        imul    edi,[esi].rd_ptlScreen.ptl_y
        add     edi,[esi].rd_ptlScreen.ptl_x ;start dest offset in bitmap
        add     edi,[ebx].dsurf_pvBitmapStart2WindowD ;start dest virtual addr
        movzx   edx,WORD PTR [esi].rd_sizb

        .ERRNZ  sizb_cy-sizb_cx-1

; Calculate the number of scans we'll do in this bank.

        mov     ecx,[ebx].dsurf_rcl2WindowClipD.yBottom
        sub     ecx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the initial bank
        sub     eax,eax
        mov     al,dh                   ;total # of scans to copy
        cmp     eax,ecx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,ecx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     dh,al                   ;count this bank's scans off total
        mov     byte ptr cjTotalScans,dh ;remember # of scans after this bank
        mov     dh,al                   ;# of scans to do in this bank

; Calculate the offset from the end of one dest scan line to the next.

        mov     al,dl           ;width to copy in bytes
        neg     eax
        add     eax,lNextScan   ;offset from end of one dest scan to start of
                                ; next

; Compute the save area offset.

        movzx   ecx,WORD PTR [esi].rd_ptbSave

        .ERRNZ  ptb_y-ptb_x-1

        xor     ebx,ebx
        xchg    bl,ch
        lea     ebx,[ebx*8+ecx]

        .ERRNZ  SAVE_BUFFER_WIDTH-8

; Determine if any wrap will occur, and handle it if so.

        add     cl,dl                   ;add extent (DL) to start X (CL)
        sub     cl,SAVE_BUFFER_WIDTH
        jg      short save_to_screen_wraps    ;CL = amount of wrap

;-----------------------------------------------------------------------;
; The copy will not wrap, so we can get into some tighter code for it.
;
; Currently:
;       EAX    =  delta to next destination scan
;       EBX    =  offset into the save buffer
;       DL     =  width of copy
;       DH     =  height of copy
;       EDI    --> destination
;-----------------------------------------------------------------------;

copy_save_next_scan:
        sub     ecx,ecx                 ;prepare for loading CL in loop
        push    ebp                     ;preserve stack frame pointer
        mov     ebp,pSaveAddr
copy_save_next_scan_loop:
        lea     esi,[ebp+ebx]
        mov     cl,dl
        rep     movsb
        add     bl,SAVE_BUFFER_WIDTH
        add     edi,eax
        dec     dh
        jnz     short copy_save_next_scan_loop

        pop     ebp                     ;restore stack frame pointer
        cmp     byte ptr cjTotalScans,0 ;more lines (in next dest bank)?
        jz      short sts_done          ;no, we're done
                                        ;advance to next dest bank and continue
                                        ; copying
        push    eax                     ;preserve dest next scan
        push    edx                     ;preserve width of copy
        mov     esi,pdsurf
        sub     edi,[esi].dsurf_pvBitmapStart2WindowD
                                        ;calculate the destination offset
                                        ; within the bitmap, because the start
                                        ; address is about to move
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [esi].dsurf_pfnBankControl2Window>, \
                <esi,edx,JustifyTop,MapDestBank> ;map in the next dest bank

        add     edi,[esi].dsurf_pvBitmapStart2WindowD
                                        ;add back in the bitmap start address
                                        ; to yield the virtual dest address
        mov     edx,[esi].dsurf_rcl2WindowClipD.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        pop     edx                     ;restore copy width in DL
        mov     dh,al                   ;# of scans to do in this bank
        pop     eax                     ;restore dest next scan
        jmp     short copy_save_next_scan     ;do the next block of scans

sts_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; The copy will wrap, so we have to handle it as two copies
;
; Currently:
;       EDI    --> destination
;       EAX    =  delta to next destination scan
;       DL     =  width of copy
;       DH     =  height of copy
;       EBX    =  offset into the save buffer
;       CL     =  amount of overflow
;-----------------------------------------------------------------------;

save_to_screen_wraps:
        sub     dl,cl                   ;set extent of first copy
        mov     byte ptr jPostWrapWidth,cl ;set extent of second copy
        sub     ecx,ecx                 ;prepare for loading CL in loop

copy_save_next_scan_wrap_loop:
        mov     esi,pSaveAddr
        add     esi,ebx
        mov     cl,dl
        rep     movsb
        sub     esi,SAVE_BUFFER_WIDTH
        mov     cl,byte ptr jPostWrapWidth
        rep     movsb
        add     bl,SAVE_BUFFER_WIDTH
        add     edi,eax
        dec     dh
        jnz     short copy_save_next_scan_wrap_loop

        cmp     byte ptr cjTotalScans,0 ;more lines (in next dest bank)?
        jz      short sts_done          ;no, we're done
                                        ;advance to next dest bank and continue
                                        ; copying
        push    eax                     ;preserve dest next scan
        push    edx                     ;preserve width of copy
        mov     esi,pdsurf
        sub     edi,[esi].dsurf_pvBitmapStart2WindowD
                                        ;calculate the destination offset
                                        ; within the bitmap, because the start
                                        ; address is about to move
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [esi].dsurf_pfnBankControl2Window>, \
                <esi,edx,JustifyTop,MapDestBank> ;map in the next dest bank

        add     edi,[esi].dsurf_pvBitmapStart2WindowD
                                        ;add back in the bitmap start address
                                        ; to yield the virtual dest address
        mov     edx,[esi].dsurf_rcl2WindowClipD.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        pop     edx                     ;restore copy width in DL
        mov     dh,al                   ;# of scans to do in this bank
        pop     eax                     ;restore dest next scan
        sub     ecx,ecx                 ;prepare for loading CL in loop
        jmp     copy_save_next_scan_wrap_loop ;do the next block of scans

page

;--------------------------Private-Routine------------------------------;
; copy_screen_to_save
;
;   The given rectangle is copied from the screen to the save area
;
; Entry:
;       ESI --> RECT_DATA structure to use
;       EGA programmed for COPY mode
; Returns:
;       None
; Error Returns:
;       No error return.
; Registers Preserved:
;       EBP
; Registers Destroyed:
;       EAX,EBX,ECX,EDX,ESI,EDI,EFLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; This is the key to wrapping in the buffer.  It is a power of two, and
; in this case the entire size is 256 bytes.  If it wasn't 256 bytes, an
; and mask could be used for wrapping.
;-----------------------------------------------------------------------;

        .ERRNZ  SAVE_BUFFER_WIDTH-8
        .ERRNZ  SAVE_BUFFER_HEIGHT-32
        .ERRNZ  SAVE_BUFFER_WIDTH*SAVE_BUFFER_HEIGHT-256

copy_screen_to_save:

        .ERRNZ  pd_rd

; Map the proper bank into the source window for the top source scan line.

        mov     ebx,pdsurf
        mov     edx,[esi].rd_ptlScreen.ptl_y
        mov     ulCurrentTopScan,edx    ;remember where the top source scan is
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yTop ;is copy top less than
                                                     ; current source bank?
        jl      short scrts_map_init_bank            ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipS.yBottom ;copy top greater than
                                                        ; current source bank?
        jl      short scrts_init_bank_mapped    ;no, proper bank already mapped
scrts_map_init_bank:

; Map bank containing the top source (screen) scan line into source window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyTop,MapSourceBank>

scrts_init_bank_mapped:


; Map the cursor bank into the dest window.

        mov     edx,ulPtrBankScan       ;scan line at end of cursor work bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yTop ;is cursor scan less than
                                                     ; current dest bank?
        jl      short scrts_map_ptr_bank            ;yes, map in proper bank
        cmp     edx,[ebx].dsurf_rcl2WindowClipD.yBottom ;cursor scan greater
                                                        ; than current dest
                                                        ; bank?
        jl      short scrts_ptr_bank_mapped     ;no, proper bank already mapped
scrts_map_ptr_bank:

; Map cursor work bank into dest window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].dsurf_pfnBankControl2Window>, \
                <ebx,edx,JustifyBottom,MapDestBank>

scrts_ptr_bank_mapped:


; Compute the virtual address of the save area.

        mov     eax,pPtrSave
        add     eax,[ebx].dsurf_pvBitmapStart2WindowD ;save area virtual addr
        mov     pSaveAddr,eax

; Compute the source screen address and delta to next scan of the screen.

        mov     edi,lNextScan
        imul    edi,[esi].rd_ptlScreen.ptl_y
        add     edi,[esi].rd_ptlScreen.ptl_x ;start source offset in bitmap
        add     edi,[ebx].dsurf_pvBitmapStart2WindowS ;start source virtual
                                                      ; address
        movzx   edx,WORD PTR [esi].rd_sizb

        .ERRNZ  sizb_cy-sizb_cx-1

; Calculate the number of scans we'll do in this bank.

        mov     ecx,[ebx].dsurf_rcl2WindowClipS.yBottom
        sub     ecx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the initial bank
        sub     eax,eax
        mov     al,dh                   ;total # of scans to copy
        cmp     eax,ecx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,ecx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     dh,al                   ;count this bank's scans off total
        mov     byte ptr cjTotalScans,dh ;remember # of scans after this bank
        mov     dh,al                   ;# of scans to do in this bank

; Calculate the offset from the end of one source scan line to the next.

        mov     al,dl           ;width to copy in bytes
        neg     eax
        add     eax,lNextScan   ;offset from end of one source scan to start of
                                ; next

; Compute the save area offset.

        movzx   ecx,WORD PTR [esi].rd_ptbSave

        .ERRNZ  ptb_y-ptb_x-1

        xor     ebx,ebx
        xchg    bl,ch
        lea     ebx,[ebx*8+ecx]

        .ERRNZ  SAVE_BUFFER_WIDTH-8

        mov     esi,edi                 ;ESI -> initial source byte

; Determine if any wrap will occur, and handle it if so.

        add     cl,dl                   ;add extent (DL) to start X (CL)
        sub     cl,SAVE_BUFFER_WIDTH
        jg      short screen_to_save_wraps    ;CL = amount of wrap

;-----------------------------------------------------------------------;
; The copy will not wrap, so we can get into some tighter code for it.
;
; Currently:
;       EAX    =  delta to next source scan
;       EBX    =  offset into the save buffer
;       DL     =  width of copy
;       DH     =  height of copy
;       ESI    --> source
;-----------------------------------------------------------------------;

copy_screen_next_scan:
        sub     ecx,ecx                 ;prepare for loading CL in loop
        push    ebp                     ;preserve stack frame pointer
        mov     ebp,pSaveAddr
copy_screen_next_scan_loop:
        lea     edi,[ebp+ebx]
        mov     cl,dl
        rep     movsb
        add     bl,SAVE_BUFFER_WIDTH
        add     esi,eax
        dec     dh
        jnz     short copy_screen_next_scan_loop

        pop     ebp                     ;restore stack frame pointer
        cmp     byte ptr cjTotalScans,0 ;more lines (in next source bank)?
        jz      short scrts_done        ;no, we're done
                                        ;advance to next source bank and
                                        ; continue copying
        push    eax                     ;preserve source next scan
        push    edx                     ;preserve width of copy
        mov     edi,pdsurf
        sub     esi,[edi].dsurf_pvBitmapStart2WindowS
                                        ;calculate the source offset
                                        ; within the bitmap, because the start
                                        ; address is about to move
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl2Window>, \
                <edi,edx,JustifyTop,MapSourceBank> ;map in the next source bank

        add     esi,[edi].dsurf_pvBitmapStart2WindowS
                                        ;add back in the bitmap start address
                                        ; to yield the virtual source address
        mov     edx,[edi].dsurf_rcl2WindowClipS.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        pop     edx                     ;restore copy width in DL
        mov     dh,al                   ;# of scans to do in this bank
        pop     eax                     ;restore source next scan
        jmp     short copy_screen_next_scan   ;do the next block of scans

scrts_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; The copy will wrap, so we have to handle it as two copies
;
; Currently:
;       EAX    =  delta to next source scan
;       EBX    =  offset into the save buffer
;       CL     =  amount of overflow
;       DL     =  width of copy
;       DH     =  height of copy
;       ESI    --> source
;-----------------------------------------------------------------------;

screen_to_save_wraps:
        sub     dl,cl                   ;set extent of first copy
        mov     byte ptr jPostWrapWidth,cl ;set extent of second copy
        sub     ecx,ecx                 ;prepare for loading CL in loop

copy_screen_next_scan_wrap_loop:
        mov     edi,pSaveAddr
        add     edi,ebx
        mov     cl,dl
        rep     movsb
        sub     edi,SAVE_BUFFER_WIDTH
        mov     cl,byte ptr jPostWrapWidth
        rep     movsb
        add     bl,SAVE_BUFFER_WIDTH
        add     esi,eax
        dec     dh
        jnz     short copy_screen_next_scan_wrap_loop

        cmp     byte ptr cjTotalScans,0 ;more lines (in next source bank)?
        jz      short scrts_done          ;no, we're done
                                        ;advance to next source bank and
                                        ; continue copying
        push    eax                     ;preserve source next scan
        push    edx                     ;preserve width of copy
        mov     edi,pdsurf
        sub     esi,[edi].dsurf_pvBitmapStart2WindowS
                                        ;calculate the source offset
                                        ; within the bitmap, because the start
                                        ; address is about to move
        mov     edx,ulCurrentTopScan

; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [edi].dsurf_pfnBankControl2Window>, \
                <edi,edx,JustifyTop,MapSourceBank> ;map in the next source bank

        add     esi,[edi].dsurf_pvBitmapStart2WindowS
                                        ;add back in the bitmap start address
                                        ; to yield the virtual source address
        mov     edx,[edi].dsurf_rcl2WindowClipS.yBottom
        sub     edx,ulCurrentTopScan    ;max # of scans that can be handled in
                                        ; the new bank
        sub     eax,eax
        mov     al,byte ptr cjTotalScans ;remaining scan count
        cmp     eax,edx                 ;can we handle all remaining scans in
                                        ; this bank?
        jb      short @F                ;yes
        mov     eax,edx                 ;no, so we'll do the whole bank's worth
@@:
        add     ulCurrentTopScan,eax    ;set top scan for next bank
        sub     byte ptr cjTotalScans,al ;count this bank's scans off total
        pop     edx                     ;restore copy width in DL
        mov     dh,al                   ;# of scans to do in this bank
        pop     eax                     ;restore source next scan
        sub     ecx,ecx                 ;prepare for loading CL in loop
        jmp     short copy_screen_next_scan_wrap_loop ;do the next block of scans

endProc vDrawPointer

;-----------------------------------------------------------------------;
; vDIB4Convert*
;
; Converts the specified number of source 4 bpp bits into the
; buffer.  These are support routines for vDIB4Planer, where a
; source byte converts into two aligned bits
;
; Entry:
;   EAX 31:8 = 0
;   EBP --> Bit conversion table
;   ESI --> Source bitmap
;   EDI --> Planer destination
;   ECX  =  Loop count
; Exit:
;   EBP --> Bit conversion table
;   ESI --> Next source byte
;   EDI --> Next planer destination
;   EDX  =  Last planer byte accumulated
; Registers Destroyed:
;   EAX,ECX,EDX
; Registers Preserved:
;-----------------------------------------------------------------------;

        extrn   aulDefBitMapping:dword

vDIB4Convert8   proc
        mov     al,[esi]        ; 1 cycle 486
        inc     esi             ; 1 cycle 486
        ; lodsb
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        mov     edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4Convert6:
        mov     al,[esi]        ; 1 cycle 486
        inc     esi             ; 1 cycle 486
        ; lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4Convert4:
        mov     al,[esi]        ; 1 cycle 486
        inc     esi             ; 1 cycle 486
        ; lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
vDIB4Convert2:
        mov     al,[esi]        ; 1 cycle 486
        inc     esi             ; 1 cycle 486
        ; lodsb
        shl     edx,1
        mov     ebx,eax
        shr     eax,4
        and     ebx,00001111b
        or      edx,[ebp][eax*4]
        shl     edx,1
        or      edx,[ebp][ebx*4]
        mov     [edi][4*0],dl
        mov     [edi][4*1],dh
        ror     edx,16
        mov     [edi][4*2],dl
        mov     [edi][4*3],dh
        inc     edi
        dec     ecx
        jnz     vDIB4Convert8
        ret

vDIB4Convert8   endp

page
;-----------------------------------------------------------------------;
; vConvertDIBPointer
;
; Converts the passed DIB into a planer format, then synthesizes the
; XOR mask.
;
; Entry:
;   ESI --> Color Bits, 4bpp format
;   EDI --> Planer destination
;   EAX  =  fIsDFB
;   ECX  =  Bitmap height
;   EBP  =  pulXlate for color mapping
;    DX  = wFlags
; Exit:
;   None
; Registers Destroyed:
;   EAX,EBX,ECX,EDX,ESI,EDI,Flags
; Registers Preserved:
;-----------------------------------------------------------------------;

vConvertDIBPointer  proc

; Convert the scans as necessary into planer format.  We'll assume a fixed
; size of 32 bits wide

        push    edx                         ;Save
        push    edi

convert_top:
        push    ecx                         ;Save loop count
        push    edi                         ;Save destination pointer
        push    esi                         ;Save source pointer
        mov     ecx,PTR_WIDTH
                                                
        and     eax,eax                     ;is cursor a dfb
        jnz     short @F                    ;yes
                                            ;no,DIB
        xor     eax,eax                     ;Needs to be zero initialized
        call    vDIB4Convert8               ;Convert one scan
        jmp     short done_with_cvt
@@:
        rep     movsd                       ;DFB
done_with_cvt:

        pop     esi
        pop     edi
        pop     ecx
        add     edi,16                      ;--> next destination scan
        add     esi,16                      ;--> next source scan
        dec     ecx
        jnz     convert_top

; The bitmap has been converted into planer format.  If it needs flipping,
; then flip it

        pop     esi                         ;Start of plane 0
        pop     edx
        or      dl,dl
        js      skipping_first_invert       ;Color bitmap is TOPDOWN
        mov     ecx,PTR_HEIGHT / 2          ;* scans to flip
        lea     edi,[esi][PTR_HEIGHT*4*4]   ;--> last scan

flip_next_scan:
        sub     edi,16                  ;decrement target pointer

        mov     eax,[esi+00h]          ;Load
        mov     ebx,[edi+00h]
        mov     [edi+00h],eax          ;Swap
        mov     [esi+00h],ebx          ;Save

        mov     eax,[esi+04h]          ;Load
        mov     ebx,[edi+04h]
        mov     [edi+04h],eax          ;Swap
        mov     [esi+04h],ebx          ;Save

        mov     eax,[esi+08h]          ;Load
        mov     ebx,[edi+08h]
        mov     [edi+08h],eax          ;Swap
        mov     [esi+08h],ebx          ;Save

        mov     eax,[esi+0Ch]          ;Load
        mov     ebx,[edi+0Ch]
        mov     [edi+0Ch],eax          ;Swap
        mov     [esi+0Ch],ebx          ;Save

        add     esi,16                  ;increment source pointer
        loop    flip_next_scan

skipping_first_invert:
        ret

vConvertDIBPointer  endp

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\rleblts.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: rleblts.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        .list

        .code

;-------------------------------Macro-----------------------------------;
; RleSetUp
;
;   Set the EGA\VGA to write mode 2 (M_COLOR_WRITE).  Initialize local vars
;
; Entry:
;       None
; Returns:
;       ESI = pointer to the source bitmap
;
;-----------------------------------------------------------------------;

RleSetUp    macro

        cld

        mov     dx,VGA_BASE + GRAF_ADDR
        mov     ax,(M_COLOR_WRITE shl 8) + GRAF_MODE
        out     dx,ax

        mov     esi,pRleInfo
        mov     edi,[esi].RLE_prctlTrg
        mov     eax,[edi].xLeft
        mov     xStart,eax
        mov     eax,[esi].RLE_xBegin
        mov     xCurr,eax
        mov     eax,[edi].yBottom
        dec     eax
        mov     yCurr,eax

        mov     eax,[esi].RLE_pulTranslate
        mov     pulXlate,eax
        mov     eax,[esi].RLE_prctlClip
        mov     prclClip,eax
        mov     eax,[esi].RLE_pjSrcBitsMax
        mov     pjSrcEnd,eax
        mov     ebx,[esi].RLE_pjTrg

        mov     pjDst,ebx
        mov     esi,[esi].RLE_pjSrcBits
endm

;-------------------------------Macro-----------------------------------;
; RleDelta
;
;   Handle the Delta case.
;
; Entry:
;       ESI = pointer to the horz/vert offset of the source bitmap
; Returns:
;       None
;
;-----------------------------------------------------------------------;

RleDelta    macro   dest

        lodsw
        movzx   ecx,al
        add     xCurr,ecx               ;x adjustment

        movzx   eax,ah
        sub     yCurr,eax               ;y adjustment

        mul     lNextScan
        sub     pjDst,eax
        jmp     dest
endm

;-------------------------------Macro-----------------------------------;
; RleExit
;
;   Prepare the Rle routine to exit.  Set the EGA/VGA to default write
;   mode.  Save the current status in the RleInfo so we can continue
;   from where we left off if a complex clipping is encountered.
;
; Entry:
;       ESI = pointer pass the first run above the clipping rect
;       EBX = yCurr(y value of the first run above the clipping rect)
;       ECX = xCurr(x value of the first run above the clipping rect)
; Returns:
;       None
;
;-----------------------------------------------------------------------;

RleExit macro

        mov     dx,VGA_BASE + GRAF_ADDR
        mov     ax,(M_PROC_WRITE shl 8) + GRAF_MODE
        out     dx,ax

        mov     ax,0FF00h + GRAF_BIT_MASK
        out     dx,ax                   ;no mask

        mov     edi,pRleInfo            ;update for next call
        dec     esi
        dec     esi
        mov     [edi].RLE_pjSrcBits,esi
        mov     esi,[edi].RLE_prctlTrg
        inc     ebx                     ;make it exclusive
        mov     [esi].yBottom,ebx
        mov     eax,pjDst
        mov     [edi].RLE_pjTrg,eax
        mov     [edi].RLE_xBegin,ecx
endm

;-------------------------------Macro-----------------------------------;
; Clip_Encoded
;
;   Clip the current run in encoded mode against the clipping rect.
;
; Entry:
;       AH = pel color of this run
;       AL = number of pels of this run
; Returns:
;       EAX = left coordinate if no clipping
;       ECX = left coordinate of the clipped run
;       EBX = right coordinate of the clipped run
;
;-----------------------------------------------------------------------;

Clip_Encoded    macro   done, loop_start

        movzx   edx,ah                  ;EDX = pel color
        movzx   eax,al                  ;EAX = number of pels
        mov     ecx,xCurr               ;ECX = left coordinate
        add     xCurr,eax               ;compute new x position
        mov     ebx,yCurr

; Check if y is inside the clipping range.

        mov     edi,prclClip
        cmp     ebx,[edi].yTop
        jb      done
        cmp     ebx,[edi].yBottom
        jae short loop_start

; Clip to the passed in clip rectangle.

        mov     eax,ecx
        cmp     ecx,[edi].xLeft
        jae short @F
        mov     ecx,[edi].xLeft

@@:
        mov     ebx,xCurr
        cmp     ebx,[edi].xRight
        jbe short @F
        mov     ebx,[edi].xRight

@@:
        cmp     ebx,ecx                 ;clipped out if left and right crossed
        jbe short loop_start
endm

;-------------------------------Macro-----------------------------------;
; Draw_Encoded
;
;   Write the current encoded run to the EGA/VGA.
;
; Entry:
;       EBX = right coordinate (exclusive)
;       ECX = left coordinate  (inclusive)
;       EDX = pel color
; Returns:
;       None
;
;-----------------------------------------------------------------------;

Draw_Encoded    macro   loop_start

        call    comp_masks              ;compute bit masks

        shl     eax,8                   ;save right mask in high word
        add     edi,pjDst

        mov     ebx,pulXlate
        mov     ebx,[ebx][edx*4]

        mov     dx,VGA_BASE + GRAF_ADDR

        or      ah,ah                   ;AH = left mask
        jz short @F

        mov     al,GRAF_BIT_MASK        ;Set bitmask for altered bits
        out     dx,ax

        mov     al,[edi]                ;latch dest (value is don't care)
        mov     [edi],bl                ;write dest, with Bit Mask clipping
        inc     edi                     ;update destination pointer

@@:
        or      ecx,ecx                 ;ECX = inner loop count
        jz short @F

        mov     ax,0FF00h + GRAF_BIT_MASK
        out     dx,ax                   ;no mask

        mov     al,bl
        rep     stosb                   ;write color

@@:
        shr     eax,8                   ;AH = right mask
        or      ah,ah
        jz      loop_start

        mov     al,GRAF_BIT_MASK        ;Set bitmask for altered bits
        out     dx,ax
        mov     al,[edi]                ;latch dest (value is don't care)
        mov     [edi],bl                ;write color

        jmp     loop_start
endm

;-------------------------------Macro-----------------------------------;
; Clip_Absolute
;
;   Clip the current run in absolute mode against the clipping rect.
;   Compute initial bit mask and other vars for subsequent loop.
;
; Entry:
;       AH = number of pels of this run
; Returns:
;       AL = GRAF_BIT_MASK
;       AH = bitmap for the first pel
;       EBX = pulXlate (pointer to the xlate table)
;       CH = 01000001b
;       EDI = pointer to destination byte to be altered
;       loop_count = loop count (number of pels to be altered)
;
;-----------------------------------------------------------------------;

Clip_Absolute   macro   done,loop_end,loop_count

        movzx   eax,ah                  ;EAX = number of pels
        mov     ecx,xCurr               ;ECX = left coordinate
        add     xCurr,eax

        mov     ebx,yCurr

; Check if y is inside the clipping range.

        mov     edi,prclClip
        cmp     ebx,[edi].yTop
        jb      done
        cmp     ebx,[edi].yBottom
        jae     loop_end

; Check if x is inside the clipping range.

        cmp     ecx,[edi].xRight        ;check if x is in range
        jae     loop_end

        mov     ebx,xCurr               ;EBX = right coordinate
        cmp     ebx,[edi].xLeft         ;can I not jump???!!!
        jbe     loop_end

; Clip to the passed in clip rectangle.

        cmp     ecx,[edi].xLeft
        mov     cPreSrcAdv,0
        jae short @F
        mov     eax,[edi].xLeft
        sub     eax,ecx                 ;diff of left coor and prclClip->xLeft
        mov     cPreSrcAdv,eax
        add     ecx,eax                 ;ECX = left coordinate = prclClip->xLeft

@@:
        xor     eax,eax                 ;diff of right coor and prclClip->xRight
        cmp     ebx,[edi].xRight
        jbe short @F
        mov     eax,ebx
        mov     ebx,[edi].xRight        ;EBX = right coor = prclClip->xRight
        sub     eax,ebx

@@:
        mov     cPostSrcAdv,eax
        sub     ebx,ecx                 ;loop count

        mov     edi,ecx
        shr     edi,3
        add     edi,pjDst               ;point to the first byte to write

        and     ecx,00000111b           ;Compute bit index for left side
        mov     ah,080h                 ;Compute bit mask
        shr     ah,cl                   ;AL = first pel bit mask
        mov     al,GRAF_BIT_MASK
        mov     loop_count,bl           ;loop count < 0FFh
        mov     ch,01000001b            ;for later use
        mov     ebx,pulXlate
endm

;-------------------------------Macro-----------------------------------;
; RleEOL
;
;   Handle the End of line case.
;
; Entry:
;       None.
; Returns:
;       None.
;
;-----------------------------------------------------------------------;

RleEOL  macro   loop_start

        mov     eax,lNextScan
        sub     pjDst,eax               ;adjust pjDst
        dec     yCurr                   ;adjust yCurr
        mov     eax,xStart              ;adjust xCurr
        mov     xCurr,eax
        jmp     loop_start
endm


;-------------------------------Macro-----------------------------------;
; Set up banking-related variables, and make sure the bank for the
; initial (bottom) scan line is mapped in.
;
; Entry:
;       None.
; Returns:
;       EBX = pdsurf
;       ESI = pRleInfo
;       EDI = RLE_prctlClip
;
;-------------------------------Macro-----------------------------------;

RleBankSetUp macro
        local   map_bank,bank_mapped

        mov     esi,pRleInfo
        mov     ebx,[esi].Rle_pdsurfTrg
        mov     pdsurf,ebx

        mov     eax,[ebx].dsurf_lNextScan
        mov     lNextScan,eax

        mov     edi,[esi].RLE_prctlClip
        mov     eax,[edi].yTop
        mov     ulTrueClipTop,eax       ;we blt until we reach this scan line

; Map in the bottom scan line of the clip rect.

        mov     eax,[edi].yBottom       ;bottom clip scan, exclusive
        dec     eax                     ;make it inclusive
        cmp     eax,[ebx].dsurf_rcl1WindowClip.yTop
        jl      short map_bank
        cmp     eax,[ebx].dsurf_rcl1WindowClip.yBottom
        jl      short bank_mapped
map_bank:
        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,eax,JustifyBottom>
bank_mapped:

        endm


;-------------------------------Macro-----------------------------------;
; Set up the screen pointer and clip the clip rect to the current bank.
;
; Entry:
;       EBX = pdsurf
;       ESI = pRleInfo
;       EDI = RLE_prctlClip
; Returns:
;       None.
;
;-------------------------------Macro-----------------------------------;

RleBankTop macro

; Convert the screen pointer from an offset within the bitmap to a virtual
; address.

        mov     eax,[ebx].dsurf_pvBitmapStart
        add     [esi].RLE_pjTrg,eax

; Set the clip rect top to MAX(top_of_bank,top_of_clip), to confine drawing to
; this bank.

        mov     eax,[ebx].dsurf_rcl1WindowClip.yTop
        cmp     ulTrueClipTop,eax
        jl      short @F
        mov     eax,ulTrueClipTop
@@:
        mov     [edi].yTop,eax

        endm


;-------------------------------Macro-----------------------------------;
; Check whether we've done the last bank spanned by this clip rect; exit
; if so, map in the bank and continue if not.
;
; Entry:
;       None.
; Returns:
;       EBX = pdsurf
;       ESI = pRleInfo
;       EDI = RLE_prctlClip
;
;-------------------------------Macro-----------------------------------;

RleBankBottom macro     loop_top,done

; Convert the screen pointer back to an offset within the bitmap.

        mov     ebx,pdsurf
        mov     esi,pRleInfo
        mov     eax,[ebx].dsurf_pvBitmapStart
        sub     [esi].RLE_pjTrg,eax

; Have we reached the top bank involved in this blt? If so, done; if not, map
; it in and blt the next bank.

        mov     eax,[ebx].dsurf_rcl1WindowClip.yTop
        cmp     eax,ulTrueClipTop
        jle     short &done
        dec     eax     ;map in the bank above the current one
        ptrCall <dword ptr [ebx].dsurf_pfnBankControl>,<ebx,eax,JustifyBottom>

        mov     edi,[esi].RLE_prctlClip ;for RleBankTop

        jmp     &loop_top

        endm


;--------------------------Public-Routine-------------------------------;
; vRle8ToVga
;
;   Write an RLE8 bitmap onto the VGA device.
;
; Entry:
;       None.
; Returns:
;       None
;
;-----------------------------------------------------------------------;

cProc   vRle8ToVga,4,<       \
        uses    esi edi ebx,  \
        pRleInfo: ptr RLEINFO >

        local   pjDst       :ptr
        local   pulXlate    :ptr
        local   xCurr       :dword
        local   yCurr       :dword
        local   xStart      :dword
        local   cPreSrcAdv  :dword
        local   cPostSrcAdv :dword
        local   prclClip    :ptr RECTL
        local   pjSrcEnd    :ptr
        local   pdsurf      :ptr DEVSURF
        local   ulTrueClipTop :dword
        local   lNextScan   : dword

        RleBankSetUp    ;wrap a banking loop around everything

rle8_bank_loop:

        RleBankTop

        RleSetUp

rle8_loop:
        cmp     esi,pjSrcEnd
        jae     rle8_done
        lodsw                           ;fetch a word from src RLE bitmap

        or      al,al
        jz      short rle8_escape

rle8_encoded:
        Clip_Encoded    rle8_done,rle8_loop
        Draw_Encoded    rle8_loop

rle8_escape:
        cmp     ah,2                    ; First byte is 0, check the second byte.
        ja      short rle8_absolute
        jb      rle8_end_of_line_or_bitmap

rle8_delta:
        RleDelta    rle8_loop

rle8_absolute:
        Clip_Absolute   rle8_done,rle8_absolute_advance_src,cl
        add     esi,cPreSrcAdv          ;advance esi to point to the clipped run

; I am doing a per pel loop rather than a per byte loop which writes 1 plane
; at a time because it appears to me that most of the time we output 2 or
; 3 pels per encounter of absolute mode.  The logic here is simple and we can
; stay with M_COLOR_WRITE mode all the time.

rle8_absolute_loop:
        mov     dx,VGA_BASE + GRAF_ADDR
        out     dx,ax                   ;Set bitmask for altered bit

        mov     dl,[edi]                ;latch dest (value is don't care)

        sub     edx,edx
        mov     dl,byte ptr [esi]       ;grab color for this pel
        inc     esi

        mov     edx,[ebx][edx*4]
        mov     [edi],dl                ;write to destination

        ror     ah,1                    ;rotate bit mask for next pel
        cmp     ch,ah                   ;cmp bitmask with 01000001b
        adc     edi,0                   ;advance edi if bitmask is 10000000b

        dec     cl                      ;per pel loop
        jnz short rle8_absolute_loop
        mov     eax,cPostSrcAdv

rle8_absolute_advance_src:
        add     esi,eax                 ;advance src ptr for clipped out pels
        bt      esi,0                   ;add 1 if not word aligned
        adc     esi,0
        jmp     rle8_loop

rle8_end_of_line_or_bitmap:
        or      ah,ah
        jnz short rle8_end_of_bitmap

rle8_end_of_line:

        RleEOL  rle8_loop

rle8_done:
        RleExit

        RleBankBottom   rle8_bank_loop,rle8_exit ;see if there are more banks
                                                 ; to do
rle8_end_of_bitmap:
        RleExit
rle8_exit:
        cRet    vRle8ToVga

endProc vRle8ToVga


;--------------------------Public-Routine-------------------------------;
; vRle4ToVga
;
;   Write an RLE4 bitmap onto the VGA device.
;
; Entry:
;       None
; Returns:
;       None
;
;-----------------------------------------------------------------------;

cProc   vRle4ToVga,4,<       \
        uses    esi edi ebx,  \
        pRleInfo: ptr RLEINFO >

        local   pjDst       :ptr
        local   pulXlate    :ptr
        local   xCurr       :dword
        local   yCurr       :dword
        local   xStart      :dword
        local   cPreSrcAdv  :dword
        local   cPostSrcAdv :dword
        local   pjDstStart  :ptr
        local   iPels       :dword
        local   xMask       :dword
        local   nPels       :byte
        local   prclClip    :ptr RECTL
        local   pjSrcEnd    :ptr
        local   pdsurf      :ptr DEVSURF
        local   ulTrueClipTop :dword
        local   lNextScan   : dword

        RleBankSetUp    ;wrap a banking loop around everything

rle4_bank_loop:

        RleBankTop

        RleSetUp

rle4_loop:
        cmp     esi,pjSrcEnd
        jae     rle4_done
        lodsw                           ;fetch a word

        or      al,al
        jz      rle4_escape

rle4_encoded:
        Clip_Encoded    rle4_done,rle4_loop

        mov     dh,dl                   ;separate two colors into dl, dh
        and     dl,0Fh
        shr     dh,4
        cmp     dh,dl
        jnz short encoded_diff_color
        xor     dh,dh                   ;Draw_Encoded use edx as color index
        Draw_Encoded    rle4_loop

encoded_diff_color:
        sub     eax,ecx                 ;-eax = #pels clipped away
        bt      eax,0
        jnc short @F
        xchg    dl,dh                   ;xchg colors if odd #pels clipped
@@:
        mov     iPels,edx               ;save color index
        sub     ebx,ecx                 ;Compute extent of interval
        dec     ebx                     ;Make interval inclusive
        mov     edi,ecx                 ;Don't destroy starting X
        shr     edi,3                   ;/8 for byte address
        add     edi,pjDst

        and     ecx,00000111b           ;Compute bit index for first byte
        mov     eax,00AAAAAAh           ;Compute altered bits mask
        shr     eax,cl                  ;AL = left side altered bytes mask

        add     ebx,ecx                 ;Compute bit index for last byte
        mov     ecx,ebx                 ;(save for inner loop count)
        and     ecx,00000111b
        mov     ch,80h
        sar     ch,cl
        and     al,ch                   ;AL = last byte altered bits mask

        mov     edx,eax
        shr     edx,1
        and     dl,ch                   ;EDX = mask for 2nd pel

        mov     ecx,ebx
        shr     ecx,3                   ;Compute inner byte count
        jnz     short comp_byte_dont_combine ;loop count + 1 > 0, check it out

; Only one byte will be affected.  Combine first/last masks, set loop count = 0

        mov     ebx,eax
        shl     eax,16                  ;Will use first byte mask only
        and     eax,ebx                 ;AH = first mask. Rest of the bits = 0

        mov     ebx,edx
        shl     edx,16                  ;Will use first byte mask only
        and     edx,ebx                 ;DH = first mask. Rest of the bits = 0
        inc     ecx                     ;Fall through to set 0

comp_byte_dont_combine:
        dec     ecx                     ;Dec inner loop count (might become 0)

        xchg    al,ah
        ror     eax,16                  ;EAX = last mask:inter mask:first mask:0
        xchg    al,ah                   ;for first pel
        xchg    dl,dh
        ror     edx,16                  ;EDX = last mask:inter mask:first mask:0
        xchg    dl,dh                   ;for second pel

        mov     pjDstStart,edi
        mov     xMask,edx                ;save mask for the 2nd round

        mov     ebx,pulXlate
        mov     edx,iPels
        shr     edx,8                   ;index for the first pel
        mov     ebx,[ebx][edx*4]
        inc     bh                      ;BH = rle4_encoded_diff_color_loop count
        inc     bh
        mov     dx,VGA_BASE + GRAF_ADDR
                                        ;BL = color for first pel
rle4_encoded_diff_color_loop:
        or      ah,ah                   ;AH = first mask
        jz short encoded_inner_diff_color

        mov     al,GRAF_BIT_MASK        ;Set bitmask for altered bits
        out     dx,ax

        mov     al,[edi]                ;latch dest (value is don't care)
        mov     [edi],bl                ;write color
encoded_inner_diff_color:
        inc     edi                     ;update destination pointer
        shr     eax,8                   ;AH = internal mask
        or      cl,cl                   ;ECX = inner loop count
        jz short encoded_last_byte_diff_color

        mov     ch,cl                   ;save loop count in ch
                                        ;loop count always fit in a byte
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;no mask

encoded_loop_diff_color:
        mov     al,[edi]                ;latch dest (value is don't care)
        mov     [edi],bl                ;write color
        inc     edi
        dec     cl
        jnz     short encoded_loop_diff_color

encoded_last_byte_diff_color:
        shr     eax,8                   ;AH = last mask
        or      ah,ah
        jz      short encoded_this_run_maybe_done

        mov     al,GRAF_BIT_MASK        ;Set bitmask for altered bits
        out     dx,ax

encoded_write:
        mov     al,[edi]                ;latch dest (value is don't care)
        mov     [edi],bl                ;write color

encoded_this_run_maybe_done:
        dec     bh
        jz      rle4_loop

        mov     edi,pulXlate
        mov     eax,iPels               ;index of the second pel
        xor     ah,ah
        mov     bl,byte ptr [edi][eax*4]
        mov     edi,pjDstStart
        mov     eax,xMask               ;load mask
        mov     cl,ch                   ;loop count

        jmp     rle4_encoded_diff_color_loop

rle4_escape:
        cmp     ah,2                    ; First byte is 0, check the second byte.
        ja      short rle4_absolute
        jb      rle4_end_of_line_or_bitmap

rle4_delta:

        RleDelta    rle4_loop

rle4_absolute:
        Clip_Absolute   rle4_done,rle4_absolute_advance_src,nPels

;advance esi to point to the clipped run

        mov     edx,cPreSrcAdv          ;number of pels to advance
        shr     edx,1                   ;number of bytes
        jnc     short @F

        add     esi,edx                 ;odd number of pels to advance
        movzx   edx,byte ptr [esi]      ;grab color for prev and this pels
        inc     esi
        mov     iPels,edx

        inc     nPels                   ;inc loop count since we start from 1
        mov     cl,1
        jmp short absolute_loop

@@:                                     ;even number of pels to advance
        add     esi,edx

; I am doing a per pel loop rather than a per byte loop which writes 1 plane
; at a time because it appears to me that most of the time we output 2 or
; 3 pels per encounter of absolute mode.  The logic here is simple and we can
; stay with M_COLOR_WRITE mode all the time.

        xor     cl,cl                   ;initialize loop count

absolute_loop:
        mov     dx,VGA_BASE + GRAF_ADDR
        out     dx,ax                   ;Set bitmask for altered bit

        mov     dl,[edi]                ;latch dest (value is don't care)

        bt      ecx,0
        jc      short @F

        movzx   edx,byte ptr [esi]      ;grab color for this and next pels
        inc     esi

        mov     iPels,edx               ;save for next pel
        shr     dl,4
        jmp short   ready_to_draw
@@:
        mov     edx,iPels               ;second pel
        and     dl,0Fh                  ;mask out the second pel

ready_to_draw:
        mov     edx,[ebx][edx*4]        ;look up for VGA color
        mov     [edi],dl                ;write to destination

        ror     ah,1                    ;rotate bit mask for next pel
        cmp     ch,ah                   ;cmp bitmask with 01000001b
        adc     edi,0                   ;advance edi if bitmask is 10000000b

        inc     cl
        cmp     cl,nPels
        jnz short absolute_loop

        mov     eax,cPostSrcAdv

rle4_absolute_advance_src:
        shr     eax,1                   ;2 pels for one byte
        add     esi,eax                 ;advance src ptr for clipped out pels
        bt      esi,0                   ;add 1 if not word aligned
        adc     esi,0
        jmp     rle4_loop


rle4_end_of_line_or_bitmap:
        or      ah,ah
        jnz short rle4_end_of_bitmap

rle4_end_of_line:
        RleEOL  rle4_loop

rle4_done:
        RleExit

        RleBankBottom   rle4_bank_loop,rle4_exit ;see if there are more banks
                                                 ; to do
rle4_end_of_bitmap:
        RleExit
rle4_exit:
        cRet    vRle4ToVga

endProc vRle4ToVga

;--------------------------Private-Routine------------------------------;
; comp_byte_interval
;
;   An interval will be computed for byte boundaries.
;
;   A first mask and a last mask will be calculated, and possibly
;   combined into the inner loop count.  If no first byte exists,
;   the start address will be incremented to adjust for it.
;
; Entry:
;       EBX = right coordinate (exclusive)
;       ECX = left coordinate  (inclusive)
; Returns:
;       EDI = offset to first byte to be altered in the scan
;       ECX = inner loop count
;       AL  = first byte mask (possibly 0)
;       AH  = last  byte mask (possibly 0)
; Error Returns:
;       None
; Registers Preserved:
;       ES,BP
; Registers Destroyed:
;       AX,BX,CX,DI,FLAGS
; Calls:
;       None
;
;-----------------------------------------------------------------------;

comp_masks      proc

        sub     ebx,ecx                 ;Compute extent of interval
        dec     ebx                     ;Make interval inclusive
        mov     edi,ecx                 ;Don't destroy starting X
        shr     edi,3                   ;/8 for byte address

        and     ecx,00000111b           ;Compute bit index for left side
        mov     al,0FFh                 ;Compute left side altered bits mask
        shr     al,cl                   ;AL = left side altered bytes mask

        add     ebx,ecx                 ;Compute bit index for right side
        mov     ecx,ebx                 ;(save for inner loop count)
        and     ecx,00000111b
        mov     ah,80h
        sar     ah,cl                   ;AH = right side altered bits mask

        shr     ebx,3                   ;Compute inner byte count
        jnz     short comp_byte_dont_combine ;loop count + 1 > 0, check it out

; Only one byte will be affected.  Combine first/last masks, set loop count = 0

        and     al,ah                   ;Will use first byte mask only
        xor     ah,ah                   ;Want last byte mask to be 0
        inc     ebx                     ;Fall through to set 0

comp_byte_dont_combine:
        dec     ebx                     ;Dec inner loop count (might become 0)

; If all pixels in the first byte are altered, combine the first byte into the
; inner loop and clear the first byte mask.  Ditto for the last byte mask.

        mov     ecx,0FFFFFFFFh
        cmp     al,cl                   ;Set 'C' if not all pixels 1
        sbb     ebx,ecx                 ;If no 'C', sub -1 (add 1), else sub 0
        cmp     al,cl                   ;Set 'C' if not all pixels 1
        sbb     al,cl                   ;If no 'C', sub -1 (add 1), else sub 0

        cmp     ah,cl                   ;Set 'C' if not all pixels 1
        sbb     ebx,ecx                 ;If no 'C', sub -1 (add 1), else sub 0
        cmp     ah,cl                   ;Set 'C' if not all pixels 1
        sbb     ah,cl                   ;If no 'C', sub -1 (add 1), else sub 0

        mov     ecx,ebx                 ;Return inner loop count in ECX

        ret

comp_masks endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\restscrn.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: restscrn.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vRestoreScreenBitsFromMemory(PDEVSURF pdsurf, PRECTL prcl,
;                              PVOID pjSrcBuffer, ULONG ulRestoreWidthInBytes,
;                              ULONG ulSrcDelta);
; Input:
;  pdsurf - surface to which to copy
;  prcl - pointer to rectangle to which to copy
;  pjSrcBuffer - pointer to source memory buffer. Should have the same
;                 dword alignment as the dest rect left edge does in screen
;                 memory
;  ulRestoreWidthInBytes - # of bytes to restore per scan (including any
;                 partial edges)
;  ulSrcDelta - distance from end of one source scan to start of next.
;                 together with ulRestoreWidthInBytes, should maintain
;                 dword alignment between source and dest
;
; Copies a rectangle from a memory buffer to VGA memory.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;
;
; Note: The rectangle is restored from interleaved-scan format; all four planes
; of one scan are saved together, then all four planes of the next scan,
; and so on. This is done for maximum restoration efficiency. Planes are
; saved in order 3, 2, 1, 0:
;
;  Scan n, plane 3
;  Scan n, plane 2
;  Scan n, plane 1
;  Scan n, plane 0
;  Scan n+1, plane 3
;  Scan n+1, plane 2
;  Scan n+1, plane 1
;  Scan n+1, plane 0
;          :
;
; There may be padding on either edge of the saved bits in the destination
; buffer, so that the destination can be dword aligned with the source.
;
;-----------------------------------------------------------------------;
;Additional optimizations:
;
; Could break out separate scan copy code with and without edge handling.
; (Possibly by threading the desired operations, or by having many separate
; optimizations.)
;
; Could handle odd bytes to dword align more efficiently, by having separate
; optimizations for various alignment widths, thereby avoiding starting REP
; and getting word accesses for 2 and 3 wide cases. Most VGAs are 8 or 16
; bit devices, and for them, using MOVSB/REP MOVSW/MOVSB might actually be
; faster, especially because it's easier to break out optimizations.
;
; Could end all scan handlers with loop bottom code.
;
; Could do more scans in one plane before doing next plane, to avoid
; slow OUTs. This could cause color effects, but that might be avoidable
; by scaling the # of scans done per plane to the width of the rectangle.
;
;-----------------------------------------------------------------------;


                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

        .data

;-----------------------------------------------------------------------;
; Masks used to do left and right edge clipping for various alignments.
; Low byte = destination mask, high byte = source mask.
;-----------------------------------------------------------------------;
        align   2
usLeftMasks     label   word
        dw      0ff00h, 07f80h, 03fc0h, 01fe0h, 00ff0h, 007f8h, 003fch, 001feh

usRightMasks    label   word
        dw      0ff00h, 0807fh, 0c03fh, 0e01fh, 0f00fh, 0f807h, 0fc03h, 0fe01h

;-----------------------------------------------------------------------;
; Same as above, but dest masks only, and whole byte case is represented
; as 0ffh rather than 0. Used for 1-byte-wide cases.
;-----------------------------------------------------------------------;
jLeftMasks      label   byte
        db      0ffh, 080h, 0c0h, 0e0h, 0f0h, 0f8h, 0fch, 0feh

jRightMasks     label   byte
        db      0ffh, 07fh, 03fh, 01fh, 00fh, 007h, 003h, 001h

        .code

_TEXT$03   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc   vRestoreScreenBitsFromMemory,20,< \
        uses    esi edi ebx,         \
        pdsurf:ptr,                  \
        prcl:ptr,                    \
        pjSrcBuffer:ptr,             \
        ulRestoreWidthInBytes:dword, \
        ulSrcDelta:dword             >

        local   ulCurrentTopScan :dword ;top scan line to copy to in current
                                        ; bank
        local   ulBottomScan :dword     ;bottom scan line of rectangle to which
                                        ; to copy
        local   pjDstStart :dword       ;destination address
        local   ulDstDelta :dword       ;distance from end of dest scan to
                                        ; start of next
        local   ulBlockHeight :dword    ;# of scans to copy in block
        local   ulLeadingBytes :dword   ;# of leading bytes to copy per scan
        local   ulMiddleDwords :dword   ;# of dwords to copy per scan
        local   ulTrailingBytes :dword  ;# of trailing bytes to copy per scan
        local   pfnCopyVector :dword    ;pointer to inner loop routine to copy
                                        ; from buffer to screen
        local   ulLeftMask :dword       ;2 byte masks for left edge clipping
                                        ; (low byte = dest mask,
                                        ;  high byte = src mask)
        local   ulRightMask :dword      ;2 byte masks for right edge clipping

;-----------------------------------------------------------------------;
; Leave the GC Index pointing to the Read Map for the rest of this routine.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

;-----------------------------------------------------------------------;
; Set up local variables.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle from which to copy
        mov     esi,pdsurf              ;point to surface from which to copy

        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;bottom scan line of source rect

        mov     eax,[esi].dsurf_lNextScan
        sub     eax,ulRestoreWidthInBytes
        mov     ulDstDelta,eax  ;distance from end of one scan's bits to save
                                ; to start of next scan's in display memory

;-----------------------------------------------------------------------;
; Figure out the left and right clip masks. If either or both edges are
; solid, add them into the whole bytes.
;-----------------------------------------------------------------------;

        mov     ebx,[edi].xLeft
        mov     ecx,[edi].xRight
        mov     edx,ebx
        lea     eax,[ecx-1]
        and     ebx,0111b
        and     ecx,0111b

        and     edx,not 0111b
        sub     eax,edx
        shr     eax,3           ;width in bytes - 1
                                ;only 1 byte wide?
        jnz     short @F        ;no
                                ;1 byte wide; special case
        mov     al,jLeftMasks[ebx]      ;look up left dest mask
        and     al,jRightMasks[ecx]     ;factor in right dest mask
        mov     ah,0ffh
        mov     ebx,offset copy_from_buffer_l_whole_only ;assume whole byte
        xor     ah,al                   ;calculate matching dest mask
                                ;is this single byte a whole byte?
        jz      set_copy_vector ;yes, select whole byte optimization
                                ;no, select partial byte optimization
        mov     ebx,offset copy_from_buffer_l_partial_only
        mov     ulLeftMask,eax
        jmp     set_copy_vector

        align   4
@@:                                     ;more than 1 byte wide

        mov     edx,ulRestoreWidthInBytes

        mov     ax,usLeftMasks[ebx*2]   ;look up left masks
        mov     ulLeftMask,eax
        and     al,al                   ;any left clipping?
        jz      short @F                ;no, do as part of whole bytes
        dec     edx                     ;yes, don't count as whole byte
@@:


        mov     ax,usRightMasks[ecx*2]  ;look up right masks
        mov     ulRightMask,eax
        and     al,al                   ;any right clipping?
        jz      short @F                ;no, do as part of whole bytes
        dec     edx                     ;yes, don't count as whole byte
@@:

;-----------------------------------------------------------------------;
; Set up for copying as much as possible via aligned dwords, and
; select the most efficient loop for doing the copy, based on the copy
; width, and on the necessity for leading and/or trailing bytes to
; dword align.
;-----------------------------------------------------------------------;

        cmp     edx,8                   ;if it's less than 8 bytes, just do a
                                        ; straight byte copy. This means we
                                        ; we only have to start 1 REP per line,
                                        ; and performing this check guarantees
                                        ; that we have at least 1 aligned dword
                                        ; to copy in the dword loops
        jb      short copy_all_as_bytes ;do straight byte copy
        mov     eax,pjSrcBuffer
        neg     eax
        and     eax,3           ;# of bytes that have to be done as leading
                                ; bytes to dword align with source (note that
                                ; for performance, the source should be dword
                                ; aligned with the destination)
        jz      short copy_no_leading_bytes     ;no leading bytes
                                ;leading bytes
        mov     ulLeadingBytes,eax
        mov     ebx,offset copy_from_buffer_l ;assume no trailing bytes
        sub     edx,eax         ;# of bytes after leading bytes
        mov     eax,edx
        shr     eax,2           ;# of dwords that can be handled as aligned
                                ; dwords
        mov     ulMiddleDwords,eax
        and     edx,3           ;# of trailing bytes left after aligned dwords
                                ; copied
        jz      short set_copy_vector ;no trailing bytes
        mov     ulTrailingBytes,edx
        mov     ebx,offset copy_from_buffer_lt  ;there are both leading and
                                                ; trailing bytes
        jmp     short set_copy_vector

        align   4
copy_no_leading_bytes:
        mov     ebx,offset copy_from_buffer ;assume no trailing bytes
        mov     eax,edx
        shr     eax,2           ;# of dwords that can be handled as aligned
                                ; dwords
        mov     ulMiddleDwords,eax
        and     edx,3           ;# of trailing bytes left after aligned dwords
                                ; copied
        jz      short set_copy_vector ;no trailing bytes
        mov     ulTrailingBytes,edx
        mov     ebx,offset copy_from_buffer_t     ;there are trailing bytes
        jmp     short set_copy_vector

; It's so narrow that we'll forget about aligned dwords, and just do a straight
; byte copy, which we'll handle by treating the entire copy as leading bytes.
        align   4
copy_all_as_bytes:
        mov     ulLeadingBytes,edx
        mov     ebx,offset copy_from_buffer_lonly

set_copy_vector:
        mov     pfnCopyVector,ebx

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to copy, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     eax,[edi].yTop          ;top scan line of copy
        mov     ulCurrentTopScan,eax    ;this will be the copy top in 1st bank

        cmp     eax,[esi].dsurf_rcl1WindowClip.yTop ;is copy top less than
                                                    ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[esi].dsurf_rcl1WindowClip.yBottom ;copy top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the copy.

        ptrCall   <dword ptr [esi].dsurf_pfnBankControl>,<esi,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Calculate the initial start address to which to copy.
;-----------------------------------------------------------------------;

        mov     eax,ulCurrentTopScan    ;top scan line to copy to in current
                                        ; bank
        imul    [esi].dsurf_lNextScan   ;offset of starting scan line in bitmap
        add     eax,[esi].dsurf_pvBitmapStart ;start address of scan
        mov     ebx,[edi].xLeft
        shr     ebx,3                   ;convert from pixel to byte address
        add     eax,ebx                 ;start dest address
        mov     pjDstStart,eax

;-----------------------------------------------------------------------;
; Loop through and copy all bank blocks spanned by the destination
; rectangle.
;
; Input:
;  ESI = pdsurf
;-----------------------------------------------------------------------;

copy_from_buffer_bank_loop:

; Copy this bank block to the buffer.

; Calculate # of scans in this bank.

        mov     ebx,ulBottomScan        ;bottom of dest rectangle
        cmp     ebx,[esi].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;dest bottom comes first, so copy to
                                        ; that; this is the last bank in copy
        mov     ebx,[esi].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; copy to
                                        ; bottom of bank
@@:
        sub     ebx,ulCurrentTopScan    ;# of scans to copy in this bank
        mov     ulBlockHeight,ebx

        mov     esi,pjSrcBuffer ;point to start of source rect

        mov     dh,VGA_BASE SHR 8       ;leave DH pointing to VGA_BASE

;-----------------------------------------------------------------------;
; Loop through all scans in this block, copying all four planes of each
; scan in turn, then doing the next scan.
;-----------------------------------------------------------------------;
copy_to_buffer_scan_loop:

        mov     bl,MM_C3        ;start by copying to plane 3

;-----------------------------------------------------------------------;
; Loop through all four planes, copying all scans in this block for each
; plane in turn.
;-----------------------------------------------------------------------;

copy_to_buffer_plane_loop:

        mov     dl,SEQ_DATA
        mov     al,bl
        out     dx,al           ;set Map Mask to plane to which we're copying

        mov     dl,GRAF_DATA
        shr     al,1
        cmp     al,3
        adc     al,-1
        out     dx,al

        mov     edi,pjDstStart  ;point to start of dest buffer (scan starts
                                ; at same address in all planes)
        jmp     pfnCopyVector   ;jump to the appropriate loop to copy plane

;-----------------------------------------------------------------------;
; Copy loops, broken out by leading and trailing bytes needed for dword
; alignment, plus one loop to perform a straight byte copy.
;
; Input:
;  ESI = initial source copy address
;  EDI = initial dest copy address
;-----------------------------------------------------------------------;

; All bytes can be copied as aligned dwords (no leading or trailing whole
; bytes).
        align   4
copy_from_buffer:

; Do the left edge byte, if there's a partial left edge byte.

        mov     eax,ulLeftMask  ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;left edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

; Do the middle (whole) bytes.

        mov     ecx,ulMiddleDwords
        rep     movsd

; Do the right edge byte, if there's a partial right edge byte.

        mov     eax,ulRightMask ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;right edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

        jmp     copy_from_buffer_scan_done

; Leading odd whole bytes, but no trailing whole bytes.
        align   4
copy_from_buffer_l:

; Do the left edge byte, if there's a partial left edge byte.

        mov     eax,ulLeftMask  ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;left edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

; Do the middle (whole) bytes.

        mov     ecx,ulLeadingBytes
        rep     movsb
        mov     ecx,ulMiddleDwords
        rep     movsd

; Do the right edge byte, if there's a partial right edge byte.

        mov     eax,ulRightMask ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;right edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

        jmp     copy_from_buffer_scan_done

; Trailing odd whole bytes, but no leading whole bytes.
        align   4
copy_from_buffer_t:

; Do the left edge byte, if there's a partial left edge byte.

        mov     eax,ulLeftMask  ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;left edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

; Do the middle (whole) bytes.

        mov     ecx,ulMiddleDwords
        rep     movsd
        mov     ecx,ulTrailingBytes
        rep     movsb

; Do the right edge byte, if there's a partial right edge byte.

        mov     eax,ulRightMask ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;right edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

        jmp     copy_from_buffer_scan_done

; Only leading whole bytes (straight whole byte copy; no aligned dwords).
        align   4
copy_from_buffer_lonly:

; Do the left edge byte, if there's a partial left edge byte.

        mov     eax,ulLeftMask  ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;left edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

; Do the middle (whole) bytes.

        mov     ecx,ulLeadingBytes
        rep     movsb

; Do the right edge byte, if there's a partial right edge byte.

        mov     eax,ulRightMask ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;right edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

        jmp     short copy_from_buffer_scan_done

; Only one masked byte; no whole bytes and no right byte.
        align   4
copy_from_buffer_l_partial_only:

        mov     eax,ulLeftMask  ;AL = dest mask, AH = source mask
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
        jmp     short copy_from_buffer_scan_done

; Only one whole byte; no left byte and no right byte.
        align   4
copy_from_buffer_l_whole_only:

        movsb                   ;copy the one byte
        jmp     short copy_from_buffer_scan_done

; Leading and trailing odd whole bytes.
        align   4
copy_from_buffer_lt:

; Do the left edge byte, if there's a partial left edge byte.

        mov     eax,ulLeftMask  ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;left edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

; Do the middle (whole) bytes.

        mov     ecx,ulLeadingBytes
        rep     movsb
        mov     ecx,ulMiddleDwords
        rep     movsd
        mov     ecx,ulTrailingBytes
        rep     movsb

; Do the right edge byte, if there's a partial right edge byte.

        mov     eax,ulRightMask ;AL = dest mask, AH = source mask
        and     al,al           ;any left mask?
        jz      short @F        ;right edge is whole
        and     al,[edi]        ;mask the dest
        and     ah,[esi]        ;mask the source
        inc     esi             ;point to next source byte
        or      al,ah           ;combine the source and dest
        stosb                   ;store the new byte
@@:

copy_from_buffer_scan_done:

        add     esi,ulSrcDelta  ;point to next source scan
        shr     bl,1            ;count down planes
        jnz     copy_to_buffer_plane_loop

        add     edi,ulDstDelta  ;point to next dest scan
        mov     pjDstStart,edi
        dec     ulBlockHeight   ;count down scans
        jnz     copy_to_buffer_scan_loop

; Remember where we left off, for the next block.

        mov     pjSrcBuffer,esi

;-----------------------------------------------------------------------;
; See if there are more banks to do
;-----------------------------------------------------------------------;

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_rcl1WindowClip.yBottom ;is the copy bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jle     short copy_from_buffer_banks_done        ;yes, so we're done
                                        ;no, map in the next bank and copy it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)
        mov     edx,[esi].dsurf_pvBitmapStart
        sub     pjDstStart,edx  ;convert from address to offset within bitmap

        ptrCall   <dword ptr [esi].dsurf_pfnBankControl>,<esi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address in this bank.
; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        mov     eax,[esi].dsurf_pvBitmapStart
        add     pjDstStart,eax  ;address of next scan to draw

; Copy the new bank.

        jmp     copy_from_buffer_bank_loop


;-----------------------------------------------------------------------;
; Done with all banks.
;
; At this point:
;  DX = VGA_BASE + GRAF_DATA
;-----------------------------------------------------------------------;
        align 4
copy_from_buffer_banks_done:

        mov     ax,(MM_ALL shl 8)+SEQ_MAP_MASK  ;restore writability for all planes
        mov     dx,VGA_BASE+SEQ_ADDR
        out     dx,ax

        cRet    vRestoreScreenBitsFromMemory ;done

;-----------------------------------------------------------------------;

endProc vRestoreScreenBitsFromMemory

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\unroll.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: unroll.inc
;
; Equates and macros for loop unrolling.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Module including this must define LOOP_UNROLL_SHIFT. the log2 of the number
; of times you want loops in this module unrolled. For example,
; LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8 times unrolling. This is the only
; thing you need to change to control unrolling.

; # of times to unroll the loop, calculated as 2**n, where n is the
; user-specified log2 of # of times to unroll the loop.

LOOP_UNROLL_COUNT equ   (1 shl LOOP_UNROLL_SHIFT)

;-----------------------------------------------------------------------;
; Macro to generate an unrolled loop of UNROLL_COUNT instances of BASE_MACRO,
; passing the base macro the info needed to construct a label of the form
; BASE_LABELxxx, where xxx is UNROLL_COUNT the first time, and counts down by
; one each time thereafter.

UNROLL_LOOP macro BASE_MACRO,BASE_LABEL,UNROLL_COUNT

INDEX=UNROLL_COUNT
        rept UNROLL_COUNT ;-------------------------;
        &BASE_MACRO &BASE_LABEL,%INDEX
INDEX=INDEX-1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Macro to generate a dword memory variable that points to the label
; specified by concatenating the label and the index.

DEFINE_DD macro BASE_LABEL,INDEX ;------------------;
        dd      &BASE_LABEL&INDEX
        endm    ;-----------------------------------;
        
;-----------------------------------------------------------------------;
; Macro to generate a table of vectors into an unrolled loop, for entering
; to handle all possible fractional loops.

UNROLL_LOOP_ENTRY_TABLE macro TABLE,BASE_LABEL,UNROLL_COUNT
        align   4
TABLE label  dword
        DEFINE_DD       BASE_LABEL,%&UNROLL_COUNT

INDEX=1
        rept    UNROLL_COUNT-1
        DEFINE_DD       BASE_LABEL,%INDEX
INDEX=INDEX+1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_VARS macro COUNT_DEST,VEC_DEST,COUNT_SOURCE,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_DEST&,&COUNT_SOURCE&       ;copy count to vector dest to
                                                ; work with it
        ifdifi  <&COUNT_SOURCE&>,<&COUNT_DEST&>
        mov     &COUNT_DEST&,&COUNT_SOURCE&     ;copy to count dest too, if not
        endif                                   ; same as count source
        add     &COUNT_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_DEST&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        mov     &VEC_DEST&,&VEC_TABLE&[&VEC_DEST&*4]
                                            ;place to jump into the unrolled
                                            ; loop so as to handle the
                                            ; fractional part first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_AND_BRANCH macro COUNT_REG,VEC_REG,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_REG&,&COUNT_REG&       ;copy count to vector dest to
                                            ; work with it
        add     &COUNT_reg&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_REG&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_REG&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        jmp     dword ptr &VEC_TABLE&[&VEC_REG&*4]
                                            ;jump into the unrolled loop so as
					    ; to handle the fractional part
					    ; first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\roptable.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPTABLE.inc
;
; Raster operation code templates for BitBLT.
;
; Copyright (c) 1988 - 1992  Microsoft Corporation
;
; This file defines the code templates for all raster operations which
; BitBLT supports.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;


ROPDEF macro lbl,ne,whocares
ROP&ne=(offset lbl)-(offset roptable)	;;Start with offset
irpc x,lbl
ROP&ne = ROP&ne AND (NOT NEGATE_NEEDED)
ifidn <n>,<&&x>
ROP&ne = ROP&ne OR NEGATE_NEEDED 	;;Show negate needed
endif
ifidn <P>,<&&x>
ROP&ne = ROP&ne OR PATTERN_PRESENT	;;Show pattern present
endif
ifidn <S>,<&&x>
ROP&ne = ROP&ne OR SOURCE_PRESENT	;;Show source needed
endif
endm
ROPDEF1 ROP&ne,%((offset $)-(offset lbl))
endm


ROPDEF1 macro lbl,len
lbl = lbl OR (ROPLen&len SHL 10)	;;Set size index
endm


	public	roptable
roptable    label   word
	errn$	roptable			;Must be at offset 0
Sn:
	ROPDEF	Sn,0033,0008


	errn$	roptable			;Must be at offset 0

	dw	ROP0000,ROP0001,ROP0002,ROP0003
	dw	ROP0004,ROP0005,ROP0006,ROP0007
	dw	ROP0008,ROP0009,ROP000A,ROP000B
	dw	ROP000C,ROP000D,ROP000E,ROP000F
	dw	ROP0010,ROP0011,ROP0012,ROP0013
	dw	ROP0014,ROP0015,ROP0016,ROP0017
	dw	ROP0018,ROP0019,ROP001A,ROP001B
	dw	ROP001C,ROP001D,ROP001E,ROP001F
	dw	ROP0020,ROP0021,ROP0022,ROP0023
	dw	ROP0024,ROP0025,ROP0026,ROP0027
	dw	ROP0028,ROP0029,ROP002A,ROP002B
	dw	ROP002C,ROP002D,ROP002E,ROP002F
	dw	ROP0030,ROP0031,ROP0032,ROP0033
	dw	ROP0034,ROP0035,ROP0036,ROP0037
	dw	ROP0038,ROP0039,ROP003A,ROP003B
	dw	ROP003C,ROP003D,ROP003E,ROP003F
	dw	ROP0040,ROP0041,ROP0042,ROP0043
	dw	ROP0044,ROP0045,ROP0046,ROP0047
	dw	ROP0048,ROP0049,ROP004A,ROP004B
	dw	ROP004C,ROP004D,ROP004E,ROP004F
	dw	ROP0050,ROP0051,ROP0052,ROP0053
	dw	ROP0054,ROP0055,ROP0056,ROP0057
	dw	ROP0058,ROP0059,ROP005A,ROP005B
	dw	ROP005C,ROP005D,ROP005E,ROP005F
	dw	ROP0060,ROP0061,ROP0062,ROP0063
	dw	ROP0064,ROP0065,ROP0066,ROP0067
	dw	ROP0068,ROP0069,ROP006A,ROP006B
	dw	ROP006C,ROP006D,ROP006E,ROP006F
	dw	ROP0070,ROP0071,ROP0072,ROP0073
	dw	ROP0074,ROP0075,ROP0076,ROP0077
	dw	ROP0078,ROP0079,ROP007A,ROP007B
	dw	ROP007C,ROP007D,ROP007E,ROP007F

	errn$	roptable,-256			;Must be 256 bytes afterwards
        db      0,2,4,6,8,10,12,14





;-----------------------------------------------------------------
;	The actual raster operation templates follow.
;
;	Entry:	AL     =  Source byte
;		DH     =  Pattern Bytes
;		ES:DI --> Destination byte
;
;	Exit:	AL     =  Result
;		DH     =  Pattern Bytes
;               DI --> Destination byte
;		AH	  IS possibly the destination byte
;
;       Us   AL,AH,DH,DL
;-----------------------------------------------------------------


DDx:
	xor	al,al
	ROPDEF	DDx,0000,0042


DPna:
Pn:
	mov	al,dh
	ROPDEF	Pn,000F,0001
	not	al
PDSanon:
        and     al,[edi]
	ROPDEF	DPna,000A,0329
PSnon:
	not	al
DPSona:
PSon:
	or	al,dh
	ROPDEF	PDSanon,0008,0F08
	ROPDEF	PSon,0003,00AA
	ROPDEF	PSnon,000C,0324
PDSnaon:
	not	al
PDSaon:
        and     al,[edi]
	ROPDEF	DPSona,0002,0C89
	or	al,dh
	ROPDEF	PDSnaon,000D,0B25
	ROPDEF	PDSaon,0007,02C5


DPon:
	mov	al,dh
PDSonon:
        or      al,[edi]
	ROPDEF	DPon,0005,00A9
DPSnoon:
	not	al
DPSoon:
	or	al,dh
	ROPDEF	PDSonon,000E,08A5
DSon:
PDSona:
        or      al,[edi]
	ROPDEF	DPSnoon,0004,0C88
	ROPDEF	DPSoon,0001,0289
	ROPDEF	DSon,0011,00A6
	not	al
	and	al,dh
	ROPDEF	PDSona,0010,0C85


SDPxnon:
        mov     ah,[edi]
	xor	ah,dh
	not	ah
	or	al,ah
	ROPDEF	SDPxnon,0012,0868


SSPxDSxaxn:
	mov	dl,al
SPxDSxa:
	mov	ah,dh
	xor	ah,al
        xor     al,[edi]
	and	al,ah
	ROPDEF	SPxDSxa,0024,0D55
	xor	al,dl
	ROPDEF	SSPxDSxaxn,0017,1D54


PSDPSanaxx:
SDPSanaxn:
	mov	dl,al
	and	al,dh
DSna:
	not	al
        and     al,[edi]
	ROPDEF	DSna,0022,0326
	xor	al,dl
	ROPDEF	SDPSanaxn,0019,1CC8
	xor	al,dh
	ROPDEF	PSDPSanaxx,0016,5CCA


PDSPanaxn:
DPSana:
	and	al,dh
PDSnaxn:
	not	al
        and     al,[edi]
	ROPDEF	DPSana,002A,0CC9
	xor	al,dh
	ROPDEF	PDSnaxn,002D,060A
	ROPDEF	PDSPanaxn,0025,1CC5




DPSaon:
PDSPaox:
	and	al,dh
PDSox:
        or      al,[edi]
	ROPDEF	DPSaon,0015,02C9
	xor	al,dh
	ROPDEF	PDSox,001E,01A5
	ROPDEF	PDSPaox,001A,06C5


SDPSxaxn:
	mov	dl,al
DPSxa:
	xor	al,dh
        and     al,[edi]
	ROPDEF	DPSxa,0028,0369
	xor	al,dl
	ROPDEF	SDPSxaxn,001B,0768


DSPDxaxn:
        mov     ah,[edi]
	mov	dl,ah
	xor	dl,dh
	and	al,dl
	xor	al,ah
	ROPDEF	DSPDxaxn,001D,0766


DPSnaa:
PSna:
	not	al
DPSaan:
	and	al,dh
	ROPDEF	PSna,0030,032A
        and     al,[edi]
	ROPDEF	DPSnaa,0020,0F09
	ROPDEF	DPSaan,007F,03C9


PSDnaon:
        mov     ah,[edi]
	not	ah
	and	al,ah
	or	al,dh
	ROPDEF	PSDnaon,000B,0B2A


SPDnaon:
        mov     ah,[edi]
	not	ah
	and	ah,dh
	or	al,ah
	ROPDEF	SPDnaon,0023,0B24


PDSPxaxn:
	xor	al,dh
        and     al,[edi]
	xor	al,dh
	ROPDEF	PDSPxaxn,0027,1868


SDPSaox:
PSDPSaoxxn:
	mov	dl,al
	and	al,dh
        or      al,[edi]
	xor	al,dl
	ROPDEF	SDPSaox,0026,06C8
	xor	al,dh
	ROPDEF	PSDPSaoxxn,0029,16CA


SSPxPDxaxn:
	mov	dl,al
SPxPDxa:
        mov     ah,[edi]
	xor	ah,dh
	xor	al,dh
	and	al,ah
	ROPDEF	SPxPDxa,0018,0D59
	xor	al,dl
	ROPDEF	SSPxPDxaxn,002B,1D58


DSPDSoaxxn:
SPDSoax:
	mov	dl,al
PDSoan:
        mov     ah,[edi]
	or	al,ah
	and	al,dh
	ROPDEF	PDSoan,001F,0385
	xor	al,dl
	ROPDEF	SPDSoax,002C,0784
	xor	al,ah
	ROPDEF	DSPDSoaxxn,0079,1786




PSDPxox:
SDPxon:
        mov     ah,[edi]
	xor	ah,dh
	or	al,ah
	ROPDEF	SDPxon,0021,0248
	xor	al,dh
	ROPDEF	PSDPxox,002E,064A


PSDnoan:
        mov     ah,[edi]
	not	ah
	or	al,ah
PSan:
	and	al,dh
	ROPDEF	PSan,003F,00EA
	ROPDEF	PSDnoan,002F,0E2A


SDPnaon:
	mov	ah,dh
	not	ah
        and     ah,[edi]
	or	al,ah
	ROPDEF	SDPnaon,0031,0B28


SDPaon:
PSDPaox:
        mov     ah,[edi]
	and	ah,dh
	or	al,ah
	ROPDEF	SDPaon,0013,02C8
	xor	al,dh
	ROPDEF	PSDPaox,001C,06CA



SDPSoox:
	mov	dl,al
	or	al,dh
        or      al,[edi]
	xor	al,dl
	ROPDEF	SDPSoox,0032,0688


SPDSaox:
	mov	dl,al
        and     al,[edi]
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSaox,0034,06C4


DPSDxaxn:
        mov     ah,[edi]
	xor	al,ah
	and	al,dh
	xor	al,ah
	ROPDEF	DPSDxaxn,0035,1864


SDPox:
        mov     ah,[edi]
	or	ah,dh
	xor	al,ah
	ROPDEF	SDPox,0036,01A8


PSDPoax:
SDPoan:
        mov     ah,[edi]
	or	ah,dh
	and	al,ah
	ROPDEF	SDPoan,0037,0388
PSx:
	xor	al,dh
	ROPDEF	PSx,003C,004A
	ROPDEF	PSDPoax,0038,078A


SPDnox:
        mov     ah,[edi]
	not	ah
	or	ah,dh
	xor	al,ah
	ROPDEF	SPDnox,0039,0604


SPDSxox:
	mov	dl,al
PDSxon:
        xor     al,[edi]
	or	al,dh
	ROPDEF	PDSxon,0009,0245
	xor	al,dl
	ROPDEF	SPDSxox,003A,0644


SPDnoan:
        mov     ah,[edi]
	not	ah
	or	ah,dh
	and	al,ah
	ROPDEF	SPDnoan,003B,0E24


SPDSonox:
	mov	dl,al
        or      al,[edi]
	not	al
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSonox,003D,18A4


DPSxnan:
	xor	al,dh
SPDSnaox:
	mov	dl,al			;(wasted for DPSxnan)
	not	al
        and     al,[edi]
	ROPDEF	DPSxnan,007D,0C69
	or	al,dh
	xor	al,dl
	ROPDEF	SPDSnaox,003E,1B24


SPDSanaxn:
	mov	dl,al
PDSana:
DSan:
        and     al,[edi]
	ROPDEF	DSan,0077,00E6
	not	al
	and	al,dh
	ROPDEF	PDSana,0070,0CC5
	xor	al,dl
	ROPDEF	SPDSanaxn,0043,1CC4


PSDPxaxn:
SDPxa:
        mov     ah,[edi]
	xor	ah,dh
	and	al,ah
	ROPDEF	SDPxa,0048,0368
	xor	al,dh
	ROPDEF	PSDPxaxn,0047,076A


DSPDaox:
PDSPDaoxxn:
        mov     ah,[edi]
	mov	dl,ah
	and	dl,dh
	or	al,dl
	xor	al,ah
	ROPDEF	DSPDaox,0046,06C6
	xor	al,dh
	ROPDEF	PDSPDaoxxn,0049,16C5

DPSDoax:
        mov     ah,[edi]
	or	al,ah
	and	al,dh
	xor	al,ah
	ROPDEF	DPSDoax,004A,0789


DPSanon:
	and	al,dh
PDSnox:
DSnon:
	not	al
        or      al,[edi]
	ROPDEF	DPSanon,0040,0F0A
	ROPDEF	DSnon,0044,0328
	xor	al,dh
	ROPDEF	PDSnox,004B,0605


SDPana:
        mov     ah,[edi]
	and	ah,dh
	not	ah
	and	al,ah
	ROPDEF	SDPana,004C,0CC8


SSPxDSxoxn:
	mov	dl,al
SPxDSxo:
	mov	ah,al
	xor	ah,dh
        xor     al,[edi]
	or	al,ah
	ROPDEF	SPxDSxo,007E,0955
	xor	al,dl
	ROPDEF	SSPxDSxoxn,004D,1954


PDSPxox:
DPSxon:
	xor	al,dh
        or      al,[edi]
	ROPDEF	DPSxon,0041,0249
	xor	al,dh
	ROPDEF	PDSPxox,004E,0645


PDna:
Dn:
        mov     al,[edi]
	ROPDEF	Dn,0055,0009
	not	al
	and	al,dh
	ROPDEF	PDna,0050,0325


DPSDaox:
        mov     ah,[edi]
	and	al,ah
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDaox,0052,06C9


SPDSxaxn:
	mov	dl,al
PDSxa:
        xor     al,[edi]
	and	al,dh
	ROPDEF	PDSxa,0060,0365
	xor	al,dl
	ROPDEF	SPDSxaxn,0053,0764


DPx:
	mov	al,dh
PDSxnon:
        xor     al,[edi]
	ROPDEF	DPx,005A,0049
DPSnoan:
	not	al
PDSPoax:
DPSoan:
	or	al,dh
	ROPDEF	PDSxnon,0006,0865
PDSax:
        and     al,[edi]
	ROPDEF	DPSnoan,005D,0E29
	ROPDEF	DPSoan,0057,0389
	xor	al,dh
	ROPDEF	PDSPoax,0058,0785
	ROPDEF	PDSax,0078,01E5


DPSnox:
	not	al
DPSox:
	or	al,dh
PDSxnan:
        xor     al,[edi]
	ROPDEF	DPSox,0056,01A9
	ROPDEF	DPSnox,0059,0609
	not	al
	and	al,dh
	ROPDEF	PDSxnan,006F,0C65


DPSDonox:
        mov     ah,[edi]
	or	al,ah
	not	al
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDonox,005B,18A9


DPSDxox:
        mov     ah,[edi]
	xor	al,ah
	or	al,dh
	xor	al,ah
	ROPDEF	DPSDxox,005C,0649


DSPnaon:
PDSPnaox:
	mov	ah,dh
	not	ah
	and	al,ah
        or      al,[edi]
	ROPDEF	DSPnaon,0051,0B26
	xor	al,dh
	ROPDEF	PDSPnaox,005E,1B29


DPan:
	mov	al,dh
        and     al,[edi]
	ROPDEF	DPan,005F,00E9


DSPDSaoxxn:
	mov	dl,al
        mov     ah,[edi]
	and	al,ah
	or	al,dh
	xor	al,dl
	xor	al,ah
	ROPDEF	DSPDSaoxxn,0061,16C6


SDPnox:
	mov	ah,dh
	not	ah
        or      ah,[edi]
	xor	al,ah
	ROPDEF	SDPnox,0063,0608


DPSnaxn:
	not	al
DPSax:
	and	al,dh
DSx:
PDSxxn:
        xor     al,[edi]
	ROPDEF	DSx,0066,0046
	ROPDEF	DPSax,006A,01E9
	ROPDEF	DPSnaxn,0065,0606
	xor	al,dh
	ROPDEF	PDSxxn,0069,0145


SDPSonox:
PSDPSonoxxn:
	mov	dl,al
DPSonon:
	or	al,dh
	not	al
        or      al,[edi]
	ROPDEF	DPSonon,0054,08A9
	xor	al,dl
	ROPDEF	SDPSonox,0067,18A8
	xor	al,dh
	ROPDEF	PSDPSonoxxn,0068,58A6


SDPSoax:
PSDPSoaxxn:
	mov	dl,al
	or	al,dh
        and     al,[edi]
	xor	al,dl
	ROPDEF	SDPSoax,0064,0788
	xor	al,dh
	ROPDEF	PSDPSoaxxn,006B,178A


SDPax:
        mov     ah,[edi]
	and	ah,dh
	xor	al,ah
	ROPDEF	SDPax,006C,01E8


DSPDoax:
PDSPDoaxxn:
        mov     ah,[edi]
	mov	dl,ah
	or	ah,dh
	and	al,ah
	xor	al,dl
	ROPDEF	DSPDoax,0062,0786
	xor	al,dh
	ROPDEF	PDSPDoaxxn,006D,1785


SDPSnoax:
	mov	dl,al
	not	al
	or	al,dh
        and     al,[edi]
	xor	al,dl
	ROPDEF	SDPSnoax,006E,1E28


SSDxPDxaxn:
	mov	dl,al
SDxPDxa:
        mov     ah,[edi]
	xor	al,ah
	xor	ah,dh
	and	al,ah
	ROPDEF	SDxPDxa,0042,0D5D
	xor	al,dl
	ROPDEF	SSDxPDxaxn,0071,1D5C


SDPSxox:
	mov	dl,al
	xor	al,dh
        or      al,[edi]
	xor	al,dl
	ROPDEF	SDPSxox,0072,0648


SDPnoan:
	mov	ah,dh
	not	ah
        or      ah,[edi]
	and	al,ah
	ROPDEF	SDPnoan,0073,0E28


DSPDxox:
        mov     ah,[edi]
	mov	dl,ah
	xor	ah,dh
	or	al,ah
	xor	al,dl
	ROPDEF	DSPDxox,0074,0646


SDPSnaox:
	mov	dl,al
DPSnaon:
	not	al
	and	al,dh
        or      al,[edi]
	ROPDEF	DPSnaon,0045,0B29
	xor	al,dl
	ROPDEF	SDPSnaox,0076,1B28


DSPnoan:
PDSPnoax:
	mov	ah,dh
	not	ah
	or	al,ah
        and     al,[edi]
	ROPDEF	DSPnoan,0075,0E26
DPSxnon:
	xor	al,dh
	ROPDEF	PDSPnoax,007A,1E29
PDSnoan:
SPDSnoax:
	mov	dl,al			;(wasted for DPSxnon)
	not	al
        or      al,[edi]
	ROPDEF	DPSxnon,0014,0869
	and	al,dh
	ROPDEF	PDSnoan,004F,0E25
	xor	al,dl
	ROPDEF	SPDSnoax,007C,1E24

SDPxnan:
        mov     ah,[edi]
	xor	ah,dh
	not	ah
	and	al,ah
	ROPDEF	SDPxnan,007B,0C68
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\savescrn.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: savescrn.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vSaveScreenBitsToMemory(PDEVSURF pdsurf, PRECTL prcl,
;                              PVOID pjDestBuffer, ULONG ulSaveWidthInBytes,
;                              ULONG ulSaveHeight, ULONG ulDestScanWidth);
; Input:
;  pdsurf - surface from which to copy
;  prcl - pointer to rectangle to copy
;  pjDestBuffer - pointer to destination memory buffer. Should have the same
;                 dword alignment as the source rect left edge does in screen
;                 memory
;  ulSaveWidthInBytes - # of bytes to save per scan
;  ulSaveHeight - # of scans to save
;  ulDestScanWidth - distance from the start of one saved scan in the
;                    destination buffer to the start of the next saved scan.
;                    This should be a dword multiple, to maintain dword
;                    alignment between the source and destination
;
; Copies a rectangle from VGA memory to a memory buffer.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;
;
; Note: The rectangle is saved in interleaved-scan format; all four planes
; of one scan are saved together, then all four plane of the next scan,
; and so on. This is done for maximum restoration efficiency. Planes are
; saved in order 3, 2, 1, 0:
;
;  Scan n, plane 3
;  Scan n, plane 2
;  Scan n, plane 1
;  Scan n, plane 0
;  Scan n+1, plane 3
;  Scan n+1, plane 2
;  Scan n+1, plane 1
;  Scan n+1, plane 0
;          :
;
; There may be padding on either edge of the saved bits in the destination
; buffer, so that the destination can be dword aligned with the source.
;
;-----------------------------------------------------------------------;
;Additional optimizations:
;
; Could handle odd bytes to dword align more efficiently, by having separate
; optimizations for various alignment widths, thereby avoiding starting REP
; and getting word accesses for 2 and 3 wide cases. Most VGAs are 8 or 16
; bit devices, and for them, using MOVSB/REP MOVSW/MOVSB might actually be
; faster, especially because it's easier to break out optimizations.
;
; Could end all scan handlers with loop bottom code.
;
;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc

        .list

        .code

_TEXT$03   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc   vSaveScreenBitsToMemory,24,< \
        uses    esi edi ebx,      \
        pdsurf:ptr,               \
        prcl:ptr,                 \
        pjDestBuffer:ptr,         \
        ulSaveWidthInBytes:dword, \
        ulSaveHeight:dword,       \
        ulDestScanWidth:dword     >

        local   ulCurrentTopScan :dword ;top scan line to copy from in current
                                        ; bank
        local   ulBottomScan :dword     ;bottom scan line of rectangle to copy
        local   pjSrcStart :dword       ;source address
        local   ulSrcDelta :dword       ;distance from end of source scan to
                                        ; start of next
        local   ulDestDelta :dword      ;distance from end of dest scan to
                                        ; start of next
        local   ulBlockHeight :dword    ;# of scans to copy in block
        local   ulLeadingBytes :dword   ;# of leading bytes to copy per scan
        local   ulMiddleDwords :dword   ;# of dwords to copy per scan
        local   ulTrailingBytes :dword  ;# of trailing bytes to copy per scan
        local   pfnCopyVector :dword    ;pointer to inner loop routine to copy
                                        ; from screen to buffer

;-----------------------------------------------------------------------;
; Leave the GC Index pointing to the Read Map for the rest of this routine.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_READ_MAP
        out     dx,al

;-----------------------------------------------------------------------;
; Set up local variables.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle from which to copy
        mov     esi,pdsurf              ;point to surface from which to copy

        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;bottom scan line of source rect

        mov     eax,ulDestScanWidth
        shl     eax,2
        sub     eax,ulSaveWidthInBytes
        mov     ulDestDelta,eax ;distance from end of one scan's saved bits
                                ; to start of next scan's (skips over the three
                                ; other plane's save areas for each scan)
        mov     eax,[esi].dsurf_lNextScan
        sub     eax,ulSaveWidthInBytes
        mov     ulSrcDelta,eax  ;distance from end of one scan's bits to save
                                ; to start of next scan's in display memory

;-----------------------------------------------------------------------;
; Set up for copying as much as possible via aligned dwords, and
; select the most efficient loop for doing the copy, based on the copy
; width, and on the necessity for leading and/or trailing bytes to
; dword align.
;-----------------------------------------------------------------------;

        mov     edx,ulSaveWidthInBytes  ;# of bytes to copy per scan
        cmp     edx,8                   ;if it's less than 8 bytes, just do a
                                        ; straight byte copy. This means we
                                        ; we only have to start 1 REP per line,
                                        ; and performing this check guarantees
                                        ; that we have at least 1 aligned dword
                                        ; to copy in the dword loops
        jb      short copy_all_as_bytes ;do straight byte copy
        mov     eax,pjDestBuffer
        neg     eax
        and     eax,3           ;# of bytes that have to be done as leading
                                ; bytes to dword align with destination (note
                                ; that for performance, the destination should
                                ; be dword aligned with the source)
        jz      short copy_no_leading_bytes     ;no leading bytes
                                ;leading bytes
        mov     ulLeadingBytes,eax
        mov     ebx,offset copy_to_buffer_l ;assume no trailing bytes
        sub     edx,eax         ;# of bytes after leading bytes
        mov     eax,edx
        shr     eax,2           ;# of dwords that can be handled as aligned
                                ; dwords
        mov     ulMiddleDwords,eax
        and     edx,3           ;# of trailing bytes left after aligned dwords
                                ; copied
        jz      short set_copy_vector ;no trailing bytes
        mov     ulTrailingBytes,edx
        mov     ebx,offset copy_to_buffer_lt    ;there are both leading and
                                                ; trailing bytes
        jmp     short set_copy_vector

        align   4
copy_no_leading_bytes:
        mov     ebx,offset copy_to_buffer ;assume no trailing bytes
        mov     eax,edx
        shr     eax,2           ;# of dwords that can be handled as aligned
                                ; dwords
        mov     ulMiddleDwords,eax
        and     edx,3           ;# of trailing bytes left after aligned dwords
                                ; copied
        jz      short set_copy_vector ;no trailing bytes
        mov     ulTrailingBytes,edx
        mov     ebx,offset copy_to_buffer_t     ;there are trailing bytes
        jmp     short set_copy_vector

; It's so narrow that we'll forget about aligned dwords, and just do a straight
; byte copy, which we'll handle by treating the entire copy as leading bytes.
        align   4
copy_all_as_bytes:
        mov     ulLeadingBytes,edx
        mov     ebx,offset copy_to_buffer_lonly

set_copy_vector:
        mov     pfnCopyVector,ebx

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to copy, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     eax,[edi].yTop          ;top scan line of copy
        mov     ulCurrentTopScan,eax    ;this will be the copy top in 1st bank

        cmp     eax,[esi].dsurf_rcl1WindowClip.yTop ;is copy top less than
                                                    ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[esi].dsurf_rcl1WindowClip.yBottom ;copy top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the copy.

        ptrCall   <dword ptr [esi].dsurf_pfnBankControl>,<esi,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Calculate the initial start address from which to copy.
;-----------------------------------------------------------------------;

        mov     eax,ulCurrentTopScan    ;top scan line to copy in current bank
        imul    [esi].dsurf_lNextScan   ;offset of starting scan line in bitmap
        add     eax,[esi].dsurf_pvBitmapStart ;start address of scan
        mov     ebx,[edi].xLeft
        shr     ebx,3                   ;convert from pixel to byte address
        add     eax,ebx                 ;start source address
        mov     pjSrcStart,eax

;-----------------------------------------------------------------------;
; Loop through and copy all bank blocks spanned by the source rectangle.
;
; Input:
;  ESI = pdsurf
;-----------------------------------------------------------------------;

copy_to_buffer_bank_loop:

; Copy this bank block to the buffer.

; Calculate # of scans in this bank.

        mov     ebx,ulBottomScan        ;bottom of source rectangle
        cmp     ebx,[esi].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; source rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;source bottom comes first, so copy to
                                        ; that; this is the last bank in copy
        mov     ebx,[esi].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; copy to
                                        ; bottom of bank
@@:
        sub     ebx,ulCurrentTopScan    ;# of scans to copy in this bank
        mov     ulBlockHeight,ebx

;-----------------------------------------------------------------------;
; Loop through all four planes, copying all scans in this block for each
; plane in turn.
;-----------------------------------------------------------------------;

        mov     eax,3           ;start by copying plane 3

copy_whole_to_buffer_plane_loop:

        mov     edx,VGA_BASE + GRAF_DATA
        out     dx,al           ;set Read Map to plane from which we're copying

        push    eax             ;remember plane index

        mov     esi,pjSrcStart   ;point to start of source rect
        mov     edi,pjDestBuffer ;point to start of dest buffer
        mov     eax,ulDestScanWidth
        add     pjDestBuffer,eax ;point to start of next plane's scan in dest
                                 ; buffer
        mov     eax,ulSrcDelta   ;offset to next source scan
        mov     edx,ulDestDelta  ;offset to next dest scan
        mov     ebx,ulBlockHeight

        jmp     pfnCopyVector   ;jump to the appropriate loop to copy plane

;-----------------------------------------------------------------------;
; Copy loops, broken out by leading and trailing bytes needed for dword
; alignment, plus one loop to perform a straight byte copy.
;
; Input:
;  EAX = offset from end of one source scan to start of next
;  EBX = block height in scans
;  EDX = offset from end of one dest scan to start of next
;  ESI = initial source copy address
;  EDI = initial dest copy address
;-----------------------------------------------------------------------;

; All byte can be copied as aligned dwords (no leading or trailing bytes).
        align   4
copy_to_buffer:
copy_to_buffer_scan_loop:
        mov     ecx,ulMiddleDwords
        rep     movsd
        add     esi,eax         ;point to next source scan
        add     edi,edx         ;point to next dest scan
        dec     ebx             ;count down scan lines
        jnz     copy_to_buffer_scan_loop
        jmp     short copy_to_buffer_scans_done

; Leading odd bytes, but no trailing bytes.
        align   4
copy_to_buffer_l:
copy_to_buffer_scan_loop_l:
        mov     ecx,ulLeadingBytes
        rep     movsb
        mov     ecx,ulMiddleDwords
        rep     movsd
        add     esi,eax         ;point to next source scan
        add     edi,edx         ;point to next dest scan
        dec     ebx             ;count down scan lines
        jnz     copy_to_buffer_scan_loop_l
        jmp     short copy_to_buffer_scans_done

; Trailing odd bytes, but no leading bytes.
        align   4
copy_to_buffer_t:
copy_to_buffer_scan_loop_t:
        mov     ecx,ulMiddleDwords
        rep     movsd
        mov     ecx,ulTrailingBytes
        rep     movsb
        add     esi,eax         ;point to next source scan
        add     edi,edx         ;point to next dest scan
        dec     ebx             ;count down scan lines
        jnz     copy_to_buffer_scan_loop_t
        jmp     short copy_to_buffer_scans_done

; Only leading bytes (straight byte copy; no aligned dwords).
        align   4
copy_to_buffer_lonly:
copy_to_buffer_scan_loop_lonly:
        mov     ecx,ulLeadingBytes
        rep     movsb
        add     esi,eax         ;point to next source scan
        add     edi,edx         ;point to next dest scan
        dec     ebx             ;count down scan lines
        jnz     copy_to_buffer_scan_loop_lonly
        jmp     short copy_to_buffer_scans_done

; Leading and trailing odd bytes.
        align   4
copy_to_buffer_lt:
copy_to_buffer_scan_loop_lt:
        mov     ecx,ulLeadingBytes
        rep     movsb
        mov     ecx,ulMiddleDwords
        rep     movsd
        mov     ecx,ulTrailingBytes
        rep     movsb
        add     esi,eax         ;point to next source scan
        add     edi,edx         ;point to next dest scan
        dec     ebx             ;count down scan lines
        jnz     copy_to_buffer_scan_loop_lt

copy_to_buffer_scans_done:

        pop     eax             ;get back plane index
        dec     eax             ;count down planes
        jns     copy_whole_to_buffer_plane_loop

; Remember where we left off, for the next block.

        mov     pjSrcStart,esi
        mov     eax,ulDestScanWidth
        lea     eax,[eax+eax*2] ;ulDestScanWidth*3
        sub     edi,eax         ;adjust back to first plane's save area
                                ; (remember, scans are interleaved by plane, so
                                ; there are four planes per scan; we're
                                ; adjusting back from the fourth to the first)
        mov     pjDestBuffer,edi

;-----------------------------------------------------------------------;
; See if there are more banks to do
;-----------------------------------------------------------------------;

        mov     esi,pdsurf
        mov     eax,[esi].dsurf_rcl1WindowClip.yBottom ;is the copy bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jle     short copy_to_buffer_banks_done        ;yes, so we're done
                                        ;no, map in the next bank and copy it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)
        mov     edx,[esi].dsurf_pvBitmapStart
        sub     pjSrcStart,edx  ;convert from address to offset within bitmap

        ptrCall   <dword ptr [esi].dsurf_pfnBankControl>,<esi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address in this bank.
; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        mov     eax,[esi].dsurf_pvBitmapStart
        add     pjSrcStart,eax  ;address of next scan to draw

; Copy the new bank.

        jmp     copy_to_buffer_bank_loop


;-----------------------------------------------------------------------;
; Done with all banks.
;-----------------------------------------------------------------------;
        align 4
copy_to_buffer_banks_done:

        cRet    vSaveScreenBitsToMemory ;done

;-----------------------------------------------------------------------;

endProc vSaveScreenBitsToMemory

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\strucs.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; DFBBLT is used to store DFB BLTing info
;-----------------------------------------------------------------------;

DFBBLT          STRUC
DstWidth        dd      77777777h      ;# of words touched by dest rectangle
SrcDelta        dd      77777777h      ;dist from end of scan to start of next
DstDelta        dd      77777777h      ;dist from end of scan to start of next
LeftMask        dd      77777777h      ;dst left mask
NotLeftMask     dd      77777777h      ;dst left mask
RightMask       dd      77777777h      ;dst right mask
NotRightMask    dd      77777777h      ;dst right mask
BurstCountLeft  dd      77777777h      ;# of scans to burst
AlignShift      dd      77777777h      ;# of bits to shift left (+) or right
Color           dd      77777777h      ;# of bits to shift left (+) or right
Tmp1            dd      77777777h      ;temp stack variable
Tmp2            dd      77777777h      ;temp stack variable
DFBBLT          ENDS

;-----------------------------------------------------------------------;
; POINTB is used for points with a range of -128..+127.
;-----------------------------------------------------------------------;

POINTB          STRUC
ptb_x           DB      0
ptb_y           DB      0
POINTB          ENDS

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS


;-----------------------------------------------------------------------;
; SIZEB is used for extents with a range of -128..+127.
;-----------------------------------------------------------------------;

SIZEB           STRUC
sizb_cx         DB      0
sizb_cy         DB      0
SIZEB           ENDS


;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends


;-----------------------------------------------------------------------;
; Definition of a device surface
;-----------------------------------------------------------------------;


DEVSURF             struc           ; /* dsurf */
dsurf_ident         dd      ?
dsurf_flSurf        dd      ?
dsurf_iColor        db      ?
dsurf_iFormat       db      ?
                    db      ?
                    db      ?
dsurf_ppdev         dd      ?
dsurf_sizlSurf      db      (size SIZEL) dup (?)
dsurf_lNextScan     dd      ?
dsurf_lNextPlane    dd      ?
dsurf_pvScan0       dd      ?
dsurf_pvStart       dd      ?
dsurf_pvConv        dd      ?

dsurf_pBankSelectInfo   dd      ?
dsurf_ulBank2RWSkip     dd      ?
dsurf_pfnBankSwitchCode dd      ?
dsurf_vbtBankingType    dd      ?
dsurf_ulBitmapSize      dd      ?
dsurf_ulPtrBankScan     dd      ?
dsurf_rcl1WindowClip    db      (size RECTL) dup (?)
dsurf_rcl2WindowClip    db      (2*(size RECTL)) dup (?)
dsurf_ulWindowBank      dd      ?,?
dsurf_pbiBankInfo       dd      ?
dsurf_ulBankInfoLength  dd      ?
dsurf_pbiBankInfo2RW    dd      ?
dsurf_ulBankInfo2RWLength dd    ?
dsurf_pfnBankControl    dd      ?
dsurf_pfnBankControl2Window dd  ?
dsurf_pvBitmapStart     dd      ?
dsurf_pvBitmapStart2Window dd   ?,?
dsurf_pvBankBufferPlane0   dd   ?
dsurf_pvBankBufferPlane1   dd   ?
dsurf_pvBankBufferPlane2   dd   ?
dsurf_pvBankBufferPlane3   dd   ?

dsurf_ajBits        dd      ?
DEVSURF             ends

dsurf_rcl2WindowClipS   equ     (dsurf_rcl2WindowClip)
dsurf_rcl2WindowClipD   equ     (dsurf_rcl2WindowClip + (size RECTL))
dsurf_pvBitmapStart2WindowS equ (dsurf_pvBitmapStart2Window)
dsurf_pvBitmapStart2WindowD equ (dsurf_pvBitmapStart2Window + dword)


;-----------------------------------------------------------------------;
; Definitions for dsurf_iFormat
;-----------------------------------------------------------------------;

BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6
BMF_4RLE            equ     8
BMF_8RLE            equ     9
BMF_DEVICE          equ     0FEh
BMF_PHYSDEVICE      equ     0FFh

VGA_TARGET          equ     0
DFB_TARGET          equ     1
NO_TARGET           equ     2


;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;


GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends


GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends


GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Information block for RLE blts
;-----------------------------------------------------------------------;

RLEINFO struc
RLE_pjTrg        dd  ?
RLE_pjSrcBits    dd  ?
RLE_pjSrcBitsMax dd  ?
RLE_prctlClip    dd  ?
RLE_pulTranslate dd  ?
RLE_xBegin       dd  ?
RLE_lNextScan    dd  ?
RLE_lNextPlane   dd  ?
RLE_prctlTrg     dd  ?
RLE_dwFormat     dd  ?
Rle_pdsurfTrg    dd  ?
RLEINFO ends

;**************************************************************************\
; Physical device description block
;**************************************************************************/

;---mirrors driver.h---;

PDEV struc
PDEV_fl dd ?
PDEV_ident dd ?
PDEV_hDriver dd ?
PDEV_hpdevEng dd ?
PDEV_hsurfEng dd ?
PDEV_pdsurf dd ?
PDEV_sizlSurf db (size SIZEL) dup (?)
;---only needs to mirror driver.h to here---;
PDEV ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Copyright (c) 1988 - 1992  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        subttl  Raster Operation Definitions
        page


if 0                                    ; Not passed to us anymore !!!

;       Raster Op Definitions
;
;
;       The include file COMMENT.BLT contains a good description
;       of the encoding of the raster operations.  It should be
;       read before examining the definitions that follow.
;
;       The sixteen-bit number indicating which raster Op is to be
;       performed is encoded in the following manner:


EPS_OFF =       0000000000000011b       ;Offset within parse string
EPS_INDEX =     0000000000011100b       ;Parse string index
LogPar  =       0000000000100000b       ;(1 indicates implied NOT as Logop6)
LogOp1  =       0000000011000000b       ;Logical Operation #1
LogOp2  =       0000001100000000b       ;Logical Operation #2
LogOp3  =       0000110000000000b       ;Logical Operation #3
LogOp4  =       0011000000000000b       ;Logical Operation #4
LogOp5  =       1100000000000000b       ;Logical Operation #5


;       The parity bit is used to encode an optional sixth logical operation
;       which will always be a "NOT".  In most cases this is used to get an
;       even number of "NOT"s so that reduction can take place (two sequential
;       trailing "NOT"s cancel each other out and thus are eliminated).



;       Each LogOp (Logical Operation) is encoded as follows:

LogNOT  =       00b                     ;NOT result
LogXOR  =       01b                     ;XOR result with next operand
LogOR   =       10b                     ;OR  result with next operand
LogAND  =       11b                     ;AND result with next operand



;       The parse string is a string which contains the operands for
;       the logical operation sequences (source, destination, pattern).
;       The logic opcodes are applied to the current result and the next
;       element of the given string (unless the LogOp is a NOT which only
;       affects the result).
;
;       The string is encoded as eight two-bit numbers indicating which
;       operand is to be used

opDefs          struc
  OpSpec        db      ?                 ;Special Operand as noted below
  OpSrc         db      ?                 ;Operand is source field
  OpDest        db      ?                 ;Operand is destination field
  OpPat         db      ?                 ;Operand is pattern field
opDefs          ends



;       The special operand is used for a few rops that would not fit into
;       an RPN format.  On the first occurance of an OpSpec, the current result
;       is "PUSHED", and the next operand is loaded.  On the second occurance
;       of the OpSpec, the given logic operation is performed between the
;       current result and the "PUSHED" value.
;
;       **NOTE**  Since there can be no guarantee that the client will call
;       the BLT routine with one of the 256 published raster ops, it is
;       possible that a value might be "PUSHED" and then never "POPPED".
;       If these "PUSHES" are made to the stack, then care must be made to
;       remove the "PUSHED" value.
;
;       In any case, since the raster op was not one of the published
;       "magic numbers", the BLT can be aborted or the result can be
;       computed to the extent possible.  The only restriction is that it
;       must not crash the system (i.e. don't leave extra stuff on the stack).
;
;               Simply: Compute garbage, but don't crash!




;       Define the parse strings to be allocated later.
;
;       An example parse string for the pattern "SDPSDPSD" would be
;       "0110110110110110b"


parseStr0       =       07AAAh          ;src,pat,dest,dest,dest,dest,dest,dest
parseStr1       =       079E7h          ;src,pat,dest,src,pat,dest,src,pat
parseStr2       =       06DB6h          ;src,dest,pat,src,dest,pat,src,dest
parseStr3       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5       =       04725h          ;src,spec,src,pat,spec,dest,src,src
parseStr6       =       04739h          ;src,spec,src,pat,spec,pat,dest,src
parseStr7       =       04639h          ;src,spec,src,dest,spec,pat,dest,src



;       The following equates are for certain special functions that are
;       derived from the very first string (index of SpecParseStrIndex).
;
;       These strings will have their innerloops special cased for
;       speed enhancements (i.e MOVSx and STOSx for pattern copys and
;       white/black fill, and MOVSx for source copy if possible)

PAT_COPY        equ     0021h           ;P    - dest = Pattern
NOTPAT_COPY     equ     0001h           ;Pn   - dest = NOT Pattern
FILL_BLACK      equ     0042h           ;DDx  - dest = 0 (black)
FILL_WHITE      equ     0062h           ;DDxn - dest = 1
SOURCE_COPY     equ     0020h           ;S    - dest = source


        errnz   LogXOR-01b              ;These must hold true for above equates
        errnz   LogOp1-0000000011000000b
        errnz   LogPar-0000000000100000b
        errnz   parseStr0-7AAAh         ;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ        0       ;Special cased strings index

endif

;       The raster operation table consists of a word for each of
;       the first 128 raster operations (00 through 7F).  The second
;       half of the raster operations (FF through 80) are the inverse
;       of the first half.
;
;       The table is encoded as follows:
;
;           N S P LLL OOOOOOOOOO
;           | | |  |      |
;           | | |  |      |_____  Offset of code from roptable.
;           | | |  |
;           | | |  |____________  Length index
;           | | |
;           | | |_______________  Pattern is present
;           | |
;           | |_________________  Source is present
;           |
;           |___________________  Generate trailing NOT
;
;
;       To map the ROPS 80h through FFh to 00h through 7Fh, take the
;       1's complement of the ROP, and invert 'N' above.
;
;
;       Notes:
;
;           1)  An offset of 0 is reserved for source copy.  This
;               was done to reduce the number of LLLs to 8, so that
;               the above encoding could fit into a 16-bit integer.
;
;
;           2)  LLL only allows a maximum of 8 different template sizes!
;               Actual length is at roptable+256+LLL.
;
;
;
;
;       ROP is the macro that generates the equates which will be
;       stored into the roptable as specified above.
;
;       Usage:
;
;           ROPDEF      Pattern,Number
;
;       Where
;
;           Pattern     Is the RPN definition of the raster operation.
;                       It is used as the label of the first byte of
;                       the template.  It also is used to determine
;                       is there is a (S)ource, (P)attern, and if the
;                       final result is to be (n)egated.
;
;           Number      is the boolean result of the raster operation
;                       based on a P=F0, S=CC, and D=AA.  These labels
;                       and indexes can be found in the file COMMENT.BLT
;
;                       Since there are many equivelent boolean expresions,
;                       some of the rops will not match the label given.
;                       The label is for reference only.  The final result
;                       is what counts.



ROPOffset       equ     0000001111111111b
ROPLength       equ     0001110000000000b
SOURCE_PRESENT  equ     0010000000000000b
PATTERN_PRESENT equ     0100000000000000b
NEGATE_NEEDED   equ     1000000000000000b


;       Define the eight template length indices.

ROPLen0         equ     0
ROPLen2         equ     1
ROPLen4         equ     2
ROPLen6         equ     3
ROPLen8         equ     4
ROPLen10        equ     5
ROPLen12        equ     6
ROPLen14        equ     7

; Binary raster ops
R2_BLACK            equ 1
R2_NOTMERGEPEN      equ 2
R2_MASKNOTPEN       equ 3
R2_NOTCOPYPEN       equ 4
R2_MASKPENNOT       equ 5
R2_NOT              equ 6
R2_XORPEN           equ 7
R2_NOTMASKPEN       equ 8
R2_MASKPEN          equ 9
R2_NOTXORPEN        equ 10
R2_NOP              equ 11
R2_MERGENOTPEN      equ 12
R2_COPYPEN          equ 13
R2_MERGEPENNOT      equ 14
R2_MERGEPEN         equ 15
R2_WHITE            equ 16
R2_LAST             equ 16



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\vgablts.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgablts.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vTrgBlt(PDEVSURF pdsurf, ULONG culRcl, RECTL * prcl, MIX ulMix,
;              ULONG ulClr);
; Input:
;  pdsurf - surface to which to draw
;  culRcl - # of rectangles to fill
;  prcl   - pointer to list of rectangles to fill
;  ulMix  - mix rop with which to fill
;  ulClr  - color with which to fill
;
; Performs accelarated solid area fills for all mixes.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;
;
; Note: Cases where the width of the whole bytes fill is equal to the
; width of the bitmap could be sped up by using a single REP MOVS or REP
; STOS, but how often does WIN32 do a fill that's the width of the screen?
; Not very.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to accept a list of rectangles to
fill, set up the VGA hardware for the desired fill, and then fill the
rectangles one at a time. Each rectangle fill is set up for everything
but vertical parameters, and then decomposed into the sections that
intersect each VGA bank; each section is drawn in turn. Vectors are set
up so that the drawing code appropriate for the desired fill is
essentially threaded together.

        commend $

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Left edge clip masks for intrabyte start addresses 0 through 7.
; Whole byte cases are flagged as 0ffh.
        public jLeftMask
jLeftMask       label   byte
        db      0ffh,07fh,03fh,01fh,00fh,007h,003h,001h

;-----------------------------------------------------------------------;
; Right edge clip masks for intrabyte end addresses (non-inclusive)
; 0 through 7. Whole byte cases are flagged as 0ffh.
        public jRightMask
jRightMask      label   byte
        db      0ffh,080h,0c0h,0e0h,0f0h,0f8h,0fch,0feh

;-----------------------------------------------------------------------;
; Tables used to set up for the desired raster op. Note that entries for raster
; ops that aren't handled here are generally correct, except that they ignore
; need for inversion of the destination, which those rops require.

; Table used to force off the drawing color for R2_BLACK (0).
; The first entry is ignored; there is no mix 0.
        public jForceOffTable
jForceOffTable  db         0
                db         0,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh
                db      0ffh,0ffh,   0,0ffh,0ffh,0ffh,0ffh,0ffh

;-----------------------------------------------------------------------;
; Table used to force on the drawing color for R2_NOT (Dn) and R2_WHITE (1).
; The first entry is ignored; there is no mix 0.
        public  jForceOnTable
jForceOnTable   db      0, 0,0,0,0,0,0ffh,0,0,0,0,0,0,0,0,0,0ffh

;-----------------------------------------------------------------------;
; Table used to invert the passed-in drawing color for Pn mixes.
; The first entry is ignored; there is no mix 0.
        public  jNotTable
jNotTable       db      0, 0,0ffh,0ffh,0ffh,0,0,0,0ffh,0,0ffh,0,0ffh,0,0,0,0

;-----------------------------------------------------------------------;
; Table of VGA ALU logical functions corresponding to mixes. Note that Dn is
; handled as a separate preceding inversion pass when part of a more complex
; mix.
; The first entry is ignored; there is no mix 0.
        public jALUFuncTable
jALUFuncTable   db      0
                db      DR_SET,DR_AND,DR_AND,DR_SET
                db      DR_AND,DR_XOR,DR_XOR,DR_OR
                db      DR_AND,DR_XOR,     0,DR_OR
                db      DR_SET,DR_OR ,DR_OR ,DR_SET

;-----------------------------------------------------------------------;
; 1 entries mark rops that require two passes, one to invert the destination
; and then another to finish the rop.
; The first entry is ignored; there is no mix 0.
        public  jInvertDest
jInvertDest     db      0, 0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0

;-----------------------------------------------------------------------;
; Table of routines to be called to draw edges, according to which edges are
; partial and which edges are whole bytes.
        align   4
pfnEdgeDrawing  label   dword
        dd      do_right_edge_bytes
        dd      do_both_edge_bytes
        dd      check_next_bank
        dd      do_left_edge_bytes

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find entry points in wide
; whole byte code.

        align   4
pfnWideWholeRep label   dword
        dd      draw_wide_w_00_loop
        dd      draw_wide_w_01_loop
        dd      draw_wide_w_02_loop
        dd      draw_wide_w_03_loop
        dd      draw_wide_w_10_loop
        dd      draw_wide_w_11_loop
        dd      draw_wide_w_12_loop
        dd      draw_wide_w_13_loop
        dd      draw_wide_w_20_loop
        dd      draw_wide_w_21_loop
        dd      draw_wide_w_22_loop
        dd      draw_wide_w_23_loop
        dd      draw_wide_w_30_loop
        dd      draw_wide_w_31_loop
        dd      draw_wide_w_32_loop
        dd      draw_wide_w_33_loop

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find entries points in narrow, special-
; cased non-replace whole byte code.

; Note: The breakpoint where one should switch from special-casing to
;  REP MOVSB is purely a guess on my part. 5 seemed reasonable.

        align   4
pfnWholeBytesNonReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_rw_loop
        dd      draw_2_wide_rw_loop
        dd      draw_3_wide_rw_loop
        dd      draw_4_wide_rw_loop
MAX_NON_REPLACE_SPECIAL equ     ($-pfnWholeBytesNonReplaceEntries)/4

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find entry points in narrow, special-
; cased replace whole byte code.

; Note: The breakpoint where one should switch from special-casing to
;  REP STOS is purely a guess on my part. 8 seemed reasonable.

; Start address MOD 3 is 0.
        align   4
pfnWholeBytesMod0ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_even_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_even_loop
        dd      draw_6_wide_w_mod3_0_loop
        dd      draw_7_wide_w_mod3_0_loop
        dd      draw_8_wide_w_mod3_0_loop
MAX_REPLACE_SPECIAL equ     ($-pfnWholeBytesMod0ReplaceEntries)/4

; Start address MOD 3 is 1.
        align   4
pfnWholeBytesMod1ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_odd_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_odd_loop
        dd      draw_6_wide_w_mod3_1_loop
        dd      draw_7_wide_w_mod3_1_loop
        dd      draw_8_wide_w_mod3_1_loop

; Start address MOD 3 is 2.
        align   4
pfnWholeBytesMod2ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_even_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_even_loop
        dd      draw_6_wide_w_mod3_2_loop
        dd      draw_7_wide_w_mod3_2_loop
        dd      draw_8_wide_w_mod3_2_loop

; Start address MOD 3 is 3.
        align   4
pfnWholeBytesMod3ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_odd_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_odd_loop
        dd      draw_6_wide_w_mod3_1_loop
        dd      draw_7_wide_w_mod3_3_loop
        dd      draw_8_wide_w_mod3_3_loop

; Master MOD 3 alignment look-up table for entry tables for four possible
; alignments for narrow, special-cased replace whole byte code.
        align   4
pfnWholeBytesReplaceMaster      label   dword
        dd      pfnWholeBytesMod0ReplaceEntries
        dd      pfnWholeBytesMod1ReplaceEntries
        dd      pfnWholeBytesMod2ReplaceEntries
        dd      pfnWholeBytesMod3ReplaceEntries

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc   vTrgBlt,20,<         \
        uses    esi edi ebx, \
        pdsurf: ptr DEVSURF, \
        culRcl: dword,       \
        prcl:   ptr RECTL,   \
        ulMix:  dword,       \
        ulColor:dword        >

        local   ulRowOffset :dword      ;Offset from start of scan line of
                                        ; first byte to fill
        local   ulWholeBytes :dword     ;# of whole bytes to fill
        local   ulWholeDwords :dword    ;# of whole dwords to fill
        local   pfnWholeFn  :dword      ;pointer to routine used to draw
                                        ; whole bytes
        local   ulScanWidth :dword      ;offset from start of one scan to start
                                        ; of next
        local   ulNextScan  :dword      ;offset from end of one scan line's
                                        ; fill to start of next
        local   ulCurrentTopScan :dword ;top scan line to fill in current bank
        local   ulMasks     :dword      ;low byte = right mask, high byte =
                                        ; left mask
        local   ulBottomScan :dword     ;bottom scan line of fill rectangle
        local   jALUFunc   :dword       ;VGA ALU logical operation (SET, AND,
                                        ; OR, or XOR)
        local   pfnStartDrawing :dword  ;pointer to function to call to start
                                        ; drawing
        local   pfnContinueDrawing :dword ;pointer to function to call to
                                        ; continue drawing after doing whole
                                        ; bytes
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial
        local   pfnWholeBytes :dword    ;pointer to table of entry points
                                        ; into loops for whole byte filling
        local   jInvertDestFirst :dword ;1 if the rop requires a pass to invert
                                        ; the destination before the normal
                                        ; pass
        local   jDrawingColor :dword    ;color with which we're drawing
                                        ; dword to finish out fill

;-----------------------------------------------------------------------;

        cld

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     culRcl,0                ;any rects to fill?
        jz      vTrgBlts_done           ;no, we're done


;-----------------------------------------------------------------------;
; Set up variables that are constant for the entire time we're in this
; module.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Set up for the desired raster op.
;-----------------------------------------------------------------------;

        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      vTrgBlts_done           ;yes, we're done
        mov     al,jInvertDest[ebx]          ;remember whether we need to
        mov     byte ptr jInvertDestFirst,al ; invert the destination before
                                             ; finishing the rop
        mov     ah,byte ptr ulColor     ;get the drawing color
        and     ah,jForceOffTable[ebx]  ;force color to 0 if necessary
                                        ; (R2_BLACK)
        or      ah,jForceOnTable[ebx]   ;force color to 0ffh if necessary
                                        ; (R2_WHITE, R2_NOT)
        xor     ah,jNotTable[ebx]       ;invert color if necessary (any Pn mix)
                                        ;at this point, CH has the color we
                                        ; want to draw with; set up the VGA
                                        ; hardware to draw with that color
        mov     byte ptr jDrawingColor,ah ;remember drawing color for restoring
                                          ; after inversion
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_SET_RESET       ;set/reset = color to write
        out     dx,ax
        mov     eax,0F00h + GRAF_ENAB_SR ;enable set/reset for all planes, so
        out     dx,ax                   ; set/reset color we just set becomes
                                        ; the drawing color, regardless of the
                                        ; value written by the CPU

        mov     ah,jALUFuncTable[ebx]   ;get the ALU logical function
        and     ah,ah                   ;is the logical function DR_SET?
        .errnz  DR_SET
        jz      short skip_ALU_set      ;yes, don't have to set because that's
                                        ; the VGA's default state
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function
skip_ALU_set:
        mov     byte ptr jALUFunc,ah    ;remember the ALU logical function

        mov     eax,GRAF_MODE + ((M_AND_WRITE + M_COLOR_READ) SHL 8)
        out     dx,ax                   ;write mode 3 so we can do the masking
                                        ; without OUTs, read mode 1 so we can
                                        ; read 0xFF from memory always, for
                                        ; ANDing (because Color Don't Care is
                                        ; all zeros)

;-----------------------------------------------------------------------;
; Fill the current rectangle with the specified raster op and color.
;-----------------------------------------------------------------------;

fill_rect_loop:

;-----------------------------------------------------------------------;
; Set up variables that are constant from bank to bank during a single
; fill.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Set up masks and widths.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;remember the bottom scan line of fill

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,0111b               ;intrabyte address of right edge
        mov     ah,jRightMask[ecx]      ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,3                   ;/8 for start offset from left edge
                                        ; of scan line
        mov     ulRowOffset,ecx         ;remember offset from start of scan
                                        ; line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,0111b               ;intrabyte address of left edge
        mov     al,jLeftMask[esi]       ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,3                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count and clear the first byte mask, because we can handle solid
; edge bytes faster as part of the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
        add     ecx,2                   ;bit 1 of ECX=0 if right edge partial,
                                        ; 1 if whole;
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
save_masks:
        mov     ulMasks,eax             ;save left and right clip masks
        mov     ulWholeBytes,ebx        ;save # of whole bytes

        mov     ecx,pfnEdgeDrawing[ecx*4] ;set address of routine to draw
        mov     pfnContinueDrawing,ecx    ; all partial (non-whole) edges

        and     ebx,ebx                 ;any whole bytes?
        jz      short start_vec_set     ;no
                                        ;yes, so draw the whole bytes before
                                        ; the edge bytes

; The whole bytes loop depends on the type of operation being done. If the
; operation is one which uses DR_SET, then we can use a STOS-type operation,
; else we have to use a MOVSB-type operation (to load the latches with the
; existing contents of display memory to allow the ALUs to work).

        cmp     byte ptr jALUFunc,DR_SET ;is it a replace-type rop?
        jz      short is_replace_type   ;yes
                                        ;no, set up for non-replace whole bytes
        mov     ecx,offset whole_bytes_non_replace_wide
                                        ;assume too wide to special-case
        cmp     ebx,MAX_NON_REPLACE_SPECIAL ;too wide to special case?
        jnb     short start_vec_set     ;yes
        mov     ecx,pfnWholeBytesNonReplaceEntries[ebx*4] ;no, point to entry
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_special
                                        ;set up to call special routine to fill
                                        ; whole bytes
        jmp     short start_vec_set

is_replace_type:                        ;set up for replace-type rop
        cmp     ebx,MAX_REPLACE_SPECIAL ;too wide to special case?
        jnb     short is_wide_replace   ;yes
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        and     ecx,011b                ;left edge whole bytes start alignment
                                        ; MOD 3
        mov     ecx,pfnWholeBytesReplaceMaster[ecx*4] ;look up table of entry
                                                      ; tables for alignment
        mov     ecx,[ecx+ebx*4]         ;look up entry table for width
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_special
                                        ;set up to call special routine to fill
                                        ; whole bytes
        jmp     short start_vec_set

is_wide_replace:                        ;set up for wide replace-type op
                                        ;Note: assumes there is at least one
                                        ; full dword involved!
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        neg     ecx
        and     ecx,011b
        mov     edx,ebx
        sub     edx,ecx                 ;ignore odd leading bytes
        mov     eax,edx
        shr     edx,2                   ;# of whole dwords across (not counting
                                        ; odd leading & trailing bytes)
        mov     ulWholeDwords,edx
        and     eax,011b                ;# of odd (fractional) trailing bytes
        shl     ecx,2
        or      ecx,eax                 ;build a look-up index from the number
                                        ; of leading and trailing bytes
        mov     ecx,pfnWideWholeRep[ecx*4] ;proper drawing handler for front/
        mov     pfnWholeBytes,ecx          ; back alignment
        mov     ecx,offset whole_bytes_rep_wide
                                        ;set up to call routine to perform wide
                                        ; whole bytes fill
start_vec_set:
        mov     pfnStartDrawing,ecx     ; all partial (non-whole) edges

        mov     ecx,pdsurf
        mov     eax,[ecx].dsurf_lNextScan
        mov     ulScanWidth,eax         ;local copy of scan line width
        sub     eax,ebx                 ;EAX = delta to next scan
        mov     ulNextScan,eax


;-----------------------------------------------------------------------;
; Fill this rectangle.
;-----------------------------------------------------------------------;

        cmp     byte ptr jInvertDestFirst,1
                                        ;is this an invert-dest-plus-something-
                                        ; else rop that requires two passes?
        jz      short do_invert_dest_rop ;yes, special case with two passes

do_single_pass:
        call    draw_banks


;-----------------------------------------------------------------------;
; See if there are any more rectangles to fill.
;-----------------------------------------------------------------------;

        add     prcl,(size RECTL) ;point to the next rectangle, if there is one
        dec     culRcl            ;count down the rectangles to fill
        jnz     fill_rect_loop


;-----------------------------------------------------------------------;
; We have filled all rectangles.  Restore the VGA to its default state.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,0000h + GRAF_ENAB_SR ;disable set/reset
        out     dx,ax
        mov     eax,GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx,ax                   ;restore read mode 0 and write mode 0
        cmp     byte ptr jALUfunc,DR_SET ;is the logical function already SET?
        jz      short vTrgBlts_done               ;yes, no need to reset it
        mov     eax,(DR_SET shl 8) + GRAF_DATA_ROT ;set the logical function to
        out     dx,ax                             ; SET
vTrgBlts_done:
        cRet    vTrgBlt


;-----------------------------------------------------------------------;
; Handles rops that require two passes, the first being a destination
; inversion pass.
;-----------------------------------------------------------------------;

do_invert_dest_rop:

; Set up the VGA's hardware for inversion

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,0ff00h + GRAF_SET_RESET ;set/reset = 0ffh to invert in
        out     dx,ax                       ; conjunction with XOR
        mov     eax,(DR_XOR shl 8) + GRAF_DATA_ROT
        out     dx,ax                   ;logical function = XOR to invert

; Invert the destination

        call    draw_banks

; Restore the VGA's hardware to the state required for the second pass.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr jDrawingColor
        mov     al,GRAF_SET_RESET       ;set/reset = color to write
        out     dx,ax
        mov     ah,byte ptr jALUFunc
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function

; Perform the second pass to finish the rop.

        jmp     do_single_pass


;-----------------------------------------------------------------------;
; Fills all banks in the current fill rectangle. Called once per fill
; rectangle, except for destination-inversion-plus-something-else rops.
;-----------------------------------------------------------------------;

draw_banks:

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to fill, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     ecx,pdsurf              ;point to surface
        mov     eax,[edi].yTop          ;top scan line of fill
        mov     ulCurrentTopScan,eax    ;this will be the fill top in 1st bank

        cmp     eax,[ecx].dsurf_rcl1WindowClip.yTop ;is fill top less than
                                                    ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[ecx].dsurf_rcl1WindowClip.yBottom ;fill top greater than
                                                       ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the fill.

        ptrCall <dword ptr [ecx].dsurf_pfnBankControl>,<ecx,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;-----------------------------------------------------------------------;

; Compute the starting address and scan line count for the initial bank.

        mov     eax,pdsurf              ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet     ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].dsurf_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Whole byte fills.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special
; case width.
;
; The destination is not involved, so a STOS (or equivalent) can be used
; (no read needed before write).
;-----------------------------------------------------------------------;

whole_bytes_rep_wide:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     esi,ulWholeDwords       ;whole dwords width
        mov     eax,-1                  ;this will become the Bit Mask,
                                        ; enabling drawing to all bits
        mov     edx,ulNextScan          ;offset from end of one scan line to
                                        ; start of next
        call    pfnWholeBytes           ;draw the wide whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handles both replace and non-replace whole byte fills narrow enough to
; special case.
;-----------------------------------------------------------------------;

whole_bytes_special:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     ecx,ulScanWidth         ;offset to next scan line
        mov     eax,-1                  ;this will become the Bit Mask,
                                        ; enabling drawing to all bits
        call    pfnWholeBytes           ;draw the whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special case
; width.
;
; The destination is involved, so a MOVSB (or equivalent) must be
; performed in order to do a read before write to give the ALUs something
; to work with.
;-----------------------------------------------------------------------;

whole_bytes_non_replace_wide:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     eax,ulWholeBytes        ;whole bytes width
        mov     edx,ulNextScan          ;offset from end of one scan line to
                                        ; start of next
        call    draw_wide_rw_loop       ;draw the wide whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Process any left/right columns that that have to be done.
;
;   Currently:
;       EBX =   height to fill, in scans
;       EDI --> first byte of left edge
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes.
;-----------------------------------------------------------------------;
        public do_both_edge_bytes
do_both_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next

        mov     esi,ulWholeBytes        ;ESI = # of whole bytes
        lea     esi,[esi+edi+1]         ;--> start for right edge
        mov     al,byte ptr ulMasks     ;this will become the Bit Mask for the
                                        ; left edge
        push    ebx                     ;preserve scan line count
        call    draw_1_wide_rw_loop     ;jump into the loop to draw
        pop     ebx                     ;restore scan line count

        mov     edi,esi                 ;point to first right edge byte
        mov     al,byte ptr ulMasks+1   ;this will become the Bit Mask for the
                                        ; right edge
        push    offset edges_done       ;return here
        jmp     draw_1_wide_rw_loop     ;jump into the loop to draw

;-----------------------------------------------------------------------;
; Handle case where only the left edge is partial (non-whole).
;-----------------------------------------------------------------------;
do_left_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next
        mov     al,byte ptr ulMasks     ;this will become the Bit Mask for the
                                        ; left edge
        push    offset edges_done       ;return here
        jmp     draw_1_wide_rw_loop     ;jump into the loop to draw

;-----------------------------------------------------------------------;
; Handle case where only the right edge is partial (non-whole).
;-----------------------------------------------------------------------;
do_right_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next
        add     edi,ulWholeBytes        ;--> start for right edge (remember,
                                        ; left edge is whole, so the left edge
                                        ; byte is included in the whole byte
                                        ; count)
        mov     al,byte ptr ulMasks+1   ;this will become the Bit Mask for the
                                        ; right edge
        call    draw_1_wide_rw_loop     ;jump into the loop to draw

;-----------------------------------------------------------------------;
; We have done all partial edges.
;-----------------------------------------------------------------------;

edges_done:

;-----------------------------------------------------------------------;
; See if there are any more banks to process.
;-----------------------------------------------------------------------;

check_next_bank::

        mov     edi,pdsurf
        mov     eax,[edi].dsurf_rcl1WindowClip.yBottom ;is the fill bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jle     short banks_done        ;yes, so we're done
                                        ;no, map in the next bank and fill it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)

        ptrCall <dword ptr [edi].dsurf_pfnBankControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address and scan line count in this bank.

        mov     eax,pdsurf              ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet2    ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].dsurf_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet2:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].dsurf_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; Draw in the new bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Done with all banks in this fill.

banks_done:
        PLAIN_RET

endProc vTrgBlt


;-----------------------------------------------------------------------;
; Drawing loops.
; There are two kinds of loops: read-before-write (to load the
;  latches), and write-only (for replace-type rops).
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is required,
; to load the latches.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide read before write drawing loops.
;
; Entry:
;       AL = pixel mask
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide read/write.

draw_1_wide_rw_loop     proc    near
        and     [edi],al                ;we always read 0xFF, so AL is written
                                        ; as-is; because we're in write mode 3,
                                        ; AL becomes the Bit Mask
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_rw_loop

        ret

draw_1_wide_rw_loop     endp

;-----------------------------------------------------------------------;

; 2-wide read/write.

draw_2_wide_rw_loop     proc    near
        and     [edi],al
        and     [edi+1],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_rw_loop

        ret

draw_2_wide_rw_loop     endp

;-----------------------------------------------------------------------;

; 3-wide read/write.

draw_3_wide_rw_loop     proc    near
        and     [edi],al
        and     [edi+1],al
        and     [edi+2],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_rw_loop

        ret

draw_3_wide_rw_loop     endp

;-----------------------------------------------------------------------;

; 4-wide read/write.

draw_4_wide_rw_loop     proc    near
        and     [edi],al
        and     [edi+1],al
        and     [edi+2],al
        and     [edi+3],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_rw_loop

        ret

draw_4_wide_rw_loop     endp

;-----------------------------------------------------------------------;
; 5-or-wider read before write loop.
;
; Entry:
;       EAX = # of bytes to fill across scan line (needed only by 5-or-wider
;               handler)
;       EBX = loop count
;       EDX = offset from end of one scan line to the start of the next next
;       EDI = start offset
;
; EBX, ECX, ESI, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 5-or-wider read/write. Draws five or more read before write bytes, then
; advances to next scan line. (Actually, will handle any number of bytes,
; including 0, but there are special-case handlers for narrow cases.)
; Works because reads of display memory return 0ffh, which then becomes the
; Bit Mask as it's written in write mode 3.

draw_wide_rw_loop proc  near
        mov     esi,edi
        mov     ecx,eax
        rep     movsb
        add     edi,edx

        dec     ebx
        jnz     draw_wide_rw_loop

        ret

draw_wide_rw_loop endp


;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is NOT required.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; [BUGFIX] - dword writes mess up the cirrus 542x chips so change them
;            to word writes.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide write-only edge-drawing loops.
;
; Entry:
;       AL/AX/EAX = pixel mask (if AX or EAX, then 0xFFFF or 0xFFFFFFFF)
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

;-----------------------------------------------------------------------;

; 1-wide write-only.

draw_1_wide_w_loop     proc    near
        mov     [edi],al                ;we always read 0xFF, so AL is written
                                        ; as-is; because we're in write mode 3,
                                        ; AL becomes the Bit Mask
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_w_loop

        ret

draw_1_wide_w_loop     endp

;-----------------------------------------------------------------------;

; 2-wide write-only.

draw_2_wide_w_loop     proc    near
        mov     [edi],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_w_loop

        ret

draw_2_wide_w_loop     endp

;-----------------------------------------------------------------------;

; 3-wide write-only, starting at an even address.

draw_3_wide_w_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_w_even_loop

        ret

draw_3_wide_w_even_loop     endp

;-----------------------------------------------------------------------;

; 3-wide write-only, starting at an odd address.

draw_3_wide_w_odd_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_w_odd_loop

        ret

draw_3_wide_w_odd_loop     endp


;-----------------------------------------------------------------------;

; 4-wide write-only.

draw_4_wide_w_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_w_loop

        ret

draw_4_wide_w_loop     endp


;-----------------------------------------------------------------------;

; 5-wide write-only, starting at an even address.

draw_5_wide_w_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_w_even_loop

        ret

draw_5_wide_w_even_loop     endp


;-----------------------------------------------------------------------;

; 5-wide write-only, starting at an odd address.

draw_5_wide_w_odd_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_w_odd_loop

        ret

draw_5_wide_w_odd_loop     endp


;-----------------------------------------------------------------------;

; 6-wide write-only, starting at MOD 3 == 0.

draw_6_wide_w_mod3_0_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_0_loop

        ret

draw_6_wide_w_mod3_0_loop     endp


;-----------------------------------------------------------------------;

; 6-wide write-only, starting at MOD 3 == 1 or 3.

draw_6_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_1_loop

        ret

draw_6_wide_w_mod3_1_loop     endp


;-----------------------------------------------------------------------;

; 6-wide write-only, starting at MOD 3 == 2.

draw_6_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_2_loop

        ret

draw_6_wide_w_mod3_2_loop     endp


;-----------------------------------------------------------------------;

; 7-wide write-only, starting at MOD 3 == 0.

draw_7_wide_w_mod3_0_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_0_loop

        ret

draw_7_wide_w_mod3_0_loop     endp


;-----------------------------------------------------------------------;

; 7-wide write-only, starting at MOD 3 == 0.

draw_7_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_1_loop

        ret

draw_7_wide_w_mod3_1_loop     endp


;-----------------------------------------------------------------------;

; 7-wide write-only, starting at MOD 3 == 2.

draw_7_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_2_loop

        ret

draw_7_wide_w_mod3_2_loop     endp


;-----------------------------------------------------------------------;

; 7-wide write-only, starting at MOD 3 == 3.

draw_7_wide_w_mod3_3_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_3_loop

        ret

draw_7_wide_w_mod3_3_loop     endp


;-----------------------------------------------------------------------;

; 8-wide write-only, starting at MOD 3 == 0.

draw_8_wide_w_mod3_0_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_0_loop

        ret

draw_8_wide_w_mod3_0_loop     endp


;-----------------------------------------------------------------------;

; 8-wide write-only, starting at MOD 3 == 1.

draw_8_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        mov     [edi+7],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_1_loop

        ret

draw_8_wide_w_mod3_1_loop     endp


;-----------------------------------------------------------------------;

; 8-wide write-only, starting at MOD 3 == 2.

draw_8_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],ax
        mov     [edi+4],ax
        mov     [edi+6],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_2_loop

        ret

draw_8_wide_w_mod3_2_loop     endp


;-----------------------------------------------------------------------;

; 8-wide write-only, starting at MOD 3 == 3.

draw_8_wide_w_mod3_3_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],ax
        mov     [edi+5],ax
        mov     [edi+7],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_3_loop

        ret

draw_8_wide_w_mod3_3_loop     endp

;-----------------------------------------------------------------------;
; Drawing loops for wide replace-type rops (arbitrary width).
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = 0ffffh
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_00_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_00_loop

        ret

draw_wide_w_00_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_01_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_01_loop

        ret

draw_wide_w_01_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_02_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_02_loop

        ret

draw_wide_w_02_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_03_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_03_loop

        ret

draw_wide_w_03_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 1 leading byte, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_10_loop     proc    near
        stosb                   ;fill the leading byte
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_10_loop

        ret

draw_wide_w_10_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 1 leading bytes, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_11_loop     proc    near
        stosb                   ;fill the leading byte
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_11_loop

        ret

draw_wide_w_11_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 1 leading bytes, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_12_loop     proc    near
        stosb                   ;fill the leading byte
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_12_loop

        ret

draw_wide_w_12_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_13_loop     proc    near
        stosb                   ;fill the leading byte
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_13_loop

        ret

draw_wide_w_13_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 2 leading bytes, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_20_loop     proc    near
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_20_loop

        ret

draw_wide_w_20_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 2 leading bytess, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_21_loop     proc    near
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_21_loop

        ret

draw_wide_w_21_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 2 leading bytess, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_22_loop     proc    near
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_22_loop

        ret

draw_wide_w_22_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_23_loop     proc    near
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_23_loop

        ret

draw_wide_w_23_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 3 leading bytes, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_30_loop     proc    near
        stosb                   ;fill the leading byte
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_30_loop

        ret

draw_wide_w_30_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 3 leading bytess, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_31_loop     proc    near
        stosb                   ;fill the leading byte
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_31_loop

        ret

draw_wide_w_31_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 3 leading bytess, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_32_loop     proc    near
        stosb                   ;fill the leading byte
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_32_loop

        ret

draw_wide_w_32_loop     endp


;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_33_loop     proc    near
        stosb                   ;fill the leading byte
        stosw                   ;fill the leading word
        mov     ecx,esi         ;# of whole dwords
        shl     ecx,1
        rep     stosw           ;fill all whole bytes as words
        stosw                   ;fill the trailing word
        stosb                   ;fill the trailing byte
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_33_loop

        ret

draw_wide_w_33_loop     endp


;--------------------------Private-Routine------------------------------;
; comp_byte_interval
;
;   A interval will be computed for byte boundaries.
;
;   A first mask and a last mask will be calculated, and possibly
;   combined into the inner loop count.  If no first byte exists,
;   the start address will be incremented to adjust for it.
;
; Entry:
;       EBX = right coordinate (exclusive)
;       EDX = left coordinate  (inclusive)
; Returns:
;       EDI = offset to first byte to be altered in the scan
;       ESI = inner loop count
;       AL  = first byte mask (possibly 0)
;       AH  = last  byte mask (possibly 0)
; Error Returns:
;       None
; Registers Preserved:
;       ES,BP
; Registers Destroyed:
;       AX,BX,CX,DX,SI,DI,FLAGS
; Calls:
;       None
; History:
;       Sat 11-Apr-1987 20:39:10 -by-  Walt Moore [waltm]
;       Created.
;-----------------------------------------------------------------------;

cProc   comp_byte_interval

        sub     ebx,edx                 ;Compute extent of interval
        dec     ebx                     ;Make interval inclusive
        mov     edi,edx                 ;Don't destroy starting X
        shr     edi,3                   ;/8 for byte address

        and     edx,00000111b           ;Compute bit index for left side
        add     ebx,edx                 ;Compute bit index for right side
        mov     esi,ebx                 ;(save for inner loop count)
        and     ebx,00000111b
        mov     cl,dl                   ;Compute left side altered bits mask
        mov     eax,0FFFFFFFFh
        mov     edx,eax                 ;Need this here later
        shr     al,cl                   ;AL = left side altered bytes mask
        mov     cl,bl                   ;Compute right side altered bits mask
        mov     ah,80h
        sar     ah,cl                   ;AH = right side altered bits mask
        shr     esi,3                   ;Compute inner byte count
        jnz     short comp_byte_dont_combine ;loop count + 1 > 0, check it out

; Only one byte will be affected.  Combine first/last masks, set loop count = 0

        and     al,ah                   ;Will use first byte mask only
        xor     ah,ah                   ;Want last byte mask to be 0
        inc     esi                     ;Fall through to set 0

comp_byte_dont_combine:
        dec     esi                     ;Dec inner loop count (might become 0)


; If all pixels in the first byte are altered, combine the first byte into the
; inner loop and clear the first byte mask.  Ditto for the last byte mask.

        cmp     al,dl                   ;Set 'C' if not all pixels 1
        sbb     esi,edx                 ;If no 'C', sub -1 (add 1), else sub 0
        cmp     al,dl                   ;Set 'C' if not all pixels 1
        sbb     al,dl                   ;If no 'C', sub -1 (add 1), else sub 0

        cmp     ah,dl                   ;Set 'C' if not all pixels 1
        sbb     esi,edx                 ;If no 'C', sub -1 (add 1), else sub 0
        cmp     ah,dl                   ;Set 'C' if not all pixels 1
        sbb     ah,dl                   ;If no 'C', sub -1 (add 1), else sub 0
        cRet    comp_byte_interval

endProc comp_byte_interval

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\vgaregs.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgaregs.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vInitRegs(void)
;
; Sets the VGA's data control registers to their default states.
;
;-----------------------------------------------------------------------;

        .386


ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        .list

        .code

cProc vInitRegs

;       Initialize sequencer to its defaults (all planes enabled, index
;       pointing to Map Mask).

        mov     dx,VGA_BASE + SEQ_ADDR
        mov     ax,(MM_ALL shl 8) + SEQ_MAP_MASK
        out     dx,ax

;       Initialize graphics controller to its defaults (set/reset disabled for
;       all planes, no rotation & ALU function == replace, write mode 0 & read
;       mode 0, color compare ignoring all planes (read mode 1 reads always
;       return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
;       bytes from the CPU.

        mov     dl,GRAF_ADDR
        mov     ax,(0 shl 8) + GRAF_ENAB_SR
        out     dx,ax

        mov     ax,(DR_SET shl 8) + GRAF_DATA_ROT
        out     dx,ax

        mov     ax,((M_PROC_WRITE or M_DATA_READ) shl 8) + GRAF_MODE
        out     dx,ax

        mov     ax,(0 shl 8) + GRAF_CDC
        out     dx,ax

        mov     ax,(0FFh shl 8) + GRAF_BIT_MASK
        out     dx,ax

        cRet    vInitRegs


endProc vInitRegs

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\vgastrps.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgastrps.asm
;
; Routines used by line code to draw strips of pixels.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\lines.inc
        .list

        .code

_TEXT$04   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;---------------------------Public-Routine------------------------------;
; vSetStrips
;
; Set the VGA into the appropriate mode for line drawing.
;
;-----------------------------------------------------------------------;

cProc   vSetStrips,8,<     \
        clr:    dword,     \
        mode:   dword      >

        mov     edx, VGA_BASE + GRAF_ADDR

        mov     al, GRAF_SET_RESET
        mov     ah, byte ptr clr
        out     dx, ax

        cmp     mode, DR_SET
        je      @F

        mov     al, GRAF_DATA_ROT
        mov     ah, byte ptr mode
        out     dx, ax

@@:
        mov     eax, GRAF_MODE + ((M_AND_WRITE + M_COLOR_READ) SHL 8)
        out     dx, ax                  ;write mode 3 so we can do the masking
                                        ; without OUTs, read mode 1 so we can
                                        ; read 0xFF from memory always, for
                                        ; ANDing (because Color Don't Care is
                                        ; all zeros)
        cRet    vSetStrips

endProc vSetStrips

;---------------------------Public-Routine------------------------------;
; vClearStrips
;
; Restore the VGA to its default state.
;
;-----------------------------------------------------------------------;

cProc   vClearStrips,4,< \
        oldmode: dword   >

; Restore the EGA/VGA to its default state:

        mov     edx, VGA_BASE + GRAF_ADDR

        cmp     oldmode, DR_SET
        je      @F
        mov     eax, (DR_SET shl 8) + GRAF_DATA_ROT
        out     dx, ax

@@:
        mov     eax, GRAF_MODE + ((M_PROC_WRITE + M_DATA_READ) SHL 8)
        out     dx, ax                  ;restore read mode 0 and write mode 0

        cRet    vClearStrips

endProc vClearStrips

;--------------------------Private-Routine------------------------------;
; vStripSolidDiagonalHorizontal
;
;   Draw an x-major near-diagonal strip left-to-right
;
;-----------------------------------------------------------------------;

cProc   vStripSolidDiagonalHorizontal,12,< \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd
        mov     ecx, [esi].ST_lNextScan
        mov     al,  [esi].ST_jBitMask
        mov     edi, [esi].ST_pjScreen
        add     esi, offset ST_alStrips

;                   al  = bit mask
;                   ebx = pixel count
;                   ecx = delta
;                   edx = port #
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

next_diagonal:
        mov     ebx, [esi]
        add     esi, 4

diagonal_loop:
        and     [edi], al
        ror     al, 1
        adc     edi, ecx
        dec     ebx
        jnz     short diagonal_loop

        sub     edi, ecx                        ; side step
        cmp     esi, ebp
        jl      short next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidDiagonalHorizontal

endProc vStripSolidDiagonalHorizontal

;--------------------------Private-Routine------------------------------;
; vStripSolidDiagonalVertical
;
;   Draw a y-major near-diagonal strip left-to-right
;
;-----------------------------------------------------------------------;

cProc   vStripSolidDiagonalVertical,12,< \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd
        mov     ecx, [esi].ST_lNextScan
        mov     al,  [esi].ST_jBitMask
        mov     edi, [esi].ST_pjScreen
        add     esi, offset ST_alStrips

;                   al  = bit mask
;                   ebx = pixel count
;                   ecx = delta
;                   edx = port #
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

next_diagonal:
        mov     ebx, [esi]
        add     esi, 4

diagonal_loop:
        and      [edi], al
        ror     al, 1
        adc     edi, ecx
        dec     ebx
        jnz     short diagonal_loop

        rol     al, 1                           ; side step
        sbb     edi, 0
        cmp     esi, ebp
        jl      short next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidDiagonalVertical

endProc vStripSolidDiagonalVertical

;--------------------------Private-Routine------------------------------;
; vStripSolidHorizontal
;
;   Draw a horizontal strip left to right
;
;-----------------------------------------------------------------------;

cProc   vStripSolidHorizontal,12,< \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initializing:

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd
        mov     edx, [esi].ST_lNextScan
        mov     al,  [esi].ST_jBitMask
        mov     edi, [esi].ST_pjScreen
        add     esi, offset ST_alStrips

;       (al)  = rotating bit
;       (bl)  = current mask
;       (ecx) = pixel count
;       (edx) = delta
;       (esi) = strip pointer
;       (edi) = display pointer
;       (ebp) = end of strips pointer

next_horizontal:
        mov     ecx, [esi]
        add     esi, 4

        lea     ebx, [2 * eax - 1]      ; bl = start mask
        ror     al, cl                  ; rotate bit
        shr     ecx, 3                  ; compute # bytes to lay down
        cmp     bl, al                  ; we have to adjust for wrap
        adc     ecx, 0
        jnz     short extends_out_of_first_byte

        sub     bl, al                  ; zero out end bits
        sub     bl, al
        inc     bl
        and     [edi], bl               ; write result
        add     edi, edx                ; increment to next scan
        cmp     esi, ebp                ; see if done strips
        jb      short next_horizontal

        pop     ebp                     ; we're done
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidHorizontal

extends_out_of_first_byte:

; This part gets called when the current strip doesn't fit entirely
; into one byte:

        and     [edi], bl               ; output with start mask
        inc     edi                     ; go on to next byte

        dec     ecx                     ; see if there's any bytes in
        jnz     short output_bunch      ;    between start and end byte

last_byte:
        lea     ebx, [2 * eax - 1]      ; compute end mask
        not     bl
        and     [edi], bl               ; write result
        add     edi, edx                ; increment to next scan
        cmp     esi, ebp                ; see if done strips
        jb      short next_horizontal

        pop     ebp                     ; we're done
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidHorizontal

output_bunch:

; We have a bunch of complete bytes to lay down.

        mov     ebx, esi                ; we're gonna overwrite esi
        mov     esi, edi
        rep     movsb                   ; Write the bytes.  Mask is 0ffh because
                                        ; we're in read mode 1, reading 0ffh,
                                        ; which becomes the write mode 3 mask.

        mov     esi, ebx                ; restore esi

        jmp     short last_byte         ; do last byte in scan

endProc vStripSolidHorizontal

;--------------------------Private-Routine------------------------------;
; vStripSolidHorizontalSet
;
;   Draw horizontal strips left to right for SRCCOPY lines.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidHorizontalSet,12,< \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initializing:

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd
        mov     edx, [esi].ST_lNextScan
        mov     al,  [esi].ST_jBitMask
        mov     edi, [esi].ST_pjScreen
        add     esi, offset ST_alStrips

;       (al)  = rotating bit
;       (bl)  = current mask
;       (ecx) = pixel count
;       (edx) = delta
;       (esi) = strip pointer
;       (edi) = display pointer
;       (ebp) = end of strips pointer

next_horizontal:
        mov     ecx, [esi]
        add     esi, 4

        lea     ebx, [2 * eax - 1]      ; bl = start mask
        ror     al, cl                  ; rotate bit
        shr     ecx, 3                  ; compute # bytes to lay down
        cmp     bl, al                  ; we have to adjust for wrap
        adc     ecx, 0
        jnz     short extends_out_of_first_byte

        sub     bl, al                  ; zero out end bits
        sub     bl, al
        inc     bl
        and     [edi], bl               ; write result
        add     edi, edx                ; increment to next scan
        cmp     esi, ebp                ; see if done strips
        jb      short next_horizontal

        pop     ebp                     ; we're done
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidHorizontalSet

extends_out_of_first_byte:

; This part gets called when the current strip doesn't fit entirely
; into one byte:

        and     [edi], bl               ; output with start mask
        inc     edi                     ; go on to next byte

        dec     ecx                     ; see if there's any bytes in
        jnz     short output_bunch      ;    between start and end byte

last_byte:
        lea     ebx, [2 * eax - 1]      ; compute end mask
        not     bl
        and     [edi], bl               ; write result
        add     edi, edx                ; increment to next scan
        cmp     esi, ebp                ; see if done strips
        jb      short next_horizontal

        pop     ebp                     ; we're done
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidHorizontalSet

output_bunch:

; We have a bunch of complete bytes to lay down.  Since we're doing
; the interior of the line and we have a SRCCOPY ROP, we don't have
; to worry about loading the latches properly, so we can do this
; without reading the VGA memory.  We also use 16 bit writes since
; on some devices it's faster to write a single word than to write
; two bytes -- doing so means we must be word-aligned.

        test    edi, 1
        jz      now_aligned
        mov     byte ptr [edi], 0ffh    ; write a byte to get alignment right
        inc     edi
        dec     ecx
        jz      short last_byte         ; maybe that was only byte we had to do

now_aligned:
        shr     ecx, 1                  ; divide by 2 to determine the number
                                        ; of words to write
                                        ; NOTE: We check the carry later on!

        jz      short last_byte_in_bunch ; small optimization: skip word stuff
                                         ; if we've only got a single byte

        mov     ebx, eax                ; save eax
        mov     eax, 0ffffh             ; prepare ax
        rep     stosw                   ; lay those words down
        mov     eax, ebx                ; restore eax
        jnc     short last_byte         ; NOTE: NOW we're checking the carry!

last_byte_in_bunch:
        mov     byte ptr [edi], 0ffh    ; write that last byte
        inc     edi
        jmp     short last_byte

endProc vStripSolidHorizontalSet


;--------------------------Private-Routine------------------------------;
; vStripSolidVertical
;
;   Draw a vertical strip left to right
;
;-----------------------------------------------------------------------;

cProc   vStripSolidVertical,12,<   \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initialization:

        mov     esi, pStrips
        mov     edx, plStripEnd
        mov     ecx, [esi].ST_lNextScan
        mov     al,  [esi].ST_jBitmask
        mov     edi, [esi].ST_pjScreen
        add     esi, offset ST_alStrips
        mov     [edx], ebp              ; save ebp

next_vertical:
        mov     ebx, [esi]              ; ebx = # bits to set
        add     esi, 4

;       (al)  = rotating bit
;       (ebx) = # of loops to do
;       (ecx) = minor add
;       (edx) = end of strips pointer
;       (esi) = strip pointer
;       (edi) = address of byte to write
;       (ebp) = garbage

vertical_strip_loop:
        and     [edi], al               ; write the byte
        add     edi, ecx                ; go to next scan
        dec     ebx
        jnz     vertical_strip_loop

; Adjust address and rotating bit for sidestep:

        ror     al, 1                   ; one to the right
        adc     edi, 0

        cmp     esi, edx
        jl      short next_vertical     ; hit end of array?

; Remember where we left off, for next time:

        mov     ebp, [edx]              ; restore ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        cRet    vStripSolidVertical

endProc vStripSolidVertical

;--------------------------Private-Routine------------------------------;
; vStripStyledHorizontal
;
;   Draws an arbitrarily styled horizontal strip left-to-right.
;
;-----------------------------------------------------------------------;

cProc   vStripStyledHorizontal,12,< \
        uses        esi edi ebx,    \
        pStrips:    ptr STRIPS,     \
        pls:        ptr LINESTATE,  \
        plStripEnd: ptr >

        local   aEnd:dword              ; end of length array
        local   minoradd:dword
        local   spToGo:dword

; So some initialization:

        mov     esi, pStrips
        mov     eax, plStripEnd
        mov     aEnd, eax

        mov     eax, [esi].ST_lNextScan
        mov     bl,  [esi].ST_jBitmask
        mov     edi, [esi].ST_pjScreen
        mov     minoradd, eax

; Initialize styling:

        mov     eax, [esi].ST_spRemaining
        mov     bh,  [esi].ST_jStyleMask
        mov     spToGo, eax
        add     esi, offset ST_alStrips

Strip_loop:
        mov     ecx, [esi]              ; ecx = # bits to write
        add     esi, 4

; Now we're going to paste the bytes to the screen
;
;       (al)  = used to accumulate the mask
;       (bl)  = rotating bit
;       (bh)  = jStyleMask
;       (ecx) = # of bits to write
;       (edx) =
;       (esi) = ptr to spot in ST_alStrips
;       (edi) = address of byte to write

        xor     al, al                  ; clear style mask

Strip_count:
        xor     al, bh                  ; set bit in output mask if style bit 0
        or      al, bl
        xor     al, bh

        dec     spToGo
        jz      short Next_style_entry

Next_bit:
        ror     bl, 1
        jc      short Output_byte
        dec     ecx
        jnz     short Strip_count

; Do sidestep

Side_step:
        and     byte ptr [edi], al
        add     edi, minoradd

        cmp     esi, aEnd
        jl      short Strip_loop

        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, bl
        mov     [esi].ST_jStyleMask, bh
        mov     eax, spToGo
        mov     [esi].ST_spRemaining, eax

        cRet    vStripStyledHorizontal

Output_byte:
        and     byte ptr [edi], al
        xor     al, al
        inc     edi                     ; Moved one byte to right on screen
        dec     ecx
        jnz     short Strip_count
        jz      short Side_step

; We're on to a new entry in the style array:

Next_style_entry:
        push    eax
        mov     edx, pStrips
        mov     eax, [edx].ST_psp
        add     eax, 4
        cmp     [edx].ST_pspEnd, eax
        jae     short @F
        mov     eax, [edx].ST_pspStart  ; Go back to start of array
@@:
        mov     [edx].ST_psp, eax
        mov     edx, [eax]              ; Load up new style entry

        add     spToGo, edx
        not     bh                      ; jStyleMask = !jStyleMask

        pop     eax
        jmp     short Next_bit

endProc vStripStyledHorizontal


;--------------------------Private-Routine------------------------------;
; vStripStyledVertical
;
;   Draw an arbitrarily styled vertical strip left-to-right.
;
;-----------------------------------------------------------------------;

cProc   vStripStyledVertical,12,<  \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   aEnd:dword              ; end of length array
        local   minoradd:dword
        local   spToGo:dword

; So some initialization:

        mov     esi, pStrips
        mov     eax, plStripEnd
        mov     aEnd, eax

        mov     ecx, [esi].ST_lNextScan
        mov     al,  [esi].ST_jBitmask
        mov     edi, [esi].ST_pjScreen
        mov     minoradd, ecx

; Initialize styling:

        mov     ebx, [esi].ST_spRemaining
        mov     ah,  [esi].ST_jStyleMask
        mov     spToGo, ebx
        add     esi, offset ST_alStrips

Strip_loop:
        mov     ebx, [esi]              ; ebx = # bits to set
        add     esi, 4

; Now we're going to paste the bytes to the screen
;
;       (al)  = rotating bit
;       (ah)  = jStyleMask
;       (ebx) = # of bits to write
;       (ecx) = minor add
;       (edx) =
;       (esi) = ptr to spot in ST_alStrips
;       (edi) = address of byte to write

Strip_count:
        or      ah, ah
        jnz     short @F                ; Don't output pixel if in a gap
        and     [edi], al
@@:
        dec     spToGo
        jz      short Next_style_entry

Minor_add:
        add     edi, ecx
        dec     ebx
        jnz     short Strip_count

; Adjust address and rotating bit for sidestep

        ror     al, 1                   ; one to the right
        adc     edi, 0

        cmp     esi, aEnd
        jl      short Strip_loop        ; hit end of array?

        mov     esi, pStrips
        mov     [esi].ST_pjScreen, edi
        mov     [esi].ST_jBitmask, al
        mov     [esi].ST_jStyleMask, ah
        mov     eax, spToGo
        mov     [esi].ST_spRemaining, eax

        cRet    vStripStyledVertical

Next_style_entry:
        mov     edx, pStrips
        mov     ecx, [edx].ST_psp
        add     ecx, 4
        cmp     [edx].ST_pspEnd, ecx
        jae     short @F
        mov     ecx, [edx].ST_pspStart  ; Go back to start of array
@@:
        mov     [edx].ST_psp, ecx       ; Save our pointer
        mov     edx, [ecx]              ; Load up new style entry
        add     spToGo, edx
        not     ah                      ; jStyleMask = !jStyleMask

; Restore the registers we used:

        mov     ecx, minoradd
        jmp     short Minor_add

endProc vStripStyledVertical


;--------------------------Private-Routine------------------------------;
; vStripMaskedHorizontal
;
;   Draws a mask-styled horizontal strip left to right.
;
;-----------------------------------------------------------------------;

cProc   vStripMaskedHorizontal,12,< \
        uses        esi edi ebx,    \
        pStrips:    ptr STRIPS,     \
        pls:        ptr LINESTATE,  \
        plStripEnd: ptr >

        local   aEnd:dword              ; end of length array
        local   minoradd:dword
        local   density:dword

; So some initialization:

        mov     esi, pStrips
        mov     eax, plStripEnd
        mov     aEnd, eax
        mov     eax, [esi].ST_lNextScan
        mov     bl,  [esi].ST_jBitmask
        mov     edi, [esi].ST_pjScreen
        mov     minoradd, eax

; Initialize styling:

        mov     ecx,          [esi].ST_xyDensity
        mov     ah,  byte ptr [esi].ST_spRemaining
        mov     bh,           [esi].ST_jStyleMask
        mov     density, ecx
        add     esi, offset ST_alStrips

Strip_loop:
        mov     ecx, [esi]              ; ecx = # bits to write
        add     esi, 4

; Now we're going to paste the bytes to the screen
;
;       (al)  = used to accumulate style mask
;       (ah)  = # pixels left in style
;       (bl)  = rotating bit
;       (bh)  = style mask
;       (ecx) = # of bits to write
;       (esi) = ptr to spot in ST_alStrips
;       (edi) = address of byte to write

        xor     al, al                  ; clear output mask

Strip_count:
        xor     al, bh                  ; set bit in output mask if style bit 0
        or      al, bl
        xor     al, bh

        dec     ah
        jnz     short @F
        rol     bh, 1
        mov     ah, byte ptr density
@@:     ror     bh, 1
        ror     bl, 1
        jc      short Output_byte
        dec     ecx
        jnz     short Strip_count

; Do sidestep

Side_step:
        and     byte ptr [edi], al
        add     edi, minoradd

        cmp     esi, aEnd
        jl      short Strip_loop

        mov     esi, pStrips

        mov              [esi].ST_pjScreen, edi
        mov              [esi].ST_jBitmask, bl
        mov              [esi].ST_jStyleMask, bh
        mov     byte ptr [esi].ST_spRemaining, ah

        cRet    vStripMaskedHorizontal

Output_byte:
        and     byte ptr [edi], al
        xor     al, al
        inc     edi
        dec     ecx
        jnz     short Strip_count
        jz      short Side_step

endProc vStripMaskedHorizontal

;--------------------------Private-Routine------------------------------;
; vStripMaskedVertical
;
;   Draw a mask-styled vertical strip left to right.
;
;-----------------------------------------------------------------------;

cProc   vStripMaskedVertical,12,<  \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   aEnd:dword              ; end of length array
        local   minoradd:dword
        local   density:dword

; So some initialization:

        mov     esi, pStrips
        mov     al,  [esi].ST_jBitmask
        mov     edi, [esi].ST_pjScreen
        mov     ebx, [esi].ST_lNextScan
        mov     ecx, plStripEnd
        mov     minoradd, ebx
        mov     aEnd, ecx

; Initialize styling:

        mov     ecx,          [esi].ST_xyDensity
        mov     ah,  byte ptr [esi].ST_spRemaining
        mov     bh,           [esi].ST_jStyleMask
        mov     density, ecx
        add     esi, offset ST_alStrips

Strip_loop:
        mov     ecx, [esi]              ; ecx = # bits to set
        add     esi, 4

; Now we're going to paste the bytes to the screen
;       (al) = rotating bit
;       (ah) = # pixels left in style
;       (bh) = style mask
;       (ecx) = # bits to write
;       (dx) = io address of mask register
;       (esi) = ptr to spot in ST_alStrips
;       (edi) = address of byte to write

Strip_count:
        test    bh, al
        jnz     short @F                ; don't output pixel if style bit is 1
        and     [edi], al
@@:
        dec     ah                      ; we've advanced 1 pel in the style
        jnz     short @F
        mov     ah, byte ptr density
        rol     bh, 1
@@:
        add     edi, minoradd

        dec     ecx
        jnz     short Strip_count

; Adjust address, style mask and rotating bit for sidestep:

        ror     bh, 1                   ; rotate style mask to stay in sync
        ror     al, 1                   ; move rotating bit one to the right
        adc     edi, 0

        cmp     esi, aEnd
        jl      short Strip_loop        ; hit end of array?

        mov     esi, pStrips

        mov              [esi].ST_pjScreen, edi
        mov              [esi].ST_jBitmask, al
        mov              [esi].ST_jStyleMask, bh
        mov     byte ptr [esi].ST_spRemaining, ah

        cRet    vStripMaskedVertical

endProc vStripMaskedVertical

_TEXT$04   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTVGA(x, y) if (!(x)) RIP (y)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTVGA(x, y)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\4bpp\i386\vgalines.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: lines.asm
;
; Draws a set of connected polylines.  Initialization for the device
; or bitmap has already been done in the stroke routine.  Solid and
; styled lines are handled for both the device and bitmaps.  Banking
; for the display is handled.
;
; The code is different depending on whether we are drawing solid
; lines, styled lines with common styles, or lines with completely
; arbitrary styles.
;
; There are sixteen raster operations (sets of logical operations)
; performed on the data written out.  When writing to the VGA there are
; four of these operations which take two passes of VGA memory.  In
; each of these cases the first pass inverts the necessary bits in the
; necessary planes.  The second pass then performs the rest of the
; raster operation.  The other twelve raster operations can be done in
; one pass of VGA memory.  All raster operations are done in one pass of
; memory for bitmaps.  Depending on the raster operation and the color
; of the pen, it is easily determined whether we set bits to zeros, set
; bits to ones, invert bits or do nothing.  Bitmaps are written to one
; plane at a time.
;
; Lines are drawn from left to right.  So if a line moves from right
; to left, the endpoints are swapped and the line is drawn from left to
; right.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\lines.inc
        .list

        .data

        public gaflRoundTable
gaflRoundTable       label  dword
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; no flips
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; D flip
        dd      FL_H_ROUND_DOWN                         ; V flip
        dd      FL_V_ROUND_DOWN                         ; D & V flip
        dd      FL_V_ROUND_DOWN                         ; slope one
        dd      0baadf00dh
        dd      FL_H_ROUND_DOWN                         ; slope one & V flip
        dd      0baadf00dh

        .code

_TEXT$03   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;--------------------------------Macro----------------------------------;
; testb ebx, <mask>
;
; Substitutes a byte compare if the mask is entirely in the lo-byte or
; hi-byte (thus saving 3 bytes of code space).
;
;-----------------------------------------------------------------------;

TESTB   macro   targ,mask,thirdarg
        local   mask2,delta

ifnb <thirdarg>
        .err    TESTB mask must be enclosed in brackets!
endif

        delta = 0
        mask2 = mask

        if mask2 AND 0ffff0000h
            test targ,mask                      ; If bit set in hi-word,
            exitm                               ; test entire dword
        endif

        if mask2 AND 0ff00h
            if mask2 AND 0ffh                   ; If bit set in lo-byte and
                test targ,mask                  ; hi-byte, test entire dword
                exitm
            endif

            mask2 = mask2 SHR 8
            delta = 1
        endif

ifidni <targ>,<EBX>
        if delta
            test bh,mask2
        else
            test bl,mask2
        endif
        exitm
endif

        .err    Too bad TESTB doesn't support targets other than ebx!
endm

;---------------------------Public-Routine------------------------------;
; bLines(pdsurf, pptfxFirst, pptfxBuf, prun, cptfx, pls,
;        prclClip, apfn[], flStart)
;
; Do all the DDA calculations for lines.
;
; Doing Lines Right
; -----------------
;
; In NT, all lines are given to the device driver in fractional
; coordinates, in a 28.4 fixed point format.  The lower 4 bits are
; fractional for sub-pixel positioning.
;
; Note that you CANNOT! just round the coordinates to integers
; and pass the results to your favorite integer Bresenham routine!!
; (Unless, of course, you have such a high resolution device that
; nobody will notice -- not likely for a display device.)  The
; fractions give a more accurate rendering of the line -- this is
; important for things like our Bezier curves, which would have 'kinks'
; if the points in its polyline approximation were rounded to integers.
;
; Unfortunately, for fractional lines there is more setup work to do
; a DDA than for integer lines.  However, the main loop is exactly
; the same (and can be done entirely with 32 bit math).
;
; If You've Got Hardware That Does Bresenham
; ------------------------------------------
;
; A lot of hardware limits DDA error terms to 'n' bits.  With fractional
; coordinates, 4 bits are given to the fractional part, letting
; you draw in hardware only those lines that lie entirely in a 2^(n-4)
; by 2^(n-4) pixel space.
;
; And you still have to correctly draw those lines with coordinates
; outside that space!  Remember that the screen is only a viewport
; onto a 28.4 by 28.4 space -- if any part of the line is visible
; you MUST render it precisely, regardless of where the end points lie.
; So even if you do it in software, somewhere you'll have to have a
; 32 bit DDA routine.
;
; Our Implementation
; ------------------
;
; We employ a run length slice algorithm: our DDA calculates the
; number of pixels that are in each row (or 'strip') of pixels.
;
; We've separated the running of the DDA and the drawing of pixels:
; we run the DDA for several iterations and store the results in
; a 'strip' buffer (which are the lengths of consecutive pixel rows of
; the line), then we crank up a 'strip drawer' that will draw all the
; strips in the buffer.
;
; We also employ a 'half-flip' to reduce the number of strip
; iterations we need to do in the DDA and strip drawing loops: when a
; (normalized) line's slope is more than 1/2, we do a final flip
; about the line y = (1/2)x.  So now, instead of each strip being
; consecutive horizontal or vertical pixel rows, each strip is composed
; of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
; (128, 128) would generate only one strip.
;
; We also always draw only left-to-right.
;
; Style lines may have arbitrary style patterns.  We specially
; optimize the default patterns (and call them 'masked' styles).
;
; The DDA Derivation
; ------------------
;
; Here is how I like to think of the DDA calculation.
;
; We employ Knuth's "diamond rule": rendering a one-pixel-wide line
; can be thought of as dragging a one-pixel-wide by one-pixel-high
; diamond along the true line.  Pixel centers lie on the integer
; coordinates, and so we light any pixel whose center gets covered
; by the "drag" region (John D. Hobby, Journal of the Association
; for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
;
; We must define which pixel gets lit when the true line falls
; exactly half-way between two pixels.  In this case, we follow
; the rule: when two pels are equidistant, the upper or left pel
; is illuminated, unless the slope is exactly one, in which case
; the upper or right pel is illuminated.  (So we make the edges
; of the diamond exclusive, except for the top and left vertices,
; which are inclusive, unless we have slope one.)
;
; This metric decides what pixels should be on any line BEFORE it is
; flipped around for our calculation.  Having a consistent metric
; this way will let our lines blend nicely with our curves.  The
; metric also dictates that we will never have one pixel turned on
; directly above another that's turned on.  We will also never have
; a gap; i.e., there will be exactly one pixel turned on for each
; column between the start and end points.  All that remains to be
; done is to decide how many pixels should be turned on for each row.
;
; So lines we draw will consist of varying numbers of pixels on
; successive rows, for example:
;
;       ******
;             *****
;                  ******
;                        *****
;
; We'll call each set of pixels on a row a "strip".
;
; (Please remember that our coordinate space has the origin as the
; upper left pixel on the screen; postive y is down and positive x
; is right.)
;
; Device coordinates are specified as fixed point 28.4 numbers,
; where the first 28 bits are the integer coordinate, and the last
; 4 bits are the fraction.  So coordinates may be thought of as
; having the form (x, y) = (M/F, N/F) where F is the constant scaling
; factor F = 2^4 = 16, and M and N are 32 bit integers.
;
; Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
; left-to-right and whose slope is in the first octant, and let
; dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
;
; Since the slope of the line is less than 1, the edges of the
; drag region are created by the top and bottom vertices of the
; diamond.  At any given pixel row y of the line, we light those
; pixels whose centers are between the left and right edges.
;
; Let mL(n) denote the line representing the left edge of the drag
; region.  On pixel row j, the column of the first pixel to be
; lit is
;
;       iL(j) = ceiling( mL(j * F) / F)
;
; Since the line's slope is less than one:
;
;       iL(j) = ceiling( mL([j + 1/2] F) / F )
;
; Recall the formula for our line:
;
;       n(m) = (dN / dM) (m - M0) + N0
;
;       m(n) = (dM / dN) (n - N0) + M0
;
; Since the line's slope is less than one, the line representing
; the left edge of the drag region is the original line offset
; by 1/2 pixel in the y direction:
;
;       mL(n) = (dM / dN) (n - F/2 - N0) + M0
;
; From this we can figure out the column of the first pixel that
; will be lit on row j, being careful of rounding (if the left
; edge lands exactly on an integer point, the pixel at that
; point is not lit because of our rounding convention):
;
;       iL(j) = floor( mL(j F) / F ) + 1
;
;             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
;
;             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
;
;                      F dM j - [ dM (N0 + F/2) - dN M0 ]
;             = floor( ---------------------------------- ) + 1
;                                   F dN
;
;                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
;             = floor( ------------------------------------ ) + 1       (1)
;                                     dN
;
;             = floor( (dM j + alpha) / dN ) + 1
;
; where
;
;       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
;
; We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
; pixels in row j.  Because we are always calculating iL(j) for
; integer quantities of j, we note that the only fractional term
; is constant, and so we can 'throw away' the fractional bits of
; alpha:
;
;       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
;
; so
;
;       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
;
; for integers j.
;
; Note if iR(j) is the line's rightmost pixel on row j, that
; iR(j) = iL(j + 1) - 1.
;
; Similarly, rewriting equation (1) as a function of column i,
; we can determine, given column i, on which pixel row j is the line
; lit:
;
;                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
;       j(i) = ceiling( ------------------------------------ ) - 1
;                                       dM
;
; Floors are easier to compute, so we can rewrite this:
;
;                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
;       j(i) = floor( ----------------------------------------------- ) - 1
;                                       dM
;
;                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
;            = floor( ---------------------------------------------------- )
;                                       dM
;
;                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
;            = floor( ---------------------------------------- )
;                                       dM
;
; We can once again wave our hands and throw away the fractional bits
; of the remainder term:
;
;       j(i) = floor( (dN i + gamma) / dM )                             (4)
;
; where
;
;       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
;
; We now note that
;
;       beta = -gamma - 1 = ~gamma                                      (6)
;
; To draw the pixels of the line, we could evaluate (3) on every scan
; line to determine where the strip starts.  Of course, we don't want
; to do that because that would involve a multiply and divide for every
; scan.  So we do everything incrementally.
;
; We would like to easily compute c , the number of pixels on scan j:
;                                  j
;
;    c  = iL(j + 1) - iL(j)
;     j
;
;       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
;
; This may be rewritten as
;
;    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
;     j          j+1    j+1                j    j
;
; where i , i    are integers and r  < dN, r    < dN.
;        j   j+1                   j        j+1
;
; Rewriting (7) again:
;
;    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
;     j          j    j                          j    j
;
;
;       = floor((r  + dM) / dN) - floor(r  / dN)
;                 j                      j
;
; This may be rewritten as
;
;    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
;     j                j                      j
;
; where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
;
; r  is the remainder (or "error") term in the DDA loop: r  / dN
;  j                                                      j
; is the exact fraction of a pixel at which the strip ends.  To go
; on to the next scan and compute c    we need to know r   .
;                                  j+1                  j+1
;
; So in the main loop of the DDA:
;
;    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
;     j                j                  j+1     j
;
; and we know r  < dN, r    < dN, and dR < dN.
;              j        j+1
;
; We have derived the DDA only for lines in the first octant; to
; handle other octants we do the common trick of flipping the line
; to the first octant by first making the line left-to-right by
; exchanging the end-points, then flipping about the lines y = 0 and
; y = x, as necessary.  We must record the transformation so we can
; undo them later.
;
; We must also be careful of how the flips affect our rounding.  If
; to get the line to the first octant we flipped about x = 0, we now
; have to be careful to round a y value of 1/2 up instead of down as
; we would for a line originally in the first octant (recall that
; "In the case where two pels are equidistant, the upper or left
; pel is illuminated...").
;
; To account for this rounding when running the DDA, we shift the line
; (or not) in the y direction by the smallest amount possible.  That
; takes care of rounding for the DDA, but we still have to be careful
; about the rounding when determining the first and last pixels to be
; lit in the line.
;
; Determining The First And Last Pixels In The Line
; -------------------------------------------------
;
; Fractional coordinates also make it harder to determine which pixels
; will be the first and last ones in the line.  We've already taken
; the fractional coordinates into account in calculating the DDA, but
; the DDA cannot tell us which are the end pixels because it is quite
; happy to calculate pixels on the line from minus infinity to positive
; infinity.
;
; The diamond rule determines the start and end pixels.  (Recall that
; the sides are exclusive except for the left and top vertices.)
; This convention can be thought of in another way: there are diamonds
; around the pixels, and wherever the true line crosses a diamond,
; that pel is illuminated.
;
; Consider a line where we've done the flips to the first octant, and the
; floor of the start coordinates is the origin:
;
;        +-----------------------> +x
;        |
;        | 0                     1
;        |     0123456789abcdef
;        |
;        |   0 00000000?1111111
;        |   1 00000000 1111111
;        |   2 0000000   111111
;        |   3 000000     11111
;        |   4 00000    ** 1111
;        |   5 0000       ****1
;        |   6 000           1***
;        |   7 00             1  ****
;        |   8 ?                     ***
;        |   9 22             3         ****
;        |   a 222           33             ***
;        |   b 2222         333                ****
;        |   c 22222       3333                    **
;        |   d 222222     33333
;        |   e 2222222   333333
;        |   f 22222222 3333333
;        |
;        | 2                     3
;        v
;        +y
;
; If the start of the line lands on the diamond around pixel 0 (shown by
; the '0' region here), pixel 0 is the first pel in the line.  The same
; is true for the other pels.
;
; A little more work has to be done if the line starts in the
; 'nether-land' between the diamonds (as illustrated by the '*' line):
; the first pel lit is the first diamond crossed by the line (pixel 1 in
; our example).  This calculation is determined by the DDA or slope of
; the line.
;
; If the line starts exactly half way between two adjacent pixels
; (denoted here by the '?' spots), the first pixel is determined by our
; round-down convention (and is dependent on the flips done to
; normalize the line).
;
; Last Pel Exclusive
; ------------------
;
; To eliminate repeatedly lit pels between continuous connected lines,
; we employ a last-pel exclusive convention: if the line ends exactly on
; the diamond around a pel, that pel is not lit.  (This eliminates the
; checks we had in the old code to see if we were re-lighting pels.)
;
; The Half Flip
; -------------
;
; To make our run length algorithm more efficient, we employ a "half
; flip".  If after normalizing to the first octant, the slope is more
; than 1/2, we subtract the y coordinate from the x coordinate.  This
; has the effect of reflecting the coordinates through the line of slope
; 1/2.  Note that the diagonal gets mapped into the x-axis after a half
; flip.
;
; How Many Bits Do We Need, Anyway?
; ---------------------------------
;
; Note that if the line is visible on your screen, you must light up
; exactly the correct pixels, no matter where in the 28.4 x 28.4 device
; space the end points of the line lie (meaning you must handle 32 bit
; DDAs, you can certainly have optimized cases for lesser DDAs).
;
; We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
; calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
; are in the first octant, so dM >= dN.  Then we know that gamma can
; be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
; valid lines will have dM and dN values at most 31 bits (unsigned)
; of significance.  So gamma requires 33 bits of significance (we store
; this as a 64 bit number for convenience).
;
; When running through the DDA loop, r  + dR can have a value in the
;                                     j
; range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
;             j
;
; Testing Lines
; -------------
;
; To be NT compliant, a display driver must exactly adhere to GIQ,
; which means that for any given line, the driver must light exactly
; the same pels as does GDI.  This can be tested using the Guiman tool
; provided elsewhere in the DDK, and 'ZTest', which draws random lines
; on the screen and to a bitmap, and compares the results.
;
; If You've Got Line Hardware
; ---------------------------
;
; If your hardware already adheres to GIQ, you're all set.  Otherwise
; you'll want to look at the S3 sample code and read the following:
;
; 1) You'll want to special case integer-only lines, since they require
;    less processing time and are more common (CAD programs will probably
;    only ever give integer lines).  GDI does not provide a flag saying
;    that all lines in a path are integer lines; consequently, you will
;    have to explicitly check every line.
;
; 2) You are required to correctly draw any line in the 28.4 device
;    space that intersects the viewport.  If you have less than 32 bits
;    of significance in the hardware for the Bresenham terms, extremely
;    long lines would overflow the hardware.  For such (rare) cases, you
;    can fall back to strip-drawing code, of which there is a C version in
;    the S3's lines.cxx (or if your display is a frame buffer, fall back
;    to the engine).
;
; 3) If you can explicitly set the Bresenham terms in your hardware, you
;    can draw non-integer lines using the hardware.  If your hardware has
;    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
;    pels long (4 bits are required for the fractional part, and one bit is
;    used as a sign bit).  Note that integer lines don't require the 4
;    fractional bits, so if you special case them as in 1), you can do
;    integer lines that are up to 2^(n - 1) pels long.  See the S3's
;    fastline.asm for an example.
;
;-----------------------------------------------------------------------;

cProc   bLines,36,< \
    uses esi edi ebx,  \
    pdsurf:     ptr,   \
    pptfxFirst: ptr,   \
    pptfxBuf:   ptr,   \
    prun:       ptr,   \
    cptfx:      dword, \
    pls:        ptr,   \
    prclClip:   ptr,   \
    apfn:       ptr,   \
    flStart:    dword  >

; pdsurf:     Surface data
; pptfxFirst: Start point of first line
; pptfxBuf:   All subsequent points
; prun:       Array of runs if doing complex clipping
; cptfx:      Number of points in pptfxBuf (i.e., # lines)
; pls:        Line state
; prclClip:   Clip rectangle if doing simple clipping
; apfn:       Pointer to table of strip drawers
; flStart:    Flags for all lines

        local cPelsAfterThisBank:    dword ; For bank switching
        local cStripsInNextRun:      dword ; For bank switching
        local pptfxBufEnd:           ptr   ; Last point in pptfxBuf
        local M0:                    dword ; Normalized x0 in device coords
        local dM:                    dword ; Delta-x in device coords
        local N0:                    dword ; Normalized y0 in device coords
        local dN:                    dword ; Delta-y in device coords
        local fl:                    dword ; Flags for current line
        local x:                     dword ; Normalized start pixel x-coord
        local y:                     dword ; Normalized start pixel y-coord
        local eqGamma_lo:            dword ; Upper 32 bits of Gamma
        local eqGamma_hi:            dword ; Lower 32 bits of Gamma
        local x0:                    dword ; Start pixel x-offset
        local y0:                    dword ; Start pixel y-offset
        local ulSlopeOneAdjustment:  dword ; Special offset if line of slope 1
        local cStylePels:            dword ; # of pixels in line (before clip)
        local xStart:                dword ; Start pixel x-offset before clip
        local pfn:                   ptr   ; Pointer to strip drawing function
        local cPels:                 dword ; # pixels to be drawn (after clip)
        local i:                     dword ; # pixels in strip
        local r:                     dword ; Remainder (or "error") term
        local d_I:                   dword ; Delta-I
        local d_R:                   dword ; Delta-R
        local plStripEnd:            ptr   ; Last strip in buffer
        local ptlStart[size POINTL]: byte  ; Unnormalized start coord
        local dN_Original:           dword ; dN before half-flip
        local xClipLeft:             dword ; Left side of clip rectangle
        local xClipRight:            dword ; Right side of clip rectangle
        local strip[size STRIPS]:    byte  ; Our strip buffer

; Do some initializing:

        mov     ecx, cptfx
        mov     edx, pptfxBuf
        lea     eax, [edx + ecx * (size POINTL) - (size POINTL)]
        mov     pptfxBufEnd, eax        ; pptfxBufEnd is inclusive of end point

        mov     eax, [edx].ptl_x        ; Load up end point (M1, N1)
        mov     edi, [edx].ptl_y

        mov     edx, pptfxFirst         ; Load up start point (M0, N0)
        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y

        mov     ebx, flStart

;-----------------------------------------------------------------------;
; Flip to the first octant.                                             ;
;-----------------------------------------------------------------------;

; Register state:       esi = M0
;                       ecx = N0
;                       eax = dM (M1)
;                       edi = dN (N1)
;                       ebx = fl

; Make sure we go left to right:

the_main_loop:
        cmp     esi, eax
        jle     short is_left_to_right  ; skip if M0 <= M1
        xchg    esi, eax                ; swap M0, M1
        xchg    ecx, edi                ; swap N0, N1
        or      ebx, FL_FLIP_H

is_left_to_right:

; Compute the deltas, remembering that the DDI says we should get
; deltas less than 2^31.  If we get more, we ensure we don't crash
; later on by simply skipping the line:

        sub     eax, esi                ; eax = dM
        jo      next_line               ; dM must be less than 2^31
        sub     edi, ecx                ; edi = dN
        jo      next_line               ; dN must be less than 2^31

        jge     short is_top_to_bottom  ; skip if dN >= 0
        neg     ecx                     ; N0 = -N0
        neg     edi                     ; N1 = -N1
        or      ebx, FL_FLIP_V

is_top_to_bottom:
        cmp     edi, eax
        jb      short done_flips        ; skip if dN < dM
        jne     short slope_more_than_one

; We must special case slopes of one (because of our rounding convention):

        or      ebx, FL_FLIP_SLOPE_ONE
        jmp     short done_flips

slope_more_than_one:
        xchg    eax, edi                ; swap dM, dN
        xchg    esi, ecx                ; swap M0, N0
        or      ebx, FL_FLIP_D

done_flips:

        mov     edx, ebx
        and     edx, FL_ROUND_MASK
        .errnz  FL_ROUND_SHIFT - 2
        or      ebx, [gaflRoundTable + edx]  ; get our rounding flags

        mov     dM, eax                 ; save some info
        mov     dN, edi
        mov     fl, ebx

; We're going to shift our origin so that it's at the closest integer
; coordinate to the left/above our fractional start point (it makes
; the math quicker):

        mov     edx, esi                ; x = LFLOOR(M0)
        sar     edx, FLOG2
        mov     x, edx

        mov     edx, ecx                ; y = LFLOOR(N0)
        sar     edx, FLOG2
        mov     y, edx

;-----------------------------------------------------------------------;
; Compute the fractional remainder term                                 ;
;-----------------------------------------------------------------------;

; By shifting the origin we've contrived to eliminate the integer
; portion of our fractional start point, giving us start point
; fractional coordinates in the range [0, F - 1]:

        and     esi, F - 1              ; M0 = FXFRAC(M0)
        and     ecx, F - 1              ; N0 = FXFRAC(N0)

; We now compute Gamma:

        mov     M0, esi                 ; save M0, N0 for later
        mov     N0, ecx

        lea     edx, [ecx + F/2]
        mul     edx                     ; [edx:eax] = dM * (N0 + F/2)
        xchg    eax, edi
        mov     ecx, edx                ; [ecx:edi] = dM * (N0 + F/2)
                                        ; (we just nuked N0)

        mul     esi                     ; [edx:eax] = dN * M0

; Now gamma = dM * (N0 + F/2) - dN * M0 - bRoundDown

        .errnz  FL_V_ROUND_DOWN - 8000h
        ror     bh, 8
        sbb     edi, eax
        sbb     ecx, edx

        shrd    edi, ecx, FLOG2
        sar     ecx, FLOG2              ; gamma = [ecx:edi] >>= 4

        mov     eqGamma_hi, ecx
        mov     eqGamma_lo, edi

        mov     eax, N0

; Register state:
;                       eax = N0
;                       ebx = fl
;                       ecx = eqGamma_hi
;                       edx = garbage
;                       esi = M0
;                       edi = eqGamma_lo

        testb   ebx, FL_FLIP_H
        jnz     line_runs_right_to_left

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a left-to-right line.      ;
;                               -------->                               ;
;-----------------------------------------------------------------------;

        public line_runs_left_to_right
line_runs_left_to_right::
        or      esi, esi
        jz      short LtoR_check_slope_one
                                        ; skip ahead if M0 == 0
                                        ;   (in that case, x0 = 0 which is to be
                                        ;   kept in esi, and is already
                                        ;   conventiently zero)

        or      eax, eax
        jnz     short LtoR_N0_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2
        jmp     short LtoR_check_slope_one
                                        ; esi = x0 = rounded M0

LtoR_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     esi, eax
        sbb     esi, esi
        inc     esi                     ; esi = x0 = (abs(N0 - F/2) <= M0)

        public  LtoR_check_slope_one
LtoR_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        jne     short LtoR_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;       if (M1 > 0) AMD (N1 == M1 + 8)
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1

        mov     edx, M0
        add     edx, dM
        and     edx, F - 1              ; edx = M1

        jz      short LtoR_slope_one_check_start_point

        add     edx, F/2                ; M1 + 8
        cmp     edx, eax                ; cmp N1, M1 + 8
        jne     short LtoR_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, -1

LtoR_slope_one_check_start_point:

        ;
        ;       if (M0 > 0) AMD (N0 == M0 + 8)
        ;

        mov     eax, M0
        or      eax, eax
        jz      short LtoR_compute_y0_from_x0

        add     eax, F/2
        cmp     eax, N0                 ; cmp M0 + 8, N0
        jne     short LtoR_compute_y0_from_x0

        xor     esi, esi                ; x0 = 0

LtoR_compute_y0_from_x0:

; ecx = eqGamma_hi
; esi = x0
; edi = eqGamma_lo

        mov     eax, dN
        mov     edx, dM

        mov     x0, esi
        mov     y0, 0
        cmp     ecx, 0
        jl      short LtoR_compute_x1

        neg     esi
        and     esi, eax
        sub     edx, esi
        cmp     edi, edx
        mov     edx, dM
        jb      short LtoR_compute_x1   ; Bug fix: Must be unsigned!
        mov     y0, 1                   ; y0 = floor((dN * x0 + eqGamma) / dM)

LtoR_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2
        dec     esi                     ; x1 = ((M0 + dM) >> 4) - 1
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15
        jz      done_first_pel_last_pel

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short LtoR_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

LtoR_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     eax, ecx
        jg      done_first_pel_last_pel
        inc     esi
        jmp     done_first_pel_last_pel

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a right-to-left line.      ;
;                               <--------                               ;
;-----------------------------------------------------------------------;

; Compute x0:

        public  line_runs_right_to_left
line_runs_right_to_left::
        mov     x0, 1                   ; x0 = 1
        or      eax, eax
        jnz     short RtoL_N0_not_zero

        xor     edx, edx                ; ulDelta = 0
        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2              ; esi = LROUND(M0, fl & FL_H_ROUND_DOWN)
        jz      short RtoL_check_slope_one

        mov     x0, 2
        mov     edx, dN
        jmp     short RtoL_check_slope_one

RtoL_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, esi                ; eax = ABS(N0 - F/2) + M0
        xor     edx, edx                ; ulDelta = 0
        cmp     eax, F
        jle     short RtoL_check_slope_one

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

        public  RtoL_check_slope_one
RtoL_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE
        jne     short RtoL_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;  if ((N1 > 0) && (M1 == N1 + 8))
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1
        jz      short RtoL_slope_one_check_start_point

        mov     esi, M0
        add     esi, dM
        and     esi, F - 1              ; esi = M1

        add     eax, F/2                ; N1 + 8
        cmp     esi, eax                ; cmp M1, N1 + 8
        jne     short RtoL_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, 1

RtoL_slope_one_check_start_point:

        ;
        ;  if ((N0 > 0) && (M0 == N0 + 8))
        ;

        mov     eax,N0                  ; eax = N0
        or      eax,eax                 ; check for N0 == 0
        jz      short RtoL_compute_y0_from_x0

        mov     esi, M0                 ; esi = M0

        add     eax, F/2                ; N0 + 8
        cmp     eax, esi                ; cmp M0 , N0 + 8
        jne     short RtoL_compute_y0_from_x0

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

RtoL_compute_y0_from_x0:

; eax = garbage
; ebx = fl
; ecx = eqGamma_hi
; edx = ulDelta
; esi = garbage
; edi = eqGamma_lo

        mov     eax, dN                 ; eax = dN
        mov     y0, 0                   ; y0 = 0

        add     edi, edx
        adc     ecx, 0                  ; eqGamma += ulDelta
                                        ; NOTE: Setting flags here!
        mov     edx, dM                 ; edx = dM
        jl      short RtoL_compute_x1   ; NOTE: Looking at the flags here!
        jg      short RtoL_y0_is_2

        lea     ecx, [edx + edx]
        sub     ecx, eax                ; ecx = 2 * dM - dN
        cmp     edi, ecx
        jae     short RtoL_y0_is_2      ; Bug fix: Must be unsigned!

        sub     ecx, edx                ; ecx = dM - dN
        cmp     edi, ecx
        jb      short RtoL_compute_x1   ; Bug fix: Must be unsigned!

        mov     y0, 1
        jmp     short RtoL_compute_x1

RtoL_y0_is_2:
        mov     y0, 2

RtoL_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2              ; x1 = (M0 + dM) >> 4
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short RtoL_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

RtoL_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, ecx                ; eax = ABS(N1 - F/2) + M1
        cmp     eax, F+1
        sbb     esi, -1

done_first_pel_last_pel:

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = garbage
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

        mov     ecx, x0
        lea     edx, [esi + 1]
        sub     edx, ecx                ; edx = x1 - x0 + 1

        jle     next_line
        mov     cStylePels, edx
        mov     xStart, ecx

;-----------------------------------------------------------------------;
; See if clipping or styling needs to be done.                          ;
;-----------------------------------------------------------------------;

        testb   ebx, FL_CLIP
        jnz     do_some_clipping

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = x0        (stack variable correct too)
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

done_clipping:
        mov     eax, y0

        sub     esi, ecx
        inc     esi                     ; esi = cPels = x1 - x0 + 1
        mov     cPels, esi

        mov     esi, pdsurf
        add     ecx, x                  ; ecx = ptlStart.ptl_x
        add     eax, y                  ; eax = ptlStart.ptl_y

        mov     esi, [esi].dsurf_lNextScan ; we'll compute the sign of lNextScan

        testb   ebx, FL_FLIP_D
        jz      short do_v_unflip
        xchg    ecx, eax

do_v_unflip:
        testb   ebx, FL_FLIP_V
        jz      short done_unflips
        neg     eax
        neg     esi

done_unflips:
        mov     strip.ST_lNextScan, esi ; lNextScan now right for y-direction
        testb   ebx, FL_STYLED
        jnz     do_some_styling

done_styling:
        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

        mov     cPelsAfterThisBank, 0
        mov     cStripsInNextRun, 7fffffffh

        testb   ebx, FL_PHYSICAL_DEVICE
        jz      done_bank_setup

;-----------------------------------------------------------------------;
; Do banking setup.                                                     ;
;-----------------------------------------------------------------------;

        public  bank_setup
bank_setup::

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     esi, pdsurf
        cmp     eax, [esi].dsurf_rcl1WindowClip.yTop
        jl      short bank_get_initial_bank   ; ptlStart.y < rcl1WindowClip.yTop

        cmp     eax, [esi].dsurf_rcl1WindowClip.yBottom
        jl      short bank_got_initial_bank   ; ptlStart.y < rcl1WindowClip.yBot

bank_get_initial_bank:
        mov     ptlStart.ptl_y, eax     ; Save ptlStart.ptl_y
        mov     edi, ecx                ; Save ptlStart.ptl_x

        .errnz  JustifyTop
        .errnz  JustifyBottom - 1
        .errnz  FL_FLIP_V - 8

        mov     ecx, ebx                ; JustifyTop if line goes down,
        shr     ecx, 3                  ; JustifyBottom if line goes up
        and     ecx, 1

bank_justified:
        ptrCall <dword ptr [esi].dsurf_pfnBankControl>, \
                <esi, eax, ecx>

        mov     eax, ptlStart.ptl_y
        mov     ecx, edi

bank_got_initial_bank:
        testb   ebx, FL_FLIP_D
        jz      short bank_major_x

bank_major_y:
        testb   ebx, FL_FLIP_V
        jz      short bank_major_y_down
bank_major_y_up:
        lea     edi, [eax + 1]
        sub     edi, [esi].dsurf_rcl1WindowClip.yTop
        jmp     short bank_done_y_major
bank_major_y_down:
        mov     edi, [esi].dsurf_rcl1WindowClip.yBottom
        sub     edi, eax
bank_done_y_major:
        mov     esi, cPels
        sub     esi, edi                ; edi = cPelsInBank
        mov     cPelsAfterThisBank, esi
        jle     short done_bank_setup
        mov     cPels, edi
        jmp     short done_bank_setup

bank_major_x:
        mov     edi, dN
        shr     edi, FLOG2
        add     edi, y

; We're guessing at the y-position of the end pixel (it's too much work
; to compute the actual value) to see if the line spans more than one
; bank.  We have to add at least a slop value of '3' because the actual
; start pixel may be may 2 off from 'y' because of end-pixel exclusiveness,
; and we have to add 1 more because we're taking the floor of (dN / F), to
; account for rounding:

        add     edi, 3                  ; yEnd = edi = y + LFLOOR(dN) + 3
        testb   ebx, FL_FLIP_V
        jz      short bank_major_x_down
bank_major_x_up:
        mov     edx, 1
        sub     edx, [esi].dsurf_rcl1WindowClip.yTop    ; edx = -yNextBankStart

        cmp     edi, edx
        lea     edx, [edx + eax]        ; edx = cStripsInNextRun
        jl      short bank_major_x_done

; Line may go over bank boundary, so don't do a half flip:

        or      ebx, FL_DONT_DO_HALF_FLIP
        jmp     short bank_major_x_done

bank_major_x_down:
        mov     esi, [esi].dsurf_rcl1WindowClip.yBottom  ; esi = yNextBankStart

        mov     edx, esi
        sub     edx, eax                ; edx = cStripsInNextRun

        cmp     edi, esi
        jl      short bank_major_x_done
        or      ebx, FL_DONT_DO_HALF_FLIP

bank_major_x_done:
        sub     edx, STRIP_MAX
        mov     cStripsInNextRun, edx
        jge     short done_bank_setup

        lea     edx, [strip.ST_alStrips + edx * 4 + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

done_bank_setup:

;-----------------------------------------------------------------------;
; Setup to do DDA.                                                      ;
;-----------------------------------------------------------------------;

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     edx, 80h
        ror     dl, cl
        mov     strip.ST_jBitMask, dl   ; ST_jBitMask =
                                        ;     (0x80 >> (ptlStart.ptl_x & 0x7))

        mov     esi, pdsurf
        mov     edi, eax                ; Now edi = ptlStart.ptl_y
        imul    [esi].dsurf_lNextScan
        add     eax, [esi].dsurf_pvBitmapStart
        sar     ecx, 3
        add     eax, ecx
        mov     strip.ST_pjScreen, eax  ; ST_pjScreen = pchBits + ptlStart.ptl_y *
                                        ;     cjDelta + (ptlStart.ptl_x >> 3)

        mov     eax, dM
        mov     ecx, dN
        mov     esi, eqGamma_lo
        mov     edi, eqGamma_hi

; Register state:
;                       eax = dM
;                       ebx = fl
;                       ecx = dN
;                       edx = garbage
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        lea     edx, [ecx + ecx]        ; if (2 * dN > dM)
        cmp     edx, eax
        mov     edx, y0                 ; Load y0 again
        jbe     short after_half_flip

        test    ebx, (FL_STYLED + FL_DONT_DO_HALF_FLIP)
        jnz     short after_half_flip

        or      ebx, FL_FLIP_HALF
        mov     fl, ebx

; Do a half flip!

        not     esi
        not     edi
        add     esi, eax
        adc     edi, 0                  ; eqGamma = -eqGamma - 1 + dM

        neg     ecx
        add     ecx, eax                ; dN = dM - dN

        neg     edx
        add     edx, x0                 ; y0 = x0 - y0

after_half_flip:
        mov     strip.ST_flFlips, ebx
        and     ebx, FL_STRIP_MASK

        .errnz  FL_STRIP_SHIFT
        mov     eax, apfn
        lea     eax, [eax + ebx * 4]
        mov     eax, [eax]
        mov     pfn, eax
        mov     eax, dM

; Register state:
;                       eax = dM
;                       ebx = garbage
;                       ecx = dN
;                       edx = y0
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        or      ecx, ecx
        jz      short zero_slope

compute_dda_stuff:
        inc     edx
        mul     edx
        stc                             ; set the carry to accomplish -1
        sbb     eax, esi
        sbb     edx, edi                ; (y0 + 1) * dM - eqGamma - 1
        div     ecx

        mov     esi, eax                ; esi = i
        mov     edi, edx                ; edi = r

        xor     edx, edx
        mov     eax, dM
        div     ecx                     ; edx = d_R, eax = d_I
        mov     d_I, eax

        sub     esi, x0
        inc     esi

done_dda_stuff:
        lea     eax, [strip.ST_alStrips]
        mov     ebx, cPels

;-----------------------------------------------------------------------;
; Do our main DDA loop.                                                 ;
;-----------------------------------------------------------------------;

        sub     edi, ecx                ; offset remainder term from [0..dN)
                                        ;   to [-dN..0) so test in inner
                                        ;   loop is quicker
        align   4

; Register state:
;                       eax = plStrip   ; current pointer into strip array
;                       ebx = cPels     ; total number of pels in line
;                       ecx = dN        ; delta-N = rise in line
;                       edx = d_R       ; d_I + d_R/dN = exact strip length
;                       esi = i         ; length of current strip
;                       edi = r         ; remainder term for current strip
;                                       ;   in range [-dN..0)

        public  dda_loop
dda_loop::
        sub     ebx, esi                ; subtract strip length from line length
        jle     final_strip             ; if negative, done with line

        mov     [eax], esi              ; write strip length to strip array
        add     eax, 4
        cmp     plStripEnd, eax         ; is the strip array buffer full?
        jbe     short output_strips     ; if so, empty it

; The output_strips routine jumps to here when done:

done_output_strips:
        mov     esi, d_I                ; our normal strip length
        add     edi, edx                ; adjust our remainder term
        jl      short dda_loop

        sub     edi, ecx                ; our remainder became 1 or more, so
        inc     esi                     ;   we increment this strip length
                                        ;   and adjust the remainder term

; We've unrolled our loop a bit, so this should look familiar to the above:

        sub     ebx, esi                ; subtract strip length from line length
        jle     final_strip             ; if negative, done with line

        mov     [eax], esi              ; write strip length to strip array
        add     eax, 4                  ; adjust strip pointer

; Note that banking requires us to check if the strip array is full here
; too (and note that if output_strips is called it will return to
; done_output_strips):

        cmp     plStripEnd, eax
        jbe     short output_strips

        mov     esi, d_I                ; our normal strip length
        add     edi, edx                ; adjust our remainder term
        jl      short dda_loop

        sub     edi, ecx                ; our remainder became 1 or more, so
        inc     esi                     ; adjust
        jmp     short dda_loop

zero_slope:
        mov     esi, 7fffffffh
        jmp     short done_dda_stuff

;-----------------------------------------------------------------------;
; Empty strips buffer & possibly do x-major bank switch.                ;
;-----------------------------------------------------------------------;

output_strips:
        mov     d_R, edx
        mov     cPels, ebx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx

        lea     edx, [strip]
        mov     ecx, pls

; Call our strip routine:

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

; It may be that we ran out of run in our strips buffer, and don't
; actually have to switch banks.  See if that's the case:

        mov     eax, cStripsInNextRun
        or      eax, eax
        jg      short done_strip_bank_switch

; We have to switch banks.  See if we're going up or down:

        mov     esi, pdsurf
        test    fl, FL_FLIP_V
        jz      short bank_x_down

bank_x_up:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].dsurf_pvBitmapStart
        mov     ebx, [esi].dsurf_rcl1WindowClip.yTop
        dec     ebx                     ; we want yTop - 1 to be mapped in

; Map in the next higher bank:

        ptrCall <dword ptr [esi].dsurf_pfnBankControl>, \
                <esi, ebx, JustifyBottom>; ebx, esi and edi are preserved

        lea     eax, [ebx + 1]
        sub     eax, [esi].dsurf_rcl1WindowClip.yTop
                                        ; eax = # of scans can do in bank

        add     edi, [esi].dsurf_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        jmp     short done_strip_bank_switch

bank_x_down:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].dsurf_pvBitmapStart
        mov     ebx, [esi].dsurf_rcl1WindowClip.yBottom

; Map in the next lower bank:

        ptrCall <dword ptr [esi].dsurf_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ; ebx, esi and edi are preserved

        mov     eax, [esi].dsurf_rcl1WindowClip.yBottom
        sub     eax, ebx                ; eax = # scans can do in bank

        add     edi, [esi].dsurf_pvBitmapStart
        mov     strip.ST_pjScreen,edi

done_strip_bank_switch:

; eax = cStripsInNextRun

        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        sub     eax, STRIP_MAX
        mov     cStripsInNextRun, eax
        jge     short get_ready_for_more_strips
        lea     edx, [edx + eax * 4]

get_ready_for_more_strips:
        mov     plStripEnd, edx

        mov     esi, i
        mov     edi, r
        mov     ebx, cPels
        mov     edx, d_R
        mov     ecx, dN
        lea     eax, [strip.ST_alStrips]
        jmp     done_output_strips

;-----------------------------------------------------------------------;
; Empty strips buffer.  Either get new line or do y-major bank switch.  ;
;-----------------------------------------------------------------------;

final_strip:
        add     ebx, esi
        mov     [eax], ebx
        add     eax, 4

        cmp     cPelsAfterThisBank, 0
        jg      short bank_y_major

very_final_strip:
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

; NOTE: next_line is jumped to from various places, and it cannot assume
;       any registers are loaded.

next_line:
        mov     ebx, flStart
        testb   ebx, FL_COMPLEX_CLIP
        jnz     short see_if_done_complex_clipping

        mov     edx, pptfxBuf
        cmp     edx, pptfxBufEnd
        je      short all_done

        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y
        add     edx, size POINTL
        mov     pptfxBuf, edx
        mov     eax, [edx].ptl_x
        mov     edi, [edx].ptl_y
        jmp     the_main_loop

all_done:
        mov     eax, 1

        cRet    bLines

see_if_done_complex_clipping:
        mov     ebx, fl
        dec     cptfx
        jz      short all_done

        and     ebx, NOT FL_FLIP_HALF   ; Make sure the next run doesn't have
        mov     fl, ebx                 ;   to do a half-flip if it doesn't
                                        ;   want to
        jmp     continue_complex_clipping

;-----------------------------------------------------------------------;
; Switch banks for a y-major line.                                      ;
;-----------------------------------------------------------------------;

        public  bank_y_major
bank_y_major::
        mov     d_R, edx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx
        sub     ebx, esi                ; Undo our offset

bank_y_output_strips:
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

        mov     esi, pdsurf
        test    fl, FL_FLIP_V
        jz      short bank_y_down

bank_y_up:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].dsurf_pvBitmapStart
        mov     ecx, [esi].dsurf_rcl1WindowClip.yTop
        push    ecx
        dec     ecx                     ; we want yTop - 1 to be mapped in

; Map in the next higher bank:

        ptrCall <dword ptr [esi].dsurf_pfnBankControl>, \
                <esi, ecx, JustifyBottom>; ebx, esi and edi are preserved

        pop     ecx
        sub     ecx, [esi].dsurf_rcl1WindowClip.yTop
                                        ; ecx = # of scans can do in bank

        add     edi, [esi].dsurf_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        mov     edx, cPelsAfterThisBank                 ; edx = cPelsAfterBank
        lea     eax, [strip.ST_alStrips]                ; eax = plStrip
        or      ebx, ebx                                ; ebx = cPels
        jge     bank_y_done_partial_strip
        jmp     short bank_y_done_switch

bank_y_down:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].dsurf_pvBitmapStart
        mov     ecx, [esi].dsurf_rcl1WindowClip.yBottom
        push    ecx

; Map in the next lower bank:

        ptrCall <dword ptr [esi].dsurf_pfnBankControl>, \
                <esi, ecx, JustifyTop>  ; ebx, esi and edi are preserved

        pop     eax
        mov     ecx, [esi].dsurf_rcl1WindowClip.yBottom
        sub     ecx, eax                ; ecx = # scans can do in bank

        add     edi, [esi].dsurf_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        mov     edx, cPelsAfterThisBank                 ; edx = cPelsAfterBank
        lea     eax, [strip.ST_alStrips]                ; eax = plStrip
        or      ebx, ebx                                ; ebx = cPels
        jge     short bank_y_done_partial_strip

bank_y_done_switch:

; Handle a single strip stretching over multiple banks:

        test    fl, FL_FLIP_HALF
        jz      short bank_y_no_half_flip

; We now have to adjust for the fact that the strip drawers always leave
; the state ready for the next new strip (e.g., if we're doing vertical
; strips, it advances pjScreen one to the right after drawing each strip).
; But the problem is that since we crossed a bank, we have to continue the
; *old* strip, so we have to undo that advance:

bank_y_half_flip:
        ror     strip.ST_jStyleMask, 1
        ror     strip.ST_jBitMask, 1
        adc     strip.ST_pjScreen, 0
        jmp     short bank_y_done_bit_adjust

bank_y_no_half_flip:
        rol     strip.ST_jStyleMask, 1
        rol     strip.ST_jBitMask, 1
        sbb     strip.ST_pjScreen, 0

bank_y_done_bit_adjust:
        mov     esi, ebx
        neg     esi                             ; esi = # pels left in strip

; eax = pointer to first strip entry
; ebx = negative esi
; ecx = # of pels we can put down in this window
; edx = # of pels remaining to do in line
; esi = # of pels left in strip

; We have three special cases to check here:
;
;       1) If the strip spans the entire next window
;       2) This is the last strip in the line
;       3) Neither of the above

        cmp     edx,ecx                         ;if line shorter than bank,
        jle     short bank_y_check_if_last_strip;  know strip doesn't span bank

        cmp     esi,ecx                         ;if line spans bank, don't have
        jl      short bank_y_continue_strip     ;  to check if last strip

; If ((# of pels in line > window size) && (# of pels in strip > window size))
; then the strip spans this bank:

        mov     [eax], ecx
        add     eax, 4
        add     ebx, ecx
        sub     edx, ecx
        mov     cPelsAfterThisBank, edx
        jmp     bank_y_output_strips

bank_y_check_if_last_strip:
        cmp     esi, edx                        ;if strip is shorter than line,
        jl      short bank_y_continue_strip     ;  we know this isn't the last
                                                ;  strip

; Handle case where this is the last strip in the line and it overlaps a bank:

        mov     [eax], edx
        add     eax, 4
        jmp     very_final_strip

bank_y_continue_strip:
        mov     [eax], esi
        add     eax, 4

bank_y_done_partial_strip:
        add     ebx, edx                ; cPels += cPelsAfterThisBank
        sub     edx, ecx                ; cPelsAfterThisBank -= cyWindow

        jle     short bank_y_get_ready
        sub     ebx, edx

bank_y_get_ready:
        mov     cPelsAfterThisBank, edx
        mov     edi, r
        mov     edx, d_R
        mov     ecx, dN
        jmp     done_output_strips

;---------------------------Private-Routine-----------------------------;
; do_some_styling
;
; Inputs:
;       eax = ptlStart.ptl_y
;       ebx = fl
;       ecx = ptlStart.ptl_x
; Preserves:
;       eax, ebx, ecx
; Output:
;       Exits to done_styling.
;
;-----------------------------------------------------------------------;

        public  do_some_styling
do_some_styling::
        mov     esi, pls
        mov     ptlStart.ptl_x, ecx

        mov     edi, [esi].LS_spNext    ; spThis
        mov     edx, edi
        add     edx, cStylePels         ; spNext

        testb   ebx, FL_ALTERNATESTYLED
        jz      short do_non_alternate_style

; Do alternate styles:

        and     edx, 1
        mov     [esi].LS_spNext, edx
        testb   ebx, FL_FLIP_H
        jz      short alternate_left_to_right

        add     ecx, edx
        sub     ecx, x0
        add     ecx, xStart             ; ptlStart.x + spNext - x0 + xStart + 1
        inc     ecx
        jmp     short compute_alternate_mask

alternate_left_to_right:
        add     ecx, edi
        add     ecx, x0
        sub     ecx, xStart             ; ptlStart.x + spThis + x0 - xStart

compute_alternate_mask:
        mov     strip.ST_jStyleMask, 55h
        ror     strip.ST_jStyleMask, cl

        mov     strip.ST_spRemaining, 1
        mov     strip.ST_xyDensity, 1
        mov     ecx, ptlStart.ptl_x
        jmp     done_styling

do_non_alternate_style:

; For styles, we don't bother to keep the style position normalized.
; (we do ensure that it's positive, though).  If a figure is over 2
; billion pels long, we'll be a pel off in our style state (oops!).

        and     edx, 7fffffffh
        mov     [esi].LS_spNext, edx
        mov     ptlStart.ptl_y, eax
        testb   ebx, FL_MASKSTYLED
        jz      short do_arbitrary_style

; Do mask styles:

        mov     eax, [esi].LS_xyDensity         ; Gotta copy to strips struct
        mov     strip.ST_xyDensity, eax

        testb   ebx, FL_FLIP_H
        jz      short mask_left_to_right

        sub     edx, x0
        add     edx, xStart
        add     edx, 2
        mov     eax, edx
        xor     edx, edx

        mov     edi, STYLE_DENSITY
        div     edi
        add     ecx, eax
        inc     edx
        mov     eax, [esi].LS_ulStyleMaskRtoL
        jmp     short compute_masked_mask

mask_left_to_right:
        add     edi, x0
        sub     edi, xStart
        mov     eax, edi
        xor     edx, edx
        mov     edi, STYLE_DENSITY
        div     edi
        sub     ecx, eax
        neg     edx
        add     edx, STYLE_DENSITY
        mov     eax, [esi].LS_ulStyleMaskLtoR

compute_masked_mask:
        mov     strip.ST_spRemaining, edx
        ror     al, cl
        mov     strip.ST_jStyleMask, al
        mov     eax, ptlStart.ptl_y
        mov     ecx, ptlStart.ptl_x
        jmp     done_styling

; Do arbitrary styles:

do_arbitrary_style:
        testb   ebx, FL_FLIP_H
        jz      short arbitrary_left_to_right

        sub     edx, x0
        add     edx, xStart
        mov     eax, edx
        xor     edx, edx
        div     [esi].LS_spTotal

        neg     edx
        jge     short continue_right_to_left
        add     edx, [esi].LS_spTotal
        not     eax

continue_right_to_left:
        mov     edi, dword ptr [esi].LS_jStartMask
        not     edi
        mov     ecx, [esi].LS_aspRtoL
        jmp     short compute_arbitrary_stuff

arbitrary_left_to_right:
        add     edi, x0
        sub     edi, xStart
        mov     eax, edi
        xor     edx, edx
        div     [esi].LS_spTotal
        mov     edi, dword ptr [esi].LS_jStartMask
        mov     ecx, [esi].LS_aspLtoR

compute_arbitrary_stuff:
;       eax = sp / spTotal
;       ebx = fl
;       ecx = pspStart
;       edx = sp % spTotal
;       esi = pls
;       edi = jStyleMask

        and     eax, [esi].LS_cStyle        ; if odd length style and second run
        and     al, 1                       ; through style array, flip the
        jz      short odd_style_array_done  ; meaning of the elements
        not     edi

odd_style_array_done:
        mov     eax, [esi].LS_cStyle
        mov     strip.ST_pspStart, ecx
        lea     eax, [ecx + eax * 4 - 4]
        mov     strip.ST_pspEnd, eax

find_psp:
        sub     edx, [ecx]
        jl      short found_psp
        add     ecx, 4
        jmp     short find_psp

found_psp:
        mov     strip.ST_psp, ecx
        neg     edx
        mov     strip.ST_spRemaining, edx

        sub     ecx, strip.ST_pspStart
        test    ecx, 4                      ; size STYLEPOS
        jz      short done_arbitrary
        not     edi

done_arbitrary:
        mov     dword ptr strip.ST_jStyleMask, edi
        mov     eax, ptlStart.ptl_y
        mov     ecx, ptlStart.ptl_x
        jmp     done_styling

;---------------------------Private-Routine-----------------------------;
; do_some_clipping
;
; Inputs:
;       eax = garbage
;       ebx = fl
;       ecx = x0
;       edx = garbage
;       esi = x1
;       edi = garbage
;
; Decides whether to do simple or complex clipping.
;
;-----------------------------------------------------------------------;

        align 4

        public  do_some_clipping
do_some_clipping::
        testb   ebx, FL_COMPLEX_CLIP
        jnz     initialize_complex_clipping

;-----------------------------------------------------------------------;
; simple_clipping
;
; Inputs:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Output:
;       ebx = fl
;       ecx = new x0 (stack variable updated too)
;       esi = new x1
;       y0 stack variable updated
; Uses:
;       All registers
; Exits:
;       to done_clipping
;
; This routine handles clipping the line to the clip rectangle (it's
; faster to handle this case in the driver than to call the engine to
; clip for us).
;
; Fractional end-point lines complicate our lives a bit when doing
; clipping:
;
; 1) For styling, we must know the unclipped line's length in pels, so
;    that we can correctly update the styling state when the line is
;    clipped.  For this reason, I do clipping after doing the hard work
;    of figuring out which pixels are at the ends of the line (this is
;    wasted work if the line is not styled and is completely clipped,
;    but I think it's simpler this way).  Another reason is that we'll
;    have calculated eqGamma already, which we use for the intercept
;    calculations.
;
;    With the assumption that most lines will not be completely clipped
;    away, this strategy isn't too painful.
;
; 2) x0, y0 are not necessarily zero, where (x0, y0) is the start pel of
;    the line.
;
; 3) We know x0, y0 and x1, but not y1.  We haven't needed to calculate
;    y1 until now.  We'll need the actual value, and not an upper bound
;    like y1 = LFLOOR(dM) + 2 because we have to be careful when
;    calculating x(y) that y0 <= y <= y1, otherwise we can cause an
;    overflow on the divide (which, needless to say, is bad).
;
;-----------------------------------------------------------------------;

        public  simple_clipping
simple_clipping::
        mov     edi, prclClip           ; get pointer to normalized clip rect
        and     ebx, FL_RECTLCLIP_MASK  ;   (it's lower-right exclusive)

        .errnz  (FL_RECTLCLIP_SHIFT - 2); ((ebx AND FL_RECTLCLIP_MASK) shr
        .errnz  (size RECTL) - 16       ;   FL_RECTLCLIP_SHIFT) is our index
        lea     edi, [edi + ebx*4]      ;   into the array of rectangles

        mov     edx, [edi].xRight       ; load the rect coordinates
        mov     eax, [edi].xLeft
        mov     ebx, [edi].yBottom
        mov     edi, [edi].yTop

; Translate to our origin and so some quick completely clipped tests:

        sub     edx, x
        cmp     ecx, edx
        jge     totally_clipped         ; totally clipped if x0 >= xRight

        sub     eax, x
        cmp     esi, eax
        jl      totally_clipped         ; totally clipped if x1 < xLeft

        sub     ebx, y
        cmp     y0, ebx
        jge     totally_clipped         ; totally clipped if y0 >= yBottom

        sub     edi, y

; Save some state:

        mov     xClipRight, edx
        mov     xClipLeft, eax

        cmp     esi, edx                ; if (x1 >= xRight) x1 = xRight - 1
        jl      short calculate_y1
        lea     esi, [edx - 1]

calculate_y1:
        mov     eax, esi                ; y1 = (x1 * dN + eqGamma) / dM
        mul     dN
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     edi, eax                ; if (yTop > y1) clipped
        jg      short totally_clipped

        cmp     ebx, eax                ; if (yBottom > y1) know x1
        jg      short x1_computed

        mov     eax, ebx                ; x1 = (yBottom * dM + eqBeta) / dN
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        mov     esi, eax

; At this point, we've taken care of calculating the intercepts with the
; right and bottom edges.  Now we work on the left and top edges:

x1_computed:
        mov     edx, y0

        mov     eax, xClipLeft          ; don't have to compute y intercept
        cmp     eax, ecx                ;   at left edge if line starts to
        jle     short top_intercept     ;   right of left edge

        mov     ecx, eax                ; x0 = xLeft
        mul     dN                      ; y0 = (xLeft * dN + eqGamma) / dM
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     ebx, eax                ; if (yBottom <= y0) clipped
        jle     short totally_clipped

        mov     edx, eax
        mov     y0, eax

top_intercept:
        mov     ebx, fl                 ; get ready to leave
        mov     x0, ecx

        cmp     edi, edx                ; if (yTop <= y0) done clipping
        jle     done_clipping

        mov     eax, edi                ; x0 = (yTop * dM + eqBeta) / dN + 1
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        lea     ecx, [eax + 1]

        cmp     xClipRight, ecx         ; if (xRight <= x0) clipped
        jle     short totally_clipped

        mov     y0, edi                 ; y0 = yTop
        mov     x0, ecx
        jmp     done_clipping           ; all done!

totally_clipped:

; The line is completely clipped.  See if we have to update our style state:

        mov     ebx, fl
        testb   ebx, FL_STYLED
        jz      next_line

; Adjust our style state:

        mov     esi, pls
        mov     eax, [esi].LS_spNext
        add     eax, cStylePels
        mov     [esi].LS_spNext, eax

        cmp     eax, [esi].LS_spTotal2
        jb      next_line

; Have to normalize first:

        xor     edx, edx
        div     [esi].LS_spTotal2
        mov     [esi].LS_spNext, edx

        jmp     next_line

;-----------------------------------------------------------------------;

initialize_complex_clipping:
        mov     eax, dN                 ; save a copy of original dN
        mov     dN_Original, eax

;---------------------------Private-Routine-----------------------------;
; continue_complex_clipping
;
; Inputs:
;       ebx = fl
; Output:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Uses:
;       All registers.
; Exits:
;       to done_clipping
;
; This routine handles the necessary initialization for the next
; run in the CLIPLINE structure.
;
; NOTE: This routine is jumped to from two places!
;-----------------------------------------------------------------------;

        public  continue_complex_clipping
continue_complex_clipping::
        mov     edi, prun
        mov     ecx, xStart
        testb   ebx, FL_FLIP_H
        jz      short complex_left_to_right

complex_right_to_left:

; Figure out x0 and x1 for right-to-left lines:

        add     ecx, cStylePels
        dec     ecx
        mov     esi, ecx                ; esi = ecx = xStart + cStylePels - 1
        sub     ecx, [edi].RUN_iStop    ; New x0
        sub     esi, [edi].RUN_iStart   ; New x1
        jmp     short complex_reset_variables

complex_left_to_right:

; Figure out x0 and x1 for left-to-right lines:

        mov     esi, ecx                ; esi = ecx = xStart
        add     ecx, [edi].RUN_iStart   ; New x0
        add     esi, [edi].RUN_iStop    ; New x1

complex_reset_variables:
        mov     x0, ecx

; The half flip mucks with some of our variables, and we have to reset
; them every pass.  We would have to reset eqGamma too, but it never
; got saved to memory in its modified form.

        add     edi, size RUN
        mov     prun, edi               ; Increment run pointer for next time

        mov     edi, pls
        mov     eax, [edi].LS_spComplex
        mov     [edi].LS_spNext, eax    ; pls->spNext = pls->spComplex

        mov     eax, dN_Original        ; dN = dN_Original
        mov     dN, eax

        mul     ecx
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi         ; [edx:eax] = dN*x0 + eqGamma

        div     dM
        mov     y0, eax
        jmp     done_clipping

endProc bLines

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Functions to control 256 colour VGA banking.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"
#include "limits.h"

VOID vBankErrorTrap(PPDEV, ULONG, BANK_JUST);
VOID vBank2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vBank1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vBank1Window(PPDEV, ULONG, BANK_JUST);
VOID vPlanar2Window(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window2RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar2Window1RW(PPDEV, ULONG, BANK_JUST, ULONG);
VOID vPlanar1Window2RW(PPDEV, ULONG, BANK_JUST);
VOID vPlanar1Window(PPDEV, ULONG, BANK_JUST);

/******************************Public*Routine******************************\
* bInitializeNonPlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiBankInfo and ppdev->pjJustifyTopBank buffers!
\**************************************************************************/

BOOL bInitializeNonPlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;

    ULONG cjGranularity = pBankInfo->Granularity;
    LONG  lDelta        = pBankInfo->BitmapWidthInBytes;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize;

    ASSERTVGA(cjBitmapSize >= ppdev->cyScreen * lDelta, "Not enough vram");

    // Set up for non-planar banking:

    ppdev->lNextScan         = lDelta;
    ppdev->vbtBankingType    = pBankInfo->BankingType;

    ppdev->pfnBankSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->CodeOffset);

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    // Set up to call the appropriate banking control routines

    switch(pBankInfo->BankingType)
    {
    case VideoBanked1RW:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnBankControl        = vBank1Window;
        ppdev->pfnBankControl2Window = vBank2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnBankControl        = vBank1Window2RW;
        ppdev->pfnBankControl2Window = vBank2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulBank2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    // Set up the bank control tables with clip rects for banks
    // Note: lTotalBanks is generally an overestimate when granularity
    // is less than window size, because we ignore any banks after the
    // first one that includes the last scan line of the bitmap. A bit
    // of memory could be saved by sizing lTotalBanks exactly. Note too,
    // though, that the 2 RW window case may require more entries then,
    // because its windows are shorter, so you'd have to make sure there
    // were enough entries for the 2 RW window case, or recalculate
    // lTotalBanks for the 2 RW case

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->cTotalScans = lTotalScans;
    ppdev->pbiBankInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiBankInfo == NULL)
    {
        RIP("Couldn't get memory for bank info");
        return(FALSE);
    }

    ppdev->pjJustifyTopBank = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopBank == NULL)
    {
        RIP("Couldn't get memory for JustifyTopBank table");
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

    if ((cjGranularity + lDelta) >= cjBankSize &&
        (cjGranularity % lDelta) != 0)
    {
        // Oh no, we've got broken rasters (where a scan line crosses
        // a bank boundary):

        RIP("Oops, broken rasters not yet handled");
        return(FALSE);
    }
    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiBankInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

        // There are no broken rasters, so don't worry about left and right
        // edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom = iScan +
                (cjEndOfBank - cjScan) / lDelta;

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastBank = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopBank[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulJustifyBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulJustifyBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulJustifyBottomOffset > 0)
            ppdev->ulJustifyBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitializePlanar(ppdev, pBankInfo)
*
* Initialize for non-planar mode banking.
*
* NOTE: Allocates ppdev->pbiPlanarInfo and ppdev->pjJustifyTopPlanar buffers!
\**************************************************************************/

BOOL bInitializePlanar(PPDEV ppdev, VIDEO_BANK_SELECT* pBankInfo)
{
    LONG  lTotalScans;
    LONG  lTotalBanks;
    ULONG cjBankSize;
    ULONG cjGranularity = pBankInfo->PlanarHCGranularity;

    // Since we're in planar mode, every byte we see actually represents
    // four bytes of video memory:

    LONG  lDelta        = pBankInfo->BitmapWidthInBytes / 4;
    ULONG cjBitmapSize  = pBankInfo->BitmapSize / 4;

    ppdev->fl |= DRIVER_PLANAR_CAPABLE;

    // Set all clip rects to invalid; they'll be updated when the first
    // bank is mapped in

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    // Set up for planar banking:

    ppdev->pfnPlanarSwitchCode =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCBankCodeOffset);
    ppdev->pfnPlanarEnable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCEnableCodeOffset);
    ppdev->pfnPlanarDisable     =
                (PFN) (((BYTE*)pBankInfo) + pBankInfo->PlanarHCDisableCodeOffset);

    ppdev->lPlanarNextScan = lDelta;
    ppdev->vbtPlanarType   = pBankInfo->PlanarHCBankingType;

    // Set up to call the appropriate banking control routines

    switch(ppdev->vbtPlanarType)
    {
    case VideoBanked1RW:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window1RW;
        break;

    case VideoBanked1R1W:
        ppdev->pfnPlanarControl  = vPlanar1Window;
        ppdev->pfnPlanarControl2 = vPlanar2Window;
        break;

    case VideoBanked2RW:
        ppdev->pfnPlanarControl  = vPlanar1Window2RW;
        ppdev->pfnPlanarControl2 = vPlanar2Window2RW;

        // Offset from one bank index to next to make two 32k banks
        // appear to be one seamless 64k bank:

        ppdev->ulPlanar2RWSkip = BANK_SIZE_2RW_WINDOW / cjGranularity;
        break;

    default:
        RIP("Bad BankingType");
        return(FALSE);
    }

    lTotalBanks = (cjBitmapSize + cjGranularity - 1) / cjGranularity;
    lTotalScans = cjBitmapSize / lDelta;

    ppdev->pbiPlanarInfo = (PBANK_INFO) EngAllocMem(FL_ZERO_MEMORY,
                          lTotalBanks * sizeof(BANK_INFO), ALLOC_TAG);
    if (ppdev->pbiPlanarInfo == NULL)
    {
        RIP("Couldn't get memory for bank info");
        return(FALSE);
    }

    ppdev->pjJustifyTopPlanar = (BYTE*) EngAllocMem(0, lTotalScans, ALLOC_TAG);
    if (ppdev->pjJustifyTopPlanar == NULL)
    {
        RIP("Couldn't get memory for JustifyTopBank table");
        return(FALSE);
    }

    // For 2 RW windows, windows are assumed to be 32k in size, otherwise
    // assumed to be 64k:

    if (pBankInfo->BankingType == VideoBanked2RW)
        cjBankSize = BANK_SIZE_2RW_WINDOW;
    else
        cjBankSize = BANK_SIZE_1_WINDOW;

    if ((cjGranularity + lDelta) >= cjBankSize &&
        (cjGranularity % lDelta) != 0)
    {
        // Oh no, we've got broken rasters (where a scan line crosses
        // a bank boundary):

        DISPDBG((0, "Can't handle broken planar rasters"));

        ppdev->fl &= ~DRIVER_PLANAR_CAPABLE;// !!! Temporary, until we handle
        return(TRUE);                       // broken rasters in planar copy
    }
    else
    {
        // We now fill in the scan-to-bank look-up and bank tables:

        LONG        iScan         = 0;
        ULONG       iBank         = 0;
        ULONG       cjScan        = 0;
        ULONG       cjNextBank    = cjGranularity;
        ULONG       cjEndOfBank   = cjBankSize;
        PBANK_INFO  pbiWorking    = ppdev->pbiPlanarInfo;

        while (TRUE)
        {
            pbiWorking->ulBankOffset         = cjNextBank - cjGranularity;

        // There are no broken rasters, so don't worry about left and right
        // edges:

            pbiWorking->rclBankBounds.left   = LONG_MIN + 1; // +1 to avoid
                                                             // compiler warn
            pbiWorking->rclBankBounds.right  = LONG_MAX;
            pbiWorking->rclBankBounds.top    = iScan;
            pbiWorking->rclBankBounds.bottom = iScan +
                (cjEndOfBank - cjScan) / lDelta;

            // We don't need any more banks if we can see to the end
            // of the bitmap with the current bank:

            if (cjScan + cjBankSize >= cjBitmapSize)
                break;

            while (cjScan < cjNextBank)
            {
                ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
                cjScan += lDelta;
            }

            // Get ready for next bank:

            cjNextBank  += cjGranularity;
            cjEndOfBank += cjGranularity;
            pbiWorking++;
            iBank++;
        }

        // Clean up the last scans:

        ppdev->iLastPlanar = iBank;
        pbiWorking->rclBankBounds.bottom = lTotalScans;
        while (iScan < lTotalScans)
        {
            ppdev->pjJustifyTopPlanar[iScan++] = (BYTE) iBank;
        }

        // We've just computed the precise table for JustifyTop; we now
        // compute the scan offset for determining JustifyBottom:

        ASSERTVGA(cjBankSize >= cjGranularity,
               "Device says granularity more than bank size?");

        ppdev->ulPlanarBottomOffset = (cjBankSize - cjGranularity) / lDelta;

        // ulPlanarBottomOffset must be less than the number of scans
        // that fit entirely in any bank less the granularity size; if
        // our width doesn't divide evenly into the granularity, we'll
        // have to adjust the value to account for the first scan not
        // starting at offset 0 in any bank:

        if ((cjGranularity % lDelta) != 0 && ppdev->ulPlanarBottomOffset > 0)
            ppdev->ulPlanarBottomOffset--;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bEnableBanking(ppdev)
*
* Set up banking for the current mode
* pdsurf and ppdev are the pointers to the current surface and device
* Relevant fields in the surface are set up for banking
\**************************************************************************/

BOOL bEnableBanking(PPDEV ppdev)
{
    PVIDEO_BANK_SELECT  pBankInfo;
    UINT                ReturnedDataLength;
    VIDEO_BANK_SELECT   TempBankInfo;
    DWORD               status;

    // Make sure we've set to NULL any pointers to buffers that we allocate,
    // so that we can free them in our error path:

    ppdev->pBankInfo          = NULL;
    ppdev->pjJustifyTopBank   = NULL;
    ppdev->pbiBankInfo        = NULL;
    ppdev->pjJustifyTopPlanar = NULL;
    ppdev->pbiPlanarInfo      = NULL;

    // Query the miniport for banking info for this mode.
    //
    // First, figure out how big a buffer we need for the banking info
    // (returned in TempBankInfo->Size).

    if (status = EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,                      // input buffer
                         0,
                         (LPVOID) &TempBankInfo,    // output buffer
                         sizeof(VIDEO_BANK_SELECT),
                         &ReturnedDataLength))
    {
        // We expect this call to fail, because we didn't allow any room
        // for the code; we just want to get the required output buffer
        // size.
    }

    // Now, allocate a buffer of the required size and get the banking info.

    pBankInfo = (PVIDEO_BANK_SELECT) EngAllocMem(FL_ZERO_MEMORY,
                    TempBankInfo.Size, ALLOC_TAG);
    if (pBankInfo == NULL)
    {
        RIP("Initialization error-couldn't get memory for bank info");
        goto error;
    }

    // Remember it so we can free it later:

    ppdev->pBankInfo    = pBankInfo;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_GET_BANK_SELECT_CODE,
                         NULL,
                         0,
                         (LPVOID) pBankInfo,
                         TempBankInfo.Size,
                         &ReturnedDataLength))
    {
        RIP("Initialization error-GetBankSelectCode, second call");
        goto error;
    }

    // Set up for banking:

    ppdev->ulBitmapSize = pBankInfo->BitmapSize;

    if (!bInitializeNonPlanar(ppdev, pBankInfo))
        goto error;

    if (pBankInfo->BankingFlags & PLANAR_HC)
    {
        ppdev->fl |= DRIVER_PLANAR_CAPABLE;
        if (!bInitializePlanar(ppdev, pBankInfo))
            goto error;
    }

    // Map in scan line 0 for read & write, to put things in a known state:

    ppdev->pfnBankControl(ppdev, 0, JustifyTop);

    return(TRUE);

// Error path:

error:
    vDisableBanking(ppdev);

    return(FALSE);
}

/******************************Public*Routine******************************\
* vDisableBanking(ppdev)
*
* Disable banking for the current mode
\**************************************************************************/

VOID vDisableBanking(PPDEV ppdev)
{
    EngFreeMem((LPVOID) ppdev->pBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopBank);
    EngFreeMem((LPVOID) ppdev->pbiBankInfo);
    EngFreeMem((LPVOID) ppdev->pjJustifyTopPlanar);
    EngFreeMem((LPVOID) ppdev->pbiPlanarInfo);
}

/******************************Private*Routine******************************\
* vBankErrorTrap
*
* Traps calls to bank control functions in non-banked modes
*
\**************************************************************************/

VOID vBankErrorTrap(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
    DISPDBG((0,"Call to bank manager in unbanked mode"));
}

/******************************Private*Routine******************************\
* vBank1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
*
\**************************************************************************/

VOID vBank1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;
             BANK_POSITION BankPosition;
             ULONG      ulReturn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    {
        register LONG lSearchScan = (LONG)lScan;
        if (ulJustification == JustifyBottom)
        {
            lSearchScan -= ppdev->ulJustifyBottomOffset;
            if (lSearchScan <= 0)
                lSearchScan = 0;
        }

        ulBank     = (ULONG) ppdev->pjJustifyTopBank[lSearchScan];
        pbiWorking = &ppdev->pbiBankInfo[ulBank];
    }

    ASSERTVGA(pbiWorking->rclBankBounds.top <= (LONG)lScan &&
           pbiWorking->rclBankBounds.bottom > (LONG)lScan,
           "Oops, scan not in bank");

    ppdev->rcl1WindowClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,eax;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd

    if (ppdev->BankIoctlSupported) {

        static ulBankOld = -1;

        if (ulBank0 != ulBankOld) {

            ulBankOld = ulBank0;

            BankPosition.ReadBankPosition = ulBank0;
            BankPosition.WriteBankPosition = ulBank0;

            EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_BANK_POSITION,
                               &BankPosition,
                               sizeof(BANK_POSITION),
                               NULL,
                               0,
                               &ulReturn);
        }
    }

}

/******************************Private*Routine******************************\
* vBank1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vBank1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1WindowClip.bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopBank[lScan];
        ulBank1 = ulBank0 + ppdev->ulBank2RWSkip;
        if (ulBank1 >= ppdev->iLastBank)
        {
            ulBank1 = ppdev->iLastBank;
            ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        }
    }
    else
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopBank[lScan];
        ulBank0 = ulBank1 - ppdev->ulBank2RWSkip;
        if ((LONG) ulBank0 < 0)
        {
            ulBank0 = 0;
            ulBank1 = ppdev->ulBank2RWSkip;
        }
    }

    ppdev->rcl1WindowClip.left   = ppdev->pbiBankInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1WindowClip.top    = ppdev->pbiBankInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1WindowClip.bottom = ppdev->pbiBankInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1WindowClip.right  = ppdev->pbiBankInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiBankInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vBank2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vBank2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vBank2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vBank1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vBank2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vBank2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulJustifyBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopBank[lScan];
    pbiWorking = &ppdev->pbiBankInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2WindowClip[ulWindowToMap].bottom == -1)
    {
        if (ppdev->flBank & BANK_PLANAR)
        {
            ppdev->flBank &= ~BANK_PLANAR;
            ppdev->pfnPlanarDisable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2WindowClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(!(ppdev->flBank & BANK_PLANAR), "Shouldn't be in planar mode");

    ppdev->rcl2WindowClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnBankSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar1Window
*
* Maps in a single R/W window that allows access to lScan. Applies to both
* 1 RW window and 1R1W window banking schemes.
\**************************************************************************/

VOID vPlanar1Window(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    ppdev->rcl1PlanarClip = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) (ppdev->pjScreen - pbiWorking->ulBankOffset);
    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ulBank;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,eax;

    _asm call pBankFn;    // actually switch the banks

    _asm popfd
}

/******************************Private*Routine******************************\
* vPlanar1Window2RW
*
* Maps in two 32K RW windows so that they form a single 64K R/W window that
* allows access to lScan. Applies only to 2 RW window schemes.
*
\**************************************************************************/

VOID vPlanar1Window2RW(PPDEV ppdev, ULONG lScan, BANK_JUST ulJustification)
{
             ULONG      ulBank0;
             ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a double-window set-up is currently active, so invalidate double-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)


    if (ppdev->rcl1PlanarClip.bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl2PlanarClip[0].bottom = -1;
        ppdev->rcl2PlanarClip[1].bottom = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyTop)
    {
        ulBank0 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank1 = ulBank0 + ppdev->ulPlanar2RWSkip;
        if (ulBank1 >= ppdev->iLastPlanar)
            ulBank1 = ppdev->iLastPlanar;
    }
    else
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;

        ulBank1 = ppdev->pjJustifyTopPlanar[lScan];
        ulBank0 = ulBank1 - ppdev->ulPlanar2RWSkip;
        if ((LONG) ulBank0 < 0)
            ulBank0 = 0;
    }

    ppdev->rcl1PlanarClip.left   = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.left;
    ppdev->rcl1PlanarClip.top    = ppdev->pbiPlanarInfo[ulBank0].rclBankBounds.top;
    ppdev->rcl1PlanarClip.bottom = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.bottom;
    ppdev->rcl1PlanarClip.right  = ppdev->pbiPlanarInfo[ulBank1].rclBankBounds.right;

    // Shift the bitmap start address so that the desired bank aligns with
    // the banking window. The source and destination are set only so 1 R/W
    // aligned blits will work without having to be specifically aware of
    // the adapter type (some of the same code works with 1R/1W adapters too).

    ppdev->pvBitmapStart = (PVOID) ((BYTE*)ppdev->pjScreen
                         - ppdev->pbiPlanarInfo[ulBank0].ulBankOffset);

    ppdev->pvBitmapStart2Window[0] = ppdev->pvBitmapStart;
    ppdev->pvBitmapStart2Window[1] = ppdev->pvBitmapStart;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank for both read and write; this is accomplished
    // by mapping in the desired 32K bank, followed by the next 32K bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 1R1W window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
*
\**************************************************************************/

VOID vPlanar2Window(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG       ulBank;
             PBANK_INFO  pbiWorking;
    volatile ULONG       ulBank0;
    volatile ULONG       ulBank1;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        ULONG ulOtherWindow = ulWindowToMap ^ 1;

        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulOtherWindow]       = pbiWorking->rclBankBounds;
        ppdev->ulWindowBank[ulOtherWindow]         = ulBank;
        ppdev->pvBitmapStart2Window[ulOtherWindow] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[ulWindowToMap] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers


    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}

/******************************Private*Routine******************************\
* vPlanar2Window1RW
*
* Maps in the one window in 1R/W case.  Does exactly the same thing as the
* one window case, because there's only one window, but has to be a separate
* entry point because of the extra parameter (because we're using STDCALL).
\**************************************************************************/

VOID vPlanar2Window1RW(PPDEV ppdev, ULONG lScan,
    BANK_JUST ulJustification, ULONG ulWindowToMap)
{
    vPlanar1Window(ppdev, lScan, ulJustification);
}

/******************************Private*Routine******************************\
* vPlanar2Window2RW
*
* Maps in one of two windows, either the source window (window 0) or the dest
* window (window 1), to allows access to lScan. Applies to 2RW window
* banking scheme; should never be called for 1 RW window schemes, because
* there's only one window in that case.
\**************************************************************************/

VOID vPlanar2Window2RW(
    PPDEV       ppdev,
    ULONG       lScan,
    BANK_JUST   ulJustification,
    ULONG       ulWindowToMap)
{
             ULONG      ulBank;
             PBANK_INFO pbiWorking;
    volatile ULONG      ulBank0;
    volatile ULONG      ulBank1;
    volatile PFN        pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the bank containing the scan line with the desired justification:

    if (ulJustification == JustifyBottom)
    {
        lScan -= ppdev->ulPlanarBottomOffset;
        if ((LONG)lScan <= 0)
            lScan = 0;
    }

    ulBank     = (ULONG) ppdev->pjJustifyTopPlanar[lScan];
    pbiWorking = &ppdev->pbiPlanarInfo[ulBank];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[ulWindowToMap].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;

        // Neither of the 2 window windows was active, so we have to set up the
        // variables for the other bank (the one other than the one we were
        // called to set) as well, to make it valid. The other bank is set to
        // the same state as the bank we were called to set

        ppdev->rcl2PlanarClip[ulWindowToMap^1] = pbiWorking->rclBankBounds;
        if (ulWindowToMap == 1)
        {
            ppdev->pvBitmapStart2Window[0] =
                (PVOID) ((BYTE*)ppdev->pjScreen - pbiWorking->ulBankOffset);
        }
        else
        {
            ppdev->pvBitmapStart2Window[1] =
                (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
                BANK_SIZE_2RW_WINDOW);
        }
        ppdev->ulWindowBank[ulWindowToMap^1] = ulBank;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[ulWindowToMap] = pbiWorking->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    if (ulWindowToMap == 0)
    {
        ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset);
    }
    else
    {
        ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbiWorking->ulBankOffset +
            BANK_SIZE_2RW_WINDOW);
    }

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Map in the desired bank; also map in the other bank to whatever its
    // current state is

    ppdev->ulWindowBank[ulWindowToMap] = ulBank;

    // Set both banks at once, because we may have just initialized the other
    // bank, and because this way the bank switch code doesn't have to do a
    // read before write to obtain the state of the other bank.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0 = ppdev->ulWindowBank[0];
    ulBank1 = ppdev->ulWindowBank[1];
    pBankFn = ppdev->pfnPlanarSwitchCode;
    _asm mov eax,ulBank0;
    _asm mov edx,ulBank1;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}


/******************************Private*Routine******************************\
* vPlanarDouble
*
* Maps in two windows simultaneously, both the source window (window 0)
* and the dest window (window 1), to allows access to the scans.
* Applies to 1R1W and 2R/w window banking schemes; should never be called
* for 1 RW window schemes, because there's only one window in that case.
*
\**************************************************************************/

VOID vPlanarDouble(
    PPDEV       ppdev,
    LONG        lScan0,          // Source bank
    BANK_JUST   ulJustification0,// Source justification
    LONG        lScan1,          // Destination bank
    BANK_JUST   ulJustification1)// Destination justification
{
             PBANK_INFO  pbi0;
             PBANK_INFO  pbi1;
             ULONG       ulBank0;
             ULONG       ulBank1;
    volatile ULONG       ulBank0_vol;
    volatile ULONG       ulBank1_vol;
    volatile PFN         pBankFn;

    // ASM routines that call this may have STD in effect, but the C compiler
    // assumes CLD

    _asm    pushfd
    _asm    cld

    // Find the banks containing the scan lines with the desired justification:

    if (ulJustification0 == JustifyBottom)
    {
        lScan0 -= ppdev->ulPlanarBottomOffset;
        if (lScan0 <= 0)
            lScan0 = 0;
    }
    if (ulJustification1 == JustifyBottom)
    {
        lScan1 -= ppdev->ulPlanarBottomOffset;
        if (lScan1 <= 0)
            lScan1 = 0;
    }

    ulBank0    = (ULONG) ppdev->pjJustifyTopPlanar[lScan0];
    ulBank1    = (ULONG) ppdev->pjJustifyTopPlanar[lScan1];
    pbi0       = &ppdev->pbiPlanarInfo[ulBank0];
    pbi1       = &ppdev->pbiPlanarInfo[ulBank1];

    // Set the clip rect for this bank; if it's set to -1, that indicates that
    // a single-window set-up is currently active, so invalidate single-window
    // clip rects and display memory pointers (when double-window is active,
    // single-window is inactive, and vice-versa; a full bank set-up has to be
    // performed to switch between the two)

    if (ppdev->rcl2PlanarClip[0].bottom == -1)
    {
        if (!(ppdev->flBank & BANK_PLANAR))
        {
            ppdev->flBank |= BANK_PLANAR;
            ppdev->pfnPlanarEnable();
        }

        ppdev->rcl1WindowClip.bottom    = -1;
        ppdev->rcl2WindowClip[0].bottom = -1;
        ppdev->rcl2WindowClip[1].bottom = -1;
        ppdev->rcl1PlanarClip.bottom    = -1;
    }

    ASSERTVGA(ppdev->flBank & BANK_PLANAR, "Should be in planar mode");

    ppdev->rcl2PlanarClip[0] = pbi0->rclBankBounds;
    ppdev->rcl2PlanarClip[1] = pbi1->rclBankBounds;

    // Shift the bitmap start address so that the desired bank aligns with the
    // banking window

    ppdev->pvBitmapStart2Window[0] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi0->ulBankOffset);
    ppdev->pvBitmapStart2Window[1] =
            (PVOID) ((UCHAR *)ppdev->pjScreen - pbi1->ulBankOffset);

    if (ppdev->vbtPlanarType == VideoBanked2RW)
    {
        ppdev->pvBitmapStart2Window[1] = (PVOID) ((BYTE*)
            ppdev->pvBitmapStart2Window[1] + BANK_SIZE_2RW_WINDOW);
    }

    // Map in the desired banks.

    ppdev->ulWindowBank[0] = ulBank0;
    ppdev->ulWindowBank[1] = ulBank1;

    ppdev->flBank &= ~BANK_BROKEN_RASTERS;              // No broken rasters

    // Set both banks at once.
    // This is so convoluted to avoid problems with wiping out registers C
    // thinks it's still using; the values are tranferred to volatiles, and
    // then to registers

    ulBank0_vol = ulBank0;
    ulBank1_vol = ulBank1;
    pBankFn = ppdev->pfnPlanarSwitchCode;

    _asm mov eax,ulBank0_vol;
    _asm mov edx,ulBank1_vol;
    _asm call pBankFn;    // actually switch the banks

    _asm popfd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Banked Frame Buffer bitblit
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/************************************************************************\
* bIntersectRect
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst.
\************************************************************************/

static const RECTL rclEmpty = { 0, 0, 0, 0 };

BOOL bIntersectRect(
    PRECTL prcDst,
    PRECTL prcSrc1,
    PRECTL prcSrc2)

{
    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    // check for empty rect

    if (prcDst->left < prcDst->right)
    {
        prcDst->top    = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        // check for empty rect

        if (prcDst->top < prcDst->bottom)
            return(TRUE);        // not empty
    }

    // empty rect

    *prcDst = rclEmpty;

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenCopyBits(ppdev, pco, pxlo, prclDest, pptlSrc)
*
* Performs a screen-to-screen CopyBits entirely using an intermediate
* temporary buffer and GDI.
*
* We found that on most machines it was faster to have the engine copy
* the source to a buffer, then blit the buffer to the destination, than
* to have optimized ASM code that copies a word at a time.  The reason?
* The engine does d-word moves, which are faster than word moves even
* going over the bus to a 16 bit display device.
*
* We could also write optimized ASM code that does d-word moves, but the
* win will be marginal, we're time constrained, we also need a routine
* like this to handle complex clip objects and palette translates, and
* most of the other times we can use planar copies for important things
* like scrolls, anyways.
*
\**************************************************************************/

BOOL bPuntScreenToScreenCopyBits(
PPDEV     ppdev,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    RECTL    rclDest;
    POINTL   ptlSrc;
    BOOL     b = TRUE;
    ULONG    ulWidth;
    LONG     ulBurstSize;
    LONG     xLeft;
    LONG     xRight;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;
    ULONG    ulAlign;

    PVOID   savedpvScan0 = psoTmp->pvScan0;
    LONG    savedlDelta = psoTmp->lDelta;
    USHORT  savedfjBitmap = psoTmp->fjBitmap;

    xLeft = prclDest->left;
    xRight = prclDest->right;

    if (pco && (pco->iDComplexity != DC_TRIVIAL))
    {
        xLeft  = max(xLeft,pco->rclBounds.left);
        xRight = min(xRight,pco->rclBounds.right);
    }

    ulAlign = xLeft & 3;
    ulWidth = (((xRight + 3) & ~3) - (xLeft & ~3));
    ulBurstSize = min((GLOBAL_BUFFER_SIZE/ulWidth),(ULONG)(prclDest->bottom-prclDest->top));

    ASSERTVGA (ulBurstSize > 0, "VGA256:  bPuntScreenToScreenBitBlt ulBurstSize <= 0\n");

    // set up pso to use stack memory

    psoTmp->pvScan0 = ppdev->pvTmpBuf;
    psoTmp->lDelta  = ulWidth;
    psoTmp->fjBitmap |= BMF_TOPDOWN;

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);
            ySrcBottom     = min(ySrcBottom,ySrcTop+ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;   // make sure buffer is aligned to dst
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yOffset == 0)
                    break;

                if (ppdev->rcl1WindowClip.top >= yThisTop)
                {
                    ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            if (ySrcTop >= ppdev->rcl1WindowClip.bottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);
            ySrcTop        = max(ySrcTop,ySrcBottom-ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                b &= EngCopyBits(pso, psoTmp, pco, pxlo, &rclDest, &ptlSrc);

                if (yThisBottom == yDestBottom)
                    break;

                if (ppdev->rcl1WindowClip.bottom <= yThisBottom)
                {
                    ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            if (ppdev->rcl1WindowClip.top >= ySrcBottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }

    // restore initial values to pso

    ppdev->psoTmp->pvScan0          = savedpvScan0;
    ppdev->psoTmp->lDelta           = savedlDelta;
    ppdev->psoTmp->fjBitmap         = savedfjBitmap;

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bPuntScreenToScreenBitBlt(...)
*
* Performs a screen-to-screen BitBlt entirely using an intermediate temporary
* buffer and GDI.
*
* This function is basically a clone of bPuntScreenToScreenCopyBits,
* except that it can handle funky ROPs and stuff.
\**************************************************************************/

BOOL bPuntScreenToScreenBitBlt(
PPDEV     ppdev,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    RECTL    rclDest;           // Temporary destination rectangle
    POINTL   ptlSrc;            // Temporary source point
    POINTL   ptlMask;           // Temporary mask offset
    POINTL   ptlMaskAdjust;     // Adjustment for mask offset
    BOOL     b = TRUE;
    ULONG    ulWidth;
    LONG     ulBurstSize;
    LONG     xLeft;
    LONG     xRight;

    SURFOBJ* pso    = ppdev->pSurfObj;
    SURFOBJ* psoTmp = ppdev->psoTmp;
    ULONG    ulAlign;

    PVOID   savedpvScan0        = psoTmp->pvScan0;
    LONG    savedlDelta         = psoTmp->lDelta;
    USHORT  savedfjBitmap       = psoTmp->fjBitmap;


    xLeft = prclDest->left;
    xRight = prclDest->right;

    if (pco && (pco->iDComplexity != DC_TRIVIAL))
    {
        xLeft  = max(xLeft,pco->rclBounds.left);
        xRight = min(xRight,pco->rclBounds.right);
    }

    if (psoMask != NULL)
    {
        ptlMaskAdjust.x = xLeft - pptlMask->x;
        ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
    }

    ulAlign = xLeft & 3;
    ulWidth = (((xRight + 3) & ~3) - (xLeft & ~3));
    ulBurstSize = min((GLOBAL_BUFFER_SIZE/ulWidth),(ULONG)(prclDest->bottom-prclDest->top));

    ASSERTVGA (ulBurstSize > 0, "bPuntScreenToScreenBitBlt ulBurstSize <= 0\n");

    // set up pso to use stack memory

    psoTmp->pvScan0 = ppdev->pvTmpBuf;
    psoTmp->lDelta  = ulWidth;
    psoTmp->fjBitmap |= BMF_TOPDOWN;

    if (prclDest->top < pptlSrc->y)
    {
        ////////////////////////////////////////////////////////////////
        // Do a top-to-bottom copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcBottom;
        LONG yDestBottom;

        LONG yDestTop = prclDest->top;
        LONG ySrcTop  = pptlSrc->y;
        LONG ySrcLast = ySrcTop + (prclDest->bottom - prclDest->top);

        if (ySrcTop <  ppdev->rcl1WindowClip.top ||
            ySrcTop >= ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcBottom     = min(ySrcLast, ppdev->rcl1WindowClip.bottom);
            ySrcBottom     = min(ySrcBottom,ySrcTop+ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestBottom = yDestTop + rclDest.bottom;

            if (ppdev->rcl1WindowClip.top >= yDestBottom)
            {
                ppdev->pfnBankControl(ppdev, yDestBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yOffset == 0)
                    break;

                if (ppdev->rcl1WindowClip.top >= yThisTop)
                {
                    ppdev->pfnBankControl(ppdev, yThisTop - 1, JustifyBottom);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcBottom >= ySrcLast)
                break;

            yDestTop = yDestBottom;
            ySrcTop  = ySrcBottom;

            if (ySrcTop >= ppdev->rcl1WindowClip.bottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }
    else
    {
        ////////////////////////////////////////////////////////////////
        // Do a bottom-to-top copy:
        ////////////////////////////////////////////////////////////////

        LONG ySrcTop;
        LONG yDestTop;

        LONG yDestBottom = prclDest->bottom;
        LONG ySrcFirst   = pptlSrc->y;
        LONG ySrcBottom  = ySrcFirst + (prclDest->bottom - prclDest->top);

        if (ySrcBottom <= ppdev->rcl1WindowClip.top ||
            ySrcBottom > ppdev->rcl1WindowClip.bottom)
        {
            ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
        }

        pso->pvScan0 = ppdev->pvBitmapStart;

        while (TRUE)
        {
            // Copy some scans into the temporary buffer:

            ySrcTop        = max(ySrcFirst, ppdev->rcl1WindowClip.top);
            ySrcTop        = max(ySrcTop,ySrcBottom-ulBurstSize);

            ptlSrc.x       = pptlSrc->x;
            ptlSrc.y       = ySrcTop;

            rclDest.left   = ulAlign;
            rclDest.top    = 0;
            rclDest.right  = xRight - xLeft + ulAlign;
            rclDest.bottom = ySrcBottom - ySrcTop;

            b &= EngCopyBits(psoTmp, pso, NULL, NULL, &rclDest, &ptlSrc);

            yDestTop = yDestBottom - rclDest.bottom;

            if (ppdev->rcl1WindowClip.bottom <= yDestTop)
            {
                ppdev->pfnBankControl(ppdev, yDestTop, JustifyTop);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }

            while (TRUE)
            {
                // Copy the temporary buffer into one or more destination
                // banks:

                LONG yThisTop;
                LONG yThisBottom;
                LONG yOffset;

                yThisTop       = max(yDestTop, ppdev->rcl1WindowClip.top);
                yThisBottom    = min(yDestBottom, ppdev->rcl1WindowClip.bottom);
                yOffset        = yThisTop - yDestTop;

                ptlSrc.x       = ulAlign;
                ptlSrc.y       = yOffset;

                rclDest.left   = xLeft;
                rclDest.top    = yThisTop;
                rclDest.right  = xRight;
                rclDest.bottom = yThisBottom;

                ptlMask.x = rclDest.left - ptlMaskAdjust.x;
                ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

                b &= EngBitBlt(pso, psoTmp, psoMask, pco, pxlo, &rclDest,
                               &ptlSrc, &ptlMask, pbo, pptlBrush, rop4);

                if (yThisBottom == yDestBottom)
                    break;

                if (ppdev->rcl1WindowClip.bottom <= yThisBottom)
                {
                    ppdev->pfnBankControl(ppdev, yThisBottom, JustifyTop);
                    pso->pvScan0 = ppdev->pvBitmapStart;
                }
            }

            if (ySrcTop <= ySrcFirst)
                break;

            yDestBottom = yDestTop;
            ySrcBottom  = ySrcTop;

            if (ppdev->rcl1WindowClip.top >= ySrcBottom)
            {
                ppdev->pfnBankControl(ppdev, ySrcBottom - 1, JustifyBottom);
                pso->pvScan0 = ppdev->pvBitmapStart;
            }
        }
    }

    // restore initial values to pso

    ppdev->psoTmp->pvScan0          = savedpvScan0;
    ppdev->psoTmp->lDelta           = savedlDelta;
    ppdev->psoTmp->fjBitmap         = savedfjBitmap;

    return(b);
}

/******************************Public*Data*********************************\
* ROP to mix translation table
*
* Table to translate ternary raster ops to mixes (binary raster ops). Ternary
* raster ops that can't be translated to mixes are translated to 0 (0 is not
* a valid mix).
*
\**************************************************************************/

UCHAR jRop3ToMix[256] = {
    R2_BLACK, 0, 0, 0, 0, R2_NOTMERGEPEN, 0, 0,
    0, 0, R2_MASKNOTPEN, 0, 0, 0, 0, R2_NOTCOPYPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPENNOT, 0, 0, 0, 0, R2_NOT, 0, 0,
    0, 0, R2_XORPEN, 0, 0, 0, 0, R2_NOTMASKPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_MASKPEN, 0, 0, 0, 0, R2_NOTXORPEN, 0, 0,
    0, 0, R2_NOP, 0, 0, 0, 0, R2_MERGENOTPEN,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    R2_COPYPEN, 0, 0, 0, 0, R2_MERGEPENNOT, 0, 0,
    0, 0, R2_MERGEPEN, 0, 0, 0, 0, R2_WHITE
};

/******************************Public*Routine******************************\
* BOOL DrvBitBlt(psoDest, psoSrc, psoMask, pco, pxlo, prclDest, pptlSrc,
*                pptlMask, pbo, pptlBrush, rop4)
*
* This routine will handle any blit.  Perhaps glacially, but it will be
* handled.
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    MIX      mix;           // Mix, when solid fill performed
    BYTE     jClipping;
    RECTL    rclTmp;
    POINTL   ptlTmp;
    BBENUM   bben;          // Clip enumerator
    BOOL     bMore;         // Clip continuation flag
    POINTL   ptlMask;       // Temporary mask for engine call-backs
    POINTL   ptlMaskAdjust; // Adjustment for mask
    INT      iCopyDir;

    RBRUSH_COLOR rbc;               // Pointer to RBRUSH or iSolidColor value
    PFNFILL      pfnFill = vTrgBlt; // Pointer to appropriate fill routine
                                    //  (solid color by default)

    DISPDBG((3, "DrvBitBlt: Entering."));

    // Set up the clipping type
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    // Handle solid fills to the VGA surface with special-case code if planar
    // mode is supported.
    // LATER handle non-planar also

    if (psoDest->iType == STYPE_DEVICE) {

        // Destination is the VGA surface

        // Masked cases must be handled differently

        if ((((PPDEV) psoDest->dhsurf)->fl & DRIVER_PLANAR_CAPABLE) &&
            ((rop4 & 0xFF) == ((rop4 >> 8) & 0xFF))) {

            // Special-case static code for no-mask cases

            // Calculate mix from ROP if possible (not possible if it's truly a
            // ternary rop or a real rop4, but we can treat all pure binary
            // rops as mixes rather than rop4s)
            mix = jRop3ToMix[rop4 & 0xFF];

            switch (mix) {
                case R2_MASKNOTPEN:
                case R2_NOTCOPYPEN:
                case R2_XORPEN:
                case R2_MASKPEN:
                case R2_NOTXORPEN:
                case R2_MERGENOTPEN:
                case R2_COPYPEN:
                case R2_MERGEPEN:
                case R2_NOTMERGEPEN:
                case R2_MASKPENNOT:
                case R2_NOTMASKPEN:
                case R2_MERGEPENNOT:

                    // vTrgBlt can only handle solid color fills

                    if (pbo->iSolidColor != 0xffffffff)
                    {
                        rbc.iSolidColor = pbo->iSolidColor;
                    }
                    else
                    {
                        rbc.prb = (RBRUSH*) pbo->pvRbrush;
                        if (rbc.prb == NULL)
                        {
                            rbc.prb = (RBRUSH*) BRUSHOBJ_pvGetRbrush(pbo);
                            if (rbc.prb == NULL)
                            {
                            // If we haven't realized the brush, punt the call
                            // to the engine:

                                break;
                            }
                        }
                        if (!(rbc.prb->fl & RBRUSH_BLACKWHITE) &&
                            (mix != R2_COPYPEN))
                        {
                        // Only black/white brushes can handle ROPs other
                        // than COPYPEN:

                            break;
                        }

                        if (rbc.prb->fl & RBRUSH_NCOLOR)
                            pfnFill = vColorPat;
                        else
                            pfnFill = vMonoPat;
                    }

                // Rops that are implicit solid colors

                case R2_NOT:
                case R2_WHITE:
                case R2_BLACK:
                    // We can do a special-case solid fill

                    switch(jClipping) {
                        case DC_TRIVIAL:

                            // Just fill the rectangle:

                            (*pfnFill)((PPDEV) psoDest->dhsurf, 1,
                                       prclDest, mix, rbc, pptlBrush);

                            break;

                        case DC_RECT:

                            // Clip the solid fill to the clip rectangle
                            if (!bIntersectRect(&rclTmp, prclDest,
                                    &pco->rclBounds))
                                return(TRUE);

                            // Fill the clipped rectangle

                            (*pfnFill)((PPDEV) psoDest->dhsurf, 1,
                                       &rclTmp, mix, rbc, pptlBrush);

                            break;

                        case DC_COMPLEX:

                            ppdev = (PPDEV) psoDest->dhsurf;

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               CD_ANY, BB_RECT_LIMIT);

                            do {
                                bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                                      (PVOID) &bben);

                                if (bben.c > 0)
                                {
                                    RECTL* prclEnd = &bben.arcl[bben.c];
                                    RECTL* prcl    = &bben.arcl[0];

                                    do {
                                        bIntersectRect(prcl, prcl, prclDest);
                                        prcl++;

                                    } while (prcl < prclEnd);

                                    (*pfnFill)(ppdev, bben.c, bben.arcl,
                                               mix, rbc, pptlBrush);
                                }

                            } while(bMore);
                    }

                case R2_NOP:
                    return(TRUE);

                default:
                    break;
            }
        }
    }

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE) {

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE)) {

            ////////////////////////////////////////////////////////////////
            // BitBlt screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // See if we can do a simple CopyBits:

            if (rop4 == 0x0000CCCC)
            {
                ppdev = (PPDEV) psoDest->dhsurf;

                // We can handle quadpixel-aligned screen-to-screen blts with
                // no translation:

                if ((((pptlSrc->x ^ prclDest->left) & 3) == 0) &&
                    (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                    ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                {
                    switch(jClipping)
                    {
                    case DC_TRIVIAL:
                        vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                        return(TRUE);

                    case DC_RECT:

                        // Clip the target rectangle to the clip rectangle:

                        if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                        {
                            DISPDBG((0, "DrvBitBlt: Nothing to draw."));
                            return(TRUE);
                        }

                        ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                        ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                        vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                        return(TRUE);

                    case DC_COMPLEX:
                        if (pptlSrc->y >= prclDest->top)
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTDOWN;
                            else
                                iCopyDir = CD_LEFTDOWN;
                        }
                        else
                        {
                            if (pptlSrc->x >= prclDest->left)
                                iCopyDir = CD_RIGHTUP;
                            else
                                iCopyDir = CD_LEFTUP;
                        }

                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                        do {
                            RECTL* prcl;
                            RECTL* prclEnd;

                            bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                                  (PVOID) &bben);

                            prclEnd = &bben.arcl[bben.c];
                            for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                            {
                                if (bIntersectRect(prcl, prclDest, prcl))
                                {
                                    ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                    ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                    vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                                }
                            }
                        } while (bMore);

                        return(TRUE);
                    }
                }

                // Can't handle in hardware, so punt:

                return(bPuntScreenToScreenCopyBits(ppdev,
                                                   pco,
                                                   pxlo,
                                                   prclDest,
                                                   pptlSrc));
            }

            // It's more complicated than a CopyBits, so punt it:

            return(bPuntScreenToScreenBitBlt(ppdev,
                                             psoMask,
                                             pco,
                                             pxlo,
                                             prclDest,
                                             pptlSrc,
                                             pptlMask,
                                             pbo,
                                             pptlBrush,
                                             rop4));
        }

        ////////////////////////////////////////////////////////////////
        // BitBlt to screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoDest->dhsurf;

        if ((rop4 == 0x0000CCCC) &&
            (psoSrc->iBitmapFormat == BMF_8BPP) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
        // We have special code for the common 8bpp from memory to screen
        // with no ROPs:

            switch(jClipping)
            {
            case DC_TRIVIAL:
                vSrcCopy8bpp(ppdev, prclDest, pptlSrc,
                             psoSrc->lDelta, psoSrc->pvScan0);
                return(TRUE);

            case DC_RECT:

                // Clip the blt to the clip rectangle

                bIntersectRect(&rclTmp, prclDest, &pco->rclBounds);

                ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                vSrcCopy8bpp(ppdev, &rclTmp, &ptlTmp,
                             psoSrc->lDelta, psoSrc->pvScan0);

                return(TRUE);

            case DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, BB_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);

                    if (bben.c > 0)
                    {
                        RECTL* prclEnd = &bben.arcl[bben.c];
                        RECTL* prcl    = &bben.arcl[0];

                        do {
                            bIntersectRect(prcl, prcl, prclDest);

                            ptlTmp.x = pptlSrc->x + prcl->left
                                     - prclDest->left;
                            ptlTmp.y = pptlSrc->y + prcl->top
                                     - prclDest->top;

                            vSrcCopy8bpp(ppdev, prcl, &ptlTmp,
                                         psoSrc->lDelta, psoSrc->pvScan0);

                            prcl++;

                        } while (prcl < prclEnd);
                    }

                } while(bMore);

                return(TRUE);
            }
        }

        // Punt the memory-to-screen call back to the engine:

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        pso = ppdev->pSurfObj;

        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(pso,
                          psoSrc,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // BitBlt from screen:
        ////////////////////////////////////////////////////////////////

        if (psoMask != NULL)
        {
            ptlMaskAdjust.x = prclDest->left - pptlMask->x;
            ptlMaskAdjust.y = prclDest->top  - pptlMask->y;
        }

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            ptlMask.x = rclDest.left - ptlMaskAdjust.x;
            ptlMask.y = rclDest.top  - ptlMaskAdjust.y;

            b = EngBitBlt(psoDest,
                          pso,
                          psoMask,
                          pco,
                          pxlo,
                          &rclDest,
                          &ptlSrc,
                          &ptlMask,
                          pbo,
                          pptlBrush,
                          rop4);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    RIP("Got a funky format?");
    return(FALSE);
}

/***************************************************************************\
* DrvCopyBits
\***************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDest,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDest,
POINTL*   pptlSrc)
{
    BOOL     b;
    POINTL   ptlSrc;
    RECTL    rclDest;
    PPDEV    ppdev;
    SURFOBJ* pso;
    BBENUM   bben;
    BOOL     bMore;
    BYTE     jClipping;
    POINTL   ptlTmp;
    RECTL    rclTmp;
    INT      iCopyDir;

    // Get the correct surface object for the target and the source

    if (psoDest->iType == STYPE_DEVICE)
    {
        // We have to special case screen-to-screen operations:

        if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
        {

            ////////////////////////////////////////////////////////////////
            // CopyBits screen-to-screen:
            ////////////////////////////////////////////////////////////////

            ppdev = (PPDEV) psoDest->dhsurf;

            // We check to see if we can do a planar copy, because usually
            // it will be faster.  But the hardware has to be capable of
            // doing it, and the source and destination must be 4-pel
            // aligned.

            if ((((pptlSrc->x ^ prclDest->left) & 3) == 0) &&
                (ppdev->fl & DRIVER_PLANAR_CAPABLE) &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
            {
                jClipping = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

                switch(jClipping)
                {
                case DC_TRIVIAL:
                    vPlanarCopyBits(ppdev, prclDest, pptlSrc);
                    return(TRUE);

                case DC_RECT:
                    // Clip the target rectangle to the clip rectangle:

                    if (!bIntersectRect(&rclTmp, prclDest, &pco->rclBounds))
                    {
                        DISPDBG((0, "DrvCopyBits: Nothing to draw."));
                        return(TRUE);
                    }

                    ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                    ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                    vPlanarCopyBits(ppdev, &rclTmp, &ptlTmp);
                    return(TRUE);

                case DC_COMPLEX:
                    if (pptlSrc->y >= prclDest->top)
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTDOWN;
                        else
                            iCopyDir = CD_LEFTDOWN;
                    }
                    else
                    {
                        if (pptlSrc->x >= prclDest->left)
                            iCopyDir = CD_RIGHTUP;
                        else
                            iCopyDir = CD_LEFTUP;
                    }

                    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, iCopyDir, 0);

                    do {
                        RECTL* prcl;
                        RECTL* prclEnd;

                        bMore = CLIPOBJ_bEnum(pco, (ULONG) sizeof(bben),
                                              (PVOID) &bben);

                        prclEnd = &bben.arcl[bben.c];
                        for (prcl = bben.arcl; prcl < prclEnd; prcl++)
                        {
                            if (bIntersectRect(prcl, prclDest, prcl))
                            {
                                ptlTmp.x = pptlSrc->x + prcl->left - prclDest->left;
                                ptlTmp.y = pptlSrc->y + prcl->top  - prclDest->top;

                                vPlanarCopyBits(ppdev, prcl, &ptlTmp);
                            }
                        }
                    } while (bMore);

                    return(TRUE);
                }
            }

            return(bPuntScreenToScreenCopyBits(ppdev,
                                               pco,
                                               pxlo,
                                               prclDest,
                                               pptlSrc));
        }

        ////////////////////////////////////////////////////////////////
        // CopyBits to screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoDest->dhsurf;

        if ((psoSrc->iBitmapFormat == BMF_8BPP) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
        {
        // We have special code for the common 8bpp from memory to screen
        // with no ROPs:

            jClipping = (pco != NULL) ? pco->iDComplexity : DC_TRIVIAL;

            switch(jClipping)
            {
            case DC_TRIVIAL:
                vSrcCopy8bpp(ppdev, prclDest, pptlSrc,
                             psoSrc->lDelta, psoSrc->pvScan0);
                return(TRUE);

            case DC_RECT:

                // Clip the blt to the clip rectangle

                bIntersectRect(&rclTmp, prclDest, &pco->rclBounds);

                ptlTmp.x = pptlSrc->x + rclTmp.left - prclDest->left;
                ptlTmp.y = pptlSrc->y + rclTmp.top  - prclDest->top;

                vSrcCopy8bpp(ppdev, &rclTmp, &ptlTmp,
                             psoSrc->lDelta, psoSrc->pvScan0);

                return(TRUE);

            case DC_COMPLEX:

                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, BB_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco,(ULONG) sizeof(bben),
                                          (PVOID) &bben);

                    if (bben.c > 0)
                    {
                        RECTL* prclEnd = &bben.arcl[bben.c];
                        RECTL* prcl    = &bben.arcl[0];

                        do {

                            ASSERTVGA((prcl->bottom - prcl->top) > 0,
                                      "DrvCopyBits: enum rect height <= 0\n");

                            ASSERTVGA((prcl->right - prcl->left) > 0,
                                      "DrvCopyBits: enum rect width <= 0\n");

                            bIntersectRect(prcl, prcl, prclDest);

                            ptlTmp.x = pptlSrc->x + prcl->left
                                     - prclDest->left;
                            ptlTmp.y = pptlSrc->y + prcl->top
                                     - prclDest->top;

                            vSrcCopy8bpp(ppdev, prcl, &ptlTmp,
                                         psoSrc->lDelta, psoSrc->pvScan0);

                            prcl++;

                        } while (prcl < prclEnd);
                    }

                } while(bMore);

                return(TRUE);
            }
        }

        // Fall back to the engine:

        pso = ppdev->pSurfObj;
        vBankStartBltDest(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(pso,
                            psoSrc,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltDest(ppdev, pso, pptlSrc, prclDest,
                                       &ptlSrc, &rclDest));

        return(b);
    }
    else if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ////////////////////////////////////////////////////////////////
        // CopyBits from screen:
        ////////////////////////////////////////////////////////////////

        ppdev = (PPDEV) psoSrc->dhsurf;
        pso   = ppdev->pSurfObj;

        vBankStartBltSrc(ppdev, pso, pptlSrc, prclDest, &ptlSrc, &rclDest);

        do {
            b = EngCopyBits(psoDest,
                            pso,
                            pco,
                            pxlo,
                            &rclDest,
                            &ptlSrc);

        } while (b && bBankEnumBltSrc(ppdev, pso, pptlSrc, prclDest,
                                      &ptlSrc, &rclDest));

        return(b);
    }

    /* we should never be here */
    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Brush support.
*
* Copyright (c) 1992-1993 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

/****************************************************************************
 * DrvRealizeBrush
 ***************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    RBRUSH* prb;        // Pointer to where realization goes
    ULONG*  pulSrc;     // Temporary pointer
    ULONG*  pulDst;     // Temporary pointer
    BYTE*   pjSrc;
    BYTE*   pjDst;
    ULONG*  pulRBits;   // Points to RBRUSH pattern bits
    BYTE    jBkColor;
    BYTE    jFgColor;
    LONG    i;
    LONG    j;

    PPDEV   ppdev = (PPDEV) psoTarget->dhsurf;

    // For now, we only accelerate patterns using the latches, and we
    // sometimes need offscreen memory as a temporary work space to
    // initialize the latches for 2-color patterns:

    if ((ppdev->fl & (DRIVER_PLANAR_CAPABLE | DRIVER_HAS_OFFSCREEN)) !=
        (DRIVER_PLANAR_CAPABLE | DRIVER_HAS_OFFSCREEN) )
    {
        return(FALSE);
    }

    // We only accelerate 8x8 patterns:

    if (psoPattern->sizlBitmap.cx != 8 || psoPattern->sizlBitmap.cy != 8)
        return(FALSE);

    // We only implement n-color patterns on devices that have multiple
    // or separate read/write banks:

    if (ppdev->vbtPlanarType == VideoBanked1RW)
        return(FALSE);

    // We also only handle 1bpp, 4bpp and 8bpp patterns:

    if (psoPattern->iBitmapFormat > BMF_8BPP)
        return(FALSE);

    // At this point, we're definitely going to realize the brush:

    prb = BRUSHOBJ_pvAllocRbrush(pbo, sizeof(RBRUSH));
    if (prb == NULL)
        return(FALSE);

    pulRBits = &prb->aulPattern[0];

    DISPDBG((2, "\n  RBrush: "));

    // If 8bpp or 4bpp, copy the bitmap to our local buffer:

    if (psoPattern->iBitmapFormat == BMF_1BPP)
    {
        ULONG ulFlippedGlyph;

        DISPDBG((2, "1bpp "));

        // First, convert the bits to our desired format:

        pjSrc  = psoPattern->pvScan0;
        pulDst = pulRBits;
        for (i = 8; i > 0; i--)
        {
            // We want to take the byte with bits 76543210 and convert it
            // to the word 4567012301234567.  The pjGlyphFlipTable gives
            // us 45670123 from 76543210.

            ulFlippedGlyph = (ULONG) ppdev->pjGlyphFlipTable[*pjSrc];
            *pulDst = (ulFlippedGlyph << 8) | ((ulFlippedGlyph & 15) << 4) |
                      (ulFlippedGlyph >> 4);

            pulDst++;
            pjSrc += psoPattern->lDelta;
        }

        // Now initialize the rest of the RBrush fields:

        prb->xBrush    = 0;
        prb->ulBkColor = (pxlo->pulXlate[0] & 0xff);
        prb->ulFgColor = (pxlo->pulXlate[1] & 0xff);

        if (prb->ulFgColor == 0xff && prb->ulBkColor == 0x00)
        {
            prb->fl = RBRUSH_BLACKWHITE;
        }
        else if (prb->ulFgColor == 0x00 && prb->ulBkColor == 0xff)
        {
            // We have to invert the brush:

            prb->fl = RBRUSH_BLACKWHITE;
            for (i = 0; i < 8; i++)
            {
                prb->aulPattern[i] = ~prb->aulPattern[i];
            }
        }
        else
        {
            prb->fl = RBRUSH_2COLOR;
        }

        return(TRUE);
    }
    else if (psoPattern->iBitmapFormat == BMF_8BPP)
    {

        if (pxlo == NULL || pxlo->flXlate & XO_TRIVIAL)
        {
            pulSrc = psoPattern->pvScan0;
            pulDst = pulRBits;

            DISPDBG((2, "8bpp noxlate "));

            // 8bpp no translate case:

            for (i = 4; i > 0; i--)
            {
                *(pulDst)     = *(pulSrc);
                *(pulDst + 1) = *(pulSrc + 1);
                pulSrc = (ULONG*) ((BYTE*) pulSrc + psoPattern->lDelta);

                *(pulDst + 2) = *(pulSrc);
                *(pulDst + 3) = *(pulSrc + 1);

                pulSrc = (ULONG*) ((BYTE*) pulSrc + psoPattern->lDelta);
                pulDst += 4;
            }
        }
        else
        {
            pjSrc = (BYTE*) psoPattern->pvScan0;
            pjDst = (BYTE*) pulRBits;

            DISPDBG((2, "8bpp xlate "));

            // 8bpp translate case:

            for (i = 8; i > 0; i--)
            {
                for (j = 8; j > 0; j--)
                {
                    *pjDst++ = (BYTE) pxlo->pulXlate[*pjSrc++];
                }

                pjSrc += psoPattern->lDelta - 8;
            }
        }
    }
    else
    {
        DISPDBG((2, "4bpp xlate "));

        ASSERTVGA(psoPattern->iBitmapFormat == BMF_4BPP, "Extra case added?");

        // 4bpp case:

        pjSrc = (BYTE*) psoPattern->pvScan0;
        pjDst = (BYTE*) pulRBits;

        for (i = 8; i > 0; i--)
        {
            // Inner loop is repeated only 4 times because each loop handles
            // 2 pixels:

            for (j = 4; j > 0; j--)
            {
                *pjDst++ = (BYTE) pxlo->pulXlate[*pjSrc >> 4];
                *pjDst++ = (BYTE) pxlo->pulXlate[*pjSrc & 15];
                pjSrc++;
            }

            pjSrc += psoPattern->lDelta - 4;
        }
    }

    // We want to check if the 4bpp or 8bpp patterns are actually
    // only two colors:

    if (b2ColorBrush(pulRBits, &jFgColor, &jBkColor))
    {
        DISPDBG((2, "2 color "));

        // ??? We could actually also handle this case even if we have only
        // 1 r/w window in planar format:

        prb->xBrush    = 0;
        prb->ulBkColor = (ULONG) jBkColor;
        prb->ulFgColor = (ULONG) jFgColor;
        prb->fl        = RBRUSH_2COLOR;

        if (jFgColor == 0x00 && jBkColor == 0xff)
        {
            // Monochrome brushes always have to have the '0' bits
            // as black and the '1' bits as white, so we'll have to
            // invert the 1bpp pattern:

            prb->fl = RBRUSH_BLACKWHITE;
            for (i = 0; i < 8; i++)
            {
                prb->aulPattern[i] = ~prb->aulPattern[i];
            }
        }

        return(TRUE);
    }

    prb->fl     = RBRUSH_NCOLOR;
    prb->cy     = 8;
    prb->cyLog2 = 3;

    // xBrush is the brush alignment for the cached brush, and this value
    // will get compared to (pptlBrush->x & 7) to see if the cache brush
    // is correctly aligned with the brush requested.  Since it will never
    // match with -1, the brush will be correctly aligned and placed in
    // the cache (which, of course, is what we want to finish our
    // initialization):

    prb->xBrush = -1;

    // Copy those bitmap bits:

    // See if pattern is really only 4 scans long:

    if (pulRBits[0] == pulRBits[8]  && pulRBits[1] == pulRBits[9]  &&
        pulRBits[2] == pulRBits[10] && pulRBits[3] == pulRBits[11] &&
        pulRBits[4] == pulRBits[12] && pulRBits[5] == pulRBits[13] &&
        pulRBits[6] == pulRBits[14] && pulRBits[7] == pulRBits[15])
    {
        prb->cy     = 4;
        prb->cyLog2 = 2;

        // See if pattern is really only 2 scans long:

        if (pulRBits[0] == pulRBits[4] && pulRBits[1] == pulRBits[5] &&
            pulRBits[2] == pulRBits[6] && pulRBits[3] == pulRBits[7])
        {
            DISPDBG((2, "cy = 2 "));

            prb->cy     = 2;
            prb->cyLog2 = 1;
        }
        else
        {
            DISPDBG((2, "cy = 4 "));
        }
    }

    // See if pattern is really only 4 pels wide:

    pulDst = pulRBits;
    for (i = prb->cy / 2; i > 0; i--)
    {
        if (*(pulDst    ) != *(pulDst + 1) ||
            *(pulDst + 2) != *(pulDst + 3))
            goto done_this_realize_brush_stuff;

        pulDst += 4;
    }

    DISPDBG((2, "4pels wide"));

    prb->fl |= RBRUSH_4PELS_WIDE;

done_this_realize_brush_stuff:

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = pvVertexData - vVertexData;    // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\bankmgr.c ===
/*****************************************************************************\
* Smart 256 Colour Bank Manager
*
* Copyright (c) 1992 Microsoft Corporation
\*****************************************************************************/

#include "driver.h"

/*****************************************************************************\
* pcoBankStart - Start the bank enumeration using the clip object.
*
* Used when the destination is the screen and we can't do the clipping
* ourselves (as we can for blt's).
\*****************************************************************************/

CLIPOBJ* pcoBankStart(
    PPDEV       ppdev,
    RECTL*      prclScans,
    SURFOBJ*    pso,
    CLIPOBJ*    pco)
{
    LONG iTopScan = max(0, prclScans->top);

    if (pco)
    {
        iTopScan = max(prclScans->top, pco->rclBounds.top);
    }
    // Adjust for those weird cases where we're asked to start enumerating
    // below the bottom of the screen:

    iTopScan = min(iTopScan, (LONG) ppdev->cyScreen - 1);

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    // Remember what the last scan is that we're going to, and
    // make sure we only try to go as far as we need to.  It could
    // happen that when get a prclScans bigger than the screen:

    ppdev->iLastScan = min(prclScans->bottom, (LONG) ppdev->cyScreen);

    if (pco)
    {
        ppdev->iLastScan = min(ppdev->iLastScan, pco->rclBounds.bottom);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    if (pco == NULL)
    {
        // The call may have come down to us as having no clipping, but
        // we have to clip to the banks, so use our own clip object:

        pco            = ppdev->pcoNull;
        pco->rclBounds = ppdev->rcl1WindowClip;
    }
    else
    {
        // Save the engine's clip object data that we'll be tromping on:

        ppdev->rclSaveBounds    = pco->rclBounds;
        ppdev->iSaveDComplexity = pco->iDComplexity;
        ppdev->fjSaveOptions    = pco->fjOptions;

        // Let engine know it has to pay attention to the rclBounds of the
        // clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;

        // Use the bank bounds if they are tighter than the existing
        // bounds.  We don't have to check the left case here because we
        // know that ppdev->rcl1WindowClip.left == 0.

        if (pco->rclBounds.top <= ppdev->rcl1WindowClip.top)
            pco->rclBounds.top = ppdev->rcl1WindowClip.top;

        if (pco->rclBounds.right >= ppdev->rcl1WindowClip.right)
            pco->rclBounds.right = ppdev->rcl1WindowClip.right;

        if (pco->rclBounds.bottom >= ppdev->rcl1WindowClip.bottom)
            pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;

        if ((pco->rclBounds.top  >= pco->rclBounds.bottom) ||
            (pco->rclBounds.left >= pco->rclBounds.right))
        {
            // It's conceivable that we could get a situation where our
            // draw rectangle is completely disjoint from the specified
            // rectangle's rclBounds.  Make sure we don't puke on our
            // shoes:

            pco->rclBounds.left   = 0;
            pco->rclBounds.top    = 0;
            pco->rclBounds.right  = 0;
            pco->rclBounds.bottom = 0;
            ppdev->iLastScan      = 0;
        }
    }

    return(pco);
}

/*****************************************************************************\
* bBankEnum - Continue the bank enumeration.
\*****************************************************************************/

BOOL bBankEnum(PPDEV ppdev, SURFOBJ* pso, CLIPOBJ* pco)
{
    // If we're on the first portion of a broken raster, get the next:

    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    DISPDBG((4, "bBankEnum: Start.\n"));

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
        ppdev->pfnBankNext(ppdev);

    else if (ppdev->rcl1WindowClip.bottom < ppdev->iLastScan)
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);

    else
    {
        // Okay, that was the last bank, so restore our structures:

        if (pco != ppdev->pcoNull)
        {
            pco->rclBounds    = ppdev->rclSaveBounds;
            pco->iDComplexity = ppdev->iSaveDComplexity;
            pco->fjOptions    = ppdev->fjSaveOptions;
        }

        return(FALSE);
    }

    // Adjust the pvScan0 because we've moved the window to view
    // a different area:

    pso->pvScan0 = ppdev->pvBitmapStart;

    if (pco == ppdev->pcoNull)
    {
        // If were given a NULL clip object originally, we don't have
        // to worry about clipping to ppdev->rclSaveBounds:

        pco->rclBounds.top    = yNewTop;
        pco->rclBounds.left   = ppdev->rcl1WindowClip.left;
        pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;
        pco->rclBounds.right  = ppdev->rcl1WindowClip.right;
    }
    else
    {
        // Use the bank bounds if they are tighter than the bounds
        // we were originally given:

        pco->rclBounds = ppdev->rclSaveBounds;

        if (pco->rclBounds.top <= yNewTop)
            pco->rclBounds.top = yNewTop;

        if (pco->rclBounds.left <= ppdev->rcl1WindowClip.left)
            pco->rclBounds.left = ppdev->rcl1WindowClip.left;

        if (pco->rclBounds.right >= ppdev->rcl1WindowClip.right)
            pco->rclBounds.right = ppdev->rcl1WindowClip.right;

        if (pco->rclBounds.bottom >= ppdev->rcl1WindowClip.bottom)
            pco->rclBounds.bottom = ppdev->rcl1WindowClip.bottom;
    }

    DISPDBG((4, "bBankEnum: Leaving.\n"));

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltSrc - Start the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

VOID vBankStartBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xRightSrc;
    LONG yBottomSrc;
    LONG iTopScan = max(0, pptlSrc->y);

    DISPDBG((4, "vBankStartBltSrc: Entering.\n"));

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");

        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the source:

    pptlNewSrc->x = pptlSrc->x;
    pptlNewSrc->y = pptlSrc->y;

    // Adjust the destination:

    prclNewDest->left = prclDest->left;
    prclNewDest->top  = prclDest->top;

    yBottomSrc = pptlSrc->y + prclDest->bottom - prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc);
    prclNewDest->bottom += prclDest->top - pptlSrc->y;

    xRightSrc = pptlSrc->x + prclDest->right - prclDest->left;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc);
    prclNewDest->right += prclDest->left - pptlSrc->x;

    DISPDBG((4, "vBankStartBltSrc: Leaving.\n"));
}

/***************************************************************************\
* bBankEnumBltSrc - Continue the bank enumeration for when the screen is
*                   the source.
\***************************************************************************/

BOOL bBankEnumBltSrc(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG xLeftSrc;
    LONG xRightSrc;
    LONG yBottomSrc;

    LONG cx = prclDest->right  - prclDest->left;
    LONG cy = prclDest->bottom - prclDest->top;

    LONG dx;
    LONG dy;

    LONG yBottom = min(pptlSrc->y + cy, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    DISPDBG((4, "bBankEnumBltSrc: Entering.\n"));

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= pptlSrc->x + cx)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= pptlSrc->x)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    // Adjust the source:

    pso->pvScan0 = ppdev->pvBitmapStart;

    pptlNewSrc->x = max(ppdev->rcl1WindowClip.left, pptlSrc->x);
    pptlNewSrc->y = yNewTop;

    // Adjust the destination:

    dy = prclDest->top - pptlSrc->y;        // y delta from source to dest

    prclNewDest->top = yNewTop + dy;

    yBottomSrc = pptlSrc->y + cy;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, yBottomSrc) + dy;

    dx = prclDest->left - pptlSrc->x;       // x delta from source to dest

    xLeftSrc = pptlSrc->x;
    prclNewDest->left = pptlNewSrc->x + dx;

    xRightSrc = pptlSrc->x + cx;
    prclNewDest->right = min(ppdev->rcl1WindowClip.right, xRightSrc) + dx;

    DISPDBG((4, "bBankEnumBltSrc: Leaving.\n"));

    return(TRUE);
}

/***************************************************************************\
* vBankStartBltDest - Start the bank enumeration for when the screen is
*                     the destination.
\***************************************************************************/

VOID vBankStartBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG iTopScan = max(0, prclDest->top);

    DISPDBG((4, "vBankSTartBltDest: Entering.\n"));

    if (iTopScan >= (LONG) ppdev->cyScreen)
    {
    // In some instances we may be asked to start on a scan below the screen.
    // Since we obviously won't be drawing anything, don't bother mapping in
    // a bank:

        return;
    }

    // Map in the bank:

    if (iTopScan <  ppdev->rcl1WindowClip.top ||
        iTopScan >= ppdev->rcl1WindowClip.bottom)
    {
        ppdev->pfnBankControl(ppdev, iTopScan, JustifyTop);
    }

    if (ppdev->rcl1WindowClip.right <= prclDest->left)
    {
    // We have to watch out for those rare cases where we're starting
    // on a broken raster and we won't be drawing on the first part:

        ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird start bounds");
        ppdev->pfnBankNext(ppdev);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->left   = prclDest->left;
    prclNewDest->top    = prclDest->top;
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
        *pptlNewSrc = *pptlSrc;

    DISPDBG((4, "vBankStartBltDest: Leaving.\n"));
}

/***************************************************************************\
* bBankEnumBltDest - Continue the bank enumeration for when the screen is
*                   the destination.
\***************************************************************************/

BOOL bBankEnumBltDest(
    PPDEV       ppdev,
    SURFOBJ*    pso,
    POINTL*     pptlSrc,
    RECTL*      prclDest,
    POINTL*     pptlNewSrc,
    RECTL*      prclNewDest)
{
    LONG yBottom = min(prclDest->bottom, (LONG) ppdev->cyScreen);
    LONG yNewTop = ppdev->rcl1WindowClip.bottom;

    DISPDBG((4, "bBankEnumBltDest: Entering.\n"));

    if (ppdev->flBank & BANK_BROKEN_RASTER1)
    {
        ppdev->pfnBankNext(ppdev);
        if (ppdev->rcl1WindowClip.left >= prclDest->right)
        {
            if (ppdev->rcl1WindowClip.bottom < yBottom)
                ppdev->pfnBankNext(ppdev);
            else
            {
                // We're done:

                return(FALSE);
            }
        }
    }
    else if (yNewTop < yBottom)
    {
        ppdev->pfnBankControl(ppdev, yNewTop, JustifyTop);
        if (ppdev->rcl1WindowClip.right <= prclDest->left)
        {
            ASSERTVGA(ppdev->flBank & BANK_BROKEN_RASTER1, "Weird bounds");
            ppdev->pfnBankNext(ppdev);
        }
    }
    else
    {
        // We're done:

        return(FALSE);
    }

    pso->pvScan0 = ppdev->pvBitmapStart;

    // Adjust the destination:

    prclNewDest->top    = yNewTop;
    prclNewDest->left   = max(ppdev->rcl1WindowClip.left,   prclDest->left);
    prclNewDest->bottom = min(ppdev->rcl1WindowClip.bottom, prclDest->bottom);
    prclNewDest->right  = min(ppdev->rcl1WindowClip.right,  prclDest->right);

    // Adjust the source if there is one:

    if (pptlSrc != NULL)
    {
        pptlNewSrc->x = pptlSrc->x + (prclNewDest->left - prclDest->left);
        pptlNewSrc->y = pptlSrc->y + (prclNewDest->top  - prclDest->top);
    }

    DISPDBG((4, "bBankEnumBltDest: Leaving.\n"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

//
// Build the driver function table gadrvfn with function index/address pairs
//

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvSaveScreenBits,        (PFN) DrvSaveScreenBits     },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              }
};



/********************************* COMMENT ********************************\

    This routine allocates a 4K global buffer for temporary working storage
    which is used by several routines.  We wanted to get the most space for
    the least paging impact, so a page aligned 4K buffer was chosen.  Any
    access to this buffer will cause at most one page fault.  Because it is
    aligned, we can access the entire 4K without causing another page fault.

    Any buffer requirement over 4K must be allocated.  If we find that we
    are still having a low hit rate on the buffer (using lot's of allocs)
    then the buffer size should be increased to 8K.

    The ONLY reason that it is OK to have this global buffer is that this
    driver does not support DFBs, and accesses to the screen are synhronized
    by the engine.  In other words, it is currently never possible to have
    two threads executing code in the driver at the same time.

\**************************************************************************/



/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
    ULONG iEngineVersion,
    ULONG cj,
    PDRVENABLEDATA pded)
{
    UNREFERENCED_PARAMETER(iEngineVersion);

// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
    DEVMODEW   *pDevmode,       // Pointer to DEVMODE
    PWSTR       pwszLogAddress, // Logical address
    ULONG       cPatterns,      // number of patterns
    HSURF      *ahsurfPatterns, // return standard patterns
    ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
    ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
    ULONG       cjDevInfo,      // Length of following PDEVINFO structure
    DEVINFO    *pDevInfo,       // physical device information structure
    HDEV        hdev,           // HDEV, used for callbacks
    PWSTR       pwszDeviceName, // DeviceName - not used
    HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev;
    BYTE   *pjTemp;
    INT     i;

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        RIP("Couldn't allocate PDEV buffer");
        goto error0;
    }

    // Create the table used for flipping bits 0-3 and 4-7 when drawing text.
    // This table must be aligned to a 256-byte boundary.
    ppdev->pjGlyphFlipTableBase =
            (BYTE *) EngAllocMem((FL_ZERO_MEMORY),
            ((256+256)*sizeof(UCHAR)), ALLOC_TAG);
    if (ppdev->pjGlyphFlipTableBase == NULL) {
        RIP("Couldn't allocate pjGlyphFlipTableBase");
        goto error01;
    }

    // Round the table start up to the nearest 256 byte boundary, because the
    // table must start on 256-byte boundaries for look-up reasons

    ppdev->pjGlyphFlipTable =
            (BYTE *) ((ULONG) (ppdev->pjGlyphFlipTableBase + 0xFF) & ~0xFF);

    // Set the table to convert bits 76543210 to 45670123, which we need for
    // drawing text in planar mode (because plane 0 is the leftmost, not
    // rightmost, pixel)

    pjTemp = ppdev->pjGlyphFlipTable;
    for (i=0; i<256; i++) {
        *pjTemp++ = ((i & 0x80) >> 3) |
                    ((i & 0x40) >> 1) |
                    ((i & 0x20) << 1) |
                    ((i & 0x10) << 3) |
                    ((i & 0x08) >> 3) |
                    ((i & 0x04) >> 1) |
                    ((i & 0x02) << 1) |
                    ((i & 0x01) << 3);
    }

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev,pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((0,"vga256 Couldn't initialize PDEV"));
        goto error1;
    }

    // Initialize palette information.

    if (!bInitPaletteInfo(ppdev, &DevInfo))
    {
        RIP("Couldn't initialize palette");
        goto error1;
    }

    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    // Create a clip object we can use when we're given a NULL clip object:

    ppdev->pcoNull = EngCreateClip();
    if (ppdev->pcoNull == NULL)
    {
        RIP("Couldn't create clip");
        goto error2;
    }

    ppdev->pcoNull->iDComplexity     = DC_RECT;
    ppdev->pcoNull->rclBounds.left   = 0;
    ppdev->pcoNull->rclBounds.top    = 0;
    ppdev->pcoNull->rclBounds.right  = ppdev->cxScreen;
    ppdev->pcoNull->rclBounds.bottom = ppdev->cyScreen;
    ppdev->pcoNull->fjOptions        = OC_BANK_CLIP;

    // pvSaveScan0 is non-NULL only when enumerating banks:

    ppdev->pvSaveScan0 = NULL;

    // We're all done:

    return((DHPDEV) ppdev);

error2:
    vDisablePalette(ppdev);

error1:
    EngFreeMem(ppdev->pjGlyphFlipTableBase);

error01:
    EngFreeMem(ppdev);

error0:
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngDeleteClip(ppdev->pcoNull);
    vDisablePalette(ppdev);
    EngFreeMem(ppdev->pjGlyphFlipTableBase);
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    HSURF hsurfBm;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;

    // Create engine bitmap around frame buffer.

    ppdev = (PPDEV) dhpdev;

    if (!bInitSURF(ppdev, TRUE))
        goto error0;

    if (!bInit256ColorPalette(ppdev))
        goto error0;

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    ulBitmapType = BMF_8BPP;
    flHooks      = HOOKS_BMF8BPP;

    ASSERTVGA(ppdev->ulBitCount == 8, "Can only handle 8bpp VGAs");

    hsurfBm = (HSURF) EngCreateBitmap(sizl,
                                      ppdev->lDeltaScreen,
                                      (ULONG) (ulBitmapType),
                                      (FLONG) (((ppdev->lDeltaScreen > 0)
                                          ? BMF_TOPDOWN
                                          : 0)),
                                      (PVOID) (ppdev->pjScreen));
    if (hsurfBm == 0)
    {
        RIP("Couldn't create surface");
        goto error0;
    }

    if (!EngAssociateSurface(hsurfBm, ppdev->hdevEng, 0))
    {
        RIP("Couldn't create or associate surface");
        goto error1;
    }

    ppdev->hsurfBm = hsurfBm;

    ppdev->pSurfObj = EngLockSurface(hsurfBm);
    if (ppdev->pSurfObj == NULL)
    {
        RIP("Couldn't lock surface");
        goto error1;
    }

    hsurf = EngCreateDeviceSurface((DHSURF) ppdev, sizl, BMF_8BPP);
    if (hsurf == 0)
    {
        RIP("Couldn't create surface");
        goto error2;
    }

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
        RIP("Couldn't associate surface");
        goto error3;
    }

    ppdev->hsurfEng = hsurf;

    // Disable all the clipping.

    if (!bEnableBanking(ppdev))
    {
        RIP("Couldn't initialize banking");
        goto error3;
    }

    ppdev->pvTmpBuf = EngAllocMem(FL_ZERO_MEMORY,
                                  GLOBAL_BUFFER_SIZE,
                                  ALLOC_TAG);

    if (ppdev->pvTmpBuf == NULL)
    {
        RIP("Couldn't allocate global buffer");
        goto error4;
    }

    ASSERTVGA(ppdev->lNextScan != 0, "lNextScan shouldn't be zero");

    sizl.cx = ppdev->lNextScan;
    sizl.cy = GLOBAL_BUFFER_SIZE / abs(ppdev->lNextScan);

    ppdev->hbmTmp = EngCreateBitmap(sizl, sizl.cx, BMF_8BPP, 0, ppdev->pvTmpBuf);
    if (ppdev->hbmTmp == (HBITMAP) 0)
    {
        RIP("Couldn't create temporary bitmap");
        goto error5;
    }

    ppdev->psoTmp = EngLockSurface((HSURF) ppdev->hbmTmp);
    if (ppdev->psoTmp == (SURFOBJ*) NULL)
    {
        RIP("Couldn't lock temporary surface");
        goto error6;
    }

    // Attempt to initialize the brush cache; if this fails, it sets a flag in
    // the PDEV instructing us to punt brush fills to the engine
    vInitBrushCache(ppdev);
    vInitSavedBits(ppdev);

    return(hsurf);

error6:
    EngDeleteSurface((HSURF) ppdev->hbmTmp);

error5:
    EngFreeMem(ppdev->pvTmpBuf);

error4:
    vDisableBanking(ppdev);

error3:
    EngDeleteSurface(hsurf);

error2:
    EngUnlockSurface(ppdev->pSurfObj);

error1:
    EngDeleteSurface(hsurfBm);

error0:
    return((HSURF) 0);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
    DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    EngUnlockSurface(ppdev->psoTmp);
    EngDeleteSurface((HSURF) ppdev->hbmTmp);
    EngFreeMem(ppdev->pvTmpBuf);
    EngDeleteSurface(ppdev->hsurfEng);
    vDisableSURF(ppdev);
    vDisableBrushCache(ppdev);
    ppdev->hsurfEng = (HSURF) 0;
    vDisableBanking(ppdev);
}

/******************************Public*Routine******************************\
* DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL
DrvAssertMode(
    DHPDEV dhpdev,
    BOOL bEnable)
{
    BOOL    bRet = TRUE;
    PPDEV   ppdev = (PPDEV) dhpdev;
    ULONG   ulReturn;

    if (bEnable)
    {
        // The screen must be reenabled, reinitialize the device to
        // a clean state.

        bRet = bInitSURF(ppdev, FALSE);

        // Restore the off screen data.  This protects the Desktop
        // from a DOS application that might trash the off screen
        // memory.

        ppdev->bBitsSaved = FALSE;  // clear the DrvSaveScreenBits info flag
                                    // ie. blow away cached screen region

        // Blow away our brush cache because a full-screen app may have
        // overwritten the video memory where we cache our brushes:

        vResetBrushCache(ppdev);
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            RIP("VIDEO_RESET_DEVICE failed");
            bRet = FALSE;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE hDriver,
ULONG cjSize,
DEVMODEW *pdm)

{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation, pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    DISPDBG((2, "Vga256.dll: DrvGetModes\n"));

    cModes = getAvailableModes(hDriver,
                               (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                               &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "VGA256 DISP DrvGetModes failed to get mode information"));
        return 0;
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the output
        // buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);

        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return cbOutputSize;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* DrvFillPath
*
* Copyright (c) 1992-1993 Microsoft Corporation
\**************************************************************************/

// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles

#include "driver.h"
#include "limits.h"


#define     TAKING_ALLOC_STATS      0


#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECT))
#define EDGE_BYTES      (GLOBAL_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

//MIX translation table. Translates a mix 1-16, into an old style Rop 0-255.
extern BYTE gaMix[];

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath
(
    SURFOBJ  *pso,
    PATHOBJ  *ppo,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix,
    FLONG    flOptions
)
{
    PPDEV ppdev;
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    RBRUSH_COLOR rbc;    // Realized brush or solid color
    PFNFILL      pfnFill;// Points to appropriate fill routine

    BOOL     bMore;
    PATHDATA pd;
    RECTL    ClipRect;
    RECTL   *pRectBuf;
    EDGE    *pEdgeBuf;

    BOOL    bRetVal=FALSE;      //FALSE until proven TRUE
    BOOL    bMemAlloced=FALSE;  //FALSE until proven TRUE

    // The drawing surface
    ppdev = (PPDEV) pso->dhsurf;

    pRectBuf = (RECTL*) ((BYTE *)ppdev->pvTmpBuf);
    pEdgeBuf = (EDGE*) ((BYTE *)ppdev->pvTmpBuf + RECT_BYTES);

    // Our rectangle fill routines work only in planar mode:
    if (!(ppdev->fl & DRIVER_PLANAR_CAPABLE))
        goto ReturnFalse;

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // See if we can handle this pattern and ROP

    // We don't handle ROP4s
    if ((mix & 0xFF) != ((mix >> 8) & 0xFF)) {
        goto ReturnFalse;  // it's a ROP4; let GDI fill the path
    }


    // See if we can use the solid brush accelerators, or have to draw a
    // pattern
    switch (mix &= 0xFF)
    {
        case R2_MASKNOTPEN:
        case R2_NOTCOPYPEN:
        case R2_XORPEN:
        case R2_MASKPEN:
        case R2_NOTXORPEN:
        case R2_MERGENOTPEN:
        case R2_COPYPEN:
        case R2_MERGEPEN:
        case R2_NOTMERGEPEN:
        case R2_MASKPENNOT:
        case R2_NOTMASKPEN:
        case R2_MERGEPENNOT:

            // vTrgBlt can only handle solid color fills

            if (pbo->iSolidColor != 0xffffffff)
            {
                rbc.iSolidColor = pbo->iSolidColor;
                pfnFill = vTrgBlt;
            }
            else
            {
                rbc.prb = (RBRUSH*) pbo->pvRbrush;
                if (rbc.prb == NULL)
                {
                    rbc.prb = (RBRUSH*) BRUSHOBJ_pvGetRbrush(pbo);
                    if (rbc.prb == NULL)
                    {
                    // If we haven't realized the brush, punt the call:

                        goto ReturnFalse;
                    }
                }
                if (!(rbc.prb->fl & RBRUSH_BLACKWHITE) &&
                    ((mix & 0xff) != R2_COPYPEN))
                {
                // Only black/white brushes can handle ROPs other
                // than COPYPEN:

                    goto ReturnFalse;
                }

                if (rbc.prb->fl & RBRUSH_NCOLOR)
                    pfnFill = vColorPat;
                else
                    pfnFill = vMonoPat;
            }

            break;

        // Rops that are implicit solid colors

        case R2_NOT:
        case R2_WHITE:
        case R2_BLACK:

            // Brush color parameter doesn't matter for these rops

            pfnFill = vTrgBlt;
            break;

        case R2_NOP:
            goto ReturnTrue;

        default:
            RIP("DrvFillPath: bad mix == 0");
    }

    // Set up working storage in the temporary buffer

    prclRects = pRectBuf;       // storage for list of rectangles to draw

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    if (!(bMore = PATHOBJ_bEnum(ppo, &pd))) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersectRect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) EngAllocMem(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = pEdgeBuf; // use buffer on stack (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, mix, rbc,
                               pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, mix, rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else
    INT NumAdjustDowns;

    // Adjust the error term up by the number of y coordinates we'll skip
    *pErrorTerm += iErrorAdjustUp * yJump;

    // See if the error term turned over even once while skipping
    if (*pErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

// Global Table defining the 20 Window Default Colors.  For 256 color
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

const PALETTEENTRY BASEPALETTE[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo);

/******************************Public*Routine******************************\
* bInitPaletteInfo
*
* Initializes the palette information for this PDEV.
*
* Called by DrvEnablePDEV.
*
\**************************************************************************/

BOOL bInitPaletteInfo(PPDEV ppdev, DEVINFO *pDevInfo)
{
    if (!bInitDefaultPalette(ppdev, pDevInfo))
        return(FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisablePalette
*
* Frees resources allocated by bInitPaletteInfo.
*
\**************************************************************************/

VOID vDisablePalette(PPDEV ppdev)
{
// Delete the default palette if we created one.

    if (ppdev->hpalDefault)
    {
        EngDeletePalette(ppdev->hpalDefault);
        ppdev->hpalDefault = (HPALETTE) 0;
    }

    if (ppdev->pPal != (PPALETTEENTRY)NULL)
        EngFreeMem((PVOID)ppdev->pPal);
}

/******************************Public*Routine******************************\
* bInitDefaultPalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitDefaultPalette(PPDEV ppdev, DEVINFO *pDevInfo)
{
    ULONG ulLoop;
    BYTE  jRed;
    BYTE  jGre;
    BYTE  jBlu;

    // Allocate our palette

    ppdev->pPal = (PPALETTEENTRY)EngAllocMem(FL_ZERO_MEMORY,
            (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);

    if ((ppdev->pPal) == NULL)
    {
        RIP("Couldn't allocate default palette");
        return(FALSE);
    }

    // Generate 256 (8*4*4) RGB combinations to fill the palette

    jRed = jGre = jBlu = 0;

    for (ulLoop = 0; ulLoop < 256; ulLoop++)
    {
        ppdev->pPal[ulLoop].peRed   = jRed;
        ppdev->pPal[ulLoop].peGreen = jGre;
        ppdev->pPal[ulLoop].peBlue  = jBlu;
        ppdev->pPal[ulLoop].peFlags = (BYTE)0;

        if (!((jRed += 8) & 0x3F))
            if (!((jGre += 8) & 0x3F))
                jBlu += 16;
    }

// Fill in Windows Reserved Colors from the WIN 3.0 DDK
// The Window Manager reserved the first and last 10 colors for
// painting windows borders and for non-palette managed applications.

    for (ulLoop = 0; ulLoop < 10; ulLoop++)
    {
    // First 10

        ppdev->pPal[ulLoop].peRed   = BASEPALETTE[ulLoop].peRed   ;
        ppdev->pPal[ulLoop].peGreen = BASEPALETTE[ulLoop].peGreen ;
        ppdev->pPal[ulLoop].peBlue  = BASEPALETTE[ulLoop].peBlue  ;
        ppdev->pPal[ulLoop].peFlags = BASEPALETTE[ulLoop].peFlags;

    // Last 10

        ppdev->pPal[246+ulLoop].peRed   = BASEPALETTE[ulLoop+10].peRed   ;
        ppdev->pPal[246+ulLoop].peGreen = BASEPALETTE[ulLoop+10].peGreen ;
        ppdev->pPal[246+ulLoop].peBlue  = BASEPALETTE[ulLoop+10].peBlue  ;
        ppdev->pPal[246+ulLoop].peFlags = BASEPALETTE[ulLoop+10].peFlags;
    }

// Create handle for palette.

    ppdev->hpalDefault = EngCreatePalette(PAL_INDEXED,
                                               256,
                                               (PULONG) ppdev->pPal,
                                               0,0,0);
    pDevInfo->hpalDefault = ppdev->hpalDefault;

    if (ppdev->hpalDefault == (HPALETTE) 0)
    {
        RIP("Couldn't create default palette");
        EngFreeMem(ppdev->pPal);
        return(FALSE);
    }

// Initialize the hardware with the initial palette.

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInit256ColorPalette
*
* Initialize the hardware's palette registers.
*
\**************************************************************************/

BOOL bInit256ColorPalette(PPDEV ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->ulBitCount == 8)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Created: 30-Mar-1992
* Author: Andrew Milton [w-andym]
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16          // Maximum number of style array entries
#define STYLE_MAX_VALUE     0x3fffL     // Maximum for of a style array element
#define RUN_MAX             20          // Size of our complex clip runs buffer
#define STRIP_MAX           100         // Size of our strip buffer
#define STYLE_DENSITY       3           // Each style unit is 3 pixels long

// For the ROP table:

#define MIX_XOR_OFFSET      8

#define AND_ZERO            0L
#define AND_PEN             1L
#define AND_NOTPEN          2L
#define AND_ONE             3L

#define XOR_ZERO            (AND_ZERO   << MIX_XOR_OFFSET)
#define XOR_PEN             (AND_PEN    << MIX_XOR_OFFSET)
#define XOR_NOTPEN          (AND_NOTPEN << MIX_XOR_OFFSET)
#define XOR_ONE             (AND_ONE    << MIX_XOR_OFFSET)

// Flip and round flags (see lines.inc for a description):

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_SET                  0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED)

#define FL_STRIP_ARRAY_MASK     0x00000C00L
#define FL_STRIP_ARRAY_SHIFT    10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

struct _STRIP;
struct _LINESTATE;

typedef VOID (*PFNSTRIP)(struct _STRIP*, struct _LINESTATE*, LONG*);

typedef struct _STRIP {

// Updated by strip drawers:

    BYTE*           pjScreen;       // Points to the first pixel of the line
    BYTE            bIsGap;         // Are we working on a gap in the style?
    BYTE            jFiller2[3];    //   bIsGap sometimes treated as a ULONG

    STYLEPOS*       psp;            // Pointer to current style entry
    STYLEPOS        spRemaining;    // To go in current style

// Not modified by strip drawers:

    LONG            lNextScan;      // Signed increment to next scan
    LONG*           plStripEnd;     // Points one element past last strip
    LONG            flFlips;        // Indicates if line goes up or down
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    ULONG           xyDensity;      // Density of style
    ULONG           chAndXor;       // Lines colors (need 2 for doing ROPs)

// We leave room for a couple of extra dwords at the end of the strips
// array that can be used by the strip drawers:

    LONG            alStrips[STRIP_MAX + 2]; // Array of strips
} STRIP;

typedef struct _LINESTATE {

    ULONG           chAndXor;       // Line colors (need 2 for doing ROPs)
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            bStartIsGap;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;	                /* ls */

BOOL bLinesSimple(PPDEV, POINTFIX*, POINTFIX*, RUN*, ULONG, LINESTATE*,
                  RECTL*, PFNSTRIP*, FLONG);

BOOL bLines(PPDEV, POINTFIX*, POINTFIX*, RUN*, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the 256 colour VGA driver.
*
* NOTE: Must mirror driver.inc!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#ifndef _DRIVER_
#define _DRIVER_

#include "stdlib.h"
#include "stddef.h"
#include "windows.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"

#include "debug.h"

typedef struct _PDEV PDEV, *PPDEV;

//
// A mode requires broken rasters if the stride is a power of 2 and the video ram
// accessed is greater than 64K.
//

#define POW2(stride) (!((stride) & ((stride)-1)))   // TRUE if stride is power of 2
#define BROKEN_RASTERS(stride,cy) ((!(POW2(stride))) && ((stride*cy) > 0x10000))

//
// Sizes assumed for 1-window and 2 RW-window banks.
//

#define BANK_SIZE_1_WINDOW      0x10000L
#define BANK_SIZE_2RW_WINDOW    0x08000L

//
// This will be used by everyone who needs a temporary working buffer
//

#define     PAGE_SIZE           4096
#define     NUM_GLOBAL_PAGES    2
#define     GLOBAL_BUFFER_SIZE  (PAGE_SIZE * NUM_GLOBAL_PAGES)

#define     PELS_PER_DWORD      4


/**************************************************************************\
*
* Specifies desired justification for requestion scan line within bank window
*
\**************************************************************************/

typedef enum {
    JustifyTop = 0,
    JustifyBottom,
} BANK_JUST;

/**************************************************************************\
*
* Specifies which window is to be mapped by two-window bank handler.
*
\**************************************************************************/

typedef enum {
    MapSourceBank = 0,
    MapDestBank,
} BANK_JUST;

/**************************************************************************\
*
* Bank clipping info
*
\**************************************************************************/

typedef struct {
    RECTL rclBankBounds;    // describes pixels addressable in this bank
    ULONG ulBankOffset;     // offset of bank start from bitmap start, if
                            // the bitmap were linearly addressable
} BANK_INFO, *PBANK_INFO;

/**************************************************************************\
*
* Bank control function vector
*
\**************************************************************************/

typedef VOID (*PFN_PlanarEnable)();
typedef VOID (*PFN_PlanarDisable)();
typedef VOID (*PFN_PlanarControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_PlanarControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_PlanarNext)(PPDEV);
typedef VOID (*PFN_PlanarNext2)(PPDEV, ULONG);
typedef VOID (*PFN_BankControl)(PPDEV, ULONG, BANK_JUST);
typedef VOID (*PFN_BankControl2)(PPDEV, ULONG, BANK_JUST, ULONG);
typedef VOID (*PFN_BankNext)(PPDEV);
typedef VOID (*PFN_BankNext2)(PPDEV, ULONG);

/**************************************************************************\
*
* Miscellaneous driver flags
*
\**************************************************************************/

#define DRIVER_PLANAR_CAPABLE       0x01L
#define DRIVER_OFFSCREEN_REFRESHED  0x02L // if not set, don't use offscreen
                                          //   memory for long operations
                                          //   (because the memory won't be
                                          //   refreshed)
#define DRIVER_HAS_OFFSCREEN        0x04L // if not set, can't use any offscreen
                                          //   memory

/**************************************************************************\
*
* Bank status flags
*
\**************************************************************************/

#define BANK_BROKEN_RASTER1     0x01L // If bank1 or read bank has broken raster
#define BANK_BROKEN_RASTER2     0x02L // If bank2 or write bank has broken raster
#define BANK_BROKEN_RASTERS    (BANK_BROKEN_RASTER1 | BANK_BROKEN_RASTER2)
#define BANK_PLANAR             0x04L // If in planar mode

/**************************************************************************\
*
* Structure for maintaining a realized brush:
*
\**************************************************************************/

extern const ULONG gaaulPlanarPat[][8]; // Hatch brushes in preferred format

#define RBRUSH_BLACKWHITE       0x001L  // Black and white brush
#define RBRUSH_2COLOR           0x002L  // 2 color brush
#define RBRUSH_NCOLOR           0x004L  // n color brush
#define RBRUSH_4PELS_WIDE       0x008L  // Brush is 4xN

#define BRUSH_SIZE              64      // An 8x8 8bpp brush needs 64 bytes
#define BRUSH_MAX_CACHE_SCANS   2       // Maximum # of scans used by brush cache

typedef struct _RBRUSH
{
    FLONG       fl;                     // Flags
    LONG        xBrush;                 // Realized brush's x brush origin

    // Info for 2 color brushes:

    ULONG       ulFgColor;              // Foreground color
    ULONG       ulBkColor;              // Background color

    // Info for n color brushes:

    LONG        cy;                     // Height of pattern
    LONG        cyLog2;                 // log2 of the height
    LONG        iCache;                 // Cache entry index.  Zero is not
                                        //  a valid index.

    // Pattern in preferred format:

    ULONG       aulPattern[BRUSH_SIZE / sizeof(ULONG)];

} RBRUSH;                           /* rb */

typedef struct _BRUSHCACHEENTRY
{
    RBRUSH*     prbVerifyRealization;   // We never dereference this pointer
                                        //  to find a brush realization;
                                        //  it is only ever used in a compare
                                        //  to verify that for a realized brush,
                                        //  its off-screen cache entry is still
                                        //  valid.
    LONG        yCache;                 // Scan where entry's bits live
    LONG        ulCache;                // Offset to cache entry from screen
                                        //  start (assuming planar format --
                                        //  if you want the non-planar offset,
                                        //  multiply by 4)

} BRUSHCACHEENTRY;                  /* bce */

/**************************************************************************\
*
* Physical device data structure
*
\**************************************************************************/

// ***********************************************************
// *** MUST match the assembler version in i386\driver.inc ***
// ***********************************************************

typedef struct _PDEV
{
    FLONG       fl;                     // Driver flags (DRIVER_xxx)
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfEng;               // Engine's handle to surface
    HANDLE      hsurfBm;                // Handle to the "punt" surface
    SURFOBJ*    pSurfObj;               // pointer to the locked "punt" surface

    HPALETTE    hpalDefault;            // Handle to the default palette for device.

    PBYTE       pjScreen;               // This is pointer to base screen address
    ULONG       cxScreen;               // Visible screen width
    ULONG       cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDeltaScreen;           // Distance from one scan to the next.

    FLONG       flRed;                  // For bitfields device, Red Mask
    FLONG       flGreen;                // For bitfields device, Green Mask
    FLONG       flBlue;                 // For bitfields device, Blue Mask
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ULONG       ulBitCount;             // # of bits per pel -- can be only 8

    ULONG       ulrm0_wmX;              // Four values (one per byte) to set
                                        //  GC5 to to select read mode 0
                                        //  together with write modes 0-3

    BYTE*       pjGlyphFlipTableBase;   // Base allocated address for flip
                                        //  table; the pointer we use is this
                                        //  pointer rounded up to the nearest
                                        //  256-byte boundary
    BYTE*       pjGlyphFlipTable;       // Pointer to table used to flip glyph
                                        //  bits 0-3 and 4-7
    PALETTEENTRY* pPal;                 // If this is pal managed, this is the pal

    HBITMAP     hbmTmp;                 // Handle to temporary buffer
    SURFOBJ*    psoTmp;                 // Temporary surface

//-----------------------------------------------------------------------------

// DCI stuff:

    BOOL        bSupportDCI;            // True if miniport supports DCI

//-----------------------------------------------------------------------------

// Off screen stuff:

// Brush cache:

    LONG                iCache;         // Index for next brush to be allocated
    LONG                iCacheLast;     // Last valid cache index (so the
                                        //  number of entries in cache is
                                        //  iCacheLast + 1)
    BRUSHCACHEENTRY*    pbceCache;      // Pointer to allocated cache

// Saved screen bits stuff

    RECTL       rclSavedBitsRight;      // right rect of vga memory that's
                                        //  not visible
    RECTL       rclSavedBitsBottom;     // bottom rect of vga memory that's
                                        //  not visible
    BOOL        bBitsSaved;             // TRUE if bits are currently saved

//-----------------------------------------------------------------------------

// Bank manager stuff common between planar and non-planar modes:

    LONG        cTotalScans;            // Number of usable on and off-screen
                                        //  scans
    PVIDEO_BANK_SELECT pBankInfo;       // Bank info for current mode returned
                                        //  by miniport

    FLONG       flBank;                 // Flags for current bank state

    ULONG       ulBitmapSize;           // Length of bitmap if there were no
                                        //  banking, in CPU addressable bytes
    ULONG       ulWindowBank[2];        // Current banks mapped into windows
                                        //  0 & 1
    PVOID       pvBitmapStart;          // Single-window bitmap start pointer
                                        //  (adjusted as necessary to make
                                        //  window map in at proper offset)
    PVOID       pvBitmapStart2Window[2];// Double-window window 0 and 1 bitmap
                                        // start

// Non-planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE  vbtBankingType;        // Type of banking
    PFN              pfnBankSwitchCode;     // Pointer to bank switch code

    LONG             lNextScan;             // Offset to next bank in bytes
    BYTE*            pjJustifyTopBank;      // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*       pbiBankInfo;           // Array of bank clip info
    ULONG            ulJustifyBottomOffset; // # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG            iLastBank;             // Index of last valid bank in
                                            //  pbiBankInfo table
    ULONG            ulBank2RWSkip;         // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_BankControl  pfnBankControl;        // Pointer to bank control function
    PFN_BankControl2 pfnBankControl2Window; // Pointer to double-window bank
                                            //  control function
    PFN_BankNext     pfnBankNext;           // Pointer to next bank function
    PFN_BankNext2    pfnBankNext2Window;    // Pointer to double-window next
                                            //  bank function

    RECTL            rcl1WindowClip;        // Single-window banking clip rect
    RECTL            rcl2WindowClip[2];     // Double-window banking clip rects for
                                            //  windows 0 & 1

// Planar mode specific bank management control stuff:

    VIDEO_BANK_TYPE    vbtPlanarType;       // Type of planar banking

    PFN                pfnPlanarSwitchCode; // Pointer to planar bank switch
                                            //  code

    LONG               lPlanarNextScan;     // Offset to next planar bank in
                                            //  bytes
    BYTE*              pjJustifyTopPlanar;  // Pointer to lookup table for
                                            //  converting scans to banks
    BANK_INFO*         pbiPlanarInfo;       // Array of bank clip info
    ULONG              ulPlanarBottomOffset;// # of scans from top to bottom
                                            //  of bank, for bottom justifying
    ULONG              iLastPlanar;         // Index of last valid bank in
                                            //  pbiPlanarInfo table
    ULONG              ulPlanar2RWSkip;     // Offset from one bank index to next
                                            //  to make two 32K banks appear to be
                                            //  one seamless 64K bank

    PFN_PlanarControl  pfnPlanarControl;    // Planar one window bank control
    PFN_PlanarControl2 pfnPlanarControl2;   // Planar two window bank control

    PFN_PlanarNext     pfnPlanarNext;       // Planar one window next bank
    PFN_PlanarNext2    pfnPlanarNext2;      // Planar two window next bank

    RECTL              rcl1PlanarClip;      // Single-window banking clip rect
    RECTL              rcl2PlanarClip[2];   // Double-window banking clip rects for
                                            //  windows 0 & 1

    PFN_PlanarEnable   pfnPlanarEnable;     // Function to enable planar mode
    PFN_PlanarDisable  pfnPlanarDisable;    // Function to disable planar mode

// Smart bank manager stuff:

    LONG        iLastScan;              // Last scan we want to enumerate
    PVOID       pvSaveScan0;            // Surface's original pvScan0
    RECTL       rclSaveBounds;          // Clip Object's original bounds
    CLIPOBJ*    pcoNull;                // Points to an empty clip object
                                        //  we can use when we're given a
                                        //  NULL CLIPOBJ pointer
    BYTE        iSaveDComplexity;       // Clip Object's original complexity
    BYTE        fjSaveOptions;          // Clip Object's original flags
    BYTE        ajFiller[2];            // Pack dword alignment

    PVOID       pvTmpBuf;               // Ptr to buffer attached to pdev

    BOOLEAN     BankIoctlSupported;     // Does the miniport support ioclt
                                        // based banking?
};                                  /* pdev */

// Palette stuff:

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

// Size of the driver extra information in the DEVMODe structure passed
// to and from the display driver

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"VGA256"       // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "VGA256: "      // All debug output is prefixed
#define ALLOC_TAG               '2gvD'          // 4 byte TAG for memory allocations

// When calling vEnumStart, make sure you set bAll to FALSE.  This will tell
// the Engine to only enumerate rectangles in rclBounds.

// Hooks and Driver function table.

#define HOOKS_BMF8BPP   (HOOK_BITBLT   | HOOK_TEXTOUT    | HOOK_FILLPATH | \
                         HOOK_COPYBITS | HOOK_STROKEPATH | HOOK_PAINT | \
                         HOOK_STRETCHBLT)

#define BB_RECT_LIMIT   50

typedef struct _BBENUM
{
    ULONG   c;
    RECTL   arcl[BB_RECT_LIMIT];
} BBENUM;

#define TO_RECT_LIMIT   20

typedef struct _TEXTENUM
{
    ULONG       c;
    RECTL       arcl[TO_RECT_LIMIT];
} TEXTENUM;

// Initialization stuff:

BOOL bEnableBanking(PPDEV);
VOID vDisableBanking(PPDEV);
BOOL bInitPDEV(PPDEV,PDEVMODEW,GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV,BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
BOOL bInit256ColorPalette(PPDEV);
BOOL bInitPatterns(PPDEV, INT);
VOID vInitBrushCache(PPDEV);
VOID vInitSavedBits(PPDEV);
VOID vDisablePalette(PPDEV);
VOID vDisablePatterns(PPDEV);
VOID vDisableSURF(PPDEV);
VOID vDisableBrushCache(PPDEV);
VOID vResetBrushCache(PPDEV);
VOID vInitRegs(PPDEV);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);

// Smart bank manager stuff:

CLIPOBJ* pcoBankStart(PPDEV, RECTL*, SURFOBJ*, CLIPOBJ*);
BOOL     bBankEnum(PPDEV, SURFOBJ*, CLIPOBJ*);
VOID     vBankStartBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltSrc(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
VOID     vBankStartBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);
BOOL     bBankEnumBltDest(PPDEV, SURFOBJ*, POINTL*, RECTL*, POINTL*, RECTL*);

// Fill routines:

typedef union _RBRUSH_COLOR {
    RBRUSH* prb;
    ULONG   iSolidColor;
} RBRUSH_COLOR;          /* rbc */

typedef VOID (*PFNFILL)(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);

VOID vTrgBlt(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);
VOID vMonoPat(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);
VOID vColorPat(PPDEV, ULONG, PRECTL, MIX, RBRUSH_COLOR, POINTL*);

// Other prototypes:

BOOL b2ColorBrush(ULONG* pvBits, BYTE* pjFgColor, BYTE* pjBkColor);
VOID vPlanarCopyBits(PPDEV, RECTL*, POINTL*);
BOOL bIntersectRect(RECTL*, RECTL*, RECTL*);
VOID vSetWriteModes(ULONG *);
VOID vClearMemDword(PULONG * pulBuffer, ULONG ulDwordCount);
VOID vSrcCopy8bpp(PPDEV, RECTL*, POINTL*, LONG, VOID*);
VOID vFastLine(PPDEV, PATHOBJ*, LONG, ULONG);

#endif // _DRIVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE
};

/******************************Public*Routine******************************\
* bPaintRgn
*
* Paint the clipping region with the specified color and mode
*
\**************************************************************************/

BOOL bPaintRgn
(
    SURFOBJ      *pso,
    CLIPOBJ      *pco,
    MIX          mix,
    RBRUSH_COLOR rbc,
    POINTL       *pptlBrush,
    PFNFILL      pfnFill
)
{
    BBENUM      bben;
    PPDEV       ppdev;
    ULONG       iRT;
    BOOL        bMore;

// Get the target surface information.

    ppdev = (PPDEV) pso->dhsurf;

    switch(pco->iMode) {

        case TC_RECTANGLES:

            // Rectangular clipping can be handled without enumeration.
            // Note that trivial clipping is not possible, since the clipping
            // region defines the area to fill

            if (pco->iDComplexity == DC_RECT)
            {
                (*pfnFill)(ppdev, 1, &pco->rclBounds, mix, rbc, pptlBrush);

            } else {

                // Enumerate all the rectangles and draw them

                CLIPOBJ_cEnumStart(pco,FALSE,CT_RECTANGLES,CD_ANY,BB_RECT_LIMIT);

                do {
                    bMore = CLIPOBJ_bEnum(pco, sizeof(bben), (PVOID) &bben);

                    (*pfnFill)(ppdev, bben.c, &bben.arcl[0], mix, rbc, pptlBrush);

                } while (bMore);
            }

            return(TRUE);

        default:
            RIP("bPaintRgn: unhandled TC_xxx\n");
            return(FALSE);
    }
}


/**************************************************************************\
* DrvPaint
*
* Paint the clipping region with the specified brush
*
\**************************************************************************/

BOOL DrvPaint
(
    SURFOBJ  *pso,
    CLIPOBJ  *pco,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    MIX       mix
)
{
    ROP4         rop4;
    RBRUSH_COLOR rbc;
    PFNFILL      pfnFill;

    // If this adapter supports planar mode and the foreground and background
    // mixes are the same,
    // LATER or if there's no brush mask
    // then see if we can use the brush accelerators
    // LATER handle non-planar also

    if ((((PPDEV) pso->dhsurf)->fl & DRIVER_PLANAR_CAPABLE) &&
        ((mix & 0xFF) == ((mix >> 8) & 0xFF))) {

        switch (mix & 0xFF) {
            case 0:
                break;

            // vTrgBlt can only handle solid color fills where if the
            // destination is inverted, no other action is also required

            case R2_MASKNOTPEN:
            case R2_NOTCOPYPEN:
            case R2_XORPEN:
            case R2_MASKPEN:
            case R2_NOTXORPEN:
            case R2_MERGENOTPEN:
            case R2_COPYPEN:
            case R2_MERGEPEN:
            case R2_NOTMERGEPEN:
            case R2_MASKPENNOT:
            case R2_NOTMASKPEN:
            case R2_MERGEPENNOT:

                // vTrgBlt can only handle solid color fills

                if (pbo->iSolidColor != 0xffffffff)
                {
                    rbc.iSolidColor = pbo->iSolidColor;
                    pfnFill = vTrgBlt;
                }
                else
                {
                    rbc.prb = (RBRUSH*) pbo->pvRbrush;
                    if (rbc.prb == NULL)
                    {
                        rbc.prb = (RBRUSH*) BRUSHOBJ_pvGetRbrush(pbo);
                        if (rbc.prb == NULL)
                        {
                        // If we haven't realized the brush, punt the call:

                            break;
                        }
                    }
                    if (!(rbc.prb->fl & RBRUSH_BLACKWHITE) &&
                        ((mix & 0xff) != R2_COPYPEN))
                    {
                    // Only black/white brushes can handle ROPs other
                    // than COPYPEN:

                        break;
                    }

                    if (rbc.prb->fl & RBRUSH_NCOLOR)
                        pfnFill = vColorPat;
                    else
                        pfnFill = vMonoPat;
                }

                return(bPaintRgn(pso, pco, mix, rbc, pptlBrush, pfnFill));

            // Rops that are implicit solid colors

            case R2_NOT:
            case R2_WHITE:
            case R2_BLACK:

                // Brush color parameter doesn't matter for these rops

                // compiler error local variable 'rbc' used without having been initialized
                rbc.prb = NULL;
                rbc.iSolidColor = 0;

                return(bPaintRgn(pso, pco, mix, rbc, NULL, vTrgBlt));

            case R2_NOP:
                return(TRUE);

            default:
                break;
        }
    }

    rop4  = (gaMix[(mix >> 8) & 0x0F]) << 8;
    rop4 |= ((ULONG) gaMix[mix & 0x0F]);

    return(DrvBitBlt(
        pso,
        (SURFOBJ *) NULL,
        (SURFOBJ *) NULL,
        pco,
        (XLATEOBJ *) NULL,
        &pco->rclBounds,
        (POINTL *)  NULL,
        (POINTL *)  NULL,
        pbo,
        pptlBrush,
        rop4));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\screen.c ===
/******************************Module*Header*******************************\
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"


#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | \
                       FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,  \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH |    \
                       FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    (GCAPS_OPAQUERECT    | // Graphics capabilities
     GCAPS_PALMANAGED    |
     GCAPS_ALTERNATEFILL |
     GCAPS_WINDINGFILL   |
     GCAPS_MONO_DITHER   |
     GCAPS_COLOR_DITHER  ),

     // Should also implement GCAPS_HORIZSTRIKE so that the underlines
     // aren't drawn using DrvBitBlt

    SYSTM_LOGFONT,      // Default font description
    HELVE_LOGFONT,      // ANSI variable font description
    COURI_LOGFONT,      // ANSI fixed font description
    0,                  // Count of device fonts
    BMF_8BPP,           // Preferred DIB format
    8,                  // Width of color dither
    8,                  // Height of color dither
    0                   // Default palette to use for this device
};

/******************************Public*Routine******************************\
* bInitSURF
*
* Enables the surface.  Maps the frame buffer into memory.
*
\**************************************************************************/

BOOL bInitSURF(PPDEV ppdev, BOOL bFirst)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;

    // Set the mode.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         (LPVOID) &ppdev->ulMode,  // input buffer
                         sizeof(DWORD),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "Failed SET_CURRENT_MODE\n"));
        return(FALSE);
    }

    if (bFirst)
    {
        // Get the linear memory address range.

        VideoMemory.RequestedVirtualAddress = NULL;

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                             (PVOID) &VideoMemory, // input buffer
                             sizeof (VIDEO_MEMORY),
                             (PVOID) &VideoMemoryInfo, // output buffer
                             sizeof (VideoMemoryInfo),
                             &ReturnedDataLength))
        {
            DISPDBG((0, "Failed MAP_VIDEO_MEMORY\n"));
            return(FALSE);
        }
    }

    // Record the Frame Buffer Linear Address.

    if (bFirst)
    {
        ppdev->pjScreen =  (PBYTE) VideoMemoryInfo.FrameBufferBase;
    }

    // Set the various write mode values, so we don't have to read before write
    // later on

    vSetWriteModes(&ppdev->ulrm0_wmX);

    // Initialize the VGA registers to their default states, so that we
    // can be sure of drawing properly even when the miniport didn't
    // happen to set them the way we like them:

    vInitRegs(ppdev);

    // Since we just did a mode-set, we'll be in non-planar mode.  And make
    // sure we reset the bank manager (otherwise, after a switch from full-
    // screen, we may think we've got one bank mapped in, when in fact there's
    // a different one mapped in, and bad things would happen...).

    ppdev->flBank &= ~BANK_PLANAR;

    ppdev->rcl1WindowClip.bottom    = -1;
    ppdev->rcl2WindowClip[0].bottom = -1;
    ppdev->rcl2WindowClip[1].bottom = -1;

    ppdev->rcl1PlanarClip.bottom    = -1;
    ppdev->rcl2PlanarClip[0].bottom = -1;
    ppdev->rcl2PlanarClip[1].bottom = -1;

    return(TRUE);
}

/******************************Public*Routine******************************\
* vDisableSURF
*
* Disable the surface. Un-Maps the frame in memory.
*
\**************************************************************************/

VOID vDisableSURF(PPDEV ppdev)
{
    DWORD returnedDataLength;
    VIDEO_MEMORY videoMemory;

    videoMemory.RequestedVirtualAddress = (PVOID) ppdev->pjScreen;

    if (EngDeviceIoControl(ppdev->hDriver,
                        IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                        (LPVOID) &videoMemory,
                        sizeof(VIDEO_MEMORY),
                        NULL,
                        0,
                        &returnedDataLength))
    {
        RIP("Failed UNMAP_VIDEO_MEMORY");
    }
}

/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* Query mini-port to get information needed to fill in the DevInfo and the
* GdiInfo .
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;
    BANK_POSITION BankPosition;
    ULONG ulReturn;

    //
    // calls the miniport to get mode information.
    //

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);

    if (cModes == 0)
    {
        DISPDBG((0, "vga256.dll: no available modes\n"));
        return(FALSE);
    }

    //
    // Determine if we are looking for a default mode.
    //

    if ( ((pDevMode->dmPelsWidth) ||
          (pDevMode->dmPelsHeight) ||
          (pDevMode->dmBitsPerPel) ||
          (pDevMode->dmDisplayFlags) ||
          (pDevMode->dmDisplayFrequency)) == 0)
    {
        bSelectDefault = TRUE;
    }
    else
    {
        bSelectDefault = FALSE;
    }

    //
    // Now see if the requested mode has a match in that table.
    //

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pDevMode->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pDevMode->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                    pVideoTemp->NumberOfPlanes  == pDevMode->dmBitsPerPel) &&
                 (pVideoTemp->Frequency  == pDevMode->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((2, "vga256: Found a match\n")) ;
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);
    }

    //
    // If no mode has been found, return an error
    //

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((0, "vga256.dll: no valid modes\n"));
        EngFreeMem(pVideoBuffer);
        return(FALSE);
    }

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //

    ppdev->ulMode = pVideoModeSelected->ModeIndex;
    ppdev->cxScreen = pVideoModeSelected->VisScreenWidth;
    ppdev->cyScreen = pVideoModeSelected->VisScreenHeight;
    ppdev->ulBitCount = pVideoModeSelected->BitsPerPlane *
                        pVideoModeSelected->NumberOfPlanes;
    ppdev->lDeltaScreen = pVideoModeSelected->ScreenStride;

    ppdev->flRed = pVideoModeSelected->RedMask;
    ppdev->flGreen = pVideoModeSelected->GreenMask;
    ppdev->flBlue = pVideoModeSelected->BlueMask;

    if (!(pVideoModeSelected->AttributeFlags & VIDEO_MODE_NO_OFF_SCREEN))
    {
        ppdev->fl |= DRIVER_OFFSCREEN_REFRESHED;
    }

    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = pVideoModeSelected->XMillimeter;
    pGdiInfo->ulVertSize   = pVideoModeSelected->YMillimeter;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = ppdev->cxScreen;
    pGdiInfo->ulPanningVertRes = ppdev->cyScreen;
    pGdiInfo->cBitsPixel       = pVideoModeSelected->BitsPerPlane;
    pGdiInfo->cPlanes          = pVideoModeSelected->NumberOfPlanes;
    pGdiInfo->ulVRefresh       = pVideoModeSelected->Frequency;
    pGdiInfo->ulBltAlignment   = 8;     // Prefer 8-pel alignment of windows
                                        //   for fast text routines

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

    pGdiInfo->flTextCaps   = TC_RA_ABLE | TC_SCROLLBLT;
    pGdiInfo->flRaster     = 0;         // DDI reservers flRaster

    pGdiInfo->ulDACRed     = pVideoModeSelected->NumberRedBits;
    pGdiInfo->ulDACGreen   = pVideoModeSelected->NumberGreenBits;
    pGdiInfo->ulDACBlue    = pVideoModeSelected->NumberBlueBits;

    // Assuming palette is orthogonal - all colors are same size.

    ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;

    pGdiInfo->ulAspectX    = 0x24;      // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;         // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    // try to get it from the miniport.
    // if the miniport doesn ot support this feature, use defaults.

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES,
                         NULL,
                         0,
                         &colorCapabilities,
                         sizeof(VIDEO_COLOR_CAPABILITIES),
                         &ulTemp))
    {
        DISPDBG((1, "vga256 DISP getcolorCapabilities failed \n"));

        pGdiInfo->ciDevice.Red.x = 6700;
        pGdiInfo->ciDevice.Red.y = 3300;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = 2100;
        pGdiInfo->ciDevice.Green.y = 7100;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = 1400;
        pGdiInfo->ciDevice.Blue.y = 800;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
        pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
        pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

        pGdiInfo->ciDevice.RedGamma = 20000;
        pGdiInfo->ciDevice.GreenGamma = 20000;
        pGdiInfo->ciDevice.BlueGamma = 20000;

    }
    else
    {

        pGdiInfo->ciDevice.Red.x = colorCapabilities.RedChromaticity_x;
        pGdiInfo->ciDevice.Red.y = colorCapabilities.RedChromaticity_y;
        pGdiInfo->ciDevice.Red.Y = 0;
        pGdiInfo->ciDevice.Green.x = colorCapabilities.GreenChromaticity_x;
        pGdiInfo->ciDevice.Green.y = colorCapabilities.GreenChromaticity_y;
        pGdiInfo->ciDevice.Green.Y = 0;
        pGdiInfo->ciDevice.Blue.x = colorCapabilities.BlueChromaticity_x;
        pGdiInfo->ciDevice.Blue.y = colorCapabilities.BlueChromaticity_y;
        pGdiInfo->ciDevice.Blue.Y = 0;
        pGdiInfo->ciDevice.AlignmentWhite.x = colorCapabilities.WhiteChromaticity_x;
        pGdiInfo->ciDevice.AlignmentWhite.y = colorCapabilities.WhiteChromaticity_y;
        pGdiInfo->ciDevice.AlignmentWhite.Y = colorCapabilities.WhiteChromaticity_Y;

        // if we have a color device store the three color gamma values,
        // otherwise store the unique gamma value in all three.

        if (colorCapabilities.AttributeFlags & VIDEO_DEVICE_COLOR)
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.RedGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.GreenGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.BlueGamma;
        }
        else
        {
            pGdiInfo->ciDevice.RedGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.GreenGamma = colorCapabilities.WhiteGamma;
            pGdiInfo->ciDevice.BlueGamma = colorCapabilities.WhiteGamma;
        }

    };

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    // Fill in the rest of the devinfo and GdiInfo structures.

    pGdiInfo->ulNumColors = 20;
    pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

    pGdiInfo->ulDevicePelsDPI  = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
    pGdiInfo->ulHTPatternSize  = HT_PATSIZE_4x4_M;
    pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
    pGdiInfo->flHTFlags        = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *pDevInfo = gDevInfoFrameBuffer;

    EngFreeMem(pVideoBuffer);

    //
    // Try to determine if the miniport supports
    // IOCTL_VIDEO_SET_BANK_POSITION.
    //

    BankPosition.ReadBankPosition = 0;
    BankPosition.WriteBankPosition = 0;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_BANK_POSITION,
                         &BankPosition,
                         sizeof(BANK_POSITION),
                         NULL,
                         0,
                         &ulReturn) == NO_ERROR)
    {
        ppdev->BankIoctlSupported = TRUE;

    } else {

        ppdev->BankIoctlSupported = FALSE;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vInitSavedBits(ppdev)
*
* Initializes saved bits structures.  Must be done after bank
* initialization and vInitBrushCache.
*
\**************************************************************************/

VOID vInitSavedBits(PPDEV ppdev)
{
    if (!((ppdev->fl & DRIVER_OFFSCREEN_REFRESHED) &&
          (ppdev->fl & DRIVER_HAS_OFFSCREEN)))
    {
        return;
    }

    //
    // set up rect to right of visible screen
    //
    ppdev->rclSavedBitsRight.left   = ppdev->cxScreen;
    ppdev->rclSavedBitsRight.top    = 0;
    ppdev->rclSavedBitsRight.right  = max((ppdev->lNextScan-PELS_PER_DWORD),
                                          ppdev->rclSavedBitsRight.left);
    ppdev->rclSavedBitsRight.bottom = ppdev->cyScreen;

    //
    // set up rect below visible screen
    //
    ppdev->rclSavedBitsBottom.left   = 0;
    ppdev->rclSavedBitsBottom.top    = ppdev->cyScreen;
    ppdev->rclSavedBitsBottom.right  = ppdev->rclSavedBitsRight.right;
    ppdev->rclSavedBitsBottom.bottom = ppdev->cTotalScans - BRUSH_MAX_CACHE_SCANS;

    //
    // NOTE: we have subtracted one DWORD from the right edge.  This is because
    //       later it is assumed that we can align by right shifting by up to
    //       one DWORD (unless of course, the width of the buffer is 0).
    //

    ppdev->bBitsSaved = FALSE;

    DISPDBG((1,"ppdev->rclSavedBitsRight = (%04x,%04x,%04x,%04x)    %lux%lu\n",
            ppdev->rclSavedBitsRight.left,
            ppdev->rclSavedBitsRight.top,
            ppdev->rclSavedBitsRight.right,
            ppdev->rclSavedBitsRight.bottom,
            ppdev->rclSavedBitsRight.right - ppdev->rclSavedBitsRight.left,
            ppdev->rclSavedBitsRight.bottom - ppdev->rclSavedBitsRight.top
            ));

    DISPDBG((1,"ppdev->rclSavedBitsBottom = (%04x,%04x,%04x,%04x)    %lux%lu\n",
            ppdev->rclSavedBitsBottom.left,
            ppdev->rclSavedBitsBottom.top,
            ppdev->rclSavedBitsBottom.right,
            ppdev->rclSavedBitsBottom.bottom,
            ppdev->rclSavedBitsBottom.right - ppdev->rclSavedBitsBottom.left,
            ppdev->rclSavedBitsBottom.bottom - ppdev->rclSavedBitsBottom.top
            ));

    return;
}

/******************************Public*Routine******************************\
* VOID vInitBrushCache(ppdev)
*
* Initializes various brush cache structures.  Must be done after bank
* initialization.
*
\**************************************************************************/

VOID vInitBrushCache(PPDEV ppdev)
{
    LONG cCacheBrushesPerScan = ppdev->lNextScan / BRUSH_SIZE;
    LONG cCacheScans;
    LONG cCacheEntries;
    LONG i;
    LONG j;
    BRUSHCACHEENTRY* pbce;

    if (ppdev->cyScreen + BRUSH_MAX_CACHE_SCANS > (ULONG) ppdev->cTotalScans)
    {
        goto InitFailed;
    }

    cCacheScans = BRUSH_MAX_CACHE_SCANS;
    cCacheEntries = cCacheScans * cCacheBrushesPerScan;

    ppdev->pbceCache = (BRUSHCACHEENTRY*) EngAllocMem(FL_ZERO_MEMORY,
                       cCacheEntries * sizeof(BRUSHCACHEENTRY), ALLOC_TAG);

    if (ppdev->pbceCache == NULL)
    {
        goto InitFailed;
    }

    // We successfully managed to allocate all our data structures for looking
    // after off-screen memory, so set the flag saying that we can use it
    // (note that if ppdev->fl's DRIVER_OFFSCREEN_REFRESHED hasn't been set, the
    // memory cannot be used for long-term storage):

    ppdev->fl |= DRIVER_HAS_OFFSCREEN;

    ppdev->iCache     = 0;          // 0 is a reserved index
    ppdev->iCacheLast = cCacheEntries - 1;

    // Initialize our cache entry array:

    pbce    = &ppdev->pbceCache[0];

    for (i = (ppdev->cTotalScans-BRUSH_MAX_CACHE_SCANS); i < ppdev->cTotalScans; i++)
    {
        for (j = 0; j < cCacheBrushesPerScan; j++)
        {
            // Bitmap offset is in planar format, where every byte is one
            // quadpixel:

            pbce->yCache  = i;
            pbce->ulCache = (i * ppdev->lNextScan + j * BRUSH_SIZE) / 4;

            // This verification pointer doesn't actually have to be
            // initialized, but we do so for debugging purposes:

            pbce->prbVerifyRealization = NULL;

            pbce++;
        }
    }

    return;

InitFailed:
    ppdev->fl &= ~(DRIVER_OFFSCREEN_REFRESHED | DRIVER_HAS_OFFSCREEN);
    return;
}

/******************************Public*Routine******************************\
* VOID vResetBrushCache(ppdev)
*
* Blows away the brush cache entries -- this is useful when switching
* out of full-screen mode, where anyone could have written over the video
* memory where we cache our brushes.
*
\**************************************************************************/

VOID vResetBrushCache(PPDEV ppdev)
{
    BRUSHCACHEENTRY* pbce;
    LONG             i;

    // Make sure we actually have a brush cache before we try to reset it:

    if (ppdev->fl & DRIVER_HAS_OFFSCREEN)
    {
        pbce = &ppdev->pbceCache[0];
        for (i = ppdev->iCacheLast; i >= 0; i--)
        {
            pbce->prbVerifyRealization = NULL;
            pbce++;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache(ppdev)
*
* Frees various brush cache structures.
*
\**************************************************************************/

VOID vDisableBrushCache(PPDEV ppdev)
{
    if (ppdev->pbceCache != NULL)
    {
        EngFreeMem(ppdev->pbceCache);
    }
}

/******************************Public*Routine******************************\
* getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE hDriver,
PVIDEO_MODE_INFORMATION *modeInformation,
DWORD *cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "vga256 getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES\n"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "vga256 getAvailableModes failed EngAllocMem\n"));

        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "vga256 getAvailableModes failed VIDEO_QUERY_AVAIL_MODES\n"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // one of 8 bits per pel (that is all the vga 256 currently supports)
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->AttributeFlags & VIDEO_MODE_LINEAR) ||
            (pVideoTemp->BitsPerPlane != 8) ||
            (BROKEN_RASTERS(pVideoTemp->ScreenStride,
                           pVideoTemp->VisScreenHeight)))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return modes.NumModes;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\egavga.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:	EGAVGA.INC
;
; This file contains the external definitions of the EGA/VGA specific
; locations which driver output routines need to reference.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
; Restrictions:
;
;	The following rules apply to the use of the EGA/VGA registers
;	for the drivers (excluding pointer code and state detection
;	code):
;
;
;	1)  Routines are allowed to alter the following registers:
;
;	    Sequencer:
;
;		SEQ_DATA		SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_ADDR
;		GRAF_DATA		GRAF_DATA_ROT
;		GRAF_SET_RESET		GRAF_READ_MAP
;		GRAF_ENAB_SR		GRAF_MODE
;		GRAF_COL_COMP		GRAF_BIT_MASK
;
;
;	2)  The following registers will always contain the indicated
;	    value.  Routines are not allowed to alter them:
;
;	    Sequencer:
;
;		SEQ_ADDR	set to point SEQ_MAP_MASK
;
;	    Graphics Controller:
;
;		GRAF_CDC	set appropriately for color model
;
;
;	3)  Rotation counts for GRAF_DATA_ROT are not allowed.
;
;
;	4)  The following EGA/VGA registers will contain the indicated
;	    value upon entry to a routine.  Any routine which alters
;	    them must restore them to the indicated state.
;
;		Map Mask	    all planes enabled
;		Enable Set/Reset    all planes disabled
;		Data Rotate	    Set, no rotation
;		Mode		    Processor write, data read
;		Bit Mask	    all bits enabled
;
;
;	5)  The Mode Register is always shadowed in EGA/VGA memory for
;	    the state detection code.  At interrupt time, the mode
;	    will be restored from the structure "shadowed_graf_mode".
;	    Any routine altering the Mode Register must keep this location
;	    current.  This is the only EGA/VGA register which requires
;	    shadowing.
;
;
;	6)  Pointer drawing will save and restore the contents of
;	    the processor latches.
;
;
;	7)  Pointer drawing will leave GRAF_ADDR set to GRAF_BIT_MASK.
;
;-----------------------------------------------------------------------;

;	Miscellaneous Registers used only at EGA/VGA initialization time

MISC_OUTPUT	EQU	0C2h		;Miscellaneous Output Register
CRTC_ADDR	EQU	0D4h		;CRTC Address Register for color mode
CRTC_DATA	EQU	0D5h		;CRTC Data    Register for color mode
GRAF_1_POS	EQU	0CCh		;Graphics 1 Address Register
GRAF_2_POS	EQU	0CAh		;Graphics 2 Address Register
ATTR_READ	EQU	0DAh		;Attribute Controler Read  Address
ATTR_WRITE	EQU	0C0h		;Attribute Controler Write Address
IN_STAT_0	EQU	0C2h		;Input Status Register 0
IN_STAT_1	EQU	0DAh		;Input Status Register 1



;	EGA/VGA Register Definitions.
;
;	The following definitions are the EGA/VGA registers and values
;	used by this driver.  All other registers are set up at
;	when the EGA/VGA is placed into graphics mode and never altered
;	afterwards.
;
;	All unspecified bits in the following registers must be 0.


EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)



;	EGA/VGA Register Definitions.

EGA_BASE	EQU	300h		;Base address of the EGA (3xx)
VGA_BASE	EQU	300h		;Base address of the VGA (3xx)

;	SEQUencer Registers Used

SEQ_ADDR	EQU	0C4h		;SEQUencer Address Register
SEQ_DATA	EQU	0C5h		;SEQUencer Data    Register

SEQ_MAP_MASK	EQU	02h		;Write Plane Enable Mask
MM_C0		EQU	00000001b	;  C0 plane enable
MM_C1		EQU	00000010b	;  C1 plane enable
MM_C2		EQU	00000100b	;  C2 plane enable
MM_C3		EQU	00001000b	;  C3 plane enable
MM_ALL		EQU	00001111b	;  All planes

SEQ_MODE	EQU	04h		;Memory Mode
SM_ALPHA	EQU	00000001b	;  Char map select enable
SM_EXTENDED	EQU	00000010b	;  Extended memory present
SM_ODD_PLANE	EQU	00000100b	;  Odd/even bytes to same plane


;	Graphics Controller Registers Used

GRAF_ADDR	EQU	0CEh		;Graphics Controller Address Register
GRAF_DATA	EQU	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	EQU	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	EQU	01h		;  Set/Reset Enable
GRAF_COL_COMP	EQU	02h		;  Color Compare Register

GRAF_DATA_ROT	EQU	03h		;  Data Rotate Register
DR_ROT_CNT	EQU	00000111b	;    Data Rotate Count
DR_SET		EQU	00000000b	;    Data Unmodified
DR_AND		EQU	00001000b	;    Data ANDed with latches
DR_OR		EQU	00010000b	;    Data ORed	with latches
DR_XOR		EQU	00011000b	;    Data XORed with latches

GRAF_READ_MAP	EQU	04h		;  Read Map Select Register
RM_C0		EQU	00000000b	;    Read C0 plane
RM_C1		EQU	00000001b	;    Read C1 plane
RM_C2		EQU	00000010b	;    Read C2 plane
RM_C3		EQU	00000011b	;    Read C3 plane

GRAF_MODE	EQU	05h		;  Mode Register
M_PROC_WRITE	EQU	00000000b	;    Write processor data rotated
M_LATCH_WRITE	EQU	00000001b	;    Write latched data
M_COLOR_WRITE	EQU	00000010b	;    Write processor data as color
M_AND_WRITE	EQU	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	EQU	00000000b	;    Read selected plane
M_COLOR_READ	EQU	00001000b	;    Read color compare

GRAF_MISC	EQU	06h		;  Miscellaneous Register
MS_NON_ALPHA	EQU	00000001b	;    Char generator disabled
MS_ODD_EVEN	EQU	00000010b	;    Map odd addresses to even
MS_A0000_128K	EQU	00000000b	;    Memory present at A0000, 128kb
MS_A0000_64K	EQU	00000100b	;    Memory present at A0000, 64kb
MS_B0000_32K	EQU	00001000b	;    Memory present at B0000, 32kb
MS_B8000_32K	EQU	00001100b	;    Memory present at B8000, 32kb
MS_ADDR_MASK	EQU	00001100b

GRAF_CDC	EQU	07h		;  Color Don't Care Register
GRAF_BIT_MASK	EQU	08h		;  Bit Mask Register


;       Various sizes for EGA/VGA data structures

;-----------------------------------------------------------------------;
; On the EGA/VGA, the number of bits/pel is 4
; The number of bytes per scan is 80
;-----------------------------------------------------------------------;

BITS_PEL        EQU     4

;-----------------------------------------------------------------------;
; Helper flags for the xyCreateMasks call
;-----------------------------------------------------------------------;

PTRI_INVERT     EQU     1   ; !!! In WINGDIP.H when H2INC works
PTRI_ANIMATE    EQU     2   ; !!! In WINGDIP.H when H2INC works

;-----------------------------------------------------------------------;
; The pointer parameters are the size of the pointer as received from
; DeviceSetCursor.
;-----------------------------------------------------------------------;

PTR_HEIGHT	EQU	32
PTR_WIDTH	EQU	4			;Width in bytes of pointer
PTR_WIDTH_BITS	EQU	PTR_WIDTH*8		;Width in bits of pointer

;-----------------------------------------------------------------------;
; The work width/height is the size of a pointer as manipulated by
; the pointer drawing code.
;-----------------------------------------------------------------------;

WORK_WIDTH	EQU	PTR_WIDTH+1		;Width of mask, work area
WORK_HEIGHT	EQU	PTR_HEIGHT+0		;Height of mask, work area
MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT	;#bytes in mask, work area
CLR_MASK_LENGTH	EQU	WORK_WIDTH*WORK_HEIGHT*BITS_PEL	;#bytes in color mask
	.errnz	BITS_PEL-4

;-----------------------------------------------------------------------;
; The save area parameters control the size of the buffer used for
; saveing the bits underneath the pointer image.  It should be a
; power of two to allow for easy wrap calculations.
;-----------------------------------------------------------------------;

SAVE_BUFFER_WIDTH  EQU	  8			  ;Width  of the save area
SAVE_BUFFER_HEIGHT EQU	  32			  ;Height of the save area
		   .errnz  PTR_WIDTH  GT SAVE_BUFFER_WIDTH
		   .errnz  PTR_HEIGHT GT SAVE_BUFFER_HEIGHT



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\savescr.c ===
/******************************Module*Header*******************************\
* Module Name: savescr.c                                                   *
*                                                                          *
* DrvSaveScreenBits                                                        *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/


#include <driver.h>

// This is just a unique ID that the driver will recongize.  Hopefully,
// nothing will ever call with this ID by pure chance.

#define     SAVED_OFFSCREEN_ID      0x7813

ULONG       ulSaveOrRestoreBits(SURFOBJ *,PPDEV,RECTL *,BOOL);

/******************************Public*Routine******************************\
* DrvSaveScreenBits(pso,iMode,iIdent,prcl)                                 *
*                                                                          *
* Saves and restores the specified area of the screen                      *
*                                                                          *
\**************************************************************************/

ULONG DrvSaveScreenBits(SURFOBJ *pso, ULONG iMode, ULONG iIdent, RECTL *prcl)
{
    PPDEV ppdev;
    ULONG ulRet;

    ppdev = (PPDEV) pso->dhpdev;    // find the PDEV that goes with this surface

    if (!((ppdev->fl & DRIVER_OFFSCREEN_REFRESHED) &&
          (ppdev->fl & DRIVER_HAS_OFFSCREEN)))
    {
        return(0);
    }

    switch(iMode)
    {
        case SS_SAVE:

            //
            // Save a block of screen bits.
            //

            if (ppdev->bBitsSaved)
            {
                DISPDBG((1, "DrvSaveScreenBits: off screen area is already in use\n"));
                return(FALSE);      // there are already valid bits saved
            }

            ulRet = ulSaveOrRestoreBits(pso, ppdev, prcl, TRUE);
            if (ulRet)
            {
                ppdev->bBitsSaved = TRUE;
            }
            else
            {
                DISPDBG((1, "DrvSaveScreenBits (save): save couldn't fit\n"));
            }

            return(ulRet);

        case SS_RESTORE:

            //
            // Restore a saved screen bits block to the screen, then free it.
            //

            ASSERTVGA(iIdent == SAVED_OFFSCREEN_ID,
                      "DrvSaveScreenBits (restore): invalid iIdent\n");
            ASSERTVGA(ppdev->bBitsSaved == TRUE,
                      "DrvSaveScreenBits (restore): there are no saved bits\n");

            ppdev->bBitsSaved = FALSE;  // successful or not, destroy the bits

            if (!ulSaveOrRestoreBits(pso, ppdev, prcl, FALSE))
            {
                RIP("DrvSaveScreenBits (restore): restore failed\n");
            }

            return(TRUE);

        case SS_FREE:

            //
            // Free up the saved screen bits
            //

            ppdev->bBitsSaved = FALSE;
            return(TRUE);

        default:

            //
            // An unknown mode was passed in.
            //

            RIP("DrvSaveScreenBits: invalid iMode");
    }

    //
    // error if you get to here
    //

    return(FALSE);
}


/******************************Public*Routine******************************\
* vCopyRects(pso,ppdev,prclSrc,prclTrg,cxPad,bIsSave)                      *
*                                                                          *
* Breaks prclSrc up and copies the parts into prclTrg                      *
*                                                                          *
\**************************************************************************/

VOID vCopyRects(SURFOBJ *pso, PPDEV ppdev, RECTL * prclSrc, RECTL * prclTrg,
                LONG cxPad,  BOOL bIsSave)
{
    RECTL rclOnScreen;
    RECTL rclOffScreen;
    POINTL * pptlSrcTmp;
    RECTL * prclTrgTmp;
    ULONG cx, cy;
    ULONG cAlign;

    // We are assuming here that either the Trg is wider than the Src, or
    // the Trg is taller than the src.

    // We are assuming that if there is a nonzero cxPad, we are copying to
    // a rectangle such that the src is taller than the dst.
    // In other words, the prclTrg is a rectangle in the bottom offscreen
    // memory region, and the prclSrc needs to be broken up.

    ASSERTVGA(cxPad == 0 ||
              (prclSrc->bottom - prclSrc->top > prclTrg->bottom - prclTrg->top),
              "DrvSaveScreenBits: vCopyRects - cxPad is invalid\n");

    // Make sure that the src and trg are dword aligned.

    cAlign = (((prclSrc->left) - (prclTrg->left)) & (PELS_PER_DWORD - 1));

    if ((prclSrc->right - prclSrc->left) > prclTrg->right - prclTrg->left)
    {
        if ((prclSrc->bottom - prclSrc->top) >= prclTrg->bottom - prclTrg->top)
        {
            RIP("DrvSaveScreenBits: vCopyRects src is bigger than trg\n");
        }

        //
        // we need to break it up into vertical strips
        //

        cx = prclTrg->right - prclTrg->left;
        cy = prclSrc->bottom - prclSrc->top;

        ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (v save width == 0)\n");
        ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (v save height == 0)\n");

        rclOnScreen.right  = prclSrc->left;
        rclOnScreen.top    = prclSrc->top;
        rclOnScreen.bottom = prclSrc->top + cy;

        rclOffScreen.left  = prclTrg->left;
        rclOffScreen.bottom = prclTrg->top;

        // align offscreen rect to src

        rclOffScreen.left += cAlign;

        /* local variable used without having been initialized */
        // rclOffScreen.right += cAlign;

        while (rclOnScreen.right < prclSrc->right)
        {
            cx = min(cx,(ULONG)(prclSrc->right - rclOnScreen.right));
            ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (cx == 0)\n");
            rclOnScreen.left = rclOnScreen.right;
            rclOnScreen.right += cx;
            rclOffScreen.right = rclOffScreen.left + cx; // in case cx is thinner on last
            rclOffScreen.top = rclOffScreen.bottom;
            rclOffScreen.bottom += cy;

            if (rclOffScreen.bottom > prclTrg->bottom)
            {
                RIP("DrvSaveScreenBits: vCopyRects can't fit src into trg (vertical)\n");
            }

            if (bIsSave)
            {
                // save
                pptlSrcTmp = (POINTL *) &rclOnScreen;
                prclTrgTmp = &rclOffScreen;

                DISPDBG((1,"DrvSaveScreenBits (v save):    "));
            }
            else
            {
                // restore
                pptlSrcTmp = (POINTL *) &rclOffScreen;
                prclTrgTmp = &rclOnScreen;

                DISPDBG((1,"DrvSaveScreenBits (v restore): "));
            }

            DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                    rclOffScreen.left,
                    rclOffScreen.top,
                    rclOffScreen.right,
                    rclOffScreen.bottom,
                    rclOffScreen.right - rclOffScreen.left,
                    rclOffScreen.bottom - rclOffScreen.top
                    ));

            ASSERTVGA (((prclTrgTmp->left ^ pptlSrcTmp->x) &
                        (PELS_PER_DWORD - 1)) == 0,
                       "DrvSaveScreenBits (v): Src and Target are not aligned\n");

            DrvCopyBits(pso,                // psoDst   (screen)
                        pso,                // psoSrc   (screen)
                        NULL,               // pco      (none)
                        NULL,               // pxlo     (none)
                        prclTrgTmp,         // prclDst
                        pptlSrcTmp);        // pptlSrc
        }
    }
    else if ((prclSrc->bottom - prclSrc->top) > prclTrg->bottom - prclTrg->top)
    {
        //
        // we need to break it up into horizontal strips
        //

        cx = prclSrc->right - prclSrc->left;
        cy = prclTrg->bottom - prclTrg->top;

        ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (h save width == 0)\n");
        ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (h save height == 0)\n");

        rclOnScreen.bottom = prclSrc->top;
        rclOnScreen.left   = prclSrc->left;
        rclOnScreen.right  = prclSrc->left + cx;

        rclOffScreen.top  = prclTrg->top;
        rclOffScreen.right = prclTrg->left - cxPad;

        // align offscreen rect to src

        rclOffScreen.right += cAlign;

        while (rclOnScreen.bottom < prclSrc->bottom)
        {
            cy = min(cy,(ULONG)(prclSrc->bottom - rclOnScreen.bottom));
            ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (cy == 0)\n");
            rclOnScreen.top = rclOnScreen.bottom;
            rclOnScreen.bottom += cy;
            rclOffScreen.bottom = rclOffScreen.top + cy; // in case cy is shorter on last
            rclOffScreen.left = rclOffScreen.right + cxPad;
            rclOffScreen.right = rclOffScreen.left + cx;

            if (rclOffScreen.right > (prclTrg->right + (LONG)cAlign))
            {
                RIP("DrvSaveScreenBits: vCopyRects can't fit src into trg (horizontal)\n");
            }

            if (bIsSave)
            {
                // save
                pptlSrcTmp = (POINTL *) &rclOnScreen;
                prclTrgTmp = &rclOffScreen;

                DISPDBG((1,"DrvSaveScreenBits (h save):    "));
            }
            else
            {
                // restore
                pptlSrcTmp = (POINTL *) &rclOffScreen;
                prclTrgTmp = &rclOnScreen;

                DISPDBG((1,"DrvSaveScreenBits (h restore): "));
            }

            DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                    rclOffScreen.left,
                    rclOffScreen.top,
                    rclOffScreen.right,
                    rclOffScreen.bottom,
                    rclOffScreen.right - rclOffScreen.left,
                    rclOffScreen.bottom - rclOffScreen.top
                    ));

            ASSERTVGA (((prclTrgTmp->left ^ pptlSrcTmp->x) &
                        (PELS_PER_DWORD - 1)) == 0,
                       "DrvSaveScreenBits (h): Src and Target are not aligned\n");

            DrvCopyBits(pso,                // psoDst   (screen)
                        pso,                // psoSrc   (screen)
                        NULL,               // pco      (none)
                        NULL,               // pxlo     (none)
                        prclTrgTmp,         // prclDst
                        pptlSrcTmp);        // pptlSrc
        }
    }
    else
    {
        // we don't need to break it up at all

        cx = prclSrc->right - prclSrc->left;
        cy = prclSrc->bottom - prclSrc->top;

        ASSERTVGA(cx != 0, "DrvSaveScreenBits: vCopyRects (save width == 0)\n");
        ASSERTVGA(cy != 0, "DrvSaveScreenBits: vCopyRects (save height == 0)\n");

        rclOffScreen.left   = prclTrg->left;
        rclOffScreen.right  = prclTrg->left + cx;
        rclOffScreen.top    = prclTrg->top;
        rclOffScreen.bottom = prclTrg->top + cy;

        // align offscreen rect to src

        rclOffScreen.left += cAlign;
        rclOffScreen.right += cAlign;

        if (bIsSave)
        {
            // save
            pptlSrcTmp = (POINTL *) prclSrc;
            prclTrgTmp = &rclOffScreen;

            DISPDBG((1,"DrvSaveScreenBits (save):    "));
        }
        else
        {
            // restore
            pptlSrcTmp = (POINTL *) &rclOffScreen;
            prclTrgTmp = prclSrc;

            DISPDBG((1,"DrvSaveScreenBits (restore): "));
        }

        DISPDBG((1,"%08x,%08x,%08x,%08x    %lux%lu\n",
                rclOffScreen.left,
                rclOffScreen.top,
                rclOffScreen.right,
                rclOffScreen.bottom,
                rclOffScreen.right - rclOffScreen.left,
                rclOffScreen.bottom - rclOffScreen.top
                ));

        ASSERTVGA (((prclTrgTmp->left ^ pptlSrcTmp->x) &
                    (PELS_PER_DWORD - 1)) == 0,
                   "DrvSaveScreenBits: Src and Target are not aligned\n");

        DrvCopyBits(pso,                // psoDst   (screen)
                    pso,                // psoSrc   (screen)
                    NULL,               // pco      (none)
                    NULL,               // pxlo     (none)
                    prclTrgTmp,         // prclDst
                    pptlSrcTmp);        // pptlSrc
    }

    return;
}


/******************************Public*Routine******************************\
* ulSaveOrRestoreBits(pso, ppdev,prcl,bIsSave)                             *
*                                                                          *
* Saves or restores the specified area of the screen                       *
*                                                                          *
\**************************************************************************/

ULONG ulSaveOrRestoreBits(SURFOBJ *pso, PPDEV ppdev, RECTL * prcl, BOOL bIsSave)
{
    ULONG dxDstBottom, dyDstBottom; // width, height of bottom edge off screen area
    ULONG dxDstRight, dyDstRight;   // width, height of right edge off screen area
    ULONG dxSrc,  dySrc;            // width, height of screen area to copy
    RECTL rclSrcRight;              // portion of *prcl to go into right edge area
    RECTL rclSrcBottom;             // portion of *prcl to go into bottom edge area
    ULONG dxPadBottom;              // width of spacer required to keep all copies
                                    //   after the first aligned in the bottom
                                    //   rectangle
    //
    // Saves bits from visible VGA memory in unused VGA memory
    //

    dxDstBottom = ppdev->rclSavedBitsBottom.right - ppdev->rclSavedBitsBottom.left;
    dyDstBottom = ppdev->rclSavedBitsBottom.bottom - ppdev->rclSavedBitsBottom.top;
    dxDstRight  = ppdev->rclSavedBitsRight.right - ppdev->rclSavedBitsRight.left;
    dyDstRight  = ppdev->rclSavedBitsRight.bottom - ppdev->rclSavedBitsRight.top;
    dxSrc       = prcl->right - prcl->left;
    dySrc       = prcl->bottom - prcl->top;

    // see if rect fits in lower rect, unbroken
    // this is the most common case!

    if (dySrc <= dyDstBottom  && dxSrc <= dxDstBottom)
    {
        // YES!

        DISPDBG((1,"DrvSaveScreenBits: bits all fit into bottom rect\n"));
        vCopyRects(pso,
                   ppdev,
                   prcl,
                   &ppdev->rclSavedBitsBottom,
                   0,
                   bIsSave);
        return(SAVED_OFFSCREEN_ID);
    }

    // see if rect fits in right rect, unbroken

    if (dySrc <= dyDstRight && dxSrc <= dxDstRight)
    {
        // YES!

        DISPDBG((1,"DrvSaveScreenBits: bits all fit into right rect\n"));
        vCopyRects(pso,
                   ppdev,
                   prcl,
                   &ppdev->rclSavedBitsRight,
                   0,
                   bIsSave);
        return(SAVED_OFFSCREEN_ID);
    }

    //
    // before we bother to break it up, see if it could even POSSIBLY fit
    //

    if ((dxSrc * dySrc) > ((dxDstRight * dyDstRight) + (dxDstBottom * dyDstBottom)))
    {
        // Forget it bud.  There are more bytes to save than we have total.
        // Don't bother checking for best fit.

        return(0);
    }

    // ARGGGHHHH!

    //
    // split source rectangle into two rectangles and see if they fit
    //

    rclSrcRight = rclSrcBottom = *prcl;

    //
    // see how many strips of height dySrc we can get into the rclDstRight
    // (of height dyDstRight) and then divide the rclSrc rectangles so
    // that rclSrcRight has that many strips and rclSrcBottom has what's left
    //
    rclSrcBottom.left = rclSrcRight.right =
        min(rclSrcBottom.right,
            rclSrcRight.left + (LONG)(dxDstRight * (dyDstRight/dySrc)));

    //
    // FYI: rclSrcRight WILL fit into ppdev->rclSavedBitsBottom because that's
    //      how its size was determined
    //

    // dxPadBottom = (-x) & (PELS_PER_DWORD - 1) where x is the width of
    // the rectangle that we want to break up and put into the bottom offscreen
    // area.  Therefore, ((rclSrcBottom.right-rclSrcBottom.left)+dxPadBottom)
    // will be a number of pels that is a DWORD multiple.

    dxPadBottom = (rclSrcBottom.left-rclSrcBottom.right) & (PELS_PER_DWORD - 1);

    if (((rclSrcBottom.right-rclSrcBottom.left) == 0) ||
        ((dySrc/dyDstBottom) <
         (dxDstBottom/((rclSrcBottom.right-rclSrcBottom.left)+dxPadBottom))))
    {
        //
        // rclSrcBottom fits into ppdev->rclSavedBitsBottom
        //

        if ((rclSrcRight.right - rclSrcRight.left) > 0)
        {
            //
            // there is data that should go into the right edge area
            //

            vCopyRects(pso,
                       ppdev,
                       &rclSrcRight,
                       &ppdev->rclSavedBitsRight,
                       0,
                       bIsSave);
        }

        if (((rclSrcBottom.right - rclSrcBottom.left) > 0) &&
            ((rclSrcBottom.bottom - rclSrcBottom.top) > 0))
        {
            //
            // there is data that should go into the bottom area
            //

            vCopyRects(pso,
                       ppdev,
                       &rclSrcBottom,
                       &ppdev->rclSavedBitsBottom,
                       dxPadBottom,
                       bIsSave);
        }

        return(SAVED_OFFSCREEN_ID);

    }

    // All that @#!&ing work, and we just barely missed fitting in.

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* DrvStretchBlt
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

//@@@ This should become a VOID when all cases are handled in the stretching
//@@@ code, and should go in driver.h
INT vStretchBlt8bpp(PPDEV ppdev, PBYTE pSrc, LONG lSrcNext,
                    PRECTL prclSrc, PRECTL prclDest, PRECTL prclDestClip,
                    PULONG pulXlatVector);

BOOL DrvStretchBlt(
SURFOBJ         *psoDest,
SURFOBJ         *psoSrc,
SURFOBJ         *psoMask,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
COLORADJUSTMENT *pca,
POINTL          *pptlBrushOrg,
RECTL           *prclDest,
RECTL           *prclSrc,
POINTL          *pptlMask,
ULONG            iMode)
{
    PPDEV  ppdev = (PPDEV) psoDest->dhpdev;
    PULONG pulXlatVector;
    INT    iClipping;

    // Handle only cases where the source is a DIB and the destination is
    // the VGA surface (which is always the case here if the source is a
    // DIB). Also, halftoning and masking aren't handled by the special-case
    // code. We only handle the case where a single source pixel is mapped onto
    // each destination pixel
    if ((iMode == COLORONCOLOR) &&
        (psoSrc->iType == STYPE_BITMAP) &&
        (psoMask == NULL)) {

        // We don't special case X or Y inversion for now
        if ((prclDest->left < prclDest->right) &&
            (prclDest->top < prclDest->bottom)) {

            // We don't special-case cases where the source has to be clipped
            // to the source bitmap extent
            if ((prclSrc->left >= 0) &&
                (prclSrc->top >= 0)  &&
                (prclSrc->right <= psoSrc->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrc->sizlBitmap.cy)) {

                // Set up the clipping type
                if (pco == (CLIPOBJ *) NULL) {
                    // No CLIPOBJ provided, so we don't have to worry about
                    // clipping
                    iClipping = DC_TRIVIAL;
                } else {
                    // Use the CLIPOBJ-provided clipping
                    iClipping = pco->iDComplexity;
                }

                // We don't special-case clipping for now
                if (iClipping != DC_COMPLEX) {

                    switch(psoSrc->iBitmapFormat) {
                        case BMF_1BPP:
                            break;

                        case BMF_4BPP:
                            break;

                        case BMF_8BPP:

                            // Set up the color translation, if any
                            if ((pxlo == NULL) ||
                                    (pxlo->flXlate & XO_TRIVIAL)) {
                                pulXlatVector = NULL;
                            } else {
                                if (pxlo->pulXlate != NULL) {
                                    pulXlatVector = pxlo->pulXlate;
                                } else {
                                    if ((pulXlatVector =
                                            XLATEOBJ_piVector(pxlo)) == NULL) {
                                        return FALSE;
                                    }
                                }
                            }

                            //if the Dest is wider than 1024, it won't fit
                            //into our 4K global buffer.  For each pixel across,
                            //we store a 4 byte DDA step in the buffer.

                            if ((prclDest->right - prclDest->left) <=
                                (GLOBAL_BUFFER_SIZE/sizeof(DWORD)))
                            {
                                //@@@ won't need to test return code once both
                                //@@@ expand cases are also handled in the
                                //@@@ stretching code

                                if (vStretchBlt8bpp(ppdev,
                                                    psoSrc->pvScan0,
                                                    psoSrc->lDelta,
                                                    prclSrc,
                                                    prclDest,
                                                    (iClipping == DC_TRIVIAL) ?
                                                     NULL :
                                                     &pco->rclBounds,
                                                    pulXlatVector))
                                {
                                    return(TRUE);
                                }
                            }
                            break;

                        case BMF_16BPP:
                            break;

                        case BMF_24BPP:
                            break;

                        case BMF_32BPP:
                            break;

                        default:
                            break;
                    }
                }
            }
        }
    }

    return(EngStretchBlt(psoDest,
                         psoSrc,
                         psoMask,
                         pco,
                         pxlo,
                         pca,
                         pptlBrushOrg,
                         prclDest,
                         prclSrc,
                         pptlMask,
                         iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\colorpat.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: colorpat.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation.  All rights reserved.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; BOOL vColorPat(ppdev, culRcl, prcl, ulMix, prb, pptlBrush)
;
; Input:
;
;  ppdev     - surface on which to draw
;  culRcl    - number of rectangles
;  prcl      - pointer to rectangles
;  ulMix     - mix mode
;  prb       - pointer to realized brush
;  pptlBrush - brush alignment
;
; Draws n-color 8x8 patterns using the latches -- we load the latches
; with one part of the pattern, and write the result whereever that
; part of the pattern is repeated; then, we load the latches for the next
; part of the pattern, and repeat the process.
;
; We special case brushes that are really 4 pels wide (i.e., the left and
; right halves of the 8x8 brush are the same), because we can light 8
; pixels on every word write to the VGA memory.  We still have to 'venetian
; blind' vertically -- i.e., load the latches with one row of the pattern,
; and write on every 8th scan line of the screen, then load the latches
; with the second row of the pattern, and repeat the process one scan lower.
;
; For brushes that are actually 8 pels wide, we also horizontally-venetian
; blind.
;
; We also handle patterns that are really only 4 or 2 pels high, because
; then we don't have to laod the latches as often, and the venetian
; blinding isn't as visually obvious.
;
; We only do all this with 1R/1W or 2R/W adapters.  We make an off-screen
; cache of brushes, and always keep one bank pointing to the brush, while
; the other bank points to the pattern destination; this way, it's easy
; to load the latches with the appropriate part of the pattern.
;
;-----------------------------------------------------------------------;
;
; NOTE: Assumes all rectangles have positive heights and widths.  Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc
        include i386\ropdefs.inc

        .list

        .data

; Function to map in two windows at the same time:

;-----------------------------------------------------------------------;
; Bits for drawing routine 8xN look-ups.

BLOCK_8xN_LEFT_EDGE               equ 000100b
BLOCK_8xN_RIGHT_EDGE              equ 000010b
BLOCK_8xN_NO_MIDDLE               equ 000001b

;-----------------------------------------------------------------------;
; Bits for drawing routine 4xN look-ups.

BLOCK_4xN_LEFT_EDGE               equ 010000b
BLOCK_4xN_RIGHT_EDGE              equ 001000b
BLOCK_4xN_MIDDLE_STARTS_UNALIGNED equ 000100b
BLOCK_4xN_NO_MIDDLE               equ 000010b
BLOCK_4xN_MIDDLE_ENDS_UNALIGNED   equ 000001b

;-----------------------------------------------------------------------;
; Table of drawing routines, with the look-up index a 3 bit field as
; follows:
;
; Bit 2 = 1 if a left edge must be drawn
; Bit 1 = 1 if a right edge must be drawn
; Bit 0 = 1 if no middle block

        align   4
gapfn8xN label dword
        dd      middle_8xN              ;000
        dd      0                       ;001
        dd      Block_MR_8xN            ;010
        dd      right_8xN               ;011
        dd      Block_LM_8xN            ;100
        dd      left_8xN                ;101
        dd      Block_LMR_8xN           ;110
        dd      Block_LR_8xN            ;111

        align   4
gapfn4xN label dword
        dd      middle_00_4xN           ;00000
        dd      middle_01_4xN           ;00001
        dd      0                       ;00010
        dd      0                       ;00011
        dd      middle_11_4xN           ;00100
        dd      middle_10_4xN           ;00101
        dd      0                       ;00110
        dd      0                       ;00111
        dd      Block_01000_4xN         ;01000
        dd      Block_01001_4xN         ;01001
        dd      right_8xN               ;01010
        dd      right_8xN               ;01011
        dd      Block_01100_4xN         ;01100
        dd      Block_01101_4xN         ;01101
        dd      right_8xN               ;01110
        dd      right_8xN               ;01111
        dd      Block_10000_4xN         ;10000
        dd      Block_10001_4xN         ;10001
        dd      left_8xN                ;10010
        dd      left_8xN                ;10011
        dd      Block_10100_4xN         ;10100
        dd      Block_10101_4xN         ;10101
        dd      left_8xN                ;10110
        dd      left_8xN                ;10111
        dd      Block_11000_4xN         ;11000
        dd      Block_11001_4xN         ;11001
        dd      Block_11010_4xN         ;11010
        dd      0                       ;11011 - can never happen
        dd      Block_11100_4xN         ;11100
        dd      Block_11101_4xN         ;11101
        dd      Block_11110_4xN         ;11110
        dd      0                       ;11111 - can never happen

        .code

        EXTRNP  vPlanarDouble,20

;-----------------------------------------------------------------------;

Block_MR_8xN:
        push    offset right_8xN
        jmp     middle_8xN

Block_LM_8xN:
        push    offset left_8xN
        jmp     middle_8xN

Block_LMR_8xN:
        push    offset right_8xN
        push    offset left_8xN
        jmp     middle_8xN

Block_LR_8xN:
        push    offset right_8xN
        jmp     left_8xN

;-----------------------------------------------------------------------;

Block_01000_4xN:
        push    offset right_8xN
        jmp     middle_00_4xN

Block_01001_4xN:
        push    offset right_8xN
        jmp     middle_01_4xN

Block_01100_4xN:
        push    offset right_8xN
        jmp     middle_11_4xN

Block_01101_4xN:
        push    offset right_8xN
        jmp     middle_10_4xN

Block_11000_4xN:
        push    offset right_8xN
Block_10000_4xN:
        push    offset left_8xN
        jmp     middle_00_4xN

Block_11001_4xN:
        push    offset right_8xN
Block_10001_4xN:
        push    offset left_8xN
        jmp     middle_01_4xN

Block_11100_4xN:
        push    offset right_8xN
Block_10100_4xN:
        push    offset left_8xN
        jmp     middle_11_4xN

Block_11101_4xN:
        push    offset right_8xN
Block_10101_4xN:
        push    offset left_8xN
        jmp     middle_10_4xN

Block_11010_4xN:
        push    offset right_8xN
        jmp     left_8xN

Block_11110_4xN:
        push    offset right_8xN
        jmp     left_8xN

;-----------------------------------------------------------------------;

cProc   vColorPat,24,<        \
        uses esi edi ebx,     \
        ppdev:     ptr PDEV,  \
        culRcl:    dword,     \
        prcl:      ptr RECTL, \
        ulMix:     dword,     \
        prb:       ptr RBRUSH,\
        pptlBrush: ptr POINTL >

        local pfnDraw:             ptr   ;pointer to draw routines

        local yBrushTimesTwo:      dword ;current y brush alignment
        local yBrushSave:          dword ;temp for saving y brush alignment
        local yBrushOrg:           dword ;original y brush alignment
        local ulMiddleDest:        dword ;bitmap offset to middle
        local ulBlockHeight:       dword ;# of scans to be drawn in block
        local ulBlockWidth:        dword ;# of quadpixels to be drawn

        local ulLeftDest:          dword ;bitmap offset to left edge
        local ulLeftMask:          dword ;plane mask for left-edge drawing
        local ulRightDest:         dword ;bitmap offset to right edge
        local ulRightMask:         dword ;plane mask for right-edge drawing
        local lPlanarNextScan:     dword ;delta between scans in planar mode

        local ulCurrentDestScan:   dword ;current destination scan
        local ulLastDestScan:      dword ;last destination scan

        local pjPattern:           ptr   ;points to off-screen cached brush

        local cyPat:               dword ;pattern height
        local cyPatLog2:           dword ;log2 of pattern height
        local cyPatMinusOne:       dword ;cyPat - 1
        local ulPatIndexMask:      dword ;cyPattern*2 - 1
        local lVenetianNextScan:   dword ;ppdev->lPlanarNextScan * cyPat
        local pbce:                ptr   ;pointer to brush's cache entry

        local ulMiddleIndexAdjust: dword ;1 if to start drawing with right half
        local ulLeftIndexAdjust:   dword ; half of pattern, 0 if with left
        local ulRightIndexAdjust:  dword

        ; For 8xN patterns:

        local cyPattern1:          dword
        local cyPattern2:          dword
        local cyPatternTop1:       dword
        local cyPatternTop2:       dword
        local pvSaveScreen:        ptr
        local cyVenetianTop1:      dword
        local cyVenetianTop2:      dword

        ; For 4xN patterns:

        local cLoops:              dword
        local cwMiddle:            dword

        mov     esi,prb                 ;esi = prb
        mov     edx,pptlBrush           ;edx = pptlBrush
        mov     edi,ppdev               ;edi = pddev

; Initialize some stack variables that we'll use later:

        mov     ecx,[esi].rb_cyLog2
        mov     cyPatLog2,ecx           ;cyPatLog2 = prb->cyLog2

        mov     eax,[edi].pdev_lPlanarNextScan
        shl     eax,cl
        mov     lVenetianNextScan,eax   ;lVenetianNextScan =
                                        ;    ppdev->lPlanarNextScan * prb->cy

        mov     eax,[esi].rb_cy
        mov     cyPat,eax               ;cyPat = prb->cy
        dec     eax
        mov     cyPatMinusOne,eax       ;cyPatMinusOne = cyPat - 1
        lea     eax,[2*eax + 1]
        mov     ulPatIndexMask,eax      ;ulPatIndexMask = cyPat * 2 - 1

; See if we'll have to refresh our brush cache:

        mov     eax,[edx].ptl_y
        mov     ecx,[edx].ptl_x
        mov     yBrushOrg,eax           ;yBrushOrg = pptlBrush->y
        and     ecx,7                   ;ecx = (pptlBrush->x & 7)

        cmp     ecx,[esi].rb_xBrush
        jne     ncol_put_brush_in_cache ;if cached brush doesn't have proper
                                        ; alignment, we have to realign

        .errnz  (size BRUSHCACHEENTRY - 12)

        mov     ebx,[edi].pdev_pbceCache
        mov     eax,[esi].rb_iCache
        lea     eax,[eax+eax*2]
        lea     ebx,[ebx+eax*4]         ;ebx = pbce (pointer to brush's cache
                                        ; entry)

        cmp     esi,[ebx].bce_prbVerifyRealization
        jne     ncol_put_brush_in_cache ;if the cache entry was commandeered
                                        ; by some other brush, we'll have to
                                        ; put the brush in the cache again

ncol_done_brush_in_cache:
        mov     pbce,ebx

; edi = ppdev
; ebx = pbce

; Set the bit mask to disable all bits, so we can copy through the latches:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0 shl 8) + GRAF_BIT_MASK
        out     dx,ax

        mov     edx,[edi].pdev_lPlanarNextScan
        mov     esi,prb
        mov     lPlanarNextScan,edx     ;lPlanarNextScan = ppdev->lPlanarNextScan
        test    [esi].rb_fl,RBRUSH_4PELS_WIDE
        jnz     col4xN_draw_rectangles

;-----------------------------------------------------------------------;
; Start here for every 8xN rectangle.
;-----------------------------------------------------------------------;

        public  col8xN_draw_rectangles
col8xN_draw_rectangles::

        mov     edi,prcl                ;edi = prcl
        mov     ecx,lPlanarNextScan     ;ecx = lPlanarNextScan
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        imul    ecx,ebx

        sub     ebx,yBrushOrg
        add     ebx,ebx
        mov     yBrushTimesTwo,ebx      ;yBrushTimesTwo = 8 * (prcl->top -
                                        ; pptlBrush->y) (our current index into
                                        ; the pattern array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lPlanarNextScan
                                        ; + (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short col8xN_done_left    ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_8xN_LEFT_EDGE shr 1)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)

        mov     ecx,ebx
        and     ecx,1
        mov     ulLeftIndexAdjust,ecx   ;this value is used when doing the left
                                        ; edge to know whether to use all the
                                        ; half of the pattern or the right side
                                        ; (i.e., 0 or 1)

        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

        public  col8xN_done_left
col8xN_done_left::
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        and     ebx,1
        mov     ulMiddleIndexAdjust,ebx ;start with left or right pattern half

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short col8xN_done_right ;skip if we don't need a right edge

        mov     ebx,ulRightDest
        and     ebx,1
        mov     ulRightIndexAdjust,ebx  ;edge uses left or right pattern half

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_8xN_RIGHT_EDGE shr 1)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short col8xN_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_8xN_RIGHT_EDGE shr 1)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  col8xN_done_right
col8xN_done_right::

; We're going to do an 'adc esi,esi' instructions here, effectively
; shifting our flags left by 1, and setting the low bit:

        .errnz  (BLOCK_8xN_NO_MIDDLE - 1)
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        mov     ulBlockWidth,eax

        mov     eax,gapfn8xN[esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

; If we were just doing a n-color patblt in the same area as this call,
; there's a good chance that we're still in planar mode, and that the source
; window points to the brush cache and the destination window points to the
; patblt destination.  So go through the bother of checking:

        mov     esi,pbce
        mov     ebx,ppdev
        mov     eax,[esi].bce_yCache
        mov     edi,[edi].yTop

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short col8xN_map_init_bank

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yBottom
        jge     short col8xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short col8xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short col8xN_init_bank_mapped

col8xN_map_init_bank:

; Map both windows in a single call.
; Preserves EBX, ESI and EDI, according to C calling conventions:

        cCall   vPlanarDouble, \
                <ebx,eax,JustifyBottom,edi,JustifyTop>

        public  col8xN_init_bank_mapped
col8xN_init_bank_mapped::

; esi = pbce
; ebx = ppdev
; edi = current scan

        mov     eax,[esi].bce_ulCache
        add     eax,[ebx].pdev_pvBitmapStart2WindowS
        mov     pjPattern,eax           ;points to directly to cached off-
                                        ; screen brush bits

        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl2PlanarClipD.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl2PlanarClipD.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        call    pfnDraw

        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     short col8xN_next_rectangle

; It's hard for the block copiers to advance their bitmap offsets to the
; next bank, so we do them all here:

        mov     eax,lPlanarNextScan
        imul    eax,ulBlockHeight
        add     ulLeftDest,eax
        add     ulMiddleDest,eax
        add     ulRightDest,eax

; Get the next bank:

        mov     ebx,ppdev

; Map the next bank into window.
; Note: EBX, ESI, and EDI are preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        mov     eax,edi
        sub     eax,yBrushOrg
        add     eax,eax
        mov     yBrushTimesTwo,eax      ;alignment for new bank

        mov     esi,pbce
        jmp     short col8xN_init_bank_mapped

;-----------------------------------------------------------------------;
; Done rectangle.
;-----------------------------------------------------------------------;

        public  col8xN_next_rectangle
col8xN_next_rectangle::
        add     prcl, size RECTL
        dec     culRcl
        jg      col8xN_draw_rectangles  ;do more rectangles

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cRet    vColorPat

;-----------------------------------------------------------------------;
; Start here for every 4xN rectangle.
;-----------------------------------------------------------------------;

        public  col4xN_draw_rectangles
col4xN_draw_rectangles::

        mov     edi,prcl                ;edi = prcl
        mov     ecx,lPlanarNextScan     ;ecx = lPlanarNextScan
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        imul    ecx,ebx

        sub     ebx,yBrushOrg
        add     ebx,ebx
        mov     yBrushTimesTwo,ebx      ;yBrushTimesTwo = 8 * (prcl->top -
                                        ; pptlBrush->y) (our current index into
                                        ; the pattern array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lPlanarNextScan
                                        ; + (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short col4xN_done_left  ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_4xN_LEFT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lPlanarNextScan +
                                        ; (prcl->left >> 2)

        mov     ulLeftIndexAdjust,0     ;always want to use left side of pattern

        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

        public  col4xN_done_left
col4xN_done_left::
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        .errnz  (BLOCK_4xN_MIDDLE_STARTS_UNALIGNED shr 2) - 1
        and     ebx,1                   ;set bit if middle doesn't start
        or      esi,ebx                 ; word aligned (remembering we'll
                                        ; soon shift flags left by 2)

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short col4xN_done_right ;skip if we don't need a right edge

        mov     ulRightIndexAdjust,0    ;always use left side of pattern

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_4xN_RIGHT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short col4xN_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_4xN_RIGHT_EDGE shr 2)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  col4xN_done_right
col4xN_done_right::

; We're going to do two 'adc esi,esi' instructions here, effectively
; shifting our flags left by 2, and setting the low bits:

        .errnz  (BLOCK_4xN_NO_MIDDLE shr 1) - 1
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        .errnz  (BLOCK_4xN_MIDDLE_ENDS_UNALIGNED) - 1
        shr     eax,1
        adc     esi,esi                 ;shift flags left one, and set low
                                        ; bit if the middle isn't an even
                                        ; number of bytes in length
        mov     cwMiddle,eax            ;cwMiddle = cjMiddle / 2
        add     eax,eax
        mov     ulBlockWidth,eax        ;ulBlockWidth = cwMiddle * 2

        mov     eax,gapfn4xN[esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

; If we were just doing a n-color patblt in the same area as this call,
; there's a good chance that we're still in planar mode, and that the source
; window points to the brush cache and the destination window points to the
; patblt destination.  So go through the bother of checking:

        mov     esi,pbce
        mov     ebx,ppdev
        mov     eax,[esi].bce_yCache
        mov     edi,[edi].yTop

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short col4xN_map_init_bank

        cmp     eax,[ebx].pdev_rcl2PlanarClipS.yBottom
        jge     short col4xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short col4xN_map_init_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short col4xN_init_bank_mapped

col4xN_map_init_bank:

; Map both windows in a single call.
; Preserves EBX, ESI and EDI, according to C calling conventions:

        cCall   vPlanarDouble, \
                <ebx,eax,JustifyBottom,edi,JustifyTop>

        public  col4xN_init_bank_mapped
col4xN_init_bank_mapped::

; esi = pbce
; ebx = ppdev
; edi = current scan

        mov     eax,[esi].bce_ulCache
        add     eax,[ebx].pdev_pvBitmapStart2WindowS
        mov     pjPattern,eax           ;points to directly to cached off-
                                        ; screen brush bits

        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl2PlanarClipD.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl2PlanarClipD.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        call    pfnDraw

        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     short col4xN_next_rectangle

; It's hard for the block copiers to advance their bitmap offsets to the
; next bank, so we do them all here:

        mov     eax,lPlanarNextScan
        imul    eax,ulBlockHeight
        add     ulLeftDest,eax
        add     ulMiddleDest,eax
        add     ulRightDest,eax

; Get the next bank:

        mov     ebx,ppdev

; Map the next bank into window.
; Note: EBX, ESI, and EDI are preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        mov     eax,edi
        sub     eax,yBrushOrg
        add     eax,eax
        mov     yBrushTimesTwo,eax      ;alignment for new bank

        mov     esi,pbce
        jmp     short col4xN_init_bank_mapped

;-----------------------------------------------------------------------;
; Done rectangle.
;-----------------------------------------------------------------------;

        public  col4xN_next_rectangle
col4xN_next_rectangle::
        add     prcl, size RECTL
        dec     culRcl
        jg      col4xN_draw_rectangles  ;do more rectangles

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cRet    vColorPat

;=======================================================================;
;=========================== Brush Caching =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; ncol_put_brush_in_cache
;
; Allocates a brush cache entry, and copies the bits from the realized
; brush to the off-screen cache.
;
; Input:
;       edi = ppdev
;       ecx = (pptlBrush->x & 7)
;       esi = prb
;
; Output:
;       edi = ppdev
;       ebx = pbce (pointer to new brush cache entry)
;-----------------------------------------------------------------------;

        align   4
gapfnCopyBrush4xN     label   dword
        dd      0
        dd      ncol_4x2
        dd      ncol_4x4
        dd      ncol_4x8

        public  ncol_put_brush_in_cache
ncol_put_brush_in_cache::

; We employ a simple FIFO circular buffer caching scheme.

        mov     eax,[edi].pdev_iCache
        cmp     eax,[edi].pdev_iCacheLast
        sbb     edx,edx
        and     edx,eax
        inc     edx                     ;edx = new brush index =
                                        ;      (ppdev->iCache + 1)
                                        ; (if the new index is greater than
                                        ; ppdev->iCacheLast, its value becomes
                                        ; one -- index zero is reserved)

        mov     [edi].pdev_iCache,edx   ;remember this cache index for nex
                                        ; time we need a new one

        mov     [esi].rb_iCache,edx     ;point the realized brush to our cache
                                        ; entry

; If offscreen memory isn't refreshed, the brush cache can't be
; guaranteed to be valid between calls.  But it should be safe to
; initialize and use it in the same call.  By never changing 'xBrush',
; we effectively never mark the cached entry as valid (and so the
; cache entry will get updated on every call), but we can still use
; our fast Asm fill code:

        test    [edi].pdev_fl,DRIVER_OFFSCREEN_REFRESHED
        jz      short ncol_find_brush_entry

        mov     [esi].rb_xBrush,ecx     ;remember the brush's x alignment

ncol_find_brush_entry::
        .errnz  (size BRUSHCACHEENTRY - 12)

        mov     ebx,[edi].pdev_pbceCache
        lea     edx,[edx+edx*2]
        lea     ebx,[ebx+edx*4]         ;ebx = new BRUSHCACHEENTRY for brush

; Because of the DDI design, we are not notified by the engine when it
; kills a brush realization, so we have no way of freeing legitimately
; free cache entries.  So whenever we cache a new brush, we pretty much
; just randomly pick a new off-screen location to write the brush bits too;
; if it was holding the brush bits for another brush that still might be
; used, we have to have some way of telling that old brush realization that
; its cache entry is no longer valid.
;
; We do this by means of the prbVerifyRealization field in the cache entry --
; it points to the brush realization that owns the brush bits.  (Remember
; that the realization may be deleted by the engine at any time, so it might
; be pointing to freed memory.  But that's okay since we only ever use it
; when given a realized brush, to see if its off-screen cache entry is still
; valid.)

        mov     [ebx].bce_prbVerifyRealization,esi
                                        ;mark that this realized brush has a
                                        ; valid cache entry

        mov     eax,[ebx].bce_yCache

        cmp     eax,[edi].pdev_rcl1WindowClip.yTop
        jl      short ncol_map_brush_bank

        cmp     eax,[edi].pdev_rcl1WindowClip.yBottom
        jl      short ncol_brush_bank_mapped

ncol_map_brush_bank:
        push    ecx
        ptrCall <dword ptr [edi].pdev_pfnBankControl>, \
                <edi,eax,JustifyBottom>
        pop     ecx

ncol_brush_bank_mapped:
        test    [esi].rb_fl,RBRUSH_4PELS_WIDE
        jz      ncol_8_wide

        mov     eax,[edi].pdev_pvBitmapStart
        mov     edi,[ebx].bce_ulCache   ;ulCache will have to be multiplied by
                                        ; 4 because we want the non-planar
                                        ; offset, not the planar offset
        lea     edi,[eax+edi*4]         ;edi = off-screen destination

        shl     ecx,3                   ;each pixel is 8 bits long

        mov     eax,[esi].rb_cyLog2
        lea     esi,[esi].rb_aulPattern ;esi = realized brush source
        jmp     gapfnCopyBrush4xN[eax*4]

; ebx = pbce
; ecx = (pptlBrush->x & 7) * 8
; esi = pointer to source realized brush bits
; edi = pointer to destination off-screen brush bits

ncol_4x8:
        mov     eax,[esi+56]
        mov     edx,[esi+60]
        shld    eax,edx,cl
        mov     [edi+56],eax            ;8th quadpixel

        mov     eax,[esi+48]
        mov     edx,[esi+52]
        shld    eax,edx,cl
        mov     [edi+48],eax            ;7th quadpixel

        mov     eax,[esi+40]
        mov     edx,[esi+44]
        shld    eax,edx,cl
        mov     [edi+40],eax            ;6th quadpixel

        mov     eax,[esi+32]
        mov     edx,[esi+36]
        shld    eax,edx,cl
        mov     [edi+32],eax            ;5th quadpixel

ncol_4x4:
        mov     eax,[esi+24]
        mov     edx,[esi+28]
        shld    eax,edx,cl
        mov     [edi+24],eax            ;4th quadpixel

        mov     eax,[esi+16]
        mov     edx,[esi+20]
        shld    eax,edx,cl
        mov     [edi+16],eax            ;3rd quadpixel

ncol_4x2:
        mov     eax,[esi+8]
        mov     edx,[esi+12]
        shld    eax,edx,cl
        mov     [edi+8],eax             ;2nd quadpixel

        mov     eax,[esi]
        mov     edx,[esi+4]
        shld    eax,edx,cl
        mov     [edi],eax               ;1st quadpixel

        mov     edi,ppdev
        jmp     ncol_done_brush_in_cache

;-----------------------------------------------------------------------;

        align   4
gapfnCopyBrush8xN     label   dword
        dd      0
        dd      ncol_8x2
        dd      ncol_8x4
        dd      ncol_8x8

        public  ncol_8_wide
ncol_8_wide::
        push    ebx                     ;we'll need 'pbce' later

        mov     eax,[edi].pdev_pvBitmapStart
        mov     edi,[ebx].bce_ulCache   ;ulCache will have to be multiplied by
                                        ; 4 because we want the non-planar
                                        ; offset, not the planar offset

; We're lacking a 64 bit roll instruction.  And we have the problem that
; we might have to roll the pattern by (for example) 7 pixels (i.e., 56
; bits), but shld can only do up to a 32 bit shift.  In those cases, the
; right quadpixel has to be moved with a shift to the left quadpixel (and
; vice versa) -- so we detect those cases and switch the destination
; pointer between left and right:

        cmp     ecx,4
        sbb     edi,-1

        lea     edi,[eax+edi*4]         ;edi = off-screen destination

        mov     ebx,edi
        xor     ebx,4                   ;put the pattern's right pixel
                                        ; adjacent to the left pixel

        shl     ecx,3                   ;each pixel is 8 bits long

        mov     eax,[esi].rb_cyLog2
        lea     esi,[esi].rb_aulPattern ;esi = realized brush source

        jmp     gapfnCopyBrush8xN[eax*4]

; ebx = destination for the source pattern's right pixels
; ecx = (pptlBrush->x & 7) * 8
; esi = pointer to source realized brush bits
; edi = destination for the source pattern's left pixels

ncol_8x8:
        mov     eax,[esi+56]
        mov     edx,[esi+60]
        shld    eax,edx,cl
        mov     [edi+56],eax            ;left side of pattern's 8th scan
        mov     eax,[esi+56]
        shld    edx,eax,cl
        mov     [ebx+56],edx            ;right side of pattern' 8th scan

        mov     eax,[esi+48]
        mov     edx,[esi+52]
        shld    eax,edx,cl
        mov     [edi+48],eax            ;left side of pattern's 7th scan
        mov     eax,[esi+48]
        shld    edx,eax,cl
        mov     [ebx+48],edx            ;right side of pattern' 7th scan

        mov     eax,[esi+40]
        mov     edx,[esi+44]
        shld    eax,edx,cl
        mov     [edi+40],eax            ;left side of pattern's 6th scan
        mov     eax,[esi+40]
        shld    edx,eax,cl
        mov     [ebx+40],edx            ;right side of pattern' 6th scan

        mov     eax,[esi+32]
        mov     edx,[esi+36]
        shld    eax,edx,cl
        mov     [edi+32],eax            ;left side of pattern's 5th scan
        mov     eax,[esi+32]
        shld    edx,eax,cl
        mov     [ebx+32],edx            ;right side of pattern' 5th scan

ncol_8x4:
        mov     eax,[esi+24]
        mov     edx,[esi+28]
        shld    eax,edx,cl
        mov     [edi+24],eax            ;left side of pattern's 4th scan
        mov     eax,[esi+24]
        shld    edx,eax,cl
        mov     [ebx+24],edx            ;right side of pattern' 4th scan

        mov     eax,[esi+16]
        mov     edx,[esi+20]
        shld    eax,edx,cl
        mov     [edi+16],eax            ;left side of pattern's 3rd scan
        mov     eax,[esi+16]
        shld    edx,eax,cl
        mov     [ebx+16],edx            ;right side of pattern' 3rd scan

ncol_8x2:
        mov     eax,[esi+8]
        mov     edx,[esi+12]
        shld    eax,edx,cl
        mov     [edi+8],eax             ;left side of pattern's 2nd scan
        mov     eax,[esi+8]
        shld    edx,eax,cl
        mov     [ebx+8],edx             ;right side of pattern's 2nd scan

        mov     eax,[esi]
        mov     edx,[esi+4]
        shld    eax,edx,cl
        mov     [edi],eax               ;left side of pattern's 1st scan
        mov     eax,[esi]
        shld    edx,eax,cl
        mov     [ebx],edx               ;right side of pattern's 1st scan

        pop     ebx
        mov     edi,ppdev
        jmp     ncol_done_brush_in_cache

;=======================================================================;
;=========================== Block Drawers =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; left_8xN
;
; Draws left edge of 8xN patterns.
;
; Input:
;       ulLeftMask
;       ulLeftDest
;       ulBlockHeight
;       pjPattern         = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo    = not kept normalized
;       ulLeftIndexAdjust
;
; Output:
;-----------------------------------------------------------------------;

        public  left_8xN
left_8xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al                   ;set left mask by disabling some planes

        mov     ecx,ppdev
        mov     edi,ulLeftDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,ulLeftIndexAdjust
        add     eax,yBrushTimesTwo      ;we adjust eax to point to either the
                                        ; left or right quadpixels of the
                                        ; first 8 pixels in the pattern,
                                        ; depending on how the edge is located

        mov     edx,lVenetianNextScan   ;screen delta between rows that have
                                        ; the same pattern

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne         ;ebx = number of rows of pattern that
        jz      short left_8xN_do_lower ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
left_8xN_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx = scan count
; edx = venetian delta
; edi = screen

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short left_8xN_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short left_8xN_done     ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

left_8xN_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
left_8xN_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short left_8xN_lower_loop

left_8xN_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; right_8xN
;
; Draws right edge of 8xN patterns.
;
; Input:
;       ulRightMask
;       ulRightDest
;       ulBlockHeight
;       pjPattern         = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo    = not kept normalized
;       ulRightIndexAdjust
;
; Output:
;-----------------------------------------------------------------------;

        public  right_8xN
right_8xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al                   ;set right mask by disabling some planes

        mov     ecx,ppdev
        mov     edi,ulRightDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,ulRightIndexAdjust
        add     eax,yBrushTimesTwo      ;we adjust eax to point to either the
                                        ; right or right quadpixels of the
                                        ; first 8 pixels in the pattern,
                                        ; depending on how the edge is located

        mov     edx,lVenetianNextScan   ;screen delta between rows that have
                                        ; the same pattern

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne         ;ebx = number of rows of pattern that
        jz      short right_8xN_do_lower ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
right_8xN_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx = scan count
; edx = venetian delta
; edi = screen

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short right_8xN_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short right_8xN_done     ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

right_8xN_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
right_8xN_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     ecx,esi

@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,edx                 ;skip a quadpixel

        dec     ecx
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short right_8xN_lower_loop

right_8xN_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; middle_8xN
;
; Draws middle of 8xN patterns.
;
; Input:
;
;-----------------------------------------------------------------------;

        public  middle_8xN
middle_8xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;we'll be writing to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the screen
                                        ; destination bank

        mov     pvSaveScreen,edi        ;save for later

        mov     esi,ulBlockHeight
        mov     ebx,esi
        mov     eax,cyPat
        sub     ebx,eax                 ;ebx = ulBlockHeight - cyPat
        sbb     ecx,ecx
        and     ecx,ebx
        add     eax,ecx
        mov     cyPattern1,eax
        mov     cyPattern2,eax          ;cyPatternX = min(ulBlockHeight, cyPat)

        and     ebx,cyPatMinusOne
        mov     cyPatternTop1,ebx
        mov     cyPatternTop2,ebx       ;cyPatternTopX = number of rows of
                                        ; pattern that are in the upper rows
                                        ; of the venetian

        mov     eax,ulMiddleIndexAdjust
        add     eax,yBrushTimesTwo
        mov     yBrushSave,eax          ;tells us where in the pattern to start

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi
        mov     cyVenetianTop1,esi
        mov     cyVenetianTop2,esi      ;cyVenetianTop = # scans that are
                                        ; drawn with each of the top
                                        ; cyPatternTopX rows of the pattern

        mov     esi,ulBlockWidth
        inc     esi
        shr     esi,1                   ;esi = number of columns to lay down
                                        ; with 'left' side of pattern

        mov     edx,lVenetianNextScan
        sub     edx,esi
        sub     edx,esi                 ;edx = delta in bytes to go from
                                        ; end of current screen scan to
                                        ; start of next that has same pattern
                                        ; quadpixel

mid_8xN_first_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ebx,cyVenetianTop1
        sub     cyPatternTop1,1         ;set carry if zero or less
        sbb     ebx,0                   ;the number of scans drawn for the
                                        ; top part of the pattern is 1 more
                                        ; than that drawn for the bottom
        mov     cyVenetianTop1,ebx

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

; eax = current brush index
; ebx = # of scans to draw
; edx = venetian delta
; ecx = scan count
; edi = destination address

        call    draw_horizontal_8xN_middle_loop
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     cyPattern1
        jnz     short mid_8xN_first_loop

        mov     esi,ulBlockWidth
        shr     esi,1
        jz      short mid_8xN_done      ;if middle was only one quadpixel wide,
                                        ; there is no second half to do

        mov     edx,lVenetianNextScan
        sub     edx,esi
        sub     edx,esi                 ;edx = delta in bytes to go from
                                        ; end of current screen scan to
                                        ; start of next that has same pattern
                                        ; quadpixel

; Now handle second half of pattern:

        mov     edi,pvSaveScreen
        inc     edi
        mov     eax,yBrushSave
        xor     eax,1                   ;now handle 'second' half of pattern

mid_8xN_second_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ebx,cyVenetianTop2
        sub     cyPatternTop2,1         ;set carry if zero or less
        sbb     ebx,0                   ;the number of scans drawn for the
                                        ; top part of the pattern is 1 more
                                        ; than that drawn for the bottom
        mov     cyVenetianTop2,ebx

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row
        call    draw_horizontal_8xN_middle_loop
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     cyPattern2
        jnz     short mid_8xN_second_loop

mid_8xN_done:
        retn

;-----------------------------------------------------------------------;
; Routine to write the middle of an n-color 8xN pattern.
;
; Input:
;
;    ebx = number of scans to draw
;    edx = venetian delta
;    esi = loop count (same as ecx)
;    edi = destination address
;
; Output:
;
;    ebx = 0
;    edi = end address
;
;-----------------------------------------------------------------------;

        public  draw_horizontal_8xN_middle_loop
draw_horizontal_8xN_middle_loop::
        mov     ecx,esi                 ;reload our cross-scan count
@@:
        mov     [edi],al                ;write the quadpixel
        add     edi,2                   ;skip a quadpixel

        dec     ecx
        jnz     @B

        add     edi,edx                 ;move to next scan

        dec     ebx                     ;that's one more scan done
        jnz     draw_horizontal_8xN_middle_loop ;do the next scan, if any

        retn

;-----------------------------------------------------------------------;
; middle_00_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_00_4xN
middle_00_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid00_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
        mov     cLoops,esi

mid00_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid00_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid00_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid00_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
        mov     cLoops,esi

mid00_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid00_lower_loop

mid00_done:
        PLAIN_RET


;-----------------------------------------------------------------------;
; middle_01_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_01_4xN
middle_01_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid01_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
        mov     cLoops,esi
mid01_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid01_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid01_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid01_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
        mov     cLoops,esi

mid01_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid01_lower_loop

mid01_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; middle_10_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_10_4xN
middle_10_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        inc     edi                     ;word align destination

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid10_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern
        mov     cLoops,esi

mid10_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row
        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid10_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid10_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid10_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern
        mov     cLoops,esi

mid10_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid10_lower_loop

mid10_done:
        PLAIN_RET

;-----------------------------------------------------------------------;
; middle_11_4xN
;
; Draws middle of 4xN patterns.
;
; Input:
;       ulLeftMask
;       ulMiddleDest
;       ulBlockHeight
;       pjPattern     = start of pattern
;       lPlanarNextScan
;       yBrushTimesTwo        = not kept normalized
;
; Output:
;-----------------------------------------------------------------------;

        public  middle_11_4xN
middle_11_4xN::
        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,MM_ALL
        out     dx,al                   ;write to all planes

        mov     ecx,ppdev
        mov     edi,ulMiddleDest
        add     edi,[ecx].pdev_pvBitmapStart2WindowD
                                        ;adjust edi to point into the
                                        ; screen destination bank

        inc     edi                     ;word align destination
        dec     cwMiddle                ;first and last bytes count as 1 word

        mov     eax,yBrushTimesTwo

        mov     edx,lVenetianNextScan
        sub     edx,ulBlockWidth        ;screen delta between rows that have
        add     edx,2                   ;plus extra word for 1st and last byte

        mov     esi,ulBlockHeight
        mov     ebx,esi
        and     ebx,cyPatMinusOne       ;ebx = number of rows of pattern that
        jz      short mid11_do_lower    ; are in the upper part of the venetian

        mov     ecx,cyPatLog2
        shr     esi,cl
        inc     esi                     ;(ulBlockHeight >> cyPatLog2) + 1
                                        ; scans are drawn with each of the top
                                        ; (ulBlockHeight & cyPatternMinus1)
                                        ; rows of the pattern

        mov     cLoops,esi

mid11_upper_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

; eax = current index into brush
; ebx = # of scans in upper part of venetian blind
; ecx =
; edx = venetian delta
; esi = loop count
; edi = screen

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're now 1 scan lower in the venetian

        dec     ebx
        jnz     short mid11_upper_loop

        mov     esi,ulBlockHeight
        cmp     esi,cyPat
        jl      short mid11_done        ;have to watch for rectangles that are
                                        ; shorter than the pattern

        mov     ebx,esi
        and     ebx,cyPatMinusOne

mid11_do_lower:
        neg     ebx
        add     ebx,cyPat               ;ebx = number of rows in pattern that
                                        ; are in the lower part of the venetian
                                        ; (namely, cyPat - # in upper)

        mov     ecx,cyPatLog2
        shr     esi,cl                  ;(ulBlockHeight >> cyPatLog2) scans
                                        ; are drawn with each of the bottom
                                        ; cyPattern - (ulBlockHeight &
                                        ; cyPatternMinus1) rows of the pattern

        mov     cLoops,esi

mid11_lower_loop:
        push    edi                     ;save screen pointer for next scan

        mov     ecx,pjPattern
        and     eax,ulPatIndexMask
        mov     cl,[ecx+eax]            ;load latches with current quadpixel
        add     eax,2                   ;advance to next quadpixel in pattern
                                        ; that is in the same row

        mov     esi,cLoops

@@:
        mov     [edi-1],al
        mov     ecx,cwMiddle
        rep     stosw
        mov     [edi],al
        add     edi,edx

        dec     esi
        jnz     @B                      ;repeat this quadpixel of the pattern
                                        ; on all the scans we can
        pop     edi
        add     edi,lPlanarNextScan     ;we're one scan lower in the venetian

        dec     ebx
        jnz     short mid11_lower_loop

mid11_done:
        inc     cwMiddle                ;restore cwMiddle
        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vColorPat

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\stroke.c ===
/******************************Module*Header*******************************\
* Module Name: Stroke.c
*
* DrvStrokePath for VGA driver
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "driver.h"
#include "lines.h"

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

// Array to compute ROP masks:

LONG gaiLineMix[] = {
    AND_ZERO   | XOR_ONE,
    AND_ZERO   | XOR_ZERO,
    AND_NOTPEN | XOR_NOTPEN,
    AND_NOTPEN | XOR_ZERO,
    AND_ZERO   | XOR_NOTPEN,
    AND_PEN    | XOR_PEN,
    AND_ONE    | XOR_ONE,
    AND_ONE    | XOR_PEN,
    AND_PEN    | XOR_ONE,
    AND_PEN    | XOR_ZERO,
    AND_ONE    | XOR_NOTPEN,
    AND_ONE    | XOR_ZERO,
    AND_PEN    | XOR_NOTPEN,
    AND_ZERO   | XOR_PEN,
    AND_NOTPEN | XOR_ONE,
    AND_NOTPEN | XOR_PEN
};

// We have 4 basic strip drawers, one for every semi-octant.  The near-
// horizontal semi-octant is number 0, and the rest are numbered
// consecutively.

// Prototypes to go to the screen and handle any ROPs:

VOID vStripSolid0(STRIP*, LINESTATE*, LONG*);
VOID vStripSolid1(STRIP*, LINESTATE*, LONG*);
VOID vStripSolid2(STRIP*, LINESTATE*, LONG*);
VOID vStripSolid3(STRIP*, LINESTATE*, LONG*);

VOID vStripStyled0(STRIP*, LINESTATE*, LONG*);
VOID vStripStyled123(STRIP*, LINESTATE*, LONG*);

// Prototypes to go to the screen and handle only set-style ROPs:

VOID vStripSolidSet0(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidSet1(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidSet2(STRIP*, LINESTATE*, LONG*);
VOID vStripSolidSet3(STRIP*, LINESTATE*, LONG*);

VOID vStripStyledSet0(STRIP*, LINESTATE*, LONG*);
VOID vStripStyledSet123(STRIP*, LINESTATE*, LONG*);

PFNSTRIP gapfnStrip[] = {
    vStripSolid0,
    vStripSolid3,
    vStripSolid1,
    vStripSolid2,

    vStripStyled0,
    vStripStyled123,
    vStripStyled123,
    vStripStyled123,

    vStripSolidSet0,
    vStripSolidSet3,
    vStripSolidSet1,
    vStripSolidSet2,

    vStripStyledSet0,
    vStripStyledSet123,
    vStripStyledSet123,
    vStripStyledSet123,
};

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, pla, mix)
*
* Strokes the path.
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* pla,
MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PPDEV     ppdev = (PPDEV) pso->dhsurf;

    UNREFERENCED_PARAMETER(pxo);
    UNREFERENCED_PARAMETER(pptlBrushOrg);

// Fast lines can't handle trivial clipping, ROPs other than R2_COPYPEN, or
// styles:

    mix &= 0xf;
    if ((mix == 0x0d) &&
        (pco->iDComplexity == DC_TRIVIAL) &&
        (pla->pstyle == NULL) && !(pla->fl & LA_ALTERNATE))
    {
        vFastLine(ppdev, ppo, ppdev->lNextScan,
                  (pbo->iSolidColor << 8) | (pbo->iSolidColor & 0xff));
        return(TRUE);
    }

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ASSERTVGA(pla->pstyle == (FLOAT_LONG*) NULL && pla->cstyle == 0,
               "Non-empty style array for PS_ALTERNATE");

        ls.bStartIsGap  = 0;                        // First pel is a dash
        ls.cStyle       = 1;                        // Size of style array
        ls.spTotal      = 1;                        // Sum of style array
        ls.spTotal2     = 2;                        // Twice the sum
        ls.aspRtoL      = &gaspAlternateStyle[0];   // Right-to-left array
        ls.aspLtoR      = &gaspAlternateStyle[0];   // Left-to-right array
        ls.spNext       = HIWORD(pla->elStyleState.l) & 1;
                                                    // Light first pixel if
                                                    //   a multiple of 2
        ls.xyDensity    = 1;                        // Each 'dot' is one
                                                    //   pixel long
        fl             |= FL_ARBITRARYSTYLED;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        FLOAT_LONG* pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        ASSERTVGA(pla->cstyle <= STYLE_MAX_COUNT, "Style array too large");

    // Compute length of style array:

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }

    // The style array is given in 'style' units.  Since we're going to
    // assign each unit to be STYLE_DENSITY (3) pixels long, multiply:

        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow).
    // Note that since the array repeats infinitely, this number might
    // actually be more than ls.spTotal2, but we take care of that later
    // in our code:

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl            |= FL_ARBITRARYSTYLED;
        ls.cStyle      = pla->cstyle;
        ls.aspRtoL     = aspRtoL;   // Style array in right-to-left order
        ls.aspLtoR     = aspLtoR;   // Style array in left-to-right order

    // ulStartMask determines if the first entry in the style array is for
    // a dash or a gap:

        ls.bStartIsGap = (pla->fl & LA_STARTGAP) ? -1L : 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

    // We always draw strips left-to-right, but styles have to be laid
    // down in the direction of the original line.  This means that in
    // the strip code we have to traverse the style array in the
    // opposite direction;

        while (pspDown >= &ls.aspRtoL[0])
        {
            ASSERTVGA(pstyle->l > 0 && pstyle->l <= STYLE_MAX_VALUE,
                   "Illegal style array value");

            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    {
    // All ROPs are handled in a single pass:

        ULONG achColor[4];
        LONG  iIndex;
        ULONG iColor = (pbo->iSolidColor & 0xff);

        achColor[AND_ZERO]   =  0;
        achColor[AND_PEN]    =  pbo->iSolidColor;
        achColor[AND_NOTPEN] = ~pbo->iSolidColor;
        achColor[AND_ONE]    =  (ULONG) -1L;

        iIndex = gaiLineMix[mix];

    // We have special strip drawers for set-style ROPs (where we don't
    // have to read video memory):

        if ((iIndex & 0xff) == AND_ZERO)
            fl |= FL_SET;

    // Put the AND index in the low byte, and the XOR index in the next:

        *((BYTE*) &ls.chAndXor)     = (BYTE) achColor[iIndex & 0xff];
        *((BYTE*) &ls.chAndXor + 1) = (BYTE) achColor[iIndex >> MIX_XOR_OFFSET];
    }

    apfn = &gapfnStrip[4 * ((fl & FL_STRIP_ARRAY_MASK) >> FL_STRIP_ARRAY_SHIFT)];

// Set up to enumerate the path:

    if (pco->iDComplexity != DC_COMPLEX)
    {
        RECTL     arclClip[4];                   // For rectangular clipping
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                ASSERTVGA(!bMore, "Empty path record in non-empty path");
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

        // We have to check for cptfx == 0 because the only point in the
        // subpath may have been the StartFigure point:

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\fastline.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fastline.asm
;
; This module goes completely overboard in trying to do fast lines.
; It handles only solid R2_COPYPEN unclipped lines.
;
; Unfortunately, I know of only 4 performance tricks:
;
;    1) Most VGAs can co-process the last write to video memory,
;       so we employ a traditional Bresenham-style algorithm (as
;       opposed to a run-length version) as this minimizes our
;       set-up time, and we can do some work between video writes
;       without any throughput penalty.
;
;    2) Most VGAs can do one aligned word write faster than two
;       byte writes; consequently we derive a double-stepping DDA
;       that does aligned word writes whenever possible (note that
;       this only makes sense on x-major lines).
;
;    3) Planar mode can be used to speed up long horizontal lines,
;       where the cost to switch from linear to planar mode is offset
;       by the ability to light 8 pixels on every word write instead
;       of 2.
;
;    4) Most lines have integer end-points, so we accelerate those.
;
; If you're not familiar with GIQ lines, this is not the code to start
; with.
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\driver.inc
        include i386\lines.inc
        .list

; Length of horizontal line needed before we'll do it in planar mode:

        NUM_PELS_NEEDED_FOR_PLANAR_HORIZONTAL   equ 64

; Line coordinates are given in 28.4 fixed point format:

        F               equ 16
        FLOG2           equ 4

; The following values must match those in winddi.h!

        PD_BEGINSUBPATH equ 00000001h
        PD_ENDSUBPATH   equ 00000002h
        PD_RESETSTYLE   equ 00000004h
        PD_CLOSEFIGURE  equ 00000008h
        PD_BEZIERS      equ 00000010h

        PATHDATA struc

        pd_flags        dd  ?
        pd_count        dd  ?
        pd_pptfx        dd  ?

        PATHDATA ends

;-------------------------------------------------------------------------;
; I felt a compelling need to use 'ebp' as a 7th general register, and we
; have no nifty macros for dereferencing frame variables off 'esp'.  So
; with this structure I am rolling my own stack frame:

STATE_MEM_SIZE          equ 4           ;4 dwords
PROC_MEM_SIZE           equ 6           ;6 dwords

STACK_FRAME struc

; State variables (don't add/delete fields without modifying STATE_MEM_SIZE!)

sf_ulOurEbp             dd ?            ;useful for debugging
sf_ulOriginalEbx        dd ?
sf_ulOriginalEdi        dd ?
sf_ulOriginalEsi        dd ?

; Frame variables (feel free to add/delete fields):

sf_lDelta               dd ?            ;sign depends on going up or down
sf_pfnReturn            dd ?            ;where to jump after getting next bank
sf_pfnNextBank          dd ?            ;routine for getting the next bank
sf_y0                   dd ?            ;GIQ variables
sf_y1                   dd ?
sf_x1                   dd ?
sf_pjStart              dd ?            ;for remembering edi
sf_cAfterThisBank       dd ?            ;# of pixels to light after this bank
sf_ptlOrg               db (size POINTL) dup (?)
                                        ;our  origin for normalizing the line
sf_ptfxLast             db (size POINTL) dup (?)
                                        ;the most recent point
sf_ptfxStartFigure      db (size POINTL) dup (?)
                                        ;the figure's 1st point
sf_bMore                dd ?            ;more path records to get?
sf_pptfxEnd             dd ?            ;points to last point in record
sf_pptfx                dd ?            ;points to current point
sf_pd                   db (size PATHDATA) dup (?)
                                        ;pathdata structure

; Procedure variables (don't add/delete fields without modifying
; PROC_MEM_SIZE!)

sf_ulOriginalEbp        dd ?
sf_ulOriginalReturn     dd ?
sf_ppdev                dd ?
sf_ppo                  dd ?
sf_lNextScan            dd ?
sf_iColor               dd ?

STACK_FRAME ends

        .code

        EXTRNP  PATHOBJ_bEnum,8

        ROUND_X_DOWN            equ     01h
        ROUND_Y_DOWN            equ     02h
        ROUND_SLOPE_ONE         equ     04h
        ROUND_X_AND_Y_DOWN      equ     (ROUND_X_DOWN + ROUND_Y_DOWN)
        ROUND_X_DOWN_SLOPE_ONE  equ     (ROUND_X_DOWN + ROUND_SLOPE_ONE)
        ROUND_Y_DOWN_SLOPE_ONE  equ     (ROUND_Y_DOWN + ROUND_SLOPE_ONE)

;--------------------------------Macro----------------------------------;
; GIQ flags
;
; This macros computes the start pixel, the number of pixels to
; be lit, and the initial error term given a GIQ line.  The line must
; have already been normalized such that dM >= dN, dN >= 0.
;
; Input:   eax - M0
;          ebx - N0
;          ecx - dM
;          edx - dN
; Trashes:
;          esi, ebp
;          [esp].sf_ptlOrg.ptl_x, [esp].sf_ptlOrg.ptl_y
; Output:
;          [esp].sf_x1  - x-coordinate of last pixel (exclusive)
;          eax - x-coordinate of first pixel
;          ebx - error term
;          ecx - dM
;          edx - dN
;          edi - y-coordinate of first pixel
;-----------------------------------------------------------------------;

GIQ     macro   flags
        local   compute_x1, compute_error_term

; We normalize our coordinate system so that if the start point is
; (M0/F, N0/F), the origin is at (floor(M0/F), (N0/F)):

        mov     esi,eax
        mov     edi,ebx
        sar     esi,FLOG2
        sar     edi,FLOG2
        mov     [esp].sf_ptlOrg.ptl_x,esi
                                        ;ptlOrg.x = floor(M0 / F)
        mov     [esp].sf_ptlOrg.ptl_y,edi
                                        ;ptlOrg.y = floor(N0 / F)

; Calculate the correct [esp].sf_x1:

        lea     edi,[ebx + edx]         ;edi = N1
        and     edi,F - 1

    if (flags AND ROUND_X_DOWN)

    if (flags AND ROUND_SLOPE_ONE)
        cmp     edi,8
        sbb     edi,-1
    endif

        cmp     edi,1
        sbb     edi,8                   ;N1 -= 8
    else
        sub     edi,8                   ;N1 -= 8
    endif
        sbb     esi,esi
        xor     edi,esi
        sub     edi,esi                 ;N1 = ABS(N1)

        lea     ebp,[eax + ecx]
        mov     esi,ebp
        sar     ebp,FLOG2
        and     esi,F - 1
        jz      short @f                ;special case for M1 == 0
        cmp     esi,edi                 ;cmp M1, N1
        sbb     ebp,-1                  ;ebp is now one pixel past the actual
@@:                                     ; end coordinate (note that it hasn't
                                        ; been affected by the origin shift)

compute_error_term:

; eax = M0
; ebx = N0
; ebp = x1
; ecx = dM
; edx = dN

        and     ebx,F - 1
        mov     [esp].sf_x1,ebp         ;save x1

; Calculate our error term for x = 0.
;
; NOTE: Since this routine is used only for lines that are unclipped, we
;       are guaranteed by our screen size that the values will be far less
;       than 32 bits in significance, and so we don't worry about overflow.
;       If this is used for clipped lines, these multiplies will have to
;       be converted to give 64 bit results, because we can have 36 bits of
;       significance!


        lea     edi,[ebx + 8]           ;edi = N0 + 8
        mov     esi,ecx
        imul    esi,edi                 ;esi = dM * (N0 + 8)
        mov     edi,edx

; We have to special case when M0 is 0 -- we know x0 will be zero.
; So we jump ahead a bit to a place where 'eax' is assumed to contain
; x0 -- and it just so happens 'eax' is zero in this case:

        and     eax,F - 1
        jz      short @f
        imul    edi,eax                 ;edi = dN * M0
        sub     esi,edi

; Calculate the x-coordinate of the first pixel:

    if (flags AND ROUND_X_DOWN)

    if (flags AND ROUND_SLOPE_ONE)
        cmp     ebx,8
        sbb     ebx,-1
    endif

        cmp     ebx,1
        sbb     ebx,8                   ;N0 -= 8
    else
        sub     ebx,8                   ;N0 -= 8
    endif
        sbb     edi,edi
        xor     ebx,edi
        sub     ebx,edi                 ;N0 = ABS(N0)
        cmp     eax,ebx
        sbb     eax,eax
        not     eax                     ;eax = -x0

; Now adjust the error term accordingly:

@@:
    if (flags AND ROUND_Y_DOWN)
        dec     esi
    endif
        sar     esi,FLOG2               ;esi = floor((N0 + 8) dM - M0 dN] / 16)

        mov     ebx,[esp].sf_ptlOrg.ptl_x
        mov     edi,[esp].sf_ptlOrg.ptl_y

        sub     ebx,eax                 ;ebx = ptlOrg.ptl_x + x0

        and     eax,edx
        add     eax,esi
        sub     eax,ecx                 ;eax = dN * x0 + initial error - dM
        jl      short @f                ;if the error term >= 0, we have to
        sub     eax,ecx                 ; add 1 to the y position and subtract
        inc     edi                     ; dM off again
@@:
        xchg    eax,ebx

endm

;--------------------------------Macro----------------------------------;
; GIQR flags
;
; Same as above, except it handles flips about the line x = y.
;
; Input:   eax - M0
;          ebx - N0
;          ecx - dM
;          edx - dN
; Trashes:
;          esi, ebp
;          [esp].sf_ptlOrg.ptl_x, [esp].sf_ptlOrg.ptl_y
; Output:
;          [esp].sf_y1  - y-coordinate of last pixel (exclusive)
;          eax - x-coordinate of first pixel
;          ebx - error term
;          ecx - dM
;          edx - dN
;          edi - y-coordinate of first pixel
;-----------------------------------------------------------------------;

GIQR    macro   flags

; We normalize our coordinate system so that if the start point is
; (M0/F, N0/F), the origin is at (floor(M0/F), (N0/F)):

        mov     esi,eax
        mov     edi,ebx
        sar     esi,FLOG2
        sar     edi,FLOG2
        mov     [esp].sf_ptlOrg.ptl_x,esi
                                        ;ptlOrg.x = floor(M0 / F)
        mov     [esp].sf_ptlOrg.ptl_y,edi
                                        ;ptlOrg.y = floor(N0 / F)

; Calculate the correct [esp].sf_y1:

        lea     edi,[eax + ecx]         ;edi = M1
        and     edi,F - 1

    if (flags AND ROUND_Y_DOWN)
        cmp     edi,1
        sbb     edi,8                   ;M1 -= 8
    else
        sub     edi,8                   ;M1 -= 8
    endif
        sbb     esi,esi
        xor     edi,esi
        sub     edi,esi                 ;M1 = ABS(M1)

        lea     ebp,[ebx + edx]
        mov     esi,ebp
        sar     ebp,FLOG2
        and     esi,F - 1
        jz      short @f                ;special case for N1 == 0
        cmp     esi,edi                 ;cmp N1, M1
        sbb     ebp,-1                  ;ebp is now one pixel past the actual
@@:                                     ; end coordinate (note that it hasn't
                                        ; been affected by the origin shift)
        and     eax,F - 1
        mov     [esp].sf_y1,ebp

; Calculate our error term for y = 0.
;
; NOTE: Since this routine is used only for lines that are unclipped, we
;       are guaranteed by our screen size that the values will be far less
;       than 32 bits in significance, and so we don't worry about overflow.
;       If this is used for clipped lines, these multiplies will have to
;       be converted to give 64 bit results, because we can have 36 bits of
;       significance!

        lea     edi,[eax + 8]           ;edi = M0 + 8
        mov     esi,edx
        imul    esi,edi                 ;esi = dN * (M0 + 8)
        mov     edi,ecx

; We have to special case when N0 is 0 -- we know y0 will be zero.
; So we jump ahead a bit to a place where 'ebx' is assumed to contain
; y0 -- and it just so happens 'ebx' is zero in this case:

        and     ebx,F - 1
        jz      short @f
        imul    edi,ebx                 ;edi = dM * N0
        sub     esi,edi

; Calculate the x-coordinate of the first pixel:

    if (flags AND ROUND_Y_DOWN)
        cmp     eax,1
        sbb     eax,8                   ;M0 -= 8
    else
        sub     eax,8                   ;M0 -= 8
    endif
        sbb     edi,edi
        xor     eax,edi
        sub     eax,edi                 ;M0 = ABS(M0)
        cmp     ebx,eax
        sbb     ebx,ebx
        not     ebx                     ;ebx = -y0

; Now adjust the error term accordingly:

@@:
    if (flags AND ROUND_X_DOWN)
        dec     esi
    endif
        sar     esi,FLOG2               ;esi = floor((M0 + 8) dN - N0 dM] / 16)

        mov     eax,[esp].sf_ptlOrg.ptl_x
        mov     edi,[esp].sf_ptlOrg.ptl_y

        sub     edi,ebx                 ;edi = ptlOrg.ptl_y + y0

        and     ebx,ecx
        add     ebx,esi
        sub     ebx,edx                 ;ebx = dM * x0 + initial error - dN
        jl      short @f                ;if the error term >= 0, we have to
        sub     ebx,edx                 ; add 1 to the x position and subtract
        inc     eax                     ; dN off again
@@:

endm

;---------------------------Public-Routine------------------------------;
; vFastLine(ppdev, ppo, lNextScan, iColor)
;
; Draws fast lines.  Or at least attempts to.
;
; Input:
;
;    ppdev     - PDEV pointer
;    ppo       - path
;    lNextScan - delta to start of next scan (same as ppdev->lNextScan)
;    iColor    - color (least significant byte must be the same as the next
;                least signficant byte, so that we can do words writes)
;
;-----------------------------------------------------------------------;

; NOTE: Don't go changing parameters without also changing STACK_FRAME!

cProc vFastLine,16,<     \
    uses esi edi ebx,    \
    ebp_ppdev:     ptr,  \
    ebp_ppo:       ptr,  \
    ebp_lNextScan: ptr,  \
    ebp_iColor:    dword >

; Leave room for our stack frame.
;
; NOTE: Don't add local variables here -- you can't reference them with
;       ebp anyway!  Add them to the STACK_FRAME structure.

    local aj[(size STACK_FRAME) - 4 * (STATE_MEM_SIZE + PROC_MEM_SIZE)]: byte

; We save 'ebp' on the stack (note that STACK_FRAME accounts for this push):

        push    ebp

; Now get some path stuff:

next_record:

        mov     esi,[esp].sf_ppo
        lea     eax,[esp].sf_pd
        cCall   PATHOBJ_bEnum,<esi,eax>
        mov     [esp].sf_bMore,eax      ;save away return code for later

        mov     eax,[esp].sf_pd.pd_count;if 0 points in record, get outta here
        or      eax,eax
        jz      check_for_closefigure

        lea     edi,[8 * eax - 8]
        add     edi,[esp].sf_pd.pd_pptfx
        mov     [esp].sf_pptfxEnd,edi   ;points to last point in record

        mov     ebx,[esp].sf_pd.pd_flags
        test    ebx,PD_BEGINSUBPATH
        jz      short continue_subpath

; Handle a new sub-path:

        mov     esi,[esp].sf_pd.pd_pptfx
        add     esi,8
        mov     [esp].sf_pptfx,esi

        mov     ecx,[edi].ptl_x         ;remember last point in case we have
        mov     edx,[edi].ptl_y         ; to continue to another record
        mov     [esp].sf_ptfxLast.ptl_x,ecx
        mov     [esp].sf_ptfxLast.ptl_y,edx

        mov     eax,[esi - 8].ptl_x     ;load up current start and end point
        mov     ebx,[esi - 8].ptl_y
        mov     ecx,[esi].ptl_x
        mov     edx,[esi].ptl_y
        mov     [esp].sf_ptfxStartFigure.ptl_x,eax
        mov     [esp].sf_ptfxStartFigure.ptl_y,ebx

        cmp     esi,[esp].sf_pptfxEnd   ;we have to be careful when the only
                                        ; point in the record is the start-
                                        ; figure point (pretty rare)
        jbe     new_line
        jmp     short next_record

continue_subpath:

; This record continues the path:

        mov     esi,[esp].sf_pd.pd_pptfx
        mov     eax,[esp].sf_ptfxLast.ptl_x ;load up current start point
        mov     ebx,[esp].sf_ptfxLast.ptl_y

        mov     ecx,[edi].ptl_x         ;remember last point in case we have
        mov     edx,[edi].ptl_y         ; to continue to another record
        mov     [esp].sf_ptfxLast.ptl_x,ecx
        mov     [esp].sf_ptfxLast.ptl_y,edx

        mov     ecx,[esi].ptl_x         ;load up current end point
        mov     edx,[esi].ptl_y
        mov     [esp].sf_pptfx,esi
        jmp     short new_line

;/////////////////////////////////////////////////////////////////////
;// Next Line Stuff
;/////////////////////////////////////////////////////////////////////

handle_closefigure:
        mov     [esp].sf_pd.pd_flags,0
        mov     eax,[esp].sf_ptfxLast.ptl_x
        mov     ebx,[esp].sf_ptfxLast.ptl_y
        mov     ecx,[esp].sf_ptfxStartFigure.ptl_x
        mov     edx,[esp].sf_ptfxStartFigure.ptl_y
        jmp     new_line

; Before getting the next path record, see if we have to do a closefigure:

check_for_closefigure:
        test    [esp].sf_pd.pd_flags,PD_CLOSEFIGURE
        jnz     handle_closefigure
        mov     ecx,[esp].sf_bMore
        or      ecx,ecx
        jnz     next_record

all_done:

        pop     ebp
        cRet    vFastLine

        public  next_line
next_line::
        mov     esi,[esp].sf_pptfx
        cmp     esi,[esp].sf_pptfxEnd
        jae     short check_for_closefigure

        mov     eax,[esi].ptl_x
        mov     ebx,[esi].ptl_y
        mov     ecx,[esi+8].ptl_x
        mov     edx,[esi+8].ptl_y
        add     esi,8
        mov     [esp].sf_pptfx,esi

;/////////////////////////////////////////////////////////////////////
;// Main Loop
;/////////////////////////////////////////////////////////////////////

        public  new_line
new_line::

; Octants are numbered as follows:
;
;        \ 5 | 6 /
;         \  |  /
;        4 \ | / 7
;           \ /
;       -----+-----
;           /|\
;        3 / | \ 0
;         /  |  \
;        / 2 | 1 \
;

; eax = M0
; ebx = N0
; ecx = M1 (dM)
; edx = N1 (dN)

        sub     ecx,eax
        jl      octants_2_3_4_5
        sub     edx,ebx
        jl      octants_6_7
        cmp     ecx,edx
        jl      octant_1

;/////////////////////////////////////////////////////////////////////
;// Octant 0
;/////////////////////////////////////////////////////////////////////

        public  octant_0
octant_0::
        mov     esi,[esp].sf_lNextScan
        mov     [esp].sf_lDelta,esi     ;we're going down
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_lower

        mov     esi,ecx
        or      esi,edx
        jz      next_line               ;we do an early check here for
                                        ; lines that start and end on the
                                        ; same GIQ point, because those
                                        ; occur surprisingly often.
        or      esi,eax
        or      esi,ebx
        and     esi,F - 1
        jnz     oct_0_non_integer

        or      edx,edx
        jz      do_horizontal_line

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_0_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_0_done_bank_map

oct_0_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_0_done_bank_map
oct_0_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        mov     ebx,-1                  ;### round y = 1/2 *DOWN* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b

;-------------------------------------------------------------------------;
; Left-to-right Lines With ABS(Slope) <= 1/2
; ------------------------------------------
;
; Since the line's slope is less than 1/2, we have only 3 possibilities
; at each pair of pixels:
;
;    Case 1:  o            Case 2:  o o            Case 3:  o o o
;               o o                     o
;
; Case:    err + dN >= 0         err + 2dN >= 0          err + 2dN < 0
; New:     err += 2dN - dM       err += 2dN - dM         err += 2dN
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

        public  oct_07a
oct_07a::
        test    edi,1
        jz      short oct_07a_main      ;start is word aligned

; Handle unaligned start:

        dec     esi
        jl      next_line

        mov     [edi],al
        inc     edi
        add     ebx,edx                 ;err += dN
        jl      short oct_07a_main

        add     edi,[esp].sf_lDelta
        dec     ebp                     ;hit a new bank?
        jz      short oct_07a_next_bank_3
oct_07a_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_07a_continue

;;; Case 1:

        public  oct_07a_case_1
oct_07a_case_1::
        sub     esi,2
        jl      short oct_07a_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        add     edi,2
        dec     ebp
        jz      short oct_07a_next_bank_1
oct_07a_done_bank_1:
        mov     [edi-1],al
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_07a_main:
        add     ebx,edx                 ;err += dN
        jge     short oct_07a_case_1
oct_07a_continue:
        sub     esi,2
        jl      short oct_07a_done
        mov     [edi],ax
        add     edi,2
        add     ebx,edx                 ;err += dN
        jl      short oct_07a_main      ;;;case 3 is done

;;; Handle end of case 2:

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_07a_next_bank_2
oct_07a_done_bank_2:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_07a_case_1
        jmp     short oct_07a_continue  ;;;case 2 is done

oct_07a_done:
        inc     esi                     ;esi = -1 means do another pixel
        jnz     next_line
        mov     [edi],al
        jmp     next_line

oct_07a_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_07a_done_bank_1
        jmp     [esp].sf_pfnNextBank
oct_07a_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_07a_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_07a_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_07a_done_bank_3
        jmp     [esp].sf_pfnNextBank

;-------------------------------------------------------------------------;
; Left-to-right Lines With 1/2 < ABS(Slope) <= 1
; ----------------------------------------------
;
; Since the line's slope is between 1/2 and 1, we have only 3 possibilities
; at each pair of pixels:
;
;   Case 1:  o o          Case 2:  o              Case 3:  o
;                o                   o o                     o
;                                                              o
;
; Case:   err + dN < 0          err + 2dN - dM < 0      err + 2dN - dM >= 0
; New:    err += 2dN - dM       err += 2dN - dM         err += 2dN - 2dM
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

        public  oct_07b
oct_07b::
        test    edi,1
        jz      short oct_07b_main

        dec     esi
        jl      next_line

        mov     [edi],al
        inc     edi
        add     ebx,edx                 ;err += dN
        jl      short oct_07b_main

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_07b_next_bank_4
oct_07b_done_bank_4:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_07b_continue

        public  oct_07b_case_1
oct_07b_case_1::
        sub     esi,2
        jl      short oct_07b_done
        mov     [edi],ax
        add     edi,[esp].sf_lDelta
        add     edi,2
        dec     ebp
        jz      short oct_07b_next_bank_1
oct_07b_done_bank_1:
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_07b_main:
        add     ebx,edx                 ;err += dN
        jl      short oct_07b_case_1
oct_07b_continue:
        sub     esi,2
        jl      short oct_07b_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        add     edi,2
        dec     ebp
        jz      short oct_07b_next_bank_2
oct_07b_done_bank_2:
        mov     [edi-1],al
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_07b_main      ;;;case 2 is done

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      oct_07b_next_bank_3
oct_07b_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_07b_case_1    ;;;case 3 is done
        jmp     short oct_07b_continue

oct_07b_next_bank_4:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_4
        jmp     [esp].sf_pfnNextBank
oct_07b_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_3
        jmp     [esp].sf_pfnNextBank
oct_07b_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_07b_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_07b_done_bank_1
        jmp     [esp].sf_pfnNextBank

oct_07b_done:
        inc     esi
        jnz     next_line               ;esi = -1 means do another pixel
        mov     [edi],al
        jmp     next_line

;-------------------------------------------------------------------------;

        public  oct_0_non_integer
oct_0_non_integer::
        cmp     ecx,edx
        je      oct_0_slope_one         ;have a special case rounding rule for
                                        ; 45 degree lines (which only affects
                                        ; non-integer lines)

        GIQ     ROUND_X_AND_Y_DOWN      ;### round x=1/2, y=1/2 down in value

        or      edx,edx
        jz      do_non_integer_horizontal_line

oct_0_common:
        mov     esi,[esp].sf_ppdev
        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_0_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_0_nonint_done_bank_map

oct_0_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_0_nonint_done_bank_map:
        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,edi                 ;### ebp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan  ;
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        sub     esi,eax                 ;esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b
        jmp     oct_07a

;-------------------------------------------------------------------;
; 45 degree lines have a special rounding rule: when the line
; runs exactly half way between to pixels, the upper or right pel
; is illuminated.  This translates into x=1/2 rounding up, and
; y=1/2 rounding down in value:

        public  oct_0_slope_one
oct_0_slope_one::
        GIQ     ROUND_Y_DOWN_SLOPE_ONE  ;round y=1/2 down in value
        jmp     oct_0_common

;/////////////////////////////////////////////////////////////////////
;// Octant 1
;/////////////////////////////////////////////////////////////////////

        public  octant_1
octant_1::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_lower

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_1_non_integer

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_1_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_1_done_bank_map

oct_1_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_1_done_bank_map
oct_1_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan

        mov     ebx,-1                  ;### round x = 1/2 *DOWN* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor

;-------------------------------------------------------------------------;
; Left-to-right Lines With Abs(Slope) > 1/2
; -----------------------------------------
;
; eax = color
; ebx = error term
; ecx = dM
; edx = dN
; esi = delta
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

oct_1_main_loop:
        dec     ebp
        jl      short oct_1_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_1_main_loop

        inc     edi                     ;one to right
        sub     ebx,edx                 ;err -= dN

; Unroll a bit:

        dec     ebp
        jl      short oct_1_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_1_main_loop

        inc     edi                     ;one to right
        sub     ebx,edx                 ;err -= dN
        jmp     short oct_1_main_loop

        public  oct_1_see_if_more
oct_1_see_if_more::
        mov     eax,[esp].sf_cAfterThisBank
        cmp     eax,0
        jle     next_line

        mov     [esp].sf_pfnReturn,offset oct_1_main_loop
        jmp     [esp].sf_pfnNextBank

        public  oct_1_non_integer
oct_1_non_integer::
        GIQR    ROUND_X_AND_Y_DOWN      ;### round x=1/2, y=1/2 down in value

        mov     esi,[esp].sf_ppdev
        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_1_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_1_nonint_done_bank_map

oct_1_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_1_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        mov     esi,[esp].sf_y1
        sub     esi,ebp

        sbb     eax,eax
        and     eax,esi
        add     ebp,eax
        sub     ebp,[esp].sf_y0         ;ebp = min(y1,
                                        ; ppdev->rcl1WindowClip.yBottom) - y0
                                        ; (# of pixels to lay down)

        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        mov     eax,[esp].sf_iColor

        jmp     oct_1_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 3
;/////////////////////////////////////////////////////////////////////

octants_2_3_4_5:
        neg     ecx                     ;dM = -dM (now positive)
        neg     eax                     ;M0 = -M0
        sub     edx,ebx
        jl      octants_4_5
        cmp     ecx,edx
        jl      octant_2

        public  octant_3
octant_3::
        mov     esi,[esp].sf_lNextScan
        mov     [esp].sf_lDelta,esi     ;we're going down
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_lower

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_3_non_integer

        or      edx,edx
        jz      flip_and_do_horizontal_line

        mov     esi,[esp].sf_ppdev

        neg     eax                     ;### untransform M0

        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_3_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_3_done_bank_map

oct_3_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and esi are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_3_done_bank_map
oct_3_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        mov     ebx,-1                  ;### round y = 1/2 *DOWN* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b

;-------------------------------------------------------------------------;
; Right-to-left Lines With ABS(Slope) <= 1/2
; ------------------------------------------
;
; Since the line's slope is less than 1/2, we have only 3 possibilities
; at each pair of pixels:
;
;    Case 1:  o            Case 2:  o o            Case 3:  o o o
;               o o                     o
;
; Case:    err + dN >= 0         err + 2dN >= 0          err + 2dN < 0
; New:     err += 2dN - dM       err += 2dN - dM         err += 2dN
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

oct_34a:
        test    edi,1
        jnz     short oct_34a_main      ;### start is word aligned

; Handle unaligned start:

        dec     esi
        jl      next_line

        mov     [edi],al
        dec     edi                     ;###
        add     ebx,edx                 ;err += dN
        jl      short oct_34a_main

        add     edi,[esp].sf_lDelta
        dec     ebp                     ;hit a new bank?
        jz      short oct_34a_next_bank_3
oct_34a_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_34a_continue

;;; Case 1:

        public  oct_34a_case_1
oct_34a_case_1::
        sub     esi,2
        jl      short oct_34a_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        sub     edi,2                   ;###
        dec     ebp
        jz      short oct_34a_next_bank_1
oct_34a_done_bank_1:
        mov     [edi+1],al
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_34a_main:
        add     ebx,edx                 ;err += dN
        jge     short oct_34a_case_1
oct_34a_continue:
        sub     esi,2
        jl      short oct_34a_done
        mov     [edi-1],ax              ;###
        sub     edi,2                   ;###
        add     ebx,edx                 ;err += dN
        jl      short oct_34a_main      ;;;case 3 is done

;;; Handle end of case 2:

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_34a_next_bank_2
oct_34a_done_bank_2:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_34a_case_1
        jmp     short oct_34a_continue  ;;;case 2 is done

oct_34a_done:
        inc     esi                     ;esi = -1 means do another pixel
        jnz     next_line
        mov     [edi],al
        jmp     next_line

oct_34a_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_34a_done_bank_1
        jmp     [esp].sf_pfnNextBank
oct_34a_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_34a_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_34a_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_34a_done_bank_3
        jmp     [esp].sf_pfnNextBank

;-------------------------------------------------------------------------;
; Right-to-left Lines With 1/2 < ABS(Slope) <= 1
; ----------------------------------------------
;
; Since the line's slope is between 1/2 and 1, we have only 3 possibilities
; at each pair of pixels:
;
;   Case 1:  o o          Case 2:  o              Case 3:  o
;                o                   o o                     o
;                                                              o
;
; Case:   err + dN < 0          err + 2dN - dM < 0      err + 2dN - dM >= 0
; New:    err += 2dN - dM       err += 2dN - dM         err += 2dN - 2dM
;
; eax = color
; ebx = error term
; ecx = dM - dN
; edx = dN
; esi = # of pixels to lay down
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

        public  oct_34b
oct_34b::
        test    edi,1
        jnz     short oct_34b_main      ;###

        dec     esi
        jl      next_line

        mov     [edi],al
        dec     edi                     ;###
        add     ebx,edx                 ;err += dN
        jl      short oct_34b_main

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      short oct_34b_next_bank_4
oct_34b_done_bank_4:
        sub     ebx,ecx                 ;err += dN - dM
        jge     short oct_34b_continue

        public  oct_34b_case_1
oct_34b_case_1::
        sub     esi,2
        jl      short oct_34b_done
        mov     [edi-1],ax              ;###
        add     edi,[esp].sf_lDelta
        sub     edi,2                   ;###
        dec     ebp
        jz      short oct_34b_next_bank_1
oct_34b_done_bank_1:
        sub     ebx,ecx                 ;err += dN - dM
                                        ;;;case 1 is done
;;; Main loop:

oct_34b_main:
        add     ebx,edx                 ;err += dN
        jl      short oct_34b_case_1
oct_34b_continue:
        sub     esi,2
        jl      short oct_34b_done
        mov     [edi],al
        add     edi,[esp].sf_lDelta
        sub     edi,2                   ;###
        dec     ebp
        jz      short oct_34b_next_bank_2
oct_34b_done_bank_2:
        mov     [edi+1],al
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_34b_main      ;;;case 2 is done

        add     edi,[esp].sf_lDelta
        dec     ebp
        jz      oct_34b_next_bank_3
oct_34b_done_bank_3:
        sub     ebx,ecx                 ;err += dN - dM
        jl      short oct_34b_case_1    ;;;case 3 is done
        jmp     short oct_34b_continue

oct_34b_next_bank_4:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_4
        jmp     [esp].sf_pfnNextBank
oct_34b_next_bank_3:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_3
        jmp     [esp].sf_pfnNextBank
oct_34b_next_bank_2:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_2
        jmp     [esp].sf_pfnNextBank
oct_34b_next_bank_1:
        mov     [esp].sf_pfnReturn,offset oct_34b_done_bank_1
        jmp     [esp].sf_pfnNextBank

oct_34b_done:
        inc     esi
        jnz     next_line               ;esi = -1 means do another pixel
        mov     [edi],al
        jmp     next_line

;-------------------------------------------------------------------------;

        public  oct_3_non_integer
oct_3_non_integer::
        GIQ     ROUND_Y_DOWN            ;### round y=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'x')

        or      edx,edx
        jz      flip_and_do_non_integer_horizontal_line

        mov     esi,[esp].sf_ppdev
        neg     eax                     ;### Untransform x0
        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_3_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_3_nonint_done_bank_map

oct_3_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_3_nonint_done_bank_map:
        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,edi                 ;### ebp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan  ;
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        add     esi,eax                 ;### esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b
        jmp     oct_34a

;/////////////////////////////////////////////////////////////////////
;// Octant 2
;/////////////////////////////////////////////////////////////////////

        public  octant_2
octant_2::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_lower

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_2_non_integer

        neg     eax                     ;### untransform M0

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_2_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_2_done_bank_map

oct_2_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_2_done_bank_map
oct_2_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        sub     ebp,ebx                 ;### ebp = # of scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan

        xor     ebx,ebx                 ;### round x = 1/2 *UP* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor

;-------------------------------------------------------------------------;
; Right-to-left Lines With Abs(Slope) > 1/2
; -----------------------------------------
;
; eax = color
; ebx = error term
; ecx = dM
; edx = dN
; esi = delta
; edi = memory pointer
; ebp = # of scans before end of bank
;-------------------------------------------------------------------------;

oct_2_main_loop:
        dec     ebp
        jl      short oct_2_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_2_main_loop

        dec     edi                     ;one to left
        sub     ebx,edx                 ;err -= dN

; Unroll a bit:

        dec     ebp
        jl      short oct_2_see_if_more
        mov     [edi],al
        add     edi,esi
        add     ebx,ecx                 ;err += dM
        jl      short oct_2_main_loop

        dec     edi                     ;one to left
        sub     ebx,edx                 ;err -= dN
        jmp     short oct_2_main_loop

        public  oct_2_see_if_more
oct_2_see_if_more::
        mov     eax,[esp].sf_cAfterThisBank
        cmp     eax,0
        jle     next_line

        mov     [esp].sf_pfnReturn,offset oct_2_main_loop
        jmp     [esp].sf_pfnNextBank

        public  oct_2_non_integer
oct_2_non_integer::
        GIQR    ROUND_Y_DOWN            ;### round y=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'x')

        mov     esi,[esp].sf_ppdev

        neg     eax                     ;### untransform x0

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_2_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_2_nonint_done_bank_map

oct_2_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyTop>  ;###

        pop     edx
        pop     ecx
        pop     eax

oct_2_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esi].pdev_rcl1WindowClip.yBottom
        mov     esi,[esp].sf_y1
        sub     esi,ebp

        sbb     eax,eax
        and     eax,esi
        add     ebp,eax
        sub     ebp,[esp].sf_y0         ;ebp = min(y1,
                                        ; ppdev->rcl1WindowClip.yBottom) - y0
                                        ; (# of pixels to lay down)

        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        mov     eax,[esp].sf_iColor

        jmp     oct_2_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 4
;/////////////////////////////////////////////////////////////////////

octants_4_5:
        neg     edx
        neg     ebx
        cmp     ecx,edx
        jl      octant_5

        public  octant_4
octant_4::
        mov     esi,[esp].sf_lNextScan
        neg     esi
        mov     [esp].sf_lDelta,esi     ;we're going up
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_4_non_integer

        neg     eax                     ;### untransform x
        neg     ebx                     ;### untransform y

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_4_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_4_done_bank_map

oct_4_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and esi are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_4_done_bank_map
oct_4_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        xor     ebx,ebx                 ;### round y = 1/2 *UP* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b
        jmp     oct_34a

        public  oct_4_non_integer
oct_4_non_integer::
        cmp     ecx,edx
        je      oct_4_slope_one
        GIQ     0                       ;###
                                        ;###  (remember that we're flipped
                                        ;###  in 'x' and 'y')

oct_4_common:
        mov     esi,[esp].sf_ppdev
        neg     edi                     ;### untransform y
        neg     eax                     ;### untransform x

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_4_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_4_nonint_done_bank_map

oct_4_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyBottom>;###

        pop     edx
        pop     ecx
        pop     eax

oct_4_nonint_done_bank_map:
        mov     ebp,edi                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### esp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        add     esi,eax                 ;### esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_34b
        jmp     oct_34a

;-------------------------------------------------------------------;
; 45 degree lines have a special rounding rule: when the line
; runs exactly half way between to pixels, the upper or right pel
; is illuminated.  This translates into x=1/2 rounding up, and
; y=1/2 rounding down in value:

        public  oct_4_slope_one
oct_4_slope_one::
        GIQ     ROUND_X_DOWN_SLOPE_ONE  ;round x=1/2 down in value
        jmp     oct_4_common

;/////////////////////////////////////////////////////////////////////
;// Octant 5
;/////////////////////////////////////////////////////////////////////

        public  octant_5
octant_5::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_5_non_integer

        mov     esi,[esp].sf_ppdev
        neg     eax                     ;### untransform
        neg     ebx                     ;### untransform
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_5_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_5_done_bank_map

oct_5_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,ebx,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_5_done_bank_map
oct_5_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!

        xor     ebx,ebx                 ;### round x = 1/2 *UP* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        jmp     oct_2_main_loop

        public  oct_5_non_integer
oct_5_non_integer::
        GIQR    0                       ;###
                                        ;###  (remember that we're flipped
                                        ;###  in 'x' and 'y')

        mov     esi,[esp].sf_ppdev

        neg     edi                     ;### untransform y0
        neg     eax                     ;### untransform x0

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_5_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_5_nonint_done_bank_map

oct_5_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,edi,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

oct_5_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esp].sf_y0         ;###
        mov     esi,[esi].pdev_rcl1WindowClip.yTop
        dec     esi                     ;### make top exclusive
        sub     ebp,esi                 ;###
        add     esi,[esp].sf_y1         ;### don't forget that y1 wasn't un-
                                        ;###  transformed (so this is an 'add')

        jg      short @F                ;###
        add     ebp,esi                 ;###
@@:
        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!
        mov     eax,[esp].sf_iColor

        jmp     oct_2_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 6
;/////////////////////////////////////////////////////////////////////

        public  octants_6_7
octants_6_7::
        neg     edx                     ;dN = -dN (now positive)
        neg     ebx                     ;M1 = -M1
        cmp     ecx,edx
        jge     octant_7

        public  octant_6
octant_6::
        mov     [esp].sf_pfnNextBank,offset bank_y_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_6_non_integer

        mov     esi,[esp].sf_ppdev
        neg     ebx                     ;### untransform
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_6_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_6_done_bank_map

oct_6_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,ebx,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_6_done_bank_map
oct_6_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,edx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        sub     esi,ebp
        sbb     ebx,ebx
        and     ebx,esi
        add     ebp,ebx                 ;ebp = # of pels in this bank

        mov     [esp].sf_cAfterThisBank,esi
        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!

        mov     ebx,-1                  ;### round x = 1/2 *DOWN* in value
        sub     ebx,edx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        jmp     oct_1_main_loop

        public  oct_6_non_integer
oct_6_non_integer::
        GIQR    ROUND_X_DOWN            ;### round x=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'y')

        mov     esi,[esp].sf_ppdev

        neg     edi                     ;### untransform y0

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_6_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_6_nonint_done_bank_map

oct_6_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,edi,JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

oct_6_nonint_done_bank_map:
        mov     [esp].sf_y0,edi
        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi points to start byte

        mov     ebp,[esp].sf_y0         ;###
        mov     esi,[esi].pdev_rcl1WindowClip.yTop
        dec     esi                     ;### make top exclusive
        sub     ebp,esi                 ;###
        add     esi,[esp].sf_y1         ;### don't forget that y1 wasn't un-
                                        ;###  transformed (so this is an 'add')

        jg      short @F                ;###
        add     ebp,esi                 ;###
@@:
        mov     [esp].sf_cAfterThisBank,esi

        mov     esi,[esp].sf_lNextScan
        neg     esi                     ;### going down!
        mov     eax,[esp].sf_iColor

        jmp     oct_1_main_loop

;/////////////////////////////////////////////////////////////////////
;// Octant 7
;/////////////////////////////////////////////////////////////////////

        public  octant_7
octant_7::
        mov     esi,[esp].sf_lNextScan
        neg     esi
        mov     [esp].sf_lDelta,esi     ;we're going up
        mov     [esp].sf_pfnNextBank,offset bank_x_major_next_upper

        mov     esi,eax
        or      esi,ebx
        or      esi,ecx
        or      esi,edx
        and     esi,F - 1
        jnz     oct_7_non_integer

        neg     ebx                     ;### untransform y

        mov     esi,[esp].sf_ppdev
        sar     eax,FLOG2               ;x0
        sar     ebx,FLOG2               ;y0

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_7_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_7_done_bank_map

oct_7_map_in_bank:
        push    eax
        push    ecx
        push    edx

; ebx, esi, edi and esi are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyBottom> ;###

        pop     edx
        pop     ecx
        pop     eax

        public  oct_7_done_bank_map
oct_7_done_bank_map::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     ebp,ebx                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### ebp = # scans before end of bank

        mov     esi,ecx
        sar     esi,FLOG2               ;esi = # of pixels to lay down

        xor     ebx,ebx                 ;### round y = 1/2 *UP* in value
        sub     ebx,ecx
        sar     ebx,1                   ;now have error term

        mov     eax,[esp].sf_iColor
        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b
        jmp     oct_07a

        public  oct_7_non_integer
oct_7_non_integer::
        cmp     ecx,edx
        je      oct_7_slope_one
        GIQ     ROUND_X_DOWN            ;### round x=1/2 down in value
                                        ;###  (remember that we're flipped
                                        ;###  in 'y')

oct_7_common:
        mov     esi,[esp].sf_ppdev
        neg     edi                     ;### untransform y

        cmp     edi,[esi].pdev_rcl1WindowClip.yTop
        jl      short oct_7_nonint_map_in_bank

        cmp     edi,[esi].pdev_rcl1WindowClip.yBottom
        jl      short oct_7_nonint_done_bank_map

oct_7_nonint_map_in_bank:
        push    eax
        push    ecx
        push    edx

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, edi, JustifyBottom>;###

        pop     edx
        pop     ecx
        pop     eax

oct_7_nonint_done_bank_map:
        mov     ebp,edi                 ;###
        sub     ebp,[esi].pdev_rcl1WindowClip.yTop
        inc     ebp                     ;### esp = # scans before end of bank

        imul    edi,[esp].sf_lNextScan
        add     edi,[esi].pdev_pvBitmapStart
        add     edi,eax                 ;edi now points to start byte

        mov     esi,[esp].sf_x1
        sub     esi,eax                 ;esi = # pixels to lay down

        mov     eax,[esp].sf_iColor

        sub     ecx,edx                 ;ecx = dM - dN
        cmp     edx,ecx
        jg      oct_07b
        jmp     oct_07a

;-------------------------------------------------------------------;
; We have to special case those lines with a slope of exactly -1 when
; 'x' rounds down in value after normalizing:

        public  oct_7_slope_one
oct_7_slope_one::
        GIQ     ROUND_X_DOWN_SLOPE_ONE
        jmp     oct_7_common

;-------------------------------------------------------------------------;
; Function to get next lower bank for x-major lines.
;-------------------------------------------------------------------------;

        public  bank_x_major_next_lower
bank_x_major_next_lower::
        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Add 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     esi,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edi,[ebx].pdev_pvBitmapStart

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyTop>

        add     edi,[ebx].pdev_pvBitmapStart
        mov     ebp,[ebx].pdev_rcl1WindowClip.yBottom
        sub     ebp,esi

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;-------------------------------------------------------------------------;
; Function to get next upper bank for x-major lines.
;-------------------------------------------------------------------------;

        public  bank_x_major_next_upper
bank_x_major_next_upper::
        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Add 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     esi,[ebx].pdev_rcl1WindowClip.yTop
        dec     esi
        sub     edi,[ebx].pdev_pvBitmapStart

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyBottom>

        add     edi,[ebx].pdev_pvBitmapStart
        lea     ebp,[esi+1]
        sub     ebp,[ebx].pdev_rcl1WindowClip.yTop

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;-------------------------------------------------------------------------;
; Function to get next lower bank for y-major lines.
;-------------------------------------------------------------------------;

        public  bank_y_major_next_lower
bank_y_major_next_lower::

; eax = # pels after this bank

        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Plus 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     esi,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edi,[ebx].pdev_pvBitmapStart

        push    eax
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyTop>
        pop     eax

        add     edi,[ebx].pdev_pvBitmapStart
        mov     ebp,[ebx].pdev_rcl1WindowClip.yBottom
        sub     ebp,esi                 ;ebp = # of pels can do in this bank
        sub     eax,ebp                 ;esi = # of pels after this bank
        sbb     ebx,ebx
        and     ebx,eax
        add     ebp,ebx                 ;ebp = # of pels in this bank

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx

        mov     [esp].sf_cAfterThisBank,eax
                                        ;this has to be done after 'esp' is
                                        ; restored!

        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;-------------------------------------------------------------------------;
; Function to get next upper bank for y-major lines.
;-------------------------------------------------------------------------;

        public  bank_y_major_next_upper
bank_y_major_next_upper::

; eax = # pels after this bank

        push    ebx
        mov     ebx,[esp+4].sf_ppdev    ;NOTE: Plus 4 because of above push!
        push    ecx
        push    edx
        push    esi

        mov     ebp,[ebx].pdev_rcl1WindowClip.yTop
        dec     ebp

        sub     edi,[ebx].pdev_pvBitmapStart

        push    eax
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,ebp,JustifyBottom>
        pop     eax

        add     edi,[ebx].pdev_pvBitmapStart

        inc     ebp                     ;restore exclusiveness
        sub     ebp,[ebx].pdev_rcl1WindowClip.yTop
                                        ;ebp = # of pels can do in this bank
        sub     eax,ebp                 ;esi = # of pels after this bank
        sbb     ebx,ebx
        and     ebx,eax
        add     ebp,ebx                 ;ebp = # of pels in this bank

        pop     esi
        pop     edx
        pop     ecx
        pop     ebx

        mov     [esp].sf_cAfterThisBank,eax
                                        ;this has to be done after 'esp' is
                                        ; restored!

        mov     eax,[esp].sf_iColor

        jmp     [esp].sf_pfnReturn

;/////////////////////////////////////////////////////////////////////
;// Horizontal Line
;/////////////////////////////////////////////////////////////////////

        public  flip_and_do_non_integer_horizontal_line
flip_and_do_non_integer_horizontal_line::
        mov     ebx,edi
        mov     ecx,[esp].sf_x1
        sub     ecx,eax
        jle     next_line
        add     eax,ecx
        neg     eax
        inc     eax                     ;x0' = -(-original x0 - dx) + 1
        jmp     short horizontal_common

        public  do_non_integer_horizontal_line
do_non_integer_horizontal_line::
        mov     ebx,edi
        mov     ecx,[esp].sf_x1
        sub     ecx,eax
        jg      short horizontal_common
        jmp     next_line

        public  flip_and_do_horizontal_line
flip_and_do_horizontal_line::

; This 'flip' entry point is for lines that were originally right-to-left:

        add     eax,ecx
        neg     eax
        add     eax,F                   ;M0' = -(-original M0 - original dM) + 1

        public  do_horizontal_line
do_horizontal_line::
        sar     eax,FLOG2               ;x0 (we're now in pixel coordinates)
        sar     ebx,FLOG2               ;y0
        sar     ecx,FLOG2               ;dx
        jz      next_line

; NOTE: Have to have some pixels to light at this point
;
; eax = x0 (in pixel coordinates)
; ebx = y0
; ecx = dx (# pixels to light)

horizontal_common:
        mov     esi,[esp].sf_ppdev

        cmp     ecx,NUM_PELS_NEEDED_FOR_PLANAR_HORIZONTAL
        jl      do_short_horizontal_line

        test    [esi].pdev_fl,DRIVER_PLANAR_CAPABLE
        jz      do_short_horizontal_line

;---------------------------------------------------------------------;
; Draw horizontal lines using planar mode.
;
; NOTE: This code assumes that the length is at least 8 pels long!

        public  horizontal_planar
horizontal_planar::
        mov     edi,[esi].pdev_lPlanarNextScan
        imul    edi,ebx

        cmp     ebx,[esi].pdev_rcl1PlanarClip.yTop
        jl      short hor_planar_map_bank

        cmp     ebx,[esi].pdev_rcl1PlanarClip.yBottom
        jl      short hor_planar_done_bank

hor_planar_map_bank:
        push    eax
        push    ecx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnPlanarControl>, \
                <esi,ebx,JustifyTop>

        pop     ecx
        pop     eax

hor_planar_done_bank:
        add     edi,[esi].pdev_pvBitmapStart

        mov     ebp,eax                 ;save x0
        sar     eax,2
        add     edi,eax                 ;edi now points to start byte

        and     ebp,3
        jz      short hor_planar_start_middle

; When the left end doesn't start on a quadpixel boundary, we have to
; adjust the start address and do some other stuff:

        mov     [esp].sf_pjStart,edi
        inc     edi
        sub     ebp,4
        add     ecx,ebp                 ;adjust byte count to account for
                                        ; fractional start

hor_planar_start_middle:
        mov     eax,[esp].sf_iColor     ;load the color
        mov     esi,ecx                 ;save length

        test    edi,1
        jz      short hor_planar_middle_aligned
        mov     [edi],al                ;handle unaligned whole start byte
        inc     edi
        sub     ecx,4
hor_planar_middle_aligned:
        shr     ecx,3                   ;NOTE: we look at the carry later!
        rep     stosw                   ;write middle as words
        jnc     short hor_planar_handle_ends
                                        ;NOTE: here we look at the carry!
        mov     [edi],al                ;handle whole end byte
        inc     edi

hor_planar_handle_ends:
        mov     edx,VGA_BASE + SEQ_DATA
        and     esi,3
        jz      short hor_planar_left
hor_planar_right:
        mov     ecx,esi
        mov     eax,0f0h
        rol     al,cl                   ;we compute the mask instead of
                                        ; using a look-up table, because the
                                        ; table probably wouldn't be in the
                                        ; cache

; Set right mask by disabling some planes:

        out     dx,al

        push    eax                     ;we add a delay here because some
        pop     eax                     ; cards can't handle a write too soon
                                        ; after an out.  Hopefully this will
                                        ; help.

        mov     eax,[esp].sf_iColor
        mov     [edi],al

hor_planar_left:
        and     ebp,3
        jz      short hor_planar_done

        mov     ecx,ebp
        mov     eax,0fh
        shl     eax,cl

; Set left mask by disabling some planes:

        out     dx,al

        push    eax                     ;we add a delay here because some
        pop     eax                     ; cards can't handle a write too soon
                                        ; after an out.  Hopefully this will
                                        ; help.

        mov     edi,[esp].sf_pjStart
        mov     eax,[esp].sf_iColor
        mov     [edi],al

hor_planar_done:
        mov     al,MM_ALL
        out     dx,al

        jmp     next_line

;---------------------------------------------------------------------;
; Draw horizontal lines using linear mode.

        public  do_short_horizontal_line
do_short_horizontal_line::
        mov     edi,[esp].sf_lNextScan
        imul    edi,ebx
        add     edi,eax

        cmp     ebx,[esi].pdev_rcl1WindowClip.yTop
        jl      short hor_map_in_bank

        cmp     ebx,[esi].pdev_rcl1WindowClip.yBottom
        jl      short hor_done_bank_map

hor_map_in_bank:
        push    ecx

; ebx, esi, edi and ebp are preserved according to C calling conventions:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi,ebx,JustifyTop>

        pop     ecx

hor_done_bank_map:
        add     edi,[esi].pdev_pvBitmapStart
                                        ;edi now points to start byte
        mov     eax,[esp].sf_iColor

        test    edi,1
        jz      short hor_aligned
        mov     [edi],al                ;write initial unaligned byte
        inc     edi
        dec     ecx
        jz      next_line

hor_aligned:
        shr     ecx,1                   ;NOTE: we look at the carry later!
        rep     stosw                   ;write middle words
        jnc     next_line               ;NOTE: here we look at the carry!
        mov     [edi],al                ;write last byte
        jmp     next_line


endProc vFastLine

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: TextOut.c
*
* Text
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

BOOL vFastText(PDEV *, GLYPHPOS *, ULONG, PBYTE, ULONG, ULONG, RECTL *,
    RECTL *, INT, INT, ULONG);
VOID lclFillRect(CLIPOBJ *, ULONG, PRECTL, PPDEV, INT);


#define     FIFTEEN_BITS        ((1 << 15)-1)

#define     TAKING_ALLOC_STATS      0

#if TAKING_ALLOC_STATS
    ULONG BufferHitInText = 0;
    ULONG BufferMissInText = 0;
#endif

/****************************************************************************
 * DrvTextOut
 ***************************************************************************/

BOOL DrvTextOut(
    SURFOBJ*  pso,
    STROBJ*   pstro,
    FONTOBJ*  pfo,
    CLIPOBJ*  pco,
    RECTL*    prclExtra,
    RECTL*    prclOpaque,
    BRUSHOBJ* pboFore,
    BRUSHOBJ* pboOpaque,
    POINTL*   pptlOrg,
    MIX       mix)
{
    BOOL    b;
    PPDEV   ppdev;
    INT     iClip;              // clip object's complexity
    ULONG   iSolidForeColor;    // Solid foreground color
    ULONG   iSolidBkColor;      // Solid background color
    RECTL   arclTmp[4];         // Temp storage for portions of opaquing rect
    ULONG   culRcl;             // Temp rectangle count
    PVOID   pvBuf;              // pointer to buffer we'll use

    ULONG   ulBufferWidthInBytes;
    ULONG   ulBufferHeight;
    ULONG   ulBufferBytes;
    BOOL    bTextPerfectFit;
    ULONG   fDrawFlags;


    ppdev = (PPDEV) pso->dhpdev;


    //---------------------------------------------------------------------
    // Get information about clip object.
    //---------------------------------------------------------------------

    iClip = DC_TRIVIAL;

    if (pco != NULL) {
        iClip = pco->iDComplexity;
    }

    //---------------------------------------------------------------------
    // Get text color.
    //---------------------------------------------------------------------

    iSolidForeColor = pboFore->iSolidColor;

    //---------------------------------------------------------------------
    // See if this is text we can handle faster with special-case code.
    //---------------------------------------------------------------------

    if (((ppdev->fl & DRIVER_PLANAR_CAPABLE) ||
        (prclOpaque == (PRECTL) NULL)) &&   // opaque only if planar for now
                                            // LATER implement fast non-planar
                                            // opaque
        (iClip == DC_TRIVIAL) &&            // no clipping for now
            ((pstro->rclBkGround.right & ~0x03) >
             ((pstro->rclBkGround.left + 3) & ~0x03)) &&
                                            // not if no full nibbles spanned
                                            //  for now @@@
            (pstro->pgp != NULL) &&         // no glyph enumeration for now
            (prclExtra == NULL) &&          // no extra rects for now
            ((pstro->flAccel & (SO_HORIZONTAL | SO_VERTICAL | SO_REVERSED)) ==
             SO_HORIZONTAL)) {              // only left-to-right text for now

        // It's the type of text we can special-case; see if the temp buffer is
        // big enough for the text.

        ulBufferWidthInBytes = ((((pstro->rclBkGround.right + 7) & ~0x07) -
                (pstro->rclBkGround.left & ~0x07)) >> 3);

        ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;

        ulBufferBytes = ulBufferWidthInBytes * ulBufferHeight;

        if ((ulBufferWidthInBytes > FIFTEEN_BITS) ||
            (ulBufferHeight > FIFTEEN_BITS))
        {
            // the math will have overflowed
            return(FALSE);
        }

        if (ulBufferBytes <= GLOBAL_BUFFER_SIZE)
        {
#if TAKING_ALLOC_STATS
            BufferHitInText++;
#endif
            pvBuf = ppdev->pvTmpBuf;
        }
        else
        {
#if TAKING_ALLOC_STATS
            BufferMissInText++;
#endif
            pvBuf = EngAllocUserMem(ulBufferBytes, ALLOC_TAG);
            if (!pvBuf)
            {
                goto no_special_case;
            }
        }

        // It's big enough; set up for the accelerator

        // Set fixed pitch, overlap, and top & bottom Y alignment flags
        fDrawFlags = ((pstro->ulCharInc != 0) ? 0x01 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT)) !=
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT))
                      ? 0x02 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ? 0x04 : 0);

        // If there's an opaque rectangle, we'll do as much opaquing as
        // possible as we do the text. If the opaque rectangle is larger
        // than the text rectangle, then we'll do the fringe areas right
        // now, and the text and associated background areas together,
        // later.
        if (prclOpaque != (PRECTL) NULL) {

            // This driver only handles solid brushes
            iSolidBkColor = pboOpaque->iSolidColor;

            // See if we have fringe areas to do. If so, build a list of
            // rectangles to fill, in rightdown order

            culRcl = 0;

            // Top fragment
            if (pstro->rclBkGround.top > prclOpaque->top) {
                arclTmp[culRcl].top = prclOpaque->top;
                arclTmp[culRcl].left = prclOpaque->left;
                arclTmp[culRcl].right = prclOpaque->right;
                arclTmp[culRcl++].bottom = pstro->rclBkGround.top;
            }

            // Left fragment
            if (pstro->rclBkGround.left > prclOpaque->left) {
                arclTmp[culRcl].top = pstro->rclBkGround.top;
                arclTmp[culRcl].left = prclOpaque->left;
                arclTmp[culRcl].right = pstro->rclBkGround.left;
                arclTmp[culRcl++].bottom = pstro->rclBkGround.bottom;
            }

            // Right fragment
            if (pstro->rclBkGround.right < prclOpaque->right) {
                arclTmp[culRcl].top = pstro->rclBkGround.top;
                arclTmp[culRcl].right = prclOpaque->right;
                arclTmp[culRcl].left = pstro->rclBkGround.right;
                arclTmp[culRcl++].bottom = pstro->rclBkGround.bottom;
            }

            // Bottom fragment
            if (pstro->rclBkGround.bottom < prclOpaque->bottom) {
                arclTmp[culRcl].bottom = prclOpaque->bottom;
                arclTmp[culRcl].left = prclOpaque->left;
                arclTmp[culRcl].right = prclOpaque->right;
                arclTmp[culRcl++].top = pstro->rclBkGround.bottom;
            }

            if (culRcl != 0) {
                if (iClip == DC_TRIVIAL) {
                    vTrgBlt(ppdev, culRcl, arclTmp, R2_COPYPEN,
                            *((RBRUSH_COLOR*) &iSolidBkColor), NULL);
                } else {
                    lclFillRect(pco, culRcl, arclTmp, ppdev,
                                iSolidBkColor);
                }
            }
        }

        // We're done with separate opaquing; any further opaquing will
        // happen as part of the text drawing

        // Clear the buffer if the text isn't going to set every bit
        bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
                SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
                SO_CHAR_INC_EQUAL_BM_BASE)) ==
                (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

        if (!bTextPerfectFit) {
            vClearMemDword(pvBuf, (ulBufferBytes + 3) >> 2);
        }

        // Draw the text into the temp buffer, and thence to the screen
        vFastText(ppdev,
                  pstro->pgp,
                  pstro->cGlyphs,
                  pvBuf,
                  ulBufferWidthInBytes,
                  pstro->ulCharInc,
                  &pstro->rclBkGround,
                  prclOpaque,
                  iSolidForeColor,
                  iSolidBkColor,
                  fDrawFlags);

        // free any memory that was allocated
        if (ulBufferBytes > GLOBAL_BUFFER_SIZE)
        {
            // we had to have allocated memory
            EngFreeUserMem (pvBuf);
        }

        return(TRUE);
    }
no_special_case:

    // Can't special-case; let the engine draw the text

    pso = ppdev->pSurfObj;

    // It may be that the opaquing rectangle is larger than the text rectangle,
    // so we'll want to use that to tell the bank manager which banks to
    // enumerate:

    pco = pcoBankStart(ppdev,
                       (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                       pso,
                       pco);

    do {
        b = EngTextOut(pso,
                       pstro,
                       pfo,
                       pco,
                       prclExtra,
                       prclOpaque,
                       pboFore,
                       pboOpaque,
                       pptlOrg,
                       mix);

    } while (b && bBankEnum(ppdev, pso, pco));

    return(b);
}

//--------------------------------------------------------------------------
// Fills the specified rectangles on the specified surface with the
// specified color, honoring the requested clipping. No more than four
// rectangles should be passed in. Intended for drawing the areas of the
// opaquing rectangle that extended beyond the text box. The rectangles must
// be in left to right, top to bottom order. Assumes there is at least one
// rectangle in the list.
//--------------------------------------------------------------------------

VOID lclFillRect(
 CLIPOBJ *pco,
 ULONG culRcl,
 PRECTL prcl,
 PPDEV ppdev,
 INT iColor)
{
    BOOL  bMore;                  // Flag for clip enumeration
    TEXTENUM txen;                // Clip enumeration object
    ULONG i, j;
    RECTL arclTmp[4];
    ULONG culRclTmp;
    RECTL *prclTmp, *prclClipTmp;
    INT   iLastBottom;
    RECTL *pClipRcl;
    INT iClip;

    iClip = DC_TRIVIAL;

    if (pco != NULL) {
        iClip = pco->iDComplexity;
    }

    switch ( iClip ) {

        case DC_TRIVIAL:

            vTrgBlt(ppdev, culRcl, prcl, R2_COPYPEN,
                    *((RBRUSH_COLOR*) &iColor), NULL);

            break;

        case DC_RECT:

            prclTmp = &pco->rclBounds;

            // Generate a list of clipped rects
            for (culRclTmp=0, i=0; i<culRcl; i++, prcl++) {

                // Intersect fill and clip rectangles
                if (bIntersectRect(&arclTmp[culRclTmp], prcl, prclTmp)) {

                    // Add to list if anything's left to draw
                    culRclTmp++;
                }
            }

            // Draw the clipped rects
            if (culRclTmp != 0) {
                vTrgBlt(ppdev, culRclTmp, arclTmp, R2_COPYPEN,
                        *((RBRUSH_COLOR*) &iColor), NULL);
            }

            break;

        case DC_COMPLEX:

            // Bottom of last rectangle to fill
            iLastBottom = prcl[culRcl-1].bottom;

            // Initialize the clip rectangle enumeration to rightdown so we can
            // take advantage of the rectangle list being rightdown
            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN,
                    TO_RECT_LIMIT);

            // Scan through all the clip rectangles, looking for intersects
            // of fill areas with region rectangles
            do {

                // Get a batch of region rectangles
                bMore = CLIPOBJ_bEnum(pco, (ULONG)sizeof(txen), (PVOID)&txen);

                // Clip the rect list to each region rect
                for (j = txen.c, pClipRcl = txen.arcl; j-- > 0; pClipRcl++) {

                    // Since the rectangles and the region enumeration are both
                    // rightdown, we can zip through the region until we reach
                    // the first fill rect, and are done when we've passed the
                    // last fill rect.

                    if (pClipRcl->top >= iLastBottom) {
                        // Past last fill rectangle; nothing left to do
                        return;
                    }

                    // Do intersection tests only if we've reached the top of
                    // the first rectangle to fill
                    if (pClipRcl->bottom > prcl->top) {

                        // We've reached the top Y scan of the first rect, so
                        // it's worth bothering checking for intersection

                        // Generate a list of the rects clipped to this region
                        // rect
                        prclTmp = prcl;
                        prclClipTmp = arclTmp;
                        for (i = culRcl, culRclTmp=0; i-- > 0; prclTmp++) {

                            // Intersect fill and clip rectangles
                            if (bIntersectRect(prclClipTmp, prclTmp,
                                    pClipRcl)) {

                                // Add to list if anything's left to draw
                                culRclTmp++;
                                prclClipTmp++;
                            }
                        }

                        // Draw the clipped rects
                        if (culRclTmp != 0) {
                            vTrgBlt(ppdev, culRclTmp, arclTmp, R2_COPYPEN,
                                    *((RBRUSH_COLOR*) &iColor), NULL);
                        }
                    }
                }
            } while (bMore);

            break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\driver.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: driver.inc
;
; Contains prototypes for the 256 colour VGA driver.
;
; NOTE: Must mirror driver.h!
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Sizes assumed for 1-window and 2 RW-window banks.

BANK_SIZE_1_WINDOW      equ 10000h
BANK_SIZE_2RW_WINDOW    equ 8000h

; Specifies desired justification for requestion scan line within bank window

JustifyTop              equ 0
JustifyBottom           equ 1

; Specifies which window is to be mapped by two-window bank handler.

MapSourceBank           equ 0
MapDestBank             equ 1

;------------------------------------------------------------------------;

; Miscellaneous driver flags

DRIVER_PLANAR_CAPABLE       equ 1
DRIVER_OFFSCREEN_REFRESHED  equ 2
DRIVER_HAS_OFFSCREEN        equ 4

; Bank status flags

BANK_BROKEN_RASTER1     equ 1       ; If bank1 or read bank has broken raster
BANK_BROKEN_RASTER2     equ 2       ; If bank2 or write bank has broken raster
BANK_BROKEN_RASTERS     equ (BANK_BROKEN_RASTER1 + BANK_BROKEN_RASTER2)

;------------------------------------------------------------------------;
; Structures for maintaining a realized brush:

RBRUSH_BLACKWHITE       equ 001h    ; Black and white brush
RBRUSH_2COLOR           equ 002h    ; 2 color brush
RBRUSH_NCOLOR           equ 004h    ; n color brush
RBRUSH_4PELS_WIDE       equ 008h    ; Brush is 4xN

BRUSH_SIZE              equ 64      ; An 8x8 8bpp brush needs 64 bytes

RBRUSH struc
rb_fl                       dd  ?           ; Flags
rb_xBrush                   dd  ?           ; Realized brush's x brush origin
                                            ; Pattern in planar format
rb_ulFgColor                dd  ?           ; Foreground color for 2-color
rb_ulBkColor                dd  ?           ; Background color for 2-color
rb_cy                       dd  ?           ; Height of pattern
rb_cyLog2                   dd  ?           ; log2 of height
rb_iCache                   dd  ?           ; Cache entry index; 0 not valid
rb_aulPattern               dd  (BRUSH_SIZE / 4) dup (?)
RBRUSH ends

BRUSHCACHEENTRY struc
bce_prbVerifyRealization    dd  ?           ; For verifying cache entry valid
bce_yCache                  dd  ?           ; Scan where entry's bits live
bce_ulCache                 dd  ?           ; Planar (!) offset to cache entry
BRUSHCACHEENTRY ends

;------------------------------------------------------------------------;
; The Physical Device data structure.

PDEV struc
pdev_fl                     dd  ?   ; Driver flags
pdev_hDriver                dd  ?   ; Handle to \Device\Screen
pdev_hdevEng                dd  ?   ; Engine's handle to PDEV
pdev_hsurfEng               dd  ?   ; Engine's handle to surface
pdev_hsurfBm                dd  ?   ; Handle to the "punt" surface
pdev_pSurfObj               dd  ?   ; Pointer to the locked "punt" surface

pdev_hpalDefault            dd  ?   ; Handle to the default palette for device.

pdev_pjScreen               dd  ?   ; This is pointer to base screen address
pdev_cxScreen               dd  ?   ; Visible screen width
pdev_cyScreen               dd  ?   ; Visible screen height
pdev_ulMode                 dd  ?   ; Mode in which the mini-port driver is
pdev_lDeltaScreen           dd  ?   ; Distance from one scan to the next

pdev_flRed                  dd  ?   ; For bitfields device, Red Mask
pdev_flGreen                dd  ?   ; For bitfields device, Green Mask
pdev_flBlue                 dd  ?   ; For bitfields device, Blue Mask
pdev_cPaletteShift          dd  ?   ; Number of bits the palette must be shifted by
pdev_ulBitCount             dd  ?   ; # of bits per pel 8,16 are only supported

pdev_ulrm0_wmX              dd  ?   ; Values to set GC5 to to select read mode
                                    ;  0 together with write modes 0-3

pdev_pjGlyphFlipTableBase   dd  ?   ; Base allocated address for flip table;
                                    ;  the pointer we use is this pointer
                                    ;  rounded up to the nearest 256-byte
                                    ;  boundary
pdev_pjGlyphFlipTable       dd  ?   ; Pointer to table used to flip glyph bits
                                    ;  0-3 and 4-7

pdev_pPal                   dd  ?   ; If this is pal managed, this is the pal

; Off Screen Save Stuff:

pdev_hbmTmp                 dd  ?   ; Handle to temporary buffer
pdev_psoTmp                 dd  ?   ; Temporary surface

; DCI:

pdev_bSupportDCI            dd  ?   ; Does miniport support DCI?

; Brush cache:

pdev_iCache                 dd  ?   ; Index for last brush to be allocated
pdev_iCacheLast             dd  ?   ; Last valid cache index
pdev_pbceCache              dd  ?   ; Pointer to allocated cache

; Saved screen bits stuff
pdev_rclSavedBitsRight      dd  ?,?,?,? ; right rect of vga memory that's unused
pdev_rclSavedBitsBottom     dd  ?,?,?,? ; bottom rect of vga memory that's unused
pdev_bBitsSaved             dd  ?   ; TRUE if bits are currently saved

; Bank manager stuff common between planar and non-planar modes:

pdev_cTotalScans            dd  ?   ; Number of usable on & off screen scans
pdev_pBankInfo              dd  ?   ; Bank info for current mode
pdev_flBank                 dd  ?   ; Flags for current bank state
pdev_ulBitmapSize           dd  ?   ; Length of bitmap if there were no
                                    ;  banking, in CPU addressable bytes

pdev_ulWindowBank           dd  ?,? ; Current banks mapped into windows
                                    ;  0 & 1 (used in 2 window mode only)

pdev_pvBitmapStart          dd  ?   ; Single-window bitmap start pointer
                                    ;  (adjusted as necessary to make
                                    ;  window map in at proper offset)
pdev_pvBitmapStart2Window   dd  ?,? ; Double-window window 0 and 1 bitmap
                                    ; start

; Non-planar mode specific bank management control stuff:

pdev_vbtBankingType         dd  ?   ; Type of banking
pdev_pfnBankSwitchCode      dd  ?   ; Pointer to bank switch code
pdev_lNextScan              dd  ?   ; Offset to next bank in bytes
pdev_pjJustifyTopBank       dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to banks
pdev_pbiBankInfo            dd  ?   ; Pointer to array of bank clip info
pdev_ulJustifyBottomOffset  dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastBank              dd  ?   ; Index of last valid bank in
pdev_ulBank2RWSkip          dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnBankControl         dd  ?   ; Pointer to bank control function
pdev_pfnBankControl2Window  dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnBankNext            dd  ?   ; Pointer to next bank function
pdev_pfnBankNext2Window     dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1WindowClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2WindowClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for
                                    ;  windows 0 & 1

; Planar mode specific bank management control stuff:

pdev_vbtPlanarType          dd  ?   ; Type of planar banking
pdev_pfnPlanarSwitchCode    dd  ?   ; Pointer to planar bank switch code
pdev_lPlanarNextScan        dd  ?   ; Offset to next planar bank in bytes
pdev_pjJustifyTopPlanar     dd  ?   ; Pointer to lookup table for
                                    ;  converting scans to planar banks
pdev_pbiPlanarInfo          dd  ?   ; Pointer to array of bank clip info
pdev_ulPlanarBottomOffset   dd  ?   ; Number of scans from top to bottom
                                    ;  of bank, for bottom justifying
pdev_iLastPlanar            dd  ?   ; Index of last valid bank in
pdev_ulPlanar2RWSkip        dd  ?   ; Offset from one bank index to next
                                    ;  to make two 32K banks appear to be
                                    ;  one seamless 64K bank

pdev_pfnPlanarControl       dd  ?   ; Pointer to bank control function
pdev_pfnPlanarControl2      dd  ?   ; Pointer to double-window bank
                                    ;  control function

pdev_pfnPlanarNext          dd  ?   ; Pointer to next bank function
pdev_pfnPlanarNext2         dd  ?   ; Pointer to double-window next bank
                                    ;  function
pdev_rcl1PlanarClip         db  (size RECTL) dup (?)
                                    ; Single-window banking clip rect
pdev_rcl2PlanarClip         db  (2*(size RECTL)) dup (?)
                                    ; Double-window banking clip rects for

pdev_pfnPlanarEnable        dd  ?   ; Function to enable planar mode
pdev_pfnPlanarDisable       dd  ?   ; Function to disable planar mode

; Smart bank management stuff:

pdev_iLastScan              dd  ?   ; Last scan we want to enumerate
pdev_pvScanScan0            dd  ?   ; Surface's original pvScan0
pdev_rclSaveBounds          db  (size RECTL) dup (?)
                                    ; Clip object's original bounds
pdev_pcoNull                dd  ?   ; Pointer to empty clip object
pdev_iSaveDComplexity       db  ?   ; Clip object's original complexity
pdev_fjSaveOptions          db  ?   ; Clip object's original flags
pdev_ajFiller               db  ?,? ; Pack to dword alignment

pdev_pvTmpBuf               dd  ?   ; Ptr to buffer attached to pdev
PDEV ends

pdev_rcl2WindowClipS        equ     (pdev_rcl2WindowClip)
pdev_rcl2WindowClipD        equ     (pdev_rcl2WindowClip + (size RECTL))

pdev_rcl2PlanarClipS        equ     (pdev_rcl2PlanarClip)
pdev_rcl2PlanarClipD        equ     (pdev_rcl2PlanarClip + (size RECTL))

pdev_pvBitmapStart2WindowS  equ     (pdev_pvBitmapStart2Window)
pdev_pvBitmapStart2WindowD  equ     (pdev_pvBitmapStart2Window + dword)

;------------------------------------------------------------------------;

; Macro to do a simple RET, with no stack stuff, in a proc.

PLAIN_RET macro
        db      0c3h
        endm

; Macro to replace a CALL followed immediately by a JMP:

CALL_AND_JUMP macro CALL_ADDR,JUMP_ADDR
        push    offset JUMP_ADDR
        jmp     CALL_ADDR
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; BOOL vFastText(PDEV * ppdev, GLYPHPOS * pGlyphPos, ULONG ulGlyphCount,
;                PBYTE pTempBuffer, ULONG ulBufDelta, ULONG ulCharInc,
;                RECTL * prclText, RECTL * prclOpaque, INT iFgColor,
;                INT iBgColor, ULONG fDrawFlags);
; ppdev -
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta - logical width of temp buffer in bytes. This value *must* be the
;               same number of bytes spanned by prclText; it is assumed that
;               scans in the temp buffer are contiguous
; ulCharInc -
; prclText -
; prclOpaque -
; iFgColor -
; iBgColor -
; fDrawFlags -
;
; Performs accelerated proportional text drawing.
;
;-----------------------------------------------------------------------;
;
; Note: The general opaque text back-end currently assumes that it will
; never receive a text string with a bounding box that does not span at
; least one quadpixel (the four pixels at a VGA screen address).
;
;-----------------------------------------------------------------------;
;
; Note: The term "quadpixel" means a four-pixel set stored across all
; four planes of VGA memory in planar high-color mode. Quadpixels map to
; nibbles in the temp buffer in which text is assembled, where nibbles
; are always bits 4-7 or 0-3.
;
;-----------------------------------------------------------------------;
;
; Note: The direction flag is *not* explicitly set or cleared.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to draw the text into a system
memory buffer, then copy the buffer to the screen a word at a time
using write mode 2 and clever use of the VGA hardware so that no OUTs
and a minimum of display memory reads are required. The clever use is
setting the ALUs to XOR, the latches to the background color, and the
write mode to 2, so each nibble in bits 0-3 written by the CPU turns
into 0 or 0ffh for that plane. Then the Bit Mask is set to fg ^ bg,
so that common bits between the fg and bg are preserved, while non-
common bits are either preserved (=bg color) by a 0->000h bit for
that plane, or flipped (=fg color) by a 1->0ffh bit for that plane. The
Map Mask is used to clip edges; no read before write is required. Note
that bits 0-3 must be reversed to match the order of pixels in planes
0-3. Note also that we write a whole word, containing two nibbles in
bits 0-3 of each byte, at once, to draw 8 pixels per write.

        commend $

        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      draw_prop_done                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *

;-----------------------------------------------------------------------
; Tables of pointers to optimizations for drawing up to four pixels
; of transparent text based on the upper or lower nibble of a byte.
        align   4
xpar_high_nibble_table  label   dword
        dd      xpar_high_nibble_0
        dd      xpar_high_nibble_1
        dd      xpar_high_nibble_2
        dd      xpar_high_nibble_3
        dd      xpar_high_nibble_4
        dd      xpar_high_nibble_5
        dd      xpar_high_nibble_6
        dd      xpar_high_nibble_7
        dd      xpar_high_nibble_8
        dd      xpar_high_nibble_9
        dd      xpar_high_nibble_A
        dd      xpar_high_nibble_B
        dd      xpar_high_nibble_C
        dd      xpar_high_nibble_D
        dd      xpar_high_nibble_E
        dd      xpar_high_nibble_F

        align   4
xpar_low_nibble_table   label   dword
        dd      xpar_low_nibble_0
        dd      xpar_low_nibble_1
        dd      xpar_low_nibble_2
        dd      xpar_low_nibble_3
        dd      xpar_low_nibble_4
        dd      xpar_low_nibble_5
        dd      xpar_low_nibble_6
        dd      xpar_low_nibble_7
        dd      xpar_low_nibble_8
        dd      xpar_low_nibble_9
        dd      xpar_low_nibble_A
        dd      xpar_low_nibble_B
        dd      xpar_low_nibble_C
        dd      xpar_low_nibble_D
        dd      xpar_low_nibble_E
        dd      xpar_low_nibble_F

; Masks for clipping for the four possible left and right edge alignments
jOpaqueLeftMasks        label   byte
        db      0ffh,00eh,00ch,008h

jOpaqueRightMasks       label   byte
        db      0ffh,001h,003h,007h

;-----------------------------------------------------------------------;

        .code

;-----------------------------------------------------------------------;

cProc vFastText,44,<\
 uses esi edi ebx,\
 ppdev:ptr,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 prclText:ptr,\
 prclOpaque:ptr,\
 iFgColor:dword,\
 iBgColor:dword,\
 fDrawFlags:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulXparBytes:dword ;general loop count storage
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulTopScan:dword     ;top scan of dest text rect in current bank
        local ulBottomScan:dword  ;bottom scan of dest text rect
        local ulNumScans:dword    ;# of scans to draw
        local ulScreenDelta:dword ;scan-to-scan offset in screen
        local ulScreenDeltaLinear:dword ;scan-to-scan offset in screen when in
                                        ; nice, neat linear packed-pixel mode
        local ulTextWidthInBytesMinus1:dword ;# of bytes across spanned by
                                             ; text, minus 1
        local pScreen:dword     ;pointer to first screen byte to which to draw
        local pfnEdgeVector:dword ;pointer to routine to draw any needed edges
        local pfnFirstOpaqVector:dword ;pointer to initial drawing routine
                                       ; called for opaque (either whole
                                       ; bytes, or edge(s) if no whole bytes)
        local ulWholeWidthInQuadpixelPairs:dword ;# of quadpixel pairs to copy
        local ulWholeWidthInQuadpixelPairsMinus1:dword ;# of whole bytes to
                                                       ; copy - 1
        local ulOddQuadpixel:dword      ;1 if odd quadpixel in quadpixel-pair
                                        ; copy
        local ulTextLeft:dword  ;left edge of leftmost glyph
        local ulLeftMask:dword  ;for opaque text, left edge mask for string
        local ulRightMask:dword ;for opaque text, right edge mask for string
        local ulScans:dword     ;# of scans in glyph
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local pGlyphFlipTable:dword ;pointer to look-up table used to reverse
                                    ; the order of bits 0-3 and 4-7
        local ulLeftEdgeShift:dword ;amount by which to right-shift left-edge
                                    ; nibbles during opaque expansion to
                                    ; right-justify them (0 or 4)
        local ulRightEdgeShift:dword ;amount by which to right-shift right-edge
                                     ; nibbles during opaque expansion to
                                     ; right-justify them (0 or 4)
        local ulVGAWidthInBytesMinus1:dword ;# of VGA addresses from left edge
                                            ; to right edge of destination

;-----------------------------------------------------------------------;
; Set the pointer to the table used to flip glyph bits 0-3 and 4-7. This
; table is guaranteed to be on a 256-byte boundary, so look-up can be
; performed simply by loading the low byte of a pointer register.
;-----------------------------------------------------------------------;

        mov     esi,ppdev
        mov     ebx,prclText    ;point to bounding text rect during 486
                                ; interlock slot
        mov     eax,[esi].pdev_pjGlyphFlipTable
        mov     pGlyphFlipTable,eax

;-----------------------------------------------------------------------;
; If 8 wide, byte aligned, and opaque, handle with very fast special-case
; code.
;-----------------------------------------------------------------------;

        cmp     ulCharInc,8                     ;8 wide?
        jnz     short @F                        ;no
        cmp     fDrawFlags,5                    ;fixed pitch?
        jnz     short @F                        ;no
        cmp     prclOpaque,0                    ;opaque?
        jz      short @F                        ;no
        test    [ebx].xLeft,111b                ;byte aligned?
        jz      special_8_wide_aligned_opaque   ;yes, special-case
@@:

general_handler::

        mov     esi,ppdev
        mov     eax,[ebx].yTop
        mov     ulTopScan,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
        and     eax,not 7
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf

        mov     eax,fDrawFlags

        mov     edx,[ebx].yBottom
        mov     ulBottomScan,edx ;bottom scan of text area

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTopScan           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all                                 ; glyphs, because text may overlap never
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      draw_to_screen          ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        mov     eax,ulYOrigin           ;dest Y coordinate

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, color-expand the temp buffer to the screen.
;
; Input:
;       ppdev = pointer to target surface's PDEV (screen)
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       iFgColor = text color
;       iBgColor = opaquing rectangle color, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               word-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
draw_to_screen::

;-----------------------------------------------------------------------;
; Is this transparent or opaque text?
;-----------------------------------------------------------------------;

        cmp     prclOpaque,0
        jnz     opaque_text

;-----------------------------------------------------------------------;
; Transparent text.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Calculate drawing parameters.
;-----------------------------------------------------------------------;

        mov     esi,prclText
        mov     ebx,ppdev
        mov     eax,[esi].xRight
        mov     edx,[esi].xLeft
        and     edx,not 7
        add     eax,7
        sub     eax,edx
        shr     eax,3           ;width of text in temp buffer in bytes, rounded
        mov     ulXparBytes,eax ; up. Also number of quadpixels to draw

        mov     ecx,[ebx].pdev_lNextScan
        mov     ulScreenDelta,ecx
        shl     eax,3           ;each temp buffer byte maps to eight VGA
                                ; addresses (two quadpixels in linear mode)
        sub     ecx,eax         ;offset to next scan in screen
        mov     ulTmpDstDelta,ecx

;-----------------------------------------------------------------------;
; Calculate the offset of the initial destination quadpixel.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop
        mul     ulScreenDelta
        mov     edi,ulTempLeft
        add     edi,eax         ;offset in bitmap of first quadpixel's byte
                                ; (remember, this is linear mode)
;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        mov     eax,[esi].yTop  ;top scan line of text
        mov     ulTopScan,eax
        mov     esi,pTempBuffer ;initial source address
        cmp     eax,[ebx].pdev_rcl1WindowClip.yTop ;is text top less than
                                                   ; current bank?
        jl      short xpar_map_init_bank           ;yes, map in proper bank
        cmp     eax,[ebx].pdev_rcl1WindowClip.yBottom ;text top greater than
                                                      ; current bank?
        jl      short xpar_init_bank_mapped     ;no, proper bank already mapped
xpar_map_init_bank::

; Map in the bank containing the top scan line of the fill.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>

xpar_init_bank_mapped::

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;
; At start of loop, EBX->pdsurf
;-----------------------------------------------------------------------;

xpar_bank_loop::
        mov     edx,ulBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulTopScan           ;# of scans to draw in bank

        mov     al,byte ptr iFgColor
        mov     ah,al
        mov     ebx,eax
        shl     eax,16
        mov     ax,bx                   ;put drawing color in all bytes of EAX

        sub     ebx,ebx                 ;prepare for look-up in loop
xpar_scan_loop::

        mov     ecx,ulXparBytes         ;number of quadpixel pairs to draw

        mov     bl,[esi]                ;get next glyph byte
        and     bl,bl                   ;are all 8 pixels transparent?
        jz      xpar_low_nibble_0       ;yes, just skip everything in this byte
        shr     bl,4                    ;shift the high nibble into the low
                                        ; nibble
        jmp     xpar_high_nibble_table[ebx*4] ;branch to draw up to four
                                              ; pixels, followed by a branch to
                                              ; draw the the other nibble (up
                                              ; to four more pixels)
xpar_scan_done::

        add     edi,ulTmpDstDelta       ;point to next screen scan

        dec     edx                     ;count down scans
        jnz     xpar_scan_loop

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,[ebx].pdev_rcl1WindowClip.yBottom ;is the text bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short do_next_xpar_bank ;no, map in the next bank and draw

        cRet    vFastText               ;yes, so we're done

do_next_xpar_bank::
        mov     ulTopScan,eax
        sub     edi,[ebx].pdev_pvBitmapStart ;convert from address to offset
                                             ; within bitmap
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>
                                             ;map in the bank (call preserves
                                             ; EBX, ESI, and EDI)
        add     edi,[ebx].pdev_pvBitmapStart ;convert from offset within bitmap
                                             ; to address (bitmap start just
                                             ; moved)
        jmp     xpar_bank_loop               ;we're ready to draw to the new
                                             ; bank

;-----------------------------------------------------------------------
; Routines to draw 0-4 pixels with the color in each byte of EAX, depending
; on the value of the nibble describing the four pixels to draw. "high_nibble"
; routines draw based on the upper nibble of the byte pointed to by ESI;
; "low_nibble" routines draw based on the lower nibble of that byte.
;
;  EAX = color with which to draw, repeated four times
;  EBX = zero (0)
;  ECX = the number of nibble pairs (source bytes = pixels*8) to draw
;  EDX = not used (preserved)
;  ESI = pointer to first nibble pair to draw
;  EDI = pointer to first destination byte to which to draw
;
; Must always be entered on the high nibble and extended for an even number of
;  nibbles.

;-----------------------------------------------------------------------
; Macro to draw the four pixels represented by the high nibble of the byte at
; [ESI].

DO_HIGH_NIBBLE macro
        inc     esi             ;point to the next glyph byte
        add     edi,8           ;point to the next destination 8-pixel set
        dec     ecx             ;count down nibble pairs (8-pixel sets)
        jz      xpar_scan_done  ;done with this scan
        mov     bl,[esi]        ;not done; get next glyph byte
        and     bl,bl           ;are all 8 pixels transparent?
        jz      xpar_low_nibble_0 ;yes, just skip everything in this byte
        shr     bl,4            ;shift the high nibble into the low nibble
        jmp     xpar_high_nibble_table[ebx*4] ;branch to draw up to four pixels
        endm

;-----------------------------------------------------------------------
; Macro to draw the four pixels represented by the low nibble of the byte at
; [ESI].

DO_LOW_NIBBLE macro
        mov     bl,[esi]        ;get glyph byte again, for the low nibble this
                                ; time
        and     ebx,0fh         ;isolate the low nibble
        jmp     xpar_low_nibble_table[ebx*4] ;branch to draw up to four pixels
        endm

;-----------------------------------------------------------------------

xpar_high_nibble_F::
        mov     [edi],eax
xpar_high_nibble_0::
        DO_LOW_NIBBLE

xpar_high_nibble_E::
        mov     [edi],ax
        mov     [edi+2],al
        DO_LOW_NIBBLE

xpar_high_nibble_D::
        mov     [edi],ax
        mov     [edi+3],al
        DO_LOW_NIBBLE

xpar_high_nibble_C::
        mov     [edi],ax
        DO_LOW_NIBBLE

xpar_high_nibble_B::
        mov     [edi],al
        mov     [edi+2],ax
        DO_LOW_NIBBLE

xpar_high_nibble_8::
        mov     [edi],al
        DO_LOW_NIBBLE

xpar_high_nibble_6::
        mov     [edi+1],ax
        DO_LOW_NIBBLE

xpar_high_nibble_5::
        mov     [edi+1],al
        mov     [edi+3],al
        DO_LOW_NIBBLE

xpar_high_nibble_4::
        mov     [edi+1],al
        DO_LOW_NIBBLE

xpar_high_nibble_7::
        mov     [edi+1],al
xpar_high_nibble_3::
        mov     [edi+2],ax
        DO_LOW_NIBBLE

xpar_high_nibble_A::
        mov     [edi],al
xpar_high_nibble_2::
        mov     [edi+2],al
        DO_LOW_NIBBLE

xpar_high_nibble_9::
        mov     [edi],al
xpar_high_nibble_1::
        mov     [edi+3],al
        DO_LOW_NIBBLE


xpar_low_nibble_0::
        DO_HIGH_NIBBLE

xpar_low_nibble_F::
        mov     [edi+4],eax
        DO_HIGH_NIBBLE

xpar_low_nibble_E::
        mov     [edi+4],ax
        mov     [edi+6],al
        DO_HIGH_NIBBLE

xpar_low_nibble_D::
        mov     [edi+4],ax
        mov     [edi+7],al
        DO_HIGH_NIBBLE

xpar_low_nibble_C::
        mov     [edi+4],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_B::
        mov     [edi+4],al
        mov     [edi+6],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_8::
        mov     [edi+4],al
        DO_HIGH_NIBBLE

xpar_low_nibble_6::
        mov     [edi+5],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_5::
        mov     [edi+5],al
        mov     [edi+7],al
        DO_HIGH_NIBBLE

xpar_low_nibble_4::
        mov     [edi+5],al
        DO_HIGH_NIBBLE

xpar_low_nibble_7::
        mov     [edi+5],al
xpar_low_nibble_3::
        mov     [edi+6],ax
        DO_HIGH_NIBBLE

xpar_low_nibble_A::
        mov     [edi+4],al
xpar_low_nibble_2::
        mov     [edi+6],al
        DO_HIGH_NIBBLE

xpar_low_nibble_9::
        mov     [edi+4],al
xpar_low_nibble_1::
        mov     [edi+7],al
        DO_HIGH_NIBBLE


;-----------------------------------------------------------------------;
; Opaque text.
;-----------------------------------------------------------------------;

opaque_text::

;-----------------------------------------------------------------------;
; Calculate drawing parameters.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     esi,prclText            ;point to bounding rectangle for text

        mov     eax,[ebx].pdev_lPlanarNextScan  ;set the screen width in
        mov     ulScreenDelta,eax               ; quadpixels

        sub     eax,eax                 ;assume clipped edge bytes won't need
        mov     ulLeftEdgeShift,eax     ; to be shifted into position
        mov     ulRightEdgeShift,eax

        mov     eax,[esi].xRight
        mov     ebx,eax
        and     ebx,11b                         ;dest right edge % 4
        mov     edx,[esi].xLeft
        mov     ulTextLeft,edx                  ;remember dest left edge
        mov     cl,jOpaqueRightMasks[ebx]       ;set right edge clip mask
        mov     ebx,edx
        and     ebx,11b                         ;dest left edge % 4
        mov     ulRightMask,ecx
        mov     cl,jOpaqueLeftMasks[ebx]        ;set left edge clip mask
        mov     ulLeftMask,ecx

        and     edx,not 7       ;left edge, rounded down to nearest byte
        dec     eax             ;right edge - 1
        sub     eax,edx
        shr     eax,3           ;width of the text in the temp buffer in bytes,
                                ; rounded up, minus 1. This is used to point to
                                ; the partial right edge, if there is one
        mov     ulTextWidthInBytesMinus1,eax

;-----------------------------------------------------------------------;
; Figure out what edges we need to handle, and calculate some info for
; doing whole bytes.
;-----------------------------------------------------------------------;

        mov     edx,[esi].xLeft
        mov     eax,[esi].xRight
        and     edx,not 3
        add     eax,3
        sub     eax,edx
        shr     eax,2           ;width of the text in the temp buffer in
                                ; quadpixels, rounded up (counting all whole
                                ; and partial quadpixels)
        cmp     eax,1           ;only one quadpixels total?
        jnz     short @F        ;no
                                ;yes, special case a single quadpixel
        mov     ecx,offset opaq_check_more_banks  ;assume it's a solid
                                                  ; quadpixel
        mov     ebx,ulLeftMask
        and     ebx,ulRightMask
        cmp     bl,0ffh                 ;solid quadpixel?
        jz      short opaq_set_deltas_and_edge_vector ;yes, all set
        mov     ulLeftMask,ebx          ;no, draw as a left edge
        dec     eax                     ;there are no whole quadpixels
        mov     ecx,offset opaq_draw_left_edge_only
        test    [esi].xLeft,100b        ;is partial quadpixel in bits 0-3?
        jnz     opaq_set_edge_vector    ;yes, no shift required, already set
        mov     ulLeftEdgeShift,4       ;no, must shift right 4 to get into
                                        ; bits 0-3
        jmp     short opaq_set_edge_vector ;yes, all set

@@:
        lea     edx,[eax-1]
        mov     ulVGAWidthInBytesMinus1,edx ;offset from leftmost VGA dest byte
                                            ; to rightmost

        test    [esi].xLeft,11b            ;is left edge a solid quadpixel?
        jz      short opaq_left_edge_solid ;yes
        dec     eax                        ;one less whole quadpixel
        mov     ecx,offset opaq_draw_left_edge_only ;assume right edge is solid
        test    [esi].xLeft,100b           ;is partial quadpixel in bits 0-3?
        jnz     short @F                   ;yes, no shift required, already set
        mov     ulLeftEdgeShift,4          ;no, must shift right 4 to get into
                                           ; bits 0-3
@@:
        test    [esi].xRight,11b           ;is right edge a solid quadpixel?
        jz      short opaq_set_deltas_and_edge_vector ;yes, all set
        dec     eax                        ;one less whole quadpixel
        mov     ecx,offset opaq_draw_both_edges ;both edges are non-solid
        jmp     short opaq_set_right_edge_shift

opaq_left_edge_solid::
        mov     ecx,offset opaq_check_more_banks  ;assume right edge is solid
        test    [esi].xRight,11b           ;is right edge a solid quadpixel?
        jz      short opaq_set_deltas_and_edge_vector ;yes, all set
        dec     eax                        ;one less whole quadpixel
        mov     ecx,offset opaq_draw_right_edge_only ;no, do non-solid right
                                                     ; edge
opaq_set_right_edge_shift:
        test    [esi].xRight,100b       ;is partial quadpixel in bits 0-3?
        jnz     short opaq_set_deltas_and_edge_vector
                                        ;yes, no shift required, already set
        mov     ulRightEdgeShift,4      ;no, must shift right 4 to get into
                                        ; bits 0-3

; At this point, EAX = # of whole quadpixels across source = # of whole bytes
; (addresses) across destination

opaq_set_deltas_and_edge_vector:
        mov     edi,ulScreenDelta
        sub     edi,eax         ;whole bytes offset to next scan in screen
                                ; (there are four pixels--one quadpixel--
                                ; at each VGA address)
        mov     ulTmpDstDelta,edi

        mov     edx,[esi].xLeft
        mov     edi,[esi].xRight
        add     edx,3
        and     edx,not 7
        add     edi,4
        sub     edi,edx
        shr     edi,3           ;width of the text in the temp buffer in bytes,
                                ; counting bytes containing whole quadpixels
                                ; but not bytes containing only partial
                                ; quadpixels. (Remember, text bytes map to
                                ; quadpixel pairs; text nibbles map to
                                ; quadpixels)
        sub     edi,ulBufDelta
        neg     edi
        mov     ulTmpSrcDelta,edi ;offset to next scan in source buffer when
                                  ; doing whole quadpixels
opaq_set_edge_vector::
        mov     pfnEdgeVector,ecx       ;save address of partial-quadpixel-
                                        ; drawing code, or end of loop if no
                                        ; partial edge
        mov     edx,eax                 ;# of whole quadpixels
        mov     pfnFirstOpaqVector,offset opaq_whole_quadpixels
                                        ;assume there are whole quadpixels
                                        ; to copy, in which case we'll draw
                                        ; them first, then the partial edge
                                        ; quadpixels
        sub     edi,edi
        shr     edx,1                   ;# of quadpixels / 2
        mov     ulWholeWidthInQuadpixelPairs,edx ;# of quadpixel pairs to copy
        adc     edi,edi                 ;odd quadpixel status
        mov     ulOddQuadpixel,edi      ;1 if there is an odd quadpixel, 0 else
        dec     edx
        mov     ulWholeWidthInQuadpixelPairsMinus1,edx
                                        ;# of whole quadpixel pairs to copy,
                                        ; minus 1 (for case with both leading
                                        ; and trailing quadpixels)
        cmp     eax,0                   ;are there any whole quadpixels at all?
        jg      short @F                ;yes, we're all set
                                        ;no, set up for edge(s) only
        mov     pfnFirstOpaqVector,ecx  ;the edges are first and only, because
                                        ; there are no whole quadpixels
@@:

;-----------------------------------------------------------------------;
; Determine the screen offset of the first destination byte.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,ulTopScan
        mov     ecx,eax
        mul     ulScreenDelta
        mov     edi,[esi].xLeft
        shr     edi,2           ;left edge screen offset in quadpixels
        add     edi,eax

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        cmp     ecx,[ebx].pdev_rcl1PlanarClip.yTop ;is text top less than
                                                   ; current bank?
        jl      short opaq_map_init_bank           ;yes, map in proper bank
        cmp     ecx,[ebx].pdev_rcl1PlanarClip.yBottom ;text top greater than
                                                      ; current bank?
        jl      short opaq_init_bank_mapped     ;no, proper bank already mapped
opaq_map_init_bank::

; Map in the bank containing the top scan line of the fill.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>,<ebx,ecx,JustifyTop>

opaq_init_bank_mapped::

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

;-----------------------------------------------------------------------;
; Load the latches with the background color.
;-----------------------------------------------------------------------;

        sub     eax,eax
        mov     edx,[esi].xLeft
        and     edx,011b
        cmp     eax,edx                 ;is the first quadpixel a full
                                        ; quadpixel?
        adc     eax,eax                 ;if so, EAX = 1, else EAX = 0
        mov     edx,iBgColor
        mov     [edi+eax],dl            ;write the bg color to the first full
                                        ; quadpixel, in each of the four planes
        mov     dl,[edi+eax]            ;read back the quadpixel to load the
                                        ; latches with the bg color

;-----------------------------------------------------------------------;
; Set up the VGA's hardware for read mode 0 and write mode 2, the ALUs
; for XOR, and the Bit Mask to 1 for bits that differ between the fg and
; bg, 0 for bits that are the same.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [ebx].pdev_ulrm0_wmX[2]
                                        ;write mode 2 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 2 to expand glyph bits to
                                        ; 0 or 0ffh per plane
        mov     eax,GRAF_DATA_ROT + (DR_XOR SHL 8)
        out     dx,ax                   ;XOR to flip latched data to make ~bg

        mov     ah,byte ptr iBgColor
        xor     ah,byte ptr iFgColor
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;pass through common fg & bg bits
                                        ; unchanged from bg color in latches;
                                        ; non-common bits come from XOR in the
                                        ; ALUs, flipped from the bg to the fg
                                        ; state if the glyph bit for the pixel
                                        ; in that plane is 1, still in bg state
                                        ; if the glyph bit for that plane is 0

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;
; At start of loop and on each loop, EBX->ppdev and EDI->first destination
; byte.
;-----------------------------------------------------------------------;

opaq_bank_loop::
        mov     pScreen,edi             ;remember initial copy destination

        mov     edx,ulBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].pdev_rcl1PlanarClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].pdev_rcl1PlanarClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulTopScan           ;# of scans to draw in bank
        mov     ulNumScans,edx
        jmp     pfnFirstOpaqVector      ;do first sort of drawing (whole
                                        ; bytes, or edge(s) if no whole
                                        ; bytes)

;-----------------------------------------------------------------------;
; Draw the whole quadpixels, handling as many as possible paired into
; bytes so we can draw 8 pixels at a time.
;
; On entry:
;       EDI = first destination byte
;-----------------------------------------------------------------------;
opaq_whole_quadpixels::
        mov     esi,pTempBuffer         ;point to first source byte
        mov     eax,ulTextLeft          ;left edge
        test    eax,011b                ;is there a partial (masked) edge?
        jz      short @f                ;no, start addresses are correct
        inc     edi                     ;yes, skip over one dest byte for the
                                        ; four pixels in the partial edge
        test    eax,100b                ;do we have a partial left edge in the
                                        ; second quadpixel?
        jz      short @f                ;no, source start address is correct
        inc     esi                     ;yes, skip over a source byte because
                                        ; the partial edge is all that's in
                                        ; this byte
@@:
        mov     ebx,pGlyphFlipTable     ;point to the look-up table we'll use
                                        ; to flip the glyph bits into the form
                                        ; required by planar mode
        mov     edx,ulNumScans          ;# of scans to draw

                                        ;decide which copy loop to use, based
                                        ; on the word-alignment of the dest
                                        ; rectangle with the screen
                                        ;the following tests rely on VGA even
                                        ; addresses being aligned to the start
                                        ; of corresponding source buffer bytes
                                        ; (4-pixel sets at even VGA addresses
                                        ; match up to the upper quadpixels of
                                        ; source buffer bytes)
        test    edi,1                   ;is dest word-aligned?
        jnz     short opaq_need_leading ;no, need leading quadpixel
                                        ;yes, no leading quadpixel
        cmp     ulOddQuadpixel,1        ;odd width in quadpixels?
        jnz     short opaq_scan_loop    ;no, no trailing quadpixel
        jmp     opaq_scan_loop_t        ;yes, trailing quadpixel

opaq_need_leading:                      ;there's a leading quadpixel
        cmp     ulOddQuadpixel,1        ;odd width in quadpixels?
        jnz     opaq_scan_loop_lt       ;no, trailing quadpixel
        jmp     opaq_scan_loop_l        ;yes, no trailing quadpixel


;-----------------------------------------------------------------------;
; Loops for copying whole quadpixels to the screen, as much as possible a
; quadpixel pair at a time.
; On entry:
;       EBX = pointer to flip table
;       EDX = # of scans to draw
;       ESI = pointer to first buffer byte from which to copy
;       EDI = pointer to first screen byte to which to copy
;       ulTmpSrcDelta = offset to next buffer scan
;       ulTmpDstDelta = offset to next destination (VGA) scan
;       ulWholeWidthInQuadpixelPairs = # of whole bytes to copy
;       ulWholeWidthInQuadpixelPairsMinus1 = # of whole bytes to copy, minus 1
; LATER could break out and optimize short runs, such as 1, 2, 3, 4 wide.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: no leading quadpixel, no trailing
; quadpixel.
;-----------------------------------------------------------------------;
opaq_scan_loop::
opaq_sl_row_loop:
        mov     ecx,ulWholeWidthInQuadpixelPairs
opaq_sl_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_sl_byte_loop
opaq_sl_whole_done:
        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx               ;count down scans
        jnz     opaq_sl_row_loop
        jmp     pfnEdgeVector     ;do the edge(s)


;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: leading quadpixel, no trailing
; quadpixel.
;-----------------------------------------------------------------------;
opaq_scan_loop_l::
opaq_sll_row_loop:
        mov     bl,[esi]        ;get the first temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3
        mov     [edi],al        ;draw the first 4 pixels (the leading quadpixel)
        inc     edi             ;point to the next destination address

        mov     ecx,ulWholeWidthInQuadpixelPairs
        test    ecx,ecx         ;see if there's anything else to draw
        jz      short opaq_sll_whole_done
opaq_sll_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_sll_byte_loop
opaq_sll_whole_done:
        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx             ;count down scans
        jnz     opaq_sll_row_loop
        jmp     pfnEdgeVector   ;do the edge(s)


;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: leading byte, trailing byte.
;-----------------------------------------------------------------------;
opaq_scan_loop_lt::
opaq_sllt_row_loop:
        mov     bl,[esi]        ;get the first temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3
        mov     [edi],al        ;draw the first 4 pixels (the leading quadpixel)
        inc     edi             ;point to the next destination address

        mov     ecx,ulWholeWidthInQuadpixelPairsMinus1
        test    ecx,ecx         ;see if there's anything else to draw
        jz      short opaq_sllt_whole_done
opaq_sllt_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_sllt_byte_loop
opaq_sllt_whole_done:
        mov     bl,[esi]        ;get the last temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 4-7
        shr     eax,4           ;put the quadpixel in bits 0-3
        mov     [edi],al        ;draw the last 4 pixels (the trailing quadpixel)
        inc     edi             ;point to the next destination address

        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx             ;count down scans
        jnz     opaq_sllt_row_loop
        jmp     pfnEdgeVector   ;do the edge(s)

;-----------------------------------------------------------------------;
; Loop for doing whole opaque words: no leading byte, trailing byte.
;-----------------------------------------------------------------------;
opaq_scan_loop_t::
opaq_slt_row_loop:
        mov     ecx,ulWholeWidthInQuadpixelPairs
        test    ecx,ecx         ;see if there's anything else to draw
        jz      short opaq_slt_whole_done
opaq_slt_byte_loop:
        mov     bl,[esi]        ;get the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        inc     esi             ;point to the next temp buffer byte
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,2           ;point to the next destination address

        dec     ecx
        jnz     opaq_slt_byte_loop
opaq_slt_whole_done:
        mov     bl,[esi]        ;get the last temp buffer byte
        inc     esi             ;point to the next temp buffer byte
        mov     al,[ebx]        ;reverse the order of bits 4-7
        shr     eax,4           ;put the quadpixel in bits 0-3
        mov     [edi],al        ;draw the last 4 pixels (the trailing quadpixel)
        inc     edi             ;point to the next destination address

        add     esi,ulTmpSrcDelta ;point to next buffer scan
        add     edi,ulTmpDstDelta ;point to next screen scan
        dec     edx             ;count down scans
        jnz     opaq_slt_row_loop
        jmp     pfnEdgeVector   ;do the edge(s)

;-----------------------------------------------------------------------;
; Draw a partial left edge.
;-----------------------------------------------------------------------;
opaq_draw_left_edge_only::

        push    offset opaq_edges_done  ;return here when done with edge

opaq_draw_left_edge_only_entry::
        mov     esi,pTempBuffer         ;source start
        mov     edi,pScreen             ;destination (VGA) start
        mov     ecx,ulLeftEdgeShift     ;CL=amount by which to shift byte to
                                        ; right-justify desired quadpixel (0 or
                                        ; 4)
        mov     eax,ulLeftMask          ;clip mask for edge

; Enter here to copy a partial edge, with the Map Mask set to clip, ESI
; pointing to the first source byte to copy, EDI pointing to the first dest
; byte to copy to, CL the amount by which to right-shift to get the quadpixel
; of interest into bits 0-3, and AL the Map Mask setting to clip the edge

opaq_draw_edge_entry:
        push    ebp                     ;preserve stack frame pointer

        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     edx,ulScreenDelta       ;width of a screen scan in addresses
        mov     eax,ulNumScans          ;height of text
        mov     ebx,pGlyphFlipTable     ;point to the look-up table we'll use
                                        ; to flip the glyph bits into the form
                                        ; required by planar mode
        mov     ebp,ulBufDelta          ;width of a source scan in bytes
                                        ;***stack frame unavailable***
opaq_edge_loop::
        mov     bl,[esi]        ;get the next text buffer byte
        shr     bl,cl           ;move the desired quadpixel into bits 0-3
        add     esi,ebp         ;point to the next destination byte
        mov     bl,[ebx]        ;reverse the order of bits 0-3
        mov     [edi],bl        ;draw up to four pixels, with the Map Mask
                                ; clipping, if necessary
        add     edi,edx         ;point to the next destination byte

        dec     eax
        jnz     opaq_edge_loop

        pop     ebp             ;restore stack frame pointer
                                ;***stack frame available***
        retn

;-----------------------------------------------------------------------;
; Draw a partial right edge only. Once we've set up the pointers, this
; is done with exactly the same code as the left edge.
;-----------------------------------------------------------------------;
opaq_draw_right_edge_only::
        push    offset opaq_edges_done  ;return here when done with edge

opaq_draw_right_edge_only_entry::
        mov     esi,ulTextWidthInBytesMinus1
        add     esi,pTempBuffer         ;point to right edge start in buffer
        mov     edi,ulVGAWidthInBytesMinus1
        add     edi,pScreen             ;point to right edge start in screen
        mov     ecx,ulRightEdgeShift    ;CL=amount by which to shift byte to
                                        ; right-justify desired quadpixel (0 or
                                        ; 4)
        mov     eax,ulRightMask         ;clip mask for edge

        jmp     opaq_draw_edge_entry

;-----------------------------------------------------------------------;
; Draw both left and right partial  edges. We do this by calling first
; the left and then the right edge drawing code.
;-----------------------------------------------------------------------;
opaq_draw_both_edges::
        call    opaq_draw_left_edge_only_entry
        call    opaq_draw_right_edge_only_entry

;-----------------------------------------------------------------------;
; Restore Map Mask to enable all planes, now that we're done drawing
; partial edges.
;-----------------------------------------------------------------------;

opaq_edges_done:
        mov     al,MM_ALL
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

opaq_check_more_banks::
        mov     ebx,ppdev
        mov     eax,[ebx].pdev_rcl1PlanarClip.yBottom ;is the text bottom in
        cmp     ulBottomScan,eax                       ; the current bank?
        jnle    short opaq_do_next_bank ;no, do the next bank
                                        ;yes, so we're done

;-----------------------------------------------------------------------;
; Restore the VGA's hardware to the default state.
; The Graphics Controller Index still points to the Bit Mask at this
; point.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,0ffh
        out     dx,al                   ;enable all bits through the Bit Mask

        mov     esi,ppdev
        dec     edx                     ;point back to the Graphics Index reg
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
                                        ;write mode 0 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     eax,GRAF_DATA_ROT + (DR_SET SHL 8)
        out     dx,ax                   ;replace mode, no rotate

        cRet    vFastText


opaq_do_next_bank::
        mov     esi,prclText
        mov     ulTopScan,eax           ;this will be the top of the next bank
        mov     ecx,eax
        mul     ulScreenDelta
        mov     edi,[esi].xLeft
        shr     edi,2                   ;convert from pixels to quadpixels
        add     edi,eax                 ;next screen byte to which to copy

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>,<ebx,ecx,JustifyTop>
                                        ;map in the bank (call preserves EBX,
                                        ; ESI, and EDI)

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

        mov     eax,ulBufDelta
        mul     ulNumScans
        add     pTempBuffer,eax         ;advance to next temp buffer scan to
                                        ; copy

        jmp     opaq_bank_loop          ;we're ready to draw in the new bank

;-----------------------------------------------------------------------;
; Special 8-wide aligned opaque drawing code. Loads the latches with the
; background color, sets the Bit Mask to 1 for bits that differ between
; the foreground and background, sets the ALUs to XOR, then uses write
; mode 3 to draw the glyphs. Joyously, there are no partial bytes to
; worry about, so we can really crank up the code.
;
; On entry:
;       EBX = prclText
;-----------------------------------------------------------------------;
special_8_wide_aligned_opaque::

        mov     esi,ppdev
        mov     edi,[ebx].yBottom
        mov     eax,[ebx].yTop
        sub     edi,eax                 ;height of glyphs

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        cmp     eax,[esi].pdev_rcl1PlanarClip.yTop ;is text top less than
                                                    ; current bank?
        jl      short s8wao_map_init_bank           ;yes, map in proper bank
        cmp     eax,[esi].pdev_rcl1PlanarClip.yBottom ;text top greater than
                                                       ; current bank?
        jl      short s8wa0_init_bank_mapped   ;no, proper bank already mapped
s8wao_map_init_bank::

; Map in the bank containing the top scan line of the text, making sure we're
; in planar mode at the same time.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [esi].pdev_pfnPlanarControl>,<esi,eax,JustifyTop>

s8wa0_init_bank_mapped::

;-----------------------------------------------------------------------;
; We handle only cases where the text lies entirely in one bank.
; LATER handle broken rasters and/or bank-spanning cases?
;-----------------------------------------------------------------------;

        mov     eax,[esi].pdev_rcl1PlanarClip.yBottom
        sub     eax,[ebx].yTop          ;maximum run in bank
        cmp     edi,eax                 ;does all the text fit in the bank?
        jg      general_handler         ;no, let general code handle it

;-----------------------------------------------------------------------;
; Set up variables.
;-----------------------------------------------------------------------;

        mov     ulScans,edi             ;# of scans

;-----------------------------------------------------------------------;
; Point to the first screen byte at which to draw.
;-----------------------------------------------------------------------;

        mov     eax,[ebx].yTop
        mul     [esi].pdev_lPlanarNextScan
        mov     edi,[ebx].xLeft
        shr     edi,2
        add     edi,eax                 ;next screen byte to which to copy
        add     edi,[esi].pdev_pvBitmapStart   ;initial destination address
        mov     pScreen,edi

;-----------------------------------------------------------------------;
; Load the latches with the background color.
;-----------------------------------------------------------------------;

        mov     eax,iBgColor
        mov     byte ptr [edi],al       ;write the bg color to the first byte
        mov     al,[edi]                ;read back the byte to load the
                                        ; latches with the bg color

;-----------------------------------------------------------------------;
; Set up the VGA's hardware for read mode 0 and write mode 2, the ALUs
; for XOR, and the Bit Mask to 1 for bits that differ between the fg and
; bg, 0 for bits that are the same.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[2]
                                        ;write mode 2 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 2 to expand glyph bits to
                                        ; 0 or 0ffh per plane
        mov     eax,GRAF_DATA_ROT + (DR_XOR SHL 8)
        out     dx,ax                   ;XOR to flip latched data to make ~bg

        mov     ah,byte ptr iBgColor
        xor     ah,byte ptr iFgColor
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;pass through common fg & bg bits
                                        ; unchanged from bg color in latches;
                                        ; non-common bits come from XOR in the
                                        ; ALUs, flipped from the bg to the fg
                                        ; state if the glyph bit for the pixel
                                        ; in that plane is 1, still in bg state
                                        ; if the glyph bit for that plane is 0

;-----------------------------------------------------------------------;
; Set up the screen scan offset in EDX.
;-----------------------------------------------------------------------;

        mov     edx,[esi].pdev_lPlanarNextScan ;offset from one scan to next

        mov     ecx,ulGlyphCount

s8wao_glyph_loop:
        mov     ebx,pGlyphPos           ;point to the current glyph to draw
        add     pGlyphPos,(size GLYPHPOS) ;point to the next glyph
        mov     edi,pScreen             ;point to current glyph's screen
                                        ; location
        mov     esi,[ebx].gp_pgdf       ;point to current glyph def
        add     pScreen,2               ;point to the next glyph's screen
                                        ; location
        mov     ecx,ulScans             ;# of scans
        mov     esi,[esi].gdf_pgb       ;point to current glyph
        mov     ebx,pGlyphFlipTable     ;point to the look-up table we'll use
                                        ; to flip the glyph bits into the form
                                        ; required by planar mode
        add     esi,gb_aj               ;point to the current glyph's bits

s8wao_byte_loop::
        mov     bl,[esi]        ;get the next glyph byte
        inc     esi             ;point to the next glyph byte
        mov     al,[ebx]        ;reverse the order of bits 0-3 and 4-7
        mov     ah,al
        shr     al,4            ;first quadpixel to draw in AL, next in AH
        mov     [edi],ax        ;draw the glyph
        add     edi,edx         ;point to the next destination byte

        dec     ecx             ;count down glyph scans
        jnz     s8wao_byte_loop

        dec     ulGlyphCount    ;count down glyphs
        jnz     s8wao_glyph_loop

;-----------------------------------------------------------------------;
; Restore the VGA's hardware to the default state.
; The Graphics Controller Index still points to the Bit Mask at this
; point.
;-----------------------------------------------------------------------;

        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,0ffh
        out     dx,al                   ;enable all bits through the Bit Mask

        mov     esi,ppdev
        dec     edx                     ;point back to the Graphics Index reg
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
                                        ;write mode 0 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     eax,GRAF_DATA_ROT + (DR_SET SHL 8)
        out     dx,ax                   ;replace mode, no rotate

draw_prop_done::
        cRet    vFastText

endProc vFastText

;-----------------------------------------------------------------------;
; VOID vSetWriteModes(ULONG * pulWriteModes);
;
; Sets the four bytes at *pulWriteModes to the values to be written to
; the Graphics Mode register to select read mode 0 and:
;  write mode 0, write mode 1, write mode 2, and write mode 3,
; respectively.
;
; Must already be in graphics mode when this is called.
;-----------------------------------------------------------------------;

cProc vSetWriteModes,4,<   \
        pulWriteModes:ptr  >

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_MODE
        out     dx,al           ;point the GC Index to the Graphics Mode reg
        inc     edx             ;point to the GC Data reg
        in      al,dx           ;get the current setting of the Graphics Mode
        and     eax,0fch        ;mask off the write mode fields
        mov     ah,al
        mov     edx,eax
        shl     edx,16
        or      eax,edx         ;put the Graphics Mode setting in all 4 bytes
        mov     edx,pulWriteModes ;the mode values go here
        or      eax,03020100h   ;insert the write mode fields
        mov     [edx],eax       ;store the Graphics Mode settings

        cRet    vSetWriteModes

endProc vSetWriteModes

;-----------------------------------------------------------------------;
; VOID vClearMemDword(PULONG * pulBuffer, ULONG ulDwordCount);
;
; Clears ulCount dwords starting at pjBuffer.
;-----------------------------------------------------------------------;

pulBuffer    equ [esp+8]
ulDwordCount equ [esp+12]

cProc vClearMemDword,8,<>

        push    edi
        mov     edi,pulBuffer
        mov     ecx,ulDwordCount
        sub     eax,eax
        rep     stosd
        pop     edi

        cRet  vClearMemDword

endProc vClearMemDword

public general_handler
public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public draw_to_screen
public opaque_text
public opaq_left_edge_solid
public opaq_set_edge_vector
public opaq_map_init_bank
public opaq_init_bank_mapped
public opaq_bank_loop
public opaq_whole_quadpixels
public opaq_scan_loop
public opaq_scan_loop_l
public opaq_scan_loop_lt
public opaq_scan_loop_t
public opaq_draw_left_edge_only
public opaq_draw_left_edge_only_entry
public opaq_edge_loop
public opaq_draw_right_edge_only
public opaq_draw_right_edge_only_entry
public opaq_draw_both_edges
public opaq_check_more_banks
public opaq_do_next_bank
public special_8_wide_aligned_opaque
public s8wa0_init_bank_mapped
public s8wao_byte_loop
public s8wao_map_init_bank
public xpar_map_init_bank
public xpar_init_bank_mapped
public xpar_bank_loop
public xpar_scan_loop
public xpar_scan_done
public do_next_xpar_bank
public xpar_high_nibble_F
public xpar_high_nibble_E
public xpar_high_nibble_D
public xpar_high_nibble_C
public xpar_high_nibble_B
public xpar_high_nibble_8
public xpar_high_nibble_6
public xpar_high_nibble_5
public xpar_high_nibble_4
public xpar_high_nibble_7
public xpar_high_nibble_3
public xpar_high_nibble_A
public xpar_high_nibble_2
public xpar_high_nibble_9
public xpar_high_nibble_1
public xpar_high_nibble_0
public xpar_low_nibble_F
public xpar_low_nibble_E
public xpar_low_nibble_D
public xpar_low_nibble_C
public xpar_low_nibble_B
public xpar_low_nibble_8
public xpar_low_nibble_6
public xpar_low_nibble_5
public xpar_low_nibble_4
public xpar_low_nibble_7
public xpar_low_nibble_3
public xpar_low_nibble_A
public xpar_low_nibble_2
public xpar_low_nibble_9
public xpar_low_nibble_1
public xpar_low_nibble_0


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\lines.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: lines.asm
;
; Draws a set of connected polylines.
;
; The actual pixel-lighting code is different depending on if the lines
; are styled/unstyled and we're doing an arbitrary ROP or set-style ROP.
;
; Lines are drawn from left to right.  So if a line moves from right
; to left, the endpoints are swapped and the line is drawn from left to
; right.
;
; See s3\lines.cxx for a portable version (sans simple clipping).
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\driver.inc
        include i386\lines.inc
        .list

        .data

        public gaflRoundTable
gaflRoundTable       label  dword
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; no flips
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; D flip
        dd      FL_H_ROUND_DOWN                         ; V flip
        dd      FL_V_ROUND_DOWN                         ; D & V flip
        dd      FL_V_ROUND_DOWN                         ; slope one
        dd      0baadf00dh
        dd      FL_H_ROUND_DOWN                         ; slope one & V flip
        dd      0baadf00dh

        .code

;--------------------------------Macro----------------------------------;
; testb ebx, <mask>
;
; Substitutes a byte compare if the mask is entirely in the lo-byte or
; hi-byte (thus saving 3 bytes of code space).
;
;-----------------------------------------------------------------------;

TESTB   macro   targ,mask,thirdarg
        local   mask2,delta

ifnb <thirdarg>
        .err    TESTB mask must be enclosed in brackets!
endif

        delta = 0
        mask2 = mask

        if mask2 AND 0ffff0000h
            test targ,mask                      ; If bit set in hi-word,
            exitm                               ; test entire dword
        endif

        if mask2 AND 0ff00h
            if mask2 AND 0ffh                   ; If bit set in lo-byte and
                test targ,mask                  ; hi-byte, test entire dword
                exitm
            endif

            mask2 = mask2 SHR 8
            delta = 1
        endif

ifidni <targ>,<EBX>
        if delta
            test bh,mask2
        else
            test bl,mask2
        endif
        exitm
endif

        .err    Too bad TESTB doesn't support targets other than ebx!
endm

;---------------------------Public-Routine------------------------------;
; BOOL bLines(ppdev, pptfxFirst, pptfxBuf, prun, cptfx, pls,
;        prclClip, apfn[], flStart)
;
; Do all the DDA calculations for lines.
;
; Doing Lines Right
; -----------------
;
; In NT, all lines are given to the device driver in fractional
; coordinates, in a 28.4 fixed point format.  The lower 4 bits are
; fractional for sub-pixel positioning.
;
; Note that you CANNOT! just round the coordinates to integers
; and pass the results to your favorite integer Bresenham routine!!
; (Unless, of course, you have such a high resolution device that
; nobody will notice -- not likely for a display device.)  The
; fractions give a more accurate rendering of the line -- this is
; important for things like our Bezier curves, which would have 'kinks'
; if the points in its polyline approximation were rounded to integers.
;
; Unfortunately, for fractional lines there is more setup work to do
; a DDA than for integer lines.  However, the main loop is exactly
; the same (and can be done entirely with 32 bit math).
;
; If You've Got Hardware That Does Bresenham
; ------------------------------------------
;
; A lot of hardware limits DDA error terms to 'n' bits.  With fractional
; coordinates, 4 bits are given to the fractional part, letting
; you draw in hardware only those lines that lie entirely in a 2^(n-4)
; by 2^(n-4) pixel space.
;
; And you still have to correctly draw those lines with coordinates
; outside that space!  Remember that the screen is only a viewport
; onto a 28.4 by 28.4 space -- if any part of the line is visible
; you MUST render it precisely, regardless of where the end points lie.
; So even if you do it in software, somewhere you'll have to have a
; 32 bit DDA routine.
;
; Our Implementation
; ------------------
;
; We employ a run length slice algorithm: our DDA calculates the
; number of pixels that are in each row (or 'strip') of pixels.
;
; We've separated the running of the DDA and the drawing of pixels:
; we run the DDA for several iterations and store the results in
; a 'strip' buffer (which are the lengths of consecutive pixel rows of
; the line), then we crank up a 'strip drawer' that will draw all the
; strips in the buffer.
;
; We also employ a 'half-flip' to reduce the number of strip
; iterations we need to do in the DDA and strip drawing loops: when a
; (normalized) line's slope is more than 1/2, we do a final flip
; about the line y = (1/2)x.  So now, instead of each strip being
; consecutive horizontal or vertical pixel rows, each strip is composed
; of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
; (128, 128) would generate only one strip.
;
; We also always draw only left-to-right.
;
; Style lines may have arbitrary style patterns.  We specially
; optimize the default patterns (and call them 'masked' styles).
;
; The DDA Derivation
; ------------------
;
; Here is how I like to think of the DDA calculation.
;
; We employ Knuth's "diamond rule": rendering a one-pixel-wide line
; can be thought of as dragging a one-pixel-wide by one-pixel-high
; diamond along the true line.  Pixel centers lie on the integer
; coordinates, and so we light any pixel whose center gets covered
; by the "drag" region (John D. Hobby, Journal of the Association
; for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
;
; We must define which pixel gets lit when the true line falls
; exactly half-way between two pixels.  In this case, we follow
; the rule: when two pels are equidistant, the upper or left pel
; is illuminated, unless the slope is exactly one, in which case
; the upper or right pel is illuminated.  (So we make the edges
; of the diamond exclusive, except for the top and left vertices,
; which are inclusive, unless we have slope one.)
;
; This metric decides what pixels should be on any line BEFORE it is
; flipped around for our calculation.  Having a consistent metric
; this way will let our lines blend nicely with our curves.  The
; metric also dictates that we will never have one pixel turned on
; directly above another that's turned on.  We will also never have
; a gap; i.e., there will be exactly one pixel turned on for each
; column between the start and end points.  All that remains to be
; done is to decide how many pixels should be turned on for each row.
;
; So lines we draw will consist of varying numbers of pixels on
; successive rows, for example:
;
;       ******
;             *****
;                  ******
;                        *****
;
; We'll call each set of pixels on a row a "strip".
;
; (Please remember that our coordinate space has the origin as the
; upper left pixel on the screen; postive y is down and positive x
; is right.)
;
; Device coordinates are specified as fixed point 28.4 numbers,
; where the first 28 bits are the integer coordinate, and the last
; 4 bits are the fraction.  So coordinates may be thought of as
; having the form (x, y) = (M/F, N/F) where F is the constant scaling
; factor F = 2^4 = 16, and M and N are 32 bit integers.
;
; Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
; left-to-right and whose slope is in the first octant, and let
; dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
;
; Since the slope of the line is less than 1, the edges of the
; drag region are created by the top and bottom vertices of the
; diamond.  At any given pixel row y of the line, we light those
; pixels whose centers are between the left and right edges.
;
; Let mL(n) denote the line representing the left edge of the drag
; region.  On pixel row j, the column of the first pixel to be
; lit is
;
;       iL(j) = ceiling( mL(j * F) / F)
;
; Since the line's slope is less than one:
;
;       iL(j) = ceiling( mL([j + 1/2] F) / F )
;
; Recall the formula for our line:
;
;       n(m) = (dN / dM) (m - M0) + N0
;
;       m(n) = (dM / dN) (n - N0) + M0
;
; Since the line's slope is less than one, the line representing
; the left edge of the drag region is the original line offset
; by 1/2 pixel in the y direction:
;
;       mL(n) = (dM / dN) (n - F/2 - N0) + M0
;
; From this we can figure out the column of the first pixel that
; will be lit on row j, being careful of rounding (if the left
; edge lands exactly on an integer point, the pixel at that
; point is not lit because of our rounding convention):
;
;       iL(j) = floor( mL(j F) / F ) + 1
;
;             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
;
;             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
;
;                      F dM j - [ dM (N0 + F/2) - dN M0 ]
;             = floor( ---------------------------------- ) + 1
;                                   F dN
;
;                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
;             = floor( ------------------------------------ ) + 1       (1)
;                                     dN
;
;             = floor( (dM j + alpha) / dN ) + 1
;
; where
;
;       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
;
; We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
; pixels in row j.  Because we are always calculating iL(j) for
; integer quantities of j, we note that the only fractional term
; is constant, and so we can 'throw away' the fractional bits of
; alpha:
;
;       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
;
; so
;
;       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
;
; for integers j.
;
; Note if iR(j) is the line's rightmost pixel on row j, that
; iR(j) = iL(j + 1) - 1.
;
; Similarly, rewriting equation (1) as a function of column i,
; we can determine, given column i, on which pixel row j is the line
; lit:
;
;                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
;       j(i) = ceiling( ------------------------------------ ) - 1
;                                       dM
;
; Floors are easier to compute, so we can rewrite this:
;
;                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
;       j(i) = floor( ----------------------------------------------- ) - 1
;                                       dM
;
;                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
;            = floor( ---------------------------------------------------- )
;                                       dM
;
;                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
;            = floor( ---------------------------------------- )
;                                       dM
;
; We can once again wave our hands and throw away the fractional bits
; of the remainder term:
;
;       j(i) = floor( (dN i + gamma) / dM )                             (4)
;
; where
;
;       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
;
; We now note that
;
;       beta = -gamma - 1 = ~gamma                                      (6)
;
; To draw the pixels of the line, we could evaluate (3) on every scan
; line to determine where the strip starts.  Of course, we don't want
; to do that because that would involve a multiply and divide for every
; scan.  So we do everything incrementally.
;
; We would like to easily compute c , the number of pixels on scan j:
;                                  j
;
;    c  = iL(j + 1) - iL(j)
;     j
;
;       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
;
; This may be rewritten as
;
;    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
;     j          j+1    j+1                j    j
;
; where i , i    are integers and r  < dN, r    < dN.
;        j   j+1                   j        j+1
;
; Rewriting (7) again:
;
;    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
;     j          j    j                          j    j
;
;
;       = floor((r  + dM) / dN) - floor(r  / dN)
;                 j                      j
;
; This may be rewritten as
;
;    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
;     j                j                      j
;
; where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
;
; r  is the remainder (or "error") term in the DDA loop: r  / dN
;  j                                                      j
; is the exact fraction of a pixel at which the strip ends.  To go
; on to the next scan and compute c    we need to know r   .
;                                  j+1                  j+1
;
; So in the main loop of the DDA:
;
;    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
;     j                j                  j+1     j
;
; and we know r  < dN, r    < dN, and dR < dN.
;              j        j+1
;
; We have derived the DDA only for lines in the first octant; to
; handle other octants we do the common trick of flipping the line
; to the first octant by first making the line left-to-right by
; exchanging the end-points, then flipping about the lines y = 0 and
; y = x, as necessary.  We must record the transformation so we can
; undo them later.
;
; We must also be careful of how the flips affect our rounding.  If
; to get the line to the first octant we flipped about x = 0, we now
; have to be careful to round a y value of 1/2 up instead of down as
; we would for a line originally in the first octant (recall that
; "In the case where two pels are equidistant, the upper or left
; pel is illuminated...").
;
; To account for this rounding when running the DDA, we shift the line
; (or not) in the y direction by the smallest amount possible.  That
; takes care of rounding for the DDA, but we still have to be careful
; about the rounding when determining the first and last pixels to be
; lit in the line.
;
; Determining The First And Last Pixels In The Line
; -------------------------------------------------
;
; Fractional coordinates also make it harder to determine which pixels
; will be the first and last ones in the line.  We've already taken
; the fractional coordinates into account in calculating the DDA, but
; the DDA cannot tell us which are the end pixels because it is quite
; happy to calculate pixels on the line from minus infinity to positive
; infinity.
;
; The diamond rule determines the start and end pixels.  (Recall that
; the sides are exclusive except for the left and top vertices.)
; This convention can be thought of in another way: there are diamonds
; around the pixels, and wherever the true line crosses a diamond,
; that pel is illuminated.
;
; Consider a line where we've done the flips to the first octant, and the
; floor of the start coordinates is the origin:
;
;        +-----------------------> +x
;        |
;        | 0                     1
;        |     0123456789abcdef
;        |
;        |   0 00000000?1111111
;        |   1 00000000 1111111
;        |   2 0000000   111111
;        |   3 000000     11111
;        |   4 00000    ** 1111
;        |   5 0000       ****1
;        |   6 000           1***
;        |   7 00             1  ****
;        |   8 ?                     ***
;        |   9 22             3         ****
;        |   a 222           33             ***
;        |   b 2222         333                ****
;        |   c 22222       3333                    **
;        |   d 222222     33333
;        |   e 2222222   333333
;        |   f 22222222 3333333
;        |
;        | 2                     3
;        v
;        +y
;
; If the start of the line lands on the diamond around pixel 0 (shown by
; the '0' region here), pixel 0 is the first pel in the line.  The same
; is true for the other pels.
;
; A little more work has to be done if the line starts in the
; 'nether-land' between the diamonds (as illustrated by the '*' line):
; the first pel lit is the first diamond crossed by the line (pixel 1 in
; our example).  This calculation is determined by the DDA or slope of
; the line.
;
; If the line starts exactly half way between two adjacent pixels
; (denoted here by the '?' spots), the first pixel is determined by our
; round-down convention (and is dependent on the flips done to
; normalize the line).
;
; Last Pel Exclusive
; ------------------
;
; To eliminate repeatedly lit pels between continuous connected lines,
; we employ a last-pel exclusive convention: if the line ends exactly on
; the diamond around a pel, that pel is not lit.  (This eliminates the
; checks we had in the old code to see if we were re-lighting pels.)
;
; The Half Flip
; -------------
;
; To make our run length algorithm more efficient, we employ a "half
; flip".  If after normalizing to the first octant, the slope is more
; than 1/2, we subtract the y coordinate from the x coordinate.  This
; has the effect of reflecting the coordinates through the line of slope
; 1/2.  Note that the diagonal gets mapped into the x-axis after a half
; flip.
;
; How Many Bits Do We Need, Anyway?
; ---------------------------------
;
; Note that if the line is visible on your screen, you must light up
; exactly the correct pixels, no matter where in the 28.4 x 28.4 device
; space the end points of the line lie (meaning you must handle 32 bit
; DDAs, you can certainly have optimized cases for lesser DDAs).
;
; We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
; calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
; are in the first octant, so dM >= dN.  Then we know that gamma can
; be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
; valid lines will have dM and dN values at most 31 bits (unsigned)
; of significance.  So gamma requires 33 bits of significance (we store
; this as a 64 bit number for convenience).
;
; When running through the DDA loop, r  + dR can have a value in the
;                                     j
; range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
;             j
;
; Testing Lines
; -------------
;
; To be NT compliant, a display driver must exactly adhere to GIQ,
; which means that for any given line, the driver must light exactly
; the same pels as does GDI.  This can be tested using the Guiman tool
; provided elsewhere in the DDK, and 'ZTest', which draws random lines
; on the screen and to a bitmap, and compares the results.
;
; If You've Got Line Hardware
; ---------------------------
;
; If your hardware already adheres to GIQ, you're all set.  Otherwise
; you'll want to look at the S3 sample code and read the following:
;
; 1) You'll want to special case integer-only lines, since they require
;    less processing time and are more common (CAD programs will probably
;    only ever give integer lines).  GDI does not provide a flag saying
;    that all lines in a path are integer lines; consequently, you will
;    have to explicitly check every line.
;
; 2) You are required to correctly draw any line in the 28.4 device
;    space that intersects the viewport.  If you have less than 32 bits
;    of significance in the hardware for the Bresenham terms, extremely
;    long lines would overflow the hardware.  For such (rare) cases, you
;    can fall back to strip-drawing code, of which there is a C version in
;    the S3's lines.cxx (or if your display is a frame buffer, fall back
;    to the engine).
;
; 3) If you can explicitly set the Bresenham terms in your hardware, you
;    can draw non-integer lines using the hardware.  If your hardware has
;    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
;    pels long (4 bits are required for the fractional part, and one bit is
;    used as a sign bit).  Note that integer lines don't require the 4
;    fractional bits, so if you special case them as in 1), you can do
;    integer lines that are up to 2^(n - 1) pels long.  See the S3's
;    fastline.asm for an example.
;
;-----------------------------------------------------------------------;

cProc   bLines,36,< \
    uses esi edi ebx,  \
    ppdev:     ptr,   \
    pptfxFirst: ptr,   \
    pptfxBuf:   ptr,   \
    prun:       ptr,   \
    cptfx:      dword, \
    pls:        ptr,   \
    prclClip:   ptr,   \
    apfn:       ptr,   \
    flStart:    dword  >

; ppdev:     Surface data
; pptfxFirst: Start point of first line
; pptfxBuf:   All subsequent points
; prun:       Array of runs if doing complex clipping
; cptfx:      Number of points in pptfxBuf (i.e., # lines)
; pls:        Line state
; prclClip:   Clip rectangle if doing simple clipping
; apfn:       Pointer to table of strip drawers
; flStart:    Flags for all lines

        local cPelsAfterThisBank:    dword ; For bank switching
        local cStripsInNextRun:      dword ; For bank switching
        local pptfxBufEnd:           ptr   ; Last point in pptfxBuf
        local M0:                    dword ; Normalized x0 in device coords
        local dM:                    dword ; Delta-x in device coords
        local N0:                    dword ; Normalized y0 in device coords
        local dN:                    dword ; Delta-y in device coords
        local fl:                    dword ; Flags for current line
        local x:                     dword ; Normalized start pixel x-coord
        local y:                     dword ; Normalized start pixel y-coord
        local eqGamma_lo:            dword ; Upper 32 bits of Gamma
        local eqGamma_hi:            dword ; Lower 32 bits of Gamma
        local x0:                    dword ; Start pixel x-offset
        local y0:                    dword ; Start pixel y-offset
        local ulSlopeOneAdjustment:  dword ; Special offset if line of slope 1
        local cStylePels:            dword ; # of pixels in line (before clip)
        local xStart:                dword ; Start pixel x-offset before clip
        local pfn:                   ptr   ; Pointer to strip drawing function
        local cPels:                 dword ; # pixels to be drawn (after clip)
        local i:                     dword ; # pixels in strip
        local r:                     dword ; Remainder (or "error") term
        local d_I:                   dword ; Delta-I
        local d_R:                   dword ; Delta-R
        local plStripEnd:            ptr   ; Last strip in buffer
        local ptlStart[size POINTL]: byte  ; Unnormalized start coord
        local dN_Original:           dword ; dN before half-flip
        local xClipLeft:             dword ; Left side of clip rectangle
        local xClipRight:            dword ; Right side of clip rectangle
        local strip[size STRIPS]:    byte  ; Our strip buffer

; Do some initializing:

        mov     esi, pls
        mov     ecx, cptfx
        mov     edx, pptfxBuf
        lea     eax, [edx + ecx * (size POINTL) - (size POINTL)]
        mov     pptfxBufEnd, eax        ; pptfxBufEnd is inclusive of end point

        mov     eax, [esi].LS_chAndXor  ; copy chAndXor from LINESTATE to STRIPS
        mov     strip.ST_chAndXor, eax  ;   buffer

        mov     eax, [edx].ptl_x        ; Load up end point (M1, N1)
        mov     edi, [edx].ptl_y

        mov     edx, pptfxFirst         ; Load up start point (M0, N0)
        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y

        mov     ebx, flStart

;-----------------------------------------------------------------------;
; Flip to the first octant.                                             ;
;-----------------------------------------------------------------------;

; Register state:       esi = M0
;                       ecx = N0
;                       eax = dM (M1)
;                       edi = dN (N1)
;                       ebx = fl

; Make sure we go left to right:

        public  the_main_loop
the_main_loop::
        cmp     esi, eax
        jle     short is_left_to_right  ; skip if M0 <= M1
        xchg    esi, eax                ; swap M0, M1
        xchg    ecx, edi                ; swap N0, N1
        or      ebx, FL_FLIP_H

is_left_to_right:

; Compute the deltas, remembering that the DDI says we should get
; deltas less than 2^31.  If we get more, we ensure we don't crash
; later on by simply skipping the line:

        sub     eax, esi                ; eax = dM
        jo      next_line               ; dM must be less than 2^31
        sub     edi, ecx                ; edi = dN
        jo      next_line               ; dN must be less than 2^31

        jge     short is_top_to_bottom  ; skip if dN >= 0
        neg     ecx                     ; N0 = -N0
        neg     edi                     ; N1 = -N1
        or      ebx, FL_FLIP_V

is_top_to_bottom:
        cmp     edi, eax
        jb      short done_flips        ; skip if dN < dM
        jne     short slope_more_than_one

; We must special case slopes of one (because of our rounding convention):

        or      ebx, FL_FLIP_SLOPE_ONE
        jmp     short done_flips

slope_more_than_one:
        xchg    eax, edi                ; swap dM, dN
        xchg    esi, ecx                ; swap M0, N0
        or      ebx, FL_FLIP_D

done_flips:

        mov     edx, ebx
        and     edx, FL_ROUND_MASK
        .errnz  FL_ROUND_SHIFT - 2
        or      ebx, [gaflRoundTable + edx]  ; get our rounding flags

        mov     dM, eax                 ; save some info
        mov     dN, edi
        mov     fl, ebx

; We're going to shift our origin so that it's at the closest integer
; coordinate to the left/above our fractional start point (it makes
; the math quicker):

        mov     edx, esi                ; x = LFLOOR(M0)
        sar     edx, FLOG2
        mov     x, edx

        mov     edx, ecx                ; y = LFLOOR(N0)
        sar     edx, FLOG2
        mov     y, edx

;-----------------------------------------------------------------------;
; Compute the fractional remainder term                                 ;
;-----------------------------------------------------------------------;

; By shifting the origin we've contrived to eliminate the integer
; portion of our fractional start point, giving us start point
; fractional coordinates in the range [0, F - 1]:

        and     esi, F - 1              ; M0 = FXFRAC(M0)
        and     ecx, F - 1              ; N0 = FXFRAC(N0)

; We now compute Gamma:

        mov     M0, esi                 ; save M0, N0 for later
        mov     N0, ecx

        lea     edx, [ecx + F/2]
        mul     edx                     ; [edx:eax] = dM * (N0 + F/2)
        xchg    eax, edi
        mov     ecx, edx                ; [ecx:edi] = dM * (N0 + F/2)
                                        ; (we just nuked N0)

        mul     esi                     ; [edx:eax] = dN * M0

; Now gamma = dM * (N0 + F/2) - dN * M0 - bRoundDown

        .errnz  FL_V_ROUND_DOWN - 8000h
        ror     bh, 8
        sbb     edi, eax
        sbb     ecx, edx

        shrd    edi, ecx, FLOG2
        sar     ecx, FLOG2              ; gamma = [ecx:edi] >>= 4

        mov     eqGamma_hi, ecx
        mov     eqGamma_lo, edi

        mov     eax, N0

; Register state:
;                       eax = N0
;                       ebx = fl
;                       ecx = eqGamma_hi
;                       edx = garbage
;                       esi = M0
;                       edi = eqGamma_lo

        testb   ebx, FL_FLIP_H
        jnz     line_runs_right_to_left

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a left-to-right line.      ;
;                               -------->                               ;
;-----------------------------------------------------------------------;

        public line_runs_left_to_right
line_runs_left_to_right::
        or      esi, esi
        jz      short LtoR_check_slope_one
                                        ; skip ahead if M0 == 0
                                        ;   (in that case, x0 = 0 which is to be
                                        ;   kept in esi, and is already
                                        ;   conventiently zero)

        or      eax, eax
        jnz     short LtoR_N0_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2
        jmp     short LtoR_check_slope_one
                                        ; esi = x0 = rounded M0

LtoR_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     esi, eax
        sbb     esi, esi
        inc     esi                     ; esi = x0 = (abs(N0 - F/2) <= M0)

        public  LtoR_check_slope_one
LtoR_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        jne     short LtoR_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;       if (M1 > 0) AMD (N1 == M1 + 8)
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1

        mov     edx, M0
        add     edx, dM
        and     edx, F - 1              ; edx = M1

        jz      short LtoR_slope_one_check_start_point

        add     edx, F/2                ; M1 + 8
        cmp     edx, eax                ; cmp N1, M1 + 8
        jne     short LtoR_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, -1

LtoR_slope_one_check_start_point:

        ;
        ;       if (M0 > 0) AMD (N0 == M0 + 8)
        ;

        mov     eax, M0
        or      eax, eax
        jz      short LtoR_compute_y0_from_x0

        add     eax, F/2
        cmp     eax, N0                 ; cmp M0 + 8, N0
        jne     short LtoR_compute_y0_from_x0

        xor     esi, esi                ; x0 = 0

LtoR_compute_y0_from_x0:

; ecx = eqGamma_hi
; esi = x0
; edi = eqGamma_lo

        mov     eax, dN
        mov     edx, dM

        mov     x0, esi
        mov     y0, 0
        cmp     ecx, 0
        jl      short LtoR_compute_x1

        neg     esi
        and     esi, eax
        sub     edx, esi
        cmp     edi, edx
        mov     edx, dM
        jb      short LtoR_compute_x1   ; Bug fix: Must be unsigned!
        mov     y0, 1                   ; y0 = floor((dN * x0 + eqGamma) / dM)

LtoR_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2
        dec     esi                     ; x1 = ((M0 + dM) >> 4) - 1
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15
        jz      done_first_pel_last_pel

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short LtoR_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

LtoR_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     eax, ecx
        jg      done_first_pel_last_pel
        inc     esi
        jmp     done_first_pel_last_pel

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a right-to-left line.      ;
;                               <--------                               ;
;-----------------------------------------------------------------------;

; Compute x0:

        public  line_runs_right_to_left
line_runs_right_to_left::
        mov     x0, 1                   ; x0 = 1
        or      eax, eax
        jnz     short RtoL_N0_not_zero

        xor     edx, edx                ; ulDelta = 0
        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2              ; esi = LROUND(M0, fl & FL_H_ROUND_DOWN)
        jz      short RtoL_check_slope_one

        mov     x0, 2
        mov     edx, dN
        jmp     short RtoL_check_slope_one

RtoL_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, esi                ; eax = ABS(N0 - F/2) + M0
        xor     edx, edx                ; ulDelta = 0
        cmp     eax, F
        jle     short RtoL_check_slope_one

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

        public  RtoL_check_slope_one
RtoL_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE
        jne     short RtoL_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;  if ((N1 > 0) && (M1 == N1 + 8))
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1
        jz      short RtoL_slope_one_check_start_point

        mov     esi, M0
        add     esi, dM
        and     esi, F - 1              ; esi = M1

        add     eax, F/2                ; N1 + 8
        cmp     esi, eax                ; cmp M1, N1 + 8
        jne     short RtoL_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, 1

RtoL_slope_one_check_start_point:

        ;
        ;  if ((N0 > 0) && (M0 == N0 + 8))
        ;

        mov     eax,N0                  ; eax = N0
        or      eax,eax                 ; check for N0 == 0
        jz      short RtoL_compute_y0_from_x0

        mov     esi, M0                 ; esi = M0

        add     eax, F/2                ; N0 + 8
        cmp     eax, esi                ; cmp M0 , N0 + 8
        jne     short RtoL_compute_y0_from_x0

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

RtoL_compute_y0_from_x0:

; eax = garbage
; ebx = fl
; ecx = eqGamma_hi
; edx = ulDelta
; esi = garbage
; edi = eqGamma_lo

        mov     eax, dN                 ; eax = dN
        mov     y0, 0                   ; y0 = 0

        add     edi, edx
        adc     ecx, 0                  ; eqGamma += ulDelta
                                        ; NOTE: Setting flags here!
        mov     edx, dM                 ; edx = dM
        jl      short RtoL_compute_x1   ; NOTE: Looking at the flags here!
        jg      short RtoL_y0_is_2

        lea     ecx, [edx + edx]
        sub     ecx, eax                ; ecx = 2 * dM - dN
        cmp     edi, ecx
        jae     short RtoL_y0_is_2      ; Bug fix: Must be unsigned!

        sub     ecx, edx                ; ecx = dM - dN
        cmp     edi, ecx
        jb      short RtoL_compute_x1   ; Bug fix: Must be unsigned!

        mov     y0, 1
        jmp     short RtoL_compute_x1

RtoL_y0_is_2:
        mov     y0, 2

RtoL_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2              ; x1 = (M0 + dM) >> 4
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short RtoL_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

RtoL_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, ecx                ; eax = ABS(N1 - F/2) + M1
        cmp     eax, F+1
        sbb     esi, -1

done_first_pel_last_pel:

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = garbage
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

        mov     ecx, x0
        lea     edx, [esi + 1]
        sub     edx, ecx                ; edx = x1 - x0 + 1

        jle     next_line
        mov     cStylePels, edx
        mov     xStart, ecx

;-----------------------------------------------------------------------;
; See if clipping or styling needs to be done.                          ;
;-----------------------------------------------------------------------;

        testb   ebx, FL_CLIP
        jnz     do_some_clipping

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = x0        (stack variable correct too)
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

done_clipping:
        mov     eax, y0

        sub     esi, ecx
        inc     esi                     ; esi = cPels = x1 - x0 + 1
        mov     cPels, esi

        mov     esi, ppdev
        add     ecx, x                  ; ecx = ptlStart.ptl_x
        add     eax, y                  ; eax = ptlStart.ptl_y

        mov     esi, [esi].pdev_lNextScan ; we'll compute the sign of lNextScan

        testb   ebx, FL_FLIP_D
        jz      short do_v_unflip
        xchg    ecx, eax

do_v_unflip:
        testb   ebx, FL_FLIP_V
        jz      short done_unflips
        neg     eax
        neg     esi

done_unflips:
        mov     strip.ST_lNextScan, esi ; lNextScan now right for y-direction
        testb   ebx, FL_STYLED
        jnz     do_some_styling

done_styling:
        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

        mov     cPelsAfterThisBank, 0
        mov     cStripsInNextRun, 7fffffffh

;-----------------------------------------------------------------------;
; Do banking setup.                                                     ;
;-----------------------------------------------------------------------;

        public  bank_setup
bank_setup::

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     esi, ppdev
        cmp     eax, [esi].pdev_rcl1WindowClip.yTop
        jl      short bank_get_initial_bank   ; ptlStart.y < rcl1WindowClip.yTop

        cmp     eax, [esi].pdev_rcl1WindowClip.yBottom
        jl      short bank_got_initial_bank   ; ptlStart.y < rcl1WindowClip.yBot

bank_get_initial_bank:
        mov     ptlStart.ptl_y, eax     ; Save ptlStart.ptl_y
        mov     edi, ecx                ; Save ptlStart.ptl_x

        .errnz  JustifyTop
        .errnz  JustifyBottom - 1
        .errnz  FL_FLIP_V - 8

        mov     ecx, ebx                ; JustifyTop if line goes down,
        shr     ecx, 3                  ; JustifyBottom if line goes up
        and     ecx, 1

bank_justified:
        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, eax, ecx>

        mov     eax, ptlStart.ptl_y
        mov     ecx, edi

bank_got_initial_bank:
        testb   ebx, FL_FLIP_D
        jz      short bank_major_x

bank_major_y:
        testb   ebx, FL_FLIP_V
        jz      short bank_major_y_down
bank_major_y_up:
        lea     edi, [eax + 1]
        sub     edi, [esi].pdev_rcl1WindowClip.yTop
        jmp     short bank_done_y_major
bank_major_y_down:
        mov     edi, [esi].pdev_rcl1WindowClip.yBottom
        sub     edi, eax
bank_done_y_major:
        mov     esi, cPels
        sub     esi, edi                ; edi = cPelsInBank
        mov     cPelsAfterThisBank, esi
        jle     short done_bank_setup
        mov     cPels, edi
        jmp     short done_bank_setup

bank_major_x:
        mov     edi, dN
        shr     edi, FLOG2
        add     edi, y

; We're guessing at the y-position of the end pixel (it's too much work
; to compute the actual value) to see if the line spans more than one
; bank.  We have to add at least a slop value of '3' because the actual
; start pixel may be may 2 off from 'y' because of end-pixel exclusiveness,
; and we have to add 1 more because we're taking the floor of (dN / F), to
; account for rounding:

        add     edi, 3                  ; yEnd = edi = y + LFLOOR(dN) + 3
        testb   ebx, FL_FLIP_V
        jz      short bank_major_x_down
bank_major_x_up:
        mov     edx, 1
        sub     edx, [esi].pdev_rcl1WindowClip.yTop    ; edx = -yNextBankStart

        cmp     edi, edx
        lea     edx, [edx + eax]        ; edx = cStripsInNextRun
        jl      short bank_major_x_done

; Line may go over bank boundary, so don't do a half flip:

        or      ebx, FL_DONT_DO_HALF_FLIP
        jmp     short bank_major_x_done

bank_major_x_down:
        mov     esi, [esi].pdev_rcl1WindowClip.yBottom  ; esi = yNextBankStart

        mov     edx, esi
        sub     edx, eax                ; edx = cStripsInNextRun

        cmp     edi, esi
        jl      short bank_major_x_done
        or      ebx, FL_DONT_DO_HALF_FLIP

bank_major_x_done:
        sub     edx, STRIP_MAX
        mov     cStripsInNextRun, edx
        jge     short done_bank_setup

        lea     edx, [strip.ST_alStrips + edx * 4 + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

done_bank_setup:

;-----------------------------------------------------------------------;
; Setup to do DDA.                                                      ;
;-----------------------------------------------------------------------;

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     esi, ppdev
        mov     edi, eax                ; Now edi = ptlStart.ptl_y
        imul    [esi].pdev_lNextScan
        add     eax, [esi].pdev_pvBitmapStart
        add     eax, ecx
        mov     strip.ST_pjScreen, eax  ; pjScreen = pchBits + ptlStart.y *
                                        ;   cjDelta + ptlStart.x

        mov     eax, dM
        mov     ecx, dN
        mov     esi, eqGamma_lo
        mov     edi, eqGamma_hi

; Register state:
;                       eax = dM
;                       ebx = fl
;                       ecx = dN
;                       edx = garbage
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        lea     edx, [ecx + ecx]        ; if (2 * dN > dM)
        cmp     edx, eax
        mov     edx, y0                 ; Load y0 again
        jbe     short after_half_flip

        test    ebx, FL_DONT_DO_HALF_FLIP
        jnz     short after_half_flip

        or      ebx, FL_FLIP_HALF
        mov     fl, ebx

; Do a half flip!

        not     esi
        not     edi
        add     esi, eax
        adc     edi, 0                  ; eqGamma = -eqGamma - 1 + dM

        neg     ecx
        add     ecx, eax                ; dN = dM - dN

        neg     edx
        add     edx, x0                 ; y0 = x0 - y0

after_half_flip:
        mov     strip.ST_flFlips, ebx
        and     ebx, FL_STRIP_MASK

        .errnz  FL_STRIP_SHIFT
        mov     eax, apfn
        lea     eax, [eax + ebx * 4]
        mov     eax, [eax]
        mov     pfn, eax
        mov     eax, dM

; Register state:
;                       eax = dM
;                       ebx = garbage
;                       ecx = dN
;                       edx = y0
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        or      ecx, ecx
        jz      short zero_slope

compute_dda_stuff:
        inc     edx
        mul     edx
        stc                             ; set the carry to accomplish -1
        sbb     eax, esi
        sbb     edx, edi                ; (y0 + 1) * dM - eqGamma - 1
        div     ecx

        mov     esi, eax                ; esi = i
        mov     edi, edx                ; edi = r

        xor     edx, edx
        mov     eax, dM
        div     ecx                     ; edx = d_R, eax = d_I
        mov     d_I, eax

        sub     esi, x0
        inc     esi

done_dda_stuff:
        lea     eax, [strip.ST_alStrips]
        mov     ebx, cPels

;-----------------------------------------------------------------------;
; Do our main DDA loop.                                                 ;
;-----------------------------------------------------------------------;

        sub     edi, ecx                ; offset remainder term from [0..dN)
                                        ;   to [-dN..0) so test in inner
                                        ;   loop is quicker

; Register state:
;                       eax = plStrip   ; current pointer into strip array
;                       ebx = cPels     ; total number of pels in line
;                       ecx = dN        ; delta-N = rise in line
;                       edx = d_R       ; d_I + d_R/dN = exact strip length
;                       esi = i         ; length of current strip
;                       edi = r         ; remainder term for current strip
;                                       ;   in range [-dN..0)

        public  dda_loop
dda_loop::
        sub     ebx, esi                ; subtract strip length from line length
        jle     final_strip             ; if negative, done with line

        mov     [eax], esi              ; write strip length to strip array
        add     eax, 4
        cmp     plStripEnd, eax         ; is the strip array buffer full?
        jbe     short output_strips     ; if so, empty it

; The output_strips routine jumps to here when done:

done_output_strips:
        mov     esi, d_I                ; our normal strip length
        add     edi, edx                ; adjust our remainder term
        jl      short dda_loop

        sub     edi, ecx                ; our remainder became 1 or more, so
        inc     esi                     ;   we increment this strip length
                                        ;   and adjust the remainder term

; We've unrolled our loop a bit, so this should look familiar to the above:

        sub     ebx, esi                ; subtract strip length from line length
        jle     final_strip             ; if negative, done with line

        mov     [eax], esi              ; write strip length to strip array
        add     eax, 4                  ; adjust strip pointer

; Note that banking requires us to check if the strip array is full here
; too (and note that if output_strips is called it will return to
; done_output_strips):

        cmp     plStripEnd, eax
        jbe     short output_strips

        mov     esi, d_I                ; our normal strip length
        add     edi, edx                ; adjust our remainder term
        jl      short dda_loop

        sub     edi, ecx                ; our remainder became 1 or more, so
        inc     esi                     ; adjust
        jmp     short dda_loop

zero_slope:
        mov     esi, 7fffffffh
        jmp     short done_dda_stuff

;-----------------------------------------------------------------------;
; Empty strips buffer & possibly do x-major bank switch.                ;
;-----------------------------------------------------------------------;

output_strips:
        mov     d_R, edx
        mov     cPels, ebx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx

        lea     edx, [strip]
        mov     ecx, pls

; Call our strip routine:

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

; It may be that we ran out of run in our strips buffer, and don't
; actually have to switch banks.  See if that's the case:

        mov     eax, cStripsInNextRun
        or      eax, eax
        jg      short done_strip_bank_switch

; We have to switch banks.  See if we're going up or down:

        mov     esi, ppdev
        test    fl, FL_FLIP_V
        jz      short bank_x_down

bank_x_up:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ebx, [esi].pdev_rcl1WindowClip.yTop
        dec     ebx                     ; we want yTop - 1 to be mapped in

; Map in the next higher bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyBottom>; ebx, esi and edi are preserved

        lea     eax, [ebx + 1]
        sub     eax, [esi].pdev_rcl1WindowClip.yTop
                                        ; eax = # of scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        jmp     short done_strip_bank_switch

bank_x_down:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ebx, [esi].pdev_rcl1WindowClip.yBottom

; Map in the next lower bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ebx, JustifyTop>  ; ebx, esi and edi are preserved

        mov     eax, [esi].pdev_rcl1WindowClip.yBottom
        sub     eax, ebx                ; eax = # scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen,edi

done_strip_bank_switch:

; eax = cStripsInNextRun

        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        sub     eax, STRIP_MAX
        mov     cStripsInNextRun, eax
        jge     short get_ready_for_more_strips
        lea     edx, [edx + eax * 4]

get_ready_for_more_strips:
        mov     plStripEnd, edx

        mov     esi, i
        mov     edi, r
        mov     ebx, cPels
        mov     edx, d_R
        mov     ecx, dN
        lea     eax, [strip.ST_alStrips]
        jmp     done_output_strips

;-----------------------------------------------------------------------;
; Empty strips buffer.  Either get new line or do y-major bank switch.  ;
;-----------------------------------------------------------------------;

final_strip:
        add     ebx, esi
        mov     [eax], ebx
        add     eax, 4

        cmp     cPelsAfterThisBank, 0
        jg      short bank_y_major

very_final_strip:
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

; NOTE: next_line is jumped to from various places, and it cannot assume
;       any registers are loaded.

next_line:
        mov     ebx, flStart
        testb   ebx, FL_COMPLEX_CLIP
        jnz     short see_if_done_complex_clipping

        mov     edx, pptfxBuf
        cmp     edx, pptfxBufEnd
        je      short all_done

        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y
        add     edx, size POINTL
        mov     pptfxBuf, edx
        mov     eax, [edx].ptl_x
        mov     edi, [edx].ptl_y
        jmp     the_main_loop

all_done:
        mov     eax, 1

        cRet    bLines

see_if_done_complex_clipping:
        mov     ebx, fl
        dec     cptfx
        jz      short all_done

        and     ebx, NOT FL_FLIP_HALF   ; Make sure the next run doesn't have
        mov     fl, ebx                 ;   to do a half-flip if it doesn't
                                        ;   want to
        jmp     continue_complex_clipping

;-----------------------------------------------------------------------;
; Switch banks for a y-major line.                                      ;
;-----------------------------------------------------------------------;

        public  bank_y_major
bank_y_major::
        mov     d_R, edx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx
        sub     ebx, esi                ; Undo our offset

bank_y_output_strips:
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <edx, ecx, eax>

        mov     esi, ppdev
        test    fl, FL_FLIP_V
        jz      short bank_y_down

bank_y_up:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ecx, [esi].pdev_rcl1WindowClip.yTop
        push    ecx
        dec     ecx                     ; we want yTop - 1 to be mapped in

; Map in the next higher bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ecx, JustifyBottom>; ebx, esi and edi are preserved

        pop     ecx
        sub     ecx, [esi].pdev_rcl1WindowClip.yTop
                                        ; ecx = # of scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen, edi

        mov     edx, cPelsAfterThisBank                 ; edx = cPelsAfterBank
        lea     eax, [strip.ST_alStrips]                ; eax = plStrip
        or      ebx, ebx                                ; ebx = cPels
        jge     bank_y_done_partial_strip
        jmp     short bank_y_done_switch

bank_y_down:
        mov     edi, strip.ST_pjScreen
        sub     edi, [esi].pdev_pvBitmapStart
        mov     ecx, [esi].pdev_rcl1WindowClip.yBottom
        push    ecx

; Map in the next lower bank:

        ptrCall <dword ptr [esi].pdev_pfnBankControl>, \
                <esi, ecx, JustifyTop>  ; ebx, esi and edi are preserved

        pop     eax
        mov     ecx, [esi].pdev_rcl1WindowClip.yBottom
        sub     ecx, eax                ; ecx = # scans can do in bank

        add     edi, [esi].pdev_pvBitmapStart
        mov     strip.ST_pjScreen,edi

        mov     edx, cPelsAfterThisBank                 ; edx = cPelsAfterBank
        lea     eax, [strip.ST_alStrips]                ; eax = plStrip
        or      ebx, ebx                                ; ebx = cPels
        jge     short bank_y_done_partial_strip

bank_y_done_switch:

; Handle a single strip stretching over multiple banks:

        test    fl, FL_FLIP_HALF
        jz      short bank_y_no_half_flip

; We now have to adjust for the fact that the strip drawers always leave
; the state ready for the next new strip (e.g., if we're doing vertical
; strips, it advances pjScreen one to the right after drawing each strip).
; But the problem is that since we crossed a bank, we have to continue the
; *old* strip, so we have to undo that advance:

bank_y_half_flip:
        inc     strip.ST_pjScreen
        jmp     short bank_y_done_bit_adjust

bank_y_no_half_flip:
        dec     strip.ST_pjScreen

bank_y_done_bit_adjust:
        mov     esi, ebx
        neg     esi                             ; esi = # pels left in strip

; eax = pointer to first strip entry
; ebx = negative esi
; ecx = # of pels we can put down in this window
; edx = # of pels remaining to do in line
; esi = # of pels left in strip

; We have three special cases to check here:
;
;       1) If the strip spans the entire next window
;       2) This is the last strip in the line
;       3) Neither of the above

        cmp     edx,ecx                         ;if line shorter than bank,
        jle     short bank_y_check_if_last_strip;  know strip doesn't span bank

        cmp     esi,ecx                         ;if line spans bank, don't have
        jl      short bank_y_continue_strip     ;  to check if last strip

; If ((# of pels in line > window size) && (# of pels in strip > window size))
; then the strip spans this bank:

        mov     [eax], ecx
        add     eax, 4
        add     ebx, ecx
        sub     edx, ecx
        mov     cPelsAfterThisBank, edx
        jmp     bank_y_output_strips

bank_y_check_if_last_strip:
        cmp     esi, edx                        ;if strip is shorter than line,
        jl      short bank_y_continue_strip     ;  we know this isn't the last
                                                ;  strip

; Handle case where this is the last strip in the line and it overlaps a bank:

        mov     [eax], edx
        add     eax, 4
        jmp     very_final_strip

bank_y_continue_strip:
        mov     [eax], esi
        add     eax, 4

bank_y_done_partial_strip:
        add     ebx, edx                ; cPels += cPelsAfterThisBank
        sub     edx, ecx                ; cPelsAfterThisBank -= cyWindow

        jle     short bank_y_get_ready
        sub     ebx, edx

bank_y_get_ready:
        mov     cPelsAfterThisBank, edx
        mov     edi, r
        mov     edx, d_R
        mov     ecx, dN
        jmp     done_output_strips

;---------------------------Private-Routine-----------------------------;
; do_some_styling
;
; Inputs:
;       eax = ptlStart.ptl_y
;       ebx = fl
;       ecx = ptlStart.ptl_x
; Preserves:
;       eax, ebx, ecx
; Output:
;       Exits to done_styling.
;
;-----------------------------------------------------------------------;

        public  do_some_styling
do_some_styling::
        mov     esi, pls
        mov     ptlStart.ptl_x, ecx

        mov     edi, [esi].LS_spNext    ; spThis
        mov     edx, edi
        add     edx, cStylePels         ; spNext

do_non_alternate_style:

; For styles, we don't bother to keep the style position normalized.
; (we do ensure that it's positive, though).  If a figure is over 2
; billion pels long, we'll be a pel off in our style state (oops!).

        and     edx, 7fffffffh
        mov     [esi].LS_spNext, edx
        mov     ptlStart.ptl_y, eax

        testb   ebx, FL_FLIP_H
        jz      short arbitrary_left_to_right

        sub     edx, x0
        add     edx, xStart
        mov     eax, edx
        xor     edx, edx
        div     [esi].LS_spTotal

        neg     edx
        jge     short continue_right_to_left
        add     edx, [esi].LS_spTotal
        not     eax

continue_right_to_left:
        mov     edi, dword ptr [esi].LS_bStartIsGap
        not     edi
        mov     ecx, [esi].LS_aspRtoL
        jmp     short compute_arbitrary_stuff

arbitrary_left_to_right:
        add     edi, x0
        sub     edi, xStart
        mov     eax, edi
        xor     edx, edx
        div     [esi].LS_spTotal
        mov     edi, dword ptr [esi].LS_bStartIsGap
        mov     ecx, [esi].LS_aspLtoR

compute_arbitrary_stuff:
;       eax = sp / spTotal
;       ebx = fl
;       ecx = pspStart
;       edx = sp % spTotal
;       esi = pls
;       edi = bIsGap

        and     eax, [esi].LS_cStyle        ; if odd length style and second run
        and     al, 1                       ; through style array, flip the
        jz      short odd_style_array_done  ; meaning of the elements
        not     edi

odd_style_array_done:
        mov     eax, [esi].LS_cStyle
        mov     strip.ST_pspStart, ecx
        lea     eax, [ecx + eax * 4 - 4]
        mov     strip.ST_pspEnd, eax

find_psp:
        sub     edx, [ecx]
        jl      short found_psp
        add     ecx, 4
        jmp     short find_psp

found_psp:
        mov     strip.ST_psp, ecx
        neg     edx
        mov     strip.ST_spRemaining, edx

        sub     ecx, strip.ST_pspStart
        test    ecx, 4                      ; size STYLEPOS
        jz      short done_arbitrary
        not     edi

done_arbitrary:
        mov     dword ptr strip.ST_bIsGap, edi
        mov     eax, ptlStart.ptl_y
        mov     ecx, ptlStart.ptl_x
        jmp     done_styling

;---------------------------Private-Routine-----------------------------;
; do_some_clipping
;
; Inputs:
;       eax = garbage
;       ebx = fl
;       ecx = x0
;       edx = garbage
;       esi = x1
;       edi = garbage
;
; Decides whether to do simple or complex clipping.
;
;-----------------------------------------------------------------------;

        public  do_some_clipping
do_some_clipping::
        testb   ebx, FL_COMPLEX_CLIP
        jnz     initialize_complex_clipping

;-----------------------------------------------------------------------;
; simple_clipping
;
; Inputs:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Output:
;       ebx = fl
;       ecx = new x0 (stack variable updated too)
;       esi = new x1
;       y0 stack variable updated
; Uses:
;       All registers
; Exits:
;       to done_clipping
;
; This routine handles clipping the line to the clip rectangle (it's
; faster to handle this case in the driver than to call the engine to
; clip for us).
;
; Fractional end-point lines complicate our lives a bit when doing
; clipping:
;
; 1) For styling, we must know the unclipped line's length in pels, so
;    that we can correctly update the styling state when the line is
;    clipped.  For this reason, I do clipping after doing the hard work
;    of figuring out which pixels are at the ends of the line (this is
;    wasted work if the line is not styled and is completely clipped,
;    but I think it's simpler this way).  Another reason is that we'll
;    have calculated eqGamma already, which we use for the intercept
;    calculations.
;
;    With the assumption that most lines will not be completely clipped
;    away, this strategy isn't too painful.
;
; 2) x0, y0 are not necessarily zero, where (x0, y0) is the start pel of
;    the line.
;
; 3) We know x0, y0 and x1, but not y1.  We haven't needed to calculate
;    y1 until now.  We'll need the actual value, and not an upper bound
;    like y1 = LFLOOR(dM) + 2 because we have to be careful when
;    calculating x(y) that y0 <= y <= y1, otherwise we can cause an
;    overflow on the divide (which, needless to say, is bad).
;
;-----------------------------------------------------------------------;

        public  simple_clipping
simple_clipping::
        mov     edi, prclClip           ; get pointer to normalized clip rect
        and     ebx, FL_RECTLCLIP_MASK  ;   (it's lower-right exclusive)

        .errnz  (FL_RECTLCLIP_SHIFT - 2); ((ebx AND FL_RECTLCLIP_MASK) shr
        .errnz  (size RECTL) - 16       ;   FL_RECTLCLIP_SHIFT) is our index
        lea     edi, [edi + ebx*4]      ;   into the array of rectangles

        mov     edx, [edi].xRight       ; load the rect coordinates
        mov     eax, [edi].xLeft
        mov     ebx, [edi].yBottom
        mov     edi, [edi].yTop

; Translate to our origin and so some quick completely clipped tests:

        sub     edx, x
        cmp     ecx, edx
        jge     totally_clipped         ; totally clipped if x0 >= xRight

        sub     eax, x
        cmp     esi, eax
        jl      totally_clipped         ; totally clipped if x1 < xLeft

        sub     ebx, y
        cmp     y0, ebx
        jge     totally_clipped         ; totally clipped if y0 >= yBottom

        sub     edi, y

; Save some state:

        mov     xClipRight, edx
        mov     xClipLeft, eax

        cmp     esi, edx                ; if (x1 >= xRight) x1 = xRight - 1
        jl      short calculate_y1
        lea     esi, [edx - 1]

calculate_y1:
        mov     eax, esi                ; y1 = (x1 * dN + eqGamma) / dM
        mul     dN
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     edi, eax                ; if (yTop > y1) clipped
        jg      short totally_clipped

        cmp     ebx, eax                ; if (yBottom > y1) know x1
        jg      short x1_computed

        mov     eax, ebx                ; x1 = (yBottom * dM + eqBeta) / dN
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        mov     esi, eax

; At this point, we've taken care of calculating the intercepts with the
; right and bottom edges.  Now we work on the left and top edges:

x1_computed:
        mov     edx, y0

        mov     eax, xClipLeft          ; don't have to compute y intercept
        cmp     eax, ecx                ;   at left edge if line starts to
        jle     short top_intercept     ;   right of left edge

        mov     ecx, eax                ; x0 = xLeft
        mul     dN                      ; y0 = (xLeft * dN + eqGamma) / dM
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     ebx, eax                ; if (yBottom <= y0) clipped
        jle     short totally_clipped

        mov     edx, eax
        mov     y0, eax

top_intercept:
        mov     ebx, fl                 ; get ready to leave
        mov     x0, ecx

        cmp     edi, edx                ; if (yTop <= y0) done clipping
        jle     done_clipping

        mov     eax, edi                ; x0 = (yTop * dM + eqBeta) / dN + 1
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        lea     ecx, [eax + 1]

        cmp     xClipRight, ecx         ; if (xRight <= x0) clipped
        jle     short totally_clipped

        mov     y0, edi                 ; y0 = yTop
        mov     x0, ecx
        jmp     done_clipping           ; all done!

totally_clipped:

; The line is completely clipped.  See if we have to update our style state:

        mov     ebx, fl
        testb   ebx, FL_STYLED
        jz      next_line

; Adjust our style state:

        mov     esi, pls
        mov     eax, [esi].LS_spNext
        add     eax, cStylePels
        mov     [esi].LS_spNext, eax

        cmp     eax, [esi].LS_spTotal2
        jb      next_line

; Have to normalize first:

        xor     edx, edx
        div     [esi].LS_spTotal2
        mov     [esi].LS_spNext, edx

        jmp     next_line

;-----------------------------------------------------------------------;

initialize_complex_clipping:
        mov     eax, dN                 ; save a copy of original dN
        mov     dN_Original, eax

;---------------------------Private-Routine-----------------------------;
; continue_complex_clipping
;
; Inputs:
;       ebx = fl
; Output:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Uses:
;       All registers.
; Exits:
;       to done_clipping
;
; This routine handles the necessary initialization for the next
; run in the CLIPLINE structure.
;
; NOTE: This routine is jumped to from two places!
;-----------------------------------------------------------------------;

        public  continue_complex_clipping
continue_complex_clipping::
        mov     edi, prun
        mov     ecx, xStart
        testb   ebx, FL_FLIP_H
        jz      short complex_left_to_right

complex_right_to_left:

; Figure out x0 and x1 for right-to-left lines:

        add     ecx, cStylePels
        dec     ecx
        mov     esi, ecx                ; esi = ecx = xStart + cStylePels - 1
        sub     ecx, [edi].RUN_iStop    ; New x0
        sub     esi, [edi].RUN_iStart   ; New x1
        jmp     short complex_reset_variables

complex_left_to_right:

; Figure out x0 and x1 for left-to-right lines:

        mov     esi, ecx                ; esi = ecx = xStart
        add     ecx, [edi].RUN_iStart   ; New x0
        add     esi, [edi].RUN_iStop    ; New x1

complex_reset_variables:
        mov     x0, ecx

; The half flip mucks with some of our variables, and we have to reset
; them every pass.  We would have to reset eqGamma too, but it never
; got saved to memory in its modified form.

        add     edi, size RUN
        mov     prun, edi               ; Increment run pointer for next time

        mov     edi, pls
        mov     eax, [edi].LS_spComplex
        mov     [edi].LS_spNext, eax    ; pls->spNext = pls->spComplex

        mov     eax, dN_Original        ; dN = dN_Original
        mov     dN, eax

        mul     ecx
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi         ; [edx:eax] = dN*x0 + eqGamma

        div     dM
        mov     y0, eax
        jmp     done_clipping

endProc bLines

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\lines.inc ===
;---------------------------- Include File Header ---------------------------;
; lines.inc
;
; Line drawing constants and structures.
;
; NOTE: This file mirrors LINES.H.  Changes here must be reflected in
; the .h file!
;
; See lines.h for a description of most defines.
;
;----------------------------------------------------------------------------;

STYLE_MAX_COUNT         equ 16
STYLE_MAX_VALUE         equ 3fffh
RUN_MAX                 equ 20
STRIP_MAX               equ 100
STYLE_DENSITY           equ 3

; For the ROP table:

MIX_XOR_OFFSET          equ 8

AND_ZERO                equ 0
AND_PEN                 equ 1
AND_NOTPEN              equ 2
AND_ONE                 equ 3

XOR_ZERO                equ (AND_ZERO   shl MIX_XOR_OFFSET)
XOR_PEN                 equ (AND_PEN    shl MIX_XOR_OFFSET)
XOR_NOTPEN              equ (AND_NOTPEN shl MIX_XOR_OFFSET)
XOR_ONE                 equ (AND_ONE    shl MIX_XOR_OFFSET)

;
; Flip and round flags:
;

FL_H_ROUND_DOWN         equ 00000080h   ; Set if x = 1/2 rounds to x = 1
FL_V_ROUND_DOWN         equ 00008000h   ; Set if y = 1/2 rounds to y = 1

FL_FLIP_D               equ 00000005h   ; Diagonal flip
FL_FLIP_V               equ 00000008h   ; Vertical flip
FL_FLIP_SLOPE_ONE       equ 00000010h   ; If slope is exactly one
FL_FLIP_HALF            equ 00000002h   ; Half flip
FL_FLIP_H               equ 00000200h   ; Horizontal (right-to-left) exchange

FL_ROUND_MASK           equ 0000001ch   ; Rounding is dependent on diagonal,
FL_ROUND_SHIFT          equ 2           ;  vertical flips and if slope is one

FL_RECTLCLIP_MASK       equ 0000000ch   ; When we unflip to do clipping, we
FL_RECTLCLIP_SHIFT      equ 2           ;  only have to look at diagonal and
                                        ;  vertical flips

FL_STRIP_MASK           equ 00000003h   ; Which strip drawer we call is based
FL_STRIP_SHIFT          equ 0           ;  on if we did diagonal and/or half
                                        ;  flips

FL_SIMPLE_CLIP          equ 00000020h   ; Denotes our clipping complexity
FL_COMPLEX_CLIP         equ 00000040h
FL_CLIP                 equ (FL_SIMPLE_CLIP + FL_COMPLEX_CLIP)

FL_SET                  equ 00000800h   ; If ROP is such that we don't have to
                                        ;  read video memory
FL_ARBITRARYSTYLED      equ 00000400h   ; If the line is styled
FL_STYLED               equ (FL_ARBITRARYSTYLED)

FL_STRIP_ARRAY_MASK     equ 00000C00h   ; Which strip arrays we look up depends
FL_STRIP_ARRAY_SHIFT    equ 10          ;  on if we're doing style and/or have
                                        ;  a 'set' style ROP

; Simple flag bits in high byte:

FL_DONT_DO_HALF_FLIP    equ 00002000h

; Miscellaneous DDA defines:

F                       equ 16
FLOG2                   equ 4

STRIPS struc

; Updated by strip drawers:

    ST_pjScreen         dd  ?
    ST_bIsGap           dd  ?

    ST_psp              dd  ?
    ST_spRemaining      dd  ?

; Not modified by strip drawers:

    ST_lNextScan        dd  ?
    ST_plStripEnd       dd  ?       ; usually won't be valid
    ST_flFlips          dd  ?
    ST_pspStart         dd  ?
    ST_pspEnd           dd  ?
    ST_xyDensity        dd  ?
    ST_chAndXor         dd  ?

; We leave room for a couple of extra dwords at the end of the strips
; array that can be used by the strip drawers:

    ST_alStrips	        dd  (STRIP_MAX + 2) dup (?)
STRIPS ends

LINESTATE struc
    LS_chAndXor         dd  ?
    LS_spTotal          dd  ?
    LS_spTotal2         dd  ?
    LS_spNext           dd  ?
    LS_spComplex        dd  ?

    LS_aspRtoL          dd  ?
    LS_aspLtoR          dd  ?

    LS_xyDensity        dd  ?
    LS_cStyle           dd  ?

    LS_ulStyleMaskLtoR  dd  ?
    LS_ulStyleMaskRtoL  dd  ?

    LS_bStartIsGap      db  ?
    LS_filler3          db  3 dup (?)
LINESTATE ends

;
; This RUN structure must match that in winddi.h!
;

RUN struc
    RUN_iStart          dd  ?
    RUN_iStop           dd  ?
RUN ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\strucs.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: stucts.inc
;
; Defines common structures.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; POINTB is used for points with a range of -128..+127.
;-----------------------------------------------------------------------;

POINTB          STRUC
ptb_x           DB      0
ptb_y           DB      0
POINTB          ENDS

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS


;-----------------------------------------------------------------------;
; SIZEB is used for extents with a range of -128..+127.
;-----------------------------------------------------------------------;

SIZEB           STRUC
sizb_cx         DB      0
sizb_cy         DB      0
SIZEB           ENDS


;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;


RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends


;-----------------------------------------------------------------------;
; Definitions for dsurf_iFormat
;-----------------------------------------------------------------------;

BMF_DEVICE          equ     0
BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6
BMF_4RLE            equ     8
BMF_8RLE            equ     9
BMF_PHYSDEVICE      equ     0FFh


;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;


GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends


GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends


GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Information block for RLE blts
;-----------------------------------------------------------------------;

RLEINFO struc
RLE_pjTrg        dd  ?
RLE_pjSrcBits    dd  ?
RLE_pjSrcBitsMax dd  ?
RLE_prctlClip    dd  ?
RLE_pulTranslate dd  ?
RLE_xBegin       dd  ?
RLE_lNextScan    dd  ?
RLE_lNextPlane   dd  ?
RLE_prctlTrg     dd  ?
RLE_dwFormat     dd  ?
Rle_pdsurfTrg    dd  ?
RLEINFO ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\unroll.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: unroll.inc
;
; Equates and macros for loop unrolling.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

; Module including this must define LOOP_UNROLL_SHIFT. the log2 of the number
; of times you want loops in this module unrolled. For example,
; LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8 times unrolling. This is the only
; thing you need to change to control unrolling.

; # of times to unroll the loop, calculated as 2**n, where n is the
; user-specified log2 of # of times to unroll the loop.

LOOP_UNROLL_COUNT equ   (1 shl LOOP_UNROLL_SHIFT)

;-----------------------------------------------------------------------;
; Macro to generate an unrolled loop of UNROLL_COUNT instances of BASE_MACRO,
; passing the base macro the info needed to construct a label of the form
; BASE_LABELxxx, where xxx is UNROLL_COUNT the first time, and counts down by
; one each time thereafter.

UNROLL_LOOP macro BASE_MACRO,BASE_LABEL,UNROLL_COUNT

INDEX=UNROLL_COUNT
        rept UNROLL_COUNT ;-------------------------;
        &BASE_MACRO &BASE_LABEL,%INDEX
INDEX=INDEX-1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Macro to generate a dword memory variable that points to the label
; specified by concatenating the label and the index.

DEFINE_DD macro BASE_LABEL,INDEX ;------------------;
        dd      &BASE_LABEL&INDEX
        endm    ;-----------------------------------;
        
;-----------------------------------------------------------------------;
; Macro to generate a table of vectors into an unrolled loop, for entering
; to handle all possible fractional loops.

UNROLL_LOOP_ENTRY_TABLE macro TABLE,BASE_LABEL,UNROLL_COUNT
        align   4
TABLE label  dword
        DEFINE_DD       BASE_LABEL,%&UNROLL_COUNT

INDEX=1
        rept    UNROLL_COUNT-1
        DEFINE_DD       BASE_LABEL,%INDEX
INDEX=INDEX+1
        endm    ;-----------------------------------;

        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_VARS macro COUNT_DEST,VEC_DEST,COUNT_SOURCE,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_DEST&,&COUNT_SOURCE&       ;copy count to vector dest to
                                                ; work with it
        ifdifi  <&COUNT_SOURCE&>,<&COUNT_DEST&>
        mov     &COUNT_DEST&,&COUNT_SOURCE&     ;copy to count dest too, if not
        endif                                   ; same as count source
        add     &COUNT_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_DEST&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_DEST&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        mov     &VEC_DEST&,&VEC_TABLE&[&VEC_DEST&*4]
                                            ;place to jump into the unrolled
                                            ; loop so as to handle the
                                            ; fractional part first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;
; Given a loop count, a vector table, and unrolling parameters, this generates
; COUNT_DEST = # of times to execute unrolled loop, VEC_DEST = entry point into
; unrolled loop to perform whatever fractional loop is needed. Assumes dests
; are registers.
        
SET_UP_UNROLL_AND_BRANCH macro COUNT_REG,VEC_REG,VEC_TABLE,UNROLL_SHIFT
        mov     &VEC_REG&,&COUNT_REG&       ;copy count to vector dest to
                                            ; work with it
        add     &COUNT_reg&,(1 shl LOOP_UNROLL_SHIFT)-1 ;round count up
        and     &VEC_REG&,(1 shl LOOP_UNROLL_SHIFT)-1
                                            ;fractional part of unrolled loop
        shr     &COUNT_REG&,UNROLL_SHIFT    ;# of repetitions of unrolled loop
        jmp     dword ptr &VEC_TABLE&[&VEC_REG&*4]
                                            ;jump into the unrolled loop so as
					    ; to handle the fractional part
					    ; first
        endm    ;-----------------------------------;

;-----------------------------------------------------------------------;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\monopat.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: monopat.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation.  All rights reserved.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vMonoPat(ppdev, culRcl, prcl, ulMix, prb, pptlBrush)
;
; Input:
;
;  ppdev     - surface on which to draw
;  culRcl    - number of rectangles
;  prcl      - pointer to rectangles
;  ulMix     - mix mode (i.e., ROP)
;  prb       - pointer to realized brush
;  pptlBrush - brush alignment
;
; Draws two color patterns using the VGA hardware.  If the ROP is a
; PATCOPY ROP, we can light 8 pixels on every word write to VGA memory.
;
; We special case black & white patterns because we can do slightly less
; initialization, and we can handle arbitrary ROPs (although if the ROP
; has to read video memory, we can only do 4 pixels on every read/write
; operation).
;
;-----------------------------------------------------------------------;
;
; NOTE: Assumes all rectangles have positive heights and widths.  Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .code

; vTrgBlt is used for 2-pass ROPs:

        EXTRNP          vTrgBlt,24

        .data

; Tables shared with vgablts.asm:

extrn   jALUFuncTable:  byte
extrn   jInvertDest:    byte

;-----------------------------------------------------------------------;
; Bits for drawing routine look-ups.

BLOCK_LEFT_EDGE                 equ 010000b
BLOCK_RIGHT_EDGE                equ 001000b
BLOCK_MIDDLE_STARTS_UNALIGNED   equ 000100b
BLOCK_NO_MIDDLE                 equ 000010b
BLOCK_MIDDLE_ENDS_UNALIGNED     equ 000001b

;-----------------------------------------------------------------------;
; Table of drawing routines, with the look-up index a 5 bit field as
; follows:
;
; Bit 4 = 1 if a left edge must be drawn
; Bit 3 = 1 if a right edge must be drawn
; Bit 2 = 1 if middle block starts unaligned word-wise
; Bit 1 = 1 if no middle block
; Bit 0 = 1 if middle block is an odd number of bytes in length

        align   4
gapfnSetTable label dword
        dd      dual_wide_00_w          ;00000
        dd      dual_wide_01_w          ;00001
        dd      0                       ;00010
        dd      0                       ;00011
        dd      dual_wide_11_w          ;00100
        dd      dual_wide_10_w          ;00101
        dd      0                       ;00110
        dd      0                       ;00111
        dd      Block_01000_w           ;01000
        dd      Block_01001_w           ;01001
        dd      dual_right_0_w          ;01010
        dd      dual_right_1_w          ;01011
        dd      Block_01100_w           ;01100
        dd      Block_01101_w           ;01101
        dd      dual_right_1_w          ;01110
        dd      dual_right_0_w          ;01111
        dd      Block_10000_w           ;10000
        dd      Block_10001_w           ;10001
        dd      dual_left_0_w           ;10010
        dd      dual_left_0_w           ;10011
        dd      Block_10100_w           ;10100
        dd      Block_10101_w           ;10101
        dd      dual_left_1_w           ;10110
        dd      dual_left_1_w           ;10111
        dd      Block_11000_w           ;11000
        dd      Block_11001_w           ;11001
        dd      Block_11010_w           ;11010
        dd      0                       ;11011 - can never happen
        dd      Block_11100_w           ;11100
        dd      Block_11101_w           ;11101
        dd      Block_11110_w           ;11110
        dd      0                       ;11111 - can never happen

gapfnROPTable label dword
        dd      dual_wide_00_rw         ;00000
        dd      dual_wide_01_rw         ;00001
        dd      0                       ;00010
        dd      0                       ;00011
        dd      dual_wide_11_rw         ;00100
        dd      dual_wide_10_rw         ;00101
        dd      0                       ;00110
        dd      0                       ;00111
        dd      Block_01000_rw          ;01000
        dd      Block_01001_rw          ;01001
        dd      dual_right_0_rw         ;01010
        dd      dual_right_1_rw         ;01011
        dd      Block_01100_rw          ;01100
        dd      Block_01101_rw          ;01101
        dd      dual_right_1_rw         ;01110
        dd      dual_right_0_rw         ;01111
        dd      Block_10000_rw          ;10000
        dd      Block_10001_rw          ;10001
        dd      dual_left_0_rw          ;10010
        dd      dual_left_0_rw          ;10011
        dd      Block_10100_rw          ;10100
        dd      Block_10101_rw          ;10101
        dd      dual_left_1_rw          ;10110
        dd      dual_left_1_rw          ;10111
        dd      Block_11000_rw          ;11000
        dd      Block_11001_rw          ;11001
        dd      Block_11010_rw          ;11010
        dd      0                       ;11011 - can never happen
        dd      Block_11100_rw          ;11100
        dd      Block_11101_rw          ;11101
        dd      Block_11110_rw          ;11110
        dd      0                       ;11111 - can never happen

gaulForceOffTable label dword
        dd      0                       ;ignored - there is no mix 0
        dd      0
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh

gaulForceOnTable label dword
        dd      0                       ;ignored - there is no mix 0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0ffffffffh

gaulForceNotTable label dword
        dd      0                       ;ignored - there is no mix 0
        dd      0
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0ffffffffh
        dd      0
        dd      0
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0ffffffffh
        dd      0
        dd      0
        dd      0
        dd      0

;-----------------------------------------------------------------------;

        .code
;-----------------------------------------------------------------------;
; Write thunks (for set ROPs)
;-----------------------------------------------------------------------;

Block_01000_w:
        push    offset dual_right_0_w
        jmp     dual_wide_00_w

Block_01001_w:
        push    offset dual_right_1_w
        jmp     dual_wide_01_w

Block_01100_w:
        push    offset dual_right_1_w
        jmp     dual_wide_11_w

Block_01101_w:
        push    offset dual_right_0_w
        jmp     dual_wide_10_w

Block_11000_w:
        push    offset dual_right_0_w
Block_10000_w:
        push    offset dual_left_0_w
        jmp     dual_wide_00_w

Block_11001_w:
        push    offset dual_right_1_w
Block_10001_w:
        push    offset dual_left_0_w
        jmp     dual_wide_01_w

Block_11100_w:
        push    offset dual_right_1_w
Block_10100_w:
        push    offset dual_left_1_w
        jmp     dual_wide_11_w

Block_11101_w:
        push    offset dual_right_0_w
Block_10101_w:
        push    offset dual_left_1_w
        jmp     dual_wide_10_w

Block_11010_w:
        push    offset dual_right_0_w
        jmp     dual_left_0_w

Block_11110_w:
        push    offset dual_right_1_w
        jmp     dual_left_1_w

;-----------------------------------------------------------------------;
; Read/write thunks (for arbitrary ROPs)
;-----------------------------------------------------------------------;

Block_01000_rw:
        push    offset dual_right_0_rw
        jmp     dual_wide_00_rw

Block_01001_rw:
        push    offset dual_right_1_rw
        jmp     dual_wide_01_rw

Block_01100_rw:
        push    offset dual_right_1_rw
        jmp     dual_wide_11_rw

Block_01101_rw:
        push    offset dual_right_0_rw
        jmp     dual_wide_10_rw

Block_11000_rw:
        push    offset dual_right_0_rw
Block_10000_rw:
        push    offset dual_left_0_rw
        jmp     dual_wide_00_rw

Block_11001_rw:
        push    offset dual_right_1_rw
Block_10001_rw:
        push    offset dual_left_0_rw
        jmp     dual_wide_01_rw

Block_11100_rw:
        push    offset dual_right_1_rw
Block_10100_rw:
        push    offset dual_left_1_rw
        jmp     dual_wide_11_rw

Block_11101_rw:
        push    offset dual_right_0_rw
Block_10101_rw:
        push    offset dual_left_1_rw
        jmp     dual_wide_10_rw

Block_11010_rw:
        push    offset dual_right_0_rw
        jmp     dual_left_0_rw

Block_11110_rw:
        push    offset dual_right_1_rw
        jmp     dual_left_1_rw

;-----------------------------------------------------------------------;

cProc   vMonoPat,24,<         \
        uses esi edi ebx,     \
        ppdev:     ptr PDEV,  \
        culRcl:    dword,     \
        prcl:      ptr RECTL, \
        ulMix:     dword,     \
        prb:       ptr RBRUSH,\
        pptlBrush: ptr POINTL >

; Variables used in block drawers:

        local ppfnDraw:            ptr   ;pointer to array of draw routines
        local pfnDraw:             ptr   ;pointer to draw routines

        local yBrush:              dword ;current y brush alignment
        local yBrushOrg:           dword ;original y brush alignment
        local ulMiddleDest:        dword ;bitmap offset to middle
        local lMiddleDelta:        dword ;delta from end of middle scan to next
        local ulBlockHeight:       dword ;# of scans to be drawn in block
        local ulBlockHeightTmp:    dword ;scratch copy of ulBlockHeight
        local cwMiddle:            dword ;# of words to be written in middle

        local ulLeftDest:          dword ;bitmap offset to left edge
        local ulLeftMask:          dword ;plane mask for left-edge drawing
        local ulRightDest:         dword ;bitmap offset to right edge
        local ulRightMask:         dword ;plane mask for right-edge drawing
        local lDelta:              dword ;delta between scans

        local ulCurrentDestScan:   dword ;current destination scan
        local ulLastDestScan:      dword ;last destination scan

        local pulPattern:          ptr   ;pointer to working pattern buffer
                                         ; (to account for brush inversions)
        local aulPatternBuffer[8]: dword ;pattern buffer

        local pfnLoopTop:           ptr   ;points to desired loop top

        mov     esi,pptlBrush
        mov     edi,prb
        mov     ecx,[esi].ptl_y
        mov     yBrushOrg,ecx           ;yBrushOrg = pptlBrush->y
        mov     ecx,[esi].ptl_x
        mov     eax,[edi].rb_xBrush
        and     ecx,7
        cmp     eax,ecx
        jne     dual_align_brush        ;only align if we really have to

dual_done_align_brush:
        test    [edi].rb_fl,RBRUSH_2COLOR
        jnz     col2_colors

; Set VGA to read mode 1 and write mode 2:

        mov     esi,ppdev
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[2]
        or      ah,M_COLOR_READ
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 2 to expand pattern bits to
                                        ; 0 or 0ffh per plane, read mode 1 so
                                        ; we can read 0xFF from memory always,
                                        ; for ANDing (because Color Don't Care
                                        ; is all zeros)

;-----------------------------------------------------------------------;
; Handle only black/white patterns.
;-----------------------------------------------------------------------;

        lea     eax,[edi].rb_aulPattern
        mov     pulPattern,eax          ;pulPattern = &pbr.rb_aulPattern[0]
        lea     eax,gapfnSetTable
        mov     ppfnDraw,eax            ;ppfnDraw = gapfnSetTable

        mov     ecx,ulMix
        and     ecx,0fh
        cmp     ecx,R2_COPYPEN
        jne     bw_init_rop             ;do some more work if not copy ROP

bw_done_init_rop:

        call    dual_draw_rectangles    ;draw those puppies

; All done!  Restore read mode 0, write mode 0:

        mov     esi,ppdev
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
        mov     al,GRAF_MODE
        out     dx,ax

; Enable all planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cmp     ulMix,R2_COPYPEN
        jne     short bw_enable_set_mode
        cRet    vMonoPat

; Set ALU function to Set mode (we don't have to bother if we had a
; COPYPEN ROP):

bw_enable_set_mode:
        mov     eax,GRAF_DATA_ROT + (DR_SET shl 8)
        mov     edx,VGA_BASE + GRAF_ADDR
        out     dx,ax
        cRet    vMonoPat

;-----------------------------------------------------------------------;
; Draw both black and white and 2 color rectangles.
;-----------------------------------------------------------------------;

        public  dual_draw_rectangles
dual_draw_rectangles::

        mov     edi,prcl                ;edi = prcl
        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        mov     ecx,edx
        imul    ecx,ebx

        sub     ebx,yBrushOrg
        and     ebx,7
        mov     yBrush,ebx              ;yBrush = (prcl->top - pptlBrush->y) & 7
                                        ; (our current index into the pattern
                                        ; array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lDelta +
                                        ; (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short dual_done_left    ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_LEFT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

dual_done_left:
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        .errnz  (BLOCK_MIDDLE_STARTS_UNALIGNED shr 2) - 1
        and     ebx,1                   ;set bit if middle doesn't start
        or      esi,ebx                 ; word aligned (remembering we'll
                                        ; soon shift flags left by 2)

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short dual_done_right   ;skip if we don't need a right edge

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_RIGHT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short dual_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_RIGHT_EDGE shr 2)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  dual_done_right
dual_done_right::
        mov     ebx,ppfnDraw

; We're going to do two 'adc esi,esi' instructions here, effectively
; shifting our flags left by 2, and setting the low bits:

        .errnz  (BLOCK_NO_MIDDLE shr 1) - 1
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        .errnz  (BLOCK_MIDDLE_ENDS_UNALIGNED) - 1
        shr     eax,1
        adc     esi,esi                 ;shift flags left one, and set low
                                        ; bit if the middle isn't an even
                                        ; number of bytes in length
        mov     cwMiddle,eax            ;cwMiddle = cjMiddle / 2

        sub     edx,eax
        sub     edx,eax
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - 2 * cwMiddle

        mov     eax,[ebx+esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

        mov     ebx,ppdev
        mov     edi,[edi].yTop

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short dual_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short dual_init_bank_mapped

dual_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

dual_init_bank_mapped:
        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl1PlanarClip.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        call    pfnDraw

dual_done_pfnDraw:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     short dual_next_rectangle

; Get the next bank:

        mov     ebx,ppdev
        mov     yBrush,esi              ;make sure we record the new brush
                                        ; alignment

; Map the next bank into window.
; Note: EBX, ESI, and EDI are preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        jmp     short dual_init_bank_mapped

;-----------------------------------------------------------------------;
; Done rectangle.
;-----------------------------------------------------------------------;

        public  dual_next_rectangle
dual_next_rectangle::
        add     prcl, size RECTL
        dec     culRcl
        jg      dual_draw_rectangles    ;do more rectangles

        PLAIN_RET                       ;return

;-----------------------------------------------------------------------;
; Handle x-brush alignment.
;-----------------------------------------------------------------------;

        public  dual_align_brush
dual_align_brush::

; Align the pattern on x.  Remember it in the realized brush, because if
; the brush is used again, it's likely to have the same alignment...

        mov     [edi].rb_xBrush,ecx     ;remember our new alignment
        sub     ecx,eax                 ;rotate pattern left by
                                        ; pptlBrush->x - prb->xBrush

; We keep each row of the pattern in the low word of each dword.  If the
; bits are to appear on the screen as 01234567, the word of our pattern
; has the bits 32107654|76543210 -- we're in write mode 3, and when
; written as a word, this results in 3210 being written in the first
; byte, and 7654 in the second byte.
;
; For our funky plaanr format, we just rotate each byte of the word left by
; 'cl' to get the desired result.

        rol     byte ptr [edi][0].rb_aulPattern,cl        ;0
        rol     byte ptr [edi][1].rb_aulPattern,cl
        rol     byte ptr [edi][4].rb_aulPattern,cl        ;1
        rol     byte ptr [edi][5].rb_aulPattern,cl
        rol     byte ptr [edi][8].rb_aulPattern,cl        ;2
        rol     byte ptr [edi][9].rb_aulPattern,cl
        rol     byte ptr [edi][12].rb_aulPattern,cl       ;3
        rol     byte ptr [edi][13].rb_aulPattern,cl
        rol     byte ptr [edi][16].rb_aulPattern,cl       ;4
        rol     byte ptr [edi][17].rb_aulPattern,cl
        rol     byte ptr [edi][20].rb_aulPattern,cl       ;5
        rol     byte ptr [edi][21].rb_aulPattern,cl
        rol     byte ptr [edi][24].rb_aulPattern,cl       ;6
        rol     byte ptr [edi][25].rb_aulPattern,cl
        rol     byte ptr [edi][28].rb_aulPattern,cl       ;7
        rol     byte ptr [edi][29].rb_aulPattern,cl

        jmp     dual_done_align_brush

;-----------------------------------------------------------------------;
; Handle arbitrary ROPs for black/white patterns.
;-----------------------------------------------------------------------;

; Expect:
;
; ecx = ulMix

        public  bw_init_rop
bw_init_rop::
        cmp     jInvertDest[ecx],0
        je      short bw_set_that_ALU   ;skip if don't need 2 passes

; For some ROPs, we have to invert the destination first, then do another
; operation (that is, it's a 2-pass ROP).  We handle the inversion here:

        cCall   vTrgBlt,<ppdev, culRcl, prcl, R2_NOT, 0, 0>
        mov     ecx,ulMix
        and     ecx,0fh

bw_set_that_ALU:
        mov     ah,jALUFuncTable[ecx]
        cmp     ah,DR_SET
        je      short bw_that_ALU_is_set
                                        ;we're already in Set mode

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function
        lea     ebx,gapfnROPTable
        mov     ppfnDraw,ebx

bw_that_ALU_is_set:
        lea     esi,aulPatternBuffer
        mov     pulPattern,esi          ;we're using the temporary buffer

        mov     ebx,gaulForceOffTable[ecx*4]
        mov     edx,gaulForceOnTable[ecx*4]
        mov     esi,gaulForceNotTable[ecx*4]

        mov     eax,[edi][0].rb_aulPattern      ;0
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][0],eax
        mov     eax,[edi][4].rb_aulPattern      ;1
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][4],eax
        mov     eax,[edi][8].rb_aulPattern      ;2
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][8],eax
        mov     eax,[edi][12].rb_aulPattern     ;3
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][12],eax
        mov     eax,[edi][16].rb_aulPattern     ;4
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][16],eax
        mov     eax,[edi][20].rb_aulPattern     ;5
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][20],eax
        mov     eax,[edi][24].rb_aulPattern     ;6
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][24],eax
        mov     eax,[edi][28].rb_aulPattern     ;7
        and     eax,ebx
        or      eax,edx
        xor     eax,esi
        mov     [aulPatternBuffer][28],eax

        jmp     bw_done_init_rop

;-----------------------------------------------------------------------;
; Handle 2-color patterns.
;-----------------------------------------------------------------------;

        public  col2_colors
col2_colors::
        lea     eax,[edi].rb_aulPattern
        mov     pulPattern,eax          ;pulPattern = &pbr.rb_aulPattern[0]
        lea     eax,gapfnSetTable
        mov     ppfnDraw,eax            ;ppfnDraw = gapfnSetTable

        call    col2_first_rectangle

; Restore VGA hardware to its default state:

        mov     edx,VGA_BASE + GRAF_DATA
        mov     al,0ffh
        out     dx,al                   ;enable all bits through the Bit Mask

        mov     esi,ppdev
        dec     edx                     ;point back to the Graphics Index reg
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
                                        ;write mode 0 setting for Graphics Mode
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     eax,GRAF_DATA_ROT + (DR_SET SHL 8)
        out     dx,ax                   ;replace mode, no rotate

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al                   ;enable all planes

        cRet    vMonoPat

;-----------------------------------------------------------------------;
; Handle first rectangle for 2-color patterns.
;-----------------------------------------------------------------------;

; We have to special case the first rectangle because we have to load
; the latches with the background color after mapping the bank but before
; doing any drawing.

        public  col2_first_rectangle
col2_first_rectangle::
        mov     edi,prcl                ;edi = prcl
        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     ebx,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        mov     ulLastDestScan,eax      ;ulLastDestScan = prcl->bottom
        mov     ulCurrentDestScan,ebx   ;ulCurrentDestScan = prcl->top

        mov     ecx,edx
        imul    ecx,ebx

        sub     ebx,yBrushOrg
        and     ebx,7
        mov     yBrush,ebx              ;yBrush = (prcl->top - pptlBrush->y) & 7
                                        ; (our current index into the pattern
                                        ; array)

        mov     ebx,[edi].xLeft
        shr     ebx,2
        add     ebx,ecx                 ;ebx = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
                                        ; (offset into bitmap of left side)

        mov     eax,[edi].xRight
        shr     eax,2
        add     eax,ecx
        mov     ulRightDest,eax         ;ulRightDest = prcl->top * lDelta +
                                        ; (prcl->right >> 2)
                                        ; (offset into bitmap of right side)

        xor     esi,esi                 ;zero our flags

        mov     ecx,[edi].xLeft
        and     ecx,3
        jz      short col2_done_left    ;skip if we don't need a left edge

        mov     esi,0fh                 ;compute the plane mask for the left
        shl     esi,cl                  ; edge.  we don't use a look-up table
        mov     ulLeftMask,esi          ; 'cause it won't be in the cache.

        mov     esi,(BLOCK_LEFT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

        mov     ulLeftDest,ebx          ;ulLeftDest = prcl->top * lDelta +
                                        ; (prcl->left >> 2)
        inc     ebx                     ;ebx = ulMiddleDest = ulLeftDest + 1
                                        ; (we have to adjust our offset to
                                        ; the first whole byte)

col2_done_left:
        sub     eax,ebx                 ;eax = cjMiddle =
                                        ; ulRightDest - ulMiddleDest
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        .errnz  (BLOCK_MIDDLE_STARTS_UNALIGNED shr 2) - 1
        and     ebx,1                   ;set bit if middle doesn't start
        or      esi,ebx                 ; word aligned (remembering we'll
                                        ; soon shift flags left by 2)

        mov     ecx,[edi].xRight
        and     ecx,3
        jz      short col2_done_right   ;skip if we don't need a right edge

        mov     ebx,0f0h                ;compute the plane mask for the right
        rol     bl,cl                   ; edge.  we don't use a look-up table
        mov     ulRightMask,ebx         ; 'cause it won't be in the cache.

        or      esi,(BLOCK_RIGHT_EDGE shr 2)
                                        ;set our flag (we soon shift left by 2)

; If the count of whole bytes is negative, that means that the pattern
; starts and ends in the same quadpixel, so we do some more work:

        cmp     eax,0
        jge     short col2_done_right

; It starts and ends in the same quadpixel:

        and     esi,not (BLOCK_RIGHT_EDGE shr 2)
                                        ;turn off right edge
        and     ebx,ulLeftMask
        mov     ulLeftMask,ebx
        xor     eax,eax                 ;we do zero middle bytes

        public  col2_done_right
col2_done_right::
        mov     ebx,ppfnDraw

; We're going to do two 'adc esi,esi' instructions here, effectively
; shifting our flags left by 2, and setting the low bits:

        .errnz  (BLOCK_NO_MIDDLE shr 1) - 1
        cmp     eax,1                   ;shift flags left one, and set low
        adc     esi,esi                 ; bit if we don't need to do a middle

        .errnz  (BLOCK_MIDDLE_ENDS_UNALIGNED) - 1
        shr     eax,1
        mov     cwMiddle,eax            ;cwMiddle = cjMiddle / 2
        adc     esi,esi                 ;shift flags left one, and set low
                                        ; bit if the middle isn't an even
                                        ; number of bytes in length

        sub     edx,eax
        sub     edx,eax
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - 2 * cwMiddle

        mov     eax,[ebx+esi*4]
        mov     pfnDraw,eax             ;pointer to function that draws
                                        ; everything in the bank

        mov     ebx,ppdev
        test    esi,BLOCK_NO_MIDDLE
        jz      short col2_have_a_middle

;-----------------------------------------;

; Handle case where there isn't a whole quadpixel that will be overwritten
; by the pattern, and so we don't have a convenient place for loading the
; latches.  For this case, we'll use off-screen memory.

        mov     esi,[ebx].pdev_pbceCache
        mov     eax,[esi].bce_yCache

        cmp     eax,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short col2_no_middle_map_brush_bank

        cmp     eax,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short col2_no_middle_brush_bank_mapped

col2_no_middle_map_brush_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,eax,JustifyBottom>

col2_no_middle_brush_bank_mapped:
        mov     ecx,prb                 ;ecx = prb
        mov     esi,[esi].bce_ulCache
        add     esi,[ebx].pdev_pvBitmapStart

        mov     eax,[ecx].rb_ulBkColor
        mov     [esi],al
        mov     al,[esi]                ;latches now laoded with bk color

        mov     edi,[edi].yTop

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short col2_no_middle_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      col2_latches_loaded

col2_no_middle_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        mov     ecx,prb                 ;reload ecx = prb
        jmp     col2_latches_loaded

;-----------------------------------------;

col2_have_a_middle:
        mov     edi,[edi].yTop

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short col2_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short col2_init_bank_mapped

col2_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

col2_init_bank_mapped:
        mov     ecx,prb                 ;ecx = prb
        mov     esi,ulMiddleDest
        add     esi,[ebx].pdev_pvBitmapStart
                                        ;pointer to the first whole quadpixel
                                        ; that will be overwritten by the
                                        ; pattern, and so which is a great
                                        ; place to use to load the latches

        mov     eax,[ecx].rb_ulBkColor
        mov     [esi],al
        mov     al,[esi]                ;latches now loaded with bk color

; Set VGA to read mode 0 and write mode 2:

col2_latches_loaded:

; ebx = ppdev
; ecx = prb
; edi = top line of rectangle

        mov     esi,ppdev
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[2]
        mov     al,GRAF_MODE
        out     dx,ax

        mov     eax,GRAF_DATA_ROT + (DR_XOR SHL 8)
        out     dx,ax                   ;XOR to flip latched data to make ~bk

        mov     ah,byte ptr [ecx].rb_ulBkColor
        xor     ah,byte ptr [ecx].rb_ulFgColor
        mov     al,GRAF_BIT_MASK
        out     dx,ax                   ;pass through common fg & bk bits
                                        ; unchanged from bk color in latches;
                                        ; non-common bits come from XOR in the
                                        ; ALUs, flipped from the bk to the fg
                                        ; state if the glyph bit for the pixel
                                        ; in that plane is 1, still in bk state
                                        ; if the glyph bit for that plane is 0

; All done hardware initialization.  Do rest of this boring stuff:

        mov     eax,ulLastDestScan
        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom

        sub     eax,ebx
        sbb     ecx,ecx
        and     ecx,eax
        add     ebx,ecx                 ;ebx = min(ulLastDestScan,
                                        ;      ppdev->rcl1PlanarClip.yBottom)
        mov     ulCurrentDestScan,ebx

        sub     ebx,edi
        mov     ulBlockHeight,ebx       ;ulBlockHeight = ebx - ulCurrentDestScan

; Draw everything in this bank:

        CALL_AND_JUMP   pfnDraw,dual_done_pfnDraw

;=======================================================================;
;========================= Set Block Drawers ===========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; dual_wide_11_w
;
; Draws middle words with 1 leading byte and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_11_w
dual_wide_11_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        add     edx,2                   ;account for first and last
                                        ; bytes
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        inc     edi                     ;align to word

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_11_w_loop:

; We aim to overdrive.

        mov     eax,[ebx+esi * 4]       ;load pattern for this scan
        mov     [edi-1],ah              ;write the first byte

        mov     ecx,cwMiddle
        dec     ecx                     ;account for first and last
                                        ; bytes
        rep     stosw                   ;light 8 pels on every write

        inc     esi                     ;advance to next scan of pattern
        and     esi,7
        mov     [edi],al                ;write that last byte

        add     edi,edx                 ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_11_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        dec     edi                     ;undo our word alignment
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_10_w
;
; Draws middle words with 1 leading byte and 0 trailing bytes.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_10_w
dual_wide_10_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        inc     edi                             ;align to word

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_10_w_loop:
        mov     eax,[ebx+esi * 4]               ;load pattern for this scan
        mov     [edi-1],ah                      ;write the first byte

        mov     ecx,cwMiddle
        rep     stosw                           ;light 8 pels on every write

        inc     esi                             ;advance to next scan of pattern
        and     esi,7

        add     edi,edx                         ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_10_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        dec     edi                             ;undo our word alignment
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_01_w
;
; Draws middle words with 0 leading bytes and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_01_w
dual_wide_01_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_01_w_loop:
        mov     eax,[ebx+esi*4]                 ;load pattern for this scan

        mov     ecx,cwMiddle
        rep     stosw                           ;light 8 pels on every write

        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        mov     [edi],al                        ;write that last byte

        add     edi,edx                         ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_01_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_00_w
;
; Draws middle words with 0 leading bytes and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_00_w
dual_wide_00_w::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ulBlockHeightTmp,ebx
        mov     ebx,pulPattern
        mov     edx,lMiddleDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest

;  EBX = pointer to start of pattern
;  EDX = offset from end of scan to start of next
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_00_w_loop:
        mov     eax,[ebx+esi*4]                 ;load pattern for this scan

        mov     ecx,cwMiddle
        rep     stosw                           ;light 8 pels on every write

        inc     esi                             ;advance to next scan of pattern
        and     esi,7

        add     edi,edx                         ;advance to next scan

        dec     ulBlockHeightTmp
        jnz     short dual_wide_00_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_1_w
;
; Draws a left edge when the next byte is not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_1_w
dual_left_1_w::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_1_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_1_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_0_w
;
; Draws a left edge when the next byte is word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_0_w
dual_left_0_w::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_0_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_0_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_1_w
;
; Draws a right edge when not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_1_w
dual_right_1_w::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_1_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_1_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_0_w
;
; Draws a right edge when word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_0_w
dual_right_0_w::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_0_w_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        mov     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_0_w_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;=======================================================================;
;========================= ROP Block Drawers ===========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; dual_wide_11_rw
;
; Draws middle words with 1 leading byte and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_11_rw
dual_wide_11_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
        mov     ebx,cwMiddle

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_11_rw_loop:
        and     [edi],ah
        and     [edi+1],al
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_11_rw_loop

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jz      short dual_wide_11_rw_done

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        mov     ebx,cwMiddle
        jmp     dual_wide_11_rw_loop

dual_wide_11_rw_done:
        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_10_rw
;
; Draws middle words with 1 leading byte and 0 trailing bytes.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_10_rw
dual_wide_10_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
        mov     ebx,cwMiddle

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        or      ebx,ebx                         ;have to watch for zero words
        jz      short dual_wide_10_rw_only_one_byte

        mov     pfnLoopTop,offset dual_wide_10_rw_loop

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_10_rw_loop:
        and     [edi],ah
        and     [edi+1],al
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_10_rw_loop

dual_wide_10_rw_odd_byte:
        and     [edi],ah                        ;write that odd byte

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jz      short dual_wide_10_rw_done

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        mov     ebx,cwMiddle
        jmp     pfnLoopTop

dual_wide_10_rw_only_one_byte:
        mov     pfnLoopTop,offset dual_wide_10_rw_odd_byte
        jmp     short dual_wide_10_rw_odd_byte

dual_wide_10_rw_done:
        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_01_rw
;
; Draws middle words with 0 leading bytes and 1 trailing byte.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_01_rw
dual_wide_01_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
        mov     ebx,cwMiddle

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        or      ebx,ebx
        jz      short dual_wide_01_rw_only_one_byte

        mov     pfnLoopTop,offset dual_wide_01_rw_loop

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_01_rw_loop:
        and     [edi],al
        and     [edi+1],ah
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_01_rw_loop

dual_wide_01_rw_odd_byte:
        and     [edi],al                        ;write that odd byte

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jz      short dual_wide_01_rw_done

        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

        mov     ebx,cwMiddle
        jmp     pfnLoopTop

dual_wide_01_rw_only_one_byte:
        mov     pfnLoopTop,offset dual_wide_01_rw_odd_byte
        jmp     short dual_wide_01_rw_odd_byte

dual_wide_01_rw_done:
        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_wide_00_rw
;
; Draws middle words with 0 leading bytes and 0 trailing bytes.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lMiddleDelta  - distance from end of current scan to start of next
;     ulMiddleDest  - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;     cwMiddle      - # of words to draw on each scan
;
; Output:
;     esi           - new y brush alignment
;     ulMiddleDest  - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_wide_00_rw
dual_wide_00_rw::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        mov     edi,ppdev

        mov     edx,ulBlockHeight
        mov     ulBlockHeightTmp,edx
        mov     edx,pulPattern                  ;load those registers

        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulMiddleDest
        mov     esi,yBrush
dual_wide_00_rw_scan_loop:
        mov     ebx,cwMiddle
        mov     eax,[edx+esi*4]                 ;load pattern for this scan
        inc     esi
        and     esi,7

;  EAX = pattern for this scan
;  EBX = count of loop iterations
;  EDX = pointer to start of pattern
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_wide_00_rw_loop:
        and     [edi],al
        and     [edi+1],ah
        add     edi,2                           ;the write will overlap this

        dec     ebx
        jnz     short dual_wide_00_rw_loop

        add     edi,lMiddleDelta
        dec     ulBlockHeightTmp
        jnz     dual_wide_00_rw_scan_loop

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_1_rw
;
; Draws a left edge when the next byte is not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_1_rw
dual_left_1_rw::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_1_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_1_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_left_0_rw
;
; Draws a left edge when the next byte is word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulLeftDest    - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulLeftDest    - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_left_0_rw
dual_left_0_rw::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulLeftDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_left_0_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_left_0_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_1_rw
;
; Draws a right edge when not word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_1_rw
dual_right_1_rw::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_1_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],ah                        ;write the high byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_1_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; dual_right_0_rw
;
; Draws a right edge when word aligned.
;
; Input:
;     ppdev         - pointer to physical device structure
;     ulBlockHeight - # of scans to draw
;     lDelta        - distance from end of current scan to start of next
;     ulRightDest   - offset in bitmap at which to start drawing
;     yBrush        - current y brush alignment
;
; Output:
;     esi           - new y brush alignment
;     ulRightDest   - new bitmap offset
;-----------------------------------------------------------------------;

        public  dual_right_0_rw
dual_right_0_rw::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     edi,ppdev
        mov     ebx,ulBlockHeight
        mov     ecx,pulPattern
        mov     edx,lDelta
        mov     esi,yBrush
        mov     edi,[edi].pdev_pvBitmapStart
        add     edi,ulRightDest

;  EBX = count of loop iterations
;  ECX = pointer to start of pattern
;  EDX = offset to next scan
;  ESI = current offset into pattern
;  EDI = target address to which to write

dual_right_0_rw_loop:
        mov     eax,[ecx+esi*4]                 ;load pattern for this scan
        and     [edi],al                        ;write the low byte
        inc     esi                             ;advance to next scan of pattern
        and     esi,7
        add     edi,edx                         ;advance to next scan

        dec     ebx
        jnz     short dual_right_0_rw_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     edi,[ecx].pdev_pvBitmapStart
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vMonoPat

;-----------------------------------------------------------------------;
; BOOL b2ColorBrush(pjBits, pjFgColor, pjBkColor)
;
; Determines if the 8x8x8bpp packed brush pointed to by pjBits has only
; two colors, and if so returns the 1bpp bitmap.
;
; Returns:
;       eax        = 1 if two (or one) color brush, 0 otherwise
;       pjBits     = pointer to packed 1bpp bitmap if a 2-color brush
;       *pjFgColor = foreground color for returned 1bpp bitmap (i.e.,
;                       used to color-expand '1' bits)
;       *pjBkColor = backgroun color for returned 1bpp bitmap (i.e.,
;                       used to color-expand '0' bits)
;-----------------------------------------------------------------------;

cProc   b2ColorBrush,12,<     \
        uses esi edi ebx,     \
        pjBits:    ptr BYTE,  \
        pjFgColor: ptr BYTE,  \
        pjBkColor: ptr BYTE   >

; al = first color
; ah = second color
; ecx = number of unrolled loops

        mov     esi,pjBits
        mov     ecx,(BRUSH_SIZE shr 1)
        mov     al,[esi]

b2col_find_2nd_color_loop:
        mov     ah,[esi+1]
        cmp     ah,al
        jne     short b2col_find_consecutive_2nd_color_loop_part_1

        add     esi,2
        dec     ecx
        jz      short b2col_is_2_colors ;actually, it's only one color

        mov     ah,[esi]
        cmp     ah,al
        jne     short b2col_find_consecutive_2nd_color_loop_part_2
        jmp     short b2col_find_2nd_color_loop

;------------------------------------;

b2col_find_consecutive_1st_color_loop_part_1:
        add     esi,2
        dec     ecx
        jz      short b2col_is_2_colors

        mov     bl,[esi]
        cmp     bl,ah
        je      short b2col_find_consecutive_2nd_color_loop_part_2
        cmp     bl,al
        jne     short b2col_isnt_2_colors

b2col_find_consecutive_1st_color_loop_part_2:
        mov     bl,[esi+1]
        cmp     bl,ah
        je      short b2col_find_consecutive_2nd_color_loop_part_1
        cmp     bl,al
        je      short b2col_find_consecutive_1st_color_loop_part_1

        xor     eax,eax
        cRet    b2ColorBrush            ;return FALSE

;------------------------------------;

b2col_find_consecutive_2nd_color_loop_part_1:
        add     esi,2
        dec     ecx
        jz      short b2col_is_2_colors

        mov     bl,[esi]
        cmp     bl,al
        je      short b2col_find_consecutive_1st_color_loop_part_2
        cmp     bl,ah
        jne     short b2col_isnt_2_colors

b2col_find_consecutive_2nd_color_loop_part_2:
        mov     bl,[esi+1]
        cmp     bl,al
        je      short b2col_find_consecutive_1st_color_loop_part_1
        cmp     bl,ah
        je      short b2col_find_consecutive_2nd_color_loop_part_1

b2col_isnt_2_colors:
        xor     eax,eax
        cRet    b2ColorBrush            ;return FALSE

;------------------------------------;

        public  b2col_is_2_colors
b2col_is_2_colors::

; Here, we want the color with the lesser value to be in 'al', and the
; other to be in 'ah'.

        cmp     al,ah
        jb      short b2col_ordered_colors
        xchg    al,ah

b2col_ordered_colors:
        mov     ecx,(BRUSH_SIZE shr 3)
        mov     esi,pjBits
        mov     edi,esi

; Colors matching 'al' will get mapped to '1' bits, and colors matching
; 'ah' will get mapped to '0' bits:

b2col_monochrome_bitmap_loop:
        cmp     [esi+7],ah
        adc     bl,bl
        cmp     [esi+6],ah
        adc     bl,bl
        cmp     [esi+5],ah
        adc     bl,bl
        cmp     [esi+4],ah
        adc     bl,bl
        cmp     [esi+3],ah
        adc     bl,bl
        cmp     [esi+2],ah
        adc     bl,bl
        cmp     [esi+1],ah
        adc     bl,bl
        cmp     [esi],ah
        adc     bl,bl

; At this point, where the 8 bytes of the bitmap were ordered 0 1 2 3 4 5 6 7,
; we've got the monochrome byte in 'bl' ordered 7 6 5 4 3 2 1 0.  We want
; the word ordered '3 2 1 0 7 6 5 4 | 7 6 5 4 3 2 1 0' where the lower 4 bits
; of every bit are the planes mask, and the upper 4 bits are ordered to
; facilitate easy rotating.
;
; The word is actually written into a dword in the destination buffer.

        mov     bh,bl
        ror     bh,4
        mov     [edi],ebx               ;save this dword of monochrome bitmap
        add     edi,4
        add     esi,8
        dec     ecx
        jnz     b2col_monochrome_bitmap_loop

; Aside: because of the way this is written, if the two colors are black
; and white (i.e., 0x00 and 0xff), the foreground color will be black (0x00),
; and the background will be white (0xff).

        mov     esi,pjFgColor
        mov     edi,pjBkColor
        mov     [esi],al                ;save foreground color
        mov     [edi],ah                ;save background color
        mov     eax,1
        cRet    b2ColorBrush

endProc b2ColorBrush

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\scroll.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: scroll.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vPlanarCopyBits(ppdev, prclDest, pptlSrc);
;
; Input:
;
;  ppdev    - surface on which to copy
;  prcldest - pointer to destination rectangle
;  pptlsrc  - pointer to source upper left corner
;
; Performs accelerated SRCCOPY screen-to-screen blts.
;
;-----------------------------------------------------------------------;
;
; NOTE: This handles only quad-pixel aligned blits!
;
; NOTE: Assumes all rectangles have positive heights and widths. Will
; not work properly if this is not the case.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .data

; Bits for block copier tables:

BLOCK_RIGHT_TO_LEFT     equ 4
BLOCK_LEFT_EDGE         equ 2
BLOCK_RIGHT_EDGE        equ 1

;-----------------------------------------------------------------------;
; Table of block copiers for various horizontal directions, with the
; look-up index a 3-bit field as follows:
;
; Bit 2 (BLOCK_RIGHT_TO_LEFT) = 1 if right-to-left copy
; Bit 1 (BLOCK_LEFT_EDGE)     = 1 if left edge must be copied
; Bit 0 (BLOCK_RIGHT_EDGE)    = 1 if right edge must be copied

        align   4
MasterBlockTable label dword

        dd      copy_just_middle_block
        dd      Block_WR
        dd      Block_LW
        dd      Block_LWR

        dd      copy_just_middle_block
        dd      Block_RW
        dd      Block_WL
        dd      Block_RWL

        align   4
TopToBottomLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      top_to_bottom_1RW
        dd      top_to_bottom_2RW
        dd      top_to_bottom_2RW

        align   4
BottomToTopLoopTable label dword
        dd      0                               ;Not used - unbanked case
        dd      bottom_to_top_1RW
        dd      bottom_to_top_2RW
        dd      bottom_to_top_2RW

        align   4
SetUpForCopyDirection label dword
        dd      left_to_right_top_to_bottom     ;CD_RIGHTDOWN
        dd      right_to_left_top_to_bottom     ;CD_LEFTDOWN
        dd      left_to_right_bottom_to_top     ;CD_RIGHTUP
        dd      right_to_left_bottom_to_top     ;CD_LEFTUP

LeftMaskTable label dword
        dd      01111b
        dd      01110b
        dd      01100b
        dd      01000b

RightMaskTable label dword
        dd      00000b
        dd      00001b
        dd      00011b
        dd      00111b

;-----------------------------------------------------------------------;

        .code

        EXTRNP  bPuntScreenToScreenCopyBits,20

Block_WR:
        push    offset copy_right_block
        jmp     copy_middle_block

Block_LW:
        push    offset copy_middle_block
        jmp     copy_left_block

Block_LWR:
        push    offset copy_right_block
        push    offset copy_middle_block
        jmp     copy_left_block

Block_RW:
        push    offset copy_middle_block
        jmp     copy_right_block

Block_WL:
        push    offset copy_left_block
        jmp     copy_middle_block

Block_RWL:
        push    offset copy_left_block
        push    offset copy_middle_block
        jmp     copy_right_block

;-----------------------------------------------------------------------;

cProc   vPlanarCopyBits,12,<    \
        uses esi edi ebx,       \
        ppdev:    ptr PDEV,     \
        prclDest: ptr RECTL,    \
        pptlSrc:  ptr POINTL    >

; Variables used in block copiers:

        local pfnCopyBlocks:       ptr   ;pointer to block copy routines

        local ulMiddleSrc:         dword ;bitmap offset to 1st source
        local ulMiddleDest:        dword ;bitmap offset to 1st dest
        local lMiddleDelta:        dword ;delta from end of middle scan to next
        local ulBlockHeight:       dword ;number of scans to be copied in block
        local cjMiddle:            dword ;number of bytes to be copied on scan

        local ulLeftSrc:           dword ;bitmap offset to left source byte edge
        local ulLeftDest:          dword ;bitmap offset to left dest byte edge
        local ulRightSrc:          dword ;bitmap offset to right source byte edge
        local ulRightDest:         dword ;bitmap offset to right dest byte edge
        local lDelta:              dword ;delta between scans

        local ulLeftMask:          dword ;byte mask for left-edge copies
        local ulRightMask:         dword ;byte mask for right-edge copies

        local rclDest[size RECTL]: byte  ;left and right values always valid
        local ptlSrc[size POINTL]: byte  ;x value always valid

        local ulCurrentSrcScan:    dword ;real current source scan
        local ulCurrentDestScan:   dword ;real current destination scan
        local ulLastDestScan:      dword ;last destination scan

; Set the bit mask to disable all bits, so we can copy through the latches:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0 shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Figure out which direction to do the copies:

        mov     esi,pptlSrc
        mov     edi,prclDest
        mov     eax,[esi].ptl_y
        cmp     eax,[edi].yTop
        jl      planar_bottom_to_top

        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     short left_to_right_top_to_bottom       ; CD_RIGHTDOWN
        jmp     right_to_left_top_to_bottom             ; CD_LEFTDOWN

planar_bottom_to_top:
        mov     eax,[esi].ptl_x
        cmp     eax,[edi].xLeft
        jge     left_to_right_bottom_to_top             ; CD_RIGHTUP
        jmp     right_to_left_bottom_to_top             ; CD_LEFTUP

all_done:

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        cld

        cRet    vPlanarCopyBits

;=======================================================================;
;==================== Direction Dependent Setup ========================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_top_to_bottom
left_to_right_top_to_bottom::

; Need to set-up: ulMiddleSrc, ulMiddleDest, lMiddleDelta, cjMiddle
;                 ulLeftSrc, ulLeftDest, ulLeftMask
;                 lDelta
;                 ulRightSrc, ulRightDest, ulRightMask
;                 ulCurrentDestScan, ulLastDestScan
;                 pfnCopyBlocks
;                 ptlSrc.x, rclDest.left, rclDest.right

; lDelta = ppdev->lPlanarScan
; ulCurrentSrcScan  = pptl->y
; ulLeftSrc         = pptl->y       * lDelta + (pptl->x >> 2)
; ulCurrentDestScan = prclDest->top
; ulLeftDest        = prclDest->top * lDelta + (prclDest->left >> 2)
;
; ulMiddleSrc  = ulLeftSrc
; ulMiddleDest = ulLeftDest
;
; cjMiddle = (prclDest->right >> 2) - (prclDest->left >> 2)
; if (prclDest->left & 3)
;     ulLeftMask = LeftMaskTable[prclDest->left & 3]
;     fl |= BLOCK_LEFT_EDGE
;     ulMiddleSrc++
;     ulMiddleDest++
;     cjMiddle--
;
; lMiddleDelta = lDelta - cjMiddle
;
; if (prclDest->right & 3)
;     ulRightMask = RightMaskTable[prclDest->right & 3]
;     fl |= BLOCK_RIGHT_EDGE
;     ulRightSrc  = ulMiddleSrc  + cjMiddle
;     ulRightDest = ulMiddleDest + cjMiddle

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,2
        add     eax,ecx                 ;eax = ulLeftSrc = pptlSrc->y *
                                        ;  lDelta + (pptlSrc->x >> 2)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulLeftDest = prclDest->top *
                                        ;  lDelta + (prclDest->left >> 2)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,2
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 2) -
                                        ;  (prclDest->left >> 2)

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short l_t_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_t_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short l_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_t_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_t_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, top-to-bottom copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_top_to_bottom
right_to_left_top_to_bottom::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yBottom
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->bottom

        mov     ecx,[esi].ptl_y
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,2
        add     eax,ecx                 ;eax = ulRightSrc = pptlSrc->y *
                                        ; lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 4

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yTop
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->top
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulRightDest = prclDest->top *
                                        ; lDelta + prclDest->right / 4

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,2
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 4 -
                                        ;  prclDest->left / 4

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short r_t_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_t_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short r_t_done_left_edge ;skip if we don't need a right edge
        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_t_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_t_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        mov     lDelta,edx              ;lDelta = ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     TopToBottomLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for left-to-right, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public left_to_right_bottom_to_top
left_to_right_bottom_to_top::

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        shr     ecx,2
        add     eax,ecx                 ;eax = ulLeftSrc = (ulCurrentSrcScan - 1)
                                        ;  * lDelta + (pptlSrc->x >> 2)

        xor     esi,esi                 ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xLeft
        mov     rclDest.xLeft,ecx       ;rclDest.left = prclDest->left
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulLeftDest = (prclDest->bottom - 1)
                                        ;  * lDelta + (prclDest->left >> 2)

        mov     edi,[edi].xRight
        mov     rclDest.xRight,edi
        shr     edi,2
        sub     edi,ecx                 ;cjMiddle = (prclDest->right >> 2) -
                                        ;  (prclDest->left >> 2)

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short l_b_done_left_edge ;skip if we don't need a left edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        mov     ulLeftSrc,eax           ;ulLeftSrc
        mov     ulLeftDest,ebx          ;ulLeftDest
        inc     eax
        inc     ebx
        dec     edi

l_b_done_left_edge:
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short l_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        add     eax,edi
        add     ebx,edi
        mov     ulRightSrc,eax          ;ulRightSrc = ulMiddleSrc + cjMiddle
        mov     ulRightDest,ebx         ;ulRightDest = ulMiddleDest + cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     l_b_done_right_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulLeftMask the composite mask:

        inc     edi
        xor     esi,BLOCK_RIGHT_EDGE
        and     ecx,ulLeftMask
        mov     ulLeftMask,ecx

l_b_done_right_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        sub     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta - cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;-----------------------------------------------------------------------;
; Set-up code for right-to-left, bottom-to-top copies.
;
; Input:
;       esi - pptlSrc
;       edi - prclDest
;-----------------------------------------------------------------------;

        public right_to_left_bottom_to_top
right_to_left_bottom_to_top::

        std                             ;copy middle blocks right-to-left

        mov     edx,ppdev
        mov     eax,[edi].yTop
        mov     edx,[edx].pdev_lPlanarNextScan ;edx = lDelta
        mov     ulLastDestScan,eax      ;ulLastDestScan = prclDest->top

        mov     ecx,[esi].ptl_y
        add     ecx,[edi].yBottom
        sub     ecx,[edi].yTop
        mov     eax,edx
        mov     ulCurrentSrcScan,ecx    ;ulCurrentSrcScan = pptlSrc->y +
                                        ;  (prclDest->bottom - prclDest->top)
        dec     ecx
        imul    eax,ecx
        mov     ecx,[esi].ptl_x
        mov     ptlSrc.ptl_x,ecx        ;ptlSrc.x = pptlSrc->x
        add     ecx,[edi].xRight
        sub     ecx,[edi].xLeft
        shr     ecx,2
        add     eax,ecx                 ;eax = ulRightSrc = (ulCurrentSrcScan
                                        ; - 1) * lDelta + (pptlSrc->x +
                                        ; prclDest->right - prclDest->left) / 4

        mov     esi,BLOCK_RIGHT_TO_LEFT ;initialize flags

        mov     ecx,[edi].yBottom
        mov     ebx,edx
        mov     ulCurrentDestScan,ecx   ;ulCurrentDestScan = prclDest->bottom
        dec     ecx
        imul    ebx,ecx
        mov     ecx,[edi].xRight
        mov     rclDest.xRight,ecx      ;rclDest.right = prclDest->right
        shr     ecx,2
        add     ebx,ecx                 ;ebx = ulRightDest = (ulCurrentDestScan
                                        ; - 1) * lDelta + prclDest->right / 4

        mov     edi,[edi].xLeft
        mov     rclDest.xLeft,edi
        shr     edi,2
        neg     edi
        add     edi,ecx                 ;cjMiddle = prclDest->right / 4 -
                                        ;  prclDest->left / 4

        mov     ecx,rclDest.xRight
        and     ecx,3
        jz      short r_b_done_right_edge ;skip if we don't need a right edge

        or      esi,BLOCK_RIGHT_EDGE
        mov     ecx,RightMaskTable[ecx*4]
        mov     ulRightMask,ecx         ;ulRightMask =
                                        ;  RightMaskTable[prclDest->right & 3]

        mov     ulRightSrc,eax          ;ulRightSrc
        mov     ulRightDest,ebx         ;ulRightDest

r_b_done_right_edge:
        dec     eax
        dec     ebx
        mov     ulMiddleSrc,eax         ;ulMiddleSrc
        mov     ulMiddleDest,ebx        ;ulMiddleDest

        mov     ecx,rclDest.xLeft
        and     ecx,3
        jz      short r_b_done_left_edge ;skip if we don't need a right edge

        or      esi,BLOCK_LEFT_EDGE
        mov     ecx,LeftMaskTable[ecx*4]
        mov     ulLeftMask,ecx          ;ulLeftMask =
                                        ;  LeftMaskTable[prclDest->left & 3]

        dec     edi                     ;adjust middle block length because
                                        ;  we're effectively doing one less
                                        ;  middle byte

        sub     eax,edi
        sub     ebx,edi
        mov     ulLeftSrc,eax           ;ulLeftSrc = ulMiddleSrc - cjMiddle
        mov     ulLeftDest,ebx          ;ulLeftDest = ulMiddleDest - cjMiddle

; We special case here blits that are less than 4 pels wide and begin and end
; in the same 4-pel quadruple:

        cmp     edi,0
        jge     r_b_done_left_edge

; We make sure the 'middle' count of bytes is zero (we'll just let the code
; fall through the 'middle' copy code), turn off the right-edge flag, and
; give ulRightMask the composite mask:

        inc     edi
        xor     esi,BLOCK_LEFT_EDGE
        and     ecx,ulRightMask
        mov     ulRightMask,ecx

r_b_done_left_edge:
        mov     cjMiddle,edi            ;cjMiddle

        neg     edx
        mov     lDelta,edx              ;lDelta = -ppdev->lPlanarNextScan
        add     edx,edi
        mov     lMiddleDelta,edx        ;lMiddleDelta = lDelta + cjMiddle

        mov     ebx,ppdev
        mov     eax,MasterBlockTable[esi*4]
        mov     pfnCopyBlocks,eax       ;copy blocks between video memory

; Branch to the appropriate top-to-bottom bank enumeration loop:

        mov     eax,[ebx].pdev_vbtPlanarType
        jmp     BottomToTopLoopTable[eax*4]

;=======================================================================;
;============================= Banking =================================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_1RW
top_to_bottom_1RW::

; LATER: Should check to see if there's any chance that the source and
;     destination overlap in the same window, so that we can use planar
;     copies -- otherwise, it's faster to directly call of to
;     bPuntScreenToScreenCopyBits

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jl      short top_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jl      short top_1RW_init_bank_mapped

top_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

top_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yBottom

        jl      short top_1RW_do_planar_copy

; ulCurrentSrcScan >= ppdev->rcl1PlanarClip.bottom, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan
        mov     rclDest.yTop,edi        ;rclDest.top = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yBottom
        mov     eax,ulLastDestScan
        sub     eax,esi
        sbb     ecx,ecx
        and     ecx,eax
        add     esi,ecx
        mov     rclDest.yBottom,esi     ;rclDest.bottom = min(ulLastDestScan,
                                        ;  ppdev->pdev_rcl1PlanarClip.bottom)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.bottom

        sub     esi,edi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        add     ulCurrentSrcScan,esi    ;ulCurrentSrcScan += ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,esi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short top_1RW_see_if_done

top_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     ebx,[ebx].pdev_rcl1PlanarClip.yBottom
        sub     ebx,eax                 ;ebx = ppdev->rcl1PlanarClip.bottom -
                                        ;  ulCurrentSrcScan
                                        ;ebx is the available number of scans
                                        ;  we have in the source

        mov     edx,ulLastDestScan
        sub     edx,edi                 ;edx = ulLastDestScan - ulCurrentDestScan
                                        ;edx is the available number of scans
                                        ;  in the destination

; (Because the source starts lower in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     ebx,edx
        sbb     ecx,ecx
        and     ecx,ebx
        add     edx,ecx                 ;edx = min(source available,
                                        ;  destination available)
        mov     ulBlockHeight,edx

        add     eax,edx                 ;We have to adjust our current scans
        add     edi,edx
        mov     ulCurrentSrcScan,eax
        mov     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

top_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>

        jmp     top_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1 R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan  - Actually, 1 more current source scan
;       ulCurrentDestScan - Actually, 1 more current destination scan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_1RW
bottom_to_top_1RW::

; We're going top to bottom. Map in the source and dest, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yTop
        jle     short bot_1RW_map_init_bank

        cmp     edi,[ebx].pdev_rcl1PlanarClip.yBottom
        jle     short bot_1RW_init_bank_mapped

bot_1RW_map_init_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

bot_1RW_init_bank_mapped:

        mov     eax,ulCurrentSrcScan
        cmp     eax,[ebx].pdev_rcl1PlanarClip.yTop

        jg      short bot_1RW_do_planar_copy

; ulCurrentSrcScan <= ppdev->rcl1PlanarClip.top, which means that
; the window can't overlap the source and destination at all.  We'll
; have to use an intermediate temporary buffer:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        mov     esi,[ebx].pdev_rcl1PlanarClip.yTop
        mov     edx,ulLastDestScan
        cmp     esi,edx
        jg      @F
        mov     esi,edx
@@:
        mov     rclDest.yTop,esi        ;rclDest.top = max(ulLastDestScan,
                                        ;  ppdev->rcl1PlanarClip.top)

        mov     rclDest.yBottom,edi     ;rclDest.bottom = ulCurrentDestScan
        add     eax,esi
        sub     eax,edi
        mov     ptlSrc.ptl_y,eax        ;ptlSrc.y = ulCurrentSrcScan -
                                        ;  (rclDest.bottom - rclDest.top)

; Enable bit mask for all bits:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(0ffh shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Enable writes to all planes and reset direction flag:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

        pushfd
        cld

; Call our routine that copies bits the slow way, preserving EBX, ESI and EDI
; according to C calling conventions:

        lea     ecx,rclDest
        lea     edx,ptlSrc

        cCall   bPuntScreenToScreenCopyBits,<ebx,0,0,ecx,edx>

        popfd

; Set the bit mask to disable all bits, so we can copy through latches again:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(000h shl 8) + GRAF_BIT_MASK
        out     dx,ax

; Update our position variables:

        mov     ulCurrentDestScan,esi   ;ulCurrentDestScan = rclDest.top

        sub     edi,esi                 ;ulBlockHeight = rclDest.bottom -
                                        ;  rclDest.top

        sub     ulCurrentSrcScan,edi    ;ulCurrentSrcScan -= ulBlockHeight

; We have to adjust the offsets for all our block copiers, according to the
; number of scans we copied:

        mov     edx,lDelta
        imul    edx,edi                 ;edx = lDelta * ulBlockHeight
        add     ulLeftSrc,edx
        add     ulLeftDest,edx
        add     ulMiddleSrc,edx
        add     ulMiddleDest,edx
        add     ulRightSrc,edx
        add     ulRightDest,edx

        jmp     short bot_1RW_see_if_done

bot_1RW_do_planar_copy:

; ebx = ppdev
; eax = ulCurrentSrcScan
; edi = ulCurrentDestScan

        sub     eax,[ebx].pdev_rcl1PlanarClip.yTop
                                        ;eax = ulCurrentSrcScan -
                                        ;  ppdev->rcl1PlanarClip.top

        sub     edi,ulLastDestScan      ;edi = ulCurrentDestScan - ulLastDestScan
                                        ;edi is the available number of scans
                                        ;  in the destination


; (Because the source starts higher in the window than the destination,
; the bottom of the bank always limits the source number of scans before
; it does the destination.)

        sub     eax,edi
        sbb     ecx,ecx
        and     ecx,eax
        add     edi,ecx                 ;edi = min(source available,
                                        ;  destination available)

        mov     ulBlockHeight,edi

        sub     ulCurrentSrcScan,edi    ;We have to adjust our current scans
        sub     ulCurrentDestScan,edi

; Now copy the puppy:

        call    pfnCopyBlocks

; See if we're done:

bot_1RW_see_if_done:
        mov     edi,ulCurrentDestScan
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl>, \
                <ebx,edi,JustifyTop>
        inc     edi

        jmp     bot_1RW_init_bank_mapped

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, top to bottom.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  top_to_bottom_2RW
top_to_bottom_2RW::

; We're going top to bottom. Map in the destination, top-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan
        mov     esi,ulCurrentSrcScan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jl      short top_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_init_dest_bank_mapped

top_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

top_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jl      short top_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

top_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yBottom
        mov     edx,ulLastDestScan

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax                 ;edx = min(ulLastDestScan,
                                        ;  ppdev->rcl2PlanarClipD.bottom)

        mov     ecx,[ebx].pdev_rcl2PlanarClipS.yBottom

        sub     edx,edi                 ;edx = available scans in destination
                                        ;  bank
        sub     ecx,esi                 ;ecx = available scans in source bank

        sub     ecx,edx
        sbb     eax,eax
        and     eax,ecx
        add     edx,eax

        mov     ulBlockHeight,edx       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        add     esi,edx                 ;adjust our currents scans accordingly
        add     edi,edx
        mov     ulCurrentSrcScan,esi
        mov     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jge     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jl      short top_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyTop,MapDestBank>

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jl      short top_2RW_main_loop

top_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyTop,MapSourceBank>

        jmp     short top_2RW_main_loop

;-----------------------------------------------------------------------;
; Banking for 1R/1W or 2R/W adapters, bottom to top.
;
; Input:
;       ulCurrentSrcScan
;       ulCurrentDestScan
;       ulLastDestScan
;       Plus some other stuff for split rasters and block copiers
;-----------------------------------------------------------------------;
        public  bottom_to_top_2RW
bottom_to_top_2RW::

; We're going bottom to top. Map in the destination, bottom-justified.

        mov     ebx,ppdev
        mov     edi,ulCurrentDestScan   ; 1 more than actual destination scan
        mov     esi,ulCurrentSrcScan    ; 1 more than actual source scan

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jle     short bot_2RW_map_init_dest_bank

        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yBottom
        jle     short bot_2RW_init_dest_bank_mapped

bot_2RW_map_init_dest_bank:

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

bot_2RW_init_dest_bank_mapped:

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jle     short bot_2RW_map_init_src_bank

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yBottom
        jle     short bot_2RW_main_loop

bot_2RW_map_init_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

bot_2RW_main_loop:
        mov     ecx,[ebx].pdev_rcl2PlanarClipD.yTop
        mov     edx,ulLastDestScan

        cmp     edx,ecx
        jg      @F
        mov     edx,ecx                 ;edx = max(ulLastDestScan,
@@:                                     ;  ppdev->rcl2PlanarClipD.top)

        sub     edi,edx                 ;edi = available scans in destination
                                        ;  bank
        sub     esi,[ebx].pdev_rcl2PlanarClipS.yTop
                                        ;esi = available scans in source bank

        sub     esi,edi
        sbb     eax,eax
        and     eax,esi
        add     edi,eax

        mov     ulBlockHeight,edi       ;ulBlockHeight = min(source available,
                                        ;  dest available)

        sub     ulCurrentSrcScan,edi    ;adjust our current scans
        sub     ulCurrentDestScan,edi

; Do the actual copy:

        call    pfnCopyBlocks

        mov     edi,ulCurrentDestScan   ;check if done
        cmp     edi,ulLastDestScan
        jle     all_done

        mov     ebx,ppdev

; We'll have to map a new source bank, destination bank, or both:

        mov     esi,ulCurrentSrcScan
        cmp     edi,[ebx].pdev_rcl2PlanarClipD.yTop
        jg      short bot_2RW_map_next_src_bank

; Map bank containing the top destination scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     edi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,edi,JustifyBottom,MapDestBank>
        inc     edi

        cmp     esi,[ebx].pdev_rcl2PlanarClipS.yTop
        jg      short bot_2RW_main_loop

bot_2RW_map_next_src_bank:

; Map bank containing the top source scan line into window.
; Note: EBX, ESI, and EDI preserved, according to C calling conventions.

        dec     esi
        ptrCall <dword ptr [ebx].pdev_pfnPlanarControl2>, \
                <ebx,esi,JustifyBottom,MapSourceBank>
        inc     esi

        jmp     short bot_2RW_main_loop

;=======================================================================;
;=========================== Block Copiers =============================;
;=======================================================================;

;-----------------------------------------------------------------------;
; Input:
;       Direction flag  - set to the appropriate direction
;       ulMiddleSrc     - offset in bitmap to source
;       ulMiddleDest    - offset in bitmap to destination
;       lMiddleDelta    - distance from end of current scan to start of next
;       ulBlockHeight   - # of scans to copy
;       cjMiddle        - # of planar bytes to copy on every scan
;
; Output:
;       Advances ulMiddleSrc and ulMiddleDest to next strip
;-----------------------------------------------------------------------;

        public  copy_middle_block
copy_middle_block::

; We only have to reset which planes are enabled if we do edges too:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     al,MM_ALL
        out     dx,al

copy_just_middle_block::

; Calculate full start addresses:

        mov     edi,ppdev
        mov     eax,cjMiddle
        mov     ebx,ulBlockHeight
        mov     edx,lMiddleDelta
        mov     esi,[edi].pdev_pvBitmapStart2WindowS
        mov     edi,[edi].pdev_pvBitmapStart2WindowD
        add     esi,ulMiddleSrc
        add     edi,ulMiddleDest

;  EAX = # of bytes to copy
;  EBX = count of unrolled loop iterations
;  EDX = offset from end of one scan's fill to start of next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

middle_loop:
        mov     ecx,eax
        rep     movsb
        add     esi,edx
        add     edi,edx

        dec     ebx
        jnz     middle_loop

; get ready for next time:

        mov     ecx,ppdev
        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulMiddleSrc,esi
        mov     ulMiddleDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulLeftSrc     - offset in bitmap to source
;       ulLeftDest    - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulLeftSrc and ulLeftDest to next strip
;-----------------------------------------------------------------------;

        public  copy_left_block
copy_left_block::

; Set left mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulLeftMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulLeftSrc
        add     edi,ulLeftDest

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

left_loop:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx

        dec     ebx
        jnz     left_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulLeftSrc,esi
        mov     ulLeftDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;
; Input:
;       ulRightSrc    - offset in bitmap to source
;       ulRightDest   - offset in bitmap to destination
;       lDelta        - distance from between planar scans
;       ulBlockHeight - # of scans to copy
;
; Output:
;       Advances ulRightSrc and ulRightDest to next strip
;-----------------------------------------------------------------------;

        public  copy_right_block
copy_right_block::

; Set right mask by disabling some planes:

        mov     edx,VGA_BASE + SEQ_DATA
        mov     eax,ulRightMask
        out     dx,al

; Calculate full start addresses:

        mov     ecx,ppdev
        mov     ebx,ulBlockHeight
        mov     edx,lDelta
        mov     esi,[ecx].pdev_pvBitmapStart2WindowS
        mov     edi,[ecx].pdev_pvBitmapStart2WindowD
        add     esi,ulRightSrc
        add     edi,ulRightDest

;  EBX = count of unrolled loop iterations
;  EDX = offset from one scan to next
;  ESI = source address from which to copy
;  EDI = target address to which to copy

right_loop:
        mov     al,[esi]
        mov     [edi],al
        add     esi,edx
        add     edi,edx

        dec     ebx
        jnz     right_loop

; get ready for next time:

        sub     esi,[ecx].pdev_pvBitmapStart2WindowS
        sub     edi,[ecx].pdev_pvBitmapStart2WindowD
        mov     ulRightSrc,esi
        mov     ulRightDest,edi

        PLAIN_RET

;-----------------------------------------------------------------------;

endProc vPlanarCopyBits

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\strips.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: strips.asm
;
; Routines used by line code to draw strips of pixels.
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

; Set LOOP_UNROLL_SHIFT to the log2 of the number of times you want loops in
; this module unrolled. For example, LOOP_UNROLL_SHIFT of 3 yields 2**3 = 8
; times unrolling. This is the only thing you need to change to control
; unrolling.

LOOP_UNROLL_SHIFT equ 1

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\egavga.inc
        include i386\strucs.inc
        include i386\driver.inc
        include i386\lines.inc
        .list

        .code

;--------------------------Private-Routine------------------------------;
; vStripSolid0
;
;   Draw lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid0,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initializing:

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd

        mov     eax,[esi].ST_lNextScan
        mov     [ebp],eax                       ;copy delta

        mov     eax,[esi].ST_chAndXor
        mov     bl,ah
        mov     bh,ah
        mov     ah,al

        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;       ax    = and mask
;       bx    = xor mask
;       ecx   = pixel count
;       dx    = temporary register
;       esi   = strip pointer
;       edi   = display pointer
;       ebp   = ends of strips pointer
;       [ebp] = delta

        mov     ecx,[esi]
        add     esi,4
        test    edi,1
        jnz     short sol0_unaligned_start

sol0_aligned_loop:
        sub     ecx,2
        jl      short sol0_strip_end_unaligned
        je      short sol0_strip_end_aligned
        mov     dx,[edi]
        and     edx,eax
        xor     edx,ebx
        mov     [edi],dx
        add     edi,2
        jmp     short sol0_aligned_loop

sol0_strip_end_aligned:
        mov     dx,[edi]
        and     edx,eax
        xor     edx,ebx
        mov     [edi],dx
        add     edi,2
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0_aligned_loop

sol0_strip_end_unaligned:
        mov     dl,[edi]                ;do last pixel
        and     dl,al
        xor     dl,bl
        mov     [edi],dl
        inc     edi
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0_all_done

        mov     ecx,[esi]               ;do first pixel of next strip
        add     esi,4

sol0_unaligned_start:
        mov     dl,[edi]
        and     dl,al
        xor     dl,bl
        mov     [edi],dl
        inc     edi
        dec     ecx
        jnz     short sol0_aligned_loop

; Have to be careful when there is only one pel in the strip and it starts
; on an unaligned address:

        add     edi,[ebp]
        cmp     esi,ebp
        jae     short sol0_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0_aligned_loop

sol0_all_done:
        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid0

endProc vStripSolid0

;--------------------------Private-Routine------------------------------;
; vStripSolid1
;
; Draws lines in the 2nd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid1,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                            ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol1_next_diagonal:
        mov     ebx,[esi]
        add     esi, 4

sol1_diagonal_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl

        add     edi,ecx
        dec     ebx
        jnz     short sol1_diagonal_loop

        sub     edi,ecx
        inc     edi
        cmp     esi,ebp
        jb      short sol1_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid1

endProc vStripSolid1

;--------------------------Private-Routine------------------------------;
; vStripSolid2
;
; Draws lines in the 3rd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid2,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                             ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol2_next_diagonal:
        mov     ebx,[esi]
        add     esi,4

sol2_diagonal_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl

        add     edi,ecx
        dec     ebx
        jnz     short sol2_diagonal_loop

        dec     edi
        cmp     esi,ebp
        jb      short sol2_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid2

endProc vStripSolid2

;--------------------------Private-Routine------------------------------;
; vStripSolid3
;
; Draws lines in the 4th half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolid3,12,<          \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol3_next_vertical:
        mov     ebx,[esi]
        add     esi,4

sol3_vertical_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl

        add     edi,ecx
        dec     ebx
        jnz     short sol3_vertical_loop

        inc     edi
        cmp     esi,ebp
        jb      short sol3_next_vertical

        pop     ebp
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolid3

endProc vStripSolid3

;--------------------------Private-Routine------------------------------;
; vStripStyled0
;
; Draws styled lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripStyled0,12,<         \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;lNextScan for screen
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

        mov     eax,[esi].ST_lNextScan
        mov     cjMajor,eax
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty0_output_loop  ;if working on a dash, start there
        jmp     short sty0_skip_loop    ;if working on a gap, start there

sty0_prepare_for_output:
        add     edi,ulNumPixels         ;adjust to do remainder of strip

        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx
        jz      short sty0_output_get_new_strip

sty0_output_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl                ;write pixel
        inc     edi                     ;move one pixel to right
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty0_prepare_for_skip

        dec     ebx
        jnz     short sty0_output_loop

sty0_output_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0_output_loop

sty0_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled0

sty0_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty0_skip_get_new_strip

sty0_skip_loop:
        add     edi,ebx                 ;assume we'll skip entire strip
        sub     ulNumPixels,ebx         ;  (we'll correct it if not)
        jle     short sty0_prepare_for_output

sty0_skip_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0_skip_loop

sty0_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled0

endProc vStripStyled0

;--------------------------Private-Routine------------------------------;
; vStripStyled123
;
; Draws styled lines in the 2nd, 3rd and 4th half-octants.
;
;-----------------------------------------------------------------------;

cProc   vStripStyled123,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;delta to go in major direction
        local   cjMinor:        dword ;delta to go in minor direction
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

; If in half-octant 3, cjMajor = cjDelta and cjMinor = 1
; If in half-octant 2, cjMajor = cjDelta + 1 and cjMinor = -1
; If in half-octant 1, cjMajor = cjDelta + 1 and cjMinor = -cjDelta

        mov     eax,[esi].ST_lNextScan
        mov     ebx,[esi].ST_flFlips
        test    ebx,FL_FLIP_HALF
        jz      short sty3_halfoctant_3

        inc     eax
        mov     cjMajor,eax
        mov     cjMinor,-1

        test    ebx,FL_FLIP_D
        jnz     short sty3_done_major_minor_comp

        neg     eax
        inc     eax
        mov     cjMinor,eax
        jmp     short sty3_done_major_minor_comp

sty3_halfoctant_3:
        mov     cjMajor,eax
        mov     cjMinor,1

sty3_done_major_minor_comp:
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty3_output_loop  ;if working on a dash, start there
        jmp     short sty3_skip_loop    ;if working on a gap, start there

sty3_prepare_for_output:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx                     ;adjust to do remainder of strip

        jz      short sty3_output_get_new_strip

sty3_output_loop:
        mov     dl,[edi]
        and     dl,al
        xor     dl,ah
        mov     [edi],dl                ;write pixel
        add     edi,cjMajor             ;move to next scan
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty3_prepare_for_skip

        dec     ebx
        jnz     short sty3_output_loop

sty3_output_get_new_strip:
        add     edi,cjMinor             ;move one pixel in minor direction
        cmp     esi,plStripEnd
        jae     short sty3_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3_output_loop

sty3_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled123

sty3_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty3_skip_get_new_strip

sty3_skip_loop:

; compute min(left in strip, left in style)

        sub     ulNumPixels,ebx         ;ulNumPixels = # style - # strip
        sbb     edx,edx
        and     edx,ulNumPixels
        add     ebx,edx                 ;ebx = min(pels left in strip,
                                        ;          pels left in style)

        mov     edx,cjMajor
        imul    edx,ebx
        add     edi,edx                 ;adjust our pointer

        cmp     ulNumPixels,0
        jle     sty3_prepare_for_output

sty3_skip_get_new_strip:
        add     edi,cjMinor             ;move one pixel in minor direction
        cmp     esi,plStripEnd
        jae     short sty3_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3_skip_loop

sty3_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyled123

endProc vStripStyled123

;--------------------------Private-Routine------------------------------;
; vStripSolidSet0
;
;   Draw lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet0,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

; Do some initializing:

        mov     esi, pStrips
        push    ebp
        mov     ebp, plStripEnd

        mov     eax,[esi].ST_lNextScan
        mov     [ebp],eax                       ;copy delta

        mov     eax,[esi].ST_chAndXor
        mov     bl,ah
        mov     bh,ah
        mov     ah,al

        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;       ax    = and mask
;       bx    = xor mask
;       ecx   = pixel count
;       dx    = temporary register
;       esi   = strip pointer
;       edi   = display pointer
;       ebp   = ends of strips pointer
;       [ebp] = delta

        mov     ecx,[esi]
        add     esi,4
        test    edi,1
        jnz     short sol0s_unaligned_start

sol0s_aligned_loop:
        sub     ecx,2
        jl      short sol0s_strip_end_unaligned
        je      short sol0s_strip_end_aligned
        mov     [edi],bx
        add     edi,2
        jmp     short sol0s_aligned_loop

sol0s_strip_end_aligned:
        mov     [edi],bx
        add     edi,2
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0s_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0s_aligned_loop

sol0s_strip_end_unaligned:
        mov     [edi],bl                ;do last pixel
        inc     edi
        add     edi,[ebp]               ;go to next scan

        cmp     esi,ebp
        jae     short sol0s_all_done

        mov     ecx,[esi]               ;do first pixel of next strip
        add     esi,4

sol0s_unaligned_start:
        mov     [edi],bl
        inc     edi
        dec     ecx
        jnz     short sol0s_aligned_loop

; Have to be careful when there is only one pel in the strip and it starts
; on an unaligned address:

        add     edi,[ebp]
        cmp     esi,ebp
        jae     short sol0s_all_done

        mov     ecx,[esi]
        add     esi,4
        jmp     short sol0s_aligned_loop

sol0s_all_done:
        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet0

endProc vStripSolidSet0

;--------------------------Private-Routine------------------------------;
; vStripSolidSet1
;
; Draws lines in the 2nd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet1,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                            ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol1s_next_diagonal:
        mov     ebx,[esi]
        add     esi, 4

sol1s_diagonal_loop:
        mov     [edi],ah

        add     edi,ecx
        dec     ebx
        jnz     short sol1s_diagonal_loop

        sub     edi,ecx
        inc     edi
        cmp     esi,ebp
        jb      short sol1s_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet1

endProc vStripSolidSet1

;--------------------------Private-Routine------------------------------;
; vStripSolidSet2
;
; Draws lines in the 3rd half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet2,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        inc     ecx                             ; Make delta advance 1 to right
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol2s_next_diagonal:
        mov     ebx,[esi]
        add     esi,4

sol2s_diagonal_loop:
        mov     [edi],ah

        add     edi,ecx
        dec     ebx
        jnz     short sol2s_diagonal_loop

        dec     edi
        cmp     esi,ebp
        jb      short sol2s_next_diagonal

        pop     ebp
        mov     esi, pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet2

endProc vStripSolidSet2

;--------------------------Private-Routine------------------------------;
; vStripSolidSet3
;
; Draws lines in the 4th half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripSolidSet3,12,<       \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        mov     esi,pStrips
        push    ebp
        mov     ebp,plStripEnd
        mov     ecx,[esi].ST_lNextScan
        mov     eax,[esi].ST_chAndXor
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

;                   al  = and mask
;                   ah  = xor mask
;                   ebx = pixel count
;                   ecx = delta
;                   dl  = temporary register
;                   esi = strip pointer
;                   edi = memory pointer
;                   ebp = end of strips pointer

sol3s_next_vertical:
        mov     ebx,[esi]
        add     esi,4

sol3s_vertical_loop:
        mov     [edi],ah

        add     edi,ecx
        dec     ebx
        jnz     short sol3s_vertical_loop

        inc     edi
        cmp     esi,ebp
        jb      short sol3s_next_vertical

        pop     ebp
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        cRet    vStripSolidSet3

endProc vStripSolidSet3

;--------------------------Private-Routine------------------------------;
; vStripStyledSet0
;
; Draws styled lines in the 1st half-octant.
;
;-----------------------------------------------------------------------;

cProc   vStripStyledSet0,12,<      \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;lNextScan for screen
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

        mov     eax,[esi].ST_lNextScan
        mov     cjMajor,eax
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty0s_output_loop ;if working on a dash, start there
        jmp     short sty0s_skip_loop   ;if working on a gap, start there

sty0s_prepare_for_output:
        add     edi,ulNumPixels         ;adjust to do remainder of strip

        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx                     ;see if we also need a new strip
        jz      short sty0s_output_get_new_strip

sty0s_output_loop:
        mov     [edi],ah                ;write pixel
        inc     edi                     ;move one pixel to right
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty0s_prepare_for_skip

        dec     ebx
        jnz     short sty0s_output_loop

sty0s_output_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0s_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0s_output_loop

sty0s_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet0

sty0s_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty0s_skip_get_new_strip

sty0s_skip_loop:
        add     edi,ebx                 ;assume we'll skip entire strip
        sub     ulNumPixels,ebx         ;  (we'll correct it if not)
        jle     short sty0s_prepare_for_output

sty0s_skip_get_new_strip:
        add     edi,cjMajor             ;move up one scan
        cmp     esi,plStripEnd
        jae     short sty0s_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty0s_skip_loop

sty0s_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet0

endProc vStripStyledSet0

;--------------------------Private-Routine------------------------------;
; vStripStyledSet123
;
; Draws styled lines in the 2nd, 3rd and 4th half-octants.
;
;-----------------------------------------------------------------------;

cProc   vStripStyledSet123,12,<    \
        uses        esi edi ebx,   \
        pStrips:    ptr STRIPS,    \
        pls:        ptr LINESTATE, \
        plStripEnd: ptr >

        local   ulNumPixels:    dword ;# of pixels in current style
        local   pspEnd:         dword ;pointer to end of style array
        local   cjMajor:        dword ;delta to go in major direction
        local   cjMinor:        dword ;delta to go in minor direction
        local   cjStyleDelta:   dword ;delta from end of style array to start

; al  = and mask
; ah  = xor mask
; ebx = # of pixels in current strip
; ecx = style pointer
; edx = temporary register
; esi = strips pointer
; edi = memory pointer

        mov     esi,pStrips

; If in half-octant 3, cjMajor = cjDelta and cjMinor = 1
; If in half-octant 2, cjMajor = cjDelta + 1 and cjMinor = -1
; If in half-octant 1, cjMajor = cjDelta + 1 and cjMinor = -cjDelta

        mov     eax,[esi].ST_lNextScan
        mov     ebx,[esi].ST_flFlips
        test    ebx,FL_FLIP_HALF
        jz      short sty3s_halfoctant_3

        inc     eax
        mov     cjMajor,eax
        mov     cjMinor,-1

        test    ebx,FL_FLIP_D
        jnz     short sty3s_done_major_minor_comp

        neg     eax
        inc     eax
        mov     cjMinor,eax
        jmp     short sty3s_done_major_minor_comp

sty3s_halfoctant_3:
        mov     cjMajor,eax
        mov     cjMinor,1

sty3s_done_major_minor_comp:
        mov     eax,[esi].ST_pspEnd
        mov     pspEnd,eax
        mov     ebx,[esi].ST_pspStart
        sub     ebx,eax                 ;compute cjStyleDelta
        sub     ebx,4                   ;make it exclusive
        mov     cjStyleDelta,ebx

        mov     edx,[esi].ST_spRemaining
        mov     ulNumPixels,edx
        mov     eax,[esi].ST_chAndXor
        mov     ecx,[esi].ST_psp
        mov     edx,[esi].ST_bIsGap
        mov     edi,[esi].ST_pjScreen
        add     esi,offset ST_alStrips

        mov     ebx,[esi]
        add     esi,4

        or      edx,edx
        jz      short sty3s_output_loop ;if working on a dash, start there
        jmp     short sty3s_skip_loop   ;if working on a gap, start there

sty3s_prepare_for_output:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        mov     ebx,ulNumPixels
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        neg     ebx                     ;adjust to do remainder of strip
        jz      short sty3s_output_get_new_strip

sty3s_output_loop:
        mov     [edi],ah                ;write pixel
        add     edi,cjMajor             ;move to next scan
        dec     ulNumPixels             ;might have to go to next style element
        jz      short sty3s_prepare_for_skip

        dec     ebx
        jnz     short sty3s_output_loop

sty3s_output_get_new_strip:
        add     edi,cjMinor             ;move in minor direction
        cmp     esi,plStripEnd
        jae     short sty3s_output_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3s_output_loop

sty3s_output_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0       ;we were working on a dash
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet123

sty3s_prepare_for_skip:
        add     ecx,4
        cmp     pspEnd,ecx              ;if (ecx == pspEnd + 4)
        sbb     edx,edx                 ;  then ecx = pspStart
        and     edx,cjStyleDelta
        add     ecx,edx

        dec     ebx
        push    eax
        mov     eax,[ecx]               ;get next style array element
        mov     ulNumPixels,eax
        pop     eax
        jz      short sty3s_skip_get_new_strip

sty3s_skip_loop:

; compute min(left in strip, left in style)

        sub     ulNumPixels,ebx         ;ulNumPixels = # style - # strip
        sbb     edx,edx
        and     edx,ulNumPixels
        add     ebx,edx                 ;ebx = min(pels left in strip,
                                        ;          pels left in style)

        mov     edx,cjMajor
        imul    edx,ebx
        add     edi,edx                 ;adjust our pointer

        cmp     ulNumPixels,0
        jle     sty3s_prepare_for_output

sty3s_skip_get_new_strip:
        add     edi,cjMinor             ;move in minor direction
        cmp     esi,plStripEnd
        jae     short sty3s_skip_all_done

        mov     ebx,[esi]               ;get next strip
        add     esi,4
        jmp     short sty3s_skip_loop

sty3s_skip_all_done:
        mov     esi,pStrips
        mov     [esi].ST_pjScreen,edi
        mov     [esi].ST_bIsGap,0ffh    ;we were working on a gap
        mov     edi,ulNumPixels
        mov     [esi].ST_spRemaining,edi
        mov     [esi].ST_psp,ecx
        cRet    vStripStyledSet123

endProc vStripStyledSet123

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\srccopy.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: srccopy.asm
;
; Copyright (c) 1993 Microsoft Corporation
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; VOID vSrcCopy8bpp(ppdev, psoSrc, prclDst, pptlSrc, lSrcDelta, pvSrcStart);
;
; Input:
;
;  ppdev      - screen pdev
;  psoSrc     - source surface
;  prcldest   - pointer to destination rectangle
;  pptlsrc    - pointer to source upper left corner
;  lSrcDelta  - offset from start of one scan to next in source
;  pvSrcStart - pointer to start of bitmap
;
; Performs 8bpp SRCCOPY memory-to-screen blts.
;
;-----------------------------------------------------------------------;
; NOTE: Assumes all rectangles have positive heights and widths. Will
; not work properly if this is not the case.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;

        .code

;-----------------------------------------------------------------------;

cProc   vSrcCopy8bpp,20,<       \
        uses esi edi ebx,       \
        ppdev:      ptr PDEV,   \
        prclDst:    ptr RECTL,  \
        pptlSrc:    ptr POINTL, \
        lSrcDelta:  dword,      \
        pvSrcStart: ptr         >

        local culMiddle:    dword ;# of dwords in middle
        local cyToGo:       dword ;# of scans to copy after the current bank
        local pfnLoopVector:ptr   ;vector to appropriate copying loop
        local pvSrc:        ptr   ;source pointer

        mov     esi,prclDst             ;esi = prclDest
        mov     ebx,ppdev               ;ebx = ppdev
        mov     edi,[esi].yTop

        cmp     edi,[ebx].pdev_rcl1WindowClip.yTop
        jl      short src8_map_init_bank

        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;edx = ppdev->rcl1WindowClip.bottom
        cmp     edi,edx
        jl      short src8_init_bank_mapped

src8_map_init_bank:
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,edi,JustifyTop>

        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom

src8_init_bank_mapped:
        mov     eax,[esi].yBottom
        sub     eax,edx
        mov     cyToGo,eax              ;eax = # scans to do after this bank
        sbb     ecx,ecx
        and     ecx,eax
        add     edx,ecx                 ;edx = min(prclDst->bottom,
                                        ;          ppdev->rcl1WindowClip.bottom)
        sub     edx,edi                 ;edx = # of scans to do in this bank

; ebx = ppdev
; edx = # of scans to do in this bank
; esi = prclDst

        mov     eax,[esi].xLeft
        add     eax,3
        and     eax,not 3               ;eax = xLeft aligned to next dword

        mov     edi,pptlSrc             ;edi = pptlSrc
        mov     ecx,lSrcDelta
        imul    ecx,[edi].ptl_y
        add     ecx,[edi].ptl_x
        add     ecx,eax
        sub     ecx,[esi].xLeft
        add     ecx,pvSrcStart
        mov     pvSrc,ecx               ;pvSrc = pptlSrc->y * lSrcDelta +
                                        ;        pptlSrc->x + dest alignment +
                                        ;        pvSrcStart

        mov     edi,[ebx].pdev_lNextScan
        imul    edi,[esi].yTop
        add     edi,eax
        add     edi,[ebx].pdev_pvBitmapStart
                                        ;edi = prclDst->top * ppdev->lNextScan +
                                        ; aligned left + ppdev->pvBitmapStart
                                        ; (the aligned destination address)

; eax = prclDst->left aligned to dword
; ebx = ppdev
; edx = # of scans to do in this bank
; esi = prclDst
; edi = destination address

        mov     ecx,[esi].xRight        ;esi = prclDst->right
        sub     ecx,eax                 ;ecx = length in bytes from first full
                                        ;      dword to last byte
        jl      short src8_one_dword    ;special case if the destination
                                        ; starts and ends in the same dword

        mov     eax,ecx
        and     ecx,not 3               ;ecx = length of middle dwords in bytes
        sub     eax,ecx                 ;eax = (right & 3)

        mov     esi,[esi].xLeft
        and     esi,3                   ;esi = (left & 3)
        shl     eax,2
        or      esi,eax                 ;esi = ((right & 3) << 2) | (left & 3)
                                        ; (look-up index for loop vectors)

        mov     ebx,[ebx].pdev_lNextScan
        sub     ebx,ecx                 ;ebx = ppdev->lNextScan
                                        ; - (culMiddle << 2)
                                        ; (destination delta)

        mov     eax,lSrcDelta
        sub     eax,ecx                 ;eax = lSrcDelta - (culMiddle << 2)
                                        ; (source delta)

        shr     ecx,2
        mov     culMiddle,ecx           ;culMiddle = number of middle dwords

; eax = source delta
; ebx = destination delta
; ecx =
; edx = # scans to do
; esi = flags
; edi = destination pointer

; Set up for loop entry

        mov     ecx,gapfnMasterCopyTable[esi*4] ;every loop vector is a dword
        mov     esi,pvSrc
        mov     pfnLoopVector,ecx       ;save loop vector for next bank
        jmp     ecx

;-----------------------------------------------------------------------;
; Here we handle cases where copy starts and ends in same dword:

        public  src8_one_dword
src8_one_dword::
        sub     eax,[esi].xLeft         ;eax = # of bytes from left edge to
                                        ; first dword
        add     ecx,eax                 ;ecx = # of bytes to do

        sub     edi,eax                 ;adjust back to start byte
        sub     pvSrc,eax               ;adjust accordingly

        mov     ebx,[ebx].pdev_lNextScan;ebx = ppdev->lNextScan
                                        ; (destination delta)

        mov     eax,lSrcDelta           ;eax = lSrcDelta
                                        ; (source delta)

; eax = source delta
; ebx = destination delta
; esi =
; edx = # scans to do
; ecx = flags
; edi = destination pointer

; Set up for loop entry

        dec     ecx                     ;adjust for table (no zero entry)
        mov     ecx,gapfnOneDwordCopyTable[ecx*4]
        mov     esi,pvSrc
        mov     pfnLoopVector,ecx       ;save loop vector for next bank
        jmp     ecx

;-----------------------------------------------------------------------;
; We have following variables set before calling loops:
;
;   eax = source delta (from end of dwords to start of dwords on next scan)
;   ebx = destination delta
;   edx = # of scans
;   esi = source pointer
;   edi = destination pointer
;   culMiddle = number of dwords to copy

;-----------------------------------------------------------------------;
; See if done.  If not, get next bank.

        public  src8_done
src8_done::
        cmp     cyToGo,0
        jg      short src8_next_bank
        cRet    vSrcCopy8bpp

src8_next_bank:
        push    esi
        push    ebx                     ;save some registers
        mov     ebx,ppdev
        push    eax

        mov     esi,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edi,[ebx].pdev_pvBitmapStart

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>, \
                <ebx,esi,JustifyTop>

        add     edi,[ebx].pdev_pvBitmapStart
        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
        sub     edx,esi                 ;edx = # scans can do in this bank

        mov     eax,cyToGo
        sub     eax,edx
        mov     cyToGo,eax              ;eax = # scans to do after this bank
        sbb     ecx,ecx
        and     ecx,eax
        add     edx,ecx                 ;edx = min(# of scans can do in bank,
                                        ;          # of scans to go)
        pop     eax                     ;restore those registers
        pop     ebx
        pop     esi

        jmp     pfnLoopVector

;-----------------------------------------------------------------------;
; We organize the tables as follows so that it's easy to index into them:
;
;   Bits 2 and 3 = # of trailing bytes
;   Bits 0 and 1 = # of leading bytes to skip in first dword

        align   4
gapfnMasterCopyTable label dword
        dd      copy_wide_w_00_loop
        dd      copy_wide_w_30_loop
        dd      copy_wide_w_20_loop
        dd      copy_wide_w_10_loop
        dd      copy_wide_w_01_loop
        dd      copy_wide_w_31_loop
        dd      copy_wide_w_21_loop
        dd      copy_wide_w_11_loop
        dd      copy_wide_w_02_loop
        dd      copy_wide_w_32_loop
        dd      copy_wide_w_22_loop
        dd      copy_wide_w_12_loop
        dd      copy_wide_w_03_loop
        dd      copy_wide_w_33_loop
        dd      copy_wide_w_23_loop
        dd      copy_wide_w_13_loop

        align   4
gapfnOneDwordCopyTable label dword
        dd      copy_thin_t_1_loop
        dd      copy_thin_t_2_loop
        dd      copy_thin_t_3_loop

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_00_loop::
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_00_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_01_loop::
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_01_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_02_loop::
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_02_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 0 leading bytes, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_03_loop::
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_03_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_10_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_10_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_11_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_11_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_12_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_12_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 1 leading byte, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_13_loop::
        mov     cl,[esi-1]
        mov     [edi-1],cl
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_13_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_20_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_20_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_21_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_21_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_22_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_22_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 2 leading bytes, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_23_loop::
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_23_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 0 trailing bytes, then advance to next
; scan line.

copy_wide_w_30_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_30_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 1 trailing bytes, then advance to next
; scan line.

copy_wide_w_31_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_31_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 2 trailing bytes, then advance to next
; scan line.

copy_wide_w_32_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_32_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy n dwords, 3 leading bytes, 3 trailing bytes, then advance to next
; scan line.

copy_wide_w_33_loop::
        mov     cl,[esi-3]
        mov     [edi-3],cl
        mov     cx,[esi-2]
        mov     [edi-2],cx
        mov     ecx,culMiddle
        rep     movsd
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_wide_w_33_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy 1 byte, then advance to next scan line.

copy_thin_t_1_loop::
        mov     cl,[esi]
        mov     [edi],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_thin_t_1_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy 2 bytes, then advance to next scan line.

copy_thin_t_2_loop::
        mov     cx,[esi]
        mov     [edi],cx
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_thin_t_2_loop
        jmp     src8_done

;-----------------------------------------------------------------------;
; Copy 3 bytes, then advance to next scan line.

copy_thin_t_3_loop::
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        mov     [edi+2],cl
        add     esi,eax
        add     edi,ebx

        dec     edx
        jnz     copy_thin_t_3_loop
        jmp     src8_done

public copy_wide_w_00_loop
public copy_wide_w_01_loop
public copy_wide_w_02_loop
public copy_wide_w_03_loop
public copy_wide_w_10_loop
public copy_wide_w_11_loop
public copy_wide_w_12_loop
public copy_wide_w_13_loop
public copy_wide_w_20_loop
public copy_wide_w_21_loop
public copy_wide_w_22_loop
public copy_wide_w_23_loop
public copy_wide_w_30_loop
public copy_wide_w_31_loop
public copy_wide_w_32_loop
public copy_wide_w_33_loop
public copy_thin_t_1_loop
public copy_thin_t_2_loop
public copy_thin_t_3_loop

endProc vSrcCopy8bpp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\ropdefs.inc ===
;----------------------------Module-Header------------------------------;
; Module Name: ROPDEFS.BLT
;
; Constants relating to raster operation definitions.
;
; Copyright (c) 1988 - 1992  Microsoft Corporation
;
; These constants are used mainly in the file ROPTABLE.BLT, in which
; the raster operation code templates are defined.
;
; This file is part of a set that makes up the Windows BitBLT function
; at driver-level.
;-----------------------------------------------------------------------;

        subttl  Raster Operation Definitions
        page


if 0                                    ; Not passed to us anymore !!!

;       Raster Op Definitions
;
;
;       The include file COMMENT.BLT contains a good description
;       of the encoding of the raster operations.  It should be
;       read before examining the definitions that follow.
;
;       The sixteen-bit number indicating which raster Op is to be
;       performed is encoded in the following manner:


EPS_OFF =       0000000000000011b       ;Offset within parse string
EPS_INDEX =     0000000000011100b       ;Parse string index
LogPar  =       0000000000100000b       ;(1 indicates implied NOT as Logop6)
LogOp1  =       0000000011000000b       ;Logical Operation #1
LogOp2  =       0000001100000000b       ;Logical Operation #2
LogOp3  =       0000110000000000b       ;Logical Operation #3
LogOp4  =       0011000000000000b       ;Logical Operation #4
LogOp5  =       1100000000000000b       ;Logical Operation #5


;       The parity bit is used to encode an optional sixth logical operation
;       which will always be a "NOT".  In most cases this is used to get an
;       even number of "NOT"s so that reduction can take place (two sequential
;       trailing "NOT"s cancel each other out and thus are eliminated).



;       Each LogOp (Logical Operation) is encoded as follows:

LogNOT  =       00b                     ;NOT result
LogXOR  =       01b                     ;XOR result with next operand
LogOR   =       10b                     ;OR  result with next operand
LogAND  =       11b                     ;AND result with next operand



;       The parse string is a string which contains the operands for
;       the logical operation sequences (source, destination, pattern).
;       The logic opcodes are applied to the current result and the next
;       element of the given string (unless the LogOp is a NOT which only
;       affects the result).
;
;       The string is encoded as eight two-bit numbers indicating which
;       operand is to be used

opDefs          struc
  OpSpec        db      ?                 ;Special Operand as noted below
  OpSrc         db      ?                 ;Operand is source field
  OpDest        db      ?                 ;Operand is destination field
  OpPat         db      ?                 ;Operand is pattern field
opDefs          ends



;       The special operand is used for a few rops that would not fit into
;       an RPN format.  On the first occurance of an OpSpec, the current result
;       is "PUSHED", and the next operand is loaded.  On the second occurance
;       of the OpSpec, the given logic operation is performed between the
;       current result and the "PUSHED" value.
;
;       **NOTE**  Since there can be no guarantee that the client will call
;       the BLT routine with one of the 256 published raster ops, it is
;       possible that a value might be "PUSHED" and then never "POPPED".
;       If these "PUSHES" are made to the stack, then care must be made to
;       remove the "PUSHED" value.
;
;       In any case, since the raster op was not one of the published
;       "magic numbers", the BLT can be aborted or the result can be
;       computed to the extent possible.  The only restriction is that it
;       must not crash the system (i.e. don't leave extra stuff on the stack).
;
;               Simply: Compute garbage, but don't crash!




;       Define the parse strings to be allocated later.
;
;       An example parse string for the pattern "SDPSDPSD" would be
;       "0110110110110110b"


parseStr0       =       07AAAh          ;src,pat,dest,dest,dest,dest,dest,dest
parseStr1       =       079E7h          ;src,pat,dest,src,pat,dest,src,pat
parseStr2       =       06DB6h          ;src,dest,pat,src,dest,pat,src,dest
parseStr3       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr4       =       0AAAAh          ;dest,dest,dest,dest,dest,dest,dest,dest
parseStr5       =       04725h          ;src,spec,src,pat,spec,dest,src,src
parseStr6       =       04739h          ;src,spec,src,pat,spec,pat,dest,src
parseStr7       =       04639h          ;src,spec,src,dest,spec,pat,dest,src



;       The following equates are for certain special functions that are
;       derived from the very first string (index of SpecParseStrIndex).
;
;       These strings will have their innerloops special cased for
;       speed enhancements (i.e MOVSx and STOSx for pattern copys and
;       white/black fill, and MOVSx for source copy if possible)

PAT_COPY        equ     0021h           ;P    - dest = Pattern
NOTPAT_COPY     equ     0001h           ;Pn   - dest = NOT Pattern
FILL_BLACK      equ     0042h           ;DDx  - dest = 0 (black)
FILL_WHITE      equ     0062h           ;DDxn - dest = 1
SOURCE_COPY     equ     0020h           ;S    - dest = source


        errnz   LogXOR-01b              ;These must hold true for above equates
        errnz   LogOp1-0000000011000000b
        errnz   LogPar-0000000000100000b
        errnz   parseStr0-7AAAh         ;  plus the string must be SPDD


SPEC_PARSE_STR_INDEX equ        0       ;Special cased strings index

endif

;       The raster operation table consists of a word for each of
;       the first 128 raster operations (00 through 7F).  The second
;       half of the raster operations (FF through 80) are the inverse
;       of the first half.
;
;       The table is encoded as follows:
;
;           N S P LLL OOOOOOOOOO
;           | | |  |      |
;           | | |  |      |_____  Offset of code from roptable.
;           | | |  |
;           | | |  |____________  Length index
;           | | |
;           | | |_______________  Pattern is present
;           | |
;           | |_________________  Source is present
;           |
;           |___________________  Generate trailing NOT
;
;
;       To map the ROPS 80h through FFh to 00h through 7Fh, take the
;       1's complement of the ROP, and invert 'N' above.
;
;
;       Notes:
;
;           1)  An offset of 0 is reserved for source copy.  This
;               was done to reduce the number of LLLs to 8, so that
;               the above encoding could fit into a 16-bit integer.
;
;
;           2)  LLL only allows a maximum of 8 different template sizes!
;               Actual length is at roptable+256+LLL.
;
;
;
;
;       ROP is the macro that generates the equates which will be
;       stored into the roptable as specified above.
;
;       Usage:
;
;           ROPDEF      Pattern,Number
;
;       Where
;
;           Pattern     Is the RPN definition of the raster operation.
;                       It is used as the label of the first byte of
;                       the template.  It also is used to determine
;                       is there is a (S)ource, (P)attern, and if the
;                       final result is to be (n)egated.
;
;           Number      is the boolean result of the raster operation
;                       based on a P=F0, S=CC, and D=AA.  These labels
;                       and indexes can be found in the file COMMENT.BLT
;
;                       Since there are many equivelent boolean expresions,
;                       some of the rops will not match the label given.
;                       The label is for reference only.  The final result
;                       is what counts.



ROPOffset       equ     0000001111111111b
ROPLength       equ     0001110000000000b
SOURCE_PRESENT  equ     0010000000000000b
PATTERN_PRESENT equ     0100000000000000b
NEGATE_NEEDED   equ     1000000000000000b


;       Define the eight template length indices.

ROPLen0         equ     0
ROPLen2         equ     1
ROPLen4         equ     2
ROPLen6         equ     3
ROPLen8         equ     4
ROPLen10        equ     5
ROPLen12        equ     6
ROPLen14        equ     7

; Binary raster ops
R2_BLACK            equ 1
R2_NOTMERGEPEN      equ 2
R2_MASKNOTPEN       equ 3
R2_NOTCOPYPEN       equ 4
R2_MASKPENNOT       equ 5
R2_NOT              equ 6
R2_XORPEN           equ 7
R2_NOTMASKPEN       equ 8
R2_MASKPEN          equ 9
R2_NOTXORPEN        equ 10
R2_NOP              equ 11
R2_MERGENOTPEN      equ 12
R2_COPYPEN          equ 13
R2_MERGEPENNOT      equ 14
R2_MERGEPEN         equ 15
R2_WHITE            equ 16
R2_LAST             equ 16



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\stretch8.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: stretch.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; INT vStretchBlt8bpp(PPDEV ppdev, PBYTE pSrc, LONG lSrcNext,
;                     PRECTL prclSrc, PRECTL prclDest, PRECTL prclDestClip,
;                     PULONG pulXlatVector)
; Input:
;
; Performs accelerated stretch blts from 8-bit DIBs to 256-color VGA
; display memory.
;-----------------------------------------------------------------------;
; Note: Does not handle source clipping.
;
; Note: Does not yet handle expansion, only shrinking.
;-----------------------------------------------------------------------;

        comment $

***

Note: in the noxlat loop, EBX isn't altered, so it could be used for
something else, like the scan line count. This isn't done currently
because the scan-line loop is shared by the xlat and noxlat cases, and
the xlat cases do alter EBX; separate loops would be needed in order
to perform this optimization.

        commend $

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;

        .code

;-----------------------------------------------------------------------;

cProc vStretchBlt8bpp,28,< \
 uses esi edi ebx,         \
 ppdev:ptr,                \
 pSrc:ptr,                 \
 lSrcNext:dword,           \
 prclSrc:ptr,              \
 prclDest:ptr,             \
 prclDestClip:ptr,         \
 pulXlatVector:dword       >

        local   pulDDAArray:dword       ;pointer to array of n and n+1
                                        ; values generated by DDA, used to
                                        ; advance across source
        local   ulXStretchCount:dword   ;# of pixels or pixel pair to copy to
                                        ; (pixel pairs except in narrow
                                        ; cases; doesn't include leading or
                                        ; trailing single pixels in pixel
                                        ; pair cases)
        local   ulDestNext:dword         ;offset from last dest pixel on one
                                        ; scan to first on next
        local   ulSrcMinNext:dword      ;offset from start of one source scan
                                        ; to start of next scan that's skipped
                                        ; to by minimum DDA advance (basically,
                                        ; skips over n scans when DDA advances
                                        ; either n or n+1 scans)
        local   lYErrorTerm:dword       ;current error term for the DDA in Y
        local   ulYAdjUp:dword          ;error term adjust up for advancing
                                        ; DDA in Y
        local   ulYAdjDown:dword        ;error term adjust down for advancing
                                        ; DDA in Y
        local   ulDstTopScan:dword         ;top scan of dest text rect in
                                        ; current bank
        local   ulDstBottomScan :dword     ;bottom scan line of dest rectangle
        local   ulScanCount:dword       ;# of scans to stretch in current
                                        ; bank
        local   pfnRowVector:dword      ;pointer to routine to be used to
                                        ; stretch each row
        local   pfnStretchFn:dword      ;pointer to routine to do a bank's
                                        ; worth of stretching
        local   ulSrcTopScan:dword      ;top scan line of source from which
                                        ; to copy (after clipping, if needed)
        local   ulYMinStep:dword        ;minimum # of scans to skip in source
                                        ; when advancing dest one scan
        local   lXDstRight:dword        ;right edge of dest area to which to
                                        ; stretch, accounting for clipping
        local   lXDstLeft:dword         ;left edge of dest area to which to
                                        ; stretch, accounting for clipping
        local   ulXAdjUp:dword          ;X error term adjust up
        local   ulXMinStep:dword        ;X minimum step per dest 1-pixel step
        local   ulXAdjDown:dword        ;X error term adjust down
        local   lXSrcRight:dword        ;right edge of source area from which
                                        ; to stretch, accounting for clipping
        local   lXSrcLeft:dword         ;left edge of source area from which to
                                        ; stretch, accounting for clipping
        local   pvBuf:dword             ;local copy of ppdev->pvTmpBuf ptr

;-----------------------------------------------------------------------;

        mov     esi,ppdev
        mov     edi,[esi].pdev_pvTmpBuf
        mov     pvBuf,edi

        mov     esi,prclSrc
        mov     edi,prclDest

        mov     eax,[esi].xRight
        mov     edx,[esi].xLeft
        mov     lXSrcLeft,edx
        sub     eax,edx         ;EAX = source width
        mov     ecx,[edi].xRight
        mov     lXDstRight,ecx
        mov     edx,[edi].xLeft
        mov     lXDstLeft,edx
        sub     ecx,edx         ;ECX = dest width

        cmp     eax,ecx         ;shrink or stretch in X?
        jge     short x_shrink  ;shrink
                                ;stretch
;@@@
DoneFailed::
        sub     eax,eax         ;@@@shouldn't have to return a value
        jmp     done

;The destination is narrower than the source
x_shrink::
        mov     pfnStretchFn,offset shrink_8bpp_loop

;-----------------------------------------------------------------------;
; Precalculate the DDA steps for X and store them in the temp buffer. We know
; these will fit in the temp buffer, because there are only, say, 2K steps
; max across the screen, and the temp buffer is guaranteed to be more than
; 2K*4 = 8K bytes long.
;
; At this point, EAX = source width, ECX = destination width
;-----------------------------------------------------------------------;

        sub     edx,edx         ;prepare for division
        div     ecx             ;SourceDeltaX / DestDeltaX
        mov     ulXMinStep,eax  ;EAX = minimum step in source for 1 dest step

        mov     esi,edx         ;set aside SourceDeltaX % DestDeltaX
        add     edx,edx         ;scale up ulXAdjUp by 2 so we can handle a
                                ; half-pixel advance
        mov     ulXAdjUp,edx    ;ulXAdjUp = (SourceDeltaX % DestDeltaX)*2

                                ;prestep source X coord and error term by 1/2
                                ; a destination pixel, so we pick the source
                                ; pixel that most closely matches the center
                                ; of each destination pixel

                                ;step by 1/2 the whole source pixel advance
                                ; per destination step
        shr     eax,1           ;minimum step/2
        jnc     short @F        ;odd
                                ;even
        add     esi,ecx         ;advance error term for 1/2 of the source
                                ; pixel we just split (by DestDeltaX)
@@:
        add     lXSrcLeft,eax   ;advance 1/2 minimum step in source
        add     ecx,ecx         ;scale up DestDeltaX by 2 so we can handle a
                                ; half-pixel advance
        mov     ulXAdjDown,ecx  ;ulXAdjDown = DestDeltaX*2

        sub     esi,ecx         ;initial error term = -(DestDeltaX*2) + 1/2
                                ; normal error term step (for 1/2 pixel dest
                                ; advance effect on error term; note that 1/2
                                ; effect on whole source pixels has already
                                ; been accounted for)

;-----------------------------------------------------------------------;
; Clip to the dest in X, if necessary.
;-----------------------------------------------------------------------;

        mov     ebx,prclDestClip
        and     ebx,ebx                 ;any clipping?
        jz      short x_clip_done       ;no, all set
        mov     eax,[ebx].xRight        ;right clip edge
        cmp     eax,lXDstRight          ;is the right edge clipped?
        jge     short check_x_left_clip ;no
                                        ;right edge is clipped
        mov     lXDstRight,eax          ;set the clipped right edge
check_x_left_clip:
        mov     eax,[ebx].xLeft         ;left clip edge
        cmp     eax,lXDstLeft           ;is the left edge clipped?
        jle     short check_x_not_fully_clipped ;no
                                        ;left edge is clipped
        mov     edx,lXDstLeft           ;get the unclipped dest left edge
        mov     lXDstLeft,eax           ;set the clipped dest left edge
                                        ;now figure out how many source pixels
                                        ; were clipped, and advance the error
                                        ; term appropriately
        sub     eax,edx                 ;# of dest pixels clipped
        mov     ecx,eax                 ;set aside # of dest pixels to skip
        mul     ulXAdjUp                ;# of adjust ups in the course of the
                                        ; skipped pixels
        add     esi,eax                 ;EDX:ESI = error term after skipping
        adc     edx,-1                  ;(the initial error term is negative;
                                        ; this stretches it to 64 bits)
        jnc     short check_x_not_fully_clipped ;didn't turn over even once
        mov     eax,esi                 ;EDX:EAX = error term after skipping
        div     ulXAdjDown              ;EAX = # of times to adjust down
                                        ; while skipping pixels, minus 1
        sub     edx,ulXAdjDown          ;do the last adjust down, to cross
                                        ; back into negative territory where
                                        ; the error term belongs
        mov     esi,edx                 ;error term at new, clipped dest left
                                        ; edge
        inc     eax                     ;count the last adjust down (# of times
                                        ; source error turned over while
                                        ; advancing to the clipped left edge)
        imul    ecx,ulXMinStep          ;# of whole pixels skipped in source
                                        ; while advancing to dest clip left
                                        ; edge
        add     eax,ecx                 ;total # of pixels skipped in source
                                        ; while advancing to dest clip left
                                        ; edge
        add     lXSrcLeft,eax           ;advance the source left edge to match
                                        ; advancing the destination left edge
                                        ; to the left edge of the clip
                                        ; rectangle
check_x_not_fully_clipped:
        mov     eax,lXDstLeft
        cmp     lXDstRight,eax          ;is the destination fully x-clipped?
        jle     done                    ;yes, nothing to draw
x_clip_done:

;-----------------------------------------------------------------------;
; Now actually generate the (possibly clipped) X DDA skip array
;
; At this point, ESI = X error term for left edge (accounting for any
; X clipping that has occurred)
;-----------------------------------------------------------------------;

        mov     eax,ulXMinStep
        mov     edi,pvBuf       ;we'll store the DDA steps in the temp
        mov     pulDDAArray,edi ; buffer

        mov     edx,ulXAdjUp
        mov     ebx,ulXAdjDown
        mov     ecx,lXDstRight
        sub     ecx,lXDstLeft   ;ECX = # of pixels per dest scan
        push    ecx             ;remember # of dest pixels across
        push    ebp             ;preserve stack frame pointer
        lea     ebp,[eax+1]     ;maximum step
                                ;***stack frame unavailable***
x_shrink_set_dda_loop::
        add     esi,edx         ;adjust the error term up
        jnc     short x_shrink_set_dda_min ;didn't turn over, so advance
                                           ; minimum step
x_shrink_set_dda_max::
        sub     esi,ebx         ;turned over; adjust error term back down
        mov     [edi],ebp       ;advance by maximum step
        add     edi,4           ;point to next DDA array storage location
        dec     ecx             ;count down steps
        jz      short x_shrink_set_dda_done ;no more steps
        add     esi,edx         ;adjust the error term up
        jc      x_shrink_set_dda_max ;did turn over, so advance maximum step
x_shrink_set_dda_min::
        mov     [edi],eax       ;advance by minimum step
        add     edi,4           ;point to next DDA array storage location
        dec     ecx             ;count down steps
        jnz     x_shrink_set_dda_loop
x_shrink_set_dda_done::
        mov     dword ptr [edi],0 ;mark the end of the DDA
        pop     ebp             ;restore stack frame pointer
                                ;***stack frame available***
        pop     ecx             ;retrieve # of dest pixels across

        mov     edi,prclDest
        cmp     pulXlatVector,0         ;translation?
        jz      short x_shrink_noxlat   ;no
                                        ;yes
        cmp     ecx,3           ;narrow case?
        ja      short @F        ;no
        mov     pfnRowVector,offset shrink_xlat_8bpp_narrow     ;narrow case
        mov     ulXStretchCount,ecx     ;do all dest pixels one at a time
        jmp     check_y_shrink
@@:                             ;not narrow case; figure out which wide case,
                                ; based on the need to perform as many word-
                                ; aligned writes to display memory as possible
        mov     edx,ecx
        test    [edi].xLeft,1   ;starting at an odd destination address?
        jnz     short x_shrink_xlat_leading ;yes, need leading pixel
        mov     pfnRowVector,offset shrink_xlat_8bpp_nl_nt
                                        ;assume no leading or trailing pixels
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jnc     short check_y_shrink  ;no leading or trailing pixels
        mov     pfnRowVector,offset shrink_xlat_8bpp_nl_t
                                        ;no leading pixel, is a trailing pixel
        jmp     short check_y_shrink
x_shrink_xlat_leading:                  ;there is a leading pixel
        mov     pfnRowVector,offset shrink_xlat_8bpp_l_nt
                                        ;assume no trailing pixel
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jc      short check_y_shrink  ;no trailing pixel
        mov     pfnRowVector,offset shrink_xlat_8bpp_l_t
                                        ;both leading and trailing pixels
        dec     edx                     ;we'll do one pixel pair in the form
                                        ; of the leading/trailing pixel pair
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jmp     short check_y_shrink

x_shrink_noxlat:                        ;no translation
        cmp     ecx,3           ;narrow case?
        ja      short @F        ;no
        mov     pfnRowVector,offset shrink_noxlat_8bpp_narrow   ;narrow case
        mov     ulXStretchCount,ecx     ;do all dest pixels one at a time
        jmp     short check_y_shrink
@@:                             ;not narrow case; figure out which wide case,
                                ; based on the need to perform as many word-
                                ; aligned writes to display memory as possible
        mov     edx,ecx
        test    [edi].xLeft,1   ;starting at an odd destination address?
        jnz     short x_shrink_noxlat_leading ;yes, need leading pixel
        mov     pfnRowVector,offset shrink_noxlat_8bpp_nl_nt
                                        ;assume no leading or trailing pixels
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jnc     short check_y_shrink  ;no leading or trailing pixels
        mov     pfnRowVector,offset shrink_noxlat_8bpp_nl_t
                                        ;no leading pixel, is a trailing pixel
        jmp     short check_y_shrink
x_shrink_noxlat_leading:                ;there is a leading pixel
        mov     pfnRowVector,offset shrink_noxlat_8bpp_l_nt
                                        ;assume no trailing pixel
        shr     edx,1                   ;destination width in pixel pairs
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw
        jc      short check_y_shrink  ;no trailing pixel
        mov     pfnRowVector,offset shrink_noxlat_8bpp_l_t
                                        ;both leading and trailing pixels
        dec     edx                     ;we'll do one pixel pair in the form
                                        ; of the leading/trailing pixel pair
        mov     ulXStretchCount,edx     ;count of pixel pairs to draw

check_y_shrink::

        mov     esi,edi                 ;ESI->prclDest
        mov     edi,prclSrc             ;EDI->prclSrc
        mov     eax,[edi].yBottom
        mov     ecx,[edi].yTop
        mov     ulSrcTopScan,ecx
        sub     eax,ecx                 ;EAX = source height
        mov     ecx,[esi].yBottom
        mov     ulDstBottomScan,ecx
        mov     edx,[esi].yTop
        mov     ulDstTopScan,edx
        sub     ecx,edx         ;ECX = dest height

        cmp     eax,ecx         ;shrink or stretch in Y?
        jge     short y_shrink  ;shrink
                                ;stretch
;@@@
        sub     eax,eax         ;@@@shouldn't have to return a value
        jmp     done

;The destination is shorter than the source; calculate the error term values
; for advancing through the source on a per-dest-scan-line basis.
y_shrink::
        sub     edx,edx         ;prepare for division
        div     ecx             ;SourceDeltaY/DestDeltaY
        mov     ulYMinStep,eax  ;EAX = minimum step in source for 1 dest step

        mov     ebx,edx         ;set aside SourceDeltaY % DestDeltaY
        add     edx,edx         ;scale up ulYAdjUp by 2 so we can handle a
                                ; half-pixel advance
        mov     ulYAdjUp,edx    ;ulYAdjUp = (SourceDeltaY % DestDeltaY)*2

        imul    lSrcNext        ;(minimum step * source scan width in bytes)
        mov     ulSrcMinNext,eax ; = minimum offset by which to advance from
                                 ; one scan to the next

                                ;prestep source X coord and error term by 1/2
                                ; a destination pixel, so we pick the source
                                ; pixel that most closely matches the center
                                ; of each destination pixel

                                ;step by 1/2 the whole source pixel advance
                                ; per destination step
        mov     eax,ulYMinStep  ;retrieve minimum step
        shr     eax,1           ;minimum step/2
        jnc     short @F        ;odd
                                ;even
        add     ebx,ecx         ;advance error term for 1/2 of the source
                                ; pixel we just split
@@:
        add     ulSrcTopScan,eax ;advance 1/2 minimum step in source

        add     ecx,ecx         ;scale up DestDeltaY by 2 so we can handle a
                                ; half-pixel advance
        mov     ulYAdjDown,ecx  ;ulYAdjDown = DestDeltaY*2

        sub     ebx,ecx         ;initial error term = -(DestDeltaY*2) + 1/2
                                ; normal error term step (for 1/2 pixel dest
                                ; advance effect on error term; note that 1/2
                                ; effect on whole source pixels has already
                                ; been accounted for)
        mov     lYErrorTerm,ebx

;-----------------------------------------------------------------------;
; Clip in Y, if necessary.
;-----------------------------------------------------------------------;

        mov     ebx,prclDestClip
        and     ebx,ebx                 ;any clipping?
        jz      short y_clip_done       ;no, all set
        mov     eax,[ebx].yBottom       ;yes, clipping
                                        ;see if the dest is clipped off the
                                        ; bottom
        cmp     ulDstBottomScan,eax     ;is the bottom clipped?
        jle     short check_y_top_clip  ;no, check the top
        mov     ulDstBottomScan,eax     ;yes, set the new bottom
check_y_top_clip:
                                        ;see if the dest is clipped off the
                                        ; top
        mov     eax,[ebx].yTop
        cmp     ulDstTopScan,eax        ;is the top clipped?
        jge     short check_y_not_fully_clipped ;no
                                        ;yes, so advance the top scan and the
                                        ; error term accordingly
        mov     ulDstTopScan,eax        ;top of clipped destination rectangle
        sub     eax,[esi].yTop          ;# of destination scans to skip
        mov     ecx,eax                 ;set aside # of dest scans to skip
        mul     ulYAdjUp                ;# of adjust ups in the course of the
                                        ; skipped scans
        add     eax,lYErrorTerm         ;EDX:EAX = error term after skipping
        adc     edx,-1                  ;(the initial error term is negative;
                                        ; this stretches it to 64 bits)
        jnc     short check_y_not_fully_clipped ;didn't turn over even once
        div     ulYAdjDown              ;EAX = # of times to adjust down
                                        ; while skipping scans, minus 1
        sub     edx,ulYAdjDown          ;do the last adjust down, to cross
                                        ; back into negative territory where
                                        ; the error term belongs
        mov     lYErrorTerm,edx         ;error term at new, clipped dest top
        inc     eax                     ;count the last adjust down (# of
                                        ; times source error has turned over)
        imul    ecx,ulYMinStep          ;# of whole steps in source while
                                        ; advancing to dest clip top
        add     eax,ecx                 ;total # of scans skipped in source
                                        ; while advancing to dest clip top
        add     ulSrcTopScan,eax        ;advance the source top edge to match
                                        ; advancing the destination top edge to
                                        ; the top of the clip rectangle
check_y_not_fully_clipped:
        mov     eax,ulDstTopScan
        cmp     ulDstBottomScan,eax        ;is the destination fully y-clipped?
        jle     done                    ;yes, nothing to draw
y_clip_done:

;-----------------------------------------------------------------------;
; Calculate the offset of the initial destination pixel.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,ulDstTopScan   ;top scan line of text
        mov     esi,[ebx].pdev_lDeltaScreen
        mul     esi
        mov     edi,lXDstLeft
        mov     ecx,lXDstRight
        sub     ecx,edi         ;dest width
        sub     esi,ecx         ;dest width - width of a dest scan to stretch
        mov     ulDestNext,esi  ;offset from end of one dest stretched
                                ; scan to start of next
        add     edi,eax

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan of the text, if it's not
; mapped in already.
;-----------------------------------------------------------------------;

        mov     eax,ulDstTopScan   ;top scan line of text
        cmp     eax,[ebx].pdev_rcl1WindowClip.yTop ;is text top less than
                                                   ; current bank?
        jl      short map_init_bank                ;yes, map in proper bank
        cmp     eax,[ebx].pdev_rcl1WindowClip.yBottom ;text top greater than
                                                      ; current bank?
        jl      short init_bank_mapped        ;no, proper bank already mapped
map_init_bank::

; Map in the bank containing the top scan line of the destination.
; Preserves EBX, ESI, and EDI.

        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>

init_bank_mapped::

        add     edi,[ebx].pdev_pvBitmapStart    ;initial destination address

;-----------------------------------------------------------------------;
; Calculate the offset of the initial source pixel.
;-----------------------------------------------------------------------;

        mov     esi,prclSrc
        mov     eax,lSrcNext
        imul    ulSrcTopScan
        mov     esi,lXSrcLeft
        add     esi,eax
        add     esi,pSrc

;-----------------------------------------------------------------------;
; Main loop for processing stretch blt in each bank.
;
; At start of loop, EBX->ppdev, ESI->current src, EDI->current dst
;-----------------------------------------------------------------------;

bank_loop::
        mov     edx,ulDstBottomScan        ;bottom of destination rectangle
        cmp     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; text rect or the bottom of the
                                        ; current bank?
        jl      short @F                ;text bottom comes first, so draw to
                                        ; that; this is the last bank in text
        mov     edx,[ebx].pdev_rcl1WindowClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
@@:
        sub     edx,ulDstTopScan           ;# of scans to draw in bank
        mov     ulScanCount,edx

        call    pfnStretchFn    ;stretch the bitmap block that's in this bank

;-----------------------------------------------------------------------;
; See if there are more banks to draw.
;-----------------------------------------------------------------------;

        mov     ebx,ppdev
        mov     eax,[ebx].pdev_rcl1WindowClip.yBottom ;is the text bottom in
        cmp     ulDstBottomScan,eax                   ; the current bank?
        jnle    short do_next_bank      ;no, map in the next bank and draw
        mov     eax,1                   ;success
                                        ;@@@shouldn't return a value
done::
        cRet    vStretchBlt8bpp         ;yes, so we're done

do_next_bank::
        mov     ulDstTopScan,eax
        sub     edi,[ebx].pdev_pvBitmapStart ;convert from address to offset
                                             ; within bitmap
        ptrCall <dword ptr [ebx].pdev_pfnBankControl>,<ebx,eax,JustifyTop>
                                             ;map in the bank (call preserves
                                             ; EBX, ESI, and EDI)
        add     edi,[ebx].pdev_pvBitmapStart ;convert from offset within bitmap
                                             ; to address (bitmap start just
                                             ; moved)
        jmp     bank_loop                    ;we're ready to draw to the new
                                             ; bank

;-----------------------------------------------------------------------;
; Shrink in X and Y, xlat or noxlat, 8-bpp source, VGA dest
;
; On entry: ESI->first source pixel to copy from
;           EDI->first dest pixel to copy to
;           pulXlatVector = pointer to color translation array (xlat cases
;                           only)
;           ulSrcMinNext = minimum offset from end of current source scan to
;                          start of next source scan to stretch
;           lSrcNext = offset from start of one source scan to start of next
;           ulDestNext = offset from end of current dest scan to start of
;                        next dest scan to stretch to
;           pfnRowVector = pointer to routine to call to stretch one scan
;           ulScanCount = # of scans to stretch
;           lYErrorTerm, ulYAdjUp, ulYAdjDown = Y DDA error term components
;
; On exit:  ESI->next source pixel to copy from
;           EDI->next dest pixel to copy to
;           lYErrorTerm advanced for next scan
;-----------------------------------------------------------------------;

shrink_8bpp_loop::
        sub     ebx,ebx         ;prepare EBX=0 for xlat-case row-drawing
                                ; routines
shrink_block_8bpp_loop::
        mov     edx,pulDDAArray ;point to array of skip values to use to scan
                                ; across the source
        mov     ecx,ulXStretchCount ;# of pixels or pixel pairs to copy to
        push    esi             ;preserve source pointer
        call    pfnRowVector    ;stretch/shrink this row
        pop     esi             ;restore source pointer
        add     esi,ulSrcMinNext ;point to start of next source row, assuming
                                 ; no extra row for error term turnover
        mov     eax,lYErrorTerm
        add     eax,ulYAdjUp    ;advance the error term
        jnc     short @F        ; didn't turn over (minimum step)
        sub     eax,ulYAdjDown  ;turned over, adjust down and...
        add     esi,lSrcNext    ; advance an extra scan (maximum step)
@@:
        mov     lYErrorTerm,eax ;remember the new error term
        add     edi,ulDestNext  ;point to start of next destination row
        dec     ulScanCount     ;count down scans
        jnz     shrink_block_8bpp_loop
        retn

;-----------------------------------------------------------------------;
; Single-row optimizations, called out of main stretch loops.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Shrink in X
; No xlat
; 8-bit source
; Writes a word at a time
;
; Input: ECX = number of pixel pairs to do, not counting leading and trailing
;              single pixels (except in narrow case, where ECX = number of
;              pixels, not pixel pairs)
;        EDX = pointer to pre-computed skip array
;        ESI = pointer to initial source pixel
;        EDI = pointer to initial destination pixel
;
; Output: ESI = pointer after last source pixel processed
;         EDI = pointer after last source pixel processed
;
; EBX and EBP are preserved
; The contents of EAX, ECX, and EDX may be destroyed
;-----------------------------------------------------------------------;

; No leading byte, no trailing byte.

shrink_noxlat_8bpp_nl_nt::
shrink_noxlat_8bpp_nl_nt_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_nl_nt_pixel_loop
        retn

; Leading byte, no trailing byte.

shrink_noxlat_8bpp_l_nt::
                                ;do the leading pixel
        mov     al,[esi]        ;get the current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_noxlat_8bpp_l_nt_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_l_nt_pixel_loop
        retn

; Leading byte, trailing byte.

shrink_noxlat_8bpp_l_t::
                                ;do the leading pixel
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_noxlat_8bpp_l_t_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_l_t_pixel_loop
                                ;do the trailing pixel
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        retn

; No leading byte, trailing byte.

shrink_noxlat_8bpp_nl_t::
shrink_noxlat_8bpp_nl_t_pixel_loop::
        mov     al,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     ah,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_noxlat_8bpp_nl_t_pixel_loop
                                ;do the trailing pixel
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        retn

; Narrow case, a byte at a time.

shrink_noxlat_8bpp_narrow::
shrink_noxlat_8bpp_narrow_pixel_loop::
        mov     al,[esi]        ;get current source pixel
        add     esi,[edx]       ;point to next source pixel
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        dec     ecx             ;count down pixels
        jnz     shrink_noxlat_8bpp_narrow_pixel_loop
        retn

;-----------------------------------------------------------------------;
; Shrink in X
; Xlat
; 8-bit source
; Writes a word at a time
;
; Input: EBX upper three bytes = zero (0)
;        ECX = number of pixel pairs to do, not counting leading and trailing
;              single pixels (except in narrow case, where ECX = number of
;              pixels, not pixel pairs)
;        EDX = pointer to pre-computed skip array
;        ESI = pointer to initial source pixel
;        EDI = pointer to initial destination pixel
;        pulXlatVector = pointer to color translation array
;
; Output: ESI = pointer after last source pixel processed
;         EDI = pointer after last source pixel processed
;
; EBP is preserved
; The upper three bytes of EBX are preserved
; The contents of EAX, BL, ECX, and EDX may be destroyed
;-----------------------------------------------------------------------;

; No leading byte, no trailing byte.

shrink_xlat_8bpp_nl_nt::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
shrink_xlat_8bpp_nl_nt_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_nl_nt_pixel_loop
        pop     ebp             ;***stack frame available***
        retn

; Leading byte, no trailing byte.

shrink_xlat_8bpp_l_nt::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
                                ;do the leading pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_xlat_8bpp_l_nt_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_l_nt_pixel_loop
        pop     ebp             ;***stack frame available***
        retn

; Leading byte, trailing byte.

shrink_xlat_8bpp_l_t::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
                                ;do the leading pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
                                ;now do pixel pairs across the middle
shrink_xlat_8bpp_l_t_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_l_t_pixel_loop
                                ;do the trailing pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        pop     ebp             ;***stack frame available***
        retn

; No leading byte, trailing byte.

shrink_xlat_8bpp_nl_t::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
shrink_xlat_8bpp_nl_t_pixel_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        mov     bl,[esi]        ;get second source pixel
        add     esi,[edx+4]     ;point to next source pixel
        mov     ah,[ebp+ebx*4]  ;translate the pixel color
        add     edx,8           ;point to next skip entry
        mov     [edi],ax        ;write both pixels to the destination
        add     edi,2           ;point to next destination pixel
        dec     ecx             ;count down pixel pairs
        jnz     shrink_xlat_8bpp_nl_t_pixel_loop
                                ;do the trailing pixel
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        pop     ebp             ;***stack frame available***
        retn
; Narrow case, a byte at a time.

shrink_xlat_8bpp_narrow::
        push    ebp             ;***stack frame not available***
        mov     ebp,pulXlatVector ;point EBP to the translation table
shrink_xlat_8bpp_narrow_loop::
        mov     bl,[esi]        ;get first source pixel
        add     esi,[edx]       ;point to next source pixel
        mov     eax,[ebp+ebx*4] ;translate the pixel color
        add     edx,4           ;point to next skip entry
        mov     [edi],al        ;write the pixel to the destination
        inc     edi             ;point to next destination pixel
        dec     ecx             ;count down pixels
        jnz     shrink_xlat_8bpp_narrow_loop
        pop     ebp             ;***stack frame available***
        retn

endProc vStretchBlt8bpp

public DoneFailed
public x_shrink
public check_y_shrink
public x_shrink_set_dda_loop
public x_shrink_set_dda_max
public x_shrink_set_dda_min
public x_shrink_set_dda_done
public y_shrink
public map_init_bank
public init_bank_mapped
public bank_loop
public done
public do_next_bank
public shrink_8bpp_loop
public shrink_block_8bpp_loop
public shrink_noxlat_8bpp_nl_nt
public shrink_noxlat_8bpp_nl_nt_pixel_loop
public shrink_noxlat_8bpp_l_nt
public shrink_noxlat_8bpp_l_nt_pixel_loop
public shrink_noxlat_8bpp_l_t
public shrink_noxlat_8bpp_l_t_pixel_loop
public shrink_noxlat_8bpp_nl_t
public shrink_noxlat_8bpp_nl_t_pixel_loop
public shrink_noxlat_8bpp_narrow
public shrink_noxlat_8bpp_narrow_pixel_loop
public shrink_xlat_8bpp_nl_nt
public shrink_xlat_8bpp_nl_nt_pixel_loop
public shrink_xlat_8bpp_l_nt
public shrink_xlat_8bpp_l_nt_pixel_loop
public shrink_xlat_8bpp_l_t
public shrink_xlat_8bpp_l_t_pixel_loop
public shrink_xlat_8bpp_nl_t
public shrink_xlat_8bpp_nl_t_pixel_loop
public shrink_xlat_8bpp_narrow
public shrink_xlat_8bpp_narrow_loop

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\vgablts.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgablts.asm
;
; Copyright (c) 1992-1993 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vTrgBlt(PDEV * ppdev, ULONG culRcl, RECTL * prcl, MIX ulMix,
;              ULONG ulClr, POINTL * pptlBrush)
; Input:
;  ppdev     - pointer to PDEV for surface to which to draw
;  culRcl    - # of rectangles to fill
;  prcl      - pointer to list of rectangles to fill
;  ulMix     - mix rop with which to fill
;  ulClr     - color with which to fill
;  pptlBrush - not used
;
; Performs accelerated solid area fills for all mixes.
;
;-----------------------------------------------------------------------;
;
; Note: Assumes all rectangles have positive heights and widths. Will not
; work properly if this is not the case.
;
;-----------------------------------------------------------------------;
;
; Note: Cases where the width of the whole bytes fill is equal to the
; width of the bitmap could be sped up by using a single REP MOVS or REP
; STOS, but how often does WIN32 do a fill that's the width of the screen?
; Not very.
;
;-----------------------------------------------------------------------;

        comment $

The overall approach of this module is to accept a list of rectangles to
fill, set up the VGA hardware for the desired fill, and then fill the
rectangles one at a time. Each rectangle fill is set up for everything
but vertical parameters, and then decomposed into the sections that
intersect each VGA bank; each section is drawn in turn. Vectors are set
up so that the drawing code appropriate for the desired fill is
essentially threaded together.

        commend $

;-----------------------------------------------------------------------;

                .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc
        include i386\ropdefs.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Left edge clip masks for intrabyte start addresses 0 through 3.
; Whole byte cases are flagged as 0ffh.
        public jLeftMask
jLeftMask       label   byte
        db      0ffh,0eh,0ch,08h

;-----------------------------------------------------------------------;
; Right edge clip masks for intrabyte end addresses (non-inclusive)
; 0 through 3. Whole byte cases are flagged as 0ffh.
        public jRightMask
jRightMask      label   byte
        db      0ffh,01h,03h,07h

;-----------------------------------------------------------------------;
; Tables used to set up for the desired raster op. Note that entries for raster
; ops that aren't handled here are generally correct, except that they ignore
; need for inversion of the destination, which those rops require.

; Table used to force off the drawing color for R2_BLACK (0).
; The first entry is ignored; there is no mix 0.
        public jForceOffTable
jForceOffTable  db         0
                db         000h,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh,0ffh
                db         0ffh,0ffh,000h,0ffh,0ffh,0ffh,0ffh,0ffh

;-----------------------------------------------------------------------;
; Table used to force on the drawing color for R2_NOT (Dn) and R2_WHITE (1).
; The first entry is ignored; there is no mix 0.
        public  jForceOnTable
jForceOnTable   db      0, 0,0,0,0,0,0ffh,0,0,0,0,0,0,0,0,0,0ffh

;-----------------------------------------------------------------------;
; Table used to invert the passed-in drawing color for Pn mixes.
; The first entry is ignored; there is no mix 0.
        public  jNotTable
jNotTable       db      0, 0,0ffh,0ffh,0ffh,0,0,0,0ffh,0,0ffh,0,0ffh,0,0,0,0

;-----------------------------------------------------------------------;
; Table of VGA ALU logical functions corresponding to mixes. Note that Dn is
; handled as a separate preceding inversion pass when part of a more complex
; mix.
; The first entry is ignored; there is no mix 0.
        public jALUFuncTable
jALUFuncTable   db      DR_SET
                db      DR_SET,DR_AND,DR_AND,DR_SET
                db      DR_AND,DR_XOR,DR_XOR,DR_OR
                db      DR_AND,DR_XOR,     0,DR_OR
                db      DR_SET,DR_OR ,DR_OR ,DR_SET

;-----------------------------------------------------------------------;
; 1 entries mark rops that require two passes, one to invert the destination
; and then another to finish the rop.
; The first entry is ignored; there is no mix 0.
        public  jInvertDest
jInvertDest     db      0, 0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0

;-----------------------------------------------------------------------;
; Table of routines to be called to draw edges, according to which edges are
; partial and which edges are whole bytes.
        align   4
pfnEdgeDrawing  label   dword
        dd      do_right_edge_bytes
        dd      do_both_edge_bytes
        dd      check_next_bank
        dd      do_left_edge_bytes

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find appropriate whole byte loops.

        align   4
pfnWideWholeRep label   dword
        dd      draw_wide_w_00_loop
        dd      draw_wide_w_01_loop
        dd      draw_wide_w_02_loop
        dd      draw_wide_w_03_loop
        dd      draw_wide_w_10_loop
        dd      draw_wide_w_11_loop
        dd      draw_wide_w_12_loop
        dd      draw_wide_w_13_loop
        dd      draw_wide_w_20_loop
        dd      draw_wide_w_21_loop
        dd      draw_wide_w_22_loop
        dd      draw_wide_w_23_loop
        dd      draw_wide_w_30_loop
        dd      draw_wide_w_31_loop
        dd      draw_wide_w_32_loop
        dd      draw_wide_w_33_loop

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find narrow, special-cased
; non-replace whole byte loops.

; Note: The breakpoint where one should switch from special-casing to
;  REP MOVSB is purely a guess on my part. 5 seemed reasonable.

        align   4
pfnWholeBytesNonReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_rw_loop
        dd      draw_2_wide_rw_loop
        dd      draw_3_wide_rw_loop
        dd      draw_4_wide_rw_loop
MAX_NON_REPLACE_SPECIAL equ     ($-pfnWholeBytesNonReplaceEntries)/4

;-----------------------------------------------------------------------;
; Table of pointers to tables used to find narrow, special-cased replace
; whole byte loops.

; Note: The breakpoint where one should switch from special-casing to
;  REP STOS is purely a guess on my part. 8 seemed reasonable.

; Start address MOD 3 is 0.
        align   4
pfnWholeBytesMod0ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_even_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_even_loop
        dd      draw_6_wide_w_mod3_0_loop
        dd      draw_7_wide_w_mod3_0_loop
        dd      draw_8_wide_w_mod3_0_loop
MAX_REPLACE_SPECIAL equ     ($-pfnWholeBytesMod0ReplaceEntries)/4

; Start address MOD 3 is 1.
        align   4
pfnWholeBytesMod1ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_odd_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_odd_loop
        dd      draw_6_wide_w_mod3_1_loop
        dd      draw_7_wide_w_mod3_1_loop
        dd      draw_8_wide_w_mod3_1_loop

; Start address MOD 3 is 2.
        align   4
pfnWholeBytesMod2ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_even_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_even_loop
        dd      draw_6_wide_w_mod3_2_loop
        dd      draw_7_wide_w_mod3_2_loop
        dd      draw_8_wide_w_mod3_2_loop

; Start address MOD 3 is 3.
        align   4
pfnWholeBytesMod3ReplaceEntries  label   dword
        dd      0                       ;we never get a 0-wide case
        dd      draw_1_wide_w_loop
        dd      draw_2_wide_w_loop
        dd      draw_3_wide_w_odd_loop
        dd      draw_4_wide_w_loop
        dd      draw_5_wide_w_odd_loop
        dd      draw_6_wide_w_mod3_1_loop
        dd      draw_7_wide_w_mod3_3_loop
        dd      draw_8_wide_w_mod3_3_loop

; Master MOD 3 alignment look-up table for entry tables for four possible
; alignments for narrow, special-cased replace whole byte loops.
        align   4
pfnWholeBytesReplaceMaster      label   dword
        dd      pfnWholeBytesMod0ReplaceEntries
        dd      pfnWholeBytesMod1ReplaceEntries
        dd      pfnWholeBytesMod2ReplaceEntries
        dd      pfnWholeBytesMod3ReplaceEntries

;-----------------------------------------------------------------------;

                .code

;-----------------------------------------------------------------------;

cProc   vTrgBlt,24,<         \
        uses    esi edi ebx, \
        ppdev:    ptr,       \
        culRcl:   dword,     \
        prcl:     ptr RECTL, \
        ulMix:    dword,     \
        ulColor:  dword,     \
        pptlBrsuh:ptr POINTL >

        local   ulRowOffset :dword      ;Offset from start of scan line of
                                        ; first byte to fill
        local   ulWholeBytes :dword     ;# of whole bytes to fill
        local   ulWholeDwords :dword    ;# of whole dwords to fill
        local   pfnWholeFn  :dword      ;pointer to routine used to draw
                                        ; whole bytes
        local   ulScanWidth :dword      ;offset from start of one scan to start
                                        ; of next
        local   ulNextScan  :dword      ;offset from end of one scan line's
                                        ; fill to start of next
        local   ulCurrentTopScan :dword ;top scan line to fill in current bank
        local   ulMasks     :dword      ;low byte = right mask, high byte =
                                        ; left mask
        local   ulBottomScan :dword     ;bottom scan line of fill rectangle
        local   jALUFunc   :dword       ;VGA ALU logical operation (SET, AND,
                                        ; OR, or XOR)
        local   pfnStartDrawing :dword  ;pointer to function to call to start
                                        ; drawing
        local   pfnContinueDrawing :dword ;pointer to function to call to
                                        ; continue drawing after doing whole
                                        ; bytes
        local   ulLeftEdgeAdjust :dword ;used to bump the whole bytes start
                                        ; address past the left edge when the
                                        ; left edge is partial
        local   pfnWholeBytes :dword    ;pointer to loop for whole byte filling
        local   jInvertDestFirst :dword ;1 if the rop requires a pass to invert
                                        ; the destination before the normal
                                        ; pass
        local   ulDrawingColor :dword   ;color byte with which to fill,
                                        ; replicated to a dword
        local   ppfnDrawEdgeTable :dword ;points to loop to be used to draw
                                         ; edge ; bytes (draw_1_wide_rw_loop
                                         ; or draw_1_wide_w_loop)

;-----------------------------------------------------------------------;
; CLD is assumed on entry.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Make sure there's something to draw; clip enumerations can be empty.
;-----------------------------------------------------------------------;

        cmp     culRcl,0                ;any rects to fill?
        jz      vTrgBlts_done           ;no, we're done


;-----------------------------------------------------------------------;
; Set up variables that are constant for the entire time we're in this
; module.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Set up for the desired raster op.
;-----------------------------------------------------------------------;

        sub     ebx,ebx                 ;ignore any background mix; we're only
        mov     bl,byte ptr ulMix       ; concerned with the foreground in this
                                        ; module
        cmp     ebx,R2_NOP              ;is this NOP?
        jz      vTrgBlts_done           ;yes, we're done
        mov     al,jInvertDest[ebx]          ;remember whether we need to
        mov     byte ptr jInvertDestFirst,al ; invert the destination before
                                             ; finishing the rop
        mov     ah,byte ptr ulColor     ;get the drawing color
        and     ah,jForceOffTable[ebx]  ;force color to 0 if necessary
                                        ; (R2_BLACK)
        or      ah,jForceOnTable[ebx]   ;force color to 0ffh if necessary
                                        ; (R2_WHITE, R2_NOT)
        xor     ah,jNotTable[ebx]       ;invert color if necessary (any Pn mix)
                                        ;at this point, CH has the color we
                                        ; want to draw with; set up the VGA
                                        ; hardware to draw with that color
        mov     al,ah                   ;replicate the drawing color to a dword
        mov     edx,eax
        shl     eax,16
        mov     ax,dx
        mov     ulDrawingColor,eax      ;remember drawing color

        mov     ppfnDrawEdgeTable,offset draw_1_wide_w_loop
                                        ;assume replace-type rop, so we can
                                        ; draw edge bytes with the write-
                                        ; without-read code pointed to by this
                                        ; table
        mov     ah,jALUFuncTable[ebx]   ;get the ALU logical function
        and     ah,ah                   ;is the logical function DR_SET?
        .errnz  DR_SET
        jz      short skip_ALU_set      ;yes, don't have to set because that's
                                        ; the VGA's default state
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function
        mov     ppfnDrawEdgeTable,offset draw_1_wide_rw_loop
                                        ;draw edge bytes with this loop
                                        ; (read/write)
skip_ALU_set:
        mov     byte ptr jALUFunc,ah    ;remember the ALU logical function

;-----------------------------------------------------------------------;
; Fill the current rectangle with the specified raster op and color.
;-----------------------------------------------------------------------;

fill_rect_loop:

;-----------------------------------------------------------------------;
; Set up variables that are constant from bank to bank during a single
; fill.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Set up masks and widths.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     eax,[edi].yBottom
        mov     ulBottomScan,eax        ;remember the bottom scan line of fill

        mov     ebx,[edi].xRight        ;right edge of fill (non-inclusive)
        mov     ecx,ebx
        and     ecx,011b                ;intrabyte address of right edge
        mov     ah,jRightMask[ecx]      ;right edge mask

        mov     esi,[edi].xLeft         ;left edge of fill (inclusive)
        mov     ecx,esi
        shr     ecx,2                   ;/4 for start offset from left edge
                                        ; of scan line
        mov     ulRowOffset,ecx         ;remember offset from start of scan
                                        ; line
        sub     ebx,esi                 ;width in pixels of fill

        and     esi,011b                ;intrabyte address of left edge
        mov     al,jLeftMask[esi]       ;left edge mask

        dec     ebx                     ;make inclusive on right
        add     ebx,esi                 ;inclusive width, starting counting at
                                        ; the beginning of the left edge byte
        shr     ebx,2                   ;width of fill in bytes touched - 1
        jnz     short more_than_1_byte  ;more than 1 byte is involved

; Only one byte will be affected. Combine first/last masks.

        and     al,ah                   ;we'll use first byte mask only
        xor     ah,ah                   ;want last byte mask to be 0
        inc     ebx                     ;so there's one count to subtract below
                                        ; if this isn't a whole edge byte
more_than_1_byte:

; If all pixels in the left edge are altered, combine the first byte into the
; whole byte count and clear the first byte mask, because we can handle solid
; edge bytes faster as part of the whole bytes. Ditto for the right edge.

        sub     ecx,ecx                 ;edge whole-status accumulator
        cmp     al,-1                   ;is left edge a whole byte or partial?
        adc     ecx,ecx                 ;ECX=1 if left edge partial, 0 if whole
        sub     ebx,ecx                 ;if left edge partial, deduct it from
                                        ; the whole bytes count
        mov     ulLeftEdgeAdjust,ecx    ;for skipping over the left edge if
                                        ; it's partial when pointing to the
                                        ; whole bytes
        and     ah,ah                   ;is right edge mask 0, meaning this
                                        ; fill is only 1 byte wide?
        jz      short save_masks        ;yes, no need to do anything
        cmp     ah,-1                   ;is right edge a whole byte or partial?
        jnz     short save_masks        ;partial
        add     ecx,2                   ;bit 1 of ECX=0 if right edge partial,
                                        ; 1 if whole;
                                        ;bit 1=0 if left edge partial, 1 whole
        inc     ebx                     ;if right edge whole, include it in the
                                        ; whole bytes count
save_masks:
        mov     ulMasks,eax             ;save left and right clip masks
        mov     ulWholeBytes,ebx        ;save # of whole bytes

        mov     ecx,pfnEdgeDrawing[ecx*4] ;set address of routine to draw
        mov     pfnContinueDrawing,ecx    ; all partial (non-whole) edges

        and     ebx,ebx                 ;any whole bytes?
        jz      short start_vec_set     ;no
                                        ;yes, so draw the whole bytes before
                                        ; the edge bytes

; The whole bytes loop depends on the type of operation being done. If the
; operation is one which uses DR_SET, then we can use a STOS-type operation,
; else we have to use a MOVSB-type operation (to load the latches with the
; existing contents of display memory to allow the ALUs to work).

        cmp     byte ptr jALUFunc,DR_SET ;is it a replace-type rop?
        jz      short is_replace_type   ;yes
                                        ;no, set up for non-replace whole bytes
        mov     ecx,offset whole_bytes_non_replace_wide
                                        ;assume too wide to special-case
        cmp     ebx,MAX_NON_REPLACE_SPECIAL ;too wide to special case?
        jnb     short start_vec_set     ;yes
        mov     ecx,pfnWholeBytesNonReplaceEntries[ebx*4] ;no, point to entry
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_special
                                        ;set up to call special routine to fill
                                        ; whole bytes
        jmp     short start_vec_set

is_replace_type:                        ;set up for replace-type rop
        cmp     ebx,MAX_REPLACE_SPECIAL ;too wide to special case?
        jnb     short is_wide_replace   ;yes
                                        ;narrow enough to special case. Look up
                                        ; the entry table for the special case
                                        ; base on the start alignment
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        and     ecx,011b                ;left edge whole bytes start alignment
                                        ; MOD 3
        mov     ecx,pfnWholeBytesReplaceMaster[ecx*4] ;look up table of entry
                                                      ; tables for alignment
        mov     ecx,[ecx+ebx*4]         ;look up entry table for width
        mov     pfnWholeBytes,ecx       ; table for width
        mov     ecx,offset whole_bytes_special
                                        ;set up to call special routine to fill
                                        ; whole bytes
        jmp     short start_vec_set

is_wide_replace:                        ;set up for wide replace-type op
                                        ;Note: assumes there is at least one
                                        ; full dword involved!
        mov     ecx,ulRowOffset
        add     ecx,ulLeftEdgeAdjust    ;left edge whole bytes start offset
        neg     ecx
        and     ecx,011b
        mov     edx,ebx
        sub     edx,ecx                 ;ignore odd leading bytes
        mov     eax,edx
        shr     edx,2                   ;# of whole dwords across (not counting
                                        ; odd leading & trailing bytes)
        mov     ulWholeDwords,edx
        and     eax,011b                ;# of odd (fractional) trailing bytes
        shl     ecx,2
        or      ecx,eax                 ;build a look-up index from the number
                                        ; of leading and trailing bytes
        mov     ecx,pfnWideWholeRep[ecx*4] ;proper drawing handler for front/
        mov     pfnWholeBytes,ecx          ; back alignment
        mov     ecx,offset whole_bytes_rep_wide
                                        ;set up to call routine to perform wide
                                        ; whole bytes fill
start_vec_set:
        mov     pfnStartDrawing,ecx     ; all partial (non-whole) edges

        mov     ecx,ppdev
        mov     eax,[ecx].pdev_lPlanarNextScan
        mov     ulScanWidth,eax         ;local copy of scan line width
        sub     eax,ebx                 ;EAX = delta to next scan
        mov     ulNextScan,eax


;-----------------------------------------------------------------------;
; Fill this rectangle.
;-----------------------------------------------------------------------;

        cmp     byte ptr jInvertDestFirst,1
                                        ;is this an invert-dest-plus-something-
                                        ; else rop that requires two passes?
        jz      short do_invert_dest_rop ;yes, special case with two passes

do_single_pass:
        call    draw_banks


;-----------------------------------------------------------------------;
; See if there are any more rectangles to fill.
;-----------------------------------------------------------------------;

        add     prcl,(size RECTL) ;point to the next rectangle, if there is one
        dec     culRcl            ;count down the rectangles to fill
        jnz     fill_rect_loop


;-----------------------------------------------------------------------;
; We have filled all rectangles.  Restore the VGA to its default state.
;-----------------------------------------------------------------------;

        cmp     byte ptr jALUfunc,DR_SET ;is the logical function already SET?
        jnz     short @F                 ;no, need to reset it
        cRet    vTrgBlt                  ;yes, no need to reset it

@@:
        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(DR_SET shl 8) + GRAF_DATA_ROT ;set the logical function to
        out     dx,ax                              ; SET
vTrgBlts_done:
        cRet    vTrgBlt


;-----------------------------------------------------------------------;
; Handles rops that require two passes, the first being a destination
; inversion pass.
;-----------------------------------------------------------------------;

do_invert_dest_rop:

; Set up the VGA's hardware for inversion

        mov     eax,ulDrawingColor      ;remember the normal drawing color
        push    eax
        mov     ulDrawingColor,-1       ;with XOR, this flips all bits

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     eax,(DR_XOR shl 8) + GRAF_DATA_ROT
        out     dx,ax                   ;logical function = XOR to invert

; Invert the destination

        call    draw_banks

; Restore the VGA's hardware to the state required for the second pass.

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr jALUFunc
        mov     al,GRAF_DATA_ROT
        out     dx,ax                   ;set the ALU logical function back to
                                        ; proper state for the rest of the rop

        pop     eax
        mov     ulDrawingColor,eax      ;restore the normal drawing color

; Perform the second pass to finish the rop.

        jmp     do_single_pass


;-----------------------------------------------------------------------;
; Fills all banks in the current fill rectangle. Called once per fill
; rectangle, except for destination-inversion-plus-something-else rops.
;-----------------------------------------------------------------------;

draw_banks:

;-----------------------------------------------------------------------;
; Map in the bank containing the top scan to fill, if it's not mapped in
; already.
;-----------------------------------------------------------------------;

        mov     edi,prcl                ;point to rectangle to fill
        mov     ecx,ppdev               ;point to PDEV
        mov     eax,[edi].yTop          ;top scan line of fill
        mov     ulCurrentTopScan,eax    ;this will be the fill top in 1st bank

        cmp     eax,[ecx].pdev_rcl1PlanarClip.yTop ;is fill top less than
                                                   ; current bank?
        jl      short map_init_bank             ;yes, map in proper bank
        cmp     eax,[ecx].pdev_rcl1PlanarClip.yBottom ;fill top greater than
                                                      ; current bank?
        jl      short init_bank_mapped          ;no, proper bank already mapped
map_init_bank:

; Map in the bank containing the top scan line of the fill.

        ptrCall <dword ptr [ecx].pdev_pfnPlanarControl>,<ecx,eax,JustifyTop>

init_bank_mapped:

;-----------------------------------------------------------------------;
; Main loop for processing fill in each bank.
;-----------------------------------------------------------------------;

; Compute the starting address and scan line count for the initial bank.

        mov     eax,ppdev               ;point to PDEV
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet     ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].pdev_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; We have computed the starting address and scan count. Time to start drawing
; in the initial bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Whole byte fills.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special
; case width.
;
; The destination is not involved, so a STOS (or equivalent) can be used
; (no read needed before write).
;-----------------------------------------------------------------------;

whole_bytes_rep_wide:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     esi,ulWholeDwords       ;whole dwords width
        mov     edx,ulNextScan          ;offset from end of one scan line to
                                        ; start of next
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        call    pfnWholeBytes           ;draw the wide whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handles both replace and non-replace whole byte fills narrow enough to
; special case.
;-----------------------------------------------------------------------;

whole_bytes_special:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     ecx,ulScanWidth         ;offset to next scan line
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        call    pfnWholeBytes           ;draw the wide whole bytes

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Handles non-replace whole byte fills wider than the maximum special case
; width.
;
; The destination is involved, so a MOVSB (or equivalent) must be
; performed in order to do a read before write to give the ALUs something
; to work with.
;-----------------------------------------------------------------------;

whole_bytes_non_replace_wide:
        push    ebx                     ;save scan count
        push    edi                     ;save starting address

        add     edi,ulLeftEdgeAdjust    ;point to first whole byte to fill
        mov     esi,ulWholeBytes        ;whole bytes width
        mov     edx,ulNextScan          ;offset from end of one scan line to
                                        ; start of next
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

;-----------------------------------------------------------------------;
; 5-or-wider read before write loop.
;
; Entry:
;       EAX = # of bytes to fill across scan line (needed only by 5-or-wider
;               handler)
;       EBX = loop count
;       EDX = offset from end of one scan line to the start of the next next
;       EDI = start offset
;
; EBX, ECX, ESI, EDI modified. All other registers preserved.

; 5-or-wider read/write.

draw_wide_rw_loop:
        mov     ecx,esi
@@:
        mov     ah,[edi]        ;latch the target address. The data read
                                ; doesn't matter
        mov     [edi],al        ;merge the drawing color with the latched
                                ; target address according to the selected ALU
                                ; function, and write the result to display
                                ; memory
        inc     edi             ;point to the next byte
        dec     ecx
        jnz     @B
        add     edi,edx
        dec     ebx
        jnz     draw_wide_rw_loop

        pop     edi                     ;restore screen pointer
        pop     ebx                     ;restore fill scan count
        jmp     pfnContinueDrawing      ;either keep drawing or we're done


;-----------------------------------------------------------------------;
; Process any left/right columns that that have to be done.
;
;   Currently:
;       EBX =   height to fill, in scans
;       EDI --> first byte of left edge
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Handle case where both edges are partial (non-whole) bytes. We don't
; have to read before write because we're using the Map Mask, not the
; Bit Mask.
;-----------------------------------------------------------------------;
        public do_both_edge_bytes
do_both_edge_bytes::

; Set up variables for entering loop.

        mov     al,byte ptr ulMasks     ;this will become the clip mask for the
                                        ; left edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     ecx,ulScanWidth         ;offset from one scan to next

        mov     esi,ulWholeBytes        ;ESI = # of whole bytes
        lea     esi,[esi+edi+1]         ;--> start for right edge
        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        push    ebx                     ;preserve scan line count
        call    ppfnDrawEdgeTable       ;jump into the loop to draw
        pop     ebx                     ;restore scan line count

        mov     edi,esi                 ;point to first right edge byte
        mov     al,byte ptr ulMasks+1   ;this will become the Bit Mask for the
                                        ; right edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        push    offset edges_done       ;return here
        jmp     ppfnDrawEdgeTable       ;jump into the loop to draw

;-----------------------------------------------------------------------;
; Handle case where only the left edge is partial (non-whole).
;-----------------------------------------------------------------------;
do_left_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next
        mov     al,byte ptr ulMasks     ;this will become the Bit Mask for the
                                        ; left edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for left edge

        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        push    offset edges_done       ;return here
        jmp     ppfnDrawEdgeTable       ;jump into the loop to draw

;-----------------------------------------------------------------------;
; Handle case where only the right edge is partial (non-whole).
;-----------------------------------------------------------------------;
do_right_edge_bytes::

; Set up variables for entering loop.

        mov     ecx,ulScanWidth         ;offset from one scan to next
        add     edi,ulWholeBytes        ;--> start for right edge (remember,
                                        ; left edge is whole, so the left edge
                                        ; byte is included in the whole byte
                                        ; count)
        mov     al,byte ptr ulMasks+1   ;this will become the Bit Mask for the
                                        ; right edge
        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        out     dx,al                   ;set Map Mask for right edge

        mov     eax,ulDrawingColor      ;each byte is color with which to fill

        call    ppfnDrawEdgeTable       ;jump into the loop to draw

;-----------------------------------------------------------------------;
; We have done all partial edges.
;-----------------------------------------------------------------------;

edges_done:

        mov     edx,VGA_BASE + SEQ_DATA ;SEQ_INDEX already points to Map Mask
        mov     al,MM_ALL               ;restore the default Map Mask of all
        out     dx,al                   ; planes enabled

;-----------------------------------------------------------------------;
; See if there are any more banks to process.
;-----------------------------------------------------------------------;

check_next_bank::

        mov     edi,ppdev
        mov     eax,[edi].pdev_rcl1PlanarClip.yBottom ;is the fill bottom in
        cmp     ulBottomScan,eax                      ; the current bank?
        jle     short banks_done        ;yes, so we're done
                                        ;no, map in the next bank and fill it
        mov     ulCurrentTopScan,eax    ;remember where the top of the bank
                                        ; we're about to map in is (same as
                                        ; bottom of bank we just did)

        ptrCall <dword ptr [edi].pdev_pfnPlanarControl>,<edi,eax,JustifyTop>
                                        ;map in the bank

; Compute the starting address and scan line count in this bank.

        mov     eax,ppdev               ;EAX->target surface
        mov     ebx,ulBottomScan        ;bottom of destination rectangle
        cmp     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;which comes first, the bottom of the
                                        ; dest rect or the bottom of the
                                        ; current bank?
        jl      short BottomScanSet2    ;fill bottom comes first, so draw to
                                        ; that; this is the last bank in fill
        mov     ebx,[eax].pdev_rcl1PlanarClip.yBottom
                                        ;bank bottom comes first; draw to
                                        ; bottom of bank
BottomScanSet2:
        mov     edi,ulCurrentTopScan    ;top scan line to fill in current bank
        sub     ebx,edi                 ;# of scans to fill in bank
        imul    edi,ulScanWidth         ;offset of starting scan line

; Note that the start of the bitmap will change each time through the
; bank loop, because the start of the bitmap is varied to map the
; desired scan line to the banking window.

        add     edi,[eax].pdev_pvBitmapStart ;start of scan in bitmap
        add     edi,ulRowOffset         ;EDI = start offset of fill in bitmap

; Draw in the new bank.

        jmp     pfnStartDrawing


;-----------------------------------------------------------------------;
; Done with all banks in this fill.

banks_done:
        retn

endProc vTrgBlt


;-----------------------------------------------------------------------;
; Drawing loops.
; There are two kinds of drawing loops: read-before-write (to load the
;  latches), and write-only (for replace-type rops).
;-----------------------------------------------------------------------;


;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is required,
; to load the latches.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide read before write drawing loops.
;
; Entry:
;       AL  = drawing color
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

; 1-wide read/write.

draw_1_wide_rw_loop     proc    near
        mov     ah,[edi]        ;latch the target address. The data read
                                ; doesn't matter
        mov     [edi],al        ;merge the drawing color with the latched
                                ; target address according to the selected ALU
                                ; function, and write the result to display
                                ; memory
        add     edi,ecx         ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_rw_loop

        ret

draw_1_wide_rw_loop     endp

; 2-wide read/write.

draw_2_wide_rw_loop     proc    near
        mov     ah,[edi]                ;see 1-wide RW case for comments
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_rw_loop

        ret

draw_2_wide_rw_loop     endp

; 3-wide read/write.

draw_3_wide_rw_loop     proc    near
        mov     ah,[edi]                ;see 1-wide RW case for comments
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        mov     ah,[edi+2]
        mov     [edi+2],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_rw_loop

        ret

draw_3_wide_rw_loop     endp

; 4-wide read/write.

draw_4_wide_rw_loop     proc    near
        mov     ah,[edi]                ;see 1-wide RW case for comments
        mov     [edi],al
        mov     ah,[edi+1]
        mov     [edi+1],al
        mov     ah,[edi+2]
        mov     [edi+2],al
        mov     ah,[edi+3]
        mov     [edi+3],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_rw_loop

        ret

draw_4_wide_rw_loop     endp

;-----------------------------------------------------------------------;
; Drawing stuff for cases where read before write is NOT required.
;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; 1-, 2-, 3-, and 4-wide write-only edge-drawing loops.
;
; Entry:
;       EAX = fill color, replicated four times
;       EBX = loop count
;       ECX = scan line width in bytes
;       EDI = start offset
;
; EBX, EDI modified. All other registers preserved.

; 1-wide write-only.

draw_1_wide_w_loop     proc    near
        mov     [edi],al                ;draw the pixel
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_1_wide_w_loop

        ret

draw_1_wide_w_loop     endp

; 2-wide write-only.

draw_2_wide_w_loop     proc    near
        mov     [edi],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_2_wide_w_loop

        ret

draw_2_wide_w_loop     endp

; 3-wide write-only, starting at an even address.

draw_3_wide_w_even_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_w_even_loop

        ret

draw_3_wide_w_even_loop     endp

; 3-wide write-only, starting at an odd address.

draw_3_wide_w_odd_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_3_wide_w_odd_loop

        ret

draw_3_wide_w_odd_loop     endp

; 4-wide write-only.

draw_4_wide_w_loop     proc    near
        mov     [edi],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_4_wide_w_loop

        ret

draw_4_wide_w_loop     endp

; 5-wide write-only, starting at an even address.

draw_5_wide_w_even_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_w_even_loop

        ret

draw_5_wide_w_even_loop     endp

; 5-wide write-only, starting at an odd address.

draw_5_wide_w_odd_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_5_wide_w_odd_loop

        ret

draw_5_wide_w_odd_loop     endp

; 6-wide write-only, starting at MOD 3 == 0.

draw_6_wide_w_mod3_0_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_0_loop

        ret

draw_6_wide_w_mod3_0_loop     endp

; 6-wide write-only, starting at MOD 3 == 1 or 3.

draw_6_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        mov     [edi+5],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_1_loop

        ret

draw_6_wide_w_mod3_1_loop     endp

; 6-wide write-only, starting at MOD 3 == 2.

draw_6_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_6_wide_w_mod3_2_loop

        ret

draw_6_wide_w_mod3_2_loop     endp

; 7-wide write-only, starting at MOD 3 == 0.

draw_7_wide_w_mod3_0_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],ax
        mov     [edi+6],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_0_loop

        ret

draw_7_wide_w_mod3_0_loop     endp

; 7-wide write-only, starting at MOD 3 == 0.

draw_7_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_1_loop

        ret

draw_7_wide_w_mod3_1_loop     endp

; 7-wide write-only, starting at MOD 3 == 2.

draw_7_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],eax
        mov     [edi+6],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_2_loop

        ret

draw_7_wide_w_mod3_2_loop     endp

; 7-wide write-only, starting at MOD 3 == 3.

draw_7_wide_w_mod3_3_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        mov     [edi+5],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_7_wide_w_mod3_3_loop

        ret

draw_7_wide_w_mod3_3_loop     endp

; 8-wide write-only, starting at MOD 3 == 0.

draw_8_wide_w_mod3_0_loop     proc    near
        mov     [edi],eax
        mov     [edi+4],eax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_0_loop

        ret

draw_8_wide_w_mod3_0_loop     endp

; 8-wide write-only, starting at MOD 3 == 0.

draw_8_wide_w_mod3_1_loop     proc    near
        mov     [edi],al
        mov     [edi+1],ax
        mov     [edi+3],eax
        mov     [edi+7],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_1_loop

        ret

draw_8_wide_w_mod3_1_loop     endp

; 8-wide write-only, starting at MOD 3 == 2.

draw_8_wide_w_mod3_2_loop     proc    near
        mov     [edi],ax
        mov     [edi+2],eax
        mov     [edi+6],ax
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_2_loop

        ret

draw_8_wide_w_mod3_2_loop     endp

; 8-wide write-only, starting at MOD 3 == 3.

draw_8_wide_w_mod3_3_loop     proc    near
        mov     [edi],al
        mov     [edi+1],eax
        mov     [edi+5],ax
        mov     [edi+7],al
        add     edi,ecx                 ;point to the next scan line

        dec     ebx
        jnz     draw_8_wide_w_mod3_3_loop

        ret

draw_8_wide_w_mod3_3_loop     endp

;-----------------------------------------------------------------------;
; Loop stuff for wide replace-type rops (arbitrary width).
;-----------------------------------------------------------------------;

; N-wide write-only, 0 leading bytes, 0 trailing bytes.
;  EAX = 0ffffh
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_00_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_00_loop

        ret

draw_wide_w_00_loop     endp

; N-wide write-only, 0 leading bytes, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_01_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_01_loop

        ret

draw_wide_w_01_loop     endp

; N-wide write-only, 0 leading bytes, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_02_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_02_loop

        ret

draw_wide_w_02_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_03_loop     proc    near
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the leading word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_03_loop

        ret

draw_wide_w_03_loop     endp

; N-wide write-only, 1 leading byte, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_10_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_10_loop

        ret

draw_wide_w_10_loop     endp

; N-wide write-only, 1 leading bytes, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_11_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_11_loop

        ret

draw_wide_w_11_loop     endp

; N-wide write-only, 1 leading bytes, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_12_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_12_loop

        ret

draw_wide_w_12_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_13_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        inc     edi
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_13_loop

        ret

draw_wide_w_13_loop     endp

; N-wide write-only, 2 leading bytes, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_20_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_20_loop

        ret

draw_wide_w_20_loop     endp

; N-wide write-only, 2 leading bytess, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_21_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_21_loop

        ret

draw_wide_w_21_loop     endp

; N-wide write-only, 2 leading bytess, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_22_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_22_loop

        ret

draw_wide_w_22_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_23_loop     proc    near
        mov     [edi],ax        ;fill the leading word
        add     edi,2
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_23_loop

        ret

draw_wide_w_23_loop     endp

; N-wide write-only, 3 leading bytes, 0 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_30_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill all whole bytes as dwords
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_30_loop

        ret

draw_wide_w_30_loop     endp

; N-wide write-only, 3 leading bytess, 1 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_31_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],al        ;fill the trailing byte
        inc     edi
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_31_loop

        ret

draw_wide_w_31_loop     endp

; N-wide write-only, 3 leading bytess, 2 trailing byte.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_32_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        add     edi,2
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_32_loop

        ret

draw_wide_w_32_loop     endp

; N-wide write-only, 0 leading bytes, 3 trailing bytes.
;  EAX = # of dwords to fill
;  EBX = count of scans to fill
;  EDX = offset from end of one scan's fill to start of next
;  ESI = # of dwords to fill
;  EDI = target address to fill

draw_wide_w_33_loop     proc    near
        mov     [edi],al        ;fill the leading byte
        mov     [edi+1],ax      ;fill the leading word
        add     edi,3
        mov     ecx,esi         ;# of whole dwords
        rep     stosd           ;fill whole bytes as dwords
        mov     [edi],ax        ;fill the trailing word
        mov     [edi+2],al      ;fill the trailing byte
        add     edi,3
        add     edi,edx         ;point to the next scan line

        dec     ebx
        jnz     draw_wide_w_33_loop

        ret

draw_wide_w_33_loop     endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\disp\8bpp\i386\vgaregs.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: vgaregs.asm
;
; Copyright (c) 1992 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vInitRegs(void)
;
; Sets the VGA's data control registers to their default states.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\driver.inc
        include i386\egavga.inc

        .list

        .code

cProc vInitRegs,4,<             \
        uses esi edi ebx,       \
        ppdev: ptr PDEV         >

        mov     esi,ppdev

;       Initialize sequencer to its defaults (all planes enabled, index
;       pointing to Map Mask).

        mov     dx,VGA_BASE + SEQ_ADDR
        mov     ax,(MM_ALL shl 8) + SEQ_MAP_MASK
        out     dx,ax

;       Initialize graphics controller to its defaults (set/reset disabled for
;       all planes, no rotation & ALU function == replace, write mode 0 & read
;       mode 0, color compare ignoring all planes (read mode 1 reads always
;       return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
;       bytes from the CPU.

        mov     dl,GRAF_ADDR
        mov     ax,(0 shl 8) + GRAF_ENAB_SR
        out     dx,ax

        mov     ax,(DR_SET shl 8) + GRAF_DATA_ROT
        out     dx,ax

;       Default to read mode 0, write mode 0:

        mov     edx,VGA_BASE + GRAF_ADDR
        mov     ah,byte ptr [esi].pdev_ulrm0_wmX[0]
        mov     al,GRAF_MODE
        out     dx,ax                   ;write mode 0, read mode 0

        mov     ax,(0 shl 8) + GRAF_CDC
        out     dx,ax

        mov     ax,(0FFh shl 8) + GRAF_BIT_MASK
        out     dx,ax

        cRet    vInitRegs


endProc vInitRegs

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\modeset.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    modeset.c

Abstract:

    This is the modeset code for the VGA miniport driver.

Environment:

    kernel mode only

Notes:

Revision History:

--*/
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"
#include "vesa.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,VgaQueryAvailableModes)
#pragma alloc_text(PAGE,VgaQueryNumberOfAvailableModes)
#pragma alloc_text(PAGE,VgaQueryCurrentMode)
#pragma alloc_text(PAGE,VgaSetMode)
#pragma alloc_text(PAGE,VgaInterpretCmdStream)
#pragma alloc_text(PAGE,VgaZeroVideoMemory)
#endif


VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    )

/*++

Routine Description:

    Interprets the appropriate command array to set up VGA registers for the
    requested mode. Typically used to set the VGA into a particular mode by
    programming all of the registers

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    pusCmdStream - array of commands to be interpreted.

Return Value:

    The status of the operation (can only fail on a bad command); TRUE for
    success, FALSE for failure.

--*/

{
    ULONG ulCmd;
    ULONG_PTR ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG_PTR ulBase;

    if (pusCmdStream == NULL) {

        VideoDebugPrint((1, "VgaInterpretCmdStream - Invalid pusCmdStream\n"));
        return TRUE;
    }

    ulBase = (ULONG_PTR)HwDeviceExtension->IOAddress;

    //
    // Now set the adapter to the desired mode.
    //

    while ((ulCmd = *pusCmdStream++) != EOD) {

        //
        // Determine major command type
        //

        switch (ulCmd & 0xF0) {

            //
            // Basic input/output command
            //

            case INOUT:

                //
                // Determine type of inout instruction
                //

                if (!(ulCmd & IO)) {

                    //
                    // Out instruction. Single or multiple outs?
                    //

                    if (!(ulCmd & MULTI)) {

                        //
                        // Single out. Byte or word out?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // Single byte out
                            //

                            ulPort = *pusCmdStream++;
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)(ulBase+ulPort),
                                    jValue);

                        } else {

                            //
                            // Single word out
                            //

                            ulPort = *pusCmdStream++;
                            usValue = *pusCmdStream++;
                            VideoPortWritePortUshort((PUSHORT)(ulBase+ulPort),
                                    usValue);

                        }

                    } else {

                        //
                        // Output a string of values
                        // Byte or word outs?
                        //

                        if (!(ulCmd & BW)) {

                            //
                            // String byte outs. Do in a loop; can't use
                            // VideoPortWritePortBufferUchar because the data
                            // is in USHORT form
                            //

                            ulPort = ulBase + *pusCmdStream++;
                            culCount = *pusCmdStream++;

                            while (culCount--) {
                                jValue = (UCHAR) *pusCmdStream++;
                                VideoPortWritePortUchar((PUCHAR)ulPort,
                                        jValue);

                            }

                        } else {

                            //
                            // String word outs
                            //

                            ulPort = *pusCmdStream++;
                            culCount = *pusCmdStream++;
                            VideoPortWritePortBufferUshort((PUSHORT)
                                    (ulBase + ulPort), pusCmdStream, culCount);
                            pusCmdStream += culCount;

                        }
                    }

                } else {

                    // In instruction
                    //
                    // Currently, string in instructions aren't supported; all
                    // in instructions are handled as single-byte ins
                    //
                    // Byte or word in?
                    //

                    if (!(ulCmd & BW)) {
                        //
                        // Single byte in
                        //

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);

                    } else {

                        //
                        // Single word in
                        //

                        ulPort = *pusCmdStream++;
                        usValue = VideoPortReadPortUshort((PUSHORT)
                                (ulBase+ulPort));

                    }

                }

                break;

            //
            // Higher-level input/output commands
            //

            case METAOUT:

                //
                // Determine type of metaout command, based on minor
                // command field
                //
                switch (ulCmd & 0x0F) {

                    //
                    // Indexed outs
                    //

                    case INDXOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            usValue = (USHORT) (ulIndex +
                                      (((ULONG)(*pusCmdStream++)) << 8));
                            VideoPortWritePortUshort((PUSHORT)ulPort, usValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // Masked out (read, AND, XOR, write)
                    //

                    case MASKOUT:

                        ulPort = *pusCmdStream++;
                        jValue = VideoPortReadPortUchar((PUCHAR)ulBase+ulPort);
                        jValue &= *pusCmdStream++;
                        jValue ^= *pusCmdStream++;
                        VideoPortWritePortUchar((PUCHAR)ulBase + ulPort,
                                jValue);
                        break;

                    //
                    // Attribute Controller out
                    //

                    case ATCOUT:

                        ulPort = ulBase + *pusCmdStream++;
                        culCount = *pusCmdStream++;
                        ulIndex = *pusCmdStream++;

                        while (culCount--) {

                            // Write Attribute Controller index
                            VideoPortWritePortUchar((PUCHAR)ulPort,
                                    (UCHAR)ulIndex);

                            // Write Attribute Controller data
                            jValue = (UCHAR) *pusCmdStream++;
                            VideoPortWritePortUchar((PUCHAR)ulPort, jValue);

                            ulIndex++;

                        }

                        break;

                    //
                    // None of the above; error
                    //
                    default:

                        return FALSE;

                }


                break;

            //
            // NOP
            //

            case NCMD:

                break;

            //
            // Unknown command; error
            //

            default:

                return FALSE;

        }

    }

    return TRUE;

} // end VgaInterpretCmdStream()


VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize,
    PULONG FrameBufferIsMoved
    )

/*++

Routine Description:

    This routine sets the VGA into the requested mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    Mode - Pointer to the structure containing the information about the
        font to be set.

    ModeSize - Length of the input buffer supplied by the user.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the input buffer was not large enough
        for the input data.

    ERROR_INVALID_PARAMETER if the mode number is invalid.

    NO_ERROR if the operation completed successfully.

--*/

{

    PVIDEOMODE pRequestedMode;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (ModeSize < sizeof(VIDEO_MODE)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    *FrameBufferIsMoved = 0;

    //
    // Extract the clear memory bit.
    //

    if (Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) {

        Mode->RequestedMode &= ~VIDEO_MODE_NO_ZERO_MEMORY;

    }  else {

        if (IS_LINEAR_MODE(&VgaModeList[Mode->RequestedMode]) == FALSE) {
            VgaZeroVideoMemory(HwDeviceExtension);
        }
    }

    //
    // Check to see if we are requesting a vlid mode
    //

    if (Mode->RequestedMode >= NumVideoModes) {

        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;

    }

    pRequestedMode = &VgaModeList[Mode->RequestedMode];

#ifdef INT10_MODE_SET
{

    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    UCHAR temp;
    UCHAR dummy;
    UCHAR bIsColor;
    ULONG modeNumber;
    VP_STATUS status;
    ULONG MemoryBase;

    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

    modeNumber = pRequestedMode->Int10ModeNumber;

    VideoDebugPrint((1, "Setting Mode: (%d,%d) @ %d bpp\n",
                        pRequestedMode->hres,
                        pRequestedMode->vres,
                        pRequestedMode->bitsPerPlane * pRequestedMode->numPlanes));


    biosArguments.Eax = modeNumber & 0x0000FFFF;
    biosArguments.Ebx = modeNumber >> 16;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if (status != NO_ERROR) {

        ASSERT(FALSE);
        return status;
    }

    //
    // If this was the VESA mode modeset, check the return value in eax
    //

    if (modeNumber >> 16) {

        if ((biosArguments.Eax & 0x0000FFFF) != VESA_STATUS_SUCCESS) {

            VideoDebugPrint((0, "Mode set failed!  AX = 0x%x\n", biosArguments.Eax));

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Double check if the current mode is the mode we just set.
        // This is to workaround the BIOS problem of some cards.
        //

        biosArguments.Eax = 0x4F03;
        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if ( (status == NO_ERROR) && 
             ((biosArguments.Eax & 0x0000FFFF) == VESA_STATUS_SUCCESS) && 
             ((biosArguments.Ebx & 0x1FF) != ((modeNumber >> 16) & 0x1FF))) {

            VideoDebugPrint((0, "VGA: The BIOS of this video card is buggy!\n"));
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Set the scan line width if we are stretching scan lines to avoid
        // broken rasters.
        //

        if (pRequestedMode->PixelsPerScan != pRequestedMode->hres) {

            VideoDebugPrint((1, "Setting scan line length to %d pixels\n",
                                pRequestedMode->PixelsPerScan));

            biosArguments.Eax = 0x4f06;
            biosArguments.Ebx = 0x00;
            biosArguments.Ecx = pRequestedMode->PixelsPerScan;

            status = VideoPortInt10(HwDeviceExtension, &biosArguments);

            if ((status != NO_ERROR) || 
                ((biosArguments.Eax & 0x0000FFFF) != VESA_STATUS_SUCCESS) || 
                ((biosArguments.Ecx & 0xFFFF) != pRequestedMode->PixelsPerScan)) {

                VideoDebugPrint((1, "Scan line status: eax = 0x%x\n", biosArguments.Eax));
                return ERROR_INVALID_PARAMETER;
            }

        }
    }

    //
    // If we are trying to go into mode X, then we are now in
    // 320x200 256 color mode.  Now let's finish the modeset
    // into MODE X.
    //

    if (pRequestedMode->hres == 320) {

        if ((pRequestedMode->vres == 240) || (pRequestedMode->vres == 480)) {

            VgaInterpretCmdStream(HwDeviceExtension, ModeX240);

        } else if ((pRequestedMode->vres == 200) || (pRequestedMode->vres == 400)) {

            VgaInterpretCmdStream(HwDeviceExtension, ModeX200);

        }

        if ((pRequestedMode->vres == 400) || (pRequestedMode->vres == 480)) {

            VgaInterpretCmdStream(HwDeviceExtension, ModeXDoubleScans);

        }
    }

    //
    // Fix to get 640x350 text mode
    //

    if (!(pRequestedMode->fbType & VIDEO_MODE_GRAPHICS)) {

        if ((pRequestedMode->hres == 640) &&
            (pRequestedMode->vres == 350)) {

            VgaInterpretCmdStream(HwDeviceExtension, VGA_TEXT_1);

        } else {

            //
            // Fix to make sure we always set the colors in text mode to be
            // intensity, and not flashing
            // For this zero out the Mode Control Regsiter bit 3 (index 0x10
            // of the Attribute controller).
            //

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT) & 0x01) {

                bIsColor = TRUE;

            } else {

                bIsColor = FALSE;

            }

            if (bIsColor) {

                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        INPUT_STATUS_1_COLOR);
            } else {

                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        INPUT_STATUS_1_MONO);
            }

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
            temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_DATA_READ_PORT);

            temp &= 0xF7;

            if (bIsColor) {

                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        INPUT_STATUS_1_COLOR);
            } else {

                dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        INPUT_STATUS_1_MONO);
            }

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT, (0x10 | VIDEO_ENABLE));
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    ATT_DATA_WRITE_PORT, temp);
        }
    }

    //
    // Retrieve the base address again. This is to handle the case 
    // when pci reprograms the bar 
    //

    MemoryBase = GetVideoMemoryBaseAddress(HwDeviceExtension, pRequestedMode);
 
    if (MemoryBase && pRequestedMode->MemoryBase != MemoryBase) {
        *FrameBufferIsMoved = 1;
        pRequestedMode->MemoryBase = MemoryBase;
    }

}
#else
    VgaInterpretCmdStream(HwDeviceExtension, pRequestedMode->CmdStrings);
#endif

    //
    // Update the location of the physical frame buffer within video memory.
    //

    HwDeviceExtension->PhysicalVideoMemoryBase.LowPart = 
        pRequestedMode->MemoryBase;

    HwDeviceExtension->PhysicalVideoMemoryLength =
        pRequestedMode->MemoryLength;

    HwDeviceExtension->PhysicalFrameBaseOffset.LowPart =
        pRequestedMode->FrameOffset;

    HwDeviceExtension->PhysicalFrameLength =
        pRequestedMode->FrameLength;

    //
    // Store the new mode value.
    //

    HwDeviceExtension->CurrentMode = pRequestedMode;
    HwDeviceExtension->ModeIndex = Mode->RequestedMode;

    return NO_ERROR;

} //end VgaSetMode()


VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the list of all available available modes on the
    card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the list of all valid modes is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    //
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize =
            NumVideoModes * sizeof(VIDEO_MODE_INFORMATION)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //


    for (i = 0; i < NumVideoModes; i++, videoModes++) {

        videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
        videoModes->ModeIndex  = i;
        videoModes->VisScreenWidth = VgaModeList[i].hres;
        videoModes->ScreenStride = VgaModeList[i].wbytes;
        videoModes->VisScreenHeight = VgaModeList[i].vres;
        videoModes->NumberOfPlanes = VgaModeList[i].numPlanes;
        videoModes->BitsPerPlane = VgaModeList[i].bitsPerPlane;
        videoModes->Frequency = VgaModeList[i].frequency;
        videoModes->XMillimeter = 320;        // temporary hardcoded constant
        videoModes->YMillimeter = 240;        // temporary hardcoded constant

        if (VgaModeList[i].bitsPerPlane < 15) {

            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->RedMask = 0;
            videoModes->GreenMask = 0;
            videoModes->BlueMask = 0;

        } else if (VgaModeList[i].bitsPerPlane == 15) {

            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->RedMask = 0x1F << 10;
            videoModes->GreenMask = 0x1F << 5;
            videoModes->BlueMask = 0x1F;

        } else if (VgaModeList[i].bitsPerPlane == 16) {

            videoModes->NumberRedBits = 6;
            videoModes->NumberGreenBits = 6;
            videoModes->NumberBlueBits = 6;

            videoModes->RedMask = 0x1F << 11;
            videoModes->GreenMask = 0x3F << 5;
            videoModes->BlueMask = 0x1F;

        } else {

            videoModes->NumberRedBits = 8;
            videoModes->NumberGreenBits = 8;
            videoModes->NumberBlueBits = 8;

            videoModes->RedMask = 0xff0000;
            videoModes->GreenMask = 0x00ff00;
            videoModes->BlueMask = 0x0000ff;
        }

        videoModes->AttributeFlags = VgaModeList[i].fbType |
               VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    }

    return NO_ERROR;

} // end VgaGetAvailableModes()

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the number of available modes for this particular
    video card.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    NumModes - Pointer to the output buffer supplied by the user. This is
        where the number of modes is stored.

    NumModesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the number of modes into the buffer.
    //

    NumModes->NumModes = NumVideoModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns a description of the current video mode.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ModeInformation - Pointer to the output buffer supplied by the user.
        This is where the current mode information is stored.

    ModeInformationSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
        for the data being returned.

    NO_ERROR if the operation completed successfully.

--*/

{
    //
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the characteristics of the current mode into the buffer.
    //

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);
    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
    ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->hres;
    ModeInformation->ScreenStride = HwDeviceExtension->CurrentMode->wbytes;
    ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->vres;
    ModeInformation->NumberOfPlanes = HwDeviceExtension->CurrentMode->numPlanes;
    ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->bitsPerPlane;
    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->frequency;

    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant

    if (HwDeviceExtension->CurrentMode->bitsPerPlane < 15) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;

        ModeInformation->RedMask = 0;
        ModeInformation->GreenMask = 0;
        ModeInformation->BlueMask = 0;

    } else if (HwDeviceExtension->CurrentMode->bitsPerPlane == 15) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;

        ModeInformation->RedMask = 0x1F << 10;
        ModeInformation->GreenMask = 0x1F << 5;
        ModeInformation->BlueMask = 0x1F;

    } else if (HwDeviceExtension->CurrentMode->bitsPerPlane == 16) {

        ModeInformation->NumberRedBits = 6;
        ModeInformation->NumberGreenBits = 6;
        ModeInformation->NumberBlueBits = 6;

        ModeInformation->RedMask = 0x1F << 11;
        ModeInformation->GreenMask = 0x3F << 5;
        ModeInformation->BlueMask = 0x1F;

    } else {

        ModeInformation->NumberRedBits = 8;
        ModeInformation->NumberGreenBits = 8;
        ModeInformation->NumberBlueBits = 8;

        ModeInformation->RedMask = 0xff0000;
        ModeInformation->GreenMask = 0x00ff00;
        ModeInformation->BlueMask = 0x0000ff;
    }

    ModeInformation->AttributeFlags = HwDeviceExtension->CurrentMode->fbType |
             VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE;

    return NO_ERROR;

} // end VgaQueryCurrentMode()


VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
/*++

Routine Description:

    This routine zeros the first 256K on the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.


Return Value:

    None.

--*/
{
    UCHAR temp;

    //
    // Map font buffer at A0000
    //
    // We need the 2 calls below to VideoPortStallExecution because on 
    // some old cards the machine would hard hang without this delay.
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);
    VideoPortStallExecution(25);

    //
    // Enable all planes.
    //
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
            IND_MAP_MASK);

    temp = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) | (UCHAR)0x0F;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + SEQ_DATA_PORT,
            temp);

    //
    // Zero the memory.
    //

    VideoPortZeroDeviceMemory(HwDeviceExtension->VideoMemoryAddress, 0xFFFF);
    VideoPortStallExecution(25);

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\vesa.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vesa.h

Abstract:

    This module implements VESA support.

Author:

    Erick Smith (ericks) Sep. 2000

Environment:

    kernel mode only

Revision History:

--*/

#define VBE_GET_CONTROLLER_INFO 0x4F00
#define VBE_GET_MODE_INFO       0x4F01
#define VBE_SET_MODE            0x4F02
#define VBE_GET_MODE            0x4F03
#define VBE_SAVE_RESTORE_STATE  0x4F04
#define VBE_WINDOW_CONTROL      0x4F05
#define VBE_SCANLINE            0x4F06
#define VBE_DISPLAY_START       0x4F07
#define VBE_PALLET_FORMAT       0x4F08
#define VBE_PALLET_DATA         0x4F09
#define VBE_PROTECTED_MODE      0x4F0A
#define VBE_PIXEL_CLOCK         0x4F0B

#define VESA_STATUS_SUCCESS 0x004F

//
// VESA SuperVGA structures
//

#pragma pack(1)
typedef struct _VGA_INFO_BLOCK
{
    ULONG VesaSignature;
    USHORT VbeVersion;
    ULONG OemStringPtr;
    ULONG Capabilities;
    ULONG VideoModePtr;
    USHORT TotalMemory;

    //
    // VBE 2.0
    //

    USHORT OemSoftwareRev;
    ULONG OemVendorNamePtr;
    ULONG OemProductNamePtr;
    ULONG OemProductRevPtr;
    UCHAR Reserved[222];

    UCHAR OemData[256];

} VGA_INFO_BLOCK, *PVGA_INFO_BLOCK;

typedef struct _MODE_INFO_BLOCK
{
    USHORT ModeAttributes;
    UCHAR WinAAttributes;
    UCHAR WinBAttributes;
    USHORT WinGranularity;
    USHORT WinSize;
    USHORT WinASegment;
    USHORT WinBSegment;
    ULONG WinFuncPtr;
    USHORT BytesPerScanLine;

    USHORT XResolution;
    USHORT YResolution;
    UCHAR XCharSize;
    UCHAR YCharSize;
    UCHAR NumberOfPlanes;
    UCHAR BitsPerPixel;
    UCHAR NumberOfBanks;
    UCHAR MemoryModel;
    UCHAR BankSize;
    UCHAR NumberOfImagePages;
    UCHAR Reserved1;

    UCHAR RedMaskSize;
    UCHAR RedFieldPosition;
    UCHAR GreenMaskSize;
    UCHAR GreenFieldPosition;
    UCHAR BlueMaskSize;
    UCHAR BlueFieldPosition;
    UCHAR RsvdMaskSize;
    UCHAR RsvdFieldPosition;
    UCHAR DirectColorModeInfo;

    //
    // VBE 2.0
    //

    ULONG PhysBasePtr;
    ULONG Reserved2;
    USHORT Reserved3;

    //
    // VBE 3.0
    //

    USHORT LinBytesPerScanLine;
    UCHAR BnkNumberOfImagePages;
    UCHAR LinNumberOfImagePages;
    UCHAR LinRedMaskSize;
    UCHAR LinRedFieldPosition;
    UCHAR LinGreenMaskSize;
    UCHAR LinGreenFieldPosition;
    UCHAR LinBlueMaskSize;
    UCHAR LinBlueFieldPosition;
    UCHAR LinRsvdMaskSize;
    UCHAR LinRsvdFieldPosition;
    ULONG MaxPixelClock;

    UCHAR Reserved4[190];

} MODE_INFO_BLOCK, *PMODE_INFO_BLOCK;

typedef struct _PALETTE_ENTRY
{
    UCHAR Blue;
    UCHAR Green;
    UCHAR Red;
    UCHAR Alignment;
} PALETTE_ENTRY, *PPALETTE_ENTRY;

#pragma pack()

typedef struct _VESA_INFO
{
    USHORT ModeNumber;
    ULONG FrameBufferSize;
    MODE_INFO_BLOCK ModeInfoBlock;
    ULONG HardwareStateSize;
    UCHAR HardwareState[];
} VESA_INFO, *PVESA_INFO;


#define VDM_TRANSFER_SEGMENT 0x2000
#define VDM_TRANSFER_OFFSET  0x0000

#define VBE_CAP_DAC_WIDTH_8BPP              0x01
#define VBE_CAP_NOT_VGA                     0x02
#define VBE_CAP_VSYNC_ON_PALETTE_UPDATE     0x04
#define VBE_CAP_STEREO_SIGNAL               0x08
#define VBE_CAP_STEREO_EVC_CONNECTOR        0x10

#define SEG(x) ((x) >> 16)
#define OFF(x) ((x) & 0xffff)

#define TRANSFER_ADDRESS ((VDM_TRANSFER_SEGMENT << 4) + VDM_TRANSFER_OFFSET)
#define INFOBLOCK_OFFSET(x) ((SEG((x)) << 4) + OFF((x)) - TRANSFER_ADDRESS)

#define IS_LINEAR_MODE(x) ((x)->bitsPerPlane >= 8)

VOID
InitializeModeTable(
    PVOID HwDeviceExtension
    );

BOOLEAN
ValidateVbeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVGA_INFO_BLOCK InfoBlock
    );

VOID
UpdateRegistry(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PWSTR ValueName,
    PUCHAR Value
    );

ULONG
GetVideoMemoryBaseAddress(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEOMODE pRequestedMode
    );

VP_STATUS
VBESetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT VesaModeNumber
    );

USHORT
VBEGetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VBEGetModeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    USHORT ModeNumber,
    PMODE_INFO_BLOCK ModeInfoBlock
    );

ULONG
VBESaveState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCHAR StateBuffer
    );

VP_STATUS
VBERestoreState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PCHAR StateBuffer,
    ULONG Size
    );

VP_STATUS
VBESetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect,
    USHORT WindowNumber
    );

USHORT
VBEGetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect
    );

USHORT
VBEGetScanLineLength(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VesaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    USHORT ModeNumber
    );

PCHAR
SaveFrameBuffer(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVESA_INFO pVesaInfo
    );

BOOLEAN
IsSavedModeVesa(
    PVIDEO_HARDWARE_STATE HardwareState
    );

VP_STATUS
VesaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

ULONG
RestoreFrameBuffer(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVESA_INFO pVesaInfo,
    PCHAR FrameBufferData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\oldvga.c ===
in DRIVER_ENTRY
    }

    DeviceExtension->CommandPhase = ScrIdle;



NTSTATUS
ScreenInitializeDevice(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS Status;

    //
    // determine hardware configuration.
    //

    UCHAR videoType;            // possible VGA video type

    KIRQL OldIrql;

    UCHAR Color = TRUE;         // assume color adapter present

    //
    // Start by assuming there is no adapter
    //

    DeviceExtension->VideoHardware.fVideoType = VDHERROR_NO_ADAPTER;

    //
    // Determine which adapter is present by testing the presence of memory.
    // A0000 isn't accessible because EGA and VGA come up in character mode.
    // put it in graphics mode and then test for memory at A0000.
    //

    KeRaiseIrql(POWER_LEVEL,
                &OldIrql);
    EnableA0000();
    KeLowerIrql(OldIrql);

    if (MemoryPresent(MEM_EGA_OR_VGA)) {

        //
        // A0000 is present so we must either have an EGA or a VGA.
        // We must now determine which one it is.
        //


        videoType = VGA_COLOR;



        if (videoType == VGA_CANNOT_DETERMINE) {


        } else {        // We are in VGA mode

            //
            // determine and record VGA information; always 256K
            //

            DeviceExtension->VideoHardware.memory = 256L * 1024L;

            switch (videoType) {

            case VGA_COLOR:

                DeviceExtension->VideoHardware.display = Color8512_8513;
                DeviceExtension->VideoHardware.popupMode = ModeIndex_VGA3p;
                DeviceExtension->VideoHardware.fVideoType ^= VGC_BIT;

                break;

            case VGA_MONO:

                DeviceExtension->VideoHardware.display = Color8512_8513;
                DeviceExtension->VideoHardware.popupMode = ModeIndex_VGA3p;
                DeviceExtension->VideoHardware.fVideoType ^= VGC_BIT;

                break;

            case VGA_NODISPLAY:

                DeviceExtension->VideoHardware.display = NoDisplay;
                DeviceExtension->VideoHardware.popupMode = ModeIndex_VGA3p;

                DeviceExtension->VideoHardware.fVideoType = NODISPLAY_BIT;

                break;

            }
        }
    }

    KeRaiseIrql(POWER_LEVEL,
                &OldIrql);
    DisableA0000(Color);
    KeLowerIrql(OldIrql);
    
    if (DeviceExtension->VideoHardware.fVideoType == NODISPLAY_BIT) {

        return STATUS_NO_SUCH_DEVICE;

    }

    //
    // set up the ROM font addresses
    //

    InitializeFonts(DeviceExtension);

    //
    // set the mode.
    //

    Status = PrepareForSetMode(DeviceExtension,
                               DeviceExtension->VideoHardware.popupMode);

    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    KeRaiseIrql(POWER_LEVEL,
                &OldIrql);

    SetHWMode(DeviceExtension,
              DeviceExtension->VideoHardware.popupMode,
              TRUE);

    //
    // Setting up the cursor position and initializing the CLUT only needs
    // to be done for VGA mode.
    //

    //
    // set up the cursor position and type
    //
{
    SCREEN_CURSOR_POSITION CursorPosition;
    SCREEN_CURSOR_TYPE CursorType;

    CursorPosition.Column = 0;
    CursorPosition.Row = 0;
    SetCursorPosition(DeviceExtension,
                      &CursorPosition);

    CursorType.TopScanLine = (USHORT)
                            (Fonts[DeviceExtension->RomFontIndex].PelRows-2);
    CursorType.BottomScanLine = 31;
    CursorType.CursorVisible = TRUE;
    SetCursorType(DeviceExtension,
                  &CursorType);
}

    //
    // initialize the CLUT.
    //

    SetColorLookup(DeviceExtension,
                   (PSCREEN_CLUT) &InitialClutVGA,
                   TRUE);

    //
    // initialize the palette registers.
    //

    SetPaletteReg(DeviceExtension,
                  (PSCREEN_PALETTE_DATA) &InitialPaletteVGA,
                  TRUE);

    KeLowerIrql(OldIrql);

    return STATUS_SUCCESS;
}


BOOLEAN
MemoryPresent(
    IN ULONG Address
    )

/*++

Routine Description:

    This routine returns TRUE if the specified memory is present.  It
    maps a view of the requested address, reads the original ulong, writes
    a different one, reads it to make sure its the written value, then
    restores the original value.

Arguments:

    Address - Physical address to check

Return Value:

    TRUE if specified memory is present, FALSE if not.

--*/

{
    BOOLEAN GoodMemory = FALSE;         // assume no memory at location
    volatile PULONG VideoMemory;
    ULONG TestValue;                    // memory read/write test value
    ULONG OriginalValue;                // original value at tested location
    PVOID Base;

    Base = MmMapIoSpace((PHYSICAL_ADDRESS) Address,
                        sizeof (ULONG),
                        FALSE);

    //
    // Read a ulong from the address and save it.  write
    // a different ulong to the address.  read from the address and see if
    // it matches the written ulong.
    //

    VideoMemory = (PULONG) Base;
    TestValue   = 0xBBBBBBBB;

    if ((OriginalValue = *VideoMemory) == 0xBBBBBBBB) {

       TestValue >>= 1;

    }

    *VideoMemory = TestValue;           // write out a test value

    if (GoodMemory = (BOOLEAN) (*VideoMemory == TestValue) ) {

       *VideoMemory = OriginalValue;    // restore value

    }

    MmUnmapIoSpace(Base,
                   sizeof (ULONG));

    return GoodMemory;
}


VOID
InitializeFonts(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This routine determines the addresses of the ROM fonts.

Arguments:

    DeviceExtension - pointer to device extension for this driver

Return Value:

    none

--*/

{

    PHYSICAL_ADDRESS PVB;
    PUCHAR RomPtr;
    ULONG RomFontLen,ROMSrchLen;
    ULONG i;

    //
    // Search through ROM to find 8x8, 8x14, 8x16, 9x14, and 9x16 fonts
    // ROM fonts are located at physical addresses:
    //        C0000 - EGA and PS/2 Adapter
    //        E0000 - VGA
    //

    for (PVB = 0xE0000, RomFontLen = 0xFFFF, ROMSrchLen = 0xFFF0;
         PVB >= 0xC0000;
         PVB -= 0x20000, RomFontLen -= 0x8000, ROMSrchLen = 0x7FF0 ) {

        RomPtr = MmMapIoSpace(PVB, RomFontLen, FALSE);

        //
        //  Locate 8x8 ROM font on EGA and VGA
        //

        for (i = 0; i < ROMSrchLen; i++) {

            while ( (i < ROMSrchLen) && (RomPtr[i] != (UCHAR)0x7E) ) {

                i++;

            }

            if ( i < ROMSrchLen) {

                if ( (RomPtr[i+1] == (UCHAR)0x81) &&
                     (RomPtr[i+2] == (UCHAR)0xA5) &&
                     (RomPtr[i+3] == (UCHAR)0x81) ) {

                    if (!Fonts[ROM_FONT_8x8].PVB && RomPtr[i+4] ==
                        (UCHAR)0xBD) {

                        Fonts[ROM_FONT_8x8].PVB = PVB + i - 8;

                    } else {

//
// Locate 8x14 ROM font on EGA, VGA, and PS/2 adapter only
//

                        if ( (RomPtr[i+4] == (UCHAR)0x81) &&
                             (RomPtr[i+5] == (UCHAR)0xBD) &&
                             (RomPtr[i+6] == (UCHAR)0x99) &&
                             (RomPtr[i+7] == (UCHAR)0x81) ) {

                            // e3f40

                            if (!Fonts[ROM_FONT_8x14].PVB &&
                                RomPtr[i+8] != (UCHAR)0x81) {

                                    Fonts[ROM_FONT_8x14].PVB = PVB  + i- 16;

                            } else {

//
// Locate 8x16 ROM font on VGA, and PS/2 adapter only
//

                          // e3e04
                                if ( !Fonts[ROM_FONT_8x16].PVB &&
                                    RomPtr[i+8] == (UCHAR)0x81 ) {

                                    Fonts[ROM_FONT_8x16].PVB = PVB + i - 18;

                                }
                            }

                        } // if ( (RomPtr[i+4] == (UCHAR)0x81) &&

                    } // if (!Fonts[ROM_FONT_8x8].PVB && RomPtr[i+4]

                } // if ( (RomPtr[i+1] == (UCHAR)0x81) &&

            } // if ( i < ROMSrchLen)

        } // end for loop Locate 8x8, 8x14, 8x16


//
// Locate 9x14 ROM font on EGA, VGA, and PS/2 adapter only
//

        for ( i = 0; i < ROMSrchLen; i++ ) {

            while ( (i < ROMSrchLen) && (RomPtr[i] != (UCHAR)0x1D) ) {

                i++;

            }

            if ( i < ROMSrchLen) {

                if ( ( RomPtr[i+1] == (UCHAR)0x00 ) &&
                     ( RomPtr[i+2] == (UCHAR)0x00 ) &&
                     ( RomPtr[i+3] == (UCHAR)0x00 ) &&
                     ( RomPtr[i+4] == (UCHAR)0x00 ) ) {

                    if ( !Fonts[ROM_FONT_9x14].PVB &&
                         ( RomPtr[i+5] == (UCHAR)0x24 ) &&
                         ( RomPtr[i+6] == (UCHAR)0x66 ) ) {

                         Fonts[ROM_FONT_9x14].PVB = PVB + i;
                    }

//
// Locate 9x16 ROM font on VGA, and PS/2 adapter only
//

                    if (!Fonts[ROM_FONT_9x16].PVB &&
                        (RomPtr[i+5] == (UCHAR)0x00) &&
                        (RomPtr[i+6] == (UCHAR)0x24) ) {

                        Fonts[ROM_FONT_9x16].PVB = PVB + i;

                    }
                }
            }
        } /* Locate 9x14, 9x16 */

        MmUnmapIoSpace(RomPtr,RomFontLen);

   } // Search next ROM area for fonts */

    if (!Fonts[ROM_FONT_8x8].PVB)
        Dprint(1, ("Fonts[ROM_FONT_8x8] not found\n"));
    if (!Fonts[ROM_FONT_8x14].PVB)
        Dprint(1, ("Fonts[ROM_FONT_8x14] not found \n"));
    if (!Fonts[ROM_FONT_8x16].PVB)
        Dprint(1, ("Fonts[ROM_FONT_8x16] not found \n"));
    if (!Fonts[ROM_FONT_9x14].PVB)
        Dprint(1, ("Fonts[ROM_FONT_9x14] not found \n"));
    if (!Fonts[ROM_FONT_9x16].PVB)
        Dprint(1, ("Fonts[ROM_FONT_9x16] not found \n"));

    //
    // we happen to know that the 8x8 font is loaded during boot.  we can't
    // call SetFont at this point because it requires data initialized by
    // SetMode.  But SetMode requires data initialized by SetFont.  so we
    // just set up RomFontIndex here manually.
    //

    DeviceExtension->RomFontIndex = 1;
}






NTSTATUS
ScreenDispatch(

    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    KIRQL OldIrql;
    PDEVICE_EXTENSION DeviceExtension;
    BOOLEAN PowerFailed = FALSE;
    PVOID SystemBuffer;

    case IRP_MJ_CLOSE:

        Dprint(2, ("VgaDispatch - CLose\n"));

        Status = ZwUnmapViewOfSection(NtCurrentProcess(),
                                      DeviceExtension->RealFrameBase);

        if (NT_SUCCESS(Status)) {

            ZwClose(DeviceExtension->FrameSection);

        }

        break;


        case IOCTL_SCR_QUERY_FRAME_BUFFER:

            Dprint(2, ("VgaDispatch - QueryFrameBuffer\n"));

            //
            // check for adequate buffer length
            //

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_FRAME_BUFFER_INFO)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

            //
            // everything's ok, return the info.
            //

                ((PSCREEN_FRAME_BUFFER_INFO) SystemBuffer)->FrameBase =
                        DeviceExtension->FrameBase;

                ((PSCREEN_FRAME_BUFFER_INFO) SystemBuffer)->FrameLength =
                        DeviceExtension->FrameLength;

                Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = sizeof(SCREEN_FRAME_BUFFER_INFO);

            }

            break;


        case IOCTL_SCR_QUERY_AVAIL_MODES:

            Dprint(2, ("VgaDispatch - QueryAvailableModes\n"));

            Status = GetAvailableModes(DeviceExtension,
                        RequestPacket->OutputBufferLength,
                                       SystemBuffer,
                                       &Irp->IoStatus.Information);

            break;


        case IOCTL_SCR_QUERY_NUM_AVAIL_MODES:

            Dprint(2, ("VgaDispatch - QueryNumAvailableModes\n"));

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_NUM_MODES)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                Status = GetNumberOfAvailableModes(DeviceExtension,
                              &(((PSCREEN_NUM_MODES)SystemBuffer)->NumModes));

                Irp->IoStatus.Information = sizeof(SCREEN_NUM_MODES);

            }

            break;


        case IOCTL_SCR_QUERY_CURRENT_MODE:

            Dprint(2, ("VgaDispatch - QueryCurrentMode\n"));


            //
            // Statistics compilation
            //

            ScreenIoctlStats.QueryCurrentMode++;

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_MODE_INFORMATION)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                Status = GetCurrentMode(DeviceExtension,
                    RequestPacket->OutputBufferLength,
                                        SystemBuffer);

                Irp->IoStatus.Information = sizeof(SCREEN_MODE_INFORMATION);

            }

            break;


        case IOCTL_SCR_SET_CURRENT_MODE:

            Dprint(2, ("VgaDispatch - SetCurrentModes\n"));

            if (RequestPacket->InputBufferLength <
                sizeof(ULONG)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                //
                // validate mode and set up device extension variables
                //

                Status = PrepareForSetMode(DeviceExtension,
                                           *((PULONG) SystemBuffer));

                if (NT_SUCCESS(Status)) {

                    //
                    // unmap old frame buffer and set up new one.
                    //

                    Status = UpdateFrameBuffer(DeviceExtension,
                                               TRUE,
                                               *((PULONG) SystemBuffer));

                    if (NT_SUCCESS(Status)) {

                        //
                        // update hardware
                        //

                        SetHWMode(DeviceExtension,
                                  *((PULONG) SystemBuffer),
                                  TRUE);

                    }
                }
            }

            break;


        case IOCTL_SCR_QUERY_AVAIL_FONTS:

            Dprint(2, ("VgaDispatch - QueryAvailableFont\n"));

            if (DeviceExtension->CurrentMode->fbType & SCREEN_MODE_GRAPHICS) {

                //
                // Text mode only
                //

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = GetAvailableFonts(DeviceExtension,
                        RequestPacket->OutputBufferLength,
                                           SystemBuffer,
                                           &Irp->IoStatus.Information);

            }

            break;


        case IOCTL_SCR_QUERY_NUM_AVAIL_FONTS:

            Dprint(2, ("VgaDispatch - QueryNumAvailableFonts\n"));

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_NUM_FONTS)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if (DeviceExtension->CurrentMode->fbType &
                    SCREEN_MODE_GRAPHICS) {                 // Text mode only

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    Status = GetNumberOfAvailableFonts(DeviceExtension,
                        &((PSCREEN_NUM_FONTS)SystemBuffer)->NumFonts);

                    Irp->IoStatus.Information = sizeof(SCREEN_NUM_FONTS);

                }
            }

            break;


        case IOCTL_SCR_QUERY_CURRENT_FONT:

            Dprint(2, ("VgaDispatch - QueryCurrentFont\n"));

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_FONT_INFORMATION)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if (DeviceExtension->CurrentMode->fbType &
                    SCREEN_MODE_GRAPHICS)  {                // Text mode only

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    Status = GetCurrentFont(DeviceExtension,
                                            SystemBuffer);

                    Irp->IoStatus.Information =
                        sizeof(SCREEN_FONT_INFORMATION);
                }
            }

            break;


        case IOCTL_SCR_SET_CURRENT_FONT:

            Dprint(2, ("VgaDispatch - SetCurrentFont\n"));

            if (RequestPacket->InputBufferLength <
                sizeof(ULONG)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if ( ((*(PULONG)SystemBuffer) > ROM_FONTS_VGA) ||
                    ((*(PULONG)SystemBuffer) == 0) ||
                    (DeviceExtension->CurrentMode->fbType &
                    SCREEN_MODE_GRAPHICS))  {               // Text mode only

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    SCREEN_SET_FONT_INFORMATION FontInformation;

                    Status = SetFontSetUp(DeviceExtension,
                                          *(PULONG)SystemBuffer,
                                          &FontInformation);

                    SetFont(DeviceExtension,
                            FontInformation);

                    Status = SetFontCleanUp(*(PULONG)SystemBuffer,
                                            &FontInformation);

                }
            }

            break;


        case IOCTL_SCR_QUERY_CURSOR_POSITION:

            Dprint(2, ("VgaDispatch - QueryCursorPosition\n"));

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_CURSOR_POSITION)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if (DeviceExtension->CurrentMode->fbType &
                    SCREEN_MODE_GRAPHICS) {                 // Text mode only

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    Status = GetCursorPosition(DeviceExtension,
                                               SystemBuffer);

                    Irp->IoStatus.Information =
                        sizeof(SCREEN_CURSOR_POSITION);

                }
            }

        break;


        case IOCTL_SCR_SET_CURSOR_POSITION:

            Dprint(2, ("VgaDispatch - SetCursorPosition\n"));

            if (RequestPacket->InputBufferLength <
                sizeof(SCREEN_CURSOR_POSITION)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {
                        
                if ((DeviceExtension->CurrentMode->fbType &
                    SCREEN_MODE_GRAPHICS) ||                // Text mode only
                    (!CheckCursorPosition(SystemBuffer,
                                          DeviceExtension))) {

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    Status = STATUS_SUCCESS;

????                SetCursorPosition(DeviceExtension,
                                      (PSCREEN_CURSOR_POSITION) SystemBuffer);


                }
            }

            break;


        case IOCTL_SCR_QUERY_CURSOR_TYPE:

            Dprint(2, ("VgaDispatch - QueryCursorType\n"));

            if (RequestPacket->OutputBufferLength <
                sizeof(SCREEN_CURSOR_TYPE)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if (DeviceExtension->CurrentMode->fbType & 
                    SCREEN_MODE_GRAPHICS)  {                // Text mode only

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    Status = GetCursorType(DeviceExtension,
                                           SystemBuffer);

                    Irp->IoStatus.Information = sizeof(SCREEN_CURSOR_TYPE);

                }
            }

            break;


        case IOCTL_SCR_SET_CURSOR_TYPE:

            Dprint(2, ("VgaDispatch - SetCursorType\n"));

            if (RequestPacket->InputBufferLength <
                sizeof(SCREEN_CURSOR_TYPE)) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if ((DeviceExtension->CurrentMode->fbType &
                    SCREEN_MODE_GRAPHICS) ||                // Text mode only
                    (!CheckCursorType(SystemBuffer,
                                      DeviceExtension))) {

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    Status = STATUS_SUCCESS;

                    SetCursorType(DeviceExtension,
                                  (PSCREEN_CURSOR_TYPE) SystemBuffer);


                }
            }

            break;


        case IOCTL_SCR_SET_PALETTE_REGISTERS:

            Dprint(2, ("VgaDispatch - SetPaletteRegs\n"));

            Status = STATUS_SUCCESS;

            if (RequestPacket->InputBufferLength <
                (sizeof(SCREEN_PALETTE_DATA) + (sizeof(USHORT) *
                (((PSCREEN_PALETTE_DATA)SystemBuffer)->NumEntries-1)))) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if ((((PSCREEN_PALETTE_DATA)SystemBuffer)->FirstEntry >
                    SCREEN_MAX_PALETTE_COLORS ) ||          // valid 1st entry
                    (((PSCREEN_PALETTE_DATA)SystemBuffer)->NumEntries ==
                    0) ||                                   // Non-zero amount
                    (((PSCREEN_PALETTE_DATA)SystemBuffer)->FirstEntry +
                    ((PSCREEN_PALETTE_DATA)SystemBuffer)->NumEntries >
                    SCREEN_MAX_PALETTE_COLORS+1)) {

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    SetPaletteReg(DeviceExtension,
                                  (PSCREEN_PALETTE_DATA) SystemBuffer,
                                  TRUE);

                }
            }

            break;


        case IOCTL_SCR_SET_COLOR_REGISTERS:

            Dprint(2, ("VgaDispatch - SetColorRegs\n"));

            Status = STATUS_SUCCESS;

            if (RequestPacket->InputBufferLength <
                (sizeof(SCREEN_CLUT) + (sizeof(ULONG) *
                (((PSCREEN_CLUT)SystemBuffer)->NumEntries-1)))) {

                    Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                if ((((PSCREEN_CLUT)SystemBuffer)->NumEntries == 0) ||
                    (((PSCREEN_CLUT)SystemBuffer)->FirstEntry >
                    SCREEN_MAX_COLOR_REGISTERS) ||
                    (((PSCREEN_CLUT)SystemBuffer)->FirstEntry +
                    ((PSCREEN_CLUT)SystemBuffer)->NumEntries >
                    SCREEN_MAX_COLOR_REGISTERS+1)) {

                        Status = STATUS_INVALID_PARAMETER;

                } else {

                    SetColorLookup(DeviceExtension,
                                   (PSCREEN_CLUT) SystemBuffer,
                                   TRUE);

                }
            }

            break;

        }

        break;


    }

    Irp->IoStatus.Status = Status;

    if (PowerFailed) {

        Status = STATUS_PENDING;

    } else {

        DeviceExtension->CommandPhase = ScrIdle;    // this is only necessary
                                                    // for KeSynchronize ioctls
        KeSetEvent(&DeviceExtension->Event,0,FALSE);

        KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );

        IoCompleteRequest( Irp, IO_VIDEO_INCREMENT );

        KeLowerIrql( OldIrql );

    }

    return Status;
}


BOOLEAN
ScreenResetDevice(
    IN PDEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This routine resets the device after a powerfail.  It sets the mode to
    the current mode and the palette and color registers to what they were
    before the powerfail.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    For now simply return TRUE.

--*/

{
    KIRQL OldIrql;

    KeRaiseIrql(POWER_LEVEL,
                &OldIrql);

#ifdef SCREEN_POWER_RECOVERY
    if (DeviceExtension->ScreenPowerFailed == TRUE) {

        KeLowerIrql( OldIrql );
        return TRUE;

    }
#endif // POWER_RECOVERY

    SetHWMode(DeviceExtension,
              DeviceExtension->ModeIndex,
              FALSE);

    if (!( DeviceExtension->CurrentMode->fbType & SCREEN_MODE_GRAPHICS ) ) {

        SetHWFontRegs(DeviceExtension,
                      Fonts[DeviceExtension->RomFontIndex].PelRows);

        SetCursorPosition(DeviceExtension,
                          &DeviceExtension->CursorPosition);

        SetCursorType(DeviceExtension,
                      &DeviceExtension->CursorType);
    }

    SetColorLookup(DeviceExtension,
                   (PSCREEN_CLUT) &DeviceExtension->Clut,
                   FALSE);

    SetPaletteReg(DeviceExtension,
                  (PSCREEN_PALETTE_DATA) &DeviceExtension->Palette,
                  FALSE);

    KeLowerIrql(OldIrql);
    return TRUE;
}


static
VOID
ScreenUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is the unload routine for the screen disk device driver.
    It performs no operation.

Arguments:

    DriverObject - Supplies a pointer to the driver object that describes
                   this driver.

Return Value:

    None.

--*/

{

    DBG_UNREFERENCED_PARAMETER(DriverObject);
    return;
}


#ifdef SCREEN_POWER_RECOVERY

VOID
ScreenPowerFail(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp, 
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called when the power fails.  It calls the routine
    to reset the device and restart any operations that write to the
    device.  It also completes any operations that were pending due to
    a powerfail.

Arguments:

    Dpc - Pointer to DPC object.
    DeviceObject - Pointer to the device object.
    Irp - Pointer to Irp.
    Context - Action to take in DCP.

Return Value:

    None.

--*/

{
    BOOLEAN PowerFailed;
    PDEVICE_EXTENSION DeviceExtension;
    KIRQL OldIrql;

    DeviceExtension = DeviceObject->DeviceExtension;

    //
    // set ScreenPowerFailed to FALSE.
    //

    KeRaiseIrql(POWER_LEVEL,
                &OldIrql);

    DeviceExtension->ScreenPowerFailed = FALSE;
    KeLowerIrql( OldIrql );

    PowerFailed = KeSynchronizeExecution(
        &DeviceExtension->ScreenInterruptObject,
                                         ScreenPowerReset,
                                         DeviceExtension);

    if (PowerFailed == FALSE) {

        DeviceExtension->CommandPhase = ScrIdle;

        KeSetEvent(&DeviceExtension->Event,
                   0,
                   FALSE);

        KeRaiseIrql(DISPATCH_LEVEL,
                    &OldIrql);

        IoCompleteRequest(Irp,
                          IO_VIDEO_INCREMENT);

        KeLowerIrql(OldIrql);

    }
}


BOOLEAN
ScreenPowerReset(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine reinitializes the device after a powerfail and restarts
    any operation that was writing to the device.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

Return Value:

    Whether the power failed during the reset.

--*/

{
    PDEVICE_EXTENSION DeviceExtension;
    BOOLEAN PowerFailed;

    DeviceExtension = DeviceObject->DeviceExtension;

    //
    // reset the device.  this sets the mode, palette regs, and CLUT to what
    // they were before the powerfail.
    //

    PowerFailed = ScreenResetDevice(DeviceExtension);

    if (PowerFailed) {

        return TRUE;

    }

    //
    // restart operation
    //

    if (DeviceExtension->CommandPhase != ScrIdle) {

        return WriteToDevice(DeviceObject);

    }

    return FALSE;
}

#endif // POWER_RECOVERY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\vesa.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    vesa.c

Abstract:

    This module implements VESA support.

Author:

    Erick Smith (ericks) Sep. 2000

Environment:

    kernel mode only

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"
#include "vesa.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,ValidateVbeInfo)
#pragma alloc_text(PAGE,InitializeModeTable)
#pragma alloc_text(PAGE,UpdateRegistry)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VesaSaveHardwareState)
#pragma alloc_text(PAGE,GetVideoMemoryBaseAddress)
#pragma alloc_text(PAGE,RaiseToPower2)
#pragma alloc_text(PAGE,RaiseToPower2Ulong)
#pragma alloc_text(PAGE,IsPower2)
#pragma alloc_text(PAGE,VBESetMode)
#pragma alloc_text(PAGE,VBEGetMode)
#pragma alloc_text(PAGE,VBEGetModeInfo)
#pragma alloc_text(PAGE,VBESaveState)
#pragma alloc_text(PAGE,VBERestoreState)
#pragma alloc_text(PAGE,VBESetDisplayWindow)
#pragma alloc_text(PAGE,VBEGetDisplayWindow)
#pragma alloc_text(PAGE,VBEGetScanLineLength)
#pragma alloc_text(PAGE,IsSavedModeVesa)
#pragma alloc_text(PAGE,VesaSaveHardwareState)
#pragma alloc_text(PAGE,VesaRestoreHardwareState)
#pragma alloc_text(PAGE,SaveFrameBuffer)
#pragma alloc_text(PAGE,RestoreFrameBuffer)
#endif

USHORT
RaiseToPower2(
    USHORT x
    )

{
    USHORT Mask = x;

    if (Mask & (Mask - 1)) {

        Mask = 1;

        while (Mask < x && Mask != 0) {
            Mask <<= 1;
        }
    }

    return Mask;
}

ULONG
RaiseToPower2Ulong(
    ULONG x
    )

{
    ULONG Mask = x;

    if (Mask & (Mask - 1)) {

        Mask = 1;

        while (Mask < x && Mask != 0) {
            Mask <<= 1;
        }
    }

    return Mask;
}

BOOLEAN
IsPower2(
    USHORT x
    )

{
    return( !(x & (x- 1)) );
}

VOID
UpdateRegistry(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PWSTR ValueName,
    PUCHAR Value
    )

/*++

--*/

{
    ULONG Len = (strlen(Value) + 1) * 2;
    PWSTR WideString;

    WideString = VideoPortAllocatePool(hwDeviceExtension,
                                       VpPagedPool,
                                       Len,
                                       ' agV');

    if (WideString) {

        PWSTR ptr = WideString;

        while(*Value) {
            *ptr++ = (WCHAR) *Value++;
        }
        *ptr = 0;

        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       ValueName,
                                       WideString,
                                       Len);

        VideoPortFreePool(hwDeviceExtension, WideString);
    }
}

BOOLEAN
IsVesaBiosOk(
    PVIDEO_PORT_INT10_INTERFACE pInt10,
    USHORT OemSoftwareRev,
    PUCHAR OemVendorName,
    PUCHAR OemProductName,
    PUCHAR OemProductRev
    )

{

    VideoDebugPrint((1, "OemSoftwareRev = %d\n",   OemSoftwareRev));
    VideoDebugPrint((1, "OemVendorName  = '%s'\n", OemVendorName));
    VideoDebugPrint((1, "OemProductName = '%s'\n", OemProductName));
    VideoDebugPrint((1, "OemProductRev  = '%s'\n", OemProductRev));

    //
    // The ATI ArtX boxes currently have a VESA Bios bug where
    // they indicate they support linear mode access when
    // they don't.  Fail these boards.
    //

    if ((strcmp(OemProductName, "ATI S1-370TL") == 0) ||
        (strcmp(OemProductName, "ArtX I") == 0)) {

        return FALSE;
    }

    //
    // Several 3dfx boards have buggy vesa bioses.  The mode set
    // works, but the display is corrupted.
    //

    if ((strcmp(OemProductName, "Voodoo4 4500 ") == 0) ||
        (strcmp(OemProductName, "Voodoo3 3000 LC ") == 0) ||
        (strcmp(OemProductName, "Voodoo3 2000 LC ") == 0) || 
        (strcmp(OemProductName, "3Dfx Banshee") == 0)) {

        return FALSE;
    }

    //
    // Matrox G100 boards with rev 1.05 bioses can't set vesa modes.
    // We hang in the bios.
    //

    if ((strcmp(OemProductName, "MGA-G100") == 0) &&
        (OemSoftwareRev == 0x105)) {

        //
        // We must also disable 800x600x16 color mode for this
        // device.  This makes the assumption that the mode we
        // are deleting is the last mode in our table.
        //

        NumVideoModes--;

        return FALSE;
    }

    //
    // We have seen at least on SIS 5597 part which returns a bad
    // linear address.  Lets disable these parts.
    //

    if (strcmp(OemProductName, "SiS 5597") == 0) {

        return FALSE;
    }

    //
    // We found a bad nVidia GeForce MX part.  It hangs in the bios
    // on boot.
    //

    if ((strcmp(OemVendorName, "NVidia Corporation") == 0) &&
        (strcmp(OemProductName, "NV11 (GeForce2) Board") == 0) &&
        (strcmp(OemProductRev, "Chip Rev B2") == 0) &&
        (OemSoftwareRev == 0x311)) {

        //
        // This bios "may" be buggy, but in an effort to not kill
        // vesa support on all GeForce MX boards, lets also look at
        // the version string embedded in the bios.
        //
        // We know the bad bios's have the following string at location
        // c000:0159:
        //
        // "Version 3.11.01.24N16"
        //
        // Lets read from this location and try to match on this string
        //

        UCHAR Version[22];
        pInt10->Int10ReadMemory(pInt10->Context,
                                (USHORT)0xC000,
                                (USHORT)0x0159,
                                Version,
                                21);

        Version[21] = 0;

        if (strcmp(Version, "Version 3.11.01.24N16") == 0) {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
ValidateVbeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVGA_INFO_BLOCK InfoBlock
    )

/*++

Notes:

    This routine makes the assumption that the InfoBlock is still
    valid in the VDM transfer area.

--*/

{
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    BOOLEAN UseVesa = FALSE;

    pInt10 = &hwDeviceExtension->Int10;

    if (InfoBlock->VesaSignature == 'ASEV') {

        PUCHAR OemString;
        UCHAR OemStringBuffer[80];
        ULONG MemorySize;

        //
        // Capture OEM String
        //

        pInt10->Int10ReadMemory(pInt10->Context,
                                (USHORT)SEG(InfoBlock->OemStringPtr),
                                (USHORT)OFF(InfoBlock->OemStringPtr),
                                OemStringBuffer,
                                80);

        OemString = OemStringBuffer;

        VideoDebugPrint((1, "*********************************************\n"));
        VideoDebugPrint((1, "  VBE Signature:      VESA\n"));
        VideoDebugPrint((1, "  VBE Version:        %d.%02d\n",
                            InfoBlock->VbeVersion >> 8,
                            InfoBlock->VbeVersion & 0xff));
        VideoDebugPrint((1, "  OEM String:         %s\n",
                             OemString));

        if (InfoBlock->TotalMemory < 16) {

            //
            // If less than 1 meg, display in KB
            //

            VideoDebugPrint((1, "  Total Memory:       %dKB\n",
                                InfoBlock->TotalMemory * 64));

        } else {

            //
            // Else display in MB
            //

            VideoDebugPrint((1, "  Total Memory:       %dMB\n",
                                InfoBlock->TotalMemory / 16));
        }

        if (InfoBlock->VbeVersion >= 0x102) {

            UCHAR OemVendorName[80];
            UCHAR OemProductName[80];
            UCHAR OemProductRev[80];

            pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)SEG(InfoBlock->OemVendorNamePtr),
                                    (USHORT)OFF(InfoBlock->OemVendorNamePtr),
                                    OemVendorName,
                                    80);

            pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)SEG(InfoBlock->OemProductNamePtr),
                                    (USHORT)OFF(InfoBlock->OemProductNamePtr),
                                    OemProductName,
                                    80);

            pInt10->Int10ReadMemory(pInt10->Context,
                                    (USHORT)SEG(InfoBlock->OemProductRevPtr),
                                    (USHORT)OFF(InfoBlock->OemProductRevPtr),
                                    OemProductRev,
                                    80);

            OemVendorName[79] = 0;
            OemProductName[79] = 0;
            OemProductRev[79] = 0;

            VideoDebugPrint((1, "  OEM Software Rev:   %d.%02d\n",
                                InfoBlock->OemSoftwareRev >> 8,
                                InfoBlock->OemSoftwareRev & 0xff));
            VideoDebugPrint((1, "  OEM Vendor Name:    %s\n", OemVendorName));
            VideoDebugPrint((1, "  OEM Product Name:   %s\n", OemProductName));
            VideoDebugPrint((1, "  OEM Product Rev:    %s\n", OemProductRev));

            UseVesa = IsVesaBiosOk(pInt10,
                                   InfoBlock->OemSoftwareRev,
                                   OemVendorName,
                                   OemProductName,
                                   OemProductRev);

        }

        VideoDebugPrint((1, "*********************************************\n"));

#if 0
        //
        // It would be nice if we could dump the following info into the
        // registry.  But as the GDI code currently stands, if we add
        // ChipType or AdapterString info into the registry, we lose
        // fullscreen support.  This has to do with the way GDI currently
        // determines the fullscreen device.
        //
        // For now, lets just not add this registry info.
        //

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.ChipType",
                       OemString);

        //
        // Adapter String MUST be VGA.  Without it, the system won't
        // recognize this driver as the VGA driver.
        //

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.AdapterString",
                       "VGA");

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.DacType",
                       (InfoBlock->Capabilities & VBE_CAP_DAC_WIDTH_8BPP)
                           ? "8 bit" : "6 bit");

        UpdateRegistry(hwDeviceExtension,
                       L"HardwareInformation.BiosString",
                       OemProductRev);

        //
        // Store memory size in registry
        //

        MemorySize = InfoBlock->TotalMemory << 16;

        VideoPortSetRegistryParameters(hwDeviceExtension,
                                       L"HardwareInformation.MemorySize",
                                       &MemorySize,
                                       sizeof(ULONG));
#endif

    } else {

        VideoDebugPrint((0, "Invalid VBE Info Block.\n"));
    }

    return UseVesa;
}

VOID
InitializeModeTable(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    INT10_BIOS_ARGUMENTS BiosArguments;
    PVGA_INFO_BLOCK InfoBlock;
    PMODE_INFO_BLOCK ModeBlock;
    PUSHORT ModeTable;
    PUSHORT ModePtr;
    ULONG NumVesaModes;
    PVIDEOMODE VideoModePtr;
    LONG TotalMemory;
    ULONG VideoMemoryRequired;
    USHORT VbeVersion;
    PULONG Memory;
    ULONG AdditionalModes = 0;

    USHORT VdmSeg, VdmOff;
    VP_STATUS Status;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    ULONG Length = 0x1000;

    BOOLEAN LinearModeSupported;
    BOOLEAN ModeValid;

    hwDeviceExtension->Int10.Size = sizeof(VIDEO_PORT_INT10_INTERFACE);
    hwDeviceExtension->Int10.Version = 1;

    Status = VideoPortQueryServices(hwDeviceExtension,
                                    VideoPortServicesInt10,
                                    (PINTERFACE)&hwDeviceExtension->Int10);

    VgaModeList = ModesVGA;

    if (Status == NO_ERROR) {

        pInt10 = &hwDeviceExtension->Int10;

        pInt10->InterfaceReference(pInt10->Context);

        //
        // Get a chunk of memory in VDM area to use for buffers.
        //

        Status = pInt10->Int10AllocateBuffer(pInt10->Context,
                                             &VdmSeg,
                                             &VdmOff,
                                             &Length);

        if ((Status != NO_ERROR) || (Length < 0x1000)) {
            ASSERT(FALSE);
        }

        hwDeviceExtension->VdmSeg = VdmSeg;
        hwDeviceExtension->VdmOff = VdmOff;

        //
        // Allocate Memory
        //

        InfoBlock = VideoPortAllocatePool(hwDeviceExtension,
                                          VpPagedPool,
                                          sizeof(VGA_INFO_BLOCK) +
                                          sizeof(MODE_INFO_BLOCK) +
                                          256 +
                                          2, // space for a 0xffff terminator
                                          ' agV');

        if (InfoBlock) {

            ModeBlock = (PMODE_INFO_BLOCK)((ULONG_PTR)InfoBlock + sizeof(VGA_INFO_BLOCK));
            ModeTable = (PUSHORT)((ULONG_PTR)ModeBlock + sizeof(MODE_INFO_BLOCK));

            ModeTable[128] = 0xffff;  // make sure we have a mode terminator

            //
            // Get VESA mode information
            //

            InfoBlock->VesaSignature = '2EBV';

            pInt10->Int10WriteMemory(pInt10->Context,
                                     VdmSeg,
                                     VdmOff,
                                     InfoBlock,
                                     sizeof(VGA_INFO_BLOCK));

            //
            // Get SuperVGA support info
            //

            BiosArguments.Eax = 0x4f00;
            BiosArguments.Edi = VdmOff;
            BiosArguments.SegEs = VdmSeg;

            pInt10->Int10CallBios(pInt10->Context, &BiosArguments);

            pInt10->Int10ReadMemory(pInt10->Context,
                                    VdmSeg,
                                    VdmOff,
                                    InfoBlock,
                                    sizeof(VGA_INFO_BLOCK));

            TotalMemory = InfoBlock->TotalMemory * 0x10000;
            VbeVersion = InfoBlock->VbeVersion;

            //
            // NOTE: We must call ValidateVbeInfo while the info block
            // is still in the transfer area.
            //

            if (ValidateVbeInfo(hwDeviceExtension, InfoBlock)) {

                //
                // Capture the list of mode numbers
                //

                pInt10->Int10ReadMemory(pInt10->Context,
                                        (USHORT)(InfoBlock->VideoModePtr >> 16),
                                        (USHORT)(InfoBlock->VideoModePtr & 0xffff),
                                        ModeTable,
                                        256);

                //
                // Count the number of VESA modes, and allocate memory for the
                // mode list.  The mode list is terminated by a -1.
                //

                ModePtr = ModeTable;
                NumVesaModes = 0;

                while (*ModePtr != 0xffff) {
                    NumVesaModes++;
                    ModePtr++;
                }

                if (NumVesaModes == 128) {

                    //
                    // Something is wrong.  We hit our hard coded terminator.
                    // Don't try to use vesa modes.
                    //

                    return;
                }

                VgaModeList = VideoPortAllocatePool(hwDeviceExtension,
                                                    VpPagedPool,
                                                    (NumVesaModes + NumVideoModes) *
                                                        sizeof(VIDEOMODE),
                                                    ' agV');

                if (VgaModeList == NULL) {

                    VideoDebugPrint((0, "failed to allocate %d bytes.\n",
                                     (NumVesaModes + NumVideoModes) * sizeof(VIDEOMODE)));

                    VgaModeList = ModesVGA;

                    //
                    // Perform clean up.
                    //

                    VideoPortFreePool(hwDeviceExtension, InfoBlock);

                    return;
                }

                //
                // Copy the existing constant VGA modes into our mode list table.
                //

                memmove(VgaModeList, ModesVGA, sizeof(VIDEOMODE) * NumVideoModes);

                //
                // Now populate the rest of the table based on the VESA mode
                // table.
                //

                VideoModePtr = VgaModeList + NumVideoModes;
                ModePtr = ModeTable;

                while (NumVesaModes--) {

                    ModeValid = FALSE;

                    //
                    // Get info about the VESA mode.
                    //

                    BiosArguments.Eax = 0x4f01;
                    BiosArguments.Ecx = *ModePtr;
                    BiosArguments.Edi = VdmOff;
                    BiosArguments.SegEs = VdmSeg;

                    pInt10->Int10CallBios(pInt10->Context, &BiosArguments);

                    if ((BiosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {

                        //
                        // Copy the mode information out of the csrss process
                        //

                        pInt10->Int10ReadMemory(pInt10->Context,
                                                VdmSeg,
                                                VdmOff,
                                                ModeBlock,
                                                sizeof(MODE_INFO_BLOCK));

                        //
                        // Make sure that this is a graphics mode, and
                        // that it is supported by this hardware.
                        //

                        if ((ModeBlock->ModeAttributes & 0x11) == 0x11) {

                            if ((VbeVersion >= 0x200) &&
                                (ModeBlock->PhysBasePtr) &&
                                (ModeBlock->ModeAttributes & 0x80)) {

                                LinearModeSupported = TRUE;

                            } else {

                                //
                                // Make sure banked modes are supported
                                //

                                ASSERT((ModeBlock->ModeAttributes & 0x40) == 0);
                                LinearModeSupported = FALSE;
                            }

                            //
                            // Only include this mode if the following are true:
                            //
                            //   1. The mode is an 8bpp or higher mode
                            //   2. The resolution is 640x480 or greater
                            //

                            if ((ModeBlock->XResolution >= 640) &&
                                (ModeBlock->YResolution >= 480) &&
                                (ModeBlock->NumberOfPlanes != 0) &&
                                (ModeBlock->BitsPerPixel >= 8)) {

                                //
                                // Fill in the video mode structure.
                                //

                                memset(VideoModePtr, 0, sizeof(VIDEOMODE));

                                if (ModeBlock->ModeAttributes & 0x08) {
                                    VideoModePtr->fbType |= VIDEO_MODE_COLOR;
                                }

                                if (ModeBlock->ModeAttributes & 0x10) {
                                    VideoModePtr->fbType |= VIDEO_MODE_GRAPHICS;
                                }

                                VideoModePtr->numPlanes = ModeBlock->NumberOfPlanes;
                                VideoModePtr->bitsPerPlane = ModeBlock->BitsPerPixel /
                                                                 ModeBlock->NumberOfPlanes;

                                if (VideoModePtr->bitsPerPlane == 16) {

                                    //
                                    // Check to see if this is really a 15 bpp mode
                                    //

                                    if (ModeBlock->GreenMaskSize == 5) {
                                        VideoModePtr->bitsPerPlane = 15;
                                    }
                                }

                                if (ModeBlock->XCharSize) {
                                    VideoModePtr->col = ModeBlock->XResolution / ModeBlock->XCharSize;
                                } else {
                                    VideoModePtr->col = 80;
                                }

                                if (ModeBlock->YCharSize) {
                                    VideoModePtr->row = ModeBlock->YResolution / ModeBlock->YCharSize;
                                } else {
                                    VideoModePtr->row = 25;
                                }

                                VideoModePtr->hres = ModeBlock->XResolution;
                                VideoModePtr->vres = ModeBlock->YResolution;
                                VideoModePtr->frequency = 1;
                                VideoModePtr->Int10ModeNumber = (((ULONG)*ModePtr) << 16) | 0x00004f02;
                                VideoModePtr->Granularity = ModeBlock->WinGranularity << 10;
                                VideoModePtr->NonVgaHardware = (ModeBlock->ModeAttributes & 0x20) ? TRUE : FALSE;

                                if (LinearModeSupported) {

                                    if (VbeVersion >= 0x300) {
                                        VideoModePtr->wbytes = ModeBlock->LinBytesPerScanLine;
                                    } else {
                                        VideoModePtr->wbytes = ModeBlock->BytesPerScanLine;
                                    }

                                    //
                                    // We first try to round up VideoMemoryRequired
                                    // to power of 2 so that we'll have a better 
                                    // chance to get it mapped as write combined 
                                    // on systems where MTRR is the only mechanism
                                    // for such mappings. If the rounded up value
                                    // is larger than the size of on-board memory
                                    // we'll at least round it up to page boundary
                                    //

                                    VideoMemoryRequired = RaiseToPower2Ulong(VideoModePtr->wbytes * VideoModePtr->vres);

                                    if(VideoMemoryRequired > (ULONG)TotalMemory) {
                                        VideoMemoryRequired = 
                                                   (VideoModePtr->wbytes * VideoModePtr->vres + 0x1000 - 1) & ~(0x1000 - 1);
                                    }
     
                                    VideoModePtr->sbytes = VideoMemoryRequired;
                                    VideoModePtr->PixelsPerScan = VideoModePtr->hres;
                                    VideoModePtr->banktype = NoBanking;

                                    VideoModePtr->Int10ModeNumber |= 0x40000000;

                                    VideoModePtr->MemoryBase = ModeBlock->PhysBasePtr;
                                    VideoModePtr->MemoryLength = VideoMemoryRequired;
                                    VideoModePtr->FrameOffset = 0;
                                    VideoModePtr->FrameLength = VideoMemoryRequired;
                                    VideoModePtr->fbType |= VIDEO_MODE_LINEAR;

                                } else {

                                    VideoModePtr->wbytes = RaiseToPower2(ModeBlock->BytesPerScanLine);

                                    //
                                    // Round up to bank boundary if possible.
                                    //
 
                                    VideoMemoryRequired = 
                                         (VideoModePtr->wbytes * VideoModePtr->vres + 0x10000 - 1) & ~(0x10000 - 1);

                                    if(VideoMemoryRequired > (ULONG)TotalMemory) {

                                        //
                                        // Round up to page boundary.
                                        //

                                        VideoMemoryRequired = 
                                             (VideoModePtr->wbytes * VideoModePtr->vres + 0x1000 - 1) & ~(0x1000 - 1);
                                    }

                                    VideoModePtr->sbytes = VideoMemoryRequired;
                                    VideoModePtr->PixelsPerScan = RaiseToPower2(VideoModePtr->hres);
                                    VideoModePtr->banktype = VideoBanked1RW;
                                    VideoModePtr->MemoryBase = 0xa0000;
                                    VideoModePtr->MemoryLength = 0x10000;
                                    VideoModePtr->FrameOffset = 0;
                                    VideoModePtr->FrameLength = 0x10000;
                                    VideoModePtr->fbType |= VIDEO_MODE_BANKED;
                                }

                                if (ModeBlock->ModeAttributes & 0x40) {
                                    VideoModePtr->banktype = NormalBanking;
                                }

                                //
                                // Make sure there is enough memory for the mode
                                //

                                if ((VideoModePtr->wbytes * VideoModePtr->vres) <= TotalMemory) {
                                    ModeValid = TRUE;
                                } 
                            }
                        }
                    }

                    if (ModeValid) {

                        VideoDebugPrint((1, "Supported: %dx%dx%dbpp\n",
                                            VideoModePtr->hres,
                                            VideoModePtr->vres,
                                            VideoModePtr->bitsPerPlane));

                        VideoModePtr++;
                        AdditionalModes++;

                    } else {

                        VideoDebugPrint((1, "Rejecting: %dx%dx%dbpp\n",
                                            ModeBlock->XResolution,
                                            ModeBlock->YResolution,
                                            ModeBlock->BitsPerPixel));
                    }

                    ModePtr++;
                }

                //
                // Lets check to see if we can map the memory for one of these modes.
                // If not, don't support the extended modes.
                //
                // Note: this is a temporary hack, until I can implent the correct
                // fix.
                //

                VideoModePtr--;

                if (IS_LINEAR_MODE(VideoModePtr)) {

                    PHYSICAL_ADDRESS Address;
                    UCHAR inIoSpace = 0;

                    Address.LowPart = VideoModePtr->MemoryBase;
                    Address.HighPart = 0;
                    
#if defined(PLUG_AND_PLAY)
                    inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
#endif
                    Memory = VideoPortGetDeviceBase(hwDeviceExtension,
                                                    Address,
                                                    0x1000,
                                                    inIoSpace);

                    if (Memory) {

                        VideoPortFreeDeviceBase(hwDeviceExtension, Memory);

                    } else {

                        //
                        // We can't map the memory, so don't expose the extra modes.
                        //

                        VideoDebugPrint((0, "vga.sys: Mapping 0x%x failed\n", VideoModePtr->MemoryBase));
                        AdditionalModes = 0;
                    }
                }
            }

            VideoPortFreePool(hwDeviceExtension, InfoBlock);
        }
    }

    NumVideoModes += AdditionalModes;

} // VgaInitialize()

ULONG
GetVideoMemoryBaseAddress(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEOMODE pRequestedMode
    )

/*++

Routine Description:

    This routine get the base address of the framebuffer of a given mode

Return Value:

    Base address of framebuffer

--*/

{
    PMODE_INFO_BLOCK ModeBlock;
    ULONG Length = 0x1000;
    INT10_BIOS_ARGUMENTS BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    ULONG RetValue;

    //
    // If this is not a vesa mode, just return the saved base address
    //

    if (pRequestedMode->fbType & VIDEO_MODE_BANKED) {

        return 0;
    }

    pInt10 = &hwDeviceExtension->Int10;

    if(!(pInt10->Size))
    {

        //
        // This structure should be initialized in VgaInitialize
        // If this function get called before VgaInitialize, just return 0;
        //

        return 0;
    }

    ModeBlock = VideoPortAllocatePool(hwDeviceExtension,
                                      VpPagedPool,
                                      sizeof(MODE_INFO_BLOCK),
                                      ' agV');

    if(!ModeBlock) {

        return 0;
    }

    //
    // Get info about the VESA mode.
    //

    BiosArguments.Eax = 0x4f01;
    BiosArguments.Ecx = pRequestedMode->Int10ModeNumber >> 16;
    BiosArguments.Edi = hwDeviceExtension->VdmOff;
    BiosArguments.SegEs = hwDeviceExtension->VdmSeg;

    pInt10->Int10CallBios(pInt10->Context, &BiosArguments);

    if ((BiosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {

        //
        // Copy the mode information out of the csrss process
        //

        pInt10->Int10ReadMemory(pInt10->Context,
                                hwDeviceExtension->VdmSeg,
                                hwDeviceExtension->VdmOff,
                                ModeBlock,
                                sizeof(MODE_INFO_BLOCK));

        RetValue = ModeBlock->PhysBasePtr;

     } else {

        RetValue = 0;
    }

    VideoPortFreePool(hwDeviceExtension, ModeBlock);
    return( RetValue );

}

VP_STATUS
VBEGetModeInfo(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    USHORT ModeNumber,
    PMODE_INFO_BLOCK ModeInfoBlock
    )
{
    INT10_BIOS_ARGUMENTS Int10BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    VP_STATUS status;

    pInt10 = &hwDeviceExtension->Int10;

    Int10BiosArguments.Eax = VBE_GET_MODE_INFO;
    Int10BiosArguments.Ecx = ModeNumber;
    Int10BiosArguments.Edi = hwDeviceExtension->VdmOff;
    Int10BiosArguments.SegEs = hwDeviceExtension->VdmSeg;

    status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

    if (status == NO_ERROR && 
        (Int10BiosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {

        //
        // Copy the mode information out of the csrss process
        //

        status = pInt10->Int10ReadMemory(pInt10->Context,
                                         hwDeviceExtension->VdmSeg,
                                         hwDeviceExtension->VdmOff,
                                         ModeInfoBlock,
                                         sizeof(MODE_INFO_BLOCK));

        if (status == NO_ERROR) {
            return NO_ERROR;
        }
    }

    return ERROR_INVALID_PARAMETER;
}

VP_STATUS
VBESetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    USHORT VesaModeNumber
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_SET_MODE;
    biosArguments.Ebx = VesaModeNumber;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) && 
        ((biosArguments.Eax & 0x0000FFFF) == VESA_STATUS_SUCCESS)) {

        return NO_ERROR;
    }

    return ERROR_INVALID_PARAMETER;
}

USHORT
VBEGetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_GET_MODE;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) && 
        ((biosArguments.Eax & 0x0000FFFF) == VESA_STATUS_SUCCESS)) {

        return (USHORT)(biosArguments.Ebx & 0x0000FFFF) ;

    } else {

        return 0;
    }
}

ULONG
VBESaveState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PCHAR StateBuffer
    )
{
    INT10_BIOS_ARGUMENTS Int10BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    VP_STATUS status;
    ULONG Size;

    pInt10 = &hwDeviceExtension->Int10;

    Int10BiosArguments.Eax = VBE_SAVE_RESTORE_STATE;
    Int10BiosArguments.Edx = 0x0;

    //
    // Save all the state
    //

    Int10BiosArguments.Ecx = 0x0F;

    status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

    if (status != NO_ERROR || 
        (Int10BiosArguments.Eax & 0xffff) != VESA_STATUS_SUCCESS) {

        return 0;
    }

    Size = (Int10BiosArguments.Ebx & 0xffff) << 6 ;

    //
    // if StateBuffer is NULL, the caller is only want to know the size 
    // of the buffer needed to store the state 
    //

    if (StateBuffer == NULL) {
        return Size;
    }

    Int10BiosArguments.Eax = VBE_SAVE_RESTORE_STATE;
    Int10BiosArguments.Edx = 0x1;
    Int10BiosArguments.Ecx = 0x0F;
    Int10BiosArguments.Ebx = hwDeviceExtension->VdmOff;
    Int10BiosArguments.SegEs = hwDeviceExtension->VdmSeg;

    status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

    if (status == NO_ERROR && 
        (Int10BiosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {

        //
        // Copy the state data of the csrss process
        //

        status = pInt10->Int10ReadMemory(pInt10->Context,
                                         hwDeviceExtension->VdmSeg,
                                         hwDeviceExtension->VdmOff,
                                         StateBuffer,
                                         Size);
        if (status == NO_ERROR) {

            return Size;
        }
    }

    return 0;
}

VP_STATUS
VBERestoreState(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PCHAR StateBuffer,
    ULONG Size
    )
{
    INT10_BIOS_ARGUMENTS Int10BiosArguments;
    PVIDEO_PORT_INT10_INTERFACE pInt10;
    VP_STATUS status;

    pInt10 = &hwDeviceExtension->Int10;

    //
    // Copy the state data to the csrss process
    //

    status = pInt10->Int10WriteMemory(pInt10->Context,
                                      hwDeviceExtension->VdmSeg,
                                      hwDeviceExtension->VdmOff,
                                      StateBuffer,
                                      Size);

    if (status != NO_ERROR) {
        return ERROR_INVALID_PARAMETER;
    }

    Int10BiosArguments.Eax = VBE_SAVE_RESTORE_STATE;
    Int10BiosArguments.Edx = 0x2;
    Int10BiosArguments.Ecx = 0x0f;
    Int10BiosArguments.Ebx = hwDeviceExtension->VdmOff;
    Int10BiosArguments.SegEs = hwDeviceExtension->VdmSeg;

    status = pInt10->Int10CallBios(pInt10->Context, &Int10BiosArguments);

    if (status != NO_ERROR ||
        (Int10BiosArguments.Eax & 0xffff) != VESA_STATUS_SUCCESS) {

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

VP_STATUS
VBESetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect,
    USHORT WindowNumber
    )

/*++

Routine Description:

    This routine set the position of the specified window in the
    frame buffer memory

Arguments:

    HwDeviceExtension  
        Pointer to the miniport driver's adapter information.

    WindowSelect
        0 for Window A and 1 for Window B

    WindowNumber
        Window number in video memory in window granularity units

Return Value:

    VP_STATUS

--*/

{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_WINDOW_CONTROL;
    biosArguments.Ebx = WindowSelect & 0x01;
    biosArguments.Edx = WindowNumber;

    status = VideoPortInt10(hwDeviceExtension, &biosArguments);

    if ((status != NO_ERROR) || 
        ((biosArguments.Eax & 0x0000FFFF) != VESA_STATUS_SUCCESS)) {

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

USHORT
VBEGetDisplayWindow(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR WindowSelect
    )

/*++

Routine Description:

    This routine set the position of the specified window in the
    frame buffer memory

Arguments:

    HwDeviceExtension
        Pointer to the miniport driver's adapter information.

    WindowSelect 
        0 for Window A and 1 for Window B

Return Value:

    Window number in video memory in window granularity units

--*/

{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_WINDOW_CONTROL;
    biosArguments.Ebx = (WindowSelect & 0x1) | 0x100;

    status = VideoPortInt10(hwDeviceExtension, &biosArguments);

    if ((status != NO_ERROR) || 
        ((biosArguments.Eax & 0x0000FFFF) != VESA_STATUS_SUCCESS)) {

        return 0;
    }

    return ((USHORT)(biosArguments.Edx & 0xFFFF));
}

USHORT
VBEGetScanLineLength(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )
{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;

    biosArguments.Eax = VBE_SCANLINE;
    biosArguments.Ebx = 0x1;

    status = VideoPortInt10(HwDeviceExtension, &biosArguments);

    if ((status == NO_ERROR) && 
        ((biosArguments.Eax & 0x0000FFFF) == VESA_STATUS_SUCCESS)) {

        return (USHORT)(biosArguments.Ebx & 0x0000FFFF) ;

    } else {

        return 0;
    }
}

VP_STATUS
VesaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    USHORT ModeNumber
    )
{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    VP_STATUS status;
    ULONG FrameBufferSize;
    PMODE_INFO_BLOCK ModeInfoBlock;
    PVESA_INFO pVesaInfo;

    hardwareStateHeader = 
            (PVIDEO_HARDWARE_STATE_HEADER) HardwareState->StateHeader;

    //
    // Zero out the structure
    //

    VideoPortZeroMemory((PVOID) hardwareStateHeader, 
                         sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Header field
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);
    hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

    hardwareStateHeader->VesaInfoOffset = 
                        (sizeof(VIDEO_HARDWARE_STATE_HEADER) + 7) & ~7;
 
    pVesaInfo = (PVESA_INFO)((PCHAR)hardwareStateHeader + 
                              hardwareStateHeader->VesaInfoOffset);

    //
    // Check the size needed to store hardware state
    //

    if (!(pVesaInfo->HardwareStateSize = 
                     VBESaveState(HwDeviceExtension, NULL))) {

        return ERROR_INVALID_FUNCTION;
    }

    //
    // In the case the size needed is too big just retrun failure
    // This should not happen in reality 
    // 

    if( VGA_TOTAL_STATE_SIZE < hardwareStateHeader->VesaInfoOffset + 
                               sizeof(VESA_INFO) + 
                               pVesaInfo->HardwareStateSize) {

        return ERROR_INVALID_FUNCTION;
    }

    //
    // Save hardware state
    //

    if (pVesaInfo->HardwareStateSize !=  
                   VBESaveState(HwDeviceExtension, pVesaInfo->HardwareState)) {

        return ERROR_INVALID_FUNCTION;
    }

    pVesaInfo->ModeNumber = ModeNumber;

    ModeInfoBlock = &(pVesaInfo->ModeInfoBlock);

    //
    // Retrieve mode info
    //

    if( VBEGetModeInfo(HwDeviceExtension, 
                       ModeNumber, 
                       ModeInfoBlock) != NO_ERROR) {

        return ERROR_INVALID_FUNCTION;
    }

    //
    // Save framebuffer
    //

    hardwareStateHeader->FrameBufferData = 
                         SaveFrameBuffer(HwDeviceExtension, pVesaInfo);

    if(hardwareStateHeader->FrameBufferData) {

        return NO_ERROR;

    } else {

        return ERROR_NOT_ENOUGH_MEMORY;  
    }
}

PCHAR
SaveFrameBuffer(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVESA_INFO pVesaInfo
    ) 
{
    ULONG FrameBufferSize, BankSize, CopySize, LeftSize, k;
    USHORT i;
    PCHAR FrameBufferData, pFrameBuffer;
    PHYSICAL_ADDRESS FBPhysicalAddress; 
    PMODE_INFO_BLOCK ModeInfoBlock;

    ModeInfoBlock = (PMODE_INFO_BLOCK) &(pVesaInfo->ModeInfoBlock);

    //
    // We'll try to get the current value of scanline size just in case a DOS 
    // app changed it. But we stay on the value we have if the vesa function
    // is not supported or failed.
    //

    i = VBEGetScanLineLength(hwDeviceExtension);

    if(i) { 
        
        ModeInfoBlock->BytesPerScanLine = i;
    }

    // 
    // 1) Calculate Framebuffer size
    // 

    //
    // Check if it is graphics or text mode. For text mode we simply
    // assume a size of 32k
    //

    if (ModeInfoBlock->ModeAttributes & 0x10) {

        FrameBufferSize = ModeInfoBlock->BytesPerScanLine * 
                          ModeInfoBlock->YResolution;

    } else {

        FrameBufferSize = 0x8000;
    }

    pVesaInfo->FrameBufferSize = FrameBufferSize;

    // 
    // 2) Determine the location and the size to be mapped and map it
    // 

    if (!(ModeInfoBlock->ModeAttributes & 0x10)) {

        //
        // This is a text mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xB8000;
        }

        BankSize = 0x8000;
        
    } else if (pVesaInfo->ModeNumber & 0x4000) {

        //
        // Linear framebuffer can be viewed as one large bank
        //

        FBPhysicalAddress.LowPart = ModeInfoBlock->PhysBasePtr;
        FBPhysicalAddress.HighPart = 0;
        BankSize = FrameBufferSize;

    } else {

        //
        // This is a banked mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xA0000;
        }

        BankSize = 1024 * ModeInfoBlock->WinSize;

        //
        // The bank size shouldn't exceed 64k. But we'd better guard 
        // the bad BIOS
        //

        if(BankSize > 0x10000 || BankSize == 0) {
            return NULL;
        }

        //
        // k will be used later to translate the window number 
        // in the unit of WinSize to the window number in the 
        // unit of WinGranularity
        //
 
        if (ModeInfoBlock->WinGranularity) {

           k = ModeInfoBlock->WinSize/ModeInfoBlock->WinGranularity;

        } else {

           k = 1;
        }
    }

    if(( pFrameBuffer = VideoPortGetDeviceBase(hwDeviceExtension, 
                                               FBPhysicalAddress,
                                               BankSize,
                                               FALSE)) == NULL ) {
        return NULL;
    }

    //
    // 3) Allocate memory for framebuffer data
    //
    
    if((FrameBufferData = VideoPortAllocatePool(hwDeviceExtension,
                                                VpPagedPool,
                                                FrameBufferSize,
                                                ' agV')) == NULL) {

        VideoPortFreeDeviceBase(hwDeviceExtension, pFrameBuffer);
        return NULL;
    }

    //
    // 4) Save famebuffer data
    //
    
    LeftSize = FrameBufferSize;

    for ( i = 0; LeftSize > 0; i++ ) {
    
        if (!(pVesaInfo->ModeNumber & 0x4000)) {

            // 
            // If this is a banked mode, switch to the right bank.
            // We set both Window A and B, as some VBEs have these 
            // set as separately available read and write windows.
            //

            VBESetDisplayWindow(hwDeviceExtension, 0, i * (USHORT)k);
            VBESetDisplayWindow(hwDeviceExtension, 1, i * (USHORT)k);
        }

        CopySize = (LeftSize < BankSize) ? LeftSize : BankSize;

        VideoPortMoveMemory(FrameBufferData + i * BankSize, 
                            pFrameBuffer, 
                            CopySize); 

        LeftSize -= CopySize;
    }

    // 
    // 5) Relese resource
    // 

    VideoPortFreeDeviceBase(hwDeviceExtension, pFrameBuffer);

    return FrameBufferData;
}

BOOLEAN
IsSavedModeVesa(
    PVIDEO_HARDWARE_STATE HardwareState
    )
{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;

    hardwareStateHeader = 
                (PVIDEO_HARDWARE_STATE_HEADER) HardwareState->StateHeader;

    if (hardwareStateHeader->Length == sizeof(VIDEO_HARDWARE_STATE_HEADER) &&
        hardwareStateHeader->VesaInfoOffset ) {

        return TRUE;

    } else {

        return FALSE;
    }
}


VP_STATUS
VesaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )
{

    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PMODE_INFO_BLOCK ModeInfoBlock;
    PVESA_INFO pVesaInfo;
    VP_STATUS status;

    hardwareStateHeader = 
           (PVIDEO_HARDWARE_STATE_HEADER) HardwareState->StateHeader;

    pVesaInfo = (PVESA_INFO)((PCHAR)hardwareStateHeader + 
                                    hardwareStateHeader->VesaInfoOffset);

    // 
    // 
    // 1) set the original mode
    // 2) restore hardware state 
    // 
    // Please note that both steps are necessary
    // 

    // 
    // We always use default CRTC value
    // 

    VBESetMode (HwDeviceExtension, pVesaInfo->ModeNumber & (~0x800));
              
    if ( VBERestoreState(HwDeviceExtension, 
                         pVesaInfo->HardwareState,
                         pVesaInfo->HardwareStateSize) != NO_ERROR ) {

        return ERROR_INVALID_FUNCTION;
    }

    ModeInfoBlock = (PMODE_INFO_BLOCK) &(pVesaInfo->ModeInfoBlock);

    //
    // Restore framebuffer data
    //

    if(RestoreFrameBuffer(HwDeviceExtension, 
                          pVesaInfo,
                          hardwareStateHeader->FrameBufferData)) {

        hardwareStateHeader->FrameBufferData = 0;
        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }
}

ULONG
RestoreFrameBuffer(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    PVESA_INFO pVesaInfo,
    PCHAR FrameBufferData
    ) 
{
    ULONG FrameBufferSize, BankSize, CopySize, LeftSize, k;
    PHYSICAL_ADDRESS FBPhysicalAddress; 
    USHORT i, WinA, WinB;
    PCHAR pFrameBuffer;
    PMODE_INFO_BLOCK ModeInfoBlock;

    if(!FrameBufferData) {

        return 0;
    }

    ModeInfoBlock = (PMODE_INFO_BLOCK) &(pVesaInfo->ModeInfoBlock);

    // 
    // 1) Get Framebuffer size
    // 

    FrameBufferSize = pVesaInfo->FrameBufferSize;

    if (!FrameBufferSize) {

        return 0;
    }

    // 
    // 2) Determine the location and the size to be mapped and map it
    // 

    if (!(ModeInfoBlock->ModeAttributes & 0x10)) {

        //
        // This is a text mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xB8000;
        }

        BankSize = 0x8000;
        
    } else if (pVesaInfo->ModeNumber & 0x4000) {

        //
        // Linear framebuffer can be viewed as one large bank
        //

        FBPhysicalAddress.LowPart = ModeInfoBlock->PhysBasePtr;
        FBPhysicalAddress.HighPart = 0;
        BankSize = FrameBufferSize;

    } else {

        //
        // This is a banked mode
        //

        FBPhysicalAddress.HighPart = 0;
        FBPhysicalAddress.LowPart = ModeInfoBlock->WinASegment << 4;

        if( FBPhysicalAddress.LowPart == 0) {

            FBPhysicalAddress.LowPart = 0xA0000;
        }

        BankSize = 1024 * ModeInfoBlock->WinSize;

        //
        // The bank size shouldn't exceed 64k. But we'd better guard 
        // the bad BIOS
        //

        if(BankSize > 0x10000 || BankSize == 0) {
            return 0;
        }

        //
        // k will be used later to translate the window number 
        // in the unit of WinSize to the window number in the 
        // unit of WinGranularity
        //
 
        if (ModeInfoBlock->WinGranularity) {

            k = ModeInfoBlock->WinSize/ModeInfoBlock->WinGranularity;

        } else {

           k = 1;
        }

    }

    if((pFrameBuffer = VideoPortGetDeviceBase(HwDeviceExtension, 
                                              FBPhysicalAddress,
                                              FrameBufferSize,
                                              FALSE)) == NULL) {
        return 0;
    }

    // 
    // 3) Restore framebuffer data
    // 

    // 
    // For banked mode we need to save the current bank number before
    // we change it.
    // 

    if (!(pVesaInfo->ModeNumber & 0x4000)) {

        // 
        // We need to save the curren window number for banked mode
        // 

        WinA = VBEGetDisplayWindow(HwDeviceExtension, 0);
        WinB = VBEGetDisplayWindow(HwDeviceExtension, 1);

    }

    LeftSize = FrameBufferSize;

    for (i = 0; LeftSize > 0; i++) {
    
        if (!(pVesaInfo->ModeNumber & 0x4000)) {

            // 
            // This is a banked mode.
            // 
            // We need set both Window A and B, as some VBEs have these 
            // set as separately available read and write windows.
            //

            VBESetDisplayWindow(HwDeviceExtension, 0, i * (USHORT)k);
            VBESetDisplayWindow(HwDeviceExtension, 1, i * (USHORT)k);
        }

        CopySize = (LeftSize < BankSize) ? LeftSize : BankSize;

        VideoPortMoveMemory(pFrameBuffer, 
                            FrameBufferData + i * BankSize, 
                            CopySize); 

        LeftSize -= CopySize;
    }

    if (!(pVesaInfo->ModeNumber & 0x4000)) {

        // 
        // For banked mode we need to restore the window number after
        // we changed it.
        // 

        VBESetDisplayWindow(HwDeviceExtension, 0, WinA);
        VBESetDisplayWindow(HwDeviceExtension, 1, WinB);
    }


    // 
    // 4) Relese resource
    // 

    VideoPortFreeDeviceBase(HwDeviceExtension, pFrameBuffer);
    VideoPortFreePool(HwDeviceExtension, FrameBufferData);

    return FrameBufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\amd64\vgahard.c ===
unsigned char BankSwitchStart;
unsigned char BankSwitchEnd;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\vga.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vga.c

Abstract:

    This is the miniport driver for the VGA card.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"
#include "vesa.h"

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,VgaFindAdapter)
#pragma alloc_text(PAGE,VgaInitialize)
#pragma alloc_text(PAGE,VgaStartIO)
#pragma alloc_text(PAGE,VgaLoadAndSetFont)
#pragma alloc_text(PAGE,VgaQueryCursorPosition)
#pragma alloc_text(PAGE,VgaSetCursorPosition)
#pragma alloc_text(PAGE,VgaQueryCursorAttributes)
#pragma alloc_text(PAGE,VgaSetCursorAttributes)
#pragma alloc_text(PAGE,VgaIsPresent)
#pragma alloc_text(PAGE,VgaSetPaletteReg)
#pragma alloc_text(PAGE,VgaSetColorLookup)
#pragma alloc_text(PAGE,VgaRestoreHardwareState)
#pragma alloc_text(PAGE,VgaSaveHardwareState)
#pragma alloc_text(PAGE,VgaGetBankSelectCode)
#pragma alloc_text(PAGE,VgaValidatorUcharEntry)
#pragma alloc_text(PAGE,VgaValidatorUshortEntry)
#pragma alloc_text(PAGE,VgaValidatorUlongEntry)
#pragma alloc_text(PAGE,GetDeviceDataCallback)
#pragma alloc_text(PAGE,VgaSetBankPosition)
#endif



ULONG
DriverEntry(
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = VgaFindAdapter;
    hwInitData.HwInitialize = VgaInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = VgaStartIO;

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Both numbers for these fields are zero since they are allocated
    // statically in the driver. We will pass pointers and sizes later in
    // the find adapter routine.
    //

//    hwInitData.NumberOfAccessRanges = 0;
//    hwInitData.NumEmulatorAccessEntries = 0;

    //
    // Always start with parameters for device0 in this case.
    // We can leave it like this since we know we will only ever find one
    // VGA type adapter in a machine.
    //

//    hwInitData.StartingDeviceNumber = 0;

    //
    // Once all the relevant information has been stored, call the video
    // port driver to do the initialization.
    //

    hwInitData.AdapterInterfaceType = Isa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);
    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = PCIBus;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = Eisa;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    hwInitData.AdapterInterfaceType = MicroChannel;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if (initializationStatus == NO_ERROR)
    {
        return initializationStatus;
    }

    //
    // For MIPS ACER machines
    //
    // *** Must keep this at the end since it will cause the global access
    // range structure to change in the driver. ***
    //

    hwInitData.AdapterInterfaceType = Internal;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    return initializationStatus;

} // end DriverEntry()

VP_STATUS
GetDeviceDataCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    VIDEO_DEVICE_DATA_TYPE DeviceDataType,
    PVOID Identifier,
    ULONG IdentifierLength,
    PVOID ConfigurationData,
    ULONG ConfigurationDataLength,
    PVOID ComponentInformation,
    ULONG ComponentInformationLength
    )
{
    PVIDEO_ACCESS_RANGE accessRange = Context;
    PVIDEO_HARDWARE_CONFIGURATION_DATA configData = ConfigurationData;
    ULONG i;

    VideoDebugPrint((2, "VGA: controller information is present\n"));

    //
    // We do not want to try to detect the vga if there isn't one present.
    // (Kind of a paradox?)  The only MIPS box I am aware of which has
    // an vga on the internal bus is the NeTPower NeTstation 100 and the Acer.
    // It has an identifier of "ALI_S3".
    //

    if (!Identifier)
    {
        return ERROR_DEV_NOT_EXIST;
    }

    if (VideoPortCompareMemory(L"ALI_S3",
                               Identifier,
                               sizeof(L"ALI_S3")) != sizeof(L"ALI_S3"))
    {
        return ERROR_DEV_NOT_EXIST;
    }


    //
    // Now lets get the base for the IO ports and memory location out of the
    // configuration information.
    //

    VideoDebugPrint((2, "VGA: Internal Bus, get new IO bases\n"));

    //
    // For MIPS machine with an Internal Bus, adjust the access ranges.
    //

    VideoDebugPrint((3, "VGA: FrameBase Offset = %08lx\n", configData->FrameBase));
    VideoDebugPrint((3, "VGA: IoBase Offset = %08lx\n", configData->ControlBase));

    for (i=0; i < NUM_VGA_ACCESS_RANGES; i++)
    {
        if (accessRange[i].RangeInIoSpace)
        {
            accessRange[i].RangeStart.LowPart += configData->ControlBase;
            accessRange[i].RangeInIoSpace = 0;
        }
        else
        {
            accessRange[i].RangeStart.LowPart += configData->FrameBase;
        }
    }

    return NO_ERROR;

} //end GetDeviceDataCallback()

VP_STATUS
VgaAcquireResources(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine tries to acquire the vga resources.

Arguments:

    Pointer to HwDeviceExtension

Returns:

    Status code indicating whether or not the resources where acquired.

--*/

{
    VP_STATUS status;
    ULONG i, NumVgaAccessRanges = NUM_VGA_ACCESS_RANGES;

    //
    // We only want the vga to claim resources if it loaded because
    // no other drivers were present.  If other drivers were present,
    // and claimed VGA resources, then we should only function as a
    // vga compatible driver (provide full screen support).
    //
    // We'll do the following:
    //
    // (1) We'll try to grab VGA resources exclusively.
    //
    // (2) If we get the resources then we are operating as the fall
    //     back device.  No other video drivers loaded.  Keep resources.
    //
    // (3) If we do not get the resources exclusively, try to claim
    //     them shared.
    //
    // (4) If we get the resources then we are loading to provide vga
    //     full screen support.  Free the resource so that we aren't
    //     holding legacy resources (so system can sleep/undock/etc).
    //
    // (5) If we still couldn't get the resources, then fail to load!
    //

    for (i=0; i<NUM_VGA_ACCESS_RANGES; i++) {
        VgaAccessRange[i].RangeShareable = FALSE;
    }

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         NumVgaAccessRanges,
                                         VgaAccessRange);

    if (status != NO_ERROR) {

        //
        // Deal with the fact that the ATI HACK doesn't work
        // if the device is on the other side of a PCI bridge.
        //

        NumVgaAccessRanges -= 2;

        status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                             NumVgaAccessRanges,
                                             VgaAccessRange);

        if (status != NO_ERROR) {

            //
            // We couldn't get the resource exclusively.  Try to get
            // them shared.
            //

            for (i=0; i<NumVgaAccessRanges; i++) {
                VgaAccessRange[i].RangeShareable = TRUE;
            }

            status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                                 NumVgaAccessRanges,
                                                 VgaAccessRange);

            if (status == NO_ERROR) {

                //
                // We were able to get the resource shared so we must be
                // providing vga full screen support.  Release our claim
                // on resources.
                //

                VideoPortVerifyAccessRanges(HwDeviceExtension,
                                            0,
                                            NULL);


                return NO_ERROR;

            } else {

                //
                // If we haven't gotten the resources by now, that means we
                // couldn't get them shared.  This means we can't load at all.
                //

                return status;
            }
        }
    }

    //
    // We got the resources exclusively which means we are acting
    // as a fall back driver.  But lets claim the resources as
    // shared so that a PnP Driver that uses the resources can still
    // load.
    //

    for (i=0; i<NumVgaAccessRanges; i++) {
        VgaAccessRange[i].RangeShareable = TRUE;
    }

    status = VideoPortVerifyAccessRanges(HwDeviceExtension,
                                         NumVgaAccessRanges,
                                         VgaAccessRange);

    return status;
}

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

    This routine is called to determine if the adapter for this driver
    is present in the system.
    If it is present, the function fills out some information describing
    the adapter.

Arguments:

    HwDeviceExtension - Supplies the miniport driver's adapter storage. This
        storage is initialized to zero before this call.

    HwContext - Supplies the context value which was passed to
        VideoPortInitialize().

    ArgumentString - Supplies a NULL terminated ASCII string. This string
        originates from the user.

    ConfigInfo - Returns the configuration information structure which is
        filled by the miniport driver. This structure is initialized with
        any known configuration information (such as SystemIoBusNumber) by
        the port driver. Where possible, drivers should have one set of
        defaults which do not require any supplied configuration information.

    Again - Indicates if the miniport driver wants the port driver to call
        its VIDEO_HW_FIND_ADAPTER function again with a new device extension
        and the same config info. This is used by the miniport drivers which
        can search for several adapters on a bus.

Return Value:

    This routine must return:

    NO_ERROR - Indicates a host adapter was found and the
        configuration information was successfully determined.

    ERROR_INVALID_PARAMETER - Indicates an adapter was found but there was an
        error obtaining the configuration information. If possible an error
        should be logged.

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Make sure we only load one copy of the vga driver
    //

    if (VgaLoaded) {

        return ERROR_DEV_NOT_EXIST;

    }

    //
    // No interrupt information is necessary.
    //

    if (ConfigInfo->AdapterInterfaceType == Internal) {

        //
        // First check if there is a video adapter on the internal bus.
        // Exit right away if there is not.
        //

        if (NO_ERROR != VideoPortGetDeviceData(hwDeviceExtension,
                                               VpControllerData,
                                               &GetDeviceDataCallback,
                                               VgaAccessRange)) {

            VideoDebugPrint((2, "VGA: VideoPort get controller info failed\n"));

            return ERROR_INVALID_PARAMETER;

        }

    }

    status = VgaAcquireResources(hwDeviceExtension);

    if (status != NO_ERROR) {
        return status;
    }


    //
    // Get logical IO port addresses.
    //

    if ( (hwDeviceExtension->IOAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
                                     VgaAccessRange->RangeStart,
                                     VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1,
                                     VgaAccessRange->RangeInIoSpace)) == NULL) {

        VideoDebugPrint((2, "VgaFindAdapter - Fail to get io address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Determine whether a VGA is present.
    //

    if (!VgaIsPresent(hwDeviceExtension)) {

        return ERROR_DEV_NOT_EXIST;

    }

    //
    // Pass a pointer to the emulator range we are using.
    //

    ConfigInfo->NumEmulatorAccessEntries = VGA_NUM_EMULATOR_ACCESS_ENTRIES;
    ConfigInfo->EmulatorAccessEntries = VgaEmulatorAccessEntries;
    ConfigInfo->EmulatorAccessEntriesContext = (ULONG_PTR) hwDeviceExtension;

    ConfigInfo->VdmPhysicalVideoMemoryAddress = VgaAccessRange[VGA_MEMORY].RangeStart;
    ConfigInfo->VdmPhysicalVideoMemoryLength = VgaAccessRange[VGA_MEMORY].RangeLength;

    //
    // Minimum size of the buffer required to store the hardware state
    // information returned by IOCTL_VIDEO_SAVE_HARDWARE_STATE.
    //

    ConfigInfo->HardwareStateSize = VGA_TOTAL_STATE_SIZE;

    //
    // Map the video memory into the system virtual address space so we can
    // clear it out and use it for save and restore.
    //

    if ( (hwDeviceExtension->VideoMemoryAddress =
              VideoPortGetDeviceBase(hwDeviceExtension,
              VgaAccessRange[VGA_MEMORY].RangeStart,
              VgaAccessRange[VGA_MEMORY].RangeLength, FALSE)) == NULL) {

        VideoDebugPrint((1, "VgaFindAdapter - Fail to get memory address\n"));

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Indicate we do not wish to be called again for another initialization.
    //

    *Again = 0;

    //
    // Keep track of if we already got loaded, since we can be called back
    // for a secondary bus (some machines have 2 PCI buses).
    // If *we* acquired the resources, then we won't conflict with ourselves
    // since we grabbed the resources as shared.
    //

    VgaLoaded = 1;

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // VgaFindAdapter()

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    None.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // set up the default cursor position and type.
    //

    hwDeviceExtension->CursorPosition.Column = 0;
    hwDeviceExtension->CursorPosition.Row = 0;
    hwDeviceExtension->CursorTopScanLine = 0;
    hwDeviceExtension->CursorBottomScanLine = 31;
    hwDeviceExtension->CursorEnable = TRUE;

    InitializeModeTable(hwDeviceExtension);

    return TRUE;

} // VgaInitialize()

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    acceptss a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

    This routine will return error codes from the various support routines
    and will also return ERROR_INSUFFICIENT_BUFFER for incorrectly sized
    buffers and ERROR_INVALID_FUNCTION for unsupported functions.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;
    VIDEO_MODE videoMode;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    ULONG inIoSpace;

#if DBG
    //
    // Keep a history of the commands.
    // This will help track down the chip being in a DOS session while
    // GDI and the S3 display driver "think" it's in GUI mode.

    gaIOControlCode[giControlCode++] = RequestPacket->IoControlCode;
    giControlCode                   %= MAX_CONTROL_HISTORY;
#endif

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {


    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - MapVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        memoryInformation = RequestPacket->OutputBuffer;

        memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                (RequestPacket->InputBuffer))->RequestedVirtualAddress;

        memoryInformation->VideoRamLength =
                hwDeviceExtension->PhysicalVideoMemoryLength;

        inIoSpace = 0;

        //
        // Let try to take advantage of write combining if using a VESA mode.
        //

        //if (IS_LINEAR_MODE(hwDeviceExtension->CurrentMode)) {
        //    inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
        //}

        status = VideoPortMapMemory(hwDeviceExtension,
                                    hwDeviceExtension->PhysicalVideoMemoryBase,
                                    &(memoryInformation->VideoRamLength),
                                    &inIoSpace,
                                    &(memoryInformation->VideoRamBase));

        memoryInformation->FrameBufferBase =
                ((PUCHAR) (memoryInformation->VideoRamBase)) +
                hwDeviceExtension->PhysicalFrameBaseOffset.LowPart;

        memoryInformation->FrameBufferLength =
            hwDeviceExtension->PhysicalFrameLength;


        break;


    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((2, "VgaStartIO - UnMapVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
        }

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      ((PVIDEO_MEMORY)
                                       (RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryAvailableModes(hwDeviceExtension,
                                        (PVIDEO_MODE_INFORMATION)
                                            RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((2, "VgaStartIO - QueryNumAvailableModes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryNumberOfAvailableModes(hwDeviceExtension,
                                                (PVIDEO_NUM_MODES)
                                                    RequestPacket->OutputBuffer,
                                                RequestPacket->OutputBufferLength,
                                                (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - QueryCurrentMode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCurrentMode(hwDeviceExtension,
                                     (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer,
                                     RequestPacket->OutputBufferLength,
                                     (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((2, "VgaStartIO - SetCurrentModes\n"));

        {
            ULONG FrameBufferIsMoved = 0;

            status = VgaSetMode(hwDeviceExtension,
                                (PVIDEO_MODE) RequestPacket->InputBuffer,
                                RequestPacket->InputBufferLength,
                                &FrameBufferIsMoved);

            if (RequestPacket->OutputBufferLength >= sizeof(ULONG)) {

                RequestPacket->StatusBlock->Information = sizeof(ULONG);
                *(PULONG)RequestPacket->OutputBuffer = FrameBufferIsMoved;
            }
        }

        break;


    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((2, "VgaStartIO - Reset Device\n"));

        videoMode.RequestedMode = DEFAULT_MODE;

        {
            ULONG FrameBufferIsMoved = 0;

            status = VgaSetMode(hwDeviceExtension,
                                (PVIDEO_MODE) &videoMode,
                                sizeof(videoMode),
                                &FrameBufferIsMoved);
        }

        break;


    case IOCTL_VIDEO_LOAD_AND_SET_FONT:

        VideoDebugPrint((2, "VgaStartIO - LoadAndSetFont\n"));

        status = VgaLoadAndSetFont(hwDeviceExtension,
                                   (PVIDEO_LOAD_FONT_INFORMATION) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorPosition\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorPosition(hwDeviceExtension,
                                        (PVIDEO_CURSOR_POSITION) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_SET_CURSOR_POSITION:

        VideoDebugPrint((2, "VgaStartIO - SetCursorPosition\n"));

        status = VgaSetCursorPosition(hwDeviceExtension,
                                      (PVIDEO_CURSOR_POSITION)
                                          RequestPacket->InputBuffer,
                                      RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_QUERY_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - QueryCursorAttributes\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaQueryCursorAttributes(hwDeviceExtension,
                                          (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->OutputBuffer,
                                          RequestPacket->OutputBufferLength,
                                          (PULONG)(&RequestPacket->StatusBlock->Information));

        break;


    case IOCTL_VIDEO_SET_CURSOR_ATTR:

        VideoDebugPrint((2, "VgaStartIO - SetCursorAttributes\n"));

        status = VgaSetCursorAttributes(hwDeviceExtension,
                                        (PVIDEO_CURSOR_ATTRIBUTES) RequestPacket->InputBuffer,
                                        RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_PALETTE_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetPaletteRegs\n"));

        status = VgaSetPaletteReg(hwDeviceExtension,
                                  (PVIDEO_PALETTE_DATA) RequestPacket->InputBuffer,
                                  RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((2, "VgaStartIO - SetColorRegs\n"));

        status = VgaSetColorLookup(hwDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);

        break;


    case IOCTL_VIDEO_ENABLE_VDM:

        VideoDebugPrint((2, "VgaStartIO - EnableVDM\n"));

        hwDeviceExtension->TrappedValidatorCount = 0;
        hwDeviceExtension->SequencerAddressValue = 0;

        hwDeviceExtension->CurrentNumVdmAccessRanges =
            NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE;
        hwDeviceExtension->CurrentVdmAccessRange =
            MinimalVgaValidatorAccessRange;

        VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                         hwDeviceExtension->CurrentNumVdmAccessRanges,
                                         hwDeviceExtension->CurrentVdmAccessRange);

        status = NO_ERROR;

        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - RestoreHardwareState\n"));

        if(IsSavedModeVesa((PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer)){

            status = VesaRestoreHardwareState(hwDeviceExtension,
                                              (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                              RequestPacket->InputBufferLength);
        } else {

            status = VgaRestoreHardwareState(hwDeviceExtension,
                                             (PVIDEO_HARDWARE_STATE) RequestPacket->InputBuffer,
                                             RequestPacket->InputBufferLength);
        }

        break;


    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

        VideoDebugPrint((2, "VgaStartIO - SaveHardwareState\n"));

        RequestPacket->StatusBlock->Information = 0;

        {
            USHORT ModeNumber;
    
            ModeNumber = VBEGetMode(hwDeviceExtension);

            if (ModeNumber & 0x100) {
    
                status = VesaSaveHardwareState(hwDeviceExtension,
                                              (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                              RequestPacket->OutputBufferLength,
                                              ModeNumber);
            } else {

                status = VgaSaveHardwareState(hwDeviceExtension,
                                              (PVIDEO_HARDWARE_STATE) RequestPacket->OutputBuffer,
                                              RequestPacket->OutputBufferLength,
                                              (PULONG)(&RequestPacket->StatusBlock->Information));
            }
        }

        break;

    case IOCTL_VIDEO_GET_BANK_SELECT_CODE:

        VideoDebugPrint((2, "VgaStartIO - GetBankSelectCode\n"));

        RequestPacket->StatusBlock->Information = 0;
        status = VgaGetBankSelectCode(hwDeviceExtension,
                                        (PVIDEO_BANK_SELECT) RequestPacket->OutputBuffer,
                                        RequestPacket->OutputBufferLength,
                                        (PULONG)(&RequestPacket->StatusBlock->Information));

        break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "VgaStartIO - Query Public Address Ranges\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                                 sizeof(VIDEO_PUBLIC_ACCESS_RANGES)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            PVIDEO_PUBLIC_ACCESS_RANGES publicAccessRanges;
            PHYSICAL_ADDRESS PhysicalRegisterAddress;
            ULONG RegisterLength;
            PVOID MappedAddress;

            publicAccessRanges = RequestPacket->OutputBuffer;

            PhysicalRegisterAddress.LowPart = VGA_END_BREAK_PORT;
            PhysicalRegisterAddress.HighPart = 0;
            RegisterLength = VGA_MAX_IO_PORT - VGA_END_BREAK_PORT;
            publicAccessRanges->InIoSpace = TRUE;
            MappedAddress = NULL;

            status = VideoPortMapMemory(
                                HwDeviceExtension,
                                PhysicalRegisterAddress,
                                &RegisterLength,
                                &(publicAccessRanges->InIoSpace),
                                &MappedAddress
                                );

            publicAccessRanges->VirtualAddress = (PVOID)((ULONG_PTR)MappedAddress - VGA_END_BREAK_PORT);
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((2, "VgaStartIO - Free Public Address Ranges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            PVIDEO_MEMORY mappedMemory;

            mappedMemory = RequestPacket->InputBuffer;

            status = VideoPortUnmapMemory(
                          HwDeviceExtension,
                          (PVOID)((ULONG_PTR)(mappedMemory->RequestedVirtualAddress)
                                                          + VGA_END_BREAK_PORT),
                          0);
        }

        break;

    case IOCTL_VIDEO_SET_BANK_POSITION:

        VideoDebugPrint((2, "VgaStartIO - Set Bank Position\n"));

        if (RequestPacket->InputBufferLength < sizeof(BANK_POSITION)) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            PBANK_POSITION BankPosition;

            BankPosition = RequestPacket->InputBuffer;

            status = VgaSetBankPosition(
                         HwDeviceExtension,
                         BankPosition);
        }

        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        VideoDebugPrint((1, "Fell through vga startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }

#if DBG

    //
    // Keep a history of the commands.
    // This will help track down the chip being in a DOS session while
    // GDI and the S3 display driver "think" it's in GUI mode.

    gaIOControlCode[giControlCode++] = 0x00005555;
    giControlCode                   %= MAX_CONTROL_HISTORY;

#endif

    RequestPacket->StatusBlock->Status = status;

    return TRUE;

} // VgaStartIO()

//
// private routines
//

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    )

/*++

Routine Description:

    Takes a buffer containing a user-defined font and loads it into the
    VGA soft font memory and programs the VGA to the appropriate character
    cell size.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FontInformation - Pointer to the structure containing the information
        about the loadable ROM font to be set.

    FontInformationSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    PUCHAR destination;
    PUCHAR source;
    USHORT width;
    ULONG i;
    UCHAR cr9;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough
    // and that it contains all the data.
    //

    if ( (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION)) ||
         (FontInformationSize < sizeof(VIDEO_LOAD_FONT_INFORMATION) +
                        sizeof(UCHAR) * (FontInformation->FontSize - 1)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check for the width and height of the font
    //

    if ( ((FontInformation->WidthInPixels != 8) &&
          (FontInformation->WidthInPixels != 9)) ||
         (FontInformation->HeightInPixels > 32) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check the size of the font buffer is the right size for the size
    // font being passed down.
    //

    if (FontInformation->FontSize < FontInformation->HeightInPixels * 256 *
                                    sizeof(UCHAR) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Since the font parameters are valid, store the parameters in the
    // device extension and load the font.
    //

    HwDeviceExtension->FontPelRows = FontInformation->HeightInPixels;
    HwDeviceExtension->FontPelColumns = FontInformation->WidthInPixels;

    HwDeviceExtension->CurrentMode->row =
        HwDeviceExtension->CurrentMode->vres / HwDeviceExtension->FontPelRows;

    width =
      HwDeviceExtension->CurrentMode->hres / HwDeviceExtension->FontPelColumns;

    if (width < (USHORT)HwDeviceExtension->CurrentMode->col) {

        HwDeviceExtension->CurrentMode->col = width;

    }

    source = &(FontInformation->Font[0]);

    //
    // Set up the destination and source pointers for the font
    //

    destination = (PUCHAR)HwDeviceExtension->VideoMemoryAddress;

    //
    // Map font buffer at A0000
    //

    VgaInterpretCmdStream(HwDeviceExtension, EnableA000Data);

    //
    // Move the font to its destination
    //

    for (i = 1; i <= 256; i++) {

        VideoPortWriteRegisterBufferUchar(destination,
                                          source,
                                          FontInformation->HeightInPixels);

        destination += 32;
        source += FontInformation->HeightInPixels;

    }

    VgaInterpretCmdStream(HwDeviceExtension, DisableA000Color);

    //
    // Restore to a text mode.
    //

    //
    // Set Height of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x9);

    cr9 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(cr9 | (FontInformation->HeightInPixels - 1)));

    //
    // Set Width of font.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0x12);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR,
            (UCHAR)(((USHORT)FontInformation->HeightInPixels *
            (USHORT)HwDeviceExtension->CurrentMode->row) - 1));

    i = HwDeviceExtension->CurrentMode->vres /
        HwDeviceExtension->CurrentMode->row;

    //
    // Set Cursor End
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xb);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    //
    // Set Cursor Statr
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, 0xa);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR)--i);

    return NO_ERROR;

} //end VgaLoadAndSetFont()

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the output buffer supplied by the user. This
        is where the cursor position is stored.

    CursorPositionSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorPositionSize < (*OutputSize = sizeof(VIDEO_CURSOR_POSITION)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the postition of the cursor into the buffer.
    //

    CursorPosition->Column = HwDeviceExtension->CursorPosition.Column;
    CursorPosition->Row = HwDeviceExtension->CursorPosition.Row;

    return NO_ERROR;

} // end VgaQueryCursorPosition()

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor position is within
    the row and column bounds of the current mode and font. If valid, then
    it sets the row and column of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorPosition - Pointer to the structure containing the cursor position.

    CursorPositionSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    USHORT position;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorPositionSize < sizeof(VIDEO_CURSOR_POSITION)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor positions are in the valid
    // bounds for the screen.
    //

    if ((CursorPosition->Column >= HwDeviceExtension->CurrentMode->col) ||
        (CursorPosition->Row >= HwDeviceExtension->CurrentMode->row)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store these new values in the device extension so we can use them in
    // a QUERY.
    //

    HwDeviceExtension->CursorPosition.Column = CursorPosition->Column;
    HwDeviceExtension->CursorPosition.Row = CursorPosition->Row;

    //
    // Calculate the position on the screen at which the cursor must be
    // be displayed
    //

    position = (USHORT) (HwDeviceExtension->CurrentMode->col *
                         CursorPosition->Row + CursorPosition->Column);


    //
    // Address Cursor Location Low Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_LOW_LOC);

    //
    // Set Cursor Location Low Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position & 0x00FF));

    //
    // Address Cursor Location High Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_ADDRESS_PORT_COLOR, IND_CURSOR_HIGH_LOC);

    //
    // Set Cursor Location High Register
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR, (UCHAR) (position >> 8));

    return NO_ERROR;

} // end VgaSetCursorPosition()

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    This routine returns information about the height and visibility of the
    cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorAttributes - Pointer to the output buffer supplied by the user.
        This is where the cursor type is stored.

    CursorAttributesSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data in the buffer. If the buffer was not large enough, this
        contains the minimum required buffer size.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        *OutputSize = 0;
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //

    if (CursorAttributesSize < (*OutputSize =
            sizeof(VIDEO_CURSOR_ATTRIBUTES)) ) {

        *OutputSize = 0;
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Store the cursor information into the buffer.
    //

    CursorAttributes->Height = (USHORT) HwDeviceExtension->CursorTopScanLine;
    CursorAttributes->Width = (USHORT) HwDeviceExtension->CursorBottomScanLine;
    CursorAttributes->Enable = HwDeviceExtension->CursorEnable;

    return NO_ERROR;

} // end VgaQueryCursorAttributes()

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    )

/*++

Routine Description:

    This routine verifies that the requested cursor height is within the
    bounds of the character cell. If valid, then it sets the new
    visibility and height of the cursor.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    CursorType - Pointer to the structure containing the cursor information.

    CursorTypeSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data

    ERROR_INVALID_PARAMETER - invalid video mode

--*/

{
    UCHAR cursorLine;

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // Text mode only; If we are in a graphics mode, return an error
    //

    if (HwDeviceExtension->CurrentMode->fbType & VIDEO_MODE_GRAPHICS) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if (CursorAttributesSize < sizeof(VIDEO_CURSOR_ATTRIBUTES)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check if the new values for the cursor type are in the valid range.
    //

    if ((CursorAttributes->Height >= HwDeviceExtension->FontPelRows) ||
        (CursorAttributes->Width > 31)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Store the cursor information in the device extension so we can use
    // them in a QUERY.
    //

    HwDeviceExtension->CursorTopScanLine = (UCHAR) CursorAttributes->Height;
    HwDeviceExtension->CursorBottomScanLine = (UCHAR) CursorAttributes->Width;
    HwDeviceExtension->CursorEnable = CursorAttributes->Enable;

    //
    // Address Cursor Start Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_START);

    //
    // Set Cursor Start Register by writting to CRTCtl Data Register
    // Preserve the high three bits of this register.
    //
    // Only the Five low bits are used for the cursor height.
    // Bit 5 is cursor enable, bit 6 and 7 preserved.
    //

    cursorLine = (UCHAR) CursorAttributes->Height & 0x1F;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        CRTC_DATA_PORT_COLOR) & 0xC0;

    if (!CursorAttributes->Enable) {

        cursorLine |= 0x20; // Flip cursor off bit

    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                                cursorLine);

    //
    // Address Cursor End Register in CRT Controller Registers
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                CRTC_ADDRESS_PORT_COLOR,
                            IND_CURSOR_END);

    //
    // Set Cursor End Register. Preserve the high three bits of this
    // register.
    //

    cursorLine =
        (CursorAttributes->Width < (USHORT)(HwDeviceExtension->FontPelRows - 1)) ?
        CursorAttributes->Width : (HwDeviceExtension->FontPelRows - 1);

    cursorLine &= 0x1f;

    cursorLine |= VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            CRTC_DATA_PORT_COLOR) & 0xE0;

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + CRTC_DATA_PORT_COLOR,
                            cursorLine);

    return NO_ERROR;

} // end VgaSetCursorAttributes()

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

/*++

Routine Description:

    This routine returns TRUE if a VGA is present. Determining whether a VGA
    is present is a two-step process. First, this routine walks bits through
    the Bit Mask register, to establish that there are readable indexed
    registers (EGAs normally don't have readable registers, and other adapters
    are unlikely to have indexed registers). This test is done first because
    it's a non-destructive EGA rejection test (correctly rejects EGAs, but
    doesn't potentially mess up the screen or the accessibility of display
    memory). Normally, this would be an adequate test, but some EGAs have
    readable registers, so next, we check for the existence of the Chain4 bit
    in the Memory Mode register; this bit doesn't exist in EGAs. It's
    conceivable that there are EGAs with readable registers and a register bit
    where Chain4 is stored, although I don't know of any; if a better test yet
    is needed, memory could be written to in Chain4 mode, and then examined
    plane by plane in non-Chain4 mode to make sure the Chain4 bit did what it's
    supposed to do. However, the current test should be adequate to eliminate
    just about all EGAs, and 100% of everything else.

    If this function fails to find a VGA, it attempts to undo any damage it
    may have inadvertently done while testing. The underlying assumption for
    the damage control is that if there's any non-VGA adapter at the tested
    ports, it's an EGA or an enhanced EGA, because: a) I don't know of any
    other adapters that use 3C4/5 or 3CE/F, and b), if there are other
    adapters, I certainly don't know how to restore their original states. So
    all error recovery is oriented toward putting an EGA back in a writable
    state, so that error messages are visible. The EGA's state on entry is
    assumed to be text mode, so the Memory Mode register is restored to the
    default state for text mode.

    If a VGA is found, the VGA is returned to its original state after
    testing is finished.

Arguments:

    None.

Return Value:

    TRUE if a VGA is present, FALSE if not.

--*/

{
    UCHAR originalGCAddr;
    UCHAR originalSCAddr;
    UCHAR originalBitMask;
    UCHAR originalReadMap;
    UCHAR originalMemoryMode;
    UCHAR testMask;
    BOOLEAN returnStatus;

    //
    // Remember the original state of the Graphics Controller Address register.
    //

    originalGCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT);

    //
    // Write the Read Map register with a known state so we can verify
    // that it isn't changed after we fool with the Bit Mask. This ensures
    // that we're dealing with indexed registers, since both the Read Map and
    // the Bit Mask are addressed at GRAPH_DATA_PORT.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // If we can't read back the Graphics Address register setting we just
    // performed, it's not readable and this isn't a VGA.
    //

    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
        GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_READ_MAP) {

        return FALSE;
    }

    //
    // Set the Read Map register to a known state.
    //

    originalReadMap = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, READ_MAP_TEST_SETTING);

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map setting we just performed can't be read back; not a
        // VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    //
    // Remember the original setting of the Bit Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT) & GRAPH_ADDR_MASK) != IND_BIT_MASK) {

        //
        // The Graphics Address register setting we just made can't be read
        // back; not a VGA. Restore the default Read Map state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_READ_MAP);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);

        return FALSE;
    }

    originalBitMask = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT);

    //
    // Set up the initial test mask we'll write to and read from the Bit Mask.
    //

    testMask = 0xBB;

    do {

        //
        // Write the test mask to the Bit Mask.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, testMask);

        //
        // Make sure the Bit Mask remembered the value.
        //

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT) != testMask) {

            //
            // The Bit Mask is not properly writable and readable; not a VGA.
            // Restore the Bit Mask and Read Map to their default states.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, BIT_MASK_DEFAULT);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT, IND_READ_MAP);
            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_DATA_PORT, READ_MAP_DEFAULT);

            return FALSE;
        }

        //
        // Cycle the mask for next time.
        //

        testMask >>= 1;

    } while (testMask != 0);

    //
    // There's something readable at GRAPH_DATA_PORT; now switch back and
    // make sure that the Read Map register hasn't changed, to verify that
    // we're dealing with indexed registers.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);
    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT) != READ_MAP_TEST_SETTING) {

        //
        // The Read Map is not properly writable and readable; not a VGA.
        // Restore the Bit Mask and Read Map to their default states, in case
        // this is an EGA, so subsequent writes to the screen aren't garbled.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, READ_MAP_DEFAULT);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, IND_BIT_MASK);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, BIT_MASK_DEFAULT);

        return FALSE;
    }

    //
    // We've pretty surely verified the existence of the Bit Mask register.
    // Put the Graphics Controller back to the original state.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalReadMap);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_BIT_MASK);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, originalBitMask);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, originalGCAddr);

    //
    // Now, check for the existence of the Chain4 bit.
    //

    //
    // Remember the original states of the Sequencer Address and Memory Mode
    // registers.
    //

    originalSCAddr = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    if ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT) & SEQ_ADDR_MASK) != IND_MEMORY_MODE) {

        //
        // Couldn't read back the Sequencer Address register setting we just
        // performed.
        //

        return FALSE;
    }
    originalMemoryMode = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT);

    //
    // Toggle the Chain4 bit and read back the result. This must be done during
    // sync reset, since we're changing the chaining state.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT),
             (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Toggle the Chain4 bit.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT, (UCHAR)(originalMemoryMode ^ CHAIN4_MASK));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT) != (UCHAR) (originalMemoryMode ^ CHAIN4_MASK)) {

        //
        // Chain4 bit not there; not a VGA.
        // Set text mode default for Memory Mode register.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, MEMORY_MODE_TEXT_DEFAULT);
        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        returnStatus = FALSE;

    } else {

        //
        // It's a VGA.
        //

        //
        // Restore the original Memory Mode setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, originalMemoryMode);

        //
        // End sync reset.
        //

        VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT),
                (USHORT)(IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

        //
        // Restore the original Sequencer Address setting.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, originalSCAddr);

        returnStatus = TRUE;
    }

    return returnStatus;

} // VgaIsPresent()

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the EGA (not DAC) palette
    registers.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    PaletteBuffer - Pointer to the structure containing the palette data.

    PaletteBufferSize - Length of the input buffer supplied by the user.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid palette size.

--*/

{
    USHORT i;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((PaletteBufferSize) < (sizeof(VIDEO_PALETTE_DATA)) ||
        (PaletteBufferSize < (sizeof(VIDEO_PALETTE_DATA) +
                (sizeof(USHORT) * (PaletteBuffer->NumEntries -1)) ))) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (PaletteBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER ) ||
         (PaletteBuffer->NumEntries == 0) ||
         (PaletteBuffer->FirstEntry + PaletteBuffer->NumEntries >
             VIDEO_MAX_PALETTE_REGISTER + 1 ) ) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Reset ATC to index mode
    //

    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                           ATT_INITIALIZE_PORT_COLOR);

    //
    // Blast out our palette values.
    //

    for (i = 0; i < PaletteBuffer->NumEntries; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                                (UCHAR)(i+PaletteBuffer->FirstEntry));

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    ATT_DATA_WRITE_PORT,
                                (UCHAR)PaletteBuffer->Colors[i]);
    }

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress + ATT_ADDRESS_PORT,
                            VIDEO_ENABLE);


    return NO_ERROR;

} // end VgaSetPaletteReg()


VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

/*++

Routine Description:

    This routine sets a specified portion of the DAC color lookup table
    settings.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough for input data.

    ERROR_INVALID_PARAMETER - invalid clut size.

--*/

{
    USHORT i;
    BOOLEAN PaletteIsSet = FALSE;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        return ERROR_INVALID_PARAMETER;

    }

    if (IS_LINEAR_MODE(HwDeviceExtension->CurrentMode)) {

        INT10_BIOS_ARGUMENTS BiosArguments;
        PVIDEO_PORT_INT10_INTERFACE pInt10 = &HwDeviceExtension->Int10;
        PPALETTE_ENTRY Palette = VideoPortAllocatePool(HwDeviceExtension,
                                                       VpPagedPool,
                                                       ClutBuffer->NumEntries *
                                                           sizeof(PALETTE_ENTRY),
                                                       ' agV');

        if (Palette) {

            for (i=0; i<ClutBuffer->NumEntries; i++) {
                Palette[i].Blue  = ClutBuffer->LookupTable[i].RgbArray.Blue;
                Palette[i].Green = ClutBuffer->LookupTable[i].RgbArray.Green;
                Palette[i].Red   = ClutBuffer->LookupTable[i].RgbArray.Red;
                Palette[i].Alignment = 0;
            }

            pInt10->Int10WriteMemory(pInt10->Context,
                                     HwDeviceExtension->VdmSeg,
                                     HwDeviceExtension->VdmOff,
                                     Palette,
                                     sizeof(PALETTE_ENTRY) * ClutBuffer->NumEntries);

            BiosArguments.Eax = 0x4f09;
            BiosArguments.Ebx = 0x0000;
            BiosArguments.Ecx = ClutBuffer->NumEntries;
            BiosArguments.Edx = ClutBuffer->FirstEntry;
            BiosArguments.Edi = HwDeviceExtension->VdmOff;
            BiosArguments.SegEs = HwDeviceExtension->VdmSeg;

            pInt10->Int10CallBios(pInt10->Context, &BiosArguments);

            if ((BiosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS) {
                PaletteIsSet = TRUE;
            }
            
            VideoPortFreePool(HwDeviceExtension, Palette);

        } else {

            //
            // in this case we'll try to set palette by programming vga registers 
            //

        }

    } 

    if(!PaletteIsSet && !(HwDeviceExtension->CurrentMode->NonVgaHardware)) {

        //
        //  Set CLUT registers directly on the hardware
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT, (UCHAR) ClutBuffer->FirstEntry);

        //
        // Now write the data entries, relying on auto-increment.
        //

        for (i = 0; i < ClutBuffer->NumEntries; i++) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    DAC_DATA_REG_PORT,
                                    ClutBuffer->LookupTable[i].RgbArray.Red);

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    DAC_DATA_REG_PORT,
                                    ClutBuffer->LookupTable[i].RgbArray.Green);

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                    DAC_DATA_REG_PORT,
                                    ClutBuffer->LookupTable[i].RgbArray.Blue);

        }

        PaletteIsSet = TRUE;

    } 

    if(PaletteIsSet) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }


} // end VgaSetColorLookup()

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    )

/*++

Routine Description:

    Restores all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer from which the state
    is to be restored. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: The offset in the hardware state header from which each general
    register is restored is the offset of the write address of that register
    from the base I/O address of the VGA.


Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure from which the saved state is to be
        restored (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the input buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to from which the state is actually restored. The
        pointed-to buffer is assumed to be big enough.)

Return Value:

    NO_ERROR - restore performed successfully

    ERROR_INSUFFICIENT_BUFFER - input buffer not large enough to provide data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    ULONG i;
    UCHAR dummy;
    PUCHAR pScreen;
    PUCHAR pucLatch;
    PULONG pulBuffer;
    PUCHAR port;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    ULONG bIsColor;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ((HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE)) ||
            (HardwareState->StateLength < VGA_TOTAL_STATE_SIZE)) {

            return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Point to the buffer where the restore data is actually stored.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Make sure the offset are in the structure ...
    //

    if ((hardwareStateHeader->BasicSequencerOffset + VGA_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicCrtContOffset + VGA_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicGraphContOffset + VGA_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicAttribContOffset + VGA_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicDacOffset + (3 * VGA_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        (hardwareStateHeader->BasicLatchesOffset + 4 >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedSequencerOffset + EXT_NUM_SEQUENCER_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedCrtContOffset + EXT_NUM_CRTC_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedGraphContOffset + EXT_NUM_GRAPH_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedAttribContOffset + EXT_NUM_ATTRIB_CONT_PORTS >
            HardwareState->StateLength) ||

        (hardwareStateHeader->ExtendedDacOffset + (4 * EXT_NUM_DAC_ENTRIES) >
            HardwareState->StateLength) ||

        //
        // Only check the validator state offset if there is unemulated data.
        //

        ((hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) &&
            (hardwareStateHeader->ExtendedValidatorStateOffset + VGA_VALIDATOR_AREA_SIZE >
            HardwareState->StateLength)) ||

        (hardwareStateHeader->ExtendedMiscDataOffset + VGA_MISC_DATA_AREA_OFFSET >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane1Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane2Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane3Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->Plane4Offset + hardwareStateHeader->PlaneLength >
            HardwareState->StateLength) ||

        (hardwareStateHeader->DIBOffset +
            hardwareStateHeader->DIBBitsPerPixel / 8 *
            hardwareStateHeader->DIBXResolution *
            hardwareStateHeader->DIBYResolution  > HardwareState->StateLength) ||

        (hardwareStateHeader->DIBXlatOffset + hardwareStateHeader->DIBXlatLength >
            HardwareState->StateLength)) {

        return ERROR_INVALID_PARAMETER;

    }

    //
    // Turn off the screen to avoid flickering. The screen will turn back on
    // when we restore the DAC state at the end of this routine.
    //

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);


    //
    // Restore the latches and the contents of display memory.
    //
    // Set up the VGA's hardware to allow us to copy to each plane in turn.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT, (UCHAR) ((VideoPortReadPortUchar(
            HwDeviceExtension->IOAddress + GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x00));

    //
    // Set the Bit Mask to 0xFF to allow all CPU bits through.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_BIT_MASK + (0xFF << 8)));

    //
    // Set the Data Rotation and Logical Function fields to 0 to allow CPU
    // data through unmodified.
    //

    VideoPortWritePortUshort((PUSHORT)(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_DATA_ROTATE + (0 << 8)));

    //
    // Set Set/Reset Enable to 0 to select CPU data for all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT) (IND_SET_RESET_ENABLE + (0 << 8)));

    //
    // Point the Sequencer Index to the Map Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
             SEQ_ADDRESS_PORT, IND_MAP_MASK);

    //
    // Restore the latches.
    //
    // Point to the saved data for the first latch.
    //

    pucLatch = ((PUCHAR) (hardwareStateHeader)) +
            hardwareStateHeader->BasicLatchesOffset;

    //
    // Point to first byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress;

    //
    // Write the contents to be restored to each of the four latches in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Write this plane's latch.
        //

        VideoPortWriteRegisterUchar(pScreen, *pucLatch++);

    }

    //
    // Read the latched data into the latches, and the latches are set.
    //

    dummy = VideoPortReadRegisterUchar(pScreen);


    //
    // Point to the offset of the saved data for the first plane.
    //

    pulBuffer = &(hardwareStateHeader->Plane1Offset);

    //
    // Restore each of the four planes in turn.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Map Mask to select the plane we want to restore next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT, (UCHAR)(1<<i));

        //
        // Restore this plane from the buffer.
        //

        VideoPortMoveMemory((PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           ((PUCHAR) (hardwareStateHeader)) + *pulBuffer,
                           hardwareStateHeader->PlaneLength);

        pulBuffer++;

    }

    //
    // If we have some unemulated data, put it back into the buffer
    //

    if (hardwareStateHeader->VGAStateFlags & VIDEO_STATE_UNEMULATED_VGA_STATE) {

        if (!hardwareStateHeader->ExtendedValidatorStateOffset) {

            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;

        }

        //
        // Get the right offset in the struct and save all the data associated
        // with the trapped validator data.
        //

        VideoPortMoveMemory(&(HwDeviceExtension->TrappedValidatorCount),
                            ((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            VGA_VALIDATOR_AREA_SIZE);

        //
        // Check to see if this is an appropriate access range.
        // We are trapping - so we must have the trapping access range enabled.
        //

        if (((HwDeviceExtension->CurrentVdmAccessRange != FullVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE)) &&
            ((HwDeviceExtension->CurrentVdmAccessRange != MinimalVgaValidatorAccessRange) ||
             (HwDeviceExtension->CurrentNumVdmAccessRanges != NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE))) {

            ASSERT (FALSE);
            return ERROR_INVALID_PARAMETER;

        }

        VideoPortSetTrappedEmulatorPorts(HwDeviceExtension,
                                         HwDeviceExtension->CurrentNumVdmAccessRanges,
                                         HwDeviceExtension->CurrentVdmAccessRange);

    }

    //
    // Set the critical registers (clock and timing states) during sync reset.
    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (START_SYNC_RESET_VALUE << 8)));

    //
    // Restore the Miscellaneous Output register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT,
            (UCHAR) (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0xF7));

    //
    // Restore all Sequencer registers except the Sync Reset register, which
    // is always not in reset (except when we send out a batched sync reset
    // register set, but that can't be interrupted, so we know we're never in
    // sync reset at save/restore time).
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
            hardwareStateHeader->BasicSequencerOffset + 1;

    for (i = 1; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)) );

    }

    //
    // Restore the Graphics Controller Miscellaneous register, which contains
    // the Chain bit.
    //

    portValue = ((PUCHAR) hardwareStateHeader) +
                hardwareStateHeader->BasicGraphContOffset + IND_GRAPH_MISC;

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT), (USHORT)(IND_GRAPH_MISC + (*portValue << 8)));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_SYNC_RESET +
            (END_SYNC_RESET_VALUE << 8)));

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if (hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }


    //
    // Restore the CRT Controller indexed registers.
    //
    // Unlock CRTC registers 0-7.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicCrtContOffset;

    if (bIsColor) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    } else {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO), (USHORT) (IND_CRTC_PROTECT +
                (((*(portValue + IND_CRTC_PROTECT)) & 0x7F) << 8)));

    }


    //
    // Now restore the CRTC registers.
    //

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR),
                    (USHORT) (i + ((*portValue++) << 8)));

        } else {

            VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO),
                    (USHORT) (i + ((*portValue++) << 8)));

        }

    }


    //
    // Restore the Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicGraphContOffset;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT), (USHORT) (i + ((*portValue++) << 8)));

    }


    //
    // Restore the Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicAttribContOffset;

    //
    // Reset the AC index/data toggle, then blast out all the register
    // settings.
    //

    if (bIsColor) {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_COLOR);
    } else {
        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                INPUT_STATUS_1_MONO);
    }

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, *portValue++);

    }

    //
    // Restore DAC registers 1 through 255. We'll do register 0, the DAC Mask,
    // and the index registers later.
    // Set the DAC address port Index, then write out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Write them one at a time due to problems on local bus machines.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
                   hardwareStateHeader->BasicDacOffset + 3;

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_WRITE_PORT, (UCHAR)i);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_DATA_REG_PORT, *portValueDAC++);

    }


    //
    // Extended registers are not supported in this driver.
    //


    //
    // Restore the Feature Control register.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_COLOR,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                FEAT_CTRL_WRITE_PORT_MONO,
                hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO]);

    }


    //
    // Restore the Sequencer Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT,
            hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT]);

    //
    // Restore the CRT Controller Index.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR]);

    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO,
                hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO]);

    }


    //
    // Restore the Graphics Controller Index.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT,
            hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT]);


    //
    // Restore the Attribute Controller Index and index/data toggle state.
    //

    if (bIsColor) {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_COLOR;
    } else {
        port = HwDeviceExtension->IOAddress + INPUT_STATUS_1_MONO;
    }

    VideoPortReadPortUchar(port);  // reset the toggle to Index state

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT,  // restore the AC Index
            hardwareStateHeader->PortValue[ATT_ADDRESS_PORT]);

    //
    // If the toggle should be in Data state, we're all set. If it should be in
    // Index state, reset it to that condition.
    //

    if (hardwareStateHeader->AttribIndexDataState == 0) {

        //
        // Reset the toggle to Index state.
        //

        VideoPortReadPortUchar(port);

    }


    //
    // Restore DAC register 0 and the DAC Mask, to unblank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader +
            hardwareStateHeader->BasicDacOffset;

    //
    // Restore the DAC Mask register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT,
            hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT]);

    //
    // Restore DAC register 0.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, *portValueDAC++);


    //
    // Restore the read/write state and the current index of the DAC.
    //
    // See whether the Read or Write Index was written to most recently.
    // (The upper nibble stored at DAC_STATE_PORT is the # of reads/writes
    // for the current index.)
    //

    if ((hardwareStateHeader->PortValue[DAC_STATE_PORT] & 0x0F) == 3) {

        //
        // The DAC Read Index was written to last. Restore the DAC by setting
        // up to read from the saved index - 1, because the way the Read
        // Index works is that it autoincrements after reading, so you actually
        // end up reading the data for the index you read at the DAC Write
        // Mask register - 1.
        //
        // Set the Read Index to the index we read, minus 1, accounting for
        // wrap from 255 back to 0. The DAC hardware immediately reads this
        // register into a temporary buffer, then adds 1 to the index.
        //

        if (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] == 0) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, 255);

        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_READ_PORT, (UCHAR)
                    (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] -
                    1));

        }

        //
        // Now read the hardware however many times are required to get to
        // the partial read state we saved.
        //

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

        }

    } else {

        //
        // The DAC Write Index was written to last. Set the Write Index to the
        // index value we read out of the DAC. Then, if a partial write
        // (partway through an RGB triplet) was in place, write the partial
        // values, which we obtained by writing them to the current DAC
        // register. This DAC register will be wrong until the write is
        // completed, but at least the values will be right once the write is
        // finished, and most importantly we won't have messed up the sequence
        // of RGB writes (which can be as long as 768 in a row).
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_WRITE_PORT,
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]);

        //
        // Now write to the hardware however many times are required to get to
        // the partial write state we saved (if any).
        //
        // Point to the saved value for the DAC register that was in the
        // process of being written to; we wrote the partial value out, so now
        // we can restore it.
        //

        portValueDAC = (PUCHAR) hardwareStateHeader +
                hardwareStateHeader->BasicDacOffset +
                (hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] * 3);

        for (i = hardwareStateHeader->PortValue[DAC_STATE_PORT] >> 4;
                i > 0; i--) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, *portValueDAC++);

        }

    }

    return NO_ERROR;

} // end VgaRestoreHardwareState()

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Saves all registers and memory of the VGA.

    Note: HardwareState points to the actual buffer in which the state
    is saved. This buffer will always be big enough (we specified
    the required size at DriverEntry).

    Note: This routine leaves registers in any state it cares to, except
    that it will not mess with any of the CRT or Sequencer parameters that
    might make the monitor unhappy. It leaves the screen blanked by setting
    the DAC Mask and DAC register 0 to all zero values. The next video
    operation we expect after this is a mode set to take us back to Win32.

    Note: The offset in the hardware state header in which each general
    register is saved is the offset of the write address of that register from
    the base I/O address of the VGA.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    HardwareState - Pointer to a structure in which the saved state will be
        returned (actually only info about and a pointer to the actual save
        buffer).

    HardwareStateSize - Length of the output buffer supplied by the user.
        (Actually only the size of the HardwareState structure, not the
        buffer it points to where the state is actually saved. The pointed-
        to buffer is assumed to be big enough.)

    OutputSize - Pointer to a buffer in which to return the actual size of
        the data returned in the buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    PVIDEO_HARDWARE_STATE_HEADER hardwareStateHeader;
    PUCHAR pScreen;
    PUCHAR portValue;
    PUCHAR portValueDAC;
    PUCHAR bufferPointer;
    ULONG i;
    UCHAR dummy, originalACIndex, originalACData;
    UCHAR ucCRTC03;
    ULONG bIsColor;


    //
    // See if the buffer is big enough to hold the hardware state structure.
    // (This is only the HardwareState structure itself, not the buffer it
    // points to.)
    //

    if (HardwareStateSize < sizeof(VIDEO_HARDWARE_STATE) ) {

        *OutputSize = 0;  // nothing returned
        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Amount of data we're going to return in the output buffer.
    // (The VIDEO_HARDWARE_STATE in the output buffer points to the actual
    // buffer in which the state is stored, which is assumed to be large
    // enough.)
    //

    *OutputSize = sizeof(VIDEO_HARDWARE_STATE);

    //
    // Indicate the size of the full state save info.
    //

    HardwareState->StateLength = VGA_TOTAL_STATE_SIZE;

    //
    // hardwareStateHeader is a structure of offsets at the start of the
    // actual save area that indicates the locations in which various VGA
    // register and memory components are saved.
    //

    hardwareStateHeader = HardwareState->StateHeader;

    //
    // Zero out the structure.
    //

    VideoPortZeroMemory(hardwareStateHeader, sizeof(VIDEO_HARDWARE_STATE_HEADER));

    //
    // Set the Length field, which is basically a version ID.
    //

    hardwareStateHeader->Length = sizeof(VIDEO_HARDWARE_STATE_HEADER);

    //
    // Set the basic register offsets properly.
    //

    hardwareStateHeader->BasicSequencerOffset = VGA_BASIC_SEQUENCER_OFFSET;
    hardwareStateHeader->BasicCrtContOffset = VGA_BASIC_CRTC_OFFSET;
    hardwareStateHeader->BasicGraphContOffset = VGA_BASIC_GRAPH_CONT_OFFSET;
    hardwareStateHeader->BasicAttribContOffset = VGA_BASIC_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->BasicDacOffset = VGA_BASIC_DAC_OFFSET;
    hardwareStateHeader->BasicLatchesOffset = VGA_BASIC_LATCHES_OFFSET;

    //
    // Set the entended register offsets properly.
    //

    hardwareStateHeader->ExtendedSequencerOffset = VGA_EXT_SEQUENCER_OFFSET;
    hardwareStateHeader->ExtendedCrtContOffset = VGA_EXT_CRTC_OFFSET;
    hardwareStateHeader->ExtendedGraphContOffset = VGA_EXT_GRAPH_CONT_OFFSET;
    hardwareStateHeader->ExtendedAttribContOffset = VGA_EXT_ATTRIB_CONT_OFFSET;
    hardwareStateHeader->ExtendedDacOffset = VGA_EXT_DAC_OFFSET;

    //
    // Figure out if color/mono switchable registers are at 3BX or 3DX.
    // At the same time, save the state of the Miscellaneous Output register
    // which is read from 3CC but written at 3C2.
    //

    if ((hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    MISC_OUTPUT_REG_READ_PORT))
            & 0x01) {
        bIsColor = TRUE;
    } else {
        bIsColor = FALSE;
    }

    //
    // Force the video subsystem enable state to enabled.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            VIDEO_SUBSYSTEM_ENABLE_PORT, 1);

    //
    // Save the DAC state first, so we can set the DAC to blank the screen
    // so nothing after this shows up at all.
    //
    // Save the DAC Mask register.
    //

    hardwareStateHeader->PortValue[DAC_PIXEL_MASK_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_PIXEL_MASK_PORT);

    //
    // Save the DAC Index register. Note that there is actually only one DAC
    // Index register, which functions as either the Read Index or the Write
    // Index as needed.
    //

    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT);

    //
    // Save the DAC read/write state. We determine if the DAC has been written
    // to or read from at the current index 0, 1, or 2 times (the application
    // is in the middle of reading or writing a DAC register triplet if the
    // count is 1 or 2), and save enough info so we can restore things
    // properly. The only hole is if the application writes to the Write Index,
    // then reads from instead of writes to the Data register, or vice-versa,
    // or if they do a partial read write, then never finish it.
    // This is fairly ridiculous behavior, however, and anyway there's nothing
    // we can do about it.
    //

    hardwareStateHeader->PortValue[DAC_STATE_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_STATE_PORT);

    if (hardwareStateHeader->PortValue[DAC_STATE_PORT] == 3) {

        //
        // The DAC Read Index was written to last. Figure out how many reads
        // have been done from the current index. We'll restart this on restore
        // by setting the Read Index to the current index - 1 (the read index
        // is one greater than the index being read), then doing the proper
        // number of reads.
        //
        // Read the Data register once, and see if the index changes.
        //

        dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two reads had already been done from
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Read the Data register again, and see if the index changes.
            //

            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one read had already been done
                // from the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 reads had been done from the current index,
            // then 0 reads were done, and we're all set, since the upper
            // nibble of the read/write state field is already 0.
            //

        }

    } else {

        //
        // The DAC Write Index was written to last. Figure out how many writes
        // have been done to the current index. We'll restart this on restore
        // by setting the Write Index to the proper index, then doing the
        // proper number of writes. When we do the DAC register save, we'll
        // read out the value that gets written (if there was a partial write
        // in progress), so we can restore the proper data later. This will
        // cause this current DAC location to be briefly wrong in the 1- and
        // 2-bytes-written case (until the app finishes the write), but that's
        // better than having the wrong DAC values written for good.
        //
        // Write the Data register once, and see if the index changes.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_DATA_REG_PORT, 0);

        if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    DAC_ADDRESS_WRITE_PORT) !=
                hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

            //
            // The DAC Index changed, so two writes had already been done to
            // the current index. Store the count "2" in the upper nibble of
            // the read/write state field.
            //

            hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x20;

        } else {

            //
            // Write the Data register again, and see if the index changes.
            //

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    DAC_DATA_REG_PORT, 0);

            if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        DAC_ADDRESS_WRITE_PORT) !=
                    hardwareStateHeader->PortValue[DAC_ADDRESS_WRITE_PORT]) {

                //
                // The DAC Index changed, so one write had already been done
                // to the current index. Store the count "1" in the upper
                // nibble of the read/write state field.
                //

                hardwareStateHeader->PortValue[DAC_STATE_PORT] |= 0x10;
            }

            //
            // If neither 2 nor 1 writes had been done to the current index,
            // then 0 writes were done, and we're all set.
            //

        }

    }


    //
    // Now, read out the 256 18-bit DAC palette registers (256 RGB triplets),
    // and blank the screen.
    //

    portValueDAC = (PUCHAR) hardwareStateHeader + VGA_BASIC_DAC_OFFSET;

    //
    // Read out DAC register 0, so we can set it to black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                DAC_ADDRESS_READ_PORT, 0);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);
    *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT);

    //
    // Set DAC register 0 to display black.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_ADDRESS_WRITE_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_DATA_REG_PORT, 0);

    //
    // Set the DAC mask register to force DAC register 0 to display all the
    // time (this is the register we just set to display black). From now on,
    // nothing but black will show up on the screen.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0);

    //
    // Read out the Attribute Controller Index state, and deduce the Index/Data
    // toggle state at the same time.
    //
    // Save the state of the Attribute Controller, both Index and Data,
    // so we can test in which state the toggle currently is.
    //

    originalACIndex = hardwareStateHeader->PortValue[ATT_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    ATT_ADDRESS_PORT);
    originalACData = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            ATT_DATA_READ_PORT);

    //
    // Sequencer Index.
    //

    hardwareStateHeader->PortValue[SEQ_ADDRESS_PORT] =
             VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                     SEQ_ADDRESS_PORT);

    //
    // Begin sync reset, just in case this is an SVGA and the currently
    // indexed Attribute Controller register controls clocking stuff (a
    // normal VGA won't require this).
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Now, write a different Index setting to the Attribute Controller, and
    // see if the Index changes.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            ATT_ADDRESS_PORT, (UCHAR) (originalACIndex ^ 0x10));

    if (VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT) == originalACIndex) {

        //
        // The Index didn't change, so the toggle was in the Data state.
        //

        hardwareStateHeader->AttribIndexDataState = 1;

        //
        // Restore the original Data state; we just corrupted it, and we need
        // to read it out later; also, it may glitch the screen if not
        // corrected. The toggle is already in the Index state.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, originalACIndex);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_WRITE_PORT, originalACData);

    } else {

        //
        // The Index did change, so the toggle was in the Index state.
        // No need to restore anything, because the Data register didn't
        // change, and we've already read out the Index register.
        //

        hardwareStateHeader->AttribIndexDataState = 0;

    }

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));



    //
    // Save the rest of the DAC registers.
    // Set the DAC address port Index, then read out the DAC Data registers.
    // Each three reads get Red, Green, and Blue components for that register.
    //
    // Read them one at a time due to problems on local bus machines.
    //

    for (i = 1; i < VGA_NUM_DAC_ENTRIES; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                                DAC_ADDRESS_READ_PORT, (UCHAR)i);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

        *portValueDAC++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                                                 DAC_DATA_REG_PORT);

    }


    //
    // The Feature Control register is read from 3CA but written at 3BA/3DA.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    } else {

        hardwareStateHeader->PortValue[FEAT_CTRL_WRITE_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        FEAT_CTRL_READ_PORT);

    }



    //
    // CRT Controller Index.
    //

    if (bIsColor) {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_COLOR] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_COLOR);

    } else {

        hardwareStateHeader->PortValue[CRTC_ADDRESS_PORT_MONO] =
                VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_ADDRESS_PORT_MONO);

    }


    //
    // Graphics Controller Index.
    //

    hardwareStateHeader->PortValue[GRAPH_ADDRESS_PORT] =
            VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    GRAPH_ADDRESS_PORT);


    //
    // Sequencer indexed registers.
    //

    portValue = ((PUCHAR) hardwareStateHeader) + VGA_BASIC_SEQUENCER_OFFSET;

    for (i = 0; i < VGA_NUM_SEQUENCER_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                SEQ_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                SEQ_DATA_PORT);

    }


    //
    // CRT Controller indexed registers.
    //

    //
    // Remember the state of CRTC register 3, then force bit 7
    // to 1 so we will read back the Vertical Retrace start and
    // end registers rather than the light pen info.
    //

    if (bIsColor) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_COLOR, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_COLOR);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_DATA_PORT_COLOR, (UCHAR) (ucCRTC03 | 0x80));
    } else {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_ADDRESS_PORT_MONO, 3);
        ucCRTC03 = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                        CRTC_DATA_PORT_MONO);
        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                CRTC_DATA_PORT_MONO, (UCHAR) (ucCRTC03 | 0x80));
    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;

    for (i = 0; i < VGA_NUM_CRTC_PORTS; i++) {

        if (bIsColor) {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_COLOR, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_COLOR);
        } else {

            VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                    CRTC_ADDRESS_PORT_MONO, (UCHAR)i);
            *portValue++ =
                    VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                            CRTC_DATA_PORT_MONO);
        }

    }

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_CRTC_OFFSET;
    portValue[3] = ucCRTC03;


    //
    // Graphics Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_GRAPH_CONT_OFFSET;

    for (i = 0; i < VGA_NUM_GRAPH_CONT_PORTS; i++) {

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT);

    }


    //
    // Attribute Controller indexed registers.
    //

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_ATTRIB_CONT_OFFSET;

    //
    // For each indexed AC register, reset the flip-flop for reading the
    // attribute register, then write the desired index to the AC Index,
    // then read the value of the indexed register from the AC Data register.
    //

    for (i = 0; i < VGA_NUM_ATTRIB_CONT_PORTS; i++) {

        if (bIsColor) {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_COLOR);
        } else {
            dummy = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                    INPUT_STATUS_1_MONO);
        }

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                ATT_ADDRESS_PORT, (UCHAR)i);
        *portValue++ = VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
                ATT_DATA_READ_PORT);

    }

    //
    // Save the latches. This destroys one byte of display memory in each
    // plane, which is unfortunate but unavoidable. Chips that provide
    // a way to read back the latches can avoid this problem.
    //
    // Set up the VGA's hardware so we can write the latches, then read them
    // back.
    //

    //
    // Begin sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8)));

    //
    // Set the Miscellaneous register to make sure we can access video RAM.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            MISC_OUTPUT_REG_WRITE_PORT, (UCHAR)(
            hardwareStateHeader->PortValue[MISC_OUTPUT_REG_WRITE_PORT] |
            0x02));

    //
    // Turn off Chain mode and map display memory at A0000 for 64K.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MISC);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xF1) | 0x04));

    //
    // Turn off Chain4 mode and odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT, IND_MEMORY_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            SEQ_DATA_PORT) & 0xF3) | 0x04));

    //
    // End sync reset.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT),
            (USHORT) (IND_SYNC_RESET + (END_SYNC_RESET_VALUE << 8)));

    //
    // Set the Map Mask to write to all planes.
    //

    VideoPortWritePortUshort((PUSHORT) (HwDeviceExtension->IOAddress +
            SEQ_ADDRESS_PORT), (USHORT) (IND_MAP_MASK + (0x0F << 8)));

    //
    // Set the write mode to 0, the read mode to 0, and turn off odd/even.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_GRAPH_MODE);
    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT,
            (UCHAR) ((VideoPortReadPortUchar(HwDeviceExtension->IOAddress +
            GRAPH_DATA_PORT) & 0xE4) | 0x01));

    //
    // Point to the last byte of display memory.
    //

    pScreen = (PUCHAR) HwDeviceExtension->VideoMemoryAddress +
            VGA_PLANE_SIZE - 1;

    //
    // Write the latches to the last byte of display memory.
    //

    VideoPortWriteRegisterUchar(pScreen, 0);

    //
    // Cycle through the four planes, reading the latch data from each plane.
    //

    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    portValue = (PUCHAR) hardwareStateHeader + VGA_BASIC_LATCHES_OFFSET;

    for (i=0; i<4; i++) {

        //
        // Set the Read Map for the current plane.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Read the latched data we've written to memory.
        //

        *portValue++ = VideoPortReadRegisterUchar(pScreen);

    }

    //
    // Set the VDM flags
    // We are a standard VGA, and then check if we have unemulated state.
    //

    hardwareStateHeader->VGAStateFlags = 0;

    if (HwDeviceExtension->TrappedValidatorCount) {

        hardwareStateHeader->VGAStateFlags |= VIDEO_STATE_UNEMULATED_VGA_STATE;

        //
        // Save the VDM Emulator data
        // No need to save the state of the sequencer port register for our
        // emulated data since it may change when we come back. It will be
        // recomputed.
        //

        hardwareStateHeader->ExtendedValidatorStateOffset = VGA_VALIDATOR_OFFSET;

        VideoPortMoveMemory(((PUCHAR) (hardwareStateHeader)) +
                                hardwareStateHeader->ExtendedValidatorStateOffset,
                            &(HwDeviceExtension->TrappedValidatorCount),
                            VGA_VALIDATOR_AREA_SIZE);

    } else {

        hardwareStateHeader->ExtendedValidatorStateOffset = 0;

    }

    //
    // Set the size of each plane.
    //

    hardwareStateHeader->PlaneLength = VGA_PLANE_SIZE;

    //
    // Store all the offsets for the planes in the structure.
    //

    hardwareStateHeader->Plane1Offset = VGA_PLANE_0_OFFSET;
    hardwareStateHeader->Plane2Offset = VGA_PLANE_1_OFFSET;
    hardwareStateHeader->Plane3Offset = VGA_PLANE_2_OFFSET;
    hardwareStateHeader->Plane4Offset = VGA_PLANE_3_OFFSET;

    //
    // Now copy the contents of video VRAM into the buffer.
    //
    // The VGA hardware is already set up so that video memory is readable;
    // we already turned off Chain mode, mapped in at A0000, turned off Chain4,
    // turned off odd/even, and set read mode 0 when we saved the latches.
    //
    // Point the Graphics Controller Index to the Read Map register.
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            GRAPH_ADDRESS_PORT, IND_READ_MAP);

    //
    // Point to the save area for the first plane.
    //

    bufferPointer = ((PUCHAR) (hardwareStateHeader)) +
                     hardwareStateHeader->Plane1Offset;

    //
    // Save the four planes consecutively.
    //

    for (i = 0; i < 4; i++) {

        //
        // Set the Read Map to select the plane we want to save next.
        //

        VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
                GRAPH_DATA_PORT, (UCHAR)i);

        //
        // Copy this plane into the buffer.
        //

        VideoPortMoveMemory(bufferPointer,
                           (PUCHAR) HwDeviceExtension->VideoMemoryAddress,
                           VGA_PLANE_SIZE);
        //
        // Point to the next plane's save area.
        //

        bufferPointer += VGA_PLANE_SIZE;
    }

    //
    // Reenable video output
    //

    VideoPortWritePortUchar(HwDeviceExtension->IOAddress +
            DAC_PIXEL_MASK_PORT, 0xff);


    return NO_ERROR;

} // end VgaSaveHardwareState()

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    )

/*++

Routine Description:

    Returns information needed in order for caller to implement bank
         management.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BankSelect - Pointer to a VIDEO_BANK_SELECT structure in which the bank
             select data will be returned (output buffer).

    BankSelectSize - Length of the output buffer supplied by the user.

    OutputSize - Pointer to a variable in which to return the actual size of
        the data returned in the output buffer.

Return Value:

    NO_ERROR - information returned successfully

    ERROR_MORE_DATA - output buffer not large enough to hold all info (but
        Size is returned, so caller can tell how large a buffer to allocate)

    ERROR_INSUFFICIENT_BUFFER - output buffer not large enough to return
        any useful data

--*/

{
    ULONG codeSize = (ULONG)(((ULONG_PTR)&BankSwitchEnd) - ((ULONG_PTR)&BankSwitchStart));
    PUCHAR pCode = (PUCHAR)BankSelect + sizeof(VIDEO_BANK_SELECT);

    //
    // check if a mode has been set
    //

    if (HwDeviceExtension->CurrentMode == NULL) {

        return ERROR_INVALID_FUNCTION;

    }

    //
    // The minimum passed buffer size is a VIDEO_BANK_SELECT
    // structure, so that we can return the required size; we can't do
    // anything if we don't have at least that much buffer.
    //

    if (BankSelectSize < sizeof(VIDEO_BANK_SELECT)) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //
    // Size of banking info.
    //

    BankSelect->Length = sizeof(VIDEO_BANK_SELECT);
    BankSelect->Size = sizeof(VIDEO_BANK_SELECT) + codeSize;

    //
    // There's room enough for everything, so fill in required fields in
    // VIDEO_BANK_SELECT.
    //
    // That's pretty easy in this case, since there's no banking; only
    // the banking type, the bitmap width, and the bitmap size need to be
    // filled in. We'll provide dummy bank switch code, too, that just
    // returns, because it shouldn't ever be called.
    //

    BankSelect->BankingFlags = 0;
    BankSelect->BankingType = VideoBanked1RW;
    BankSelect->PlanarHCBankingType = VideoBanked1RW;
    BankSelect->BitmapWidthInBytes = HwDeviceExtension->CurrentMode->wbytes;
    BankSelect->BitmapSize = HwDeviceExtension->CurrentMode->sbytes;

    BankSelect->Granularity = HwDeviceExtension->CurrentMode->Granularity;
    if(! BankSelect->Granularity ) 
         BankSelect->Granularity = 0x10000;
    BankSelect->PlanarHCGranularity = BankSelect->Granularity >> 2;

    //
    // If the buffer isn't big enough to hold all info, just return
    // ERROR_MORE_DATA; Size is already set.
    //

    if (BankSelectSize < BankSelect->Size ) {

        //
        // We're returning only the VIDEO_BANK_SELECT structure.
        //

        *OutputSize = sizeof(VIDEO_BANK_SELECT);
        return ERROR_MORE_DATA;
    }

    //
    // Set the bank switch code's location in the returned buffer.
    //

    BankSelect->CodeOffset = sizeof(VIDEO_BANK_SELECT);
    BankSelect->PlanarHCBankCodeOffset = sizeof(VIDEO_BANK_SELECT);
    BankSelect->PlanarHCEnableCodeOffset = sizeof(VIDEO_BANK_SELECT);
    BankSelect->PlanarHCDisableCodeOffset = sizeof(VIDEO_BANK_SELECT);

    //
    // Copy the code (just a RET; this code should never be called, since
    // there's no banking in any mode supported by this miniport, and we want
    // to flag such an incorrect call unmistakably) into the output buffer.
    //

    VideoPortMoveMemory(pCode,
                        &BankSwitchStart,
                        codeSize);

    //
    // Number of bytes we're returning is the full banking info size.
    //

    *OutputSize = BankSelect->Size;

    return NO_ERROR;

} // end VgaGetBankSelectCode()

VP_STATUS
VgaValidatorUcharEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    )

/*++

Routine Description:

    Entry point into the validator for byte I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_UCHAR_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) == END_SYNC_RESET_VALUE) &&
                 (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If we are accessing the seq address port, keep track of the
                // data value
                //

                if (Port == SEQ_ADDRESS_PORT) {

                    hwDeviceExtension->SequencerAddressValue = *Data;

                }

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                         (UCHAR) (*Data & 0xF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                            SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            //
            // If we get an access to the sequencer register, start trapping.
            //

            if ( (Port == SEQ_DATA_PORT) &&
                 ((*Data & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 (VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                         SEQ_ADDRESS_PORT) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_UCHAR_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + Port,
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUchar(hwDeviceExtension->IOAddress + Port);

        }
    }

    return NO_ERROR;

} // end VgaValidatorUcharEntry()

VP_STATUS
VgaValidatorUshortEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    )

/*++

Routine Description:

    Entry point into the validator for word I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar((PUCHAR) (hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT),
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress
                                                + Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             (ULONG)Port),
                                         (USHORT) (*Data & 0xFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_USHORT_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                             Port),
                                         *Data);

            }

        } else {

            *Data = VideoPortReadPortUshort((PUSHORT)(hwDeviceExtension->IOAddress +
                                            Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUshortEntry()

VP_STATUS
VgaValidatorUlongEntry(
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    )

/*++

Routine Description:

    Entry point into the validator for dword I/O operations.

    The entry point will be called whenever a byte operation was performed
    by a DOS application on one of the specified Video ports. The kernel
    emulator will forward these requests.

Arguments:

    Context - Context value that is passed to each call made to the validator
        function. This is the value the miniport driver specified in the
        MiniportConfigInfo->EmulatorAccessEntriesContext.

    Port - Port on which the operation is to be performed.

    AccessMode - Determines if it is a read or write operation.

    Data - Pointer to a variable containing the data to be written or a
        variable into which the read data should be stored.

Return Value:

    NO_ERROR.

--*/

{

    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) Context;
    ULONG endEmulation;
    UCHAR temp;

    Port -= VGA_BASE_IO_PORT;

    if (hwDeviceExtension->TrappedValidatorCount) {

        //
        // If we are processing a WRITE instruction, then store it in the
        // playback buffer. If the buffer is full, then play it back right
        // away, end sync reset and reinitialize the buffer with a sync
        // reset instruction.
        //
        // If we have a READ, we must flush the buffer (which has the side
        // effect of starting SyncReset), perform the read operation, stop
        // sync reset, and put back a sync reset instruction in the buffer
        // so we can go on appropriately
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscellaneous register is always 0.
            // If it is 1 it could select a non-existent clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                *Data &= 0xFFFFFFF7;

            }

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Port = Port;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].AccessType = VGA_VALIDATOR_ULONG_ACCESS;

            hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
                TrappedValidatorCount].Data = *Data;

            hwDeviceExtension->TrappedValidatorCount++;

            //
            // Check to see if this instruction was ending sync reset.
            // If it did, we must flush the buffer and reset the trapped
            // IO ports to the minimal set.
            //

            if (Port == SEQ_ADDRESS_PORT) {

                //
                // If we are accessing the seq address port, keep track of its
                // value
                //

                hwDeviceExtension->SequencerAddressValue = (*Data & 0xFF);

            }

            if ((Port == SEQ_ADDRESS_PORT) &&
                ( ((*Data >> 8) & END_SYNC_RESET_VALUE) ==
                   END_SYNC_RESET_VALUE) &&
                (hwDeviceExtension->SequencerAddressValue == IND_SYNC_RESET)) {

                endEmulation = 1;

            } else {

                //
                // If the buffer is not full, then just return right away.
                //

                if (hwDeviceExtension->TrappedValidatorCount <
                       VGA_MAX_VALIDATOR_DATA - 1) {

                    return NO_ERROR;

                }

                endEmulation = 0;
            }
        }

        //
        // We are either in a READ path or a WRITE path that caused a
        // a full buffer. So flush the buffer either way.
        //
        // To do this put an END_SYNC_RESET at the end since we want to make
        // the buffer is ended sync reset ended.
        //

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].AccessType = VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[hwDeviceExtension->
            TrappedValidatorCount].Data = (USHORT) (IND_SYNC_RESET +
                                          (END_SYNC_RESET_VALUE << 8));

        hwDeviceExtension->TrappedValidatorCount++;

        VideoPortSynchronizeExecution(hwDeviceExtension,
                                      VpHighPriority,
                                      (PMINIPORT_SYNCHRONIZE_ROUTINE)
                                          VgaPlaybackValidatorData,
                                      hwDeviceExtension);

        //
        // Write back the real value of the sequencer address port.
        //

        VideoPortWritePortUchar(hwDeviceExtension->IOAddress +
                                    SEQ_ADDRESS_PORT,
                                (UCHAR) hwDeviceExtension->SequencerAddressValue);

        //
        // If we are in a READ path, read the data
        //

        if (AccessMode & EMULATOR_READ_ACCESS) {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

            endEmulation = 0;

        }

        //
        // If we are ending emulation, reset trapping to the minimal amount
        // and exit.
        //

        if (endEmulation) {

            VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                             NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE,
                                             MinimalVgaValidatorAccessRange);

            return NO_ERROR;

        }

        //
        // For both cases, put back a START_SYNC_RESET in the buffer.
        //

        hwDeviceExtension->TrappedValidatorCount = 1;

        hwDeviceExtension->TrappedValidatorData[0].Port = SEQ_ADDRESS_PORT;

        hwDeviceExtension->TrappedValidatorData[0].AccessType =
                VGA_VALIDATOR_USHORT_ACCESS;

        hwDeviceExtension->TrappedValidatorData[0].Data =
                (ULONG) (IND_SYNC_RESET + (START_SYNC_RESET_VALUE << 8));

    } else {

        //
        // Nothing trapped.
        // Lets check is the IO is trying to do something that would require
        // us to stop trapping
        //

        if (AccessMode & EMULATOR_WRITE_ACCESS) {

            //
            // Make sure Bit 3 of the Miscelaneous register is always 0.
            // If it is 1 it could select a non-existant clock, and kill the
            // system
            //

            if (Port == MISC_OUTPUT_REG_WRITE_PORT) {

                temp = VideoPortReadPortUchar(hwDeviceExtension->IOAddress +
                                                  SEQ_ADDRESS_PORT);

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (START_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                             Port),
                                         (ULONG) (*Data & 0xFFFFFFF7) );

                VideoPortWritePortUshort((PUSHORT) (hwDeviceExtension->IOAddress +
                                             SEQ_ADDRESS_PORT),
                                         (USHORT) (IND_SYNC_RESET +
                                             (END_SYNC_RESET_VALUE << 8)));

                VideoPortWritePortUchar(hwDeviceExtension->IOAddress + SEQ_ADDRESS_PORT,
                                        temp);

                return NO_ERROR;

            }

            if ( (Port == SEQ_ADDRESS_PORT) &&
                 (((*Data>> 8) & END_SYNC_RESET_VALUE) != END_SYNC_RESET_VALUE) &&
                 ((*Data & 0xFF) == IND_SYNC_RESET)) {

                VideoPortSetTrappedEmulatorPorts(hwDeviceExtension,
                                                 NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE,
                                                 FullVgaValidatorAccessRange);

                hwDeviceExtension->TrappedValidatorCount = 1;
                hwDeviceExtension->TrappedValidatorData[0].Port = Port;
                hwDeviceExtension->TrappedValidatorData[0].AccessType =
                    VGA_VALIDATOR_ULONG_ACCESS;

                hwDeviceExtension->TrappedValidatorData[0].Data = *Data;

                //
                // Start keeping track of the state of the sequencer port.
                //

                hwDeviceExtension->SequencerAddressValue = IND_SYNC_RESET;

            } else {

                VideoPortWritePortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                            Port),
                                        *Data);

            }

        } else {

            *Data = VideoPortReadPortUlong((PULONG) (hwDeviceExtension->IOAddress +
                                               Port));

        }
    }

    return NO_ERROR;

} // end VgaValidatorUlongEntry()


BOOLEAN
VgaPlaybackValidatorData(
    PVOID Context
    )

/*++

Routine Description:

    Performs all the DOS apps IO port accesses that were trapped by the
    validator. Only IO accesses that can be processed are WRITEs

    The number of outstanding IO access in deviceExtension is set to
    zero as a side effect.

    This function must be called via a call to VideoPortSynchronizeRoutine.

Arguments:

    Context - Context parameter passed to the synchronized routine.
        Must be a pointer to the miniport driver's device extension.

Return Value:

    TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = Context;
    ULONG_PTR ioBaseAddress = (ULONG_PTR) hwDeviceExtension->IOAddress;
    ULONG i;
    PVGA_VALIDATOR_DATA validatorData = hwDeviceExtension->TrappedValidatorData;

    //
    // Loop through the array of data and do instructions one by one.
    //

    for (i = 0; i < hwDeviceExtension->TrappedValidatorCount;
         i++, validatorData++) {

        //
        // Calculate base address first
        //

        ioBaseAddress = (ULONG_PTR)hwDeviceExtension->IOAddress +
                            validatorData->Port;


        //
        // This is a write operation. We will automatically stop when the
        // buffer is empty.
        //

        switch (validatorData->AccessType) {

        case VGA_VALIDATOR_UCHAR_ACCESS :

            VideoPortWritePortUchar((PUCHAR)ioBaseAddress,
                                    (UCHAR) validatorData->Data);

            break;

        case VGA_VALIDATOR_USHORT_ACCESS :

            VideoPortWritePortUshort((PUSHORT)ioBaseAddress,
                                     (USHORT) validatorData->Data);

            break;

        case VGA_VALIDATOR_ULONG_ACCESS :

            VideoPortWritePortUlong((PULONG)ioBaseAddress,
                                    (ULONG) validatorData->Data);

            break;

        default:

            VideoDebugPrint((0, "InvalidValidatorAccessType\n" ));

        }
    }

    hwDeviceExtension->TrappedValidatorCount = 0;

    return TRUE;

} // end VgaPlaybackValidatorData()

VP_STATUS
VgaSetBankPosition(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PBANK_POSITION BankPosition
    )

{
    PVIDEO_PORT_INT10_INTERFACE Int10 = &hwDeviceExtension->Int10;
    INT10_BIOS_ARGUMENTS BiosArguments;

    ASSERT(Int10 != NULL);

    BiosArguments.Eax = 0x4f05;
    BiosArguments.Ebx = 0;
    BiosArguments.Edx = BankPosition->WriteBankPosition;
    Int10->Int10CallBios(Int10->Context, &BiosArguments);

    BiosArguments.Eax = 0x4f05;
    BiosArguments.Ebx = 1;
    BiosArguments.Edx = BankPosition->ReadBankPosition;
    Int10->Int10CallBios(Int10->Context, &BiosArguments);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\vga.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vga.h

Abstract:

    This module contains the definitions for the code that implements the
    VGA device driver.

Author:

Environment:

    Kernel mode

Revision History:


--*/

//
// Base address of VGA memory range.  Also used as base address of VGA
// memory when loading a font, which is done with the VGA mapped at A0000.
//

#define MEM_VGA      0xA0000
#define MEM_VGA_SIZE 0x20000

//
// Index in the access range sturture for video memory
// !!! This must match the VgaAccessRange structure    !!!
// !!! Memory is in the structure, index 2 (3rd entry) !!!

#define VGA_MEMORY  2


//
// VGA port-related definitions.
//
//
// Port definitions for filling the ACCSES_RANGES structure in the miniport
// information, defines the range of I/O ports the VGA spans.
// There is a break in the IO ports - a few ports are used for the parallel
// port. Those cannot be defined in the ACCESS_RANGE, but are still mapped
// so all VGA ports are in one address range.
//

#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF

//
// VGA register definitions
//
                                            // ports in monochrome mode
#define CRTC_ADDRESS_PORT_MONO      0x0004  // CRT Controller Address and
#define CRTC_DATA_PORT_MONO         0x0005  // Data registers in mono mode
#define FEAT_CTRL_WRITE_PORT_MONO   0x000A  // Feature Control write port
                                            // in mono mode
#define INPUT_STATUS_1_MONO         0x000A  // Input Status 1 register read
                                            // port in mono mode
#define ATT_INITIALIZE_PORT_MONO    INPUT_STATUS_1_MONO
                                            // Register to read to reset
                                            // Attribute Controller index/data

#define ATT_ADDRESS_PORT            0x0010  // Attribute Controller Address and
#define ATT_DATA_WRITE_PORT         0x0010  // Data registers share one port
                                            // for writes, but only Address is
                                            // readable at 0x3C0
#define ATT_DATA_READ_PORT          0x0011  // Attribute Controller Data reg is
                                            // readable here
#define MISC_OUTPUT_REG_WRITE_PORT  0x0012  // Miscellaneous Output reg write
                                            // port
#define INPUT_STATUS_0_PORT         0x0012  // Input Status 0 register read
                                            // port
#define VIDEO_SUBSYSTEM_ENABLE_PORT 0x0013  // Bit 0 enables/disables the
                                            // entire VGA subsystem
#define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address and
#define SEQ_DATA_PORT               0x0015  // Data registers
#define DAC_PIXEL_MASK_PORT         0x0016  // DAC pixel mask reg
#define DAC_ADDRESS_READ_PORT       0x0017  // DAC register read index reg,
                                            // write-only
#define DAC_STATE_PORT              0x0017  // DAC state (read/write),
                                            // read-only
#define DAC_ADDRESS_WRITE_PORT      0x0018  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x0019  // DAC data transfer reg
#define FEAT_CTRL_READ_PORT         0x001A  // Feature Control read port
#define MISC_OUTPUT_REG_READ_PORT   0x001C  // Miscellaneous Output reg read
                                            // port
#define GRAPH_ADDRESS_PORT          0x001E  // Graphics Controller Address
#define GRAPH_DATA_PORT             0x001F  // and Data registers

#define CRTC_ADDRESS_PORT_COLOR     0x0024  // CRT Controller Address and
#define CRTC_DATA_PORT_COLOR        0x0025  // Data registers in color mode
#define FEAT_CTRL_WRITE_PORT_COLOR  0x002A  // Feature Control write port
#define INPUT_STATUS_1_COLOR        0x002A  // Input Status 1 register read
                                            // port in color mode
#define ATT_INITIALIZE_PORT_COLOR   INPUT_STATUS_1_COLOR
                                            // Register to read to reset
                                            // Attribute Controller index/data
                                            // toggle in color mode

//
// Offsets in HardwareStateHeader->PortValue[] of save areas for non-indexed
// VGA registers.
//

#define CRTC_ADDRESS_MONO_OFFSET      0x04
#define FEAT_CTRL_WRITE_MONO_OFFSET   0x0A
#define ATT_ADDRESS_OFFSET            0x10
#define MISC_OUTPUT_REG_WRITE_OFFSET  0x12
#define VIDEO_SUBSYSTEM_ENABLE_OFFSET 0x13
#define SEQ_ADDRESS_OFFSET            0x14
#define DAC_PIXEL_MASK_OFFSET         0x16
#define DAC_STATE_OFFSET              0x17
#define DAC_ADDRESS_WRITE_OFFSET      0x18
#define GRAPH_ADDRESS_OFFSET          0x1E
#define CRTC_ADDRESS_COLOR_OFFSET     0x24
#define FEAT_CTRL_WRITE_COLOR_OFFSET  0x2A

//
// VGA indexed register indexes.
//

#define IND_CURSOR_START        0x0A    // index in CRTC of the Cursor Start
#define IND_CURSOR_END          0x0B    //  and End registers
#define IND_CURSOR_HIGH_LOC     0x0E    // index in CRTC of the Cursor Location
#define IND_CURSOR_LOW_LOC      0x0F    //  High and Low Registers
#define IND_VSYNC_END           0x11    // index in CRTC of the Vertical Sync
                                        //  End register, which has the bit
                                        //  that protects/unprotects CRTC
                                        //  index registers 0-7
#define IND_SET_RESET_ENABLE    0x01    // index of Set/Reset Enable reg in GC
#define IND_DATA_ROTATE         0x03    // index of Data Rotate reg in GC
#define IND_READ_MAP            0x04    // index of Read Map reg in Graph Ctlr
#define IND_GRAPH_MODE          0x05    // index of Mode reg in Graph Ctlr
#define IND_GRAPH_MISC          0x06    // index of Misc reg in Graph Ctlr
#define IND_BIT_MASK            0x08    // index of Bit Mask reg in Graph Ctlr
#define IND_SYNC_RESET          0x00    // index of Sync Reset reg in Seq
#define IND_MAP_MASK            0x02    // index of Map Mask in Sequencer
#define IND_MEMORY_MODE         0x04    // index of Memory Mode reg in Seq
#define IND_CRTC_PROTECT        0x11    // index of reg containing regs 0-7 in
                                        //  CRTC

#define START_SYNC_RESET_VALUE  0x01    // value for Sync Reset reg to start
                                        //  synchronous reset
#define END_SYNC_RESET_VALUE    0x03    // value for Sync Reset reg to end
                                        //  synchronous reset

//
// Values for Attribute Controller Index register to turn video off
// and on, by setting bit 5 to 0 (off) or 1 (on).
//

#define VIDEO_DISABLE 0
#define VIDEO_ENABLE  0x20

//
// Value written to the Read Map register when identifying the existence of
// a VGA in VgaInitialize. This value must be different from the final test
// value written to the Bit Mask in that routine.
//

#define READ_MAP_TEST_SETTING 0x03

//
// Masks to keep only the significant bits of the Graphics Controller and
// Sequencer Address registers. Masking is necessary because some VGAs, such
// as S3-based ones, don't return unused bits set to 0, and some SVGAs use
// these bits if extensions are enabled.
//

#define GRAPH_ADDR_MASK 0x0F
#define SEQ_ADDR_MASK   0x07

//
// Mask used to toggle Chain4 bit in the Sequencer's Memory Mode register.
//

#define CHAIN4_MASK 0x08

//
// Default text mode setting for various registers, used to restore their
// states if VGA detection fails after they've been modified.
//

#define MEMORY_MODE_TEXT_DEFAULT 0x02
#define BIT_MASK_DEFAULT 0xFF
#define READ_MAP_DEFAULT 0x00

//
// Palette-related info.
//

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF

//
// Highest valid palette register index
//

#define VIDEO_MAX_PALETTE_REGISTER 0x0F

//
// For a mode, the type of banking supported. Controls the information
// returned in VIDEO_BANK_SELECT. PlanarHCBanking includes NormalBanking.
//

typedef enum _BANK_TYPE {
    NoBanking = 0,
    NormalBanking,
    PlanarHCBanking
} BANK_TYPE, *PBANK_TYPE;

//
// Structure used to describe each video mode in ModesVGA[].
//

typedef struct {
    USHORT  fbType; // color or monochrome, text or graphics, via
                    //  VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
    USHORT  numPlanes;    // # of video memory planes
    USHORT  bitsPerPlane; // # of bits of color in each plane
    SHORT   col;    // # of text columns across screen with default font
    SHORT   row;    // # of text rows down screen with default font
    USHORT  hres;   // # of pixels across screen
    USHORT  vres;   // # of scan lines down screen
    USHORT  frequency;    // refresh rate in Hz
    USHORT  wbytes; // # of bytes from start of one scan line to start of next
    ULONG   sbytes; // total size of addressable display memory in bytes
    BANK_TYPE banktype; // NoBanking, NormalBanking, PlanarHCBanking
#ifdef INT10_MODE_SET
    ULONG   Int10ModeNumber;
#else
    PUSHORT CmdStrings;     // pointer to array of register-setting commands
#endif
    ULONG MemoryBase;       // Base of frame buffer
    ULONG FrameOffset;      // Offset from beginning of frame buffer for this mode
    ULONG FrameLength;      // Size of available frame buffer
    ULONG MemoryLength;     // Total memory
    ULONG PixelsPerScan;    // This is larger than hres if we need to stretch scan
    BOOLEAN NonVgaHardware; // If this mode is compatible with VGA hw register & io ports
    ULONG Granularity;      // The window granularity for banked modes
} VIDEOMODE, *PVIDEOMODE;


//
// Mode into which to put the VGA before starting a VDM, so it's a plain
// vanilla VGA.  (This is the mode's index in ModesVGA[], currently standard
// 80x25 text mode.)
//

#define DEFAULT_MODE 0


//
// Info for the validator functions.
//

//
// Number of each type of indexed register in a standard VGA, used by
// validator and state save/restore functions.
//
// Note: VDMs currently only support basic VGAs only.
//

#define VGA_NUM_SEQUENCER_PORTS     5
#define VGA_NUM_CRTC_PORTS         25
#define VGA_NUM_GRAPH_CONT_PORTS    9
#define VGA_NUM_ATTRIB_CONT_PORTS  21
#define VGA_NUM_DAC_ENTRIES       256

//
// Number of each type of extended indexed register.
//

#define EXT_NUM_SEQUENCER_PORTS     0
#define EXT_NUM_CRTC_PORTS          0
#define EXT_NUM_GRAPH_CONT_PORTS    0
#define EXT_NUM_ATTRIB_CONT_PORTS   0
#define EXT_NUM_DAC_ENTRIES         0

//
// Info used by the Validator functions and save/restore code.
// Structure used to trap register accesses that must be done atomically.
//

#define VGA_MAX_VALIDATOR_DATA             100

#define VGA_VALIDATOR_UCHAR_ACCESS   1
#define VGA_VALIDATOR_USHORT_ACCESS  2
#define VGA_VALIDATOR_ULONG_ACCESS   3

typedef struct _VGA_VALIDATOR_DATA {
   ULONG Port;
   UCHAR AccessType;
   ULONG Data;
} VGA_VALIDATOR_DATA, *PVGA_VALIDATOR_DATA;


//
// Info for the save and restore state functions.
//

//
// Number of bytes to save in each plane.
//

#define VGA_PLANE_SIZE 0x10000

//
// These constants determine the offsets within the
// VIDEO_HARDWARE_STATE_HEADER structure that are used to save and
// restore the VGA's state.
//

#define VGA_HARDWARE_STATE_SIZE sizeof(VIDEO_HARDWARE_STATE_HEADER)

#define VGA_BASIC_SEQUENCER_OFFSET (VGA_HARDWARE_STATE_SIZE + 0)
#define VGA_BASIC_CRTC_OFFSET (VGA_BASIC_SEQUENCER_OFFSET + \
         VGA_NUM_SEQUENCER_PORTS)
#define VGA_BASIC_GRAPH_CONT_OFFSET (VGA_BASIC_CRTC_OFFSET + \
         VGA_NUM_CRTC_PORTS)
#define VGA_BASIC_ATTRIB_CONT_OFFSET (VGA_BASIC_GRAPH_CONT_OFFSET + \
         VGA_NUM_GRAPH_CONT_PORTS)
#define VGA_BASIC_DAC_OFFSET (VGA_BASIC_ATTRIB_CONT_OFFSET + \
         VGA_NUM_ATTRIB_CONT_PORTS)
#define VGA_BASIC_LATCHES_OFFSET (VGA_BASIC_DAC_OFFSET + \
         (3 * VGA_NUM_DAC_ENTRIES))

#define VGA_EXT_SEQUENCER_OFFSET (VGA_BASIC_LATCHES_OFFSET + 4)
#define VGA_EXT_CRTC_OFFSET (VGA_EXT_SEQUENCER_OFFSET + \
         EXT_NUM_SEQUENCER_PORTS)
#define VGA_EXT_GRAPH_CONT_OFFSET (VGA_EXT_CRTC_OFFSET + \
         EXT_NUM_CRTC_PORTS)
#define VGA_EXT_ATTRIB_CONT_OFFSET (VGA_EXT_GRAPH_CONT_OFFSET + \
         EXT_NUM_GRAPH_CONT_PORTS)
#define VGA_EXT_DAC_OFFSET (VGA_EXT_ATTRIB_CONT_OFFSET + \
         EXT_NUM_ATTRIB_CONT_PORTS)

#define VGA_VALIDATOR_OFFSET (VGA_EXT_DAC_OFFSET + 4 * EXT_NUM_DAC_ENTRIES)

#define VGA_VALIDATOR_AREA_SIZE  sizeof (ULONG) + (VGA_MAX_VALIDATOR_DATA * \
                                 sizeof (VGA_VALIDATOR_DATA)) +             \
                                 sizeof (ULONG) +                           \
                                 sizeof (ULONG) +                           \
                                 sizeof (PVIDEO_ACCESS_RANGE)

#define VGA_MISC_DATA_AREA_OFFSET VGA_VALIDATOR_OFFSET + VGA_VALIDATOR_AREA_SIZE

#define VGA_MISC_DATA_AREA_SIZE  0

#define VGA_PLANE_0_OFFSET VGA_MISC_DATA_AREA_OFFSET + VGA_MISC_DATA_AREA_SIZE

#define VGA_PLANE_1_OFFSET VGA_PLANE_0_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_2_OFFSET VGA_PLANE_1_OFFSET + VGA_PLANE_SIZE
#define VGA_PLANE_3_OFFSET VGA_PLANE_2_OFFSET + VGA_PLANE_SIZE

//
// Space needed to store all state data.
//

#define VGA_TOTAL_STATE_SIZE VGA_PLANE_3_OFFSET + VGA_PLANE_SIZE


//
// Device extension for the driver object.  This data is only used
// locally, so this structure can be added to as needed.
//

typedef struct _HW_DEVICE_EXTENSION {

    PUCHAR IOAddress;              // base I/O address of VGA ports
    PVOID VideoMemoryAddress;      // base virtual memory address of VGA memory
    ULONG   ModeIndex;             // index of current mode in ModesVGA[]
    PVIDEOMODE CurrentMode;        // pointer to VIDEOMODE structure for
                                   // current mode

    USHORT  FontPelColumns;        // Width of the font in pels
    USHORT  FontPelRows;           // height of the font in pels

    VIDEO_CURSOR_POSITION CursorPosition;     // current cursor position

    UCHAR CursorEnable;            // whether cursor is enabled or not
    UCHAR CursorTopScanLine;       // Cursor Start register setting (top scan)
    UCHAR CursorBottomScanLine;    // Cursor End register setting (bottom scan)

    PHYSICAL_ADDRESS PhysicalVideoMemoryBase; // physical memory address and
    ULONG PhysicalVideoMemoryLength;          // length of display memory
    PHYSICAL_ADDRESS PhysicalFrameBaseOffset; // physical memory address and
    ULONG PhysicalFrameLength;                // length of display memory for
                                              // the current mode.

    //
    // These 4 fields must be at the end of the device extension and must be
    // kept in this order since this data will be copied to and from the save
    // state buffer that is passed to and from the VDM.
    //

    ULONG TrappedValidatorCount;   // number of entries in the Trapped
                                   // validator data Array.
    VGA_VALIDATOR_DATA TrappedValidatorData[VGA_MAX_VALIDATOR_DATA];
                                   // Data trapped by the validator routines
                                   // but not yet played back into the VGA
                                   // register.

    ULONG SequencerAddressValue;   // Determines if the Sequencer Address Port
                                   // is currently selecting the SyncReset data
                                   // register.

    ULONG CurrentNumVdmAccessRanges;           // Number of access ranges in
                                               // the access range array pointed
                                               // to by the next field
    PVIDEO_ACCESS_RANGE CurrentVdmAccessRange; // Access range currently
                                               // associated to the VDM

    VIDEO_PORT_INT10_INTERFACE Int10; // Int10 interface
    USHORT VdmSeg;                    // Segment of Bios transfer area
    USHORT VdmOff;                    // Offset of Bios transfer area

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Function prototypes.
//

VP_STATUS
VgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
VgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
VgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

//
// Private function prototypes.
//

VP_STATUS
VgaQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE Mode,
    ULONG ModeSize,
    PULONG FrameBufferIsMoved
    );

VP_STATUS
VgaLoadAndSetFont(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_LOAD_FONT_INFORMATION FontInformation,
    ULONG FontInformationSize
    );

VP_STATUS
VgaQueryCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorPosition(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_POSITION CursorPosition,
    ULONG CursorPositionSize
    );

VP_STATUS
VgaQueryCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize,
    PULONG OutputSize
    );

VP_STATUS
VgaSetCursorAttributes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CURSOR_ATTRIBUTES CursorAttributes,
    ULONG CursorAttributesSize
    );

BOOLEAN
VgaIsPresent(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

VP_STATUS
VgaInterpretCmdStream(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PUSHORT pusCmdStream
    );

VP_STATUS
VgaSetPaletteReg(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_PALETTE_DATA PaletteBuffer,
    ULONG PaletteBufferSize
    );

VP_STATUS
VgaSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VP_STATUS
VgaRestoreHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize
    );

VP_STATUS
VgaSaveHardwareState(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_HARDWARE_STATE HardwareState,
    ULONG HardwareStateSize,
    PULONG OutputSize
    );

VP_STATUS
VgaGetBankSelectCode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_BANK_SELECT BankSelect,
    ULONG BankSelectSize,
    PULONG OutputSize
    );

VOID
VgaZeroVideoMemory(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

//
// Entry points for the VGA validator. Used in VgaEmulatorAccessEntries[].
//

VP_STATUS
VgaValidatorUcharEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUCHAR Data
    );

VP_STATUS
VgaValidatorUshortEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PUSHORT Data
    );

VP_STATUS
VgaValidatorUlongEntry (
    ULONG_PTR Context,
    ULONG Port,
    UCHAR AccessMode,
    PULONG Data
    );

BOOLEAN
VgaPlaybackValidatorData (
    PVOID Context
    );

VP_STATUS
VgaSetBankPosition(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PBANK_POSITION BankPosition
    );

USHORT
RaiseToPower2(
    USHORT x
    );

ULONG
RaiseToPower2Ulong(
    ULONG x
    );

BOOLEAN
IsPower2(
    USHORT x
    );

//
// Global to make sure driver is only loaded once.
//

extern ULONG VgaLoaded;

#if DBG
#define MAX_CONTROL_HISTORY 512
extern ULONG giControlCode;
extern ULONG gaIOControlCode[];
#endif



//
// Bank switch code start and end labels, define in HARDWARE.ASM
//

extern UCHAR BankSwitchStart;
extern UCHAR BankSwitchEnd;

//
// Vga init scripts for font loading
//

extern USHORT EnableA000Data[];
extern USHORT DisableA000Color[];


extern USHORT VGA_640x480[];
extern USHORT VGA_TEXT_0[];
extern USHORT VGA_TEXT_1[];
extern USHORT ModeX240[];
extern USHORT ModeX200[];
extern USHORT ModeXDoubleScans[];

extern VIDEOMODE ModesVGA[];
extern ULONG NumVideoModes;
extern PVIDEOMODE VgaModeList;

#define NUM_VGA_ACCESS_RANGES  5
extern VIDEO_ACCESS_RANGE VgaAccessRange[];

#define VGA_NUM_EMULATOR_ACCESS_ENTRIES     8
extern EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[];

#define NUM_MINIMAL_VGA_VALIDATOR_ACCESS_RANGE 5
extern VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[];

#define NUM_FULL_VGA_VALIDATOR_ACCESS_RANGE 3
extern VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\i386\vgahard.asm ===
title  "Vga Hard.asm"
;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;     vgahard.asm
;
; Abstract:
;
;	This module includes the banking stub.
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;
;--

.386p
        .xlist
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Bank Switching Stub"

;
;    Bank switching code. There are no banks in any mode supported by this
;    miniport driver, so there's a bug if this code,
;
        public _BankSwitchStart, _BankSwitchEnd
_BankSwitchStart proc ;start of bank switch code

        ret           ; This should be a fatal error ...

;
;    Just here to generate end-of-bank-switch code label.
;
_BankSwitchEnd:

_BankSwitchStart endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\vgadata.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    vgadata.c

Abstract:

    This module contains all the global data used by the VGA driver.

Environment:

    Kernel mode

Revision History:


--*/

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"
#include "vga.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE_DATA")
#endif


//
// Global to make sure driver is only loaded once.
//

ULONG VgaLoaded = 0;

#if DBG
ULONG giControlCode;
ULONG gaIOControlCode[MAX_CONTROL_HISTORY];
#endif


//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    1                                            // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    1
},
{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    1
},
    // HACK Allow our standard VGA to be used with ATI cards:
    // ATI uses an extra IO port at location 1CE on pretty much all of its
    // video boards
{
    0x000001CE, 0x00000000,
    2,
    1,
    1,
    1
},
    // Another HACK to fix ATI problems.  During GUI mode setup
    // Network detection may touch ports in the 0x2e8 to 0x2ef range.  ATI
    // decodes these ports, and the video goes out of sync when network
    // detection runs.
    //
    // NOTE: We don't need to add this to validator routines since the
    // ATI bios won't touch these registers.
{
    0x000002E8, 0x00000000,
    8,
    1,
    1,
    1
}
};


//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {

    //
    // Traps for byte OUTs.
    //

    {
        0x000003b0,                   // range start I/O address
        0xC,                          // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    {
        0x000003c0,                   // range start I/O address
        0x20,                         // range length
        Uchar,                        // access size to trap
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
        FALSE,                        // does not support string accesses
        (PVOID)VgaValidatorUcharEntry // routine to which to trap
    },

    //
    // Traps for word OUTs.
    //

    {
        0x000003b0,
        0x06,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    {
        0x000003c0,
        0x10,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    },

    //
    // Traps for dword OUTs.
    //

    {
        0x000003b0,
        0x03,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    {
        0x000003c0,
        0x08,
        Ulong,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUlongEntry
    },

    //
    // ATI hack for port 1CE
    //

    {
        0x000001ce,
        0x2,
        Uchar,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUcharEntry
    },

    {
        0x000001ce,
        0x1,
        Ushort,
        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
        FALSE,
        (PVOID)VgaValidatorUshortEntry
    }

};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    1
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    1
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    1
},
    // HACK Allow our standard VGA to be used with ATI cards:
    // ATI uses an extra IO port at location 1CE on pretty much all of its
    // video boards
{
    0x000001CE, 0x00000000,
    2,
    1,
    1,
    1
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    1
},
    // HACK Allow our standard VGA to be used with ATI cards:
    // ATI uses an extra IO port at location 1CE on pretty much all of its
    // video boards
{
    0x000001CE, 0x00000000,
    2,
    1,
    0,
    1
}
};


//
// Color graphics mode 0x12, 640x480 16 colors.

#ifndef INT10_MODE_SET
//
USHORT VGA_640x480[] = {
    OWM,                            // start sync reset program up sequencer
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0f02,0x0003,0x0604,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,     // Misc output register
    0xe3,

    OW,                             // Set chain mode in sync reset
    GRAPH_ADDRESS_PORT,
    0x0506,

    OB,                             // EndSyncResetCmd
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,                             // Unlock CRTC registers 0-7
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4F,0x50,0x82,0x54,0x80,0x0B,0x3E,0x00,0x40,0x0,0x0,0x0,0x0,0x0,0x0,
    0xEA,0x8C,0xDF,0x28,0x0,0xE7,0x4,0xE3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 // program attribute controller registers
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
    0x01,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                // program graphics controller registers
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x0,0x05,0x0F,0x0FF,

    OB,                             // DAC mask registers
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

//
// Color text mode, 720x480
//

USHORT VGA_TEXT_0[] = {

    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0001,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0x67,

    OW,
    GRAPH_ADDRESS_PORT,
    0x0e06,

//  EndSyncResetCmd
    OB,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0E11,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4f,0xd,0xe,0x0,0x0,0x0,0x0,
    0x9c,0x8e,0x8f,0x28,0x1f,0x96,0xb9,0xa3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x04,0x0,0x0F,0x8,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

#endif//!INT10_MODE_SET

//
// Color text mode, 640x480
//

USHORT VGA_TEXT_1[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    5,
    0x0100,0x0101,0x0302,0x0003,0x0204,    // program up sequencer

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xa3,

    OW,
    GRAPH_ADDRESS_PORT,
    0x0e06,

//  EndSyncResetCmd
    OB,
    SEQ_ADDRESS_PORT,
    IND_SYNC_RESET,

    OB,
    SEQ_DATA_PORT,
    END_SYNC_RESET_VALUE,

    OW,
    CRTC_ADDRESS_PORT_COLOR,
    0x0511,

    METAOUT+INDXOUT,                // program crtc registers
    CRTC_ADDRESS_PORT_COLOR,
    VGA_NUM_CRTC_PORTS,             // count
    0,                              // start index
    0x5F,0x4f,0x50,0x82,0x55,0x81,0xbf,0x1f,0x00,0x4d,0xb,0xc,0x0,0x0,0x0,0x0,
    0x83,0x85,0x5d,0x28,0x1f,0x63,0xba,0xa3,0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    METAOUT+ATCOUT,                 //
    ATT_ADDRESS_PORT,               // port
    VGA_NUM_ATTRIB_CONT_PORTS,      // count
    0,                              // start index
    0x0,0x1,0x2,0x3,0x4,0x5,0x14,0x7,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x00,0x0,0x0F,0x0,0x0,

    METAOUT+INDXOUT,                //
    GRAPH_ADDRESS_PORT,             // port
    VGA_NUM_GRAPH_CONT_PORTS,       // count
    0,                              // start index
    0x00,0x0,0x0,0x0,0x0,0x10,0x0e,0x0,0x0FF,

    OB,
    DAC_PIXEL_MASK_PORT,
    0xFF,

    IB,                             // prepare atc for writing
    INPUT_STATUS_1_COLOR,

    OB,                             // turn video on.
    ATT_ADDRESS_PORT,
    VIDEO_ENABLE,

    EOD
};

USHORT ModeX200[] = {
    OW,
    SEQ_ADDRESS_PORT,
    0x0604,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    2,
    0xe317,
    0x0014,

    EOD
};

USHORT ModeX240[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    2,
    0x0604,
    0x0100,

    OB,
    MISC_OUTPUT_REG_WRITE_PORT,
    0xe3,

    OW,
    SEQ_ADDRESS_PORT,
    0x0300,

    OB,
    CRTC_ADDRESS_PORT_COLOR,
    0x11,

    METAOUT+MASKOUT,
    CRTC_DATA_PORT_COLOR,
    0x7f, 0x00,

    OWM,
    CRTC_ADDRESS_PORT_COLOR,
    10,
    0x0d06,
    0x3e07,
    0x4109,
    0xea10,
    0xac11,
    0xdf12,
    0x0014,
    0xe715,
    0x0616,
    0xe317,

    OW,
    SEQ_ADDRESS_PORT,
    0x0f02,

    EOD
};

USHORT ModeXDoubleScans[] = {

    OW, CRTC_ADDRESS_PORT_COLOR,    0x4009,

    EOD
};

//
// We will dynamically build a list of supported modes, based on the VESA
// modes the card supports.
//

PVIDEOMODE VgaModeList;

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//


VIDEOMODE ModesVGA[] = {

//
// Mode index 0
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//

{
  VIDEO_MODE_COLOR |
  VIDEO_MODE_BANKED,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of color per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  1,                 // Frequency in Hz
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  NoBanking,         // no banking supported or needed in this mode
#ifdef INT10_MODE_SET
  0x3,
#else
  VGA_TEXT_0,              // pointer to the command strings
#endif
  MEM_VGA, 0x18000, 0x08000, MEM_VGA_SIZE,
  720
},

//
// Mode index 1.
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//

{
  VIDEO_MODE_COLOR | VIDEO_MODE_BANKED, 4, 1, 80, 25, 640, 350, 1, 160, 0x10000, NoBanking,
#ifdef INT10_MODE_SET
  0x3,
#else
  VGA_TEXT_1,              // pointer to the command strings
#endif
  MEM_VGA, 0x18000, 0x08000, MEM_VGA_SIZE,
  640
},

//
//
// Mode index 2
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//

{
    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 4, 1, 80, 30,
    640, 480, 1, 80, 0x10000, NoBanking,
#ifdef INT10_MODE_SET
    0x12,
#else
    VGA_640x480,             // pointer to the command strings
#endif
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  640
},


#ifdef INT10_MODE_SET

//
// 320x200 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 200, 70, 80, 0x10000, NoBanking,
  0x13,
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  320
},

//
// 320x240 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 240, 60, 80, 0x10000, NoBanking,
  0x13,
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  320
},

//
// 320x400 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 400, 70, 80, 0x10000, NoBanking,
  0x13,
  MEM_VGA, 0x0000, MEM_VGA_SIZE,
  320
},

//
// 320x480 256 colors ModeX
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 8, 1, 0, 0,
  320, 480, 60, 80, 0x10000, NoBanking,
  0x13,
  MEM_VGA, 0x0000, MEM_VGA_SIZE,
  320
},

//
// 800x600 16 colors.
//
// NOTE: This must be the last mode in our static mode table.
//

{ VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_BANKED, 4, 1, 100, 37,
  800, 600, 1, 100, 0x10000, NoBanking,
  0x01024F02,
  MEM_VGA, 0x0000, MEM_VGA_SIZE, MEM_VGA_SIZE,
  800
},

#endif

};

ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);

//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};


#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vga\mini\ia64\vgahard.c ===
unsigned char BankSwitchStart;
unsigned char BankSwitchEnd;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\hardware.c ===
/******************************Module*Header*******************************\
* Module Name: hardware.c
*
* Contains all the code that touches the display hardware.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Values for the internal, EGA-compatible palette.

static WORD gPaletteBuffer[] = {

        16, // 16 entries
        0,  // start with first palette register

// On the VGA, the palette contains indices into the array of color DACs.
// Since we can program the DACs as we please, we'll just put all the indices
// down at the beginning of the DAC array (that is, pass pixel values through
// the internal palette unchanged).

        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};


// These are the values for the first 16 DAC registers, the only ones we'll
// work with. These correspond to the RGB colors (6 bits for each primary, with
// the fourth entry unused) for pixel values 0-15.

static BYTE gColorBuffer[] = {

      16, // 16 entries
      0,
      0,
      0,  // start with first palette register
                0x00, 0x00, 0x00, 0x00, // black
                0x2A, 0x00, 0x15, 0x00, // red
                0x00, 0x2A, 0x15, 0x00, // green
                0x2A, 0x2A, 0x15, 0x00, // mustard/brown
                0x00, 0x00, 0x2A, 0x00, // blue
                0x2A, 0x15, 0x2A, 0x00, // magenta
                0x15, 0x2A, 0x2A, 0x00, // cyan
                0x21, 0x22, 0x23, 0x00, // dark gray   2A
                0x30, 0x31, 0x32, 0x00, // light gray  39
                0x3F, 0x00, 0x00, 0x00, // bright red
                0x00, 0x3F, 0x00, 0x00, // bright green
                0x3F, 0x3F, 0x00, 0x00, // bright yellow
                0x00, 0x00, 0x3F, 0x00, // bright blue
                0x3F, 0x00, 0x3F, 0x00, // bright magenta
                0x00, 0x3F, 0x3F, 0x00, // bright cyan
                0x3F, 0x3F, 0x3F, 0x00  // bright white
};

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD   ReturnedDataLength;
    BYTE*   pjBase;

    pjBase = ppdev->pjBase;

    if (bEnable)
    {
        // Set the desired mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(VIDEO_MODE),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        // Set up the internal palette.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_PALETTE_REGISTERS,
                             (PVOID) gPaletteBuffer, // input buffer
                             sizeof(gPaletteBuffer),
                             NULL,    // output buffer
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_PALETTE_REGISTERS"));
            return(FALSE);
        }

        // Set up the DAC.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             (PVOID) gColorBuffer, // input buffer
                             sizeof(gColorBuffer),
                             NULL,    // output buffer
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_COLOR_REGISTERS"));
            return(FALSE);
        }

        // Initialize sequencer to its defaults (all planes enabled, index
        // pointing to Map Mask).

        OUT_WORD(pjBase, VGA_BASE + SEQ_ADDR, (MM_ALL << 8) + SEQ_MAP_MASK);

        // Initialize graphics controller to its defaults (set/reset disabled for
        // all planes, no rotation & ALU function == replace, write mode 0 & read
        // mode 0, color compare ignoring all planes (read mode 1 reads always
        // return 0ffh, handy for ANDing), and the bit mask == 0ffh, gating all
        // bytes from the CPU.

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, GRAF_ENAB_SR);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, (DR_SET << 8) + GRAF_DATA_ROT);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, ((M_PROC_WRITE | M_DATA_READ) << 8)
                                              + GRAF_MODE);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, GRAF_CDC);

        OUT_WORD(pjBase, VGA_BASE + GRAF_ADDR, (0xffL << 8) + GRAF_BIT_MASK);

        DISPDBG((5, "Passed bAssertModeHardware"));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware into the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    VIDEO_MODE_INFORMATION      VideoModeInfo;
    DWORD                       ReturnedDataLength;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange;
    DWORD                       status;

    // Map io ports into virtual memory:

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         &VideoAccessRange,         // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Initialization error mapping IO port base"));
        goto ReturnFalse;
    }

    ppdev->pjBase = (UCHAR*) VideoAccessRange.VirtualAddress;

    // Set the desired mode. (Must come before IOCTL_VIDEO_MAP_VIDEO_MEMORY;
    // that IOCTL returns information for the current mode, so there must be a
    // current mode for which to return information.)

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         &ppdev->ulMode,        // input buffer
                         sizeof(VIDEO_MODE),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Set current mode"));
        goto ReturnFalse;
    }

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    DISPDBG((1, "FrameBufferBase: %lx", VideoMemoryInfo.FrameBufferBase));

    // Record the Frame Buffer Linear Address.

    ppdev->pjScreen = (BYTE*) VideoMemoryInfo.FrameBufferBase;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_CURRENT_MODE,
                         NULL,
                         0,
                         &VideoModeInfo,
                         sizeof(VideoModeInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - failed VIDEO_QUERY_CURRENT_MODE"));
        goto ReturnFalse;
    }

    // Store the width of the screen in bytes

    ppdev->lDelta = VideoModeInfo.ScreenStride;

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory;

    if ((VideoMemory.RequestedVirtualAddress = ppdev->pjScreen) != NULL) {

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                             &VideoMemory,
                             sizeof(VIDEO_MEMORY),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
        }
    }

    if((VideoMemory.RequestedVirtualAddress = ppdev->pjBase) != INVALID_BASE_ADDRESS) 
    {
        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                               &VideoMemory,
                               sizeof(VIDEO_MEMORY),
                               NULL,
                               0,
                               &ReturnedDataLength))
        {
            DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
        }

        ppdev->pjBase = INVALID_BASE_ADDRESS;
    }
}

/******************************Public*Routine******************************\
* VOID vUpdate(ppdev, prcl, pco)
*
* Updates the screen from the DIB surface for the given rectangle.
* Increases the rectangle size if necessary for easy alignment.
*
\**************************************************************************/

#define STRIP_SIZE 32

// This little macro returns the 'PositionInNibble' bit of the
// 'NibbleNumber' nibble of the given 'Dword', and aligns it so that
// it's in the 'PositionInResult' bit of the result.  Numbering is done
// in the order '7 6 5 4 3 2 1 0'.
//
// Given constants for everything but 'Dword', this will amount to an
// AND and a SHIFT.

#define BITPOS(Dword, PositionInNibble, NibbleNumber, PositionInResult) \
(WORD) (((((PositionInNibble) + (NibbleNumber) * 4) > (PositionInResult)) ? \
 (((Dword) & (1 << ((PositionInNibble) + (NibbleNumber) * 4)))          \
  >> ((PositionInNibble) + (NibbleNumber) * 4 - (PositionInResult))) :  \
 (((Dword) & (1 << ((PositionInNibble) + (NibbleNumber) * 4)))          \
  << ((PositionInResult) - (PositionInNibble) - (NibbleNumber) * 4))))

VOID vUpdate(PDEV* ppdev, RECTL* prcl, CLIPOBJ* pco)
{
    BYTE*       pjBase;
    RECTL       rcl;
    SURFOBJ*    pso;
    LONG        cy;
    LONG        cyThis;
    LONG        cw;
    ULONG*      pulSrcStart;
    ULONG*      pulSrc;
    WORD*       pwDstStart;
    WORD*       pwDst;
    LONG        i;
    LONG        j;
    ULONG       ul;
    WORD        w;
    LONG        lSrcDelta;
    LONG        lDstDelta;
    LONG        lSrcSkip;
    LONG        lDstSkip;

    pjBase = ppdev->pjBase;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // We have to clip to the screen dimensions because we may have
        // been a bit loose when we guessed the bounds of the drawing:

        rcl.left   = max(0,               prcl->left);
        rcl.top    = max(0,               prcl->top);
        rcl.right  = min(ppdev->cxScreen, prcl->right);
        rcl.bottom = min(ppdev->cyScreen, prcl->bottom);
    }
    else
    {
        // We may as well save ourselves some blting by clipping to
        // the clip object's maximum extent.  The clip object's bounds
        // are guaranteed to be contained within the dimensions of the
        // screen:

        rcl.left   = max(pco->rclBounds.left,   prcl->left);
        rcl.top    = max(pco->rclBounds.top,    prcl->top);
        rcl.right  = min(pco->rclBounds.right,  prcl->right);
        rcl.bottom = min(pco->rclBounds.bottom, prcl->bottom);
    }

    // Be paranoid:

    if ((rcl.left >= rcl.right) || (rcl.top >= rcl.bottom))
        return;

    // Align to words so that we don't have to do any read-modify-write
    // operations.

    rcl.left  = (rcl.left) & ~15;
    rcl.right = (rcl.right + 15) & ~15;

    pso = ppdev->pso;
    lSrcDelta = pso->lDelta;
    pulSrcStart = (ULONG*) ((BYTE*) pso->pvScan0 + (rcl.top * lSrcDelta)
                                                 + (rcl.left >> 1));

    lDstDelta = ppdev->lDelta;
    pwDstStart = (WORD*) (ppdev->pjScreen + (rcl.top * lDstDelta)
                                          + (rcl.left >> 3));

    cy = (rcl.bottom - rcl.top);
    cw = (rcl.right - rcl.left) >> 4;

    lSrcSkip = lSrcDelta - (8 * cw);
    lDstSkip = lDstDelta - (2 * cw);

    do {
        cyThis = STRIP_SIZE;
        cy -= STRIP_SIZE;
        if (cy < 0)
            cyThis += cy;

        // Map in plane 0:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C0);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 0, 6, 0) |
                    BITPOS(ul, 0, 7, 1) |
                    BITPOS(ul, 0, 4, 2) |
                    BITPOS(ul, 0, 5, 3) |
                    BITPOS(ul, 0, 2, 4) |
                    BITPOS(ul, 0, 3, 5) |
                    BITPOS(ul, 0, 0, 6) |
                    BITPOS(ul, 0, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 0, 6, 8)  |
                     BITPOS(ul, 0, 7, 9)  |
                     BITPOS(ul, 0, 4, 10) |
                     BITPOS(ul, 0, 5, 11) |
                     BITPOS(ul, 0, 2, 12) |
                     BITPOS(ul, 0, 3, 13) |
                     BITPOS(ul, 0, 0, 14) |
                     BITPOS(ul, 0, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Map in plane 1:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C1);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 1, 6, 0) |
                    BITPOS(ul, 1, 7, 1) |
                    BITPOS(ul, 1, 4, 2) |
                    BITPOS(ul, 1, 5, 3) |
                    BITPOS(ul, 1, 2, 4) |
                    BITPOS(ul, 1, 3, 5) |
                    BITPOS(ul, 1, 0, 6) |
                    BITPOS(ul, 1, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 1, 6, 8)  |
                     BITPOS(ul, 1, 7, 9)  |
                     BITPOS(ul, 1, 4, 10) |
                     BITPOS(ul, 1, 5, 11) |
                     BITPOS(ul, 1, 2, 12) |
                     BITPOS(ul, 1, 3, 13) |
                     BITPOS(ul, 1, 0, 14) |
                     BITPOS(ul, 1, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Map in plane 2:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C2);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 2, 6, 0) |
                    BITPOS(ul, 2, 7, 1) |
                    BITPOS(ul, 2, 4, 2) |
                    BITPOS(ul, 2, 5, 3) |
                    BITPOS(ul, 2, 2, 4) |
                    BITPOS(ul, 2, 3, 5) |
                    BITPOS(ul, 2, 0, 6) |
                    BITPOS(ul, 2, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 2, 6, 8)  |
                     BITPOS(ul, 2, 7, 9)  |
                     BITPOS(ul, 2, 4, 10) |
                     BITPOS(ul, 2, 5, 11) |
                     BITPOS(ul, 2, 2, 12) |
                     BITPOS(ul, 2, 3, 13) |
                     BITPOS(ul, 2, 0, 14) |
                     BITPOS(ul, 2, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Map in plane 3:

        OUT_BYTE(pjBase, VGA_BASE + SEQ_DATA, MM_C3);

        pwDst = pwDstStart;
        pulSrc = pulSrcStart;

        for (j = cyThis; j != 0; j--)
        {
            for (i = cw; i != 0; i--)
            {
                ul = *(pulSrc);

                w = BITPOS(ul, 3, 6, 0) |
                    BITPOS(ul, 3, 7, 1) |
                    BITPOS(ul, 3, 4, 2) |
                    BITPOS(ul, 3, 5, 3) |
                    BITPOS(ul, 3, 2, 4) |
                    BITPOS(ul, 3, 3, 5) |
                    BITPOS(ul, 3, 0, 6) |
                    BITPOS(ul, 3, 1, 7);

                ul = *(pulSrc + 1);

                w |= BITPOS(ul, 3, 6, 8)  |
                     BITPOS(ul, 3, 7, 9)  |
                     BITPOS(ul, 3, 4, 10) |
                     BITPOS(ul, 3, 5, 11) |
                     BITPOS(ul, 3, 2, 12) |
                     BITPOS(ul, 3, 3, 13) |
                     BITPOS(ul, 3, 0, 14) |
                     BITPOS(ul, 3, 1, 15);

                WRITE_WORD(pwDst, w);

                pwDst  += 1;
                pulSrc += 2;
            }

            pwDst  = (WORD*)  ((BYTE*) pwDst  + lDstSkip);
            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);
        }

        // Get ready for next strip:

        pulSrcStart = (ULONG*) ((BYTE*) pulSrcStart + (cyThis * lSrcDelta));
        pwDstStart  = (WORD*)  ((BYTE*) pwDstStart  + (cyThis * lDstDelta));

    } while (cy > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//  Miscellaneous Registers used only at EGA/VGA initialization time

#define MISC_OUTPUT         0x0C2       // Miscellaneous Output Register
#define CRTC_ADDR           0x0D4       // CRTC Address Register for color mode
#define CRTC_DATA           0x0D5       // CRTC Data    Register for color mode
#define GRAF_1_POS          0x0CC       // Graphics 1 Address Register
#define GRAF_2_POS          0x0CA       // Graphics 2 Address Register
#define ATTR_READ           0x0DA       // Attribute Controler Read  Address
#define ATTR_WRITE          0x0C0       // Attribute Controler Write Address
#define IN_STAT_0           0x0C2       // Input Status Register 0
#define IN_STAT_1           0x0DA       // Input Status Register 1

//  EGA/VGA Register Definitions.
//
//  The following definitions are the EGA/VGA registers and values
//  used by this driver.  All other registers are set up at
//  when the EGA/VGA is placed into graphics mode and never altered
//  afterwards.
//
//  All unspecified bits in the following registers must be 0.

#define EGA_BASE            0x300       // Base address of the EGA (3xx)
#define VGA_BASE            0x300       // Base address of the VGA (3xx)

//  SEQUencer Registers Used

#define SEQ_ADDR            0xC4        // SEQUencer Address Register
#define SEQ_DATA            0xC5        // SEQUencer Data    Register

#define SEQ_MAP_MASK        0x02        // Write Plane Enable Mask
#define MM_C0               0x01        // C0 plane enable
#define MM_C1               0x02        // C1 plane enable
#define MM_C2               0x04        // C2 plane enable
#define MM_C3               0x08        // C3 plane enable
#define MM_ALL              0x0f        // All planes

#define SEQ_MODE            0x04        // Memory Mode
#define SM_ALPHA            0x01        // Char map select enable
#define SM_EXTENDED         0x02        // Extended memory present
#define SM_ODD_PLANE        0x04        // Odd/even bytes to same plane

//  Graphics Controller Registers Used

#define GRAF_ADDR           0xCE        // Graphics Controller Address Register
#define GRAF_DATA           0xCF        // Graphics Controller Data    Register

#define GRAF_SET_RESET      0x00        // Set/Reset Plane Color
#define GRAF_ENAB_SR        0x01        // Set/Reset Enable
#define GRAF_COL_COMP       0x02        // Color Compare Register

#define GRAF_DATA_ROT       0x03        // Data Rotate Register
#define DR_ROT_CNT          0x07        //   Data Rotate Count
#define DR_SET              0x00        //   Data Unmodified
#define DR_AND              0x08        //   Data ANDed with latches
#define DR_OR               0x10        //   Data ORed  with latches
#define DR_XOR              0x18        //   Data XORed with latches

#define GRAF_READ_MAP       0x04        // Read Map Select Register
#define RM_C0               0x00        //   Read C0 plane
#define RM_C1               0x01        //   Read C1 plane
#define RM_C2               0x02        //   Read C2 plane
#define RM_C3               0x03        //   Read C3 plane

#define GRAF_MODE           0x05        // Mode Register
#define M_PROC_WRITE        0x00        //   Write processor data rotated
#define M_LATCH_WRITE       0x01        //   Write latched data
#define M_COLOR_WRITE       0x02        //   Write processor data as color
#define M_AND_WRITE         0x03        //   Write (procdata AND bitmask)
#define M_DATA_READ         0x00        //   Read selected plane
#define M_COLOR_READ        0x08        //   Read color compare

#define GRAF_MISC           0x06        // Miscellaneous Register
#define MS_NON_ALPHA        0x01        //   Char generator disabled
#define MS_ODD_EVEN         0x02        //   Map odd addresses to even
#define MS_A0000_128K       0x00        //   Memory present at A0000, 128kb
#define MS_A0000_64K        0x04        //   Memory present at A0000, 64kb
#define MS_B0000_32K        0x08        //   Memory present at B0000, 32kb
#define MS_B8000_32K        0x0C        //   Memory present at B8000, 32kb
#define MS_ADDR_MASK        0x0C

#define GRAF_CDC            0x07        // Color Don't Care Register
#define GRAF_BIT_MASK       0x08        // Bit Mask Register

// pdev->pjBase is set to this value before it is actually initialized

#define INVALID_BASE_ADDRESS (UCHAR *)( -1 )

////////////////////////////////////////////////////////////////////////
// Direct access macros
//

#define OUT_WORD(pjBase, addr, w)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_USHORT((BYTE*) (pjBase) + (addr), (USHORT) (w)); \
}

#define OUT_BYTE(pjBase, addr, j)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j)); \
}

#define WRITE_WORD(pwAddr, w)                               \
    WRITE_REGISTER_USHORT((USHORT*) (pwAddr), (USHORT) (w))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration
//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"vga"          // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "Vga risc: "    // All debug output is prefixed
                                                //   by this string
#define ALLOC_TAG               'rgvD'          // Dvgr
                                                // Four byte tag (characters in
                                                // reverse order) used for
                                                // memory allocations

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

// Describes a single color tetrahedron vertex for dithering

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    ULONG       iBitmapFormat;          // BMF_4BPP (our current colour depth)
    BYTE*       pjScreen;               // Points to base screen address
    LONG        lDelta;                 // Screen stride
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    FLONG       flHooks;                // What we're hooking from GDI
    UCHAR*      pjBase;                 // Mapped IO port base for this PDEV

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    ULONG       ulMode;                 // Mode the mini-port driver is in.

    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    SURFOBJ*    pso;                    // DIB copy of our surface to which we
                                        //   have GDI draw everything

} PDEV, *PPDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

VOID vUpdate(PDEV*, RECTL*, CLIPOBJ*);
BOOL bAssertModeHardware(PDEV*, BOOL);
BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include "driver.h"
#include "debug.h"
#include "hw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0x07070707,
    0x08080808,
    0x09090909,
    0x0A0A0A0A,
    0x0B0B0B0B,
    0x0C0C0C0C,
    0x0D0D0D0D,
    0x0E0E0E0E,
    0x0F0F0F0F
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity. This is organized in the following form, for
// efficiency: every set of 8 pixels (0-7, 8-15, 16-23, ... ,56-63) is
// placed in the dither pattern in the order: 0 2 4 6 1 3 5 7. This is
// done so that two longs can be combined to put 8 pixels in DIB4 format
// at once (the first dword is shifted left 4, then the two dwords are
// ORed, to produce 0 1 2 3 4 5 6 7 order in memory), which is much faster than
// combining the output of the straight dither ordering.
// The effective dither ordering after we combine each pair of ULONGS at the
// end (the desired dither ordering) is:
//
//  0, 36,  4, 32, 18, 54, 22, 50,
//  2, 38,  6, 34, 16, 52, 20, 48,
//  9, 45, 13, 41, 27, 63, 31, 59,
// 11, 47, 15, 43, 25, 61, 29, 57,
//  1, 37,  5, 33, 19, 55, 23, 51,
//  3, 39,  7, 35, 17, 53, 21, 49,
//  8, 44, 12, 40, 26, 62, 30, 58,
// 10, 46, 14, 42, 24, 60, 28, 56,
//
ULONG aulDitherOrder[] = {
  0, 34,  2, 32, 17, 51, 19, 49,
  1, 35,  3, 33, 16, 50, 18, 48,
 12, 46, 14, 44, 29, 63, 31, 61,
 13, 47, 15, 45, 28, 62, 30, 60,
  4, 38,  6, 36, 21, 55, 23, 53,
  5, 39,  7, 37, 20, 54, 22, 52,
  8, 42, 10, 40, 25, 59, 27, 57,
  9, 43, 11, 41, 24, 58, 26, 56,
};

/******************************Public*Routine******************************\
* ComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA * ComputeSubspaces(ULONG rgb, VERTEX_DATA *pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(ULONG * pulDest, VERTEX_DATA * vVertexData,
    VERTEX_DATA * pvVertexDataEnd, ULONG ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulTemp, *pulDitherOrder;
    BYTE    jColor;
    BYTE    ajDither[64];

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) pvVertexData->ulVertex;
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        ajDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        ajDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        ajDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        ajDither[*pulDitherOrder] = jColor;
                        ajDither[*(pulDitherOrder+1)] = jColor;
                        ajDither[*(pulDitherOrder+2)] = jColor;
                        ajDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) vVertexData[1].ulVertex;
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) vVertexData[0].ulVertex;
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        pulTemp = (ULONG *)ajDither;
        *pulTemp = ulColor;
        *(pulTemp+1) = ulColor;
        *(pulTemp+2) = ulColor;
        *(pulTemp+3) = ulColor;
        *(pulTemp+4) = ulColor;
        *(pulTemp+5) = ulColor;
        *(pulTemp+6) = ulColor;
        *(pulTemp+7) = ulColor;
        *(pulTemp+8) = ulColor;
        *(pulTemp+9) = ulColor;
        *(pulTemp+10) = ulColor;
        *(pulTemp+11) = ulColor;
        *(pulTemp+12) = ulColor;
        *(pulTemp+13) = ulColor;
        *(pulTemp+14) = ulColor;
        *(pulTemp+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                ajDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                ajDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                ajDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                ajDither[*pulDitherOrder] = jColor;
                ajDither[*(pulDitherOrder+1)] = jColor;
                ajDither[*(pulDitherOrder+2)] = jColor;
                ajDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        ulColor |= ulColor << 4;
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;

        return;
    }

    // Now convert the 64 bytes into the 4BPP Engine Format Bitmap
    pulTemp = (ULONG *)ajDither;

    *pulDest = (*pulTemp << 4) | *(pulTemp + 1);
    *(pulDest + 1) = (*(pulTemp + 2) << 4) | *(pulTemp + 3);
    *(pulDest + 2) = (*(pulTemp + 4) << 4) | *(pulTemp + 5);
    *(pulDest + 3) = (*(pulTemp + 6) << 4) | *(pulTemp + 7);
    *(pulDest + 4) = (*(pulTemp + 8) << 4) | *(pulTemp + 9);
    *(pulDest + 5) = (*(pulTemp + 10) << 4) | *(pulTemp + 11);
    *(pulDest + 6) = (*(pulTemp + 12) << 4) | *(pulTemp + 13);
    *(pulDest + 7) = (*(pulTemp + 14) << 4) | *(pulTemp + 15);
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = ComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\videosim\videodat.c ===
/*++

Copyright (c) 1992-1994  Microsoft Corporation

Module Name:

    videosim.c

Abstract:

    mode table for the simulation driver.

Environment:

    Kernel mode

Revision History:

--*/

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntosp.h"
#include "stdarg.h"
#include "stdio.h"

#include "ntddvdeo.h"
#include "video.h"
#include "videosim.h"


#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif


ULONG bLoaded = 0;

//
// sim mode information Tables.
//

VIDEO_MODE_INFORMATION SimModes[] = {
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      2000,
      1600,
      4000,
      1,
      16,
      0,
      320,
      240,
      8,
      8,
      8,
      0x00007c00,
      0x000003e0,
      0x0000001f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1280,
      1024,
      2560,
      1,
      16,
      72,
      320,
      240,
      8,
      8,
      8,
      0x0000fc00,
      0x000003f0,
      0x0000000f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1280,
      1024,
      1280,
      1,
      8,
      60,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1152,
      900,
      2304,
      1,
      16,
      66,
      320,
      240,
      8,
      8,
      8,
      0x0000fc00,
      0x000003f0,
      0x0000000f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      1152,
      900,
      1152,
      1,
      8,
      66,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      800,
      600,
      1600,
      1,
      16,
      72,
      320,
      240,
      8,
      8,
      8,
      0x0000fc00,
      0x000003f0,
      0x0000000f,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      800,
      600,
      800,
      1,
      8,
      72,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      640,
      480,
      2560,
      1,
      32,
      0,
      320,
      240,
      8,
      8,
      8,
      0x00ff0000,
      0x0000ff00,
      0x000000ff,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      640,
      480,
      640,
      1,
      8,
      45,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
},
{
      sizeof(VIDEO_MODE_INFORMATION),
      0,
      100,
      100,
      100,
      1,
      8,
      45,
      320,
      240,
      8,
      8,
      8,
      0x00000000,
      0x00000000,
      0x00000000,
      VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE
}
};

ULONG SimNumModes = sizeof(SimModes) / sizeof(VIDEO_MODE_INFORMATION);

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\draw.c ===
/******************************Module*Header*******************************\
* Module Name: draw.c
*
* The drawing guts of a portable 16-colour VGA driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended if you want
*               to get decent performance.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* DrvStrokePath
*
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL        b;
    PDEV*       ppdev;
    RECTFX      rcfxBounds;
    RECTL       rclBounds;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngStrokePath(ppdev->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    vUpdate(ppdev, &rclBounds, pco);

    return(b);
}

/******************************Public*Routine******************************\
* DrvBitBlt
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL        bUpdate;
    BOOL        b;
    PDEV*       ppdev;

    bUpdate = FALSE;
    if (psoDst->iType == STYPE_DEVICE)
    {
        bUpdate = TRUE;
        ppdev   = (PDEV*) psoDst->dhpdev;
        psoDst  = ppdev->pso;
    }
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ppdev   = (PDEV*) psoSrc->dhpdev;
        psoSrc  = ppdev->pso;
    }

    b = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc,
                  pptlMask, pbo, pptlBrush, rop4);

    if (bUpdate)
    {
        vUpdate(ppdev, prclDst, pco);
    }

    return(b);
}

/******************************Public*Routine******************************\
* DrvCopyBits
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL        bUpdate;
    BOOL        b;
    PDEV*       ppdev;

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc,
                     NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL        b;
    PDEV*       ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngTextOut(ppdev->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                   pboFore, pboOpaque, pptlOrg, mix);

    vUpdate(ppdev, (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround, pco);

    return(b);
}

/******************************Public*Routine******************************\
* DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    BOOL        b;
    PDEV*       ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngPaint(ppdev->pso, pco, pbo, pptlBrush, mix);

    vUpdate(ppdev, &pco->rclBounds, pco);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\vgarisc\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* The initialization guts of the portable 16-colour VGA driver.
*
* The drawing guts of a portable 16-colour VGA driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended for decent
*               driver performance.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

static DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits               },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint                  },
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

GDIINFO ggdiDefault = {
     GDI_DRIVER_VERSION,
     DT_RASDISPLAY,         // ulTechnology
     0,                     // ulHorzSize
     0,                     // ulVertSize
     0,                     // ulHorzRes (filled in at initialization)
     0,                     // ulVertRes (filled in at initialization)
     4,                     // cBitsPixel
     1,                     // cPlanes
     16,                    // ulNumColors
     0,                     // flRaster (DDI reserved field)

     0,                     // ulLogPixelsX (filled in at initialization)
     0,                     // ulLogPixelsY (filled in at initialization)

     TC_RA_ABLE,            // flTextCaps

     6,                     // ulDACRed
     6,                     // ulDACGree
     6,                     // ulDACBlue

     0x0024,                // ulAspectX  (one-to-one aspect ratio)
     0x0024,                // ulAspectY
     0x0033,                // ulAspectXY

     1,                     // xStyleStep
     1,                     // yStyleSte;
     3,                     // denStyleStep

     { 0, 0 },              // ptlPhysOffset
     { 0, 0 },              // szlPhysSize

     0,                     // ulNumPalReg (win3.1 16 color drivers say 0 too)

// These fields are for halftone initialization.

     {                                          // ciDevice, ColorInfo
        { 6700, 3300, 0 },                      // Red
        { 2100, 7100, 0 },                      // Green
        { 1400,  800, 0 },                      // Blue
        { 1750, 3950, 0 },                      // Cyan
        { 4050, 2050, 0 },                      // Magenta
        { 4400, 5200, 0 },                      // Yellow
        { 3127, 3290, 0 },                      // AlignmentWhite
        20000,                                  // RedGamma
        20000,                                  // GreenGamma
        20000,                                  // BlueGamma
        0, 0, 0, 0, 0, 0
     },

     0,                      // ulDevicePelsDPI  (filled in at initialization)
     PRIMARY_ORDER_CBA,                         // ulPrimaryOrder
     HT_PATSIZE_4x4_M,                          // ulHTPatternSize
     HT_FORMAT_4BPP_IRGB,                       // ulHTOutputFormat
     HT_FLAG_ADDITIVE_PRIMS,                    // flHTFlags

     0,                                         // ulVRefresh
     1,                      // ulBltAlignment (preferred window alignment
                             //   for fast-text routines)
     0,                                         // ulPanningHorzRes
     0,                                         // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 4bpp non-palette device.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,  L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault =
{
    (GCAPS_MONO_DITHER | GCAPS_COLOR_DITHER),
                    // Graphics capabilities

    SYSTM_LOGFONT,  // Default font description
    HELVE_LOGFONT,  // ANSI variable font description
    COURI_LOGFONT,  // ANSI fixed font description
    0,              // Count of device fonts
    BMF_4BPP,       // preferred DIB format
    8,              // Width of color dither
    8,              // Height of color dither
    0               // Default palette to use for this device
};

/******************************Public*Data*Struct*************************\
* VGALOGPALETTE logPalVGA
*
* This is the palette for the VGA.
*
\**************************************************************************/

typedef struct _VGALOGPALETTE
{
    USHORT          ident;
    USHORT          NumEntries;
    PALETTEENTRY    palPalEntry[16];
} VGALOGPALETTE;

const VGALOGPALETTE logPalVGA =
{
    0x400,  // Driver version
    16,     // Number of entries
    {
        { 0,   0,   0,   0 },       // 0
        { 0x80,0,   0,   0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0x80,0x80,0,   0 },       // 3
        { 0,   0,   0x80,0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0x80,0x80,0 },       // 6
        { 0x80,0x80,0x80,0 },       // 7

        { 0xC0,0xC0,0xC0,0 },       // 8
        { 0xFF,0,   0,   0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0xFF,0xFF,0,   0 },       // 11
        { 0,   0,   0xFF,0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0,   0xFF,0xFF,0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD status;

    //
    // Get the number of modes supported by the mini-port
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem"));
        return(0);
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not 4 planes, or not graphics, or is not
    // one of 1 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 4 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            (pVideoTemp->BitsPerPlane != 1) ||
            (pVideoTemp->VisScreenWidth > 800))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);

}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->iBitmapFormat    = BMF_4BPP;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_PAINT);

    ppdev->pjBase = INVALID_BASE_ADDRESS;

    // Fill in the GDIINFO data structure with the default 4bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 4bpp values:

    *pdi = gdevinfoDefault;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    HPALETTE    hpal;

    hpal = EngCreatePalette(PAL_INDEXED, 16, (ULONG*) (logPalVGA.palPalEntry),
                            0, 0, 0);

    if (hpal == 0)
        goto ReturnFalse;

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurfShadow;
    HSURF   hsurfDevice;
    SIZEL   sizl;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // Have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfDevice = EngCreateDeviceSurface(NULL, sizl, ppdev->iBitmapFormat);
    if (hsurfDevice == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateSurface"));
        return(0);
    }

    ppdev->hsurfScreen = hsurfDevice;       // Remember it for clean-up

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurfDevice, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create the 4bpp DIB on which we'll have GDI do all the drawing.
    // We'll merely occasionally blt portions to the screen to update.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfShadow = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat, 0,
                                          NULL);
    if (hsurfShadow == 0)
        goto ReturnFailure;

    if (!EngAssociateSurface(hsurfShadow, ppdev->hdevEng, 0))
    {
        DISPDBG((0, "DrvEnableSurface - Failed second EngAssociateSurface"));
        goto ReturnFailure;
    }

    ppdev->pso = EngLockSurface(hsurfShadow);
    if (ppdev->pso == NULL)
        goto ReturnFailure;

    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurfDevice);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableHardware(ppdev);

    if (ppdev->pso) {
        hsurf = ppdev->pso->hsurf;

        EngUnlockSurface(ppdev->pso);
        EngDeleteSurface(hsurf);
    }

    EngDeleteSurface(ppdev->hsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        return(bAssertModeHardware(ppdev, FALSE));
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        return(bAssertModeHardware(ppdev, TRUE));
    }
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Contains all the banking code for the display driver.
*
* It's helpful not to have to implement all the DDI drawing functionality
* in a driver (who wants to write the code to support true ROP4's with
* arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
* drawing we don't want to do.  And if GDI can write directly on the frame
* buffer bits, performance won't even be toooo bad.
*
* NT's GDI can draw on any standard format frame buffer.  When the entire
* frame buffer can be mapped into main memory, it's very simple to set up:
* the display driver tells GDI the frame buffer format and location, and
* GDI can then just draw directly.
*
* When only one bank of the frame buffer can be mapped into main memory
* at one time (e.g., there is a moveable 64k aperture) things are not
* nearly so easy.  For every bank spanned by a drawing operation, we have
* to set the hardware to the bank, and call back to GDI.  We tell GDI
* to draw only on the mapped-in bank by mucking with the drawing call's
* CLIPOBJ.
*
* This module contains the code for doing all banking support.
*
* This code supports 8, 16 and 32bpp colour depths, arbitrary bank
* sizes, and handles 'broken rasters' (which happens when the bank size
* is not a multiple of the scan length; some scans will end up being
* split over two separate banks).
*
* Note:  If you mess with this code and break it, you can expect to get
*        random access violations on call-backs in internal GDI routines
*        that are very hard to debug.
*
* Copyright (c) 1993-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

typedef struct _BANKDATA {
    ULONG nothing_yet;
} BANKDATA;                      /* bd, pbd */

////////////////////////////////////////////////////////////////////////////
// W32(i/p) Banking
//

VOID vBankSelectMode(
PPDEV       ppdev,
BANK_MODE   bankm)
{
    // BANK_ENABLE   - We've exited full-screen; re-enable banking
    // BANK_ON       - We're about to use the memory aperture
    // BANK_OFF      - We've finished using the memory aperture
    // BANK_DISABLE  - We're about to enter full-screen; shut down banking

    BYTE* pjBase = ppdev->pjBase;

    switch(bankm){

        case BANK_ENABLE:   DISPDBG((115,"vBankSelectMode(BANK_ENABLE)"));
                            break;

        case BANK_ON:       DISPDBG((115,"vBankSelectMode(BANK_ON)"));
                            WAIT_FOR_IDLE_ACL(ppdev, pjBase);
                            break;

        case BANK_OFF:      DISPDBG((115,"vBankSelectMode(BANK_OFF)"));
                            break;

        case BANK_DISABLE:  DISPDBG((115,"vBankSelectMode(BANK_DISABLE)"));
                            break;

        default:            DISPDBG((115,"vBankSelectMode(UNKNOWN=%d)", bankm));
                            RIP("Bad BANK_MODE selected");
                            break;
    }
}

VOID vBankMap(
PPDEV       ppdev,
LONG        iBank)
{
    #define SEG_READ_SHIFT_LO   4
    #define SEG_READ_SHIFT_HI   0
    #define SEG_WRITE_SHIFT_LO  0
    #define SEG_WRITE_SHIFT_HI  4

    #define SEG_READ_MASK_LO    0x0F
    #define SEG_READ_MASK_HI    0x30
    #define SEG_WRITE_MASK_LO   0x0F
    #define SEG_WRITE_MASK_HI   0x30

    BYTE jSegLo, jSegHi;

    //
    // map the read and write segements to iBank
    //

    DISPDBG((10,"vBankMap(iBank=%d)", iBank));

    jSegLo = (BYTE)(((iBank & SEG_READ_MASK_LO) << SEG_READ_SHIFT_LO) |
                    ((iBank & SEG_WRITE_MASK_LO) << SEG_WRITE_SHIFT_LO));

    jSegHi = (BYTE)(((iBank & SEG_READ_MASK_HI) >> SEG_READ_SHIFT_HI) |
                    ((iBank & SEG_WRITE_MASK_HI) >> SEG_WRITE_SHIFT_HI));

    DISPDBG((10,"vBankMap: Segment Selector %02x %02x)", jSegHi, jSegLo));

    CP_OUT_BYTE(ppdev->pjPorts,SEG_SELECT_HI,jSegHi);
    CP_OUT_BYTE(ppdev->pjPorts,SEG_SELECT_LO,jSegLo);
}

VOID vBankInitialize(
PPDEV       ppdev,
BOOL        bMmIo)
{
    // BANKDATA   *pbd = ppdev->pvBankData;
}

/******************************Public*Routine******************************\
* BOOL bEnableBanking
*
\**************************************************************************/

BOOL bEnableBanking(
PDEV*   ppdev)
{
    CLIPOBJ*            pcoBank;
    SURFOBJ*            psoBank;
    SIZEL               sizl;
    HSURF               hsurf;
    FNBANKINITIALIZE*   pfnBankInitialize;
    LONG                lDelta;
    LONG                cjBank;
    LONG                cPower2;

    // This routine may be called multiple times (e.g., each time
    // full-screen is exited), so make sure we do any allocations
    // only once:

    if (ppdev->pcoBank == NULL)
    {
        // Create a temporary clip object that we'll use for the bank
        // when we're given a Null or DC_TRIVIAL clip object:

        pcoBank = EngCreateClip();
        if (pcoBank == NULL)
            goto ReturnFalse;

        // We break every per-bank GDI call-back into simple rectangles:

        pcoBank->iDComplexity = DC_RECT;
        pcoBank->fjOptions    = OC_BANK_CLIP;

        // Create a GDI surface that we'll wrap around our bank in
        // call-backs:

        sizl.cx = ppdev->cxMemory;
        sizl.cy = ppdev->cyMemory;

        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        ppdev->lDelta,
                                        ppdev->iBitmapFormat,
                                        BMF_TOPDOWN,
                                        ppdev->pjScreen);

        // Note that we hook zero calls -- after all, the entire point
        // of all this is to have GDI do all the drawing on the bank.
        // Once we're done the association, we can leave the surface
        // permanently locked:

        if ((hsurf == 0)                                        ||
            (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))    ||
            (!(psoBank = EngLockSurface(hsurf))))
        {
            DISPDBG((0, "Failed wrapper surface creation"));

            EngDeleteSurface(hsurf);
            EngDeleteClip(pcoBank);

            goto ReturnFalse;
        }

        ppdev->pcoBank    = pcoBank;
        ppdev->psoBank    = psoBank;
        ppdev->pvBankData = &ppdev->aulBankData[0];

        ppdev->pfnBankMap        = vBankMap;
        ppdev->pfnBankSelectMode = vBankSelectMode;
        pfnBankInitialize        = vBankInitialize;

        lDelta = ppdev->lDelta;
        cjBank = ppdev->cjBank;

        ASSERTDD(lDelta > 0, "Bad things happen with negative lDeltas");
        ASSERTDD(cjBank > lDelta, "Worse things happen with bad bank sizes");

        if (((lDelta & (lDelta - 1)) != 0) || ((cjBank & (cjBank - 1)) != 0))
        {
            // When either the screen stride or the bank size is not a power
            // of two, we have to use the slower 'bBankComputeNonPower2'
            // function for bank calculations, 'cause there can be broken
            // rasters and stuff:

            ppdev->pfnBankCompute = bBankComputeNonPower2;
        }
        else
        {
            // We can use the super duper fast bank calculator.  Yippie,
            // yahoo!  (I am easily amused.)

            cPower2 = 0;
            while (cjBank != lDelta)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // We've just calculated that cjBank / lDelta = 2 ^ cPower2:

            ppdev->cPower2ScansPerBank = cPower2;

            while (cjBank != 1)
            {
                cjBank >>= 1;
                cPower2++;
            }

            // Continuing on, we've calculated that cjBank = 2 ^ cPower2:

            ppdev->cPower2BankSizeInBytes = cPower2;

            ppdev->pfnBankCompute = bBankComputePower2;
        }
    }

    // Warm up the hardware:

    pfnBankInitialize(ppdev,
                      ppdev->flCaps & (CAPS_MM_TRANSFER | CAPS_MM_IO));
    ppdev->pfnBankSelectMode(ppdev, BANK_ENABLE);

    DISPDBG((5, "Passed bEnableBanking"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableBanking!"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableBanking
*
\**************************************************************************/

VOID vDisableBanking(PDEV* ppdev)
{
    HSURF hsurf;

    if (ppdev->psoBank != NULL)
    {
        hsurf = ppdev->psoBank->hsurf;
        EngUnlockSurface(ppdev->psoBank);
        EngDeleteSurface(hsurf);
    }

    if (ppdev->pcoBank != NULL)
        EngDeleteClip(ppdev->pcoBank);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBanking
*
\**************************************************************************/

VOID vAssertModeBanking(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Inform the miniport bank code about the change in state:

    ppdev->pfnBankSelectMode(ppdev,
                             bEnable ? BANK_ENABLE : BANK_DISABLE);
}

/******************************Public*Routine******************************\
* BOOL bBankComputeNonPower2
*
* Given the bounds of the drawing operation described by 'prclDraw',
* computes the bank number and rectangle bounds for the first engine
* call back.
*
* Returns the bank number, 'prclBank' is the bounds for the first
* call-back, and 'pcjOffset' is the adjustment for 'pvScan0'.
*
* This routine does a couple of divides for the bank calculation.  We
* don't use a look-up table for banks because it's not straight forward
* to use with broken rasters, and with large amounts of video memory
* and small banks, the tables could get large.  We'd probably use it
* infrequently enough that the memory manager would be swapping it
* in and out whenever we touched it.
*
* Returns TRUE if prclDraw is entirely contained in one bank; FALSE if
* prclDraw spans multiple banks.
*
\**************************************************************************/

BOOL bBankComputeNonPower2( // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG cjBufferOffset;
    LONG iBank;
    LONG cjBank;
    LONG cjBankOffset;
    LONG cjBankRemainder;
    LONG cjScan;
    LONG cScansInBank;
    LONG cjScanRemainder;
    LONG lDelta;
    BOOL bOneBank;

    bOneBank = FALSE;
    lDelta   = ppdev->lDelta;

    cjBufferOffset  = prclDraw->top * lDelta
                    + (prclDraw->left << ppdev->cPelSize);

    cjBank          = ppdev->cjBank;

    // iBank        = cjBufferOffset / cjBank;
    // cjBankOffset = cjBufferOffset % cjBank;

    QUOTIENT_REMAINDER(cjBufferOffset, cjBank, iBank, cjBankOffset);

    *piBank         = iBank;
    *pcjOffset      = iBank * cjBank;
    cjBankRemainder = cjBank - cjBankOffset;
    cjScan          = (prclDraw->right - prclDraw->left) << ppdev->cPelSize;

    if (cjBankRemainder < cjScan)
    {
        // Oh no, we've got a broken raster!

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->left +
                           (cjBankRemainder >> ppdev->cPelSize);
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + 1;
    }
    else
    {
        // cScansInBank    = cjBankRemainder / lDelta;
        // cjScanRemainder = cjBankRemainder % lDelta;

        ASSERTDD(lDelta > 0, "We assume positive lDelta here");

        QUOTIENT_REMAINDER(cjBankRemainder, lDelta,
                           cScansInBank, cjScanRemainder);

        if (cjScanRemainder >= cjScan)
        {
            // The bottom scan of the bank may be broken, but it breaks after
            // any drawing we'll be doing on that scan.  So we can simply
            // add the scan to this bank:

            cScansInBank++;
        }

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->right;
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + cScansInBank;

        if (prclBank->bottom >= prclDraw->bottom)
        {
            prclBank->bottom  = prclDraw->bottom;
            bOneBank          = TRUE;
        }
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* BOOL bBankComputePower2
*
* Functions the same as 'bBankComputeNonPower2', except that it is
* an accelerated special case for when both the screen stride and bank
* size are powers of 2.
*
\**************************************************************************/

BOOL bBankComputePower2(    // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG iBank;
    LONG yTopNextBank;
    BOOL bOneBank;

    iBank        = prclDraw->top >> ppdev->cPower2ScansPerBank;
    yTopNextBank = (iBank + 1) << ppdev->cPower2ScansPerBank;
    *piBank      = iBank;
    *pcjOffset   = iBank << ppdev->cPower2BankSizeInBytes;

    prclBank->left   = prclDraw->left;
    prclBank->right  = prclDraw->right;
    prclBank->top    = prclDraw->top;
    prclBank->bottom = yTopNextBank;

    bOneBank = FALSE;
    if (prclBank->bottom >= prclDraw->bottom)
    {
        prclBank->bottom  = prclDraw->bottom;
        bOneBank          = TRUE;
    }

    return(bOneBank);
}

#if GDI_BANKING                 // GDI can't draw directly in the framebuffer
                                //   when running on the Alpha

/******************************Public*Routine******************************\
* VOID vBankStart
*
* Given the bounds of the drawing operation described by 'prclDraw' and
* the original clip object, maps in the first bank and returns in
* 'pbnk->pco' and 'pbnk->pso' the CLIPOBJ and SURFOBJ to be passed to the
* engine for the first banked call-back.
*
* Note: This routine only supports the screen being the destination, and
*       not the source.  We have a separate, faster routine for doing
*       SRCCOPY reads from the screen, so it isn't worth the extra code
*       size to implement.
*
\**************************************************************************/

VOID vBankStart(
PDEV*       ppdev,      // Physical device information.
RECTL*      prclDraw,   // Rectangle bounding the draw area, in relative
                        //  coordinates.  Note that 'left' and 'right'
                        //  should be set for correct handling with broken
                        //  rasters.
CLIPOBJ*    pco,        // Original drawing clip object (may be modified).
BANK*       pbnk)       // Resulting bank information.
{
    LONG cjOffset;
    LONG xOffset;
    LONG yOffset;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pco = ppdev->pcoBank;

        // Reset the clipping flag to trivial because we may have left
        // it as rectangular in a previous call:

        pco->iDComplexity = DC_TRIVIAL;

        // At the same time we convert to absolute coordinates, make sure
        // we won't try to enumerate past the bounds of the screen:

        pbnk->rclDraw.left       = prclDraw->left   + xOffset;
        pbnk->rclDraw.right      = prclDraw->right  + xOffset;

        pbnk->rclDraw.top
            = max(0,               prclDraw->top    + yOffset);
        pbnk->rclDraw.bottom
            = min(ppdev->cyMemory, prclDraw->bottom + yOffset);
    }
    else
    {
        pbnk->rclSaveBounds    = pco->rclBounds;
        pbnk->iSaveDComplexity = pco->iDComplexity;
        pbnk->fjSaveOptions    = pco->fjOptions;

        // Let GDI know that it has to pay attention to the clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // We have to honour the original clip object's rclBounds, so
        // intersect the drawing region with it, then convert to absolute
        // coordinates:

        pbnk->rclDraw.left
            = max(prclDraw->left,   pco->rclBounds.left)   + xOffset;
        pbnk->rclDraw.right
            = min(prclDraw->right,  pco->rclBounds.right)  + xOffset;
        pbnk->rclDraw.top
            = max(prclDraw->top,    pco->rclBounds.top)    + yOffset;
        pbnk->rclDraw.bottom
            = min(prclDraw->bottom, pco->rclBounds.bottom) + yOffset;
    }

    if ((pbnk->rclDraw.left > pbnk->rclDraw.right)
     || (pbnk->rclDraw.top  > pbnk->rclDraw.bottom))
    {
        // It's conceivable that we could get a situation where we have
        // an empty draw rectangle.  Make sure we won't puke on our shoes:

        pbnk->rclDraw.left   = 0;
        pbnk->rclDraw.right  = 0;
        pbnk->rclDraw.top    = 0;
        pbnk->rclDraw.bottom = 0;
    }

    if (!ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                               &cjOffset, &pbnk->iBank))
    {
        // The drawing operation spans multiple banks.  If the original
        // clip object was marked as trivial, we have to make sure to
        // change it to rectangular so that GDI knows to pay attention
        // to the bounds of the bank:

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;
    }

    pbnk->ppdev = ppdev;
    pbnk->pco   = pco;
    pbnk->pso   = ppdev->psoBank;

    // Convert rclBounds and pvScan0 from absolute coordinates back to
    // relative.  When GDI calculates where to start drawing, it computes
    // pjDst = pso->pvScan0 + y * pso->lDelta + (x << cPelSize), where 'x'
    // and 'y' are relative coordinates.  We'll muck with pvScan0 to get
    // it pointing to the correct spot in the bank:

    pbnk->pso->pvScan0 = ppdev->pjScreen - cjOffset
                       + yOffset * ppdev->lDelta
                       + (xOffset << ppdev->cPelSize);

    ASSERTDD((((ULONG_PTR) pbnk->pso->pvScan0) & 3) == 0,
             "Off-screen bitmaps must be dword aligned");

    pco->rclBounds.left   -= xOffset;
    pco->rclBounds.right  -= xOffset;
    pco->rclBounds.top    -= yOffset;
    pco->rclBounds.bottom -= yOffset;

    // Enable banking and map in bank iBank:

    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, pbnk->iBank);
}

/******************************Public*Routine******************************\
* BOOL bBankEnum
*
* If there is another bank to be drawn on, maps in the bank and returns
* TRUE and the CLIPOBJ and SURFOBJ to be passed in the banked call-back.
*
* If there were no more banks to be drawn, returns FALSE.
*
\**************************************************************************/

BOOL bBankEnum(
BANK* pbnk)
{
    LONG     iBank;
    LONG     cjOffset;
    PDEV*    ppdev;
    CLIPOBJ* pco;
    LONG     xOffset;
    LONG     yOffset;

    ppdev   = pbnk->ppdev;
    pco     = pbnk->pco;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    // We check here to see if we have to handle the second part of
    // a broken raster.  Recall that pbnk->rclDraw is in absolute
    // coordinates, but pco->rclBounds is in relative coordinates:

    if (pbnk->rclDraw.right - xOffset != pco->rclBounds.right)
    {
        // The clip object's 'top' and 'bottom' are already correct:

        pco->rclBounds.left  = pco->rclBounds.right;
        pco->rclBounds.right = pbnk->rclDraw.right - xOffset;

        pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
        pbnk->iBank++;

        ppdev->pfnBankMap(ppdev, pbnk->iBank);

        return(TRUE);
    }

    if (pbnk->rclDraw.bottom > pco->rclBounds.bottom + yOffset)
    {
        // Advance the drawing area 'top' to account for the bank we've
        // just finished, and map in the new bank:

        pbnk->rclDraw.top = pco->rclBounds.bottom + yOffset;

        ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                              &cjOffset, &iBank);

        // Convert rclBounds back from absolute to relative coordinates:

        pco->rclBounds.left   -= xOffset;
        pco->rclBounds.right  -= xOffset;
        pco->rclBounds.top    -= yOffset;
        pco->rclBounds.bottom -= yOffset;

        // If we just finished handling a broken raster, we've already
        // got the bank mapped in:

        if (iBank != pbnk->iBank)
        {
            pbnk->iBank = iBank;
            pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
            ppdev->pfnBankMap(ppdev, iBank);
        }

        return(TRUE);
    }

    // We're done!  Turn off banking and reset the clip object if necessary:

    ppdev->pfnBankSelectMode(ppdev, BANK_OFF);

    if (pco != ppdev->pcoBank)
    {
        pco->rclBounds    = pbnk->rclSaveBounds;
        pco->iDComplexity = pbnk->iSaveDComplexity;
        pco->fjOptions    = pbnk->fjSaveOptions;
    }

    return(FALSE);
}

#endif // GDI_BANKING

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (0 - ((bDstIsScreen) ? (LONG)((ULONG_PTR)pjDst) : (LONG)((ULONG_PTR)pjSrc))) & 3;
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    #if defined(i386)
    {
        _asm {
            mov     eax,lSrcDelta   ; eax = Source delta accounting for middle
            mov     ebx,lDstDelta   ; ebx = Dest delta accounting for middle
            mov     edx,cyScan      ; edx = Count of scans
            mov     esi,pjSrc       ; esi = Source pointer
            mov     edi,pjDst       ; edi = Dest pointer

        Next_Scan:

            mov     ecx,cjStartPhase
            rep     movsb

            mov     ecx,culMiddle
            rep     movsd

            mov     ecx,cjEndPhase
            rep     movsb

            add     esi,eax         ; Advance to next scan
            add     edi,ebx
            dec     edx
            jnz     Next_Scan

            mov     eax,ppjSrc      ; Save the updated pointers
            mov     ebx,ppjDst
            mov     [eax],esi
            mov     [ebx],edi
        }
    }
    #else
    {
        LONG i;

        // Because of its bus design, we cannot do a straight memcpy
        // to/from the frame buffer on an Alpha -- we have to go
        // through WRITE/READ macros.

        // First, to be safe, flush all pending I/O:

        MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    // ### WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    *pjDst = *pjSrc;
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    // ### WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    *((ULONG *)pjDst) = *((ULONG UNALIGNED *)pjSrc);
                    pjSrc += sizeof(ULONG UNALIGNED);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    // ### WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    *pjDst = *pjSrc;
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    // ### *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    *pjDst = *pjSrc;
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    #if !defined(ALPHA)
                    {
                        // ### *((ULONG UNALIGNED *)pjDst) = READ_REGISTER_ULONG(pjSrc);
                        *((ULONG UNALIGNED *)pjDst) = *((ULONG *)pjSrc);
                    }
                    #else
                    {
                        // There are some board 864/964 boards where we can't
                        // do dword reads from the frame buffer without
                        // crashing the Avanti.

                        //*((ULONG UNALIGNED *) pjDst) =
                        // ((ULONG) READ_REGISTER_UCHAR(pjSrc + 3) << 24) |
                        // ((ULONG) READ_REGISTER_UCHAR(pjSrc + 2) << 16) |
                        // ((ULONG) READ_REGISTER_UCHAR(pjSrc + 1) << 8)  |
                        // ((ULONG) READ_REGISTER_UCHAR(pjSrc));

                        *((ULONG UNALIGNED *) pjDst) =
                             (((ULONG) *(pjSrc + 3)) << 24) |
                             (((ULONG) *(pjSrc + 2)) << 16) |
                             (((ULONG) *(pjSrc + 1)) << 8)  |
                             (((ULONG) *(pjSrc)));
                    }
                    #endif

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG UNALIGNED);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    // ### *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    *pjDst = *pjSrc;
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }
    #endif
}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:

    DISPDBG((2, "vPutBits -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank:

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + (rclDraw.left << ppdev->cPelSize)
                                - cjOffset;

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + pptlSrc->y * lSrcDelta
                                        + (pptlSrc->x << ppdev->cPelSize);

    while (TRUE)
    {
        cjScan = (rclBank.right  - rclBank.left) << ppdev->cPelSize;
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(&pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;
            ppdev->pfnBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = (rclDraw.right - rclBank.right) << ppdev->cPelSize;

            // Account for the fact that we're now one bank lower in the
            // destination:

            pjDst -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan:

            #if GDI_BANKING
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            #else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(&pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             TRUE);    // Screen is the destination
            }
            #endif
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjDst -= ppdev->cjBank;
                iBank = iNewBank;
                ppdev->pfnBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, BANK_OFF);
            DISPDBG((2, "vPutBits -- exit"));
            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vPutBitsLinear
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    cjRemainder;

    BYTE* pjBase = ppdev->pjBase;

    DISPDBG((2, "vPutBitsLinear -- enter"));

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vPutBitsLinear: rectangle wasn't fully clipped");

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + (rclDraw.left * ppdev->cBpp);

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + (pptlSrc->y  * lSrcDelta)
                                        + (pptlSrc->x * ppdev->cBpp);

    cjScan = (rclDraw.right  - rclDraw.left) * ppdev->cBpp;
    cyScan = (rclDraw.bottom - rclDraw.top);

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    vAlignedCopy(&pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 TRUE);            // Screen is the dest
    DISPDBG((2, "vPutBitsLinear -- exit"));
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    DISPDBG((2, "vGetBits -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank.

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, BANK_ON);
    ppdev->pfnBankMap(ppdev, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + (rclDraw.left << ppdev->cPelSize)
                                - cjOffset;

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + (prclDst->left << ppdev->cPelSize);

    while (TRUE)
    {
        cjScan = (rclBank.right  - rclBank.left) << ppdev->cPelSize;
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(&pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     FALSE);            // Screen is the source

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;
            ppdev->pfnBankMap(ppdev, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = (rclDraw.right - rclBank.right) << ppdev->cPelSize;

            // Account for the fact that we're now one bank lower in the
            // source:

            pjSrc -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan.  Note that we don't have to
            // advance the pointers because they're already pointing to the
            // beginning of the next scan:

            #if GDI_BANKING
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            #else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(&pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             FALSE);    // Screen is the source
            }
            #endif
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjSrc -= ppdev->cjBank;
                iBank = iNewBank;
                ppdev->pfnBankMap(ppdev, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, BANK_OFF);
            DISPDBG((2, "vGetBits -- exit"));
            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vGetBitsLinear
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBitsLinear(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    cjRemainder;

    BYTE* pjBase = ppdev->pjBase;

    DISPDBG((2, "vGetBitsLinear -- enter"));

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "vGetBitsLinear: rectangle wasn't fully clipped");

    DISPDBG((1, "rclDraw(%d,%d,%d,%d)", rclDraw.left,
                                        rclDraw.top,
                                        rclDraw.right,
                                        rclDraw.bottom));

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + (rclDraw.left * ppdev->cBpp);

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + (prclDst->left * ppdev->cBpp);

    cjScan = (rclDraw.right  - rclDraw.left) * ppdev->cBpp;
    cyScan = (rclDraw.bottom - rclDraw.top);

    WAIT_FOR_IDLE_ACL(ppdev, pjBase);
    vAlignedCopy(&pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                 FALSE);            // Screen is the source
    DISPDBG((2, "vGetBitsLinear -- exit"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\w32\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in the 'blt??.c' files.
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).
*
*       Unfortunately, if we've created our primary surface as a device-
*       managed surface, it has an 'iType' of STYPE_BITMAP and not
*       STYPE_DEVICE.  So throughout this code, we will determine if a
*       surface is one of ours by checking 'dhsurf' -- a NULL value means
*       that it's a GDI-created DIB, otherwise it's one of our surfaces and
*       'dhsurf' points to our DSURF structure.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* VOID vXferNativeSrccopy
*
* Does a SRCCOPY transfer of a bitmap to the screen using the frame
* buffer, because on the Tseng chips it's faster than using the data
* transfer register.
*
\**************************************************************************/

VOID vXferNativeSrccopy(        // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       rop4,               // Not used
SURFOBJ*    psoSrc,             // Source surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Not used
{
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    RECTL   rclDst;
    POINTL  ptlSrc;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rop4 == 0xcccc, "Must be a SRCCOPY rop");

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    while (TRUE)
    {
        ptlSrc.x      = prcl->left   + dx;
        ptlSrc.y      = prcl->top    + dy;

        // 'ppdev->pfnPutBits' takes only absolute coordinates, so add in the
        // off-screen bitmap offset here:

        rclDst.left   = prcl->left   + xOffset;
        rclDst.right  = prcl->right  + xOffset;
        rclDst.top    = prcl->top    + yOffset;
        rclDst.bottom = prcl->bottom + yOffset;

        ppdev->pfnPutBits(ppdev, psoSrc, &rclDst, &ptlSrc);

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(_X86_)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwMix,            // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{
    LONG    cBpp;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory * ppdev->cBpp),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // ppdev->pfnGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cBpp = ppdev->cBpp;

        soTmp.lDelta = cBpp * (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L));

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jR