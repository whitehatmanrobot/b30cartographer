
                Utils.AddConfigDatabaseSetting2(ClientName, 99,    0, Name0, "AGroup", Utils.INITIAL_BETA_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(ClientName);
                xrl.SetClientVersion(2, 0, 18964, 0);
                xrl.SetBetaGroupFlag(false);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for "+ClientName);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for "+ClientName));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", ClientName);
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// For this test we use the initial beta group.
        /// In this case there is no non-beta setting available.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [CompoundCase("InBeta", true)]
        [CompoundCase("OutOfBeta", false)]
        [TestCase, Description("Verifies that it works when there is a version with ONLY a beta group setting and no non-beta group setting.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Xenon_Build_QFE_BetaOnly : HiveTestNode
        {
            public override void Setup()
            {
                if ((bool)MyValues[0])
                {
                    Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
                }
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.INITIAL_BETA_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag((bool)MyValues[0]);

                if ((bool)MyValues[0])
                {
                    ExecuteXrl(xrl);

                    string configString = xrl.Response.config;
                    Global.RO.Debug("resp.config: " + configString);

                    if (Utils.VerifyHiveSettings(xrl, Utils.INITIAL_BETA_GROUP, true))
                    {
                        Global.RO.Success("Verified HIVE for [{0}]", name);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                    }
                }
                else //not in the beta
                {
                    ExecuteXrlExpectingFailure(xrl, 0x8015C101); //XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// For this test we use the initial beta group.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [TestCase, Description("A setting has multiple different values for several different beta groups, verify we get the right one.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_Xenon_Build_QFE_BetaMultipleHiveSettings : HiveTestNode
        {
            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.OTHER_BETA_GROUP1);
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.FillConfigDatabase(3, name, 50, 6699, 1, Utils.INITIAL_BETA_GROUP);
                Utils.FillConfigDatabase(3, name, 50, 6699, 1, Utils.OTHER_BETA_GROUP0);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-A", "0", Utils.OTHER_BETA_GROUP0);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-B", "X0", Utils.OTHER_BETA_GROUP0);
                Utils.FillConfigDatabase(3, name, 50, 6699, 1, Utils.OTHER_BETA_GROUP1);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-A", "1", Utils.OTHER_BETA_GROUP1);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-B", "X1", Utils.OTHER_BETA_GROUP1);
                Utils.FillConfigDatabase(3, name, 50, 6699, 1, Utils.OTHER_BETA_GROUP2);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-A", "2", Utils.OTHER_BETA_GROUP2);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-B", "X2", Utils.OTHER_BETA_GROUP2);
                Utils.FillConfigDatabase(3, name, 50, 6699, 1, Utils.NO_GROUP);
                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "settingInBoth-A", "2", Utils.NO_GROUP);
                Utils.FillConfigDatabase(3, name, 50);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.OTHER_BETA_GROUP1, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        [TestCase, Description("A setting exists in a beta group but not in the global groups.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_UniqueBetaOnlyDifferentSettings : HiveTestNode
        {
            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "UniqueBetaSetting", "1337-A", Utils.INITIAL_BETA_GROUP);
                Utils.AddConfigDatabaseSetting2(name, null, null, "UniqueBaseSetting", "1337-B", Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.INITIAL_BETA_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        [TestCase, Description("A setting exists in a beta group but not in the global groups.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
        public class P_UniqueBetaOnlySameSetting : HiveTestNode
        {
            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.AddConfigDatabaseSetting2(name, 6699, 1, "CommonSetting", "1337-A", Utils.INITIAL_BETA_GROUP);
                Utils.AddConfigDatabaseSetting2(name, null, null, "CommonSetting", "1337-C", Utils.NO_GROUP);
                Utils.AddConfigDatabaseSetting2(name, null, null, "BaseOnlySetting", "Whatever", Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.INITIAL_BETA_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        [TestCase, Description("Settings are defined for combinations of base/build/beta and verify that all configs still return correct settings")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        [CompoundCase("BaseOnly", true, false, false)]
        [CompoundCase("BuildQfeOnly", false, true, false)]
        [CompoundCase("BetaOnly", false, false, true)]
        [CompoundCase("BaseBuildQfe", true, true, false)]
        [CompoundCase("BaseBeta", true, false, true)]
        [CompoundCase("BuildQfeBeta", false, true, true)]
        [CompoundCase("BaseBuildQfeBeta", true, true, true)]
        public class P_BasicVerify : HiveTestNode
        {
            String name = "BuildQfeBetaTest";
            UInt16 build = 6699;
            UInt16 qfe = 1;

            Boolean propBase;
            Boolean propBuild;
            Boolean propBeta;

            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.OTHER_BETA_GROUP0);

                propBase = (Boolean)MyValues[0];
                propBuild = (Boolean)MyValues[1];
                propBeta = (Boolean)MyValues[2];

                if (propBase)
                {
                    // Add 10 settings to the base class
                    Utils.FillConfigDatabase(1, name, 50);
                }

                if (propBuild)
                {
                    // Add 5 settings to the empty beta group
                    Utils.FillConfigDatabase(2, name, 50, build, qfe, Utils.NO_GROUP);
                }

                if (propBeta)
                {
                    // Add 3 settings to the specific beta group
                    Utils.FillConfigDatabase(3, name, 50, build, qfe, Utils.OTHER_BETA_GROUP0);
                }

                Utils.ReloadLiveRegistry();
            }

            public override void Run()
            {
                XRLGetLiveConfig xrl;

                if (propBase)
                {
                    xrl = CreateXRL(name);

                    // Request the settings for the base group (no build/qfe or beta)
                    Global.RO.Info("Requesting base settings...");
                    ExecuteXrl(xrl);

                    if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                    {
                        Global.RO.Success("Verified base settings HIVE for [{0}]", name);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed base HIVE for [{0}]", name));
                    }
                }

                if (propBuild)
                {
                    xrl = CreateXRL(name);
                    xrl.SetClientVersion(2, 0, build, qfe);

                    // Request the settings for the build/qfe group (no beta)
                    Global.RO.Info("Requesting build/qfe settings...");
                    ExecuteXrl(xrl);

                    if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                    {
                        Global.RO.Success("Verified build/qfe settings HIVE for [{0}]", name);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(string.Format("Failed build/qfe HIVE for [{0}]", name));
                    }
                }

                xrl = CreateXRL(name);
                xrl.SetClientVersion(2, 0, build, qfe);
                xrl.SetBetaGroupFlag(true);

                // Request the settings for the specific beta group
                Global.RO.Info("Requesting betagroup settings...");
                ExecuteXrl(xrl);

                if (Utils.VerifyHiveSettings(xrl, Utils.OTHER_BETA_GROUP0, true))
                {
                    Global.RO.Success("Verified beta settings HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed beta HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// For this test we use the initial beta group.
        /// However the beta group flag is not set in the authdata, so it should short circuit and assume it's not in a group.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Request for a machine that is in a beta group, but their authdata bit is not set so they should be treated like they're not in a group.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_Xenon_Build_QFE_Beta_NoBetaFlag : HiveTestNode
        {
            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.INITIAL_BETA_GROUP);
                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag(false);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// However the beta group flag is set in the authdata even though they're not in a beta group.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Request for a machine that is not in a beta group, but their authdata bit is set.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_Xenon_Build_QFE_NotInBeta_BetaFlag : HiveTestNode
        {
            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.INITIAL_BETA_GROUP);
                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
                Utils.RemoveMachineAndGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
            }
        }

        /// <summary>
        /// Validates that GetLiveConfig will not give us settings for a group that
        /// we don't belong to.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that we don't get beta settings for a group we are not a member of.")]
        [Owner("TobiasB"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_Xenon_Build_QFE_Beta_Not_Member : HiveTestNode
        {
            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Guid betaGroup = Guid.NewGuid();
                Utils.EnsureMachineInGroup(MachinePuid, betaGroup);

                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.INITIAL_BETA_GROUP);
                Utils.FillConfigDatabase(10, name, 50, 6699, 1, Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6699, 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                Utils.RemoveMachineAndGroup(MachinePuid, betaGroup);

                // Results are for the other group
                if (Utils.VerifyHiveSettings(xrl, betaGroup, true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates the real mainline scenario, calling GetLiveConfig with the same
        /// string that the console would normally call it with. That means that it is
        /// of the form Xenon.Build.QFE.Beta. This is accomplished by filling in the
        /// fakeSG auth data with build numbers that we expect in the database.
        /// For this test we use the initial beta group.
        /// Machine is in several unrelated non-conflicting beta groups.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration which matches
        ///     what the Xbox360 console will send gets the correct result for that
        ///     config name.
        ///     </scenarios>
        /// </remarks>
        [TestCase, Description("Request for a machine that is in multiple beta group."), Ignore("For the 2010 March XSR we added a constraint preventing a machine from being in multiple groups.  This will be allowed in a later release.")]
        [Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(2)]
        [CompoundCase("GroupOverride",     5000, true)]  //the group overrides the base
        [CompoundCase("Conflicting",       4000, false)] //same version for different groups with different values
        [CompoundCase("MultipleIdentical", 3000, true)]  //same version for different groups but values are the same so there's no conflict
        public class N_Xenon_Build_QFE_Beta_MachineInMultipleGroups : HiveTestNode
        {
            public override void Setup()
            {
                Utils.EnsureMachineInGroup(MachinePuid, Utils.INITIAL_BETA_GROUP);
                Utils.EnsureMachineInGroup(MachinePuid, Utils.OTHER_BETA_GROUP0);
                Utils.EnsureMachineInGroup(MachinePuid, Utils.OTHER_BETA_GROUP1);
                Utils.EnsureMachineInGroup(MachinePuid, Utils.OTHER_BETA_GROUP2);
            }

            public override void Run()
            {
                string name = "BuildQfeBetaTest";

                Utils.FillConfigDatabase(10, name, 50, 3000, 1, Utils.NO_GROUP);
                Utils.FillConfigDatabase(10, name, 50, 4000, 1, Utils.NO_GROUP);
                Utils.FillConfigDatabase(10, name, 50, 5000, 1, Utils.NO_GROUP);
                Utils.AddConfigDatabaseSetting2(name, 3000, 1, "SettingA", "5", Utils.OTHER_BETA_GROUP0);
                Utils.AddConfigDatabaseSetting2(name, 3000, 1, "SettingA", "5", Utils.OTHER_BETA_GROUP1);
                Utils.AddConfigDatabaseSetting2(name, 3000, 1, "SettingA", "5", Utils.OTHER_BETA_GROUP2);
                Utils.AddConfigDatabaseSetting2(name, 4000, 1, "SettingA", "3", Utils.INITIAL_BETA_GROUP);
                Utils.AddConfigDatabaseSetting2(name, 4000, 1, "SettingA", "0", Utils.OTHER_BETA_GROUP0);
                Utils.AddConfigDatabaseSetting2(name, 4000, 1, "SettingA", "1", Utils.OTHER_BETA_GROUP1);
                Utils.AddConfigDatabaseSetting2(name, 4000, 1, "SettingA", "2", Utils.OTHER_BETA_GROUP2);
                Utils.AddConfigDatabaseSetting2(name, 5000, 1, "SettingA", "4", Utils.OTHER_BETA_GROUP1);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, (ushort)(int)MyValues[0], 1);
                xrl.SetBetaGroupFlag(true);
                ExecuteXrl(xrl);

                string configString = xrl.Response.config;
                Global.RO.Debug("resp.config: " + configString);

                if (Utils.VerifyHiveSettings(xrl, ((bool)MyValues[1]?Utils.OTHER_BETA_GROUP1:Utils.NO_GROUP), true))
                {
                    Global.RO.Success("Verified HIVE for [{0}]", name);
                }
                else
                {
                    throw new UnexpectedTestResultException(string.Format("Failed HIVE for [{0}]", name));
                }
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "BuildQfeBetaTest");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that a call to GetLiveConfig without a Build and QFE is not
        /// allowed if the config name does not exists in NPDB.t_multisettings. The
        /// setting allows the call to be made without a Build and QFE specified.
        /// This should never be allowed in production.
        ///
        /// The expected failure code is
        /// <code>8015C101: XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG</code>
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made with a configuration that has not
        ///     been defined as a shared setting is denied when requested.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [TestCase, Description("BVT verifies that a result is returned from GetLiveConfig")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_NoBaseConfig : HiveTestNode
        {
            public override void Run()
            {
                string name = "NoBase";

                Utils.FillConfigDatabase(10, name, 100);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                ExecuteXrlExpectingFailure(xrl, 0x8015C101); //XONLINE_E_LIVEINFO_HIVE_INVALID_CONFIG
            }

            public override void Cleanup()
            {
                Utils.RemoveConfigDatabaseSetting("", "NoBase");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// Validates that a call to GetLiveConfig who's only settings have BUILD and
        /// QFE still returns a valid restult.
        ///
        /// Xenon           Setting1=1 Does not exist
        /// Xenon.6666.10   Setting1=1 Does exist
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> A request made to a configuration that doesn't have
        ///     a base value defined still returns valid settings.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     Beta cannot be defined if Build and QFE are not both defined.
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that a config with only settings that have BUILD and QFE still works.")]
        [Owner("BenRan"), TestFrequency("Regression"), TestCasePriority(2)]
        public class N_NoBaseWithBuildQfe : HiveTestNode
        {
            public override void Run()
            {
                string name = "NoBaseConfigWithBuild";

                Utils.EmptyConfigDatabase("", name);
                Utils.FillConfigDatabase(10, name, 50, 6666, 10, Utils.NO_GROUP);
                Utils.ReloadLiveRegistry();

                XRLGetLiveConfig xrl=CreateXRL(name);
                xrl.SetClientVersion(2, 0, 6666, 10);
                ExecuteXrl(xrl);

                if (!Utils.VerifyHiveSettings(xrl, Utils.NO_GROUP, true))
                {
                    throw new UnexpectedTestResultException("Hive settings verification failed.");
                }
            }

            public override void Cleanup()
            {
                Utils.EmptyConfigDatabase("", "NoBaseConfigWithBuild");
                Utils.RemoveConfigDatabaseSetting("", "NoBaseConfigWithBuild");
                Utils.ReloadLiveRegistry();
            }
        }

        /// <summary>
        /// BVT that verifies that the Wiredata Public Key values we expect to exist in the hive for the xenon client do exist in the hive, 
        /// and that we can get the expected private key from the Crypto system.
        /// This should probably be moved into LiveBVT at some point, after the necessary steps have been taken to make it as robust as possible.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     BVT: Clients can get the public key from the hive
        ///     BVT: Xuacs can get the private key from KEKCryptoMgr.GetKey
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test compares the key returned by a query of the hive against a hardcoded known value. If the public key ever changes, then this test will need to be updated with the new value.
        ///     The value for the private key is stored unencrypted in test-pci.xboxlive.com.cspblob, and will also need to be updated if the keys ever change.
        ///     The values used in this test are (for obvious reasons) only valid for use in test environments.
        ///     </section>
        /// </remarks>
        [TestCase, Description("BVT verifies that the expected pub/priv Wiredata keys are available to clients/XUACS")]
        [Owner("ilatham"), TestFrequency("Regression"), EnvRequirement("Manual"), TestCasePriority(3)]
        public class P_WiredataKeys : HiveTestNode
        {
            public override void Run()
            {
                string expectedPublicKey = @"BgIAAACkAABSU0ExAAgAAAEAAQAZ5xN9vY2Z5B17TN7hbISt3naz/C2IvhFxgTB2jgDgCFyQU4YxQ1oveKpC6PV4r8T9xH79ATomw6wMyzmflMV1gfQ8BXiQffm/PY2rm2fKeim6480L3M4xPpbp9mUb1B0ByRnMoXXwPVuuQAQaIHRG0xmHW46tqCTZoxiYcUTiHWsRH8ohveVPG5MhV39pD4Eg65HTrMEG+qBNV+IIJ5V+EJ0muRg2MXxtapFBUdOAZMG+WV11p65MeV2oWu/53aktO0ZzgjwOMgQEUpOImg17a0N+fgu/MmHQid8OauHCW5V0DsmUo+GLxCGVOFMUCEKrQ94rN4yYq3rT2phcAZ7D";
                string expectedPrivateKeyLocation = Path.Combine(System.Environment.CurrentDirectory, @"SuitesData\Hive\test-pci.xboxlive.com.cspblob");
                byte[] expectedPrivateKey;
                string expectedPublicKeyVersion = @"1";
                string wiredataKeyVersionRegEx = @"(?<KeyVersionEntry>WiredataKeyVersion=(?<KeyVersionValue>[\w+/]*));";
                string wiredataPublicKeyRegEx = @"(?<KeyEntry>WiredataPublicKey=(?<KeyValue>[\w+/]*));";

                if (!File.Exists(expectedPrivateKeyLocation))
                {
                    throw new UnexpectedTestResultException(string.Format("Expected PrivateKey file not found: {0}.", expectedPrivateKeyLocation));
                }

                // get the decrypted private key from the Crypto Manager
                byte[] privateKey = xonline.common.service.ServiceKey.GetLatest(xonline.common.service.ServiceKeyType.WIREDATA_PRIVATE_KEY).Key; // xonline.common.crypto.KEKCryptoMgr.GetKey(keyType, publicKeyVersion);

                expectedPrivateKey = System.IO.File.ReadAllBytes(expectedPrivateKeyLocation);

                // verify that it's the expected key
                if (privateKey.Length != expectedPrivateKey.Length)
                {
                    throw new UnexpectedTestResultException(string.Format("Private Key length ({0}) not as expected ({1}).", privateKey.Length, expectedPrivateKey.Length));
                }
                for (int i = 0; i < privateKey.Length; i++)
                {
                    if (privateKey[i] != expectedPrivateKey[i])
                    {
                        System.IO.File.WriteAllBytes(expectedPrivateKeyLocation + ".actual", privateKey);
                        throw new UnexpectedTestResultException(string.Format("Private Key differs from expected value beginning at index {0}.", i));
                    }
                }

                // get the live hive settings
                XRLGetLiveConfig xrl = CreateXRL("xenon");
                ExecuteXrl(xrl);
                string configString = xrl.Response.config;

                Global.RO.Debug("resp.config: " + configString);

                // check for the WiredataKeyVersion
                System.Text.RegularExpressions.Regex keyVerRegEx = new System.Text.RegularExpressions.Regex(wiredataKeyVersionRegEx);
                System.Text.RegularExpressions.Match keyVerMatch = keyVerRegEx.Match(configString);
                if (!keyVerMatch.Success)
                {
                    Global.RO.Debug("regex: {0}", wiredataKeyVersionRegEx);
                    throw new UnexpectedTestResultException("Failed to find expected WiredataKeyVersion entry.");
                }
                else
                {
                    if (!keyVerMatch.Groups[2].Value.Equals(expectedPublicKeyVersion))
                    {
                        throw new UnexpectedTestResultException(string.Format("WiredataKeyVersion did not have expected value of \"{0}\", got value \"{0}\" instead.", expectedPublicKeyVersion, keyVerMatch.Captures[1].Value));
                    }
                }

                // check for the WireDataPublicKey
                System.Text.RegularExpressions.Regex keyRegEx = new System.Text.RegularExpressions.Regex(wiredataPublicKeyRegEx);
                System.Text.RegularExpressions.Match keyMatch = keyRegEx.Match(configString);
                if (!keyMatch.Success)
                {
                    Global.RO.Debug("regex: {0}", wiredataPublicKeyRegEx);
                    throw new UnexpectedTestResultException("Failed to find expected WiredataPublicKey entry.");
                }
                else
                {
                    if (!keyMatch.Groups[2].Value.Equals(expectedPublicKey))
                    {
                        throw new UnexpectedTestResultException(string.Format("WiredataPublicKey did not have expected value.\nexpected: {0}\ngot: {1}", expectedPublicKey, keyMatch.Groups[2].Value));
                    }
                }

                // TODO: encrypt a test blob of data with the public key we got back
                // TODO: decrypt the test blob of data with the private key
                // TODO: verify that the decrypted test data matches the starting test data
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\HiveUtils.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.LiveInfo;

using xonline.common.utilities;
using xonline.common.sql.webstore;
using xonline.common.config;

namespace Hive
{
    public class Utils
    {
        public class HiveSettings : IEquatable<HiveSettings>
        {
            public Dictionary<string, string> settings;

            public HiveSettings()
            {
                settings = new Dictionary<string, string>();
            }

            public int Count
            {
                get { return settings.Count; }
            }

            public void Insert(string _setting, string _value)
            {
                settings.Add(_setting, _value);
            }

            public void InsertFromString(string _listOfSettings)
            {
                settings = XRLGetLiveConfig.ParseResponseString(_listOfSettings);
            }

            public string EscapeReplacementReverse(string _setting)
            {
                _setting = _setting.Replace("^=", "=");
                _setting = _setting.Replace("^;", ";");
                _setting = _setting.Replace("^^", "^");

                return _setting;
            }

            public bool SettingExists(string _setting)
            {
                return settings.ContainsKey(_setting);
            }

            public string GetSetting(string _setting)
            {
                if(settings.ContainsKey(_setting))
                {
                    return settings[_setting];
                }
                else
                {
                    return "";
                }
            }

            public bool ValueExists(string _value)
            {
                return settings.ContainsValue(_value);
            }

            public bool Equals(HiveSettings other)
            {
                return this.Equals(other, false);
            }

            public bool Equals(HiveSettings other, Boolean verbose)
            {
                //
                // First verify that the number of settings is the same
                // if it isn't there is no way we will find all the values.
                //
                ValueCheck.Test("Number of settings", settings.Count, other.Count);

                //
                // Check each setting individually to make sure the values
                // a. Exist, and b. Match
                //
                foreach (KeyValuePair<string, string> kvp in settings)
                {
                    // If the setting exists
                    if (other.SettingExists(kvp.Key))
                    {
                        // Check that the value is the same
                        if (kvp.Value != other.GetSetting(kvp.Key))
                        {
                            if (verbose)
                            {
                                Global.RO.Error("Setting Mismatch: Setting:{0} ValueA:{1} ValueB:{2}", kvp.Key, kvp.Value, other.GetSetting(kvp.Key));
                            }
                            return false;
                        }
                        else
                        {
                            if (verbose)
                            {
                                Global.RO.Success("Setting Match: Setting:{0} ValueA:{1} ValueB:{2}", kvp.Key, kvp.Value, other.GetSetting(kvp.Key));
                            }
                        }
                    }
                    else
                    {
                        if (verbose)
                        {
                            Global.RO.Error("Setting not found: {0}", kvp.Key);
                        }
                        return false;
                    }
                }
                return true;
            }
        }

        private static string configTableName = "t_live_registry_settings";

        /// <summary>
        /// Forces the LiveInfo service to reload the live hive settings
        /// </summary>
        public static void ReloadLiveRegistry()
        {
            Global.RO.Debug("Reloading LiveHive  - e :LiveInfo ReloadLiveHive");
            Global.XEnv.ExecuteXmgmtCommand(Interface.liveinfo, "e :LiveInfo ReloadLiveHive", 10);
        }

        /// <summary>
        /// Looks into the config database in npdb and builds the expected
        /// GetLiveConfig result based on the database current state.
        /// </summary>
        /// <param name="_configName">The name that corresponds to the config name to retrieve</param>
        /// <returns></returns>
        public static string GetLiveConfigFromDatabase(string _configName)
        {
            return GetLiveConfigFromDatabase(_configName, -1, -1, Utils.NO_GROUP);
        }

        public static string GetLiveConfigFromDatabase(string _configName, int _build, int _qfe, Guid _betaGuid)
        {
            string configString = "";
            string sqlBase=null, sqlVersion=null, sqlBeta=null;

            //
            // If there was a build number given
            // look up the setting for that config first.
            //
            if (_build != 0)
            {
                sqlVersion = string.Format("SELECT vc_setting, vc_value FROM {0} WHERE vc_client_config = '{1}' AND vc_environment = '{2}' AND si_build = {3} AND si_qfe = {4} AND guid_beta_group_id = '{5}'",
                    configTableName,
                    _configName,
                    Global.XEnv.GetEnv(),
                    _build,
                    _qfe,
                    NO_GROUP);

                if (_betaGuid!=NO_GROUP)
                {
                    sqlBeta = string.Format("SELECT vc_setting, vc_value FROM {0} WHERE vc_client_config = '{1}' AND vc_environment = '{2}' AND si_build = {3} AND si_qfe = {4} AND guid_beta_group_id = '{5}'",
                        configTableName,
                        _configName,
                        Global.XEnv.GetEnv(),
                        _build,
                        _qfe,
                        _betaGuid);
                }
            }

            sqlBase = string.Format("SELECT vc_setting, vc_value FROM {0} WHERE vc_client_config = '{1}' AND vc_environment = '{2}' AND si_build IS {3} AND si_qfe IS {4} AND (guid_beta_group_id = '{5}' OR guid_beta_group_id = '{6}')",
                configTableName,
                _configName,
                Global.XEnv.GetEnv(),
                "NULL",
                "NULL",
                _betaGuid,
                NO_GROUP);

            //concatenate the results of all the queries.  settings that appear first have priority once we filter them later.
            configString+=GetLiveConfigPairsFromDatabaseQuery(sqlBeta);
            configString+=GetLiveConfigPairsFromDatabaseQuery(sqlVersion);
            configString+=GetLiveConfigPairsFromDatabaseQuery(sqlBase);
            return configString;
        }

        private static string GetLiveConfigPairsFromDatabaseQuery(string query)
        {
            if (query==null || query.Length==0)
            {
                return "";
            }

            string configString="";

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            System.Data.SqlClient.SqlDataReader reader;
            npdb.ReadData(query, out reader);

            // Loop through all the returned results, and build the expected GetLiveConig result. The current format is <setting>=<value>;
            while (reader.Read())
            {
                string temp = (string)reader[1];
                temp = temp.Replace("^", "^^");
                temp = temp.Replace(";", "^;");
                temp = temp.Replace("=", "^=");
                configString += string.Format("{0}={1};", ((string)reader[0]).Trim().ToLower(), temp);
            }
            reader.Close();

            return configString;
        }

        /// <summary>
        /// Looks into config database and builds a list of all the different
        /// config setting names.
        /// </summary>
        /// <returns></returns>
        public static List<string> GetAllConfigNames()
        {
            List<string> configNames = new List<string>();
            string sql = string.Format("SELECT DISTINCT(vc_client_config) FROM {0}", configTableName);

            //
            // Setup the connection to NPDB and execute the command
            //
            using (Npdb npdb = new Npdb())
            {
                npdb.ConnectToServer();
                System.Data.SqlClient.SqlDataReader reader;
                npdb.ReadData(sql, out reader);

                while (reader.Read())
                {
                    configNames.Add((string)reader[0]);
                }
            }

            return configNames;
        }

        public static bool VerifyHiveSettings(XRLGetLiveConfig xrl, Guid betaGroup)
        {
            return VerifyHiveSettings(xrl, betaGroup, false);
        }
        public static bool VerifyHiveSettings(XRLGetLiveConfig xrl, Guid betaGroup, bool _verbose)
        {
            string expectedSettings = Utils.GetLiveConfigFromDatabase(xrl.Request.configname,
                                                                      xrl.Slot.wBuildNumber,
                                                                      xrl.Slot.wQFENumber,
                                                                      betaGroup);
            string actualSettings = xrl.Response.config;

            Utils.HiveSettings expected = new Utils.HiveSettings();
            Utils.HiveSettings actual = new Utils.HiveSettings();
            expected.InsertFromString(expectedSettings);
            actual.InsertFromString(actualSettings);

            return expected.Equals(actual, _verbose);
        }

        public static Guid INITIAL_BETA_GROUP = new Guid("1A75281C-6B30-4BA8-80C6-66B339F2BA89");
        public static Guid OTHER_BETA_GROUP0 =  new Guid("2A75281C-6B30-1337-80C6-66B339F2BA80");
        public static Guid OTHER_BETA_GROUP1 =  new Guid("2A75281C-6B30-1337-80C6-66B339F2BA81");
        public static Guid OTHER_BETA_GROUP2 =  new Guid("2A75281C-6B30-1337-80C6-66B339F2BA82");
        public static Guid NO_GROUP = Guid.Empty;

        /// <summary>
        /// Inserts entries into the HIVE config table. These settings are totally random string
        /// the entries are inserted as a random string for the setting name and then that same
        /// string in square brackets for the value. That way simple verification can be done if
        /// it is needed. The random string will be prefixed with XLH_, to make clean up much easier
        /// </summary>
        /// <param name="_numRows">Number of random rows to add</param>
        /// <param name="_configName">The config name to enter the rows under.</param>
        public static void FillConfigDatabase(int _numRows, string _configName)
        {
            FillConfigDatabase(_numRows, _configName, 20, -1, -1, NO_GROUP);
        }

        /// <summary>
        /// Inserts entries into the HIVE config table. These settings are totally random string
        /// the entries are inserted as a random string for the setting name and then that same
        /// string in square brackets for the value. That way simple verification can be done if
        /// it is needed. The random string will be prefixed with XLH_, to make clean up much easier
        /// </summary>
        /// <param name="_numRows">Number of random rows to add</param>
        /// <param name="_configName">The config name to enter the rows under.</param>
        /// <param name="_lengthOfEachSetting">Indicates the final length of the setting string returned in the response</param>
        public static void FillConfigDatabase(int _numRows, string _configName, int _lengthOfEachSetting)
        {
            FillConfigDatabase(_numRows, _configName, _lengthOfEachSetting, -1, -1, NO_GROUP);
        }

        /// <summary>
        /// Inserts entries into the HIVE config table. These settings are totally random string
        /// the entries are inserted as a random string for the setting name and then that same
        /// string in square brackets for the value. That way simple verification can be done if
        /// it is needed. The random string will be prefixed with XLH_, to make clean up much easier
        /// </summary>
        /// <param name="_numRows">Number of random rows to add</param>
        /// <param name="_configName">The config name to enter the rows under.</param>
        /// <param name="_lengthOfEachSetting">Indicates the final length of the setting string returned in the response</param>
        /// <param name="_build">The build that the setting applies to</param>
        /// <param name="_qfe">The QFE number that the setting applies to</param>
        /// <param name="_betaGroupId">The beta group the setting applies to</param>
        public static void FillConfigDatabase(int _numRows, string _configName, int _lengthOfEachSetting, int _build, int _qfe, Guid _betaGroupId)
        {
            // Each config setting is generated from a randomly generated 
            // string prefixed with XLH_ used as the name and the value 
            // which is formatted in the response as follows :
            // 
            // XLH_XXXX=[XLH_XXXX];
            if ((_lengthOfEachSetting % 2 != 0) || (_lengthOfEachSetting < 20))
            {
                throw new UnexpectedTestResultException("lengthOfEachSetting must be a multiple of 2 and greater than 20, please update test and try again");
            }

            int lengthOfStringSpace = _lengthOfEachSetting - 4; // account for the =[];
            int lengthOfActualSetting = (lengthOfStringSpace / 2) - 4; // account for the prefix XLH_

            //
            // Setup the connection to NPDB and execute the command
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            string sql = "";

            //
            // Generate a random 10 char string, and insert it into the table as the setting,
            // then put it in [] and insert it as the value relating to that setting. Continue
            // do this until we have inserted _numRows worth of data.
            //
            for (int i = 0; i < _numRows; i++)
            {
                string randomString = "XLH_" + ServerTestFramework.Utilities.RandomEx.GlobalRandGen.GenerateRandomString(lengthOfActualSetting);

                //
                // Build and insert the row into the table. The current table config
                // (vc_environment, vc_client_config, vc_setting, vc_value)
                //
                sql += string.Format(
                    "INSERT INTO {0} (guid_setting, vc_environment, vc_client_config, si_build, si_qfe, vc_setting, vc_value, guid_beta_group_id) VALUES ('{1}', '{2}', '{3}', {4}, {5}, '{6}', '[{7}]', '{8}') \n",
                    configTableName,
                    Guid.NewGuid(),
                    xonline.common.config.Config.Environment,
                    _configName,
                    (_build < 0) ? "NULL" : _build.ToString(),
                    (_qfe < 0) ? "NULL" : _qfe.ToString(),
                    randomString, // vc_setting
                    randomString, // vc_value
                    _betaGroupId
                    );
            }

            Global.RO.Debug(sql);

            if (0 == npdb.IssueCommand(sql))
            {
                Global.RO.Error("0 rows affected");
            }
        }

        /// <summary>
        /// Goes through the config database and removes all settings that are prefixed with
        /// 'XLH_' this way we don't leave the database full of random settings.
        /// </summary>
        /// <returns></returns>
        public static int EmptyConfigDatabase()
        {
            return EmptyConfigDatabase("XLH_", null);
        }

        /// <summary>
        /// Goes through the config database and removes all settings that are LIKE the
        /// passed in setting name.
        /// </summary>
        /// <param name="_settingLike">The setting name to match with LIKE %[setting]%</param>
        /// <param name="_configName">The config name to remove those settings from. Pass null for all.</param>
        /// <returns></returns>
        public static int EmptyConfigDatabase(string _settingLike, string _configName)
        {
            //
            // Setup the connection to NPDB and execute the command
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            string sql;

            //
            // Delete any row from that table whos setting is LIKE _settingLike
            //
            if (_configName != null)
            {
                sql = string.Format("DELETE FROM {0} WHERE vc_setting LIKE '%{1}%' AND vc_client_config = '{2}'", configTableName, _settingLike, _configName);
            }
            else
            {
                sql = string.Format("DELETE FROM {0} WHERE vc_setting LIKE '%{1}%'", configTableName, _settingLike);
            }

            int numRows = npdb.IssueCommand(sql);
            npdb.Close();

            Global.RO.Success("Removed [{0}] rows for {1} from {2}", numRows, _configName, configTableName);
            return numRows;
        }

        /// <summary>
        /// Removes a single setting from the config database
        /// </summary>
        /// <param name="_settingName">Setting name to remove</param>
        /// <param name="_configName">Which configuration to remove the setting from. Pass null for all.</param>
        /// <returns></returns>
        public static int RemoveConfigDatabaseSetting(string _settingName, string _configName)
        {
            //
            // Setup the connection to NPDB and execute the command
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            string sql;

            //
            // Delete any row from that table whos setting is LIKE _settingLike
            //
            if (_configName != null)
            {
                sql = string.Format("DELETE FROM {0} WHERE vc_setting LIKE '%{1}%' AND vc_client_config = '{2}'", configTableName, _settingName, _configName);
            }
            else
            {
                sql = string.Format("DELETE FROM {0} WHERE vc_setting = '{1}'", configTableName, _settingName);
            }

            Global.RO.Info(sql);

            int numRows = npdb.IssueCommand(sql);
            npdb.Close();

            return numRows;
        }

        public static int AddConfigDatabaseSetting(string _settingName, string _settingValue, string _configName, string _environment)
        {
            //
            // Setup the connection to NPDB and execute the command
            //
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            string sql;

            if (_environment == null)
            {
                sql = string.Format(
                    "INSERT INTO {0} (vc_environment, vc_setting, vc_client_config, vc_value) VALUES ('{1}', '{2}', '{3}', '{4}')",
                    configTableName,
                    xonline.common.config.Config.Environment,
                    _settingName,
                    _configName,
                    _settingValue
                    );
            }
            else
            {
                sql = string.Format(
                    "INSERT INTO {0} (vc_environment, vc_setting, vc_client_config, vc_value) VALUES ('{1}', '{2}', '{3}', '{4}')",
                    configTableName,
                    _environment,
                    _settingName,
                    _configName,
                    _settingValue
                    );
            }

            Global.RO.Debug(sql);

            int numRows = npdb.IssueCommand(sql);
            npdb.Close();

            if(numRows < 1)
            {
                throw new Exception(string.Format("{0} FAILED", sql));
            }

            return numRows;
        }

        public static int AddConfigDatabaseSetting2(string _configName, int? _build, int? _qfe, string _settingName, string _settingValue, Guid _group)
        {
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            string sql;


            sql = string.Format("insert into {0} (vc_environment, vc_client_config, si_build, si_qfe, vc_setting, vc_value, guid_beta_group_id) "+
                                "values          ({1},            {2},              {3},      {4},    {5},        {6},      {7})",
                configTableName,
                QueryGenerator.EvaluateObject(Global.XEnv.GetEnv()),
                QueryGenerator.EvaluateObject(_configName),
                QueryGenerator.EvaluateObject(_build),
                QueryGenerator.EvaluateObject(_qfe),
                QueryGenerator.EvaluateObject(_settingName),
                QueryGenerator.EvaluateObject(_settingValue),
                QueryGenerator.EvaluateObject(_group)
                );

            Global.RO.Debug(sql);

            int numRows = npdb.IssueCommand(sql);
            npdb.Close();

            if(numRows < 1)
            {
                throw new Exception(string.Format("{0} FAILED", sql));
            }

            return numRows;
        }

        public static string DeserializeConfigBlocks(ServerTestFramework.XeGenericBlock[] _blocks)
        {
            ServerTestFramework.BlockDeserializer deserializer = new BlockDeserializer(_blocks);
            byte[] clear = deserializer.Deserialize();
            return System.Text.UTF8Encoding.UTF8.GetString(clear);
        }

        public static void EnsureMachineInGroup(ulong machinePuid, Guid groupId)
        {
            MachineEditor machineEditor = MachineEditor.FromId(machinePuid);
            BetaGroupEditor groupEditor = BetaGroupEditor.CreateOrUseExistingId(groupId);
            groupEditor.AddMachine(machinePuid);
            Global.RO.Warn("Ensured group {0} has machine 0x{1:x8}.", groupEditor.Id, machinePuid);
        }

        public static void RemoveMachineAndGroup(ulong machinePuid, Guid groupId)
        {
            BetaGroupEditor.NukeGroup(groupId);
            MachineEditor machineEditor = MachineEditor.FromId(machinePuid);
            machineEditor.CompletelyRemoveMachine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\NetworkAuth\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\Hive\LiveRegistrySprocs.cs ===
using System;
using System.Data.SqlClient;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Database;

using xonline.common.utilities2;
using ServerTestFramework.Utilities;

namespace Hive.Functional
{
    [TestGroup]
    public class LiveRegistrySprocs : TestNode
    {
        private class LiveRegistrySetting : IEquatable<LiveRegistrySetting>
        {
            public LiveRegistrySetting(SqlDataReader reader)
                : this((string)reader[0], SafeReadInt16(reader, 1), SafeReadInt16(reader, 2), (byte)reader[3], (string)reader[4], MungeValue((string)reader[5]), (Guid)reader[6])
            {
            }

            public static LiveRegistrySetting FromObject(object o)
            {
                return new LiveRegistrySetting((object[])o);
            }

            private LiveRegistrySetting(object[] objects)
                : this((string)objects[0], (Int16)objects[1], (Int16)objects[2], (byte)objects[3], (string)objects[4], (string)objects[5], SafeGuidFromString((string)objects[6]))
            {
            }

            private LiveRegistrySetting(string clientConfig, Int16? build, Int16? qfe, byte betaMachine, string setting, string value, Guid? betaGroupId)
            {
                ClientConfig = clientConfig;
                Build = build;
                Qfe = qfe;
                BetaMachine = betaMachine;
                Setting = setting;
                Value = value;
                BetaGroupId = betaGroupId;
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override bool Equals(object obj)
            {
                LiveRegistrySetting setting = obj as LiveRegistrySetting;
                if (setting == null)
                {
                    return false;
                }

                return this.Equals(setting);
            }

            public bool Equals(LiveRegistrySetting lrs)
            {
                return ClientConfig == lrs.ClientConfig
                    && Build == lrs.Build
                    && Qfe == lrs.Qfe
                    && BetaMachine == lrs.BetaMachine
                    && Setting == lrs.Setting
                    && Value == lrs.Value
                    && NullableGuidToGuid(BetaGroupId) == NullableGuidToGuid(lrs.BetaGroupId);
            }

            public override string ToString()
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine(String.Format("ClientConfig = {0}", ClientConfig));
                sb.AppendLine(String.Format("Build = {0}", Build));
                sb.AppendLine(String.Format("Qfe = {0}", Qfe));
                sb.AppendLine(String.Format("BetaMachine = {0}", BetaMachine));
                sb.AppendLine(String.Format("Setting = {0}", Setting));
                sb.AppendLine(String.Format("Value = {0}", Value));
                sb.AppendLine(String.Format("BetaGroupId = {0}", BetaGroupId.HasValue ? BetaGroupId.ToString() : "null"));

                return sb.ToString();
            }

            // NOTE: Docs say that if I implement IEquatable, I should override Equals and GetHashCode. I'm not because I don't care about them (yet).

            private static string MungeValue(string raw)
            {
                string temp = raw.Replace("^", "^^");
                temp = temp.Replace(";", "^;");
                temp = temp.Replace("=", "^=");
                return temp;
            }

            private static Int16? SafeReadInt16(SqlDataReader reader, int index)
            {
                if (reader.IsDBNull(index))
                {
                    return null;
                }
                else
                {
                    return (Int16?)reader[index];
                }
            }

            private static Guid? SafeGuidFromString(string s)
            {
                if (s == null)
                {
                    return null;
                }
                else
                {
                    return new Guid(s);
                }
            }

            private static Guid NullableGuidToGuid(Guid? ng)
            {
                if (ng.HasValue)
                {
                    return ng.Value;
                }
                else
                {
                    return Guid.Empty;
                }
            }

            public static void Insert(LiveRegistrySetting setting)
            {
                RegistrySprocUtil.ManualInsert(ENVIRONMENT, setting);
            }

            public static void Set(LiveRegistrySetting setting)
            {
                RegistrySprocUtil.SprocSet(ENVIRONMENT, setting);
            }

            public static void Test(LiveRegistrySetting expectedSetting)
            {
                LiveRegistrySetting gotSetting = RegistrySprocUtil.GetOneSettingManual(ENVIRONMENT, expectedSetting.Setting);
                ValueCheck.Test("LiveRegistrySetting", expectedSetting, gotSetting);
            }

            public string ClientConfig;
            public Int16? Build;
            public Int16? Qfe;
            public byte BetaMachine;
            public string Setting;
            public string Value;
            public Guid? BetaGroupId;
        }

        private static class RegistrySprocUtil
        {
            private const string MANUAL_INSERT_GROUP = "INSERT INTO t_live_registry_settings (vc_environment, vc_client_config, si_build, si_qfe, vc_setting, vc_value, guid_beta_group_id)"
                                                        + " VALUES ('{0}', '{1}', {2}, {3}, '{4}', '{5}', '{6}')";

            private const string MANUAL_INSERT_NO_GROUP = "INSERT INTO t_live_registry_settings (vc_environment, vc_client_config, si_build, si_qfe, vc_setting, vc_value)"
                                                            + " VALUES ('{0}', '{1}', {2}, {3}, '{4}', '{5}')";

            private const string P_LIVE_REGISTRY_GET_ALL_SETTINGS = "EXEC p_live_registry_get_all_settings '{0}'";

            private const string P_LIVE_REGISTRY_SET_SETTING_GROUP = "EXEC p_live_registry_set_setting '{0}', '{1}', '{2}', '{3}', {4}, {5}, {6}, '{7}'";

            private const string P_LIVE_REGISTRY_SET_SETTING_NO_GROUP = "EXEC p_live_registry_set_setting '{0}', '{1}', '{2}', '{3}', {4}, {5}, {6}";

            private const string MANUAL_GET_SETTING = "SELECT vc_client_config, si_build, si_qfe, CASE WHEN guid_beta_group_id = '1A75281C-6B30-4BA8-80C6-66B339F2BA89' THEN CAST(1 AS TINYINT) ELSE CAST(0 AS TINYINT) END ti_beta_machine, vc_setting, vc_value, guid_beta_group_id FROM t_live_registry_settings"
                                                        + " WHERE vc_environment = '{0}' AND vc_setting = '{1}'";

            private static void IssueCommand(string sql)
            {
                using (Npdb npdb = new Npdb())
                {
                    npdb.ConnectToServer();
                    npdb.IssueCommand(sql);
                }
            }

            public static void ManualInsert(string environment, LiveRegistrySetting lrs)
            {
                string sql = null;
                if (lrs.BetaGroupId.HasValue)
                {
                    sql = String.Format(MANUAL_INSERT_GROUP, environment, lrs.ClientConfig, lrs.Build, lrs.Qfe, lrs.Setting, lrs.Value, lrs.BetaGroupId);
                }
                else
                {
                    sql = String.Format(MANUAL_INSERT_NO_GROUP, environment, lrs.ClientConfig, lrs.Build, lrs.Qfe, lrs.Setting, lrs.Value);
                }

                IssueCommand(sql);
            }

            public static void SprocSet(string environment, LiveRegistrySetting lrs)
            {
                string sql = null;
                if (lrs.BetaGroupId.HasValue)
                {
                    sql = String.Format(P_LIVE_REGISTRY_SET_SETTING_GROUP, environment, lrs.ClientConfig, lrs.Setting, lrs.Value, lrs.Build, lrs.Qfe, lrs.BetaMachine, lrs.BetaGroupId);
                }
                else
                {
                    sql = String.Format(P_LIVE_REGISTRY_SET_SETTING_NO_GROUP, environment, lrs.ClientConfig, lrs.Setting, lrs.Value, lrs.Build, lrs.Qfe, lrs.BetaMachine);
                }

                IssueCommand(sql);
            }

            private static LiveRegistrySetting GetSingleSettingFromCommand(string sql, string setting)
            {
                using (Npdb npdb = new Npdb())
                {
                    npdb.ConnectToServer();

                    SqlDataReader reader;

                    npdb.ReadData(sql, out reader);

                    using (reader)
                    {
                        while (reader.Read())
                        {
                            LiveRegistrySetting lrs = new LiveRegistrySetting(reader);
                            if (lrs.Setting == setting)
                            {
                                return lrs;
                            }
                        }
                    }

                    throw new UnexpectedTestResultException(String.Format("Could not find setting named {0}", setting));
                }
            }

            public static LiveRegistrySetting GetOneSettingSproc(string environment, string setting)
            {
                string sql = String.Format(P_LIVE_REGISTRY_GET_ALL_SETTINGS, environment);
                return GetSingleSettingFromCommand(sql, setting);
            }

            public static LiveRegistrySetting GetOneSettingManual(string environment, string setting)
            {
                string sql = String.Format(MANUAL_GET_SETTING, environment, setting);
                return GetSingleSettingFromCommand(sql, setting);
            }
        }

        private const string ENVIRONMENT = "xblob";
        private const string CLIENT_CONFIG = "xenon";
        private const Int16 BUILD = 1234;
        private const Int16 QFE = 5678;
        private const byte BETA_MACHINE = 0;
        private const string SETTING_NAME_PREFIX = "P_Live_Registry_Get_All_Settings_Direct_";

        [TestCase, Description("Test p_live_registry_get_all_settings directly.")]
        [Owner("TobiasB"), TestFrequency("Daily"), TestCasePriority(1)]
        [CompoundCase("Normal Case with a beta group",
            new object[]
                {
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value", "00000000-0000-0000-0000-000000000001" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value", "00000000-0000-0000-0000-000000000002" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_3", "setting_3_value", "00000000-0000-0000-0000-000000000003" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_4", "setting_4_value", "00000000-0000-0000-0000-000000000004" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_5", "setting_5_value", "00000000-0000-0000-0000-000000000005" },
                })]
        [CompoundCase("Normal Case with no beta group",
            new object[]
                {
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_3", "setting_3_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_4", "setting_4_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_5", "setting_5_value", null },
                })]
        public class P_Live_Registry_Get_All_Settings: TestNode
        {
            private LiveRegistrySetting[] _rglrs = null;

            public override void PreRun()
            {
                _rglrs = Array.ConvertAll<object, LiveRegistrySetting>(MyValues, LiveRegistrySetting.FromObject);
                Array.ForEach(_rglrs, LiveRegistrySetting.Insert);
            }

            public override void Run()
            {
                Array.ForEach(_rglrs, LiveRegistrySetting.Test);
            }

            public override void PostRun()
            {
                Utils.EmptyConfigDatabase(SETTING_NAME_PREFIX, CLIENT_CONFIG);
            }
        }

        [TestCase, Description("Test p_live_registry_set_setting directly for insertion--not update.")]
        [Owner("TobiasB"), TestFrequency("Daily"), TestCasePriority(1)]
        [CompoundCase("Normal Case with a beta group",
            new object[]
                {
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value", "00000000-0000-0000-0000-000000000001" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value", "00000000-0000-0000-0000-000000000002" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_3", "setting_3_value", "00000000-0000-0000-0000-000000000003" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_4", "setting_4_value", "00000000-0000-0000-0000-000000000004" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_5", "setting_5_value", "00000000-0000-0000-0000-000000000005" },
                })]
        [CompoundCase("Normal Case with no beta group",
            new object[]
                {
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_3", "setting_3_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_4", "setting_4_value", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_5", "setting_5_value", null },
                })]
        public class P_Live_Registry_Set_Setting_Insert : TestNode
        {
            private LiveRegistrySetting[] _rglrs = null;

            public override void PreRun()
            {
                _rglrs = Array.ConvertAll<object, LiveRegistrySetting>(MyValues, LiveRegistrySetting.FromObject);
            }

            public override void Run()
            {
                Array.ForEach(_rglrs, LiveRegistrySetting.Set);
                Array.ForEach(_rglrs, LiveRegistrySetting.Test);
            }

            public override void PostRun()
            {
                Utils.EmptyConfigDatabase(SETTING_NAME_PREFIX, CLIENT_CONFIG);
            }
        }

        [TestCase, Description("Test p_live_registry_set_setting directly for update, using the same beta groups.")]
        [Owner("TobiasB"), TestFrequency("Daily"), TestCasePriority(1)]
        [CompoundCase("Normal Case with a beta group",
            new object[]
                {
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value_1", "00000000-0000-0000-0000-000000000001" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value_1", "00000000-0000-0000-0000-000000000002" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value_2", "00000000-0000-0000-0000-000000000001" },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value_2", "00000000-0000-0000-0000-000000000002" },
                })]
        [CompoundCase("Normal Case with no beta group",
            new object[]
                {
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value_1", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value_1", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_1", "setting_1_value_2", null },
                    new object[] { CLIENT_CONFIG, BUILD, QFE, BETA_MACHINE, "P_Live_Registry_Get_All_Settings_Direct_setting_2", "setting_2_value_2", null },
                })]
        public class P_Live_Registry_Set_Setting_Update : TestNode
        {
            private LiveRegistrySetting[] _rglrsInsert;
            private LiveRegistrySetting[] _rglrsUpdate;

            public override void PreRun()
            {
                object[] insert;
                object[] update;
                ArrayUtil.SplitArray(MyValues, 2, out insert, out update);
                _rglrsInsert = Array.ConvertAll<object, LiveRegistrySetting>(insert, LiveRegistrySetting.FromObject);
                _rglrsUpdate = Array.ConvertAll<object, LiveRegistrySetting>(update, LiveRegistrySetting.FromObject);
            }

            public override void Run()
            {
                Array.ForEach(_rglrsInsert, LiveRegistrySetting.Set);
                Array.ForEach(_rglrsInsert, LiveRegistrySetting.Test);
                Array.ForEach(_rglrsUpdate, LiveRegistrySetting.Set);
                Array.ForEach(_rglrsUpdate, LiveRegistrySetting.Test);
            }

            public override void PostRun()
            {
                Utils.EmptyConfigDatabase(SETTING_NAME_PREFIX, CLIENT_CONFIG);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\NetworkAuth\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\NetworkAuth\NetworkAuthStress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;

namespace LiveInfo.NetworkAuthorization.Stress
{
    [TestGroup]
    public class NetworkAuthorizationStress : TestNode
    {
        /// <summary>
        /// Stress test for GetNetworkAuthorizationList. This test validates that the server 
        /// can meet expected TPS requirements for this API.
        /// </summary>
        /// 
        /// <remarks>
        ///     <scenarios>
        ///     <b>Stress:</b> A request is made over and over and the results are validated
        ///     to ensure quality and efficiency of the GetLiveInfo API.
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     </section>
        ///
        ///     <dependencies>
        ///     None.
        ///     </dependencies>
        /// </remarks>
        [StressTest, Owner("BenRan")]
        public class GetNetworkAuthorizationList : TestNode
        {
            public override void PreRun()
            {

            }

            public override void Run()
            {

            }

            public override void PostRun()
            {

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\fd\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\fd\enumerate.cs ===
//
// enumerate.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//

using System;
using System.Web;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.lsp;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.sqlclient;

namespace xonline.server.lsp.fd
{
    // -----------------------------------------------------------------------
    // Enumerate
    // Request handler
    // Called by the console to enumerate SGLSPs
    // -----------------------------------------------------------------------
    public class Enumerate : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            EnumerateCounters countersG = new EnumerateCounters();
            EnumerateCounters countersT = new EnumerateCounters();
            LspEnumerateRequest req = new LspEnumerateRequest();
            int resultCount = 0;
            uint totalResults = 0;
            bool ok = false;
            LspLib.EnumStatus enumStatus = LspLib.EnumStatus.Unknown;

            try
            {
                countersG.StartRequest(0);

                string viface = CallSource.Check(VirtualInterface.xqry, VirtualInterface.xqry_int);

                req.ReadStream(ctx.Request.InputStream);

                countersT.StartRequest(req.titleId);
               
                //
                // if req.userData is an empty string, pass null to Enumerate which 
                // effectivelly tells it to enumerate all entries. If req.userData is not 
                // empty, pass it down to Enumerate in which case only entries that match 
                // the specified user-data will be enumerated.
                //
                
                string userData = req.userData != string.Empty ?
                    req.userData :
                    null;

                LspLib.LspInfo[] results;

                if (LspApp.DatabaseCachingEnabled)
                {
                    enumStatus = LspLib.EnumerateWithCache(req.titleId,
                                              userData,
                                              req.resultIndex,
                                              req.resultCount,
                                              out results,
                                              out totalResults);
                }
                else
                {
                    enumStatus = LspLib.EnumStatus.FromDb;
                    LspLib.Enumerate(req.titleId,
                                     userData,
                                     req.resultIndex,
                                     req.resultCount,
                                     out results,
                                     out totalResults);
                }

                resultCount = results.Length;

                LspEnumerateReply rep = new LspEnumerateReply();
                
                rep.lspInfoCount = (uint) resultCount;
                rep.lspInfo = new LspEnumerateServerInfo[resultCount];

                for(int i=0; i < rep.lspInfo.Length; i++)
                {
                    LspEnumerateServerInfo lspInfo = new LspEnumerateServerInfo();

                    lspInfo.ipSgLsp     = results[i].ipSgLsp;
                    lspInfo.flags       = results[i].flags;
                    lspInfo.userData    = results[i].userData;

                    rep.lspInfo[i] = lspInfo;
                }

                rep.WriteStream(ctx.Response.OutputStream);

                ok = true;
            }
            finally
            {
                string logLine = string.Join("|", new string[] {
                    "LSPENUM3",
                    ctx.Request.UserHostAddress,
                    "0x" + req.titleId.ToString("x8"),
                    req.userData != null ? req.userData : null,
                    req.resultIndex.ToString(),
                    req.resultCount.ToString(),
                    resultCount.ToString(),
                    enumStatus.ToString(),
                    FrontEndApp.MillisecondsElapsed.ToString(),
                    ok ? "0" : "1" });

                Xom.Log(XomAreaName.log, logLine);
            }

            countersG.EndRequest(!ok, enumStatus);
            countersT.EndRequest(!ok, enumStatus);
        }

        public bool IsReusable
        {
            get { return true; }
        }
    }
   
    // -----------------------------------------------------------------------
    // EnumerateCountersCategory
    // Performace counters category for Enumerate
    // -----------------------------------------------------------------------
    [XomPerformanceCounterCategoryAttr( "LSP FD", "LSPFD: Enumerate cache and others" )]
    public class EnumerateCountersCategory : XomPerformanceCounterCategory
    {
        static public EnumerateCountersCategory _instance = new EnumerateCountersCategory();
        static public EnumerateCountersCategory Current(string titleId)
        {
            if (titleId == null)
            {
                titleId = XomPerformanceCounterCategory.DEFAULT_INSTANCE;
            }
            return (EnumerateCountersCategory)_instance.GetInstance(titleId);
        }

        [XomPerformanceCounterAttr(
            "Requests (database)/sec",
            "Requests per second that hit the database",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecondDatabase;

        [XomPerformanceCounterAttr(
             "Requests (database) total", 
             "Total number of requests that hit the database", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsDatabase;
        
        [XomPerformanceCounterAttr(
            "Requests (cache)/sec",
            "Requests per second that hit the local cache",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecondCache;

        [XomPerformanceCounterAttr(
             "Requests (cache) total", 
             "Total number of requests that hit the cache", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsCache;
        
        [XomPerformanceCounterAttr(
            "Requests (cache expired)/sec",
            "Requests per second that hit the local cache while the database is down. This means the entry is expired.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecondCacheDbDown;

        [XomPerformanceCounterAttr(
             "Requests (cache expired) total", 
             "Total number of requests that hit the local cache while the database is down. This means the entry is expired.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsCacheDbDown;
        
    }

    // -----------------------------------------------------------------------
    // EnumerateCounters
    // Performance counters utility class for Enumerate
    // -----------------------------------------------------------------------
    public class EnumerateCounters
    {
        public void StartRequest(uint titleId)
        {
            if(titleId != 0)
            {
                // Use title specific instance
                hexTitleId = titleId.ToString("x8");
            }
            else
            {
                // Use default instance 
                hexTitleId = null;
            }
            
            // lspfd perf counters that duplicated FEAPP ones were removed. --kgoodier
        }

        public void EndRequest(bool failed, LspLib.EnumStatus enumStatus)
        {
            // don't care if call failed for the "new" perf counters tracking the cache

            switch (enumStatus)
            {
            case LspLib.EnumStatus.FromDb:
                EnumerateCountersCategory.Current(hexTitleId).RequestsPerSecondDatabase.Increment();
                EnumerateCountersCategory.Current(hexTitleId).TotalRequestsDatabase.Increment();
                break;
            case LspLib.EnumStatus.FromCache:
                EnumerateCountersCategory.Current(hexTitleId).RequestsPerSecondCache.Increment();
                EnumerateCountersCategory.Current(hexTitleId).TotalRequestsCache.Increment();
                break;
            case LspLib.EnumStatus.FromCacheDbDown:
                EnumerateCountersCategory.Current(hexTitleId).RequestsPerSecondCacheDbDown.Increment();
                EnumerateCountersCategory.Current(hexTitleId).TotalRequestsCacheDbDown.Increment();
                break;
            }
        }

        string hexTitleId = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\NetworkAuth\NetworkAuth.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework.Database;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace LiveInfo.NetworkAuthorization.Functional
{
    ///<HighLevel>
    ///The goal of this test plan is define the test coverage for the Network Authorization APIs. Included you will find API descriptions, a test matrix, and signoff criteria.
    ///
    ///<b>What is the Network Authorization List?</b>
    ///
    ///
    ///<b>How it works?</b>
    ///
    ///GetNetworkAuthorizationList only has one input value, and that is the title id to get an authorization list for. The title id is used to gather the network resources that a specific title is authorized to connect to. The frontdoor code walks through all of the rows in the table and builds an authorization list which is then cached for future requests.
    ///
    ///</HighLevel>
    ///<Goals>
    /// 	Verify that the items returned from the NSAL are as expected
    ///</Goals>
    ///<NonGoals>
    /// 	Test NPDB
    /// 	Test Client Side uses of this API
    /// 	Test other XSTS database tables and functionality
    /// 	Test STSConfig functionality
    ///</NonGoals>
    public class Doc
    {
    }

    [TestGroup]
    public class NetworkAuthorization : TestNode
    {
        /// <summary>
        /// BVT that verifies that a result is returned from GetNetworkAuthorizationList. A good 
        /// baseline case will be the dashboard getting it's own authorization list.  Even if the
        /// returned list is expected to be empty, this should still return succesfully.
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     BVT: A request is made for the dashboard authorization list
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     This test does no validation, it only verifies that a response is returned.
        ///     </section>
        /// </remarks>
        [TestCase, Description("BVT verifies that a result is returned from GetNetworkAuthorizationList")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(1)]
        public class BVT : TestNode
        {
            NetworkAuthHelper helper = null;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());
                helper.GenerateEndpoints(1, 1);
                NetworkAuth.ReloadNetworkAuthorizationList();
            }

            public override void Run()
            {
                helper.Execute(false);

                foreach (var e in helper.Xrl.Response.authorizationList)
                {
                    Global.RO.Info("{0} [{1}]", e.GetServerString(), e.appliesTo);
                }
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Reload the network authorization list")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(2)]
        public class ReloadNetworkAuthorizationList : TestNode
        {
            public override void Run()
            {
                NetworkAuth.ReloadNetworkAuthorizationList();
            }
        }

        /// <summary>
        /// </summary>
        ///
        /// <remarks>
        ///     <scenarios>
        ///     <b>Functional:</b> 
        ///     </scenarios>
        ///
        ///     <section name="Notes">
        ///     </section>
        /// </remarks>
        [TestCase, Description("Verifies that a request returns the expected resource list for various resource counts")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(1)]
        [CompoundCase("SinglePartnerOneEndpoint", 1, 1)]
        [CompoundCase("SinglePartnerTwoEndpoints", 1, 2)]
        [CompoundCase("SinglePartnerTenEndpoints", 1, 10)]
        [CompoundCase("SinglePartner50Endpoints", 1, 50)]
        [CompoundCase("SinglePartner199Endpoints", 1, 199)]
        [CompoundCase("SinglePartner200Endpoints", 1, 200)]
        [CompoundCase("MultiplePartnerOneEndpoint", 4, 1)]
        [CompoundCase("MultiplePartnerTwoEndpoints", 4, 2)]
        [CompoundCase("MultiplePartnerTenEndpoints", 4, 10)]
        [CompoundCase("MultiplePartner25Endpoints", 4, 25)]
        public class SimpleRequestVerify : TestNode
        {
            private NetworkAuthHelper helper;
            private UInt32 titleId;

            public override void PreRun()
            {
                titleId = (UInt32)RandomEx.GlobalRandGen.Next();
                helper = new NetworkAuthHelper(titleId);

                UInt32 businessPartnerCount = Convert.ToUInt32(MyValues[0]);
                UInt32 endpointCount = Convert.ToUInt32(MyValues[1]);

                helper.GenerateEndpoints(endpointCount, businessPartnerCount);
                NetworkAuth.ReloadNetworkAuthorizationList();
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Verifies that a request returns the expected resource list for various resource counts")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(3)]
        public class MoreThan200Endpoints : TestNode
        {
            private NetworkAuthHelper helper;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());
                // Generate 210 endpoints
                helper.GenerateEndpoints(21, 10);
                NetworkAuth.ReloadNetworkAuthorizationList();
            }

            public override void Run()
            {
                // Verify the failure
                helper.Execute(HResult.E_FAIL);

                Global.RO.Success("Request failed as expected with more than 200 endpoints.");
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Performance tests on the network authorization list reloading")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(2)]
        public class ReloadPerformance : TestNode
        {
            private NetworkAuthHelper helper;
            private UInt32 totalEndpoints = 100;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());
                helper.GenerateEndpoints(totalEndpoints, 1);
                NetworkAuth.ReloadNetworkAuthorizationList();
            }

            public override void Run()
            {
                UInt32 endpointIncrement = 100;

                for (int i = 0; i < 10; i++)
                {
                    // Just make sure the request works
                    helper.Execute(false);

                    // Then add a bunch of endpoints to another title
                    NetworkAuth.GenerateEndpoints((UInt32)RandomEx.GlobalRandGen.Next(), endpointIncrement);
                    totalEndpoints += endpointIncrement;

                    DateTime reloadStart = DateTime.UtcNow;
                    NetworkAuth.ReloadNetworkAuthorizationList();
                    TimeSpan reloadTime = DateTime.UtcNow - reloadStart;

                    Global.RO.Info("Loaded {0} endpoints in {1} ms", totalEndpoints, (Int32)reloadTime.TotalMilliseconds);
                }
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Verifies that a request returns the expected resource list for various resource counts")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(2)]
        public class MaximumRequestSize : TestNode
        {
            private NetworkAuthHelper helper;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());
                // Generate 200 Endpoints with a bunch of max legth characters
                // Max length for all strings is 1014 bytes, remaining bytes are for other stuff
                helper.Endpoints = NetworkAuth.GenerateEndpoints(helper.TitleId, 100, 2, 269);
                NetworkAuth.ReloadNetworkAuthorizationList();
            }

            public override void Run()
            {
                // Don't auto verify the response
                helper.Execute(false);

                // We don't really need to verify the response contents, 
                // just that it's no longer than expected
                ValueCheck.Test("Response Count", 200, helper.Xrl.Response.authorizationListCount);
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Checks that an invalid endpoint doesn't prevent valid values from loading")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(3)]
        [CompoundCase("InvalidProtocol", 100, 443, "www.xbox.com", 0, 0, "/", null)]
        [CompoundCase("InvalidPort", 2, 0, "www.xbox.com", 0, 0, "/", null)]
        [CompoundCase("InvalidServer", 2, 443, "--> || :) - :( - :O || <--", 0, 0, "/", null)]
        [CompoundCase("InvalidFromIp", 2, 443, "", Int32.MinValue, 0, "/", null)]
        [CompoundCase("InvalidToIp", 2, 443, "", 0, Int32.MinValue, "/", null)]
        [CompoundCase("MissingFromIp", 2, 443, "", 0x0100A8C0, 0, "/", null)]
        [CompoundCase("MissingToIp", 2, 443, "", 0, 0x0100A8C0, "/", null)]
        [CompoundCase("InvalidPath", 2, 443, "www.xbox.com", 0, 0, @"/Woot! o/-< o|-< o\-<", null)]
        //[CompoundCase("InvalidAppliesTo", 2, 443, "www.xbox.com", 0, 0, "/", ":( What is this!!!")]
        public class InvalidEndpoint : TestNode
        {
            private NetworkAuthHelper helper;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());

                // Generate 10 endpoints
                helper.GenerateEndpoints(10, 1);

                // Then add one invalid one
                NetworkAuthorizationListItem endpoint = new NetworkAuthorizationListItem
                {
                    protocol = Convert.ToUInt16(MyValues[0]),
                    port = (UInt16)(Int32)MyValues[1],
                    server = (String)MyValues[2],
                    fromIP = (UInt32)(Int32)MyValues[3],
                    toIP = (UInt32)(Int32)MyValues[4],
                    path = (String)MyValues[5],
                    appliesTo = MyValues[6] == null ? helper.Endpoints[0].appliesTo : (String)MyValues[6],
                };

                endpoint.serverLen = (UInt16)endpoint.server.Length;
                endpoint.pathLen = (UInt16)endpoint.path.Length;
                endpoint.appliesToLen = (UInt16)endpoint.appliesTo.Length;

                helper.AddEndpoint(endpoint);

                try
                {
                    NetworkAuth.ReloadNetworkAuthorizationList();
                }
                // The invalid item may very well cause a load error, but we
                // want to ignore it, to see if the rest of the list loads
                catch { }
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Checks that an ip endpoint works properly")]
        [Owner("BenRan"), TestFrequency("Daily"), TestCasePriority(2)]
        [CompoundCase("SingleAddress", 0x0100A8C0, 0x0100A8C0)]
        [CompoundCase("ShortRange", 0x0100A8C0, 0x0200A8C0)]
        [CompoundCase("FullSubnet", 0xFF00A8C0, 0x0000A8C0)]
        [CompoundCase("LargeRange", 0x0000000A, 0x00000014)]
        [CompoundCase("AllAddresses", 0x00000000, 0xFFFFFFFF)]
        public class IPAddressEndpoint : TestNode
        {
            private NetworkAuthHelper helper;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());
                helper.DumpLists = true;

                // Generate 1 endpoint
                helper.GenerateEndpoints(1, 1);

                // Generate an ip endpoint
                NetworkAuthorizationListItem endpoint = new NetworkAuthorizationListItem
                {
                    protocol = 0x01, // HTTP
                    port = 80,
                    server = "",
                    serverLen = 0,
                    fromIP = Convert.ToUInt32(MyValues[0]),
                    toIP = Convert.ToUInt32(MyValues[1]),
                    path = "/",
                    pathLen = 1,
                    appliesTo = helper.Endpoints[0].appliesTo,
                    appliesToLen = helper.Endpoints[0].appliesToLen,
                };

                helper.AddEndpoint(endpoint);

                try
                {
                    NetworkAuth.ReloadNetworkAuthorizationList();
                }
                // The invalid item may very well cause a load error, but we
                // want to ignore it, to see if the rest of the list loads
                catch { }
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }

        [TestCase, Description("Verifies the ordering of the return results")]
        public class EndpointOrdering : TestNode
        {
            private NetworkAuthHelper helper;

            protected override void EditInstances(ref List<CompoundCaseAttribute> instances)
            {
                var titleIds = new List<UInt32> {
                    0xFFFE07D1,
                    0xFFFF07D4,
                    0xFFFFDC01,
                    0xFFFFDC23,
                    0xFFFFDC48,
                    0x304807D1,
                    0x304E07D1,
                    0x305007D1,
                    0x305507D2,
                    0x314107D1,
                    0x325A07D1,
                    0x333207D1,
                    0x333707D1,
                    0x345007D0,
                    0x345007D3,
                    0x345007DB,
                    0x345007DD,
                    0x345007DE,
                    0x345907D0,
                    0x345907E5,
                    0x353507D1,
                    0x355407D1,
                    0x383607D1,
                    0x384B07D1,
                    0x394707D1,
                    0x395007D1,
                    0x415608B6,
                    0x423607D1,
                    0x423707D1,
                    0x423907D1,
                    0x42560804,
                    0x4256080D,
                    0x443007D2,
                    0x443407D1,
                    0x444607D1,
                    0x454107D5,
                    0x463707D1,
                    0x464D07D1,
                    0x465807D1,
                    0x473007D1,
                    0x473407D1,
                    0x475907D1,
                    0x475A07D1,
                    0x483907D1,
                    0x484707D1,
                    0x4B5A07D1,
                    0x4C3907D1,
                    0x4D4807D2,
                    0x4D5309CD,
                    0x4D5309DA,
                    0x4D5309E4,
                    0x4D5309F4,
                    0x4E4F07D1,
                    0x4E5707D1,
                    0x524A07D1,
                    0x534C07D2,
                    0x544807D1,
                    0x544A07D1,
                    0x54510897,
                    0x545707D1,
                    0x563107D1,
                    0x563807D1,
                    0x574307D1,
                    0x583207D1,
                    0x583307D1,
                    0x58480811,
                    0x5848085B,
                    0x58480869,
                    0x594C07D1,
                    0x594D07D2,
                    0x594D07D4,
                    0x594D07D5,
                    0x594D07D6,
                    0x594D07D8,
                    0x594D07D9,
                    0x594D07DA,
                    0x594D07DB,
                };

                foreach (var titleId in titleIds)
                {
                    instances.Add(new CompoundCaseAttribute(String.Format("0x{0:X8}", titleId), titleId));
                }
            }

            public override void PreRun()
            {
                helper = NetworkAuthHelper.FromTitleId((UInt32)MyValues[0]);
                helper.DumpLists = true;
            }

            public override void Run()
            {
                if (helper.Endpoints.Count == 0)
                {
                    throw new DidNotExecuteException("There are no endpoints configured for this title, so we won't bother testing it.");
                }

                helper.Execute();
            }

            public override void PostRun()
            {
                // Don't bother disposing because we didn't create
                // anything for this helper
                //helper.Dispose();
            }
        }

        [TestCase(185096, BugDatabase="ISSAll"), Description("Verify that duplicate non-expired endpoints aren't returned in the result")]
        public class DuplicateEndpoint : TestNode
        {
            private NetworkAuthHelper helper;

            public override void PreRun()
            {
                helper = new NetworkAuthHelper((UInt32)RandomEx.GlobalRandGen.Next());
                helper.DumpLists = true;

                // Generate 1 endpoint
                helper.GenerateEndpoints(1, 1);

                // Then prop it again
                NetworkAuth.PropEndpoint(helper.TitleId, helper.Endpoints[0]);

                try
                {
                    NetworkAuth.ReloadNetworkAuthorizationList();
                }
                // The invalid item may very well cause a load error, but we
                // want to ignore it, to see if the rest of the list loads
                catch { }
            }

            public override void Run()
            {
                helper.Execute();
            }

            public override void PostRun()
            {
                helper.Dispose();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\fd\lspapp.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Diagnostics;
using System.IO;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.lsp;
using xonline.common.health;

[assembly: XomIisInstallerAttribute( Interface.lspfd )]
[assembly: XomIisInstallerAttribute( Interface.lspfd_int )]
[assembly: ConfigAttribute(Component.lspfd)]
[assembly: XomAreaDefinition(XomAreaName.log)]


namespace xonline.server.lsp.fd
{
    // ----------------------------------------------------------------------------------
    // Custom healthcheck block. This implements custom logic for checking the health of 
    // the LSPFD. It should check *only* LSPFD things -- anything common should be put 
    // into its own block and stored in \private\common\health\dll\.
    // ----------------------------------------------------------------------------------

    public class LspfdHealthcheck : IHealthBlock
    {
        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager  blockManager,
            NameValueCollection blockParams,
            HealthReport        report)
        {
            LspfdHealthcheckReport myReport = new LspfdHealthcheckReport();
            report.ExtendedReport = myReport;

            FastFailInternal.FFState ffstate = LspLib.FastFailState;
        
            myReport.CacheEntries = LspLib.CacheEntries;
            myReport.FastFailState = ffstate.ToString();

            if (ffstate != FastFailInternal.FFState.Ok)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
            }
            else
            {
                report.HealthStatus = HealthStatusEnum.Green;
            }
        }
    }

    // ----------------------------------------------------------------------------------
    // Custom healthcheck report for the LspfdHealthcheck block.
    // ----------------------------------------------------------------------------------

    public class LspfdHealthcheckReport : IExtendedHealthReport
    {
        public int CacheEntries;
        public string FastFailState;
    }



    public class LspApp : FrontEndApp
    {
        private static volatile bool _DatabaseCachingEnabled;

        public static bool DatabaseCachingEnabled
        {
            // in LspApp
            get { return _DatabaseCachingEnabled; }
            set { _DatabaseCachingEnabled = value; }
        }

        // ---------------------------------------------------------------------
        // Application_Start
        // ---------------------------------------------------------------------
        protected override void OnApplicationStart()
        {
            // Tell XMgmt that we want our handler called for control requests
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(LspApp_OnControlRequest);

            // Load settings
            DatabaseCachingEnabled = Config.GetBoolSetting(Setting.lspfd_databaseCachingEnabled);

            // Register for notification of t_interface_bucket changes and setting changes
            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(OnInterfaceBucketChange);
            Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);
        }

        private const string c_HelpText = @"
LSPFD help:
  enumcacheflush : Remove all entries from the Enumerate cache
  status         : Display the status of the Enumerate cache
";

        // ---------------------------------------------------------------------
        // OnControlRequest - called by XMgmt when a control request is sent
        // ---------------------------------------------------------------------
        public static void LspApp_OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string str = null;

            try
            {
                switch(args.Command.ToLower())
                {

                case "help":
                    str = c_HelpText;
                    break;

                case "enumcacheflush":
                    LspLib.ResetCache();
                    str = "All entries removed from the Enumerate cache.";
                    break;

                case "status":
                    str = LspLib.GetStatus();
                    break;

                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage(
                    "Error: " + e.ToString() + "\r\n\r\n",
                    args.RequestId
                    );
            }

            if (str != null)
            {
                XomControlConnection.SendMessage(
                    str + "\r\n\r\n",
                    args.RequestId
                    );
                args.Handled = true;
            }
        
        }


        // ---------------------------------------------------------------------
        // OnInterfaceBucketChange
        // ---------------------------------------------------------------------
        public void OnInterfaceBucketChange(object sender, InterfaceBucketChangeEventArgs args)
        {
            // Doesn't need to do anything. Its presence will tell Config that we accept 
            // the change, and that's all we need to do. Yay.
        }

        // ---------------------------------------------------------------------
        // OnSettingChange
        // ---------------------------------------------------------------------
        public void OnSettingChange(object sender, SettingChangeEventArgs args)
        {
            if (args.Setting == Setting.lspfd_databaseCachingEnabled)
            {
                string val = args.ValueNew.ToLower();
                DatabaseCachingEnabled = (val == "1" || val == "yes" || val == "true" || val == "on");
            }
            // lspfd_fastFail* settings are consumed in FastFail automatically
        }
            
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\fd\advertise.cs ===
//
// advertise.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//

using System;
using System.Web;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.lsp;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.sqlclient;

namespace xonline.server.lsp.fd
{
    // -----------------------------------------------------------------------
    // Advertise
    // Request handler
    // Called by a SgLsp to advertise its presence to consoles.
    // -----------------------------------------------------------------------
    public class Advertise : IHttpHandler
    {
        public void ProcessRequest(HttpContext ctx)
        {
            LspAdvertiseRequest req = new LspAdvertiseRequest();
            bool ok = false;

            try
            {
                string viface = CallSource.Check(
                    VirtualInterface.xqry_int);

                req.ReadStream(ctx.Request.InputStream);

                LspLib.Update(
                    req.titleId,
                    req.ipSgLsp,
                    req.ttlInSeconds,
                    req.flags,
                    req.userData,
                    req.xnkid,
                    req.xnkey);

                ok = true;
            }
            finally
            {
                string logLine = string.Join("|", new string[] {
                    "LSPADVER2",
                    "0x"+req.titleId.ToString("x8"),
                    FormatIpH(req.ipSgLsp),
                    req.ttlInSeconds.ToString(),
                    "0x"+req.flags.ToString("x8"),
                    req.userData != null ? req.userData : null,
                    FrontEndApp.MillisecondsElapsed.ToString(),
                    ok ? "0" : "1" });

                Xom.Log(XomAreaName.log, logLine);
            }
        }

        public bool IsReusable
        {
            get { return true; }
        }

        private static string FormatIpH(UInt32 dwIp)
        {
            // format ip address in network byte order
            return String.Format("{0}.{1}.{2}.{3}",
                                 (byte)((dwIp >> 24) & 0xFF),
                                 (byte)((dwIp >> 16) & 0xFF),
                                 (byte)((dwIp >> 8 ) & 0xFF),
                                 (byte)((dwIp      ) & 0xFF));
        }

    }
  
    // No unique perf counters, see FEAPP.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\listener.cpp ===
// listener.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.

#include "lhdp.h"

#define MAX_WHITE_LIST_SIZE 512 

SOCKET  g_sockListen;
IN_ADDR g_aWhiteListIps[MAX_WHITE_LIST_SIZE];   // list of IPs allowed to connect
DWORD   g_cWhiteListIps;                        // number of IPs in g_aWhiteListIps

// @@@ need a way to have multiple listeners running at once for tests

BOOL ListenerInit(CConfig* pCfg)
{
    HRESULT     hr;
    DWORD       err;
    DWORD       dwIp;
    DWORD       dwPort;
    WORD        wPort;
    TLocalStr<64000>   whiteList;
    DWORD       dwAllowEverybody = 0;

    //
    // Read in configuration
    //

    if(!pCfg->GetIp("Bindings", "Ip", (UINT32*)&dwIp))
    {
        NtEventLog(EVENT_CONFIG_ERROR, 
                   "The setting 'Ip' on section [Bindings] is missing or invalid");
        hr = E_INVALIDARG;
        goto error;
    }

    if(!pCfg->GetUInt32("Bindings", "Port", (UINT32*)&dwPort))
    {
        NtEventLog(EVENT_CONFIG_ERROR, 
                   "The setting 'Port' on section [Bindings] is missing or invalid");
        hr = E_INVALIDARG;
        goto error;
    }

    if (dwPort >= 0xFFFF)
    {
        NtEventLog(EVENT_CONFIG_ERROR, CSmallStr().Format(
                   "Port must be less than 65535 (was %u)", 
                   dwPort).cstr());
        hr = E_INVALIDARG;
        goto error;
    }
    wPort = htons((WORD)dwPort);

    NtEventLog(EVENT_CONFIG_INFO, CSmallStr().Format(
               "Lsp-Proxy will listen on: %s", 
               CStrUtil().FormatIpPortN(dwIp, wPort)).cstr());

    if(pCfg->GetUInt32("Allow", "Everybody", (UINT32*)&dwAllowEverybody) && 
       dwAllowEverybody == 1)
    {
        g_cWhiteListIps = 0;
        whiteList.CopyFrom("Everybody");
    }
    else
    {
        //
        // Read white list
        //
        
        g_cWhiteListIps = 0;
        for(int i=0; i < ARRAY_SIZE(g_aWhiteListIps); i++)
        {
            //
            // Read Ip # i, starting at 1 (not 0)
            //
            
            if(pCfg->GetIp("Allow", CTinyStr().Format("Ip%u", i+1).cstr(), 
                           (UINT32*)&g_aWhiteListIps[g_cWhiteListIps]))
            {
                // 
                // Add ip to pretty formatted string
                //
                
                whiteList.Format("%s ", CStrUtil().FormatIpN(
                        g_aWhiteListIps[g_cWhiteListIps].s_addr));
                g_cWhiteListIps++;
            }
        }

        if(0 == g_cWhiteListIps)
        {
            NtEventLog(EVENT_CONFIG_ERROR,
                       "At least one Ip must be specified in the [Allow] section of lsphttpd.ini.");
            goto error;
        }
        else if(g_cWhiteListIps >= ARRAY_SIZE(g_aWhiteListIps))
        {
            NtEventLog(EVENT_CONFIG_WARNING, CSmallStr().Format(
                       "Warning: only %u entries are permitted in the [Allow] section. Additional entries will be ignored.",
                       ARRAY_SIZE(g_aWhiteListIps)).cstr());
        }
    }

    NtEventLog(EVENT_CONFIG_INFO, TLocalStr<64000>().Format(
            "The following %u addresses (maximum %u) will be allowed to connect: %s", 
            g_cWhiteListIps,
            ARRAY_SIZE(g_aWhiteListIps),
            whiteList.cstr()).cstr());

    //
    // Set up the listening socket
    //

    Assert(g_sockListen == NULL);
    
    WSADATA wsaData;

    int rc = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
    if( 0 != rc )
    {
        err = WSAGetLastError();
        hr  = HRESULT_FROM_WIN32(err);
        NtEventLog(EVENT_INIT_ERROR, CSmallStr().Format(
                   "WSAStartup failed, hr = %X", hr).cstr());
        return(FALSE);
    }

    g_sockListen = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
        
    if (g_sockListen == INVALID_SOCKET)
    {
        g_sockListen = NULL;
        err          = WSAGetLastError();
        hr           = HRESULT_FROM_WIN32(err);
        NtEventLog(EVENT_INIT_ERROR, CSmallStr().Format(
                   "WSASocket failed, hr = %X", hr).cstr());
        goto error;
    }

    sockaddr_in sin;
    memset(&sin, 0, sizeof(sin));
    sin.sin_family      = AF_INET;
    sin.sin_port        = wPort;
    sin.sin_addr.s_addr = dwIp;

    rc = bind(g_sockListen, (sockaddr *)&sin, sizeof(sin));
    if( 0 != rc )
    {
        err = WSAGetLastError();
        hr  = HRESULT_FROM_WIN32(err);
        NtEventLog(EVENT_INIT_ERROR, CSmallStr().Format(
                   "bind failed, hr = 0x%X. Please verify the [Bindings] section of lsphttpd.ini.", hr).cstr());
        goto error;
    }

    rc = listen(g_sockListen, SOMAXCONN);
    if( 0 != rc )
    {
        err = WSAGetLastError();
        hr  = HRESULT_FROM_WIN32(err);
        NtEventLog(EVENT_INIT_ERROR, CSmallStr().Format(
                   "listen failed, hr = %X", hr).cstr());
        goto error;
    }

    return(TRUE);

error:
    ListenerTerm();
    return(FALSE);
}

void ListenerTerm()
{
    if (g_sockListen != NULL)
    {
        closesocket(g_sockListen);
        g_sockListen = NULL;
    }

    WSACleanup();
}

// ---------------------------------------------------------------------------------------
// ListenerAcceptFilter
// Called by WSAAccept to allow/deny connections based on the configured white-list.
// ---------------------------------------------------------------------------------------
int CALLBACK ListenerAcceptFilter(
  IN LPWSABUF lpCallerId,
  IN LPWSABUF lpCallerData,
  IN OUT LPQOS lpSQOS,
  IN OUT LPQOS lpGQOS,
  IN LPWSABUF lpCalleeId,
  OUT LPWSABUF lpCalleeData,
  OUT GROUP FAR *g,
  IN DWORD_PTR dwCallbackData
)
{
    bool ok = false;
    
    if(!g_cWhiteListIps)
    {
        // white list is off
        ok = true;
        goto Exit;
    }

    if(!lpCallerId ||
       !lpCallerId->buf ||
       lpCallerId->len != sizeof(SOCKADDR_IN))
    {
        NtEventLog(EVENT_UNEXPECTED_ERROR,
                   "ListenerAcceptFilter received an invalid lpCallerId");
        goto Exit;
    }

    SOCKADDR_IN* psin;
    psin = (SOCKADDR_IN*)lpCallerId->buf;

    if(psin->sin_family != AF_INET)
    {
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "ListenerAcceptFilter received lpCallerId with invalid family %u",
                   psin->sin_family).cstr());
        goto Exit;
    }

    //
    // check if address is inside white-list
    //

    for(DWORD i=0; i < g_cWhiteListIps; i++)
    {
        if(psin->sin_addr.s_addr == g_aWhiteListIps[i].s_addr)
        {
            ok = true;
            break;
        }
    }

    if(!ok)
    {
        NtEventLog(EVENT_SERVER_NOT_ALLOWED, CSmallStr().Format(
                "Caller-Address: %s", 
                CStrUtil().FormatIpN(psin->sin_addr.s_addr)).cstr());
    }

Exit:

    return ok ? CF_ACCEPT : CF_REJECT;
}

BOOL ListenerAcceptRequest(ListenerContext * pctx)
{
    HRESULT hr      = S_OK;
    DWORD   err     = 0;
    pctx->cbRequest = 0;
    pctx->s         = WSAAccept(g_sockListen, NULL, NULL, ListenerAcceptFilter, 0);

    if (pctx->s == INVALID_SOCKET)
    {
        pctx->s = NULL;
        err     = WSAGetLastError();
        hr      = HRESULT_FROM_WIN32(err);

        if (!g_fShutdown && err != WSAECONNREFUSED)
        {
            NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                       "WSAAccept failed, hr = %X", hr).cstr());
        }
    }

    return(SUCCEEDED(hr));
}

BOOL ListenerRecv(ListenerContext * pctx)
{
    HRESULT hr = S_OK;
    INT     cb = sizeof(pctx->abRequest) - pctx->cbRequest;
    DWORD   err;

    cb = recv(pctx->s, (char *)pctx->abRequest + pctx->cbRequest, cb, 0);

    if (cb == SOCKET_ERROR)
    {
        err = WSAGetLastError();
        hr  = HRESULT_FROM_WIN32(err);
    }
    else
    {
        pctx->cbRequest += cb;
    }

    return(SUCCEEDED(hr));
}

BOOL ListenerSend(ListenerContext * pctx, UINT cb, BYTE * pb)
{
    DWORD   err;
    HRESULT hr = S_OK;
    INT     rc = send(pctx->s, (char *)pb, cb, 0);

    if (cb == SOCKET_ERROR)
    {
        err = WSAGetLastError();
        hr  = HRESULT_FROM_WIN32(err);
    }
    
    return(SUCCEEDED(hr));
}

void ListenerClose(ListenerContext * pctx)
{
    // @@@ should be interlocked in case async callbacks come from winhttp
    if (pctx->s != NULL)
    {
        // Important to use closesocket() and not CloseHandle(). You may leak a lot of 
        // handles if you don't. 
        closesocket(pctx->s);
        pctx->s = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\liveinfo\test\NetworkAuth\NetworkAuthHelpers.cs ===
using System;
using System.Linq;
using System.Collections;
using ServerTestFramework.LiveService;
using ServerTestFramework.Database;
using System.Data.SqlClient;
using System.Data;
using xonline.common.protocol;
using System.Collections.Generic;
using ServerTestFramework.LiveService.LiveInfo;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Text;
using xonline.common.sql.webstore;
using xonline.common.config;
using System.Net;

namespace LiveInfo.NetworkAuthorization
{
    public class NetworkAuth
    {
        private static Npdb npdb = null;
        public static Npdb Npdb
        {
            get
            {                
                if (npdb == null)
                {
                    npdb = new Npdb();
                    npdb.ConnectToServer();
                }

                return npdb;
            }
        }

        public static WSClient SecDB
        {
            get
            {
                return new WSClient(ConfigUtil.SecDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            }
        }

        public static readonly String BaseAppliesToUri = "http://test.xbox.com";

        public static Guid GenerateBusinessPartner(UInt32 titleId)
        {
            Guid businessPartnerId = Guid.NewGuid();
            String cert = "MIIF6TCCBNGgAwIBAgIKI5IpWAAFAAELsjANBgkqhkiG9w0BAQUFADCBizETMBEGCgmSJomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1pY3Jvc29mdDEUMBIGCgmSJomT8ixkARkWBGNvcnAxFzAVBgoJkiaJk/IsZAEZFgdyZWRtb25kMSowKAYDVQQDEyFNaWNyb3NvZnQgU2VjdXJlIFNlcnZlciBBdXRob3JpdHkwHhcNMDkwMzAyMjAyMzQ3WhcNMTAwMzAyMjAyMzQ3WjBrMQswCQYDVQQGEwJVUzELMAkGA1UECBMCV0ExEDAOBgNVBAcTB1JlZG1vbmQxEjAQBgNVBAoTCU1pY3Jvc29mdDESMBAGA1UECxMJWGJveCBMaXZlMRUwEwYDVQQDEwx3d3cueGJveC5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAI/XKJl0Q73EDc7t0GLR+9KhZDbVo3liZVXqSPsCGHRf/v0DYbc9kOI6ZDQvPJ0ykqZl23ww43kyw2ANuVol2p7EB+GlxlqgnzU6UEt7kwU2Jx+Niq/FQ/WFzpACQ7X//1ecek7G7aFDEFO8FCjikMciaOVDMqzod6nbg4vaqVhLAgMBAAGjggLwMIIC7DALBgNVHQ8EBAMCBLAwRAYJKoZIhvcNAQkPBDcwNTAOBggqhkiG9w0DAgICAIAwDgYIKoZIhvcNAwQCAgCAMAcGBSsOAwIHMAoGCCqGSIb3DQMHMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATAdBgNVHQ4EFgQUDFktSehtvdyvr3edmeAxvdV4RcMwHwYDVR0jBBgwFoAUFFXEOeA9LtFVLkiWsNh+FCIGk7wwggEKBgNVHR8EggEBMIH+MIH7oIH4oIH1hlhodHRwOi8vbXNjcmwubWljcm9zb2Z0LmNvbS9wa2kvbXNjb3JwL2NybC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3JshlZodHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9jcmwvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNybIZBaHR0cDovL2NvcnBwa2kvY3JsL01pY3Jvc29mdCUyMFNlY3VyZSUyMFNlcnZlciUyMEF1dGhvcml0eSg1KS5jcmwwgb8GCCsGAQUFBwEBBIGyMIGvMF4GCCsGAQUFBzAChlJodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL21zY29ycC9NaWNyb3NvZnQlMjBTZWN1cmUlMjBTZXJ2ZXIlMjBBdXRob3JpdHkoNSkuY3J0ME0GCCsGAQUFBzAChkFodHRwOi8vY29ycHBraS9haWEvTWljcm9zb2Z0JTIwU2VjdXJlJTIwU2VydmVyJTIwQXV0aG9yaXR5KDUpLmNydDA/BgkrBgEEAYI3FQcEMjAwBigrBgEEAYI3FQiDz4lNrfIChaGfDIL6yn2B4ft0gU+Dwu2FCI6p0oVjAgFkAgEGMCcGCSsGAQQBgjcVCgQaMBgwCgYIKwYBBQUHAwIwCgYIKwYBBQUHAwEwDQYJKoZIhvcNAQEFBQADggEBADI74KksprLMaSXuRyx0Zh7+bzpTj6qR6Uq/9TyowVI5QaJFTusncHzoYgPzTRj9hQx6ur2gs+bfIxdH9v9sreulBfEcrSag54Q19V0qeiHesMShwyO+L8KHFI/AHpo++JDOKOBnScjGmX5uO6XdwA5+rcSBwM+5WLMORyA2WFbLo/cCScegeWtaJNTe5SNIjUyd6kEUoe/D7er55PRRTjhcvg/gTPUPsh+/pE6AmP/hZXYAAmHItG+IDKDdw6T45uXR+b+dMePV1IS0vZ9RzHhgZYk85I9NkDo3ClH65S1guaO5m83YGKi4ziqTYtVWNQ8YtVf32z/agCCMCy4B0MA=";
            String tokenType = "urn:oasis:names:tc:SAML:2.0:assertion";
            String appliesToUri = String.Format("{0}/{1}", BaseAppliesToUri, businessPartnerId);
            String claimUri = String.Format("{0}/NetworkAuthTestClaim", appliesToUri);

            StringBuilder sql = new StringBuilder();
            sql.AppendFormat("insert into t_sts_business_partner (uid_business_partner_id, vc_friendly_name, vc_anonymizing_salt, b_private) values('{0}', 'TestBusinessPartner_{0}', '', '')\n", businessPartnerId);
            sql.AppendFormat("insert into t_sts_business_partner_connection_info (uid_business_partner_id, vc_friendly_name, vc_partner_sg_cert) values ('{0}', 'BusinessPartnerConnectionInfo_{0}', '{1}')\n", businessPartnerId, cert);
            sql.AppendFormat("insert into t_sts_claim (vc_claim_uri, vc_friendly_title, vc_friendly_description, b_encrypted, b_private, b_anonymized, vc_value_type) values ('{0}', 'NetworkAuthTestClaim', 'TestClaim Used by NetworkAuth Tests', 0, 0, 0, '')\n", claimUri);
            sql.AppendFormat("insert into t_sts_applies_to (vc_applies_to_uri, vc_applies_to_cert, t_validity_interval, uid_business_partner_id, vc_token_type_uri) values ('{0}', '{1}', '04:00', '{2}', '{3}')\n", appliesToUri, cert, businessPartnerId, tokenType);
            sql.AppendFormat("insert into t_sts_applies_to_claim (vc_applies_to_uri, vc_claim_uri, b_required) values ('{0}', '{1}', 0)\n", appliesToUri, claimUri);

            using (var client = SecDB)
            {
                client.CommandSql = sql.ToString();
                client.ExecuteNonQuery();
            }

            return businessPartnerId;
        }

        public static List<NetworkAuthorizationListItem> GenerateEndpoints(UInt32 titleId, UInt32 endpointCount)
        {
            return GenerateEndpoints(titleId, endpointCount, 1, 0);
        }

        public static List<NetworkAuthorizationListItem> GenerateEndpoints(UInt32 titleId, UInt32 endpointCount, UInt32 businessPartnerCount)
        {
            return GenerateEndpoints(titleId, endpointCount, businessPartnerCount, 0);
        }

        public static List<NetworkAuthorizationListItem> GenerateEndpoints(UInt32 titleId, UInt32 endpointCount, UInt32 businessPartnerCount, Int32 endpointLength)
        {
            List<NetworkAuthorizationListItem> endpoints = new List<NetworkAuthorizationListItem>();

            for (int i = 0; i < businessPartnerCount; i++)
            {
                Guid businessPartnerId = GenerateBusinessPartner(titleId);

                if (i == 0)
                {
                    // Generate a business partner title relationship
                    StringBuilder sql = new StringBuilder();
                    sql.AppendFormat("insert into t_sts_business_partner_title (uid_business_partner_id, i_title_id) values ('{0}', 0x{1:X8})\n", businessPartnerId, titleId);

                    using (var client = SecDB)
                    {
                        client.CommandSql = sql.ToString();
                        client.ExecuteNonQuery();
                    }
                }

                for (int j = 0; j < endpointCount; j++)
                {
                    endpoints.Add(GenerateEndpoint(titleId, businessPartnerId, endpointLength));
                }
            }

            return endpoints;
        }

        public static NetworkAuthorizationListItem GenerateEndpoint(UInt32 titleId, Guid businessPartnerId, Int32 length)
        {
            return GenerateEndpoint(titleId, businessPartnerId, length, BaseAppliesToUri + "/" + businessPartnerId.ToString());
        }

        public static NetworkAuthorizationListItem GenerateEndpoint(UInt32 titleId, Guid businessPartnerId, Int32 length, String appliesTo)
        {
            Guid endpointId = Guid.NewGuid();
            String server = "www.xbox.com";
            UInt16 port = 80;
            String path = String.Format("/networkauthtest/{0}/{1}", businessPartnerId, endpointId);

            // This is not really accurate right now, each of the strings in the response has
            // different lengths for some reason (some are 200, some 255), so this is really 
            // just a random value right now.  I should update this eventually to be something
            // reasonable
            if (length != 0)
            {
                Int32 remainingBytes = length - server.Length - path.Length - appliesTo.Length;
                if (remainingBytes > 0)
                {
                    path += RandomEx.GlobalRandGen.GenerateRandomString("/", remainingBytes);
                }
            }

            NetworkAuthorizationListItem endpoint = new NetworkAuthorizationListItem
            {
                protocol = 1, // http
                port = port,
                server = server,
                serverLen = (ushort)server.Length,
                path = path,
                pathLen = (ushort)path.Length,
                appliesTo = appliesTo,
                appliesToLen = (ushort)appliesTo.Length,
            };

            PropEndpoint(titleId, endpoint, endpointId);

            return endpoint;
        }

        public static void PropEndpoint(UInt32 titleId, NetworkAuthorizationListItem endpoint)
        {
            PropEndpoint(titleId, endpoint, Guid.NewGuid());
        }

        public static void PropEndpoint(UInt32 titleId, NetworkAuthorizationListItem endpoint, Guid endpointId)
        {
            String protocol;
            switch (endpoint.protocol)
            {
                case 1:
                    protocol = "http";
                    break;
                case 2:
                    protocol = "https";
                    break;
                default:
                    protocol = endpoint.protocol.ToString();
                    break;
            }

            String appliesToString = endpoint.appliesTo == null ? "null" : "'" + endpoint.appliesTo + "'";
            String sql = String.Format(@"insert into t_sts_title_endpoint (uid_endpoint_id, i_title_id, vc_protocol, 
                                             i_port, i_from_ip, i_to_ip, vc_hostname, vc_path, vc_applies_to_uri) 
                                             values('{0}', 0x{1:X8}, '{2}', {3}, 0x{4:X}, 0x{5:X}, '{6}', '{7}', {8})",
                                       endpointId, titleId, protocol, endpoint.port, endpoint.fromIP,
                                       endpoint.toIP, endpoint.server, endpoint.path, appliesToString);

            using (var client = SecDB)
            {
                client.CommandSql = sql;
                client.ExecuteNonQuery();
            }
        }

        public static List<NetworkAuthorizationListItem> ReadEndpoints(UInt32 titleId)
        {
            List<NetworkAuthorizationListItem> endpoints = new List<NetworkAuthorizationListItem>();

            using (var client = SecDB)
            {
                client.StoredProc = "p_sts_title_endpoint_get_by_title";
                client.AddParameter("i_title_id", titleId);

                //client.CommandSql = String.Format(@"select * from t_sts_title_endpoint where i_title_id = 0x{0:X}", titleId);
                using (var reader = client.Execute())
                {
                    if (reader.HasRows)
                    {
                        while (reader.Read())
                        {
                            var ep = new NetworkAuthorizationListItem
                            {
                                protocol = GetProtocolId((String)reader["vc_protocol"]),
                                port = (ushort)(int)reader["i_port"],
                                fromIP = (uint)(int)reader["i_from_ip"],
                                toIP = (uint)(int)reader["i_to_ip"],
                                server = (String)reader["vc_hostname"],
                                path = (String)reader["vc_path"],
                                appliesTo = WSClient.GetNullableString(reader, "vc_applies_to_uri"),
                            };

                            ep.serverLen = (ushort)(ep.server != null ? ep.server.Length : 0);
                            ep.pathLen = (ushort)(ep.path != null ? ep.path.Length : 0);
                            ep.appliesToLen = (ushort)(ep.appliesTo!= null ? ep.appliesTo.Length : 0);

                            endpoints.Add(ep);
                        }
                    }
                }
            }

            return endpoints;
        }

        public static UInt16 GetProtocolId(String protocol)
        {
            switch (protocol.ToLower())
            {
                case "http":
                    return 1;
                case "https":
                    return 2;
                default:
                    return 3;
            }
        }

        public static void ClearBusinessPartners()
        {
            ClearBusinessPartners("TestBusinessPartner");
        }

        public static void ClearBusinessPartners(String businessPartnerPrefix)
        {
            String sql = String.Format(@"
                declare @bp_prefix varchar(100) = '{0}%'

                -- Delete all the endpoints
                delete from t_sts_title_endpoint where vc_applies_to_uri in (
	                select vc_applies_to_uri from t_sts_applies_to at
		                inner join t_sts_business_partner bp on at.uid_business_partner_id = bp.uid_business_partner_id
		                where bp.vc_friendly_name like @bp_prefix
	                )

                -- Delete all the applies to claim mappings
                delete from t_sts_applies_to_claim
	                where vc_claim_uri like '%/NetworkAuthTestClaim'
                	
                -- Delete all the applies to values
                delete from t_sts_applies_to 
	                where uid_business_partner_id in (
		                select uid_business_partner_id from t_sts_business_partner
		                where vc_friendly_name like @bp_prefix
	                )

                -- Delete all the claims
                delete from t_sts_claim
	                where vc_friendly_title like 'NetworkAuthTestClaim%'

                -- Delete all the business partner title mappings
                delete from t_sts_business_partner_title
	                where uid_business_partner_id in (
		                select uid_business_partner_id from t_sts_business_partner
		                where vc_friendly_name like @bp_prefix
	                )

                -- Delete all the business partner title mappings
                delete from t_sts_business_partner_connection_info
	                where uid_business_partner_id in (
		                select uid_business_partner_id from t_sts_business_partner
		                where vc_friendly_name like @bp_prefix
	                )
                	
                -- Delete all the business partners
                delete from t_sts_business_partner
	                where vc_friendly_name like @bp_prefix
            ", businessPartnerPrefix);

            try
            {
                using (var client = SecDB)
                {
                    client.CommandSql = sql;
                    client.ExecuteNonQuery();
                }
            }
            catch(SqlException se)
            {
                Global.RO.Warn("There was a problem trying to clean up test data");
                Global.RO.Warn(se.ToString());
            }
        }

        internal static void ClearEndpoints(IEnumerable<NetworkAuthorizationListItem> endpoints)
        {
            if (endpoints.Count() == 0)
            {
                return;
            }

            // Throw all the deletes into a single command and perform them all at the same time
            StringBuilder sql = new StringBuilder();

            // Remove all the endpoints
            foreach (var endpoint in endpoints)
            {
                sql.AppendFormat("delete from t_applies_to where i_protocol = {0} and vc_server = '{1}' and vc_path = '{2}' and i_protocol = '{3}';", 
                    endpoint.protocol, endpoint.server, endpoint.path, endpoint.port);
            }

            // Now remove all of the associated applies tos
            foreach (var appliesTo in endpoints.Select(e => e.appliesTo).Distinct())
            {
                sql.AppendFormat("delete from t_applies_to where vc_applies_to = '{0}';", appliesTo);
            }

            Npdb.ExecuteScalar(sql.ToString());
        }

        public static void ReloadNetworkAuthorizationList()
        {
            foreach (var resp in ManagementConsole.ExecuteOnAll(Interface.liveinfo, "e :liveinfo reloadnacl"))
            {
                // If the component isn't loaded yet, we'll get some benign failures we can ignore
                if ((!resp.Result && !resp.Response.Contains("Process/Component not found")) || 
                    resp.Response.Contains("Error reloading network authorization list"))
                {
                    throw new UnexpectedTestResultException("Failed to reload network authorization list on LiveInfo at " + resp.EndPoint);
                }
            }
        }
    }

    public class NetworkAuthHelper : IDisposable
    {
        private Boolean isDisposed = false;
        public Boolean IsDisposed { get { return isDisposed; } }

        public Boolean DumpLists { get; set; }

        public XRLGetNetworkAuthorizationList Xrl { get; set; }
        public List<NetworkAuthorizationListItem> Endpoints { get; set; }

        public UInt32 TitleId { get { return Xrl.TitleId; } set { Xrl.TitleId = value; } }

        public static NetworkAuthHelper FromTitleId(UInt32 titleId)
        {
            NetworkAuthHelper helper = new NetworkAuthHelper(titleId);
            helper.Endpoints = NetworkAuth.ReadEndpoints(titleId);

            return helper;
        }

        public NetworkAuthHelper()
        {
            Xrl = new XRLGetNetworkAuthorizationList();
        }

        public NetworkAuthHelper(UInt32 titleId)
        {
            Xrl = new XRLGetNetworkAuthorizationList(titleId);
        }

        public void Execute()
        {
            Execute(HResult.S_OK);
        }

        public void Execute(Boolean verifyResponse)
        {
            Execute(HResult.S_OK, verifyResponse);
        }

        public void Execute(HResult expectedResult)
        {
            Execute(expectedResult, true);
        }

        public void Execute(HResult expectedResult, Boolean verifyResponse)
        {
            if (!Xrl.Execute())
            {
                // If we expect success
                if (expectedResult == HResult.S_OK)
                {
                    throw new UnexpectedTestResultException("GetNetworkAuthorizationList request failed: " + Xrl.GetDumpString());
                }

                // If we expect failure, validate it has the correct result code
                ValueCheck.TestHR("GetNetworkAuthorizationList XErr", expectedResult, Xrl.XErr);
            }
            else
            {
                if (expectedResult != HResult.S_OK)
                {
                    throw new UnexpectedTestResultException("GetNetworkAuthorizationList request succeded unexpectedly");
                }

                this.Endpoints.Sort(NetworkAuthExtensions.Compare);

                if (verifyResponse)
                {
                    try
                    {
                        VerifyResponse(Xrl.Response);
                    }
                    catch
                    {
                        if (DumpLists)
                        {
                            Global.RO.Debug("Expected List");
                            DumpNacl(this.Endpoints);
                            Global.RO.Debug("Actual List");
                            DumpNacl(this.Xrl.Response.authorizationList);
                        }
                        throw;
                    }
                }
            }
        }

        private void DumpNacl(IEnumerable<NetworkAuthorizationListItem> networkAuthorizationList)
        {
            foreach (var i in networkAuthorizationList)
            {
                Global.RO.Debug(i.GetDumpString());
            }
        }

        public void VerifyResponse(GetNetworkAuthorizationListResponse response)
        {
            //DateTime expectedValidUntil = DateTime.UtcNow; // + validUntilTime
            //ValueCheck.Test("ValidUntil", expectedValidUntil, response.expiresOn);

            ValueCheck.Test("AuthorizationListCount", Endpoints.Count, response.authorizationListCount);
            ValueCheck.Test("AuthorizationListLength", Endpoints.Count, response.authorizationList.Length);

            // Duplicate the endponits list
            var expectedEndpoints = Endpoints.ToList();

            for (int i = 0; i < Endpoints.Count; i++)
            {
                var expectedEndpoint = expectedEndpoints[i];
                var actualEndpoint = response.authorizationList[i];

                if (!NetworkAuthExtensions.Equals(expectedEndpoint, actualEndpoint))
                {
                    if (expectedEndpoint.serverLen == actualEndpoint.serverLen && expectedEndpoint.serverLen != 0)
                    {
                        // These are functionally identical, so we can ignore this
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Response contained an unexpected endpoint {0}:{1} [{2}] at position {3}",
                                actualEndpoint.GetServerString(),
                                actualEndpoint.port,
                                actualEndpoint.appliesTo,
                                i));
                    }
                }
            }

            /*
            for (int i = 0; i < Endpoints.Count; i++)
            {
                NetworkAuthorizationListItem actualEndpoint = response.authorizationList[i];
                Boolean found = false;

                for (int j = 0; j < expectedEndpoints.Count; j++)
                {
                    NetworkAuthorizationListItem expectedEndpoint = expectedEndpoints[j];
                    if (NetworkAuthExtensions.Equals(expectedEndpoint,actualEndpoint))
                    {
                        expectedEndpoints.Remove(expectedEndpoint);
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    throw new UnexpectedTestResultException(
                        String.Format("Response contained an unexpected endpoint {0}:{1} [{1}]",
                            actualEndpoint.GetServerString(),
                            actualEndpoint.port,
                            actualEndpoint.appliesTo));
                }
            }

            if (expectedEndpoints.Count > 0)
            {
                throw new UnexpectedTestResultException(String.Format("Response missing {0} expected endpoint(s).", expectedEndpoints.Count));
            }
            */
        }

        public void GenerateEndpoints(UInt32 endpointCount)
        {
            this.Endpoints = NetworkAuth.GenerateEndpoints(this.TitleId, endpointCount, 1);
        }

        public void GenerateEndpoints(UInt32 endpointCount, UInt32 businessPartnerCount)
        {
            this.Endpoints = NetworkAuth.GenerateEndpoints(this.TitleId, endpointCount, businessPartnerCount);
        }

        public void AddEndpoint(NetworkAuthorizationListItem endpoint)
        {
            AddEndpoint(endpoint, true);
        }

        public void AddEndpoint(NetworkAuthorizationListItem endpoint, Boolean propEndpoint)
        {
            if (propEndpoint)
            {
                NetworkAuth.PropEndpoint(this.TitleId, endpoint);
            }

            if (this.Endpoints == null)
            {
                this.Endpoints = new List<NetworkAuthorizationListItem>();
            }

            this.Endpoints.Add(endpoint);
        }

        public void Dispose()
        {
            Dispose(true);   
        }

        protected void Dispose(Boolean disposing)
        {
            if (!isDisposed)
            {
                isDisposed = true;

                if (disposing)
                {
                    NetworkAuth.ClearBusinessPartners();
                    //NetworkAuth.ClearEndpoints(this.Endpoints);
                    //NetworkAuth.ClearReliantParties(this.ReliantParties.Select(p => p.reliantpartyid));
                }
            }
        }
    }

    public static class NetworkAuthExtensions
    {
        public static void Verify(this NetworkAuthorizationListItem endpoint, NetworkAuthorizationListItem otherEndpoint)
        {
            ValueCheck.Test("protocol", endpoint.protocol, otherEndpoint.protocol);
            ValueCheck.Test("port", endpoint.port, otherEndpoint.port);
            ValueCheck.Test("serverLen", endpoint.serverLen, otherEndpoint.serverLen);
            ValueCheck.Test("server", endpoint.server, otherEndpoint.server);
            ValueCheck.Test("fromIP", endpoint.fromIP, otherEndpoint.fromIP);
            ValueCheck.Test("toIP", endpoint.toIP, otherEndpoint.toIP);
            ValueCheck.Test("pathLen", endpoint.pathLen, otherEndpoint.pathLen);
            ValueCheck.Test("path", endpoint.path, otherEndpoint.path);
            ValueCheck.Test("appliesToLen", endpoint.appliesToLen, otherEndpoint.appliesToLen);
            ValueCheck.Test("appliesTo", endpoint.appliesTo, otherEndpoint.appliesTo);
        }

        public static Boolean Equals(this NetworkAuthorizationListItem endpoint, NetworkAuthorizationListItem otherEndpoint)
        {
            return endpoint.protocol == otherEndpoint.protocol &&
                   endpoint.port == otherEndpoint.port &&
                   endpoint.serverLen == otherEndpoint.serverLen &&
                   endpoint.server == otherEndpoint.server &&
                   // It doesn't matter which ip we reverse, we just have to reverse one of them
                   endpoint.fromIP == ReverseIPAddress(otherEndpoint.fromIP) && 
                   endpoint.toIP == ReverseIPAddress(otherEndpoint.toIP) &&
                   endpoint.pathLen == otherEndpoint.pathLen &&
                   endpoint.path == otherEndpoint.path &&
                   endpoint.appliesToLen == otherEndpoint.appliesToLen &&
                   // If the length is zero, then we don't check the appliesTo to deal with nulls
                   (endpoint.appliesToLen == 0 || endpoint.appliesTo == otherEndpoint.appliesTo);
        }

        public static Int32 Compare(this NetworkAuthorizationListItem a, NetworkAuthorizationListItem b)
        {
            Int32 compRes = 0;

            // First see if we've got an empty server name
            if (a.serverLen == 0 || b.serverLen == 0)
            {
                // If they are both empty
                if (a.serverLen == b.serverLen)
                {
                    // Then we can sort by the ip addresses
                    if ((compRes = a.fromIP.CompareTo(b.fromIP)) != 0)
                    {
                        return compRes;
                    }
                    else if ((compRes = a.toIP.CompareTo(b.toIP)) != 0)
                    {
                        return compRes;
                    }

                    // If the ip's are the same, then continue with the rest of the comparisons
                }
                else
                {
                    // One of them is empty, that means it has an IP.
                    // Return it before the one with a server name
                    return -b.serverLen.CompareTo(a.serverLen);
                }
            }
            // Otherwise do a real server name sort
            else
            {
                String aBld = a.server.Substring(0, a.server.IndexOf('.'));
                String bBld = b.server.Substring(0, b.server.IndexOf('.'));

                if (aBld == "*" || bBld == "*")
                {
                    if (aBld == bBld)
                    {
                        //if ((compRes = a.server.CompareTo(b.server)) != 0)
                        if ((compRes = a.serverLen.CompareTo(b.serverLen)) != 0)
                        {
                            return -compRes;
                        }
                    }
                    else
                    {
                        return aBld == "*" ? 1 : -1;
                    }
                }
            }

            // If host/ips are equivalent, compare the port
            if ((compRes = a.port.CompareTo(b.port)) != 0)
            {
                return compRes;
            }

            // If ports are the same, check protocol
            if ((compRes = a.protocol.CompareTo(b.protocol)) != 0)
            {
                return compRes;
            }

            // Same host, port, protocol.  Check the path
            if ((compRes = a.path.CompareTo(b.path)) != 0)
            {
                return compRes;
            }

            // They are identical
            return 0;
        }

        public static String GetServerString(this NetworkAuthorizationListItem endpoint)
        {
            String server = null;

            if (!String.IsNullOrEmpty(endpoint.server))
            {
                server = endpoint.server;
            }
            else
            {
                IPAddress from = new IPAddress(endpoint.fromIP);
                IPAddress to = new IPAddress(endpoint.toIP);

                if (from == to)
                {
                    server = from.ToString();
                }
                else
                {
                    server = from + "-" + to;
                }
            }

            return server;
        }

        public static String GetProtocolString(this NetworkAuthorizationListItem endpoint)
        {
            switch(endpoint.protocol)
            {
                case 1:
                    return "http";
                case 2:
                    return "https";
                default:
                    return "Unknown";
            }
        }

        public static String GetUrl(this NetworkAuthorizationListItem endpoint)
        {
            return String.Format("{0}://{1}:{2}{3}", endpoint.GetProtocolString(), endpoint.GetServerString(), endpoint.port, endpoint.path);
        }

        public static String GetDumpString(this NetworkAuthorizationListItem endpoint)
        {
            return String.Format("{0}://{1}:{2}{3} [{4}]", 
                endpoint.GetProtocolString(), 
                endpoint.GetServerString(), 
                endpoint.port, 
                endpoint.path, 
                endpoint.appliesToLen > 0 ? endpoint.appliesTo.ToString() : "<null>");
        }

        public static UInt32 ReverseIPAddress(UInt32 ipAddress)
        {
            return (UInt32)(((ipAddress & 0x000000FF) << 24) | 
                            ((ipAddress & 0x0000FF00) <<  8) | 
                            ((ipAddress & 0x00FF0000) >>  8) | 
                            ((ipAddress & 0xFF000000) >> 24));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\lhdp.h ===
// lhdp.h
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
#undef UNICODE
#undef _UNICODE

#include <winsock2.h>
#include <windows.h>
#include <winhttp.h>
#include <wincrypt.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <objbase.h>
#include <Aclapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <atlbase.h>
#include <atlcom.h>
#include <loadperf.h>

#include <cutil.h>
#include <xboxverp.h>

//----------------------------------------------------------------------
// Definitions
//----------------------------------------------------------------------

#define INLINE __forceinline

#if DBG
//#define LHD_FEATURE_TEST
#endif

#define Assert DBGASSERT

#define dimensionof(x) (sizeof((x))/sizeof(*(x)))
#define MIN(a,b) ((a) < (b) ? (a) : (b))

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)
#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)
#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


#include "util.h"
#include "lspservice.h"
#include "events.h"

//----------------------------------------------------------------------
// Constants
//----------------------------------------------------------------------

#define MAX_HTTP_HEADERS_PER_REQUEST    20
#define MAX_HTTP_REQUEST_BYTES          8192
#define MAX_PROXY_THREADS               8

//----------------------------------------------------------------------
// Parser
//----------------------------------------------------------------------

struct HttpString
{
    UINT   cch;                     // count of characters in the string
    CHAR * pch;                     // pointer to the start of the string
};

struct HttpHeader
{
    HttpString Name;                // name of the HTTP header, not including trailing colon and whitespace
    HttpString Value;               // value of HTTP header
};

struct HttpRequest
{
    HttpString Verb;                // HTTP verb
    HttpString Url;                 // HTTP Url
    HttpString Version;             // full HTTP version string
    HttpString AllHeaders;          // all the headers after the request line
    UINT       cHeaders;            // number of HTTP headers in request
    HttpHeader aHeaders[MAX_HTTP_HEADERS_PER_REQUEST];
    UINT       cbEntity;            // size of entity data
    BYTE *     pbEntity;            // pointer to entity data
};

class HttpParser
{
public:
    #define HPS_VERB        0
    #define HPS_URL         1
    #define HPS_VERSION     2
    #define HPS_HEADER      3
    #define HPS_ENTITY      4
    #define HPS_DONE      100
    #define HPS_ERROR     101

    void Init(BYTE * pb);
    UINT Parse(UINT cb);

    HttpRequest req;

private:    

    UINT   _uiState;                // next thing to parse
    BYTE * _pbStart;                // first byte in the buffer
    CHAR * _pch;                    // first unparsed character
};

//----------------------------------------------------------------------
// Listener
//----------------------------------------------------------------------


struct ListenerContext
{
    SOCKET       s;
    UINT         cbRequest;
    BYTE         abRequest[MAX_HTTP_REQUEST_BYTES];
};

BOOL ListenerInit(CConfig* pCfg);
void ListenerTerm();

BOOL ListenerAcceptRequest(ListenerContext * pctx);
BOOL ListenerRecv(ListenerContext * pctx);
BOOL ListenerSend(ListenerContext * pctx, UINT cb, BYTE * pb);
void ListenerClose(ListenerContext * pctx);

//----------------------------------------------------------------------
// Talker
//----------------------------------------------------------------------

#define CCHAUXBUFFER                8192
#define CBREADBUFFER                8192


struct TalkerRequest
{
    LPCWSTR pwzVerb;        // HTTP verb
    LPCWSTR pwzUrl;         // HTTP URL
    UINT    cchHeaders;     // size of additional headers in characters
    WCHAR * pwchHeaders;    // pointer to additional headers
    UINT    cbEntity;       // size of entity data in bytes
    BYTE *  pbEntity;       // pointer to entity data

    WCHAR   awchAux[CCHAUXBUFFER];  // for rendering verb and headers in Unicode
};

struct TalkerContext
{
    HINTERNET         hses;         // WinHttp session
    HINTERNET         hcon;         // WinHttp connection
    HINTERNET         hreq;         // WinHttp request
    WORD              wPort;        // TCP port
    DWORD             cbRead;       // Number of bytes available in abRead
    union
    {
        TalkerRequest req;          // HTTP request
        BYTE          abRead[CBREADBUFFER];
    };
};

BOOL TalkerInit(CConfig* pCfg);
void TalkerTerm();

HRESULT TalkerConnect(TalkerContext * pctx, PCSTR pszHost, WORD wPort);
void    TalkerClose(TalkerContext * pctx);
HRESULT TalkerSendRequest(TalkerContext * pctx, HttpRequest * preq, PWSTR pwzAltUrl, PCCERT_CONTEXT pcertctx);
HRESULT TalkerReadData(TalkerContext * pctx);

//----------------------------------------------------------------------
// Proxy
//----------------------------------------------------------------------

struct ProxyContext
{
    HANDLE          hThread;
    ListenerContext lctx;
    TalkerContext   tctx;

    CHAR            szHost[200];
    WORD            wPort;
};

BOOL ProxyInit(CConfig* pCfg);
void ProxyTerm();
BOOL CertInit(CConfig* pCfg);
void CertTerm();

PCCERT_CONTEXT CertFind();
void           CertFree(PCCERT_CONTEXT pccertctx);

BOOL ThreadsInit(CConfig* pCfg);
void ThreadsTerm();

extern volatile BOOL  g_fShutdown;

//----------------------------------------------------------------------
// NT Service class
//----------------------------------------------------------------------

class CLspHttpdService : public CLspService
{

public:

    // Constructor / Destructor ----------------------------------------------------------

    CLspHttpdService() : CLspService(
        L"LSPHTTPD",
        L"XLSP Proxy",
        L"Forwards LSP requests to Live",
        NULL /* pszPerfBaseName */,
        0)
    {
    }

    // CNTService ------------------------------------------------------------------------

    virtual HRESULT InitService (DWORD dwArgc, LPWSTR * ppszArgv);
    virtual HRESULT RunService(BOOL * pfServiceRan);
    virtual DWORD   Install();

    // Data ------------------------------------------------------------------------------

private:


};


//----------------------------------------------------------------------
// Utility
//----------------------------------------------------------------------

char *  HexDumpStr(const void * pv, size_t cb);

//----------------------------------------------------------------------
// Unit Tests
//----------------------------------------------------------------------

#ifdef LHD_FEATURE_TEST

INLINE void DbgBreak()
{
    _asm int 3;
}

#define Verify(x)       do { if (!(x)) { fprintf(stderr, "Verify( " #x " ) failed. last error: 0x%x\n", GetLastError()); DbgBreak(); } } while (0)

void Test_Parser();
void Test_SiteKey();
void Test_SitePuids();
void Test_TalkListen();
void Test_SSL(UINT n);
void Test_404();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\lspservice.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "lhdp.h"
#include "ntsecapi.h"
#include "msxml2.h"
#include <atlbase.h>
#include <atlcom.h>
#include <loadperf.h>

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

#ifndef SAFE_CLOSEHANDLE
#define SAFE_CLOSEHANDLE( h )  if( NULL != h ) { CloseHandle( h ); h = NULL; }
#endif

//////////////////////////////////////////////////////////////////////////////
CLspService::CLspService(
                LPCWSTR  pszServiceName,
                LPCWSTR  pszServiceDisplayName,
                LPCWSTR  pszServiceDescription,
                LPCWSTR  pszPerfBaseName,
                CComBSTR bstrReserved
) :
    m_pszServiceName( pszServiceName ),
    m_pszServiceDisplayName( pszServiceDisplayName ),
    m_pszServiceDescription( pszServiceDescription ),
    m_pszPerfBaseName( pszPerfBaseName ),
    m_fRunningAsService( TRUE ),
    m_hServiceStatus( NULL ),
    m_pszInstallAccountName( NULL ),
    m_pszInstallAccountPassword( NULL )
{
    UNREFERENCED_PARAMETER(bstrReserved);

    Assert( NULL != m_pszServiceName );
    ZeroMemory( &m_Status, sizeof(m_Status) );

    m_Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    m_hevtShutdown = CreateEvent( NULL, FALSE, FALSE, NULL );
}


//////////////////////////////////////////////////////////////////////////////
CLspService::~CLspService()
{
    SAFE_CLOSEHANDLE( m_hevtShutdown );
}

BOOL
AmIAService(
    PBOOL IsAService
    )
{

    PSID Service = NULL;
    PSID LocalSystem = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY ;
    BOOL IsService = FALSE ;
    BOOL IsLocalSystem = FALSE ;
    BOOL Success = FALSE ;

    if ( !AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 
            0, 0, 0, 0, 0, 0, 0, &LocalSystem ) )
    {
        return FALSE ;
    }

    if ( !AllocateAndInitializeSid( &NtAuthority, 1, SECURITY_SERVICE_RID, 
            0, 0, 0, 0, 0, 0, 0, &Service ) )
    {
        FreeSid( LocalSystem );
        return FALSE ;
        
    }

    *IsAService = FALSE ;

    if ( CheckTokenMembership(NULL, Service, &IsService ) )
    {
        if ( !IsService )
        {
            if ( CheckTokenMembership(NULL, LocalSystem, &IsLocalSystem ) )
            {
                Success = TRUE ;

                if ( IsLocalSystem )
                {
                    *IsAService = TRUE ;
                }
            }
            
        }
        else 
        {
            Success = TRUE ;

            *IsAService = TRUE ;
        }

    }

    FreeSid ( LocalSystem );
    FreeSid ( Service );
    return Success ;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ProcessMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //
    // process parameters
    //

    if(dwArgc > 1)
    {
        LPCWSTR pszCommand = pszArgv[1];

        if(_wcsicmp(pszArgv[1], L"install") == 0)
        {
            return ProcessCommandInstall(dwArgc-2, pszArgv+2);
        }
        else if(_wcsicmp(pszArgv[1], L"uninstall") == 0)
        {
            return ProcessCommandUninstall(dwArgc-2, pszArgv+2);
        }
        else
        {
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // no parameters - run the service
    //

    AmIAService( &m_fRunningAsService );

    //
    // Run the service main routine either on this thread (if running as
    // a console app) or on a new thread (if running as a service).
    //
    if( m_fRunningAsService )
    {
        OutputDebugStringA("Running in service mode\n");

        SERVICE_TABLE_ENTRYW DispatchTable[] =
        {
            { (WCHAR *) m_pszServiceName, StaticServiceMain },
            { NULL, NULL }
        };

        if( !StartServiceCtrlDispatcherW( DispatchTable ) )
        {
            return( GetLastError() );
        }
    }
    else
    {
        printf("Running in console mode\n");

        // Allow Ctrl+C to exit the console app
        SetConsoleCtrlHandler( StaticConsoleCtrlHandler, TRUE );
        ServiceMain( dwArgc, pszArgv );
    }

    CoUninitialize();

    //
    // The service has been stopped (or the console has been shut down).
    //
    return( m_Status.dwWin32ExitCode );
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandInstall
// Process the command-line command 'install'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv)
{
    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    if(dwArgc > 0)
    {
        if(dwArgc != 2)
        {
            InstallInfo("Invalid number of parameters for Install");
            PrintUsage();
            return ERROR_INVALID_PARAMETER;
        }

        m_pszInstallAccountName     = pArgv[0];
        m_pszInstallAccountPassword = pArgv[1];
    }

    DWORD status = Install();

    if(m_pszInstallAccountPassword)
    {
        memset(m_pszInstallAccountPassword, 0, wcslen(m_pszInstallAccountPassword));
    }

    m_pszInstallAccountName     = NULL;
    m_pszInstallAccountPassword = NULL;

    return status;
}

// --------------------------------------------------------------------------------------
// CLspService::ProcessCommandUninstall
// Process the command-line command 'uinstall'
// --------------------------------------------------------------------------------------
DWORD CLspService::ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv)
{
    if(dwArgc != 0)
    {
        InstallInfo("Invalid number of parameters for Uninstall");
        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }

    return Uninstall();
}

void CLspService::PrintUsage()
{
    CSmallStr     moduleFullName;
    CVerySmallStr serviceName;  

    CSystem::GetModuleName(NULL, &moduleFullName);
    CSystem::ParseFileName(moduleFullName.cstr(), CSystem::PARSE_NAME_WITHOUT_EXTENSION,
                           &serviceName);

    //           0123456789012345678901234567890123456789012345678901234567890123456789
    InstallInfo("Usage:");
    InstallInfo("");
    InstallInfo("  %s install [<account-name> <account-password]", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Installs service. If account-name and account-password is not");
    InstallInfo("     specified, the service will use the system account.");
    InstallInfo("");
    InstallInfo("  %s uninstall", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Uninstalls service.");
    InstallInfo("");
    InstallInfo("  %s", serviceName.cstr());
    InstallInfo("");
    InstallInfo("     Run in console mode.");
    InstallInfo("");
}

//////////////////////////////////////////////////////////////////////////////
BOOL CLspService::IsServiceInstalled()
{
    BOOL fResult = FALSE;

    SC_HANDLE hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

    if( NULL != hSCM )
    {
        SC_HANDLE hService = ::OpenServiceW( hSCM, m_pszServiceName, SERVICE_QUERY_CONFIG );

        if( NULL != hService )
        {
            fResult = TRUE;
            CloseServiceHandle( hService );
        }

        CloseServiceHandle( hSCM );
    }

    return( fResult );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Install()
{
    DWORD dwRes = ERROR_SUCCESS;
    
    InstallInfo( "Configurator performing Install");

    do
    {
        //
        // Optionally uninstall the service - is this necessary?
        //
        if( IsServiceInstalled() )
        {
            InstallInfo( "Removing pre-existing service");

            dwRes = UninstallService();

            if( ERROR_SUCCESS != dwRes )
            {
                break;
            }
        }

        //
        // Optionally install into the SCM
        //
        dwRes = InstallService();

        if( ERROR_SUCCESS != dwRes )
        {
            break;
        }

    }
    while( FALSE );

    return( dwRes );
}



//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Uninstall()
{
    DWORD dwRes = ERROR_SUCCESS;

    InstallInfo( "Configurator performing Uninstall");

    do
    {
        //
        // Remove the perfmon counters
        //
        dwRes = UninstallCounters();

        if( ERROR_SUCCESS != dwRes )
        {
            break;
        }

        //
        // Remove the service from the SCM
        //
        if( IsServiceInstalled() )
        {
            dwRes = UninstallService();

            if( ERROR_SUCCESS != dwRes )
            {
                break;
            }
        }
        else
        {
            InstallInfo( "Service was not present and did not have to be removed");
        }
    }
    while( FALSE );

    return( dwRes );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::InstallCounters()
{
    DWORD dwRes = ERROR_SUCCESS;

    do
    {
        // Skip this step if the service doesn't have a counter dll
        if(NULL == m_pszPerfBaseName)
            break;
        
        if(0 == wcslen(m_pszPerfBaseName))
            break;
        
        InstallInfo( "Installing performance counters specified in %S", m_pszPerfBaseName);

        //
        // Construct name of perf DLL from this EXE's base name
        //
        WCHAR szPerfDLL[ MAX_PATH ];
        wcscpy(szPerfDLL, m_pszPerfBaseName);
        wcscat(szPerfDLL, L".dll");

        //
        // Get the perf DLL to register its entry points
        //
        HMODULE hmodPerf = LoadLibraryW( szPerfDLL );

        if( NULL == hmodPerf )
        {
            dwRes = GetLastError();
            break;
        }

        FARPROC DllRegServ = (FARPROC) GetProcAddress( hmodPerf, "DllRegisterServer" );

        if( NULL != DllRegServ )
        {
            DllRegServ();
        }

        FreeLibrary( hmodPerf );

    }
    while( FALSE );

    return( dwRes );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::UninstallCounters()
{
    DWORD dwRes = ERROR_SUCCESS;


    do
    {
        // Skip this step if the service doesn't have a counter dll
        if(NULL == m_pszPerfBaseName)
            break;
        
        InstallInfo( "Removing performance counters specified in %S", m_pszPerfBaseName);

        //
        // Use the same routine as unlodctr.exe to do the proper registry
        // grovelling necessary to remove our counters
        //
        WCHAR szCmdLine[ MAX_PATH ];
        wcscpy(szCmdLine, L"unlodctr.exe ");
        wcscat(szCmdLine, m_pszServiceName);

        dwRes = UnloadPerfCounterTextStringsW( szCmdLine, TRUE );

        if( ERROR_SUCCESS != dwRes )
        {
            InstallError( "Failed to unload performance counters strings (0x%08x)\n", dwRes );
            break;
        }
    }
    while( FALSE );

    return( dwRes );
}





//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::InstallService()
{
    DWORD       dwRes = ERROR_SUCCESS;
    SC_HANDLE   hSCM      = NULL;
    SC_HANDLE   hService  = NULL;
    HANDLE      hToken    = NULL;
    LPCWSTR     pszSvcDependencies = L"RPCSS\0";

    do
    {
        InstallInfo( "Installing NT service");

        //
        // Anything to do?
        //
        if( IsServiceInstalled() )
        {
            InstallInfo( "WARNING: Service is already installed!  Pre-existance check didn't work?");
            break;
        }

        //
        // Figure out where this .EXE lives
        //
        WCHAR szFileName[MAX_PATH + 1];
        GetModuleFileNameW(NULL, szFileName, MAX_PATH);
        szFileName[MAX_PATH] = L'\0';
 
        // If there was a service account specified, make sure that account is granted
        // rights to logon as a service
        if (m_pszInstallAccountName != NULL)
        {
            dwRes = GrantLogonRights(m_pszInstallAccountName);
            if ( ERROR_SUCCESS != dwRes )
            {
                if (dwRes == 0x80070534)
                    InstallError( "Failed granting SeLogonServiceRight to %S because account could not be resolved (0x%08x)\n", m_pszInstallAccountName, dwRes );
                else
                    InstallError( "Failed granting SeLogonServiceRight to %S (0x%08x)\n", m_pszInstallAccountName, dwRes );
                break;
            }
        }

        //
        // Contact the SCM and attempt to add a new service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        DWORD dwFlags = SERVICE_WIN32_OWN_PROCESS;

#if DBG
        // $REVIEW (michion):  Can't specify a service account and interactive process
        //                     at the same time
        if (m_pszInstallAccountName == NULL)
        {
            dwFlags |= SERVICE_INTERACTIVE_PROCESS;
        }

#endif

        hService = CreateServiceW(
            hSCM,
            m_pszServiceName,
            m_pszServiceDisplayName,
            SERVICE_ALL_ACCESS,
            dwFlags,
            SERVICE_AUTO_START,
            SERVICE_ERROR_NORMAL,
            szFileName,
            NULL,
            NULL,
            pszSvcDependencies,
            m_pszInstallAccountName,
            m_pszInstallAccountPassword ? m_pszInstallAccountPassword : NULL);

        if( NULL == hService )
        {
            // common errors:  1057 = ERROR_INVALID_SERVICE_ACCOUNT
            dwRes = GetLastError();
            InstallError( "Failed to create service %S (0x%08x)\n", m_pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service '%S' (%S) successfully created", m_pszServiceDisplayName, m_pszServiceName);

        //
        // Associate our descriptive string with the newly installed service
        //
        SERVICE_DESCRIPTIONW scDescription;
        scDescription.lpDescription = (LPWSTR) m_pszServiceDescription;

        if( !ChangeServiceConfig2W(
                        hService,
                        SERVICE_CONFIG_DESCRIPTION,
                        (void *) &scDescription ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed to change service description (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // Now, reconfigure the service retry configuration.  This turns out to
        // be a bit of a PITA because it requires the process token to have
        // the SE_SHUTDOWN_NAME privilege enabled which isn't (apparently)
        // present by default, even for machine/domain admins.
        //
        InstallInfo( "Setting service retry configuration");

        TOKEN_PRIVILEGES         tkPrivileges;
        SERVICE_FAILURE_ACTIONSW scFailureActions;
        SC_ACTION                rgActions[4];
    
        if( !OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling OpenProcessToken (0x%08x)\n", dwRes );
            break;
        }
     
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkPrivileges.Privileges[0].Luid); 

        tkPrivileges.PrivilegeCount           = 1;
        tkPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
     
        if( !AdjustTokenPrivileges(hToken, FALSE, &tkPrivileges, 0, (PTOKEN_PRIVILEGES)NULL, 0) ||
            ERROR_SUCCESS != GetLastError() ) // Not all privileges were adjusted
        {
            dwRes = GetLastError();
            InstallError( "Failed calling AdjustTokenPrivileges (0x%08x)\n", dwRes );
            break;
        }

        //---------------------------------------------------------------------
        // With that out of the way, we can set the restart configuration
        // (the privilege switch above is needed in order to set an
        // SC_ACTION_REBOOT Type entry)
        //
        rgActions[0].Type  = SC_ACTION_NONE;     // $REVIEW (michion): parameterize these into member vars
        rgActions[0].Delay = 5000;
        rgActions[1].Type  = SC_ACTION_NONE;
        rgActions[1].Delay = 5000;
        rgActions[2].Type  = SC_ACTION_NONE;
        rgActions[2].Delay = 5000;
        rgActions[3].Type  = SC_ACTION_NONE;
        rgActions[3].Delay = 5000;

        scFailureActions.dwResetPeriod = 1800;
        scFailureActions.lpRebootMsg   = L"";
        scFailureActions.lpCommand     = L"";
        scFailureActions.cActions      = sizeof(rgActions)/sizeof(rgActions[0]);
        scFailureActions.lpsaActions   = rgActions;

        if( !ChangeServiceConfig2(
                        hService,
                        SERVICE_CONFIG_FAILURE_ACTIONS,
                        (void *) &scFailureActions ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed calling ChangeServiceConfig2 (0x%08x)\n", dwRes );
            break;
        }

        dwRes = InstallCounters();

        if( ERROR_SUCCESS != dwRes )
        {
            InstallError( "Failed calling InstallCounters (0x%08x)\n", dwRes );
            break;
        }
    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hToken )
    {
        CloseHandle( hToken );
    }

    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }
    
    return( dwRes );
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::UninstallService()
{
    DWORD dwRes = ERROR_SUCCESS;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL      fOK = FALSE;

    do
    {
        InstallInfo( "Uninstalling NT service");

        //
        // Anything to do?
        //
        if( !IsServiceInstalled() )
        {
            InstallInfo( "WARNING: Service is not installed!  Pre-existance check didn't work?");
            break;
        }

        //
        // Contact the SCM and attempt to open the existing service
        //
        hSCM = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );

        if( NULL == hSCM )
        {
            dwRes = GetLastError();
            InstallError( "Failed opening Service Control Manager (0x%08x)\n", dwRes );
            break;
        }

        hService = OpenServiceW( hSCM, m_pszServiceName, SERVICE_STOP | DELETE );

        if( NULL == hService )
        {
            dwRes = GetLastError();
            InstallError( "Failed retrieving service handle for %S (0x%08x)\n", m_pszServiceName, dwRes );
            break;
        }

        //
        // Stop and delete the service
        //
        SERVICE_STATUS status;

        fOK = ControlService( hService, SERVICE_CONTROL_STOP, &status );
        if (!fOK)
        {
            dwRes = GetLastError();

            if (dwRes != 0x00000426)   // if the service isn't running, we should get back 0x0426 (ERROR_SERVICE_NOT_ACTIVE)
            {
                InstallError( "Failed to stop service %S.  Service delete will probably fail as well (0x%08x)\n", m_pszServiceName, dwRes );
            }
            else
            {
                dwRes = 0;  // reset the exit code so that XMGMT doesn't think this was an actual error
            }
        }


        if( !DeleteService( hService ) )
        {
            dwRes = GetLastError();
            InstallError( "Failed deleting service %S (0x%08x)\n", m_pszServiceName, dwRes );
            break;
        }

        InstallInfo( "Service '%S' (%S) successfully stopped and deleted", m_pszServiceDisplayName, m_pszServiceName);

    }
    while( FALSE );

    //
    // Clean up
    //
    if( NULL != hService )
    {
        CloseServiceHandle( hService );
    }

    if( NULL != hSCM )
    {
        CloseServiceHandle( hSCM );
    }

    return( dwRes );
}

////////////////////////////////////////////////////////////////////////////
void CLspService::InstallError( char* pszFmt, ... )
{
    char szFmt[ 1024 ];
    va_list marker;

    va_start( marker, pszFmt );
    _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
    printf("InstallError: %s\n", szFmt);
    va_end( marker );

    return;
}


////////////////////////////////////////////////////////////////////////////
void CLspService::InstallInfo( char* pszFmt, ... )
{
    if (pszFmt == NULL)
    {
        printf("CLspService configurator intializing\n");
    }
    else
    {
        char szFmt[ 1024 ];
        va_list marker;

        va_start( marker, pszFmt );
        _vsnprintf(szFmt, ARRAY_SIZE(szFmt), pszFmt, marker );
        printf("   %s\n", szFmt);
        va_end( marker );
    }

    return;
}

////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ChangeState( DWORD dwState )
{
    m_Status.dwCheckPoint = (DWORD) -1; // will be inc. in Checkpoint()
    m_Status.dwCurrentState = dwState;

    return( Checkpoint() );
}


///////////////////////////////////////////////////////////////////////////////////////
DWORD CLspService::Checkpoint( DWORD dwWaitHint /* = 0 */ )
{
    if( m_fRunningAsService )
    {
        m_Status.dwWaitHint = dwWaitHint;
        m_Status.dwCheckPoint++;
        
        if( !SetServiceStatus( m_hServiceStatus, &m_Status ) )
        {
            return( GetLastError() );
        }
    }

    return( ERROR_SUCCESS );
}


////////////////////////////////////////////////////////////////////////////
DWORD CLspService::ReportError( DWORD dwErr )
{
    m_Status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    m_Status.dwServiceSpecificExitCode = dwErr;

    return( Checkpoint() );
}


//////////////////////////////////////////////////////////////////////////////
void CLspService::ServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    // CONSIDER: Move mgmt initialization here

    if( m_fRunningAsService )
    {
        m_hServiceStatus = RegisterServiceCtrlHandlerW(
                                            m_pszServiceName,
                                            StaticServiceControlHandler );

        if( NULL == m_hServiceStatus )
        {
            m_Status.dwWin32ExitCode = GetLastError();
            return;
        }
    }

    ChangeState( SERVICE_START_PENDING );

    m_Status.dwWin32ExitCode = S_OK;
    m_Status.dwCheckPoint = 0;
    m_Status.dwWaitHint = 0;

    HRESULT hr = S_OK;
    BOOL fServiceRan = FALSE;

    do
    {
        Checkpoint();

        hr = InitService( dwArgc, pszArgv );

        if( FAILED( hr ) )
        {
            break;
        }

        Checkpoint();

        ChangeState( SERVICE_RUNNING );

        hr = RunService( &fServiceRan );

        if( FAILED( hr ) )
        {
            break;
        }
    }
    while( FALSE );

    if ( FAILED( hr ) && !fServiceRan )
    {
        ChangeState( SERVICE_STOP_PENDING );
        ReportError( hr );
    }

    ChangeState( SERVICE_STOPPED );
}

//////////////////////////////////////////////////////////////////////////////
void CLspService::TermService()
{
    // wake up the RunService thread
    SetEvent( m_hevtShutdown );
}

//////////////////////////////////////////////////////////////////////////////
void CLspService::ServiceControlHandler( DWORD dwOpcode )
{
    if( SERVICE_CONTROL_STOP == dwOpcode )
    {
        // tell scm we're stopping
        ChangeState( SERVICE_STOP_PENDING );

        // wake up any sockets that are waiting to connect
//        g_SocketConnectWatchdog.Shutdown();

        TermService();
    }
    else
    {
        //
        // Unknown service control opcode?
        //
        OutputDebugStringA(CSmallStr().Format(
                           "ServiceControlHandler: unknown opcode %d", 
                           dwOpcode).cstr());
    }
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CLspService::StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv )
{
    Assert( NULL != g_pService );
    g_pService->ServiceMain( dwArgc, pszArgv );
}


//////////////////////////////////////////////////////////////////////////////
void WINAPI CLspService::StaticServiceControlHandler( DWORD dwOpcode )
{
    Assert( NULL != g_pService );
    g_pService->ServiceControlHandler( dwOpcode );
}

//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI CLspService::StaticConsoleCtrlHandler( DWORD dwCtrlType )
{
    Assert( NULL != g_pService );
    g_pService->ServiceControlHandler( SERVICE_CONTROL_STOP );
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CLspService::GrantLogonRights(LPCWSTR szAccount)
{
    DWORD       dwRes       = ERROR_SUCCESS;
    NTSTATUS    ntStatus    = 0;

    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    LSA_UNICODE_STRING      PrivilegeString;
    LSA_HANDLE              PolicyHandle = NULL;

    CSIDLookup              sidLookup;

    dwRes = sidLookup.Lookup(szAccount);
    if (FAILED(dwRes))
    {
        goto lCleanup;
    }
    //
    // It is very unfortunate that at this point dwRes holds a HRESULT
    // while this function returns a Win32 error by contract. The best
    // compromise is to have the function return a value that honors the
    // win32 success/failure semantics (0 -> success, failure otherwise),
    // but could potentially return hresults/ntstatus's as failure. This
    // ensures that returns such as S_FALSE are sanitized, but that doesn't
    // fix callers that use FAILED(dwRes). Those need to be fixed case by
    // case
    //
    dwRes = ERROR_SUCCESS;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    ntStatus = ::LsaOpenPolicy(
                    NULL,
                    &ObjectAttributes,
                    POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                    &PolicyHandle
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = ::LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }

    

    PrivilegeString.Buffer        = L"SeServiceLogonRight";
    PrivilegeString.Length        = (USHORT) wcslen(PrivilegeString.Buffer) * sizeof(WCHAR);
    PrivilegeString.MaximumLength = (USHORT)(wcslen(PrivilegeString.Buffer)+1) * sizeof(WCHAR);


    ntStatus = ::LsaAddAccountRights(
                    PolicyHandle,
                    sidLookup.GetPSID(),
                    &PrivilegeString,
                    1
                    );

    if (ntStatus != STATUS_SUCCESS)
    {
        dwRes = LsaNtStatusToWinError(ntStatus);
        goto lCleanup;
    }


lCleanup:
    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
        PolicyHandle = NULL;
    }

    return( dwRes );
}

CSIDLookup::CSIDLookup()
{
    m_cbSID            = 0;
    m_cchRefDomainName = 0;
    m_pSID             = NULL;
    m_szRefDomainName  = NULL;
}


CSIDLookup::~CSIDLookup()
{
    if (m_pSID)
    {
        ::LocalFree(m_pSID);
        m_pSID = NULL;
    }

    if (m_szRefDomainName)
    {
        ::LocalFree(m_szRefDomainName);
        m_szRefDomainName = NULL;
    }
}


HRESULT CSIDLookup::Lookup(LPCWSTR szAccount)
{
    BOOL    fRet    = false;
    HRESULT hr      = S_OK;
    DWORD   dwRes   = ERROR_SUCCESS;
    SID     sidDummy;
    WCHAR   wstrDummy[2];

    // Get the required buffer sizes

    // N.B.: This is royally F*(&@#D up!  The MSDN docs claim that passing
    //       NULL for the PSID and ReferenceDomainName parameters will,
    //       in conjunction with passing pointers to zero'd out DWORDs for
    //       cbSid and cchReferenceDomainName, return the amount of
    //       space needed for these two buffers.  Total BS!  Unless the
    //       pointers are non-NULL, the function won't return anything in
    //       the cb/cch DWORDS except zero


    fRet = LookupAccountNameW(
            NULL,
            szAccount,
            &sidDummy,
            &m_cbSID,
            wstrDummy,
            &m_cchRefDomainName,
            &m_SIDNameUse
            );

    if (!fRet)
    {
        dwRes = ::GetLastError();
        if (dwRes == ERROR_INSUFFICIENT_BUFFER)
        {
            //-----------------------------------------------------------------
            // this is ok, we expected the function to complain about buffer
            // sizes being too small.  Just keep going now that we have the
            // actual buffer sizes we need in m_cbSID and m_cchRefDomainName
            //
            dwRes = ERROR_SUCCESS;
        }
        else
        {
            //-----------------------------------------------------------------
            // Gotta convert errors into HRESULTS (caller is checking FAILED()
            // which doesn't pick up on regular win32 errors
            //
            hr = HRESULT_FROM_WIN32(dwRes);
            goto lCleanup;
        }
    }
    
    
    m_szRefDomainName = (LPWSTR)::LocalAlloc(LPTR, m_cchRefDomainName * sizeof(TCHAR));
    if (m_szRefDomainName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    m_pSID = (PSID)::LocalAlloc(LPTR, m_cbSID);
    if (m_pSID == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanup;
    }
    
    
    // Do the lookup for real now
    fRet = LookupAccountNameW(
             NULL,
             szAccount,
             m_pSID,
             &m_cbSID,
             m_szRefDomainName,
             &m_cchRefDomainName,
             &m_SIDNameUse
             );
    
    if (!fRet)
    {
        dwRes = ::GetLastError();
        hr = HRESULT_FROM_WIN32(dwRes);
        goto lCleanup;
    }
    

lCleanup:
    if (FAILED(hr))
    {
        if (m_pSID)
        {
            ::LocalFree(m_pSID);
            m_pSID = NULL;
        }
        
        if (m_szRefDomainName)
        {
            ::LocalFree(m_szRefDomainName);
            m_szRefDomainName = NULL;
        }
    }

    return hr;
}

PSID    CSIDLookup::GetPSID(void)
{
    return m_pSID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\lsphttpd.cpp ===
// lsphttpd.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.

// @@@ test configuration negative cases

#include "lhdp.h"

CLspHttpdService    g_LspHttpdSvc;
CLspService *       g_pService = &g_LspHttpdSvc;

#define LSPHTTPD_EVENT_SOURCE "Lsphttpd"
#define LSPHTTPD_EVENT_BINARY "lsphttpd.exe"

void Test_Setup(CConfig* pCfg);

void __cdecl wmain(int argc, WCHAR ** argv)
{
    LARGE_INTEGER liTime;
    GetSystemTimeAsFileTime((LPFILETIME)&liTime);
    printf("LSP HTTP Proxy (%s) %I64x\n\n", VER_PRODUCTVERSION_STR, liTime.QuadPart);
    CMemAlloc::Init();

    g_LspHttpdSvc.ProcessMain(argc, argv);
}

HRESULT CLspHttpdService::InitService (DWORD dwArgc, LPWSTR * ppszArgv)
{
    HRESULT hr = S_OK;
    CConfig config;

    if(!CNtEventLog::Init(LSPHTTPD_EVENT_SOURCE))
    {
        hr = E_FAIL;
        goto exit;
    }

    if(!config.Init("lsphttpd.ini"))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (!ProxyInit(&config))
    {
        hr = E_FAIL;
        goto exit;
    }

//     Test_Setup(&config);

#ifdef LHD_FEATURE_TEST
    Test_Parser();
//    Test_SiteKey();
    Test_SitePuids();
//    Test_404();
//    Test_TalkListen();
//    Test_SSL(10000);

#endif

exit:
    
    return(hr);
}

HRESULT CLspHttpdService::RunService(BOOL * pfServiceRan)
{
    NtEventLog(EVENT_INIT_INFO, "");

    WaitForSingleObject(ShutdownEvent(), INFINITE);
    ProxyTerm();
    
    NtEventLog(EVENT_SHUTDOWN_INFO, ""); 
    
    return(S_OK);
}

DWORD CLspHttpdService::Install()
{
    DWORD status = CLspService::Install();

    InstallInfo("Registering event-source");
    
    if(status == ERROR_SUCCESS)
    {
        if(CNtEventLog::Install(LSPHTTPD_EVENT_SOURCE, LSPHTTPD_EVENT_BINARY))
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            status = ERROR_FUNCTION_FAILED;
        }
    }

    return status;
}

char * HexDumpStr(const void * pv, size_t cbTotal)
{
    STATIC_BUFFER(HexDumpStr, 32, 1420);
    char * pchDst = pch;
    BYTE * pb = (BYTE *)pv;
    BYTE * pbLine;
    UINT   ui, ib;
    UINT   cb;

    if (cbTotal > 320)
        cbTotal = 320;

    for ( ; cbTotal > 0; cbTotal -= cb)
    {
        cb     = min(16, cbTotal);
        pbLine = pb;

        for (ib = 0; ib < cb; ++ib, ++pb)
        {
            ui = (*pb) >> 4;
            *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
            ui = (*pb) & 0x0F;
            *pchDst++ = ui < 10 ? '0' + ui : 'A' + (ui - 10);
            *pchDst++ = ' ';

            if (ib == 7)
            {
                *pchDst++ = ' ';
            }
        }

        for (; ib < 16; ++ib)
        {
            *pchDst++ = ' ';
            *pchDst++ = ' ';
            *pchDst++ = ' ';

            if (ib == 7)
            {
                *pchDst++ = ' ';
            }
        }

        *pchDst++ = ' ';

        for (pb = pbLine, ib = 0; ib < cb; ++ib, ++pb)
        {
            if (*pb >= 32 && *pb < 127)
                *pchDst++ = (char)(*pb);
            else
                *pchDst++ = '.';
        }

        *pchDst++ = '\n';
    }

    *pchDst = 0;

    return(pch);
}



#ifdef LHD_FEATURE_TEST

//
// g_abMatchCreate
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
// Content-Length: 104
//

BYTE g_abMatchCreate[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x31, 0x30, 0x34, 0x0D, 0x0A,
0x0D, 0x0A,
0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0x04, 0x00, 0x00,
0x0A, 0x01, 0x01, 0x02, 0x41, 0x34, 0xF0, 0xD7, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0xC7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// g_abMatchCreateNoEntity
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
//

BYTE g_abMatchCreateNoEntity[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x0D, 0x0A
};

//
// g_abMatchCreateManyHeaders
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-Length: 104
//

BYTE g_abMatchCreateManyHeaders[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x31, 0x30, 0x34, 0x0D, 0x0A,
0x0D, 0x0A,
0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0x04, 0x00, 0x00,
0x0A, 0x01, 0x01, 0x02, 0x41, 0x34, 0xF0, 0xD7, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0xC7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// g_abMatchCreateTooManyHeaders
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-type: xon/6
// Content-Length: 104
//

BYTE g_abMatchCreateTooManyHeaders[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x31, 0x30, 0x34, 0x0D, 0x0A,
0x0D, 0x0A,
0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0x04, 0x00, 0x00,
0x0A, 0x01, 0x01, 0x02, 0x41, 0x34, 0xF0, 0xD7, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0xC7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// g_abMatchCreateExtraSpaces
//
// POST   /xmatch/xmatchhost.srf  HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
//  Content-Length:      104
//

BYTE g_abMatchCreateExtraSpaces[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x20, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x20, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x20, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x34, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A,
0x0D, 0x0A,
0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0x04, 0x00, 0x00,
0x0A, 0x01, 0x01, 0x02, 0x41, 0x34, 0xF0, 0xD7, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0xC7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// g_abMatchCreateOddHeaders
//
// POST   /xmatch/xmatchhost.srf  HTTP/1.0
// User-Agent: 6/1.00.5816
// User-Agent: 6/1.00.5816\r
// User-Agent: 6/1.00.5816\n
// Content-type :
//  Content-Length:      104
//

BYTE g_abMatchCreateOddHeaders[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x20, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x20, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x0D, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x0A, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x20, 0x3A, 0x0D, 0x0A,
0x20, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x34, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A,
0x0D, 0x0A,
0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0x04, 0x00, 0x00,
0x0A, 0x01, 0x01, 0x02, 0x41, 0x34, 0xF0, 0xD7, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0xC7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// g_abMatchCreateMissingColon
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent 6/1.00.5816
// Content-type: xon/6
//

BYTE g_abMatchCreateMissingColon[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x0D, 0x0A
};

//
// g_abMatchCreateContentTooLong
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
// Content-Length: 9999999999
//

BYTE g_abMatchCreateContentTooLong[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39, 0x0D, 0x0A,
0x0D, 0x0A,
0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2, 0x04, 0x00, 0x00,
0x0A, 0x01, 0x01, 0x02, 0x41, 0x34, 0xF0, 0xD7, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
0xC7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

//
// g_abMatchCreateContentLengthBogus
//
// POST /xmatch/xmatchhost.srf HTTP/1.0
// User-Agent: 6/1.00.5816
// Content-type: xon/6
// Content-Length: A
//

BYTE g_abMatchCreateContentLengthBogus[] =
{
0x50, 0x4F, 0x53, 0x54, 0x20, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2F, 0x78, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x68, 0x6F, 0x73, 0x74, 0x2E, 0x73, 0x72, 0x66, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2F, 0x31, 0x2E, 0x30, 0x0D, 0x0A,
0x55, 0x73, 0x65, 0x72, 0x2D, 0x41, 0x67, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x36, 0x2F, 0x31, 0x2E, 0x30, 0x30, 0x2E, 0x35, 0x38, 0x31, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x74, 0x79, 0x70, 0x65, 0x3A, 0x20, 0x78, 0x6F, 0x6E, 0x2F, 0x36, 0x0D, 0x0A,
0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x2D, 0x4C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3A, 0x20, 0x41, 0x0D, 0x0A,
0x0D, 0x0A
};

void Test_Parser_Success(BYTE * pb, UINT cb, PSTR pszVerb, PSTR pszUrl, PSTR pszVersion, UINT cHeaders, UINT cbEntity)
{
    HttpParser hp1, hp2, hp3;
    UINT       ui;

    // parse all at once
    hp1.Init(pb);
    ui = hp1.Parse(cb);
    Verify(ui == HPS_DONE);

    // parse one character at a time
    hp2.Init(pb);
    for (UINT i = 1; i < cb; i++)
    {
        ui = hp2.Parse(i);
        Verify(ui < HPS_DONE);
    }
    ui = hp2.Parse(i);
    Verify(ui == HPS_DONE);

    // split the request into two halves
    for (UINT i = 1; i < (cb - 1); i++)
    {
        hp3.Init(pb);
        ui = hp3.Parse(i);
        Verify(ui < HPS_DONE);
        ui = hp3.Parse(cb);
        Verify(ui == HPS_DONE);
    }

    Verify(memcmp(&hp1.req, &hp2.req, sizeof(hp1.req)) == 0);
    Verify(memcmp(&hp1.req, &hp3.req, sizeof(hp1.req)) == 0);

    Verify(strlen(pszVerb) == hp1.req.Verb.cch);
    Verify(strncmp(pszVerb, hp1.req.Verb.pch, hp1.req.Verb.cch) == 0);

    Verify(strlen(pszUrl) == hp1.req.Url.cch);
    Verify(strncmp(pszUrl, hp1.req.Url.pch, hp1.req.Url.cch) == 0);

    Verify(strlen(pszVersion) == hp1.req.Version.cch);
    Verify(strncmp(pszVersion, hp1.req.Version.pch, hp1.req.Version.cch) == 0);

    Verify(cHeaders == hp1.req.cHeaders);
    Verify(cbEntity == hp1.req.cbEntity);

    printf(".");

}

void Test_Parser_Fail(BYTE * pb, UINT cb)
{
    HttpParser hp1, hp2, hp3;
    UINT       ui;

    // parse all at once
    hp1.Init(pb);
    ui = hp1.Parse(cb);
    Verify(ui == HPS_ERROR);

    // parse one character at a time
    hp2.Init(pb);
    for (UINT i = 1; i < cb; i++)
    {
        ui = hp2.Parse(i);
        if (ui == HPS_ERROR)
            break;

        Verify(ui < HPS_DONE);
    }
    if (ui < HPS_DONE)
    {
        ui = hp2.Parse(i);
    }
    Verify(ui == HPS_ERROR);

    // split the request into two halves
    for (UINT i = 1; i < (cb - 1); i++)
    {
        hp3.Init(pb);
        ui = hp3.Parse(i);
        Verify(ui < HPS_DONE || ui == HPS_ERROR);

        if (ui < HPS_DONE)
        {
            ui = hp3.Parse(cb);
            Verify(ui == HPS_ERROR);
        }
    }

    Verify(memcmp(&hp1.req, &hp2.req, sizeof(hp1.req)) == 0);
    Verify(memcmp(&hp1.req, &hp3.req, sizeof(hp1.req)) == 0);

    printf(".");
}

void Test_Parser()
{
    printf("Testing Parser ");

    Test_Parser_Success(g_abMatchCreate, sizeof(g_abMatchCreate), "POST", "/xmatch/xmatchhost.srf", "HTTP/1.0", 3, 104);
    Test_Parser_Success(g_abMatchCreateExtraSpaces, sizeof(g_abMatchCreateExtraSpaces), "POST", "/xmatch/xmatchhost.srf", "HTTP/1.0", 3, 104);
    Test_Parser_Success(g_abMatchCreateNoEntity, sizeof(g_abMatchCreateNoEntity), "POST", "/xmatch/xmatchhost.srf", "HTTP/1.0", 2, 0);
    Test_Parser_Success(g_abMatchCreateManyHeaders, sizeof(g_abMatchCreateManyHeaders), "POST", "/xmatch/xmatchhost.srf", "HTTP/1.0", 20, 104);
    Test_Parser_Success(g_abMatchCreateOddHeaders, sizeof(g_abMatchCreateOddHeaders), "POST", "/xmatch/xmatchhost.srf", "HTTP/1.0", 5, 104);
    Test_Parser_Success(g_abMatchCreateContentLengthBogus, sizeof(g_abMatchCreateContentLengthBogus), "POST", "/xmatch/xmatchhost.srf", "HTTP/1.0", 3, 0);
    Test_Parser_Fail(g_abMatchCreateTooManyHeaders, sizeof(g_abMatchCreateTooManyHeaders));
    Test_Parser_Fail(g_abMatchCreateMissingColon, sizeof(g_abMatchCreateMissingColon));
    Test_Parser_Fail(g_abMatchCreateContentTooLong, sizeof(g_abMatchCreateContentTooLong));

    printf(" [OK]\n");
}

CHAR g_achResponseFmt[] = "HTTP/1.1 200 OK\r\n"
                          "Content-type: text/html\r\n"
                          "Content-length: %d\r\n"
                          "\r\n";

CHAR g_achResponseHdr[sizeof(g_achResponseFmt) + 10];

UINT Test_TalkListenThreadProc(void *)
{
    // start listening
    ListenerContext lctx;
    HttpParser      hp;
    UINT            uiState;

    hp.Init(lctx.abRequest);

    Verify(ListenerAcceptRequest(&lctx));
    do
    {
        Verify(ListenerRecv(&lctx));
        uiState = hp.Parse(lctx.cbRequest);
    }
    while (uiState < HPS_DONE);
    Verify(uiState == HPS_DONE);

    UINT cbHeader = sprintf(g_achResponseHdr, g_achResponseFmt, lctx.cbRequest);

    Verify(ListenerSend(&lctx, cbHeader, (BYTE *)g_achResponseHdr));
    Verify(ListenerSend(&lctx, lctx.cbRequest, lctx.abRequest));
    ListenerClose(&lctx);

    return(0);
}

CHAR g_achResponse[8192];

void VerifyResponse(UINT cch, CHAR * pch, CHAR * pchUrl)
{
    CHAR * pchEntity = strstr(pch, "\r\n\r\n") + 4;
    Verify((UINT)(pchEntity - pch) < cch);

    HttpParser hp;
    hp.Init((BYTE *)pchEntity);
    Verify(hp.Parse(cch - (pchEntity - pch)) == HPS_DONE);

    Verify(strncmp("POST", hp.req.Verb.pch, hp.req.Verb.cch) == 0);
    Verify(strncmp(pchUrl, hp.req.Url.pch, hp.req.Url.cch) == 0);
    Verify(strncmp("HTTP/1.1", hp.req.Version.pch, hp.req.Version.cch) == 0);
    Verify(hp.req.cbEntity == 104);
}

void Test_TalkListen()
{
    printf("Testing Talker/Listener ");

    HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, Test_TalkListenThreadProc, NULL, 0, NULL);
    Verify(hThread != NULL);

    // send a request
    HttpParser hp;
    hp.Init(g_abMatchCreate);
    Verify(hp.Parse(sizeof(g_abMatchCreate)) == HPS_DONE);

    TalkerContext ctx;
    CHAR *        pch = g_achResponse;
    memset(&ctx, 0, sizeof(ctx));
    Verify(SUCCEEDED(TalkerConnect(&ctx, L"localhost", 8080)));
    Verify(SUCCEEDED(TalkerSendRequest(&ctx, &hp.req, NULL, NULL)));
    do
    {
//        printf(HexDumpStr(&ctx.abRead, ctx.cbRead));
        memcpy(pch, ctx.abRead, ctx.cbRead);
        pch += ctx.cbRead;
        Verify(SUCCEEDED(TalkerReadData(&ctx)));
    }
    while (ctx.cbRead > 0);
    VerifyResponse(pch - g_achResponse, g_achResponse, "/xmatch/xmatchhost.srf");
    TalkerClose(&ctx);

    WaitForSingleObject(hThread, INFINITE);
    printf(".");

    // send the same request with alternate Url

    hThread = (HANDLE)_beginthreadex(NULL, 0, Test_TalkListenThreadProc, NULL, 0, NULL);
    Verify(hThread != NULL);

    pch = g_achResponse;
    memset(&ctx, 0, sizeof(ctx));
    Verify(SUCCEEDED(TalkerConnect(&ctx, L"localhost", 8080)));
    Verify(SUCCEEDED(TalkerSendRequest(&ctx, &hp.req, L"/alternate.aspx", NULL)));
    do
    {
//        printf(HexDumpStr(&ctx.abRead, ctx.cbRead));
        memcpy(pch, ctx.abRead, ctx.cbRead);
        pch += ctx.cbRead;
        Verify(SUCCEEDED(TalkerReadData(&ctx)));
    }
    while (ctx.cbRead > 0);
    VerifyResponse(pch - g_achResponse, g_achResponse, "/alternate.aspx");
    TalkerClose(&ctx);

    WaitForSingleObject(hThread, INFINITE);
    printf(".");

    printf(" [OK]\n");
}

CHAR g_achLookupPUID[] = "POST /LiveProxy/lookuppuid.aspx HTTP/1.1\r\n"
                         "Content-Type: xon/0\r\n"
                         "Content-Length: 12\r\n"
                         "\r\n"
                         "\x01\x00\x00\x00\xFF\xFF\xFF\xFF\xFF\xFF\x09\x00";

void Test_SSL(UINT n)
{
    printf("Testing SSL \n");

    HttpParser hp;
    hp.Init((BYTE *)g_achLookupPUID);
    Verify(hp.Parse(sizeof(g_achLookupPUID)) == HPS_DONE);

    UINT delay = 64 * 1000;

    TalkerContext ctx;
    memset(&ctx, 0, sizeof(ctx));
    Verify(SUCCEEDED(TalkerConnect(&ctx, L"192.168.86.166", 443)));

    for (UINT i = 0; i < n; i++)
    {
        if (i > 0)
        {
            Sleep(delay);
            delay *= 2;
        }

        printf("ssl iteration %d, delay %d\n", i, delay / 1000);

        PCCERT_CONTEXT pcertctx = CertFind();
        Verify(pcertctx != NULL);
        Verify(SUCCEEDED(TalkerSendRequest(&ctx, &hp.req, NULL, pcertctx)));
        do
        {
            printf(HexDumpStr(&ctx.abRead, ctx.cbRead));
            Verify(SUCCEEDED(TalkerReadData(&ctx)));
        }
        while (ctx.cbRead > 0);
        CertFree(pcertctx);
    }

    TalkerClose(&ctx);

    printf("[OK]\n");
}


CHAR g_achGetSiteInfo[] = "POST /LiveProxy/GetSiteInfo.aspx HTTP/1.1\r\n"
                          "Content-Type: xon/0\r\n"
                          "Content-Length: 4\r\n"
                          "\r\n"
                          "\x65\x00\x00\x00";

void Test_SiteKey()
{
    printf("Testing SiteKey \n");

    HttpParser hp;
    hp.Init((BYTE *)g_achGetSiteInfo);
    Verify(hp.Parse(sizeof(g_achGetSiteInfo)) == HPS_DONE);

    TalkerContext ctx;
    memset(&ctx, 0, sizeof(ctx));
    Verify(SUCCEEDED(TalkerConnect(&ctx, L"192.168.86.166", 443)));
    Verify(SUCCEEDED(TalkerSendRequest(&ctx, &hp.req, NULL, g_pcertctx)));
    do
    {
        printf(HexDumpStr(&ctx.abRead, ctx.cbRead));
        Verify(SUCCEEDED(TalkerReadData(&ctx)));
    }
    while (ctx.cbRead > 0);
    TalkerClose(&ctx);


    printf("[OK]\n");
}

CHAR g_achGetSitePuids[] = "POST /LiveProxy/GetSitePuids.aspx HTTP/1.1\r\n"
                           "Content-Type: xon/0\r\n"
                           "\r\n";

void Test_SitePuids()
{
    printf("Testing SitePuids \n");

    HttpParser hp;
    hp.Init((BYTE *)g_achGetSitePuids);
    Verify(hp.Parse(sizeof(g_achGetSitePuids)) == HPS_DONE);

    TalkerContext ctx;
    memset(&ctx, 0, sizeof(ctx));
    Verify(SUCCEEDED(TalkerConnect(&ctx, L"192.168.86.166", 443)));
    Verify(SUCCEEDED(TalkerSendRequest(&ctx, &hp.req, NULL, g_pcertctx)));
    do
    {
        printf(HexDumpStr(&ctx.abRead, ctx.cbRead));
        Verify(SUCCEEDED(TalkerReadData(&ctx)));
    }
    while (ctx.cbRead > 0);
    TalkerClose(&ctx);


    printf("[OK]\n");
}

CHAR g_achGet404[] = "POST /LiveProxy/GetSiteInfo.aspx HTTP/1.1\r\n"
                     "Content-Length: 4\r\n"
                     "\r\n"
                     "\x65\x00\x00\x00";

void Test_404()
{
    printf("Testing 404 \n");

    HttpParser hp;
    hp.Init((BYTE *)g_achGet404);
    Verify(hp.Parse(sizeof(g_achGet404)) == HPS_DONE);

    TalkerContext ctx;
    memset(&ctx, 0, sizeof(ctx));
    Verify(SUCCEEDED(TalkerConnect(&ctx, L"192.168.86.166", 443)));
    Verify(SUCCEEDED(TalkerSendRequest(&ctx, &hp.req, NULL, g_pcertctx)));
    do
    {
        printf(HexDumpStr(&ctx.abRead, ctx.cbRead));
        Verify(SUCCEEDED(TalkerReadData(&ctx)));
    }
    while (ctx.cbRead > 0);
    TalkerClose(&ctx);


    printf("[OK]\n");
}

#endif

// ---------------------------------------------------------------------------------------
// Setup Test
// ---------------------------------------------------------------------------------------

#include <pshpack1.h>

struct LspSiteInfo
{
    LARGE_INTEGER _liTime;
    DWORD         _cKeys;
};

struct LspKeyInfo
{
    DWORD         _dwVersion;
    BYTE          _abKey[16];
};

#include <poppack.h>

CHAR g_achGetSiteInfoTS[] = "POST /LiveProxy/GetSiteInfo.aspx HTTP/1.1\r\n"
                            "Content-Type: xon/0\r\n"
                            "Content-Length: 4\r\n"
                            "\r\n"
                            "\x65\x00\x00\x00";

#if 0
void Test_Setup(CConfig* pCfg)
{
    HRESULT         hr;
    DWORD           dwBool;
    DWORD           dwSiteId;
    CVerySmallStr   host;
    DWORD           dwPort;
    WORD            wPort;

    if(!pCfg->GetUInt32("LspProxy", "SelfTest.Setup.Enable", (UINT32*)&dwBool) || !dwBool)
    {
        return;
    }

    if(!pCfg->GetUInt32("LspProxy", "SelfTest.Setup.SiteId", (UINT32*)&dwSiteId))
    {
        return;
    }

    //
    // Read in configuration
    //

    if(!pCfg->GetString("LspProxy", "SelfTest.Setup.HostName", &host))
    {
        return;
    }

    host.Trim();

    if(!pCfg->GetUInt32("LspProxy", "SelfTest.Setup.Port", (UINT32*)&dwPort))
    {
        dwPort = 443;
    }
    else if(dwPort > 0xFFFF)
    {
        return;
    }

    wPort = (WORD)dwPort;

    printf("Running setup test(Site = %u, Host = %ws, Port = %u)\n", dwSiteId, host.cstr(), wPort);

    //
    // try to request site info
    //
    HttpParser hp;
    hp.Init((BYTE *)g_achGetSiteInfoTS);
    if (hp.Parse(sizeof(g_achGetSiteInfoTS)) != HPS_DONE)
    {
        Assert(!"Premade HTTP Request failed to parse!");
        return;
    }

    hp.req.pbEntity = (BYTE *)&dwSiteId;

    TalkerContext ctx;
    memset(&ctx, 0, sizeof(ctx));
    hr = TalkerConnect(&ctx, host.cstr(), wPort);

    if (FAILED(hr))
    {
        printf("Couldn't connect to WebSG, hr = 0x%X\n", hr);
        return;
    }

    BYTE abResponse[sizeof(LspSiteInfo) + sizeof(LspKeyInfo)];
    UINT cbResponse = sizeof(abResponse);
    UINT cbRead     = 0;

    hr = TalkerSendRequest(&ctx, &hp.req, NULL, g_pcertctx);

    if (FAILED(hr))
    {
        printf("Failed to send request to WebSG, hr = 0x%X\n", hr);
        TalkerClose(&ctx);
        return;
    }

    do
    {
        hr = TalkerReadData(&ctx);
        if (FAILED(hr))
            break;

        UINT cbCopy = MIN(ctx.cbRead, cbResponse);
        memcpy(&abResponse[cbRead], ctx.abRead, cbCopy);
        cbRead     += cbCopy;
        cbResponse -= cbCopy;
    }
    while (cbResponse > 0);

    if (FAILED(hr))
    {
        printf("Failed to read response from WebSG, hr = 0x%X\n", hr);
        TalkerClose(&ctx);
        return;
    }

    LspSiteInfo * pSiteInfo = (LspSiteInfo *)abResponse;
    LARGE_INTEGER liTime;

    GetSystemTimeAsFileTime((LPFILETIME)&liTime);

    printf("Read %d keys, LSP time = %I64X, System time = %I64X\n", pSiteInfo->_cKeys, pSiteInfo->_liTime.QuadPart, liTime.QuadPart);

    TalkerClose(&ctx);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\parser.cpp ===
// parser.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.

#include "lhdp.h"

#define CONTENT_LENGTH_HEADER      "Content-Length"
#define CONTENT_LENGTH_HEADER_SIZE (sizeof(CONTENT_LENGTH_HEADER) - 1)

CHAR * FindSpace(CHAR * pch, UINT cch)
{
    for ( ; cch > 0; --cch, ++pch)
    {
        if (*pch == ' ')
            return(pch);
    }

    return(NULL);
}

UINT SkipSpace(CHAR * pch, UINT cch)
{
    UINT cWhite = 0;
    
    for ( ; cch > 0; --cch, ++pch, ++cWhite)
    {
        if (*pch != ' ')
            break;
    }

    return(cWhite);
}

UINT SkipTrailSpace(CHAR * pch, CHAR * pchEnd)
{
    UINT cWhite = 0;

    for (pchEnd = (pchEnd - 1); pchEnd > pch; --pchEnd, ++cWhite)
    {
        if (*pchEnd != ' ')
            break;
    }

    return(cWhite);
}

CHAR * FindCRLF(CHAR * pch, UINT cch)
{
    for ( ; cch > 1; --cch, ++pch)
    {
        if (*pch == '\r' && *(pch + 1) == '\n')
            return(pch);
    }

    return(NULL);
}

CHAR * FindColon(CHAR * pch, UINT cch)
{
    for ( ; cch > 1; --cch, ++pch)
    {
        if (*pch == ':')
            return(pch);
    }

    return(NULL);
}

void HttpParser::Init(BYTE * pb)
{
    memset(&req, 0, sizeof(req));
    _uiState = HPS_VERB;
    _pch     = (CHAR *)pb;
    _pbStart = pb;
}

UINT HttpParser::Parse(UINT cb)
{
    UINT cch = cb - ((BYTE *)_pch - _pbStart);
    Assert(cch <= cb);
    Assert(cch > 0);

    CHAR * pchEnd;

    while (cch > 0)
    {
        switch (_uiState)
        {
        case HPS_VERB:
        {
            UINT cWhite = SkipSpace(_pch, cch);
            _pch += cWhite;
            cch  -= cWhite;
            
            pchEnd = FindSpace(_pch, cch);

            if (pchEnd == NULL)
                return(_uiState);

            req.Verb.cch = pchEnd - _pch;
            req.Verb.pch = _pch;

            _pch  = pchEnd;
            cch  -= req.Verb.cch;

            _uiState = HPS_URL;
            
        }
        break;
        
        case HPS_URL:
        {
            UINT cWhite = SkipSpace(_pch, cch);
            _pch += cWhite;
            cch  -= cWhite;

            pchEnd = FindSpace(_pch, cch);

            if (pchEnd == NULL)
                return(_uiState);

            req.Url.cch = pchEnd - _pch;
            req.Url.pch = _pch;
            
            _pch  = pchEnd;
            cch  -= req.Url.cch;

            _uiState = HPS_VERSION;
        }
        break;
        
        case HPS_VERSION:
        {
            UINT cWhite = SkipSpace(_pch, cch);
            _pch += cWhite;
            cch  -= cWhite;

            pchEnd = FindCRLF(_pch, cch);

            if (pchEnd == NULL)
                return(_uiState);

            cWhite = SkipTrailSpace(_pch, pchEnd);

            req.Version.cch = pchEnd - _pch - cWhite;
            req.Version.pch = _pch;

            _pch  = pchEnd;
            cch  -= req.Version.cch;

            Assert(FindCRLF(_pch, cch) == _pch);
            _pch += 2;
            cch  -= 2;

            _uiState = HPS_HEADER;
        }
        break;
        
        case HPS_HEADER:
        {
            UINT cWhite = SkipSpace(_pch, cch);
            _pch += cWhite;
            cch  -= cWhite;

            if (req.cHeaders == 0)
            {
                req.AllHeaders.pch = _pch;
            }
            
            pchEnd = FindCRLF(_pch, cch);

            if (pchEnd == NULL)
                return(_uiState);

            if (pchEnd != _pch)
            {
                if (req.cHeaders == MAX_HTTP_HEADERS_PER_REQUEST)
                {
                    _uiState = HPS_ERROR;
                    return(_uiState);
                }
                
                CHAR * pchColon;

                for (pchColon = _pch; pchColon != pchEnd; ++pchColon)
                {
                    if (*pchColon == ':')
                        break;
                }

                if (pchColon == pchEnd)
                {
                    _uiState = HPS_ERROR;
                    return(_uiState);
                }

                HttpHeader * phdr = &req.aHeaders[req.cHeaders];

                phdr->Name.cch = pchColon - _pch;
                phdr->Name.pch = _pch;

                CHAR * pchValue = pchColon + 1;

                cWhite    = SkipSpace(pchValue, pchEnd - pchValue);
                pchValue += cWhite;

                cWhite = SkipTrailSpace(_pch, pchEnd);

                phdr->Value.cch = pchEnd - pchValue - cWhite;
                phdr->Value.pch = pchValue;

                cch  -= (pchEnd - _pch);
                _pch  = pchEnd;

                if (   phdr->Name.cch == CONTENT_LENGTH_HEADER_SIZE
                    && _strnicmp(phdr->Name.pch, CONTENT_LENGTH_HEADER, CONTENT_LENGTH_HEADER_SIZE) == 0)
                {
                    if (phdr->Value.cch > 10)
                    {
                        _uiState = HPS_ERROR;
                        return(_uiState);
                    }

                    CHAR ach[11];
                    memcpy(ach, phdr->Value.pch, phdr->Value.cch);
                    ach[phdr->Value.cch] = '\0';

                    LONGLONG ll = _atoi64(ach);

                    if (ll > 0xFFFFFFFF)
                    {
                        _uiState = HPS_ERROR;
                        return(_uiState);
                    }

                    req.cbEntity = (UINT)ll;
                }

                req.cHeaders += 1;

                Assert(FindCRLF(_pch, cch) == _pch);
                _pch += 2;
                cch  -= 2;
            }
            else
            {
                req.AllHeaders.cch = _pch - req.AllHeaders.pch;
                
                if (req.cbEntity > 0)
                {
                    Assert(FindCRLF(_pch, cch) == _pch);
                    _pch += 2;
                    cch  -= 2;
                        
                    _uiState = HPS_ENTITY;
                }
                else
                {
                    _uiState = HPS_DONE;
                    return(_uiState);
                }
            }
        }
        break;
            
        case HPS_ENTITY:
        {
            if (cch >= req.cbEntity)
            {
                req.pbEntity = (BYTE *)_pch;

                _uiState = HPS_DONE;
            }
            
            return(_uiState);
        }
        break;
            
        case HPS_DONE:  // fall through
        case HPS_ERROR: // fall through
        default:
            Assert(FALSE);
            _uiState = HPS_ERROR;
            break;
        }

    }

    return(_uiState);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\lspservice.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#define MAX_SERVICE_NAME        128
#define MAX_SERVICE_ACCT_PWD    128

//////////////////////////////////////////////////////////////////////////////
//
// Base class for an NT service that runs in its own process.
//
class CLspService
{
public:
    
    CLspService(
            LPCWSTR pszServiceName,
            LPCWSTR pszServiceDisplayName,
            LPCWSTR pszServiceDescription,
            LPCWSTR pszPerfBaseName,
            CComBSTR reserved
            ); 
    virtual ~CLspService();

    //
    // Call this function as the body of the service's main() routine.
    //
    DWORD ProcessMain( DWORD dwArgc, LPWSTR *pszArgv );

protected:
    
    DWORD ProcessCommandInstall(DWORD dwArgc, LPWSTR* pArgv);
    DWORD ProcessCommandUninstall(DWORD dwArgc, LPWSTR* pArgv);
    void PrintUsage();
    
    //
    // Utility function that determines if the service has been registered
    // with the SCM
    //
    BOOL IsServiceInstalled();

    //
    // Derived classes must implement this initialization method
    //
    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv ) = 0;

    //
    // Derived classes must do run their service in this routine
    //
    virtual HRESULT RunService( BOOL *pfServiceRan ) = 0;

    //
    // Derived classes can override this termination method
    //
    virtual void TermService();

    //
    // Handle all aspects of service installation
    //
    virtual DWORD Install();

    //
    // Handle all aspects of service uninstallation
    //
    virtual DWORD Uninstall();

    //
    // Register perfmon counters using perf DLL with same base name as the EXE
    //
    DWORD InstallCounters();

    //
    // Unregister any previously registered perfmon counters
    //
    DWORD UninstallCounters();

    //
    // Register the service with the SCM
    //
    DWORD InstallService();

    //
    // Unregister the service with the SCM
    //
    DWORD UninstallService();

    //
    // Grant the service account rights to logon as a service
    //
    virtual DWORD GrantLogonRights(LPCWSTR szAccount);

    //
    // Various service status reporting methods
    //
    DWORD ChangeState( DWORD dwState );

    DWORD Checkpoint( DWORD dwWaitHint = 0 );

    DWORD ReportError( DWORD dwErr );

    //
    // Runs the main thread of the service/console app
    //
    virtual void ServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    //
    // Called by the service control handler routine to process notifications
    // and commands from the SCM.
    //
    virtual void ServiceControlHandler( DWORD dwOpcode );

    //
    // Gives derived classes access to our shutdown notification event
    //
    HANDLE ShutdownEvent()
    {
        return( m_hevtShutdown );
    }

    //
    // Report installation progress/error
    //
    void InstallError( char* pszFmt, ... );
    void InstallInfo( char* pszFmt = NULL, ... );

private:
    static void WINAPI StaticServiceMain( DWORD dwArgc, LPWSTR *pszArgv );

    static void WINAPI StaticServiceControlHandler( DWORD dwOpcode );

    static BOOL WINAPI StaticConsoleCtrlHandler( DWORD dwCtrlType );

protected:
    WCHAR m_szServiceName       [ MAX_SERVICE_NAME ];
    WCHAR m_szServiceDisplayName[ MAX_SERVICE_NAME ];

    LPCWSTR m_pszServiceName;
    LPCWSTR m_pszServiceDisplayName;
    LPCWSTR m_pszServiceDescription;
    LPCWSTR m_pszPerfBaseName;

    BOOL m_fRunningAsService;

    HANDLE m_hevtShutdown;

    SERVICE_STATUS_HANDLE m_hServiceStatus;

    SERVICE_STATUS m_Status;

    LPWSTR m_pszInstallAccountName;
    LPWSTR m_pszInstallAccountPassword;
};

class CSIDLookup
{
public:
    CSIDLookup();
    ~CSIDLookup();

    HRESULT Lookup(LPCWSTR szAccount);
    PSID    GetPSID(void);

private:
    DWORD           m_cbSID;
    DWORD           m_cchRefDomainName;
    PSID            m_pSID;
    LPWSTR          m_szRefDomainName;
    SID_NAME_USE    m_SIDNameUse;
};

//////////////////////////////////////////////////////////////////////////////
//
// There must always be only one global service object; it is pointed to
// by the following global pointer;  the actual object can be a derived class.
//
extern CLspService *g_pService;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\util.cpp ===
// ----------------------------------------------------------------------------
// util.cpp
//
// lsphttpd's miscelaneous functions, structs and classes
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ----------------------------------------------------------------------------

#include "lhdp.h"

HANDLE CNtEventLog::_hApplicationLog = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\proxy.cpp ===
// proxy.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.

#include "lhdp.h"

struct
{
    CSmallStr       issuer;
    CSmallStr       subject;
    HCERTSTORE      hCertStore;
    PCCERT_CONTEXT  pCertCtx;
} g_Certificate;

UINT32 g_cThreads = 1;

BOOL CertInit(CConfig* pCfg)
{
    Assert(!g_Certificate.hCertStore);
    Assert(!g_Certificate.pCertCtx);
    
    CHAR      szCertName[1024];
    DWORD     dwErr;
    HRESULT   hr;
    BOOL      ok = FALSE;
    
    if(!pCfg->GetString("WebSg", "CertIssuer", &g_Certificate.issuer))
    {
        g_Certificate.issuer.CopyFrom("XBox Partners Authority");
    }

    if(!pCfg->GetString("WebSg", "CertSubject", &g_Certificate.subject))
    {
        g_Certificate.subject.Reset();
    }

    //
    // Read in the cert.
    //

    g_Certificate.hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                      0,
                                      NULL,
                                      CERT_SYSTEM_STORE_CURRENT_USER, 
                                      L"MY"
                                     );

    if (g_Certificate.hCertStore == NULL)
    {
        dwErr = GetLastError();
        hr    = HRESULT_FROM_WIN32(dwErr);
        NtEventLog(EVENT_CERT_ERROR, CSmallStr().Format(
                   "Couldn't open \"MY\" certificate store, hr = 0x%X", hr).cstr());
        goto exit;
    }

    // first try subject name lookup if we have one
    if (!g_Certificate.subject.IsEmpty())
    {
        g_Certificate.pCertCtx = CertFindCertificateInStore(
            g_Certificate.hCertStore, PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0,
            CERT_FIND_SUBJECT_STR_A, g_Certificate.subject.cstr(), NULL);

        if (g_Certificate.pCertCtx == NULL)
        {
            dwErr = GetLastError();
            hr    = HRESULT_FROM_WIN32(dwErr);
            NtEventLog(EVENT_CERT_ERROR, CSmallStr().Format( 
                       "Couldn't find certificate with subject \"%s\", hr = 0x%X", 
                       g_Certificate.subject.cstr(), hr).cstr());
            goto exit;
        }
    }

    // next try issuer string, we always have an issuer name
    if (g_Certificate.pCertCtx == NULL)
    {
        g_Certificate.pCertCtx = CertFindCertificateInStore(
            g_Certificate.hCertStore, PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0,
            CERT_FIND_ISSUER_STR_A, g_Certificate.issuer.cstr(), NULL);
    }

    if (g_Certificate.pCertCtx == NULL)
    {
        dwErr = GetLastError();
        hr    = HRESULT_FROM_WIN32(dwErr);
        NtEventLog(EVENT_CERT_ERROR, CSmallStr().Format( 
                   "Couldn't find certificate from \"%s\", hr = %X", 
                   g_Certificate.issuer.cstr(), hr).cstr());
        goto exit;
    }
    
    DWORD cch = CertNameToStr(g_Certificate.pCertCtx->dwCertEncodingType, &g_Certificate.pCertCtx->pCertInfo->Subject, 
                              CERT_SIMPLE_NAME_STR, szCertName, dimensionof(szCertName));

    if (cch == 0)
    {
        sprintf(szCertName, "could not read certificate name, error %d", GetLastError());
    }

    NtEventLog(EVENT_CONFIG_INFO, CSmallStr().Format(
               "The following certificate is going to be used: %s", szCertName).cstr());

    ok = TRUE;

exit:    

    if(!ok)
    {
        CertTerm();
    }

    return ok;
}

void CertTerm()
{
    if(g_Certificate.pCertCtx)
    {
        CertFreeCertificateContext(g_Certificate.pCertCtx);
        g_Certificate.pCertCtx   = NULL;
    }

    if(g_Certificate.hCertStore)
    {
        CertCloseStore(g_Certificate.hCertStore, 0);
        g_Certificate.hCertStore = NULL;
    }
}

ProxyContext * g_pproxyctx;
HANDLE         g_evtStart;
volatile BOOL  g_fShutdown;

CHAR g_achBadRequest[] = "HTTP/1.0 400 Bad Request\r\n"
                         "Server: LSP Proxy\r\n"
                         "\r\n";

CHAR g_achConnectionFailure[] = "HTTP/1.0 500 Could not connect to Live\r\n"
                                "Server: LSP Proxy\r\n"
                                "\r\n";

CHAR g_achCertificateFailure[] = "HTTP/1.0 500 Could not find certificate\r\n"
                                 "Server: LSP Proxy\r\n"
                                 "\r\n";

CHAR g_achResponseHeaderFailure[] = "HTTP/1.0 500 Could not read response from Live\r\n"
                                    "Server: LSP Proxy\r\n"
                                    "\r\n";

CHAR g_achResponseEntityFailure[] = "HTTP/1.0 500 Could not read response entity from Live\r\n"
                                    "Server: LSP Proxy\r\n"
                                    "\r\n";


UINT ProxyWorkerThreadProc(void * pv)
{
    ProxyContext *    pctx  = (ProxyContext *)pv;
    ListenerContext * plctx = &pctx->lctx;
    TalkerContext   * ptctx = &pctx->tctx;

    // wait for start event to be signalled
    WaitForSingleObject(g_evtStart, INFINITE);

    printf("Thread %d started.\n", pctx - g_pproxyctx);

    HttpParser              hp;
    UINT                    uiState;
    BOOL                    fOk;
    HRESULT                 hr;

    while (!g_fShutdown)
    {
        // receive a request

        hp.Init(plctx->abRequest);

        fOk = ListenerAcceptRequest(plctx);

        if (!fOk)
        {
            if (g_fShutdown)
                break;
            
            Sleep(1000);   // @@@ configuration
            continue;
        }
        
        do 
        {
            fOk = ListenerRecv(plctx);

            if (!fOk)
            {
                break;
            }
            
            uiState = hp.Parse(plctx->cbRequest);
        }
        while (uiState < HPS_DONE);

        if (!fOk)
        {
            ListenerClose(plctx);
            continue;
        }

        if (uiState == HPS_ERROR)
        {
            ListenerSend(plctx, sizeof(g_achBadRequest) - 1, (BYTE *)g_achBadRequest);
            ListenerClose(plctx);
            continue;
        }

        // send it to the widget

        if (ptctx->hcon == NULL)
        {
            hr = TalkerConnect(ptctx, pctx->szHost, pctx->wPort);
            if (FAILED(hr))
            {
                ListenerSend(plctx, sizeof(g_achConnectionFailure) - 1, (BYTE *)g_achConnectionFailure);
                ListenerClose(plctx);            
                continue;
            }
        }

        BOOL  fUseAlt  = (strncmp("/LiveProxy/", hp.req.Url.pch, MIN(hp.req.Url.cch,11)) != 0);
        PWSTR wzAltUrl = fUseAlt ? L"/LiveProxy/forwardrequest.aspx" : NULL;

        hr = TalkerSendRequest(ptctx, &hp.req, wzAltUrl, g_Certificate.pCertCtx);
        if (FAILED(hr))
        {
            ListenerSend(plctx, sizeof(g_achResponseHeaderFailure) - 1, (BYTE *)g_achResponseHeaderFailure);
            ListenerClose(plctx);
            TalkerClose(ptctx);
            continue;
        }
        
        do
        {
            printf("\nPROXY <-- LIVE\n");
            printf("%s", HexDumpStr(ptctx->abRead, ptctx->cbRead));

            fOk = ListenerSend(plctx, ptctx->cbRead, ptctx->abRead);
            if (!fOk)
            {
                // ignore this error so the response entity will be drained for the next request
                // on the connection.
            }
            
            hr = TalkerReadData(ptctx);
            if (FAILED(hr))
            {
                ListenerSend(plctx, sizeof(g_achResponseEntityFailure) - 1, (BYTE *)g_achResponseEntityFailure);
                ListenerClose(plctx);
                TalkerClose(ptctx);
                continue;
            }
        }
        while (ptctx->cbRead > 0);

        ListenerClose(plctx);
    }
    
    return(0);
}

BOOL ThreadsInit(CConfig* pCfg)
{
    HRESULT       hr;
    CVerySmallStr host;
    DWORD         dwPort;
    WORD          wPort;

    //
    // Read in configuration
    //

    if(!pCfg->GetString("WebSg", "HostName", &host))
    {
        NtEventLog(EVENT_CONFIG_ERROR, 
                   "The setting 'HostName' on section [WebSg] is missing or invalid");
        goto error;
    }

    host.Trim();

    if(host.GetLength() > ARRAY_SIZE(g_pproxyctx[0].szHost)-1)
    {
        NtEventLog(EVENT_CONFIG_ERROR, "HostName is too long");
        goto error;
    }

    if(!pCfg->GetUInt32("Global", "ThreadCount", (UINT32*)&g_cThreads))
    {
        // 1 thread seems more reasonable than 8; how much load do we really expect on the 
        // proxy?
        g_cThreads = 1;
    }
    else if (g_cThreads > MAX_PROXY_THREADS)  // max 8 is arbitrary
    {
        NtEventLog(EVENT_CONFIG_ERROR, CSmallStr().Format(
                   "ThreadCount must be less than or equal to %u (was %u)", MAX_PROXY_THREADS, g_cThreads).cstr());
        goto error;
    } 
    
    if(!pCfg->GetUInt32("WebSg", "Port", (UINT32*)&dwPort))
    {
        dwPort = 443;
    }
    else if (dwPort > 0xFFFF)
    {
        NtEventLog(EVENT_CONFIG_ERROR, CSmallStr().Format(
                   "Port must be less than 65535 (was %u)", dwPort).cstr());
        goto error;
    }

    
    wPort = (WORD)dwPort;
    
    NtEventLog(EVENT_CONFIG_INFO, CSmallStr().Format(
            "Requests will be forwarded to %s port %u. \nUsing %u threads.", host.cstr(), wPort, g_cThreads).cstr());

    Assert(g_pproxyctx == NULL);
    Assert(g_cThreads > 0 && g_cThreads <= MAX_PROXY_THREADS);
    g_pproxyctx = (ProxyContext *)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(ProxyContext) * g_cThreads);

    if (g_pproxyctx == NULL)
    {
        NtEventLog(EVENT_UNEXPECTED_ERROR, "Couldn't allocate memory for proxy contexts.");
        goto error;
    }

    for (UINT i = 0; i < g_cThreads; i++)
    {
        strcpy(g_pproxyctx[i].szHost, host.cstr());
        g_pproxyctx[i].wPort = wPort;

        g_pproxyctx[i].hThread = (HANDLE)_beginthreadex(NULL, 0, ProxyWorkerThreadProc, &g_pproxyctx[i], 0, NULL);
        if (g_pproxyctx[i].hThread == NULL)
        {
            DWORD dwErr = GetLastError();
            hr          = HRESULT_FROM_WIN32(dwErr);

            NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                       "Failed to start worker thread, hr = 0x%X", hr).cstr());
            
            goto error;
        }
    }

    return(TRUE);    

error:
    return(FALSE);
}

void ThreadsTerm()
{
    // @@@ set end event and wait for all threads to exit.

    if (g_pproxyctx != NULL)
    {
        for (UINT i = 0; i < g_cThreads; ++i)
        {
            if (g_pproxyctx[i].hThread != NULL)
            {
                ListenerClose(&g_pproxyctx[i].lctx);
                WaitForSingleObject(g_pproxyctx[i].hThread, 30 * 1000);    // @@@ configuration
                CloseHandle(g_pproxyctx[i].hThread);
            }
        }
    
        LocalFree(g_pproxyctx); // @@@ don't do this if threads are running
        g_pproxyctx = NULL;
    }
}

BOOL ProxyInit(CConfig* pCfg)
{
    BOOL fOk = TRUE;

    fOk = fOk && CertInit(pCfg);
    fOk = fOk && TalkerInit(pCfg);
    fOk = fOk && ListenerInit(pCfg);
    fOk = fOk && ThreadsInit(pCfg);

    return(fOk);
}

void ProxyTerm()
{
    g_fShutdown = TRUE;
    
    ListenerTerm();
    ThreadsTerm();
    TalkerTerm();
    CertTerm();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\util.h ===
// ----------------------------------------------------------------------------
// util.h
//
// lsphttpd's miscelaneous functions, structs and classes
//
// Copyright (C) Microsoft Corporation.  All rights reserved.
// ----------------------------------------------------------------------------

#pragma once

class CConfig
{
public:
    
    BOOL Init(LPCSTR szNameIniFile)
    {
        CHAR szFileName[MAX_PATH];
        DWORD cch;

        cch = GetModuleFileNameA(NULL, szFileName, ARRAY_SIZE(szFileName));
        if(!cch || cch > ARRAY_SIZE(szFileName))
        {
            OutputDebugStringA(CSmallStr().Format(
                              "GetModuleFileNameA failed. Error=%u", GetLastError()).cstr());
            return FALSE;
        }
        szFileName[ARRAY_SIZE(szFileName) - 1] = 0;

        char* pLastSlash = strrchr(szFileName, '\\');

        if(!pLastSlash)
        {
            OutputDebugStringA(CSmallStr().Format(
                               "Can't parse module file name '%s'", szFileName).cstr());
            return FALSE;
        }

        _nameIniFile.Reset();
        _nameIniFile.CopyFrom(szFileName, 0, (INT32)(pLastSlash-szFileName+1));
        _nameIniFile.CopyFrom(szNameIniFile);

        return TRUE;
    }

    BOOL GetString(LPCSTR szSection, LPCSTR szSetting, CStr* pValue)
    {
        if(!InternalGetString(szSection, szSetting, pValue))
        {
            // 
            // for backwards compability, try to find the setting again, this time with 
            // 'LspProxy.' prefixing the section name
            //

            return InternalGetString(CSmallStr().Format("LspProxy.%s", szSection).cstr(),
                                     szSetting, pValue);
        }

        return TRUE;
    }

    BOOL GetUInt32(LPCSTR szSection, LPCSTR szSetting, UINT32* pValue)
    {
        CSmallStr value;

        if(GetString(szSection, szSetting, &value))
        {
            char* pEndPtr = NULL;
            *pValue = (UINT32) strtoul(value.cstr(), &pEndPtr, 0);

            if(pEndPtr != NULL && *pEndPtr == 0)
            {
                return TRUE;
            }
            else
            {
                // string value is not a valid UINT32
                return FALSE;
            }
        }
        else
        {
            // setting not found or some error happened
            return FALSE;
        }
    }

    BOOL GetIp(LPCSTR szSection, LPCSTR szSetting, UINT32* pIp)
    {
        CSmallStr value;

        if(GetString(szSection, szSetting, &value))
        {
            *pIp = inet_addr(value.cstr());

            if(*pIp != 0)
            {
                return TRUE;
            }
            else
            {
                // string value is not a valid IP
                return FALSE;
            }
        }
        else
        {
            // setting not found or some error happened
            return FALSE;
        }
    }


protected:
    
    BOOL InternalGetString(LPCSTR szSection, LPCSTR szSetting, CStr* pValue)
    {
        Assert(_nameIniFile.GetLength() != 0);

        static const CHAR* not_found = "$#@";
        CHAR    szBuffer[2000];
        DWORD   cch;

        cch = GetPrivateProfileString(szSection, szSetting, not_found, 
                                      szBuffer, ARRAY_SIZE(szBuffer),
                                      _nameIniFile.cstr());

        if(cch == ARRAY_SIZE(szBuffer) - 1)
        {
            // string was truncated
            pValue->Reset();
            return FALSE;
        }

        if(cch > ARRAY_SIZE(szBuffer) - 1)
        {
            Assert(!"GetPrivateProfileString returned unexpected value size");
            pValue->Reset();
            return FALSE;
        }

        CConstStr value(szBuffer, cch);
        if(value.IsEqualTo(CSTR(not_found)))
        {
            // setting not found
            pValue->Reset();
            return FALSE;
        }

        pValue->CopyFrom(value);

        return TRUE;
    }

    CSmallStr _nameIniFile;

};

class CNtEventLog
{
public:

    static BOOL Init(LPCSTR sourceName)
    {
        _hApplicationLog = RegisterEventSourceA(NULL, sourceName);

        if(!_hApplicationLog)
        {
            OutputDebugString(CSmallStr().Format(
                    "RegisterEventSourceA failed. Error=%u", GetLastError()).cstr());
            return FALSE;
        }

        return TRUE;
    }

    static void Term()
    {
        if(_hApplicationLog)
        {
            DeregisterEventSource(_hApplicationLog);
        }
    }

    static void LogEvent(
        UINT32      eventId, 
        UINT32      cbData, 
        void*       pData, 
        LPCSTR      pszMessage
        )
    {
        BOOL ok;
        WORD eventType;
        LPCSTR stringArray[1];
    
        if(NT_INFORMATION(eventId))
        {
            eventType = EVENTLOG_INFORMATION_TYPE;
        }
        else if(NT_WARNING(eventId))
        {
            eventType = EVENTLOG_WARNING_TYPE;
        }
        else
        {
            eventType = EVENTLOG_ERROR_TYPE;
        }

        stringArray[0] = pszMessage;

        ok = ReportEventA(_hApplicationLog, eventType, 0 /* category */, eventId,
                          NULL /* lpUserSid */, ARRAY_SIZE(stringArray), 
                          cbData, stringArray, pData);

        if(!ok)
        {
            OutputDebugString(CSmallStr().Format(
                    "ReportEventA failed. Error=%u", GetLastError()).cstr());
        }
    }

    static BOOL Install(LPCSTR sourceName, LPCSTR eventDll)
    {
        BOOL ok;

        BOOL fRet    = FALSE;
        HKEY hKeyApp = NULL;
        HKEY hKeySub = NULL;
        CHAR szModuleName[MAX_PATH];
        CHAR szDrive[_MAX_DRIVE];
        CHAR szDir[_MAX_DIR];
        CHAR szEventDll[MAX_PATH];
        
        static const CHAR szSvcEventRoot[] = 
            "System\\CurrentControlSet\\Services\\EventLog\\Application\\";

        // Use the path to this module to build the path to the event dll which 
        // should be located in the same directory
        if(0 == ::GetModuleFileNameA(NULL, szModuleName, dimensionof(szModuleName)))
        {
            OutputDebugStringA(CSmallStr().Format(
                               "GetModuleFileName failed. Error = %u", 
                               GetLastError()).cstr());
            goto Exit;
        }
        
        szDrive[0]    = '\0';
        szDir[0]      = '\0';
        szEventDll[0] = '\0';
        _splitpath(szModuleName, szDrive, szDir, NULL, NULL);
        _snprintf(szEventDll, dimensionof(szEventDll), "%s%s%s", szDrive, szDir, 
            eventDll);
        
        // Open the eventlog\application regkey
        if(::RegOpenKeyA(HKEY_LOCAL_MACHINE, szSvcEventRoot, &hKeyApp) != ERROR_SUCCESS)
        {
            OutputDebugStringA(CSmallStr().Format(
                               "RegOpenKey failed. Error = %u", 
                               GetLastError()).cstr());
            goto Exit;
        }
        
        // Best effort to delete old key
        ::RegDeleteKeyA(hKeyApp, sourceName);
        
        // Create the source subkey. The source is the same string we pass to 
        // RegisterEventSource when we want to send events. It's also the string
        // that will show up in the source column on Event Viewer
        if(::RegCreateKeyA(hKeyApp, sourceName, &hKeySub) != ERROR_SUCCESS)
        {
            OutputDebugStringA(CSmallStr().Format(
                               "RegCreateKey failed. Error = %u", 
                               GetLastError()).cstr());
            goto Exit;
        }
        
        // Point events from sourceName to szEventDll
        if(::RegSetValueExA(hKeySub, "EventMessageFile", NULL,REG_SZ,(BYTE*)szEventDll, 
            strlen(szEventDll)+sizeof(CHAR)) != ERROR_SUCCESS)
        {
            OutputDebugStringA(CSmallStr().Format(
                               "RegSetValueEx failed. Error = %u", 
                               GetLastError()).cstr());
            goto Exit;
        }
        
        DWORD dwVal = 0x0000000b;
        if(::RegSetValueExA(hKeySub, "TypesSupported", NULL, REG_DWORD, 
            (BYTE*)&dwVal, sizeof(DWORD)) != ERROR_SUCCESS)
        {
            OutputDebugStringA(CSmallStr().Format(
                               "RegSetValueEx failed. Error = %u", 
                               GetLastError()).cstr());
            goto Exit;
        }
        
        fRet = TRUE;
        
    Exit:

        if(hKeyApp != NULL)
            ::RegCloseKey(hKeyApp);
        
        if(hKeySub != NULL)
            ::RegCloseKey(hKeySub);

        return fRet;
    }

protected:

    static HANDLE _hApplicationLog;
};

#define NtEventLog(eid, m) \
    CNtEventLog::LogEvent(eid, 0, NULL, m)

#define NtEventLogData(eid, cb, pb, m) \
    CNtEventLog::LogEvent(eid, cb, pb, m)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_lsphttpd_none_12.4.56.0_none_768a68ee19cba977
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lsphttpd
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.manifest
XP_MANIFEST_PATH=manifests\x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.cat
XP_CATALOG_PATH=manifests\x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.cat
XP_PAYLOAD_PATH=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lsphttpd,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_lsphttpd_none_12.4.56.0_none_768a68ee19cba977
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=lsphttpd
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.manifest
XP_MANIFEST_PATH=manifests\x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.cat
XP_CATALOG_PATH=manifests\x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9.cat
XP_PAYLOAD_PATH=x86_lsphttpd_no-public-key_12.4.56.0_x-ww_68c97da9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=lsphttpd,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\talker.cpp ===
// talker.cpp
//
// Copyright (C) Microsoft Corporation.  All rights reserved.

#include "lhdp.h"

BOOL TalkerInit(CConfig* pCfg)
{
    UNREFERENCED_PARAMETER(pCfg);
    
    return(TRUE);    
}

void TalkerTerm()
{
}

WCHAR * CStringToUnicode(UINT cchIn, const CHAR * pchIn, UINT cchOutMax, WCHAR * pwchOut)
{
    if ((cchIn + 1) > cchOutMax)
        return(NULL);

    for (UINT i = 0; i < cchIn; i++)
    {
        *pwchOut++ = pchIn[i];
    }
    *pwchOut++ = L'\0';
    
    return(pwchOut);
}

WCHAR * HttpStringToUnicode(HttpString hs, UINT cchOutMax, WCHAR * pwchOut)
{
    return CStringToUnicode(hs.cch, hs.pch, cchOutMax, pwchOut);
}

#define XRL_HEADER_NAME         L"XRL: "
#define CCHXRLHEADERNAME        (sizeof(XRL_HEADER_NAME)/sizeof(WCHAR) - 1)
#define CBXRLHEADERNAME         (sizeof(XRL_HEADER_NAME) - sizeof(WCHAR))

#define CONNECTION_HEADER      "Connection"
#define CONNECTION_HEADER_SIZE (sizeof(CONNECTION_HEADER) - 1)

BOOL HttpReqToTalkerReq(HttpRequest * phttpreq, TalkerRequest * ptalkreq, PWSTR pwzAltUrl)
{
    WCHAR * pwch    = ptalkreq->awchAux;
    WCHAR * pwchEnd = pwch + CCHAUXBUFFER;

    ptalkreq->pwzVerb = pwch;
    pwch              = HttpStringToUnicode(phttpreq->Verb, pwchEnd - pwch, pwch);
    
    if (pwch == NULL)
        return(FALSE);

    // Move headers. The SG <-> PROXY connection uses "Connection: Close" semantics, while 
    // the PROXY <-> WEBSG connection uses "Connection: Keep-Alive". We need to fix that 
    // up. WinHttp will not overwrite an existing "Connection:" header. But if that header 
    // doesn't exist, then WinHttp will insert the appropriate one.

    CLargeStr strHeaders;
    for (DWORD idxHeader = 0; idxHeader < phttpreq->cHeaders; idxHeader++)
    {
        HttpString hdrName = phttpreq->aHeaders[idxHeader].Name;
        HttpString hdrValue = phttpreq->aHeaders[idxHeader].Value;

        // Ignore the "Connection" header
        if (hdrName.cch == CONNECTION_HEADER_SIZE && 
            _strnicmp(hdrName.pch, CONNECTION_HEADER, CONNECTION_HEADER_SIZE) == 0)
        {
            continue;
        }

        strHeaders.CopyFrom(hdrName.pch, 0, hdrName.cch);
        strHeaders.CopyFrom(": ");
        strHeaders.CopyFrom(hdrValue.pch, 0, hdrValue.cch);
        strHeaders.CopyFrom("\r\n");
    }

    // Stripping the "Connection: Close" is sufficient. But if we needed to insert our own 
    // header, this is how it would be done:
    //strHeaders.Format("Connection: Keep-Alive\r\n");

    // Copy headers over and convert to unicode
    ptalkreq->cchHeaders  = strHeaders.GetLength();
    ptalkreq->pwchHeaders = pwch;
    pwch                  = CStringToUnicode(strHeaders.GetLength(), strHeaders.cstr(), pwchEnd - pwch, pwch);
    
    if (pwch == NULL)
        return(FALSE);
    
    if (pwzAltUrl != NULL)
    {
        // this has to happen right after the headers are generated so we
        // can append the XRL: header.

        --pwch;         // remove trailing NUL from last string
        
        if (CCHXRLHEADERNAME > (pwchEnd - pwch))
            return(FALSE);

        memcpy(pwch, XRL_HEADER_NAME, CBXRLHEADERNAME);
        pwch += CCHXRLHEADERNAME;

        pwch = HttpStringToUnicode(phttpreq->Url, pwchEnd - pwch, pwch);
        if (pwch == NULL)
            return(FALSE);

        --pwch;         // remove trailing NUL from last string
        
        if (3 > (pwchEnd - pwch))
            return(FALSE);

        *pwch++ = L'\r';
        *pwch++ = L'\n';
        *pwch++ = L'\0';

        ptalkreq->cchHeaders += CCHXRLHEADERNAME + phttpreq->Url.cch + 2;

        ptalkreq->pwzUrl = pwzAltUrl;
    }
    else
    {
        ptalkreq->pwzUrl = pwch;
        pwch             = HttpStringToUnicode(phttpreq->Url, pwchEnd - pwch, pwch);
        
        if (pwch == NULL)
            return(FALSE);

    }


    ptalkreq->cbEntity = phttpreq->cbEntity;
    ptalkreq->pbEntity = phttpreq->pbEntity;

    printf("\nPROXY --> LIVE\n");
    printf("%S %S\n", ptalkreq->pwzVerb, ptalkreq->pwzUrl);
    printf("%S", ptalkreq->pwchHeaders);
    printf("%s", HexDumpStr(ptalkreq->pbEntity, ptalkreq->cbEntity));
    
    return(TRUE);
}


HRESULT TalkerConnect(TalkerContext * pctx, PCSTR pszHost, WORD wPort)
{
    Assert(!pctx->hses);

    HRESULT hr = S_OK;
    CVerySmallWStr host;
    BOOL ok = FALSE;

    pctx->hses = WinHttpOpen(L"LSP Proxy", // @@@ would be nice to work in VER_PRODUCTVERSION_STR
                             WINHTTP_ACCESS_TYPE_NO_PROXY, //WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 
                             NULL,  NULL, 0 );
    
    if (pctx->hses == NULL)
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "CWinHttpMgr::Initialize:  Failed to create connection pool. "
                   "HR = 0x%X", hr).cstr());
        
        goto Exit;
    }

    host.Format(L"%S", pszHost);
    pctx->hcon = WinHttpConnect( pctx->hses, host.cstr(), wPort, 0 );

    if (pctx->hcon == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        NtEventLog(EVENT_NETWORK_ERROR, CSmallStr().Format(
                   "WinHttpConnect host=%s failed, hr = 0x%X", pszHost, hr).cstr());

        goto Exit;
    }

    ok = TRUE;

Exit:

    if(!ok)
    {
        TalkerClose(pctx);
        hr = FAILED(hr) ? hr : E_UNEXPECTED;
    }
    
    return(hr);
}

void TalkerClose(TalkerContext * pctx)
{
    if (pctx->hreq != NULL)
    {
        WinHttpCloseHandle(pctx->hreq);
        pctx->hreq = NULL;
    }
    
    if (pctx->hcon != NULL)
    {
        WinHttpCloseHandle(pctx->hcon);
        pctx->hcon = NULL;
    }

    if (pctx->hses != NULL)
    {
        WinHttpCloseHandle(pctx->hses);
        pctx->hses = NULL;
    }
}

HRESULT TalkerSendRequest(TalkerContext * pctx, HttpRequest * preq, PWSTR pwzProxyUrl, PCCERT_CONTEXT pcertctx)
{
    HRESULT hr = S_OK;
    BOOL fOk;

    Assert(pctx->hcon != NULL);
    Assert(pctx->hreq == NULL);

    if (pctx->hreq != NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "TalkerSendRequest failed, hr = 0x%X", hr).cstr());
        goto error;
    }

    if (!HttpReqToTalkerReq(preq, &pctx->req, pwzProxyUrl))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "TalkerSendRequest failed, hr = 0x%X", hr).cstr());
        goto error;
    }

    pctx->hreq = WinHttpOpenRequest(pctx->hcon, pctx->req.pwzVerb, pctx->req.pwzUrl,
                                    L"HTTP/1.1", WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES,
                                    (pcertctx == NULL) ? 0 : WINHTTP_FLAG_SECURE);

    if (pctx->hreq == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                "WinHttpOpenRequest failed, hr = 0x%X", hr).cstr());
        goto error;
    }

    fOk = WinHttpSendRequest(pctx->hreq, pctx->req.pwchHeaders, pctx->req.cchHeaders,
                             pctx->req.pbEntity, pctx->req.cbEntity, pctx->req.cbEntity,
                             (DWORD_PTR)pctx);

    if (!fOk)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "WinHttpSendRequest failed, hr = 0x%X", hr).cstr());
        goto error;
    }

    fOk = WinHttpReceiveResponse(pctx->hreq, NULL);

    if (!fOk)
    {
        // The server may request a certificate. If so, let's supply one and retry the 
        // request. WinHttp will cache this certificate, so in theory we should only hit 
        // this code path once.
        if (GetLastError() == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED &&
            pcertctx != NULL)
        {
            printf("Server requires certificate, supplying one and retrying...\n");

            fOk = WinHttpSetOption(pctx->hreq, WINHTTP_OPTION_CLIENT_CERT_CONTEXT,
                                   (void *)pcertctx, sizeof(CERT_CONTEXT));

            if (!fOk)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                        "WinHttpSetOption failed, hr = 0x%X", hr).cstr());
                goto error;
            }

            fOk = WinHttpSendRequest(pctx->hreq, pctx->req.pwchHeaders, pctx->req.cchHeaders,
                                     pctx->req.pbEntity, pctx->req.cbEntity, pctx->req.cbEntity,
                                     (DWORD_PTR)pctx);

            if (!fOk)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                        "WinHttpSendRequest failed, hr = 0x%X", hr).cstr());
                goto error;
            }

            fOk = WinHttpReceiveResponse(pctx->hreq, NULL);

            if (!fOk)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                        "WinHttpReceiveResponse failed, hr = 0x%X", hr).cstr());
                goto error;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                    "WinHttpReceiveResponse failed, hr = 0x%X", hr).cstr());
            goto error;
        }
    }

    DWORD cbRead = sizeof(pctx->abRead);
    
    fOk = WinHttpQueryHeaders(pctx->hreq, WINHTTP_QUERY_RAW_HEADERS_CRLF,
                              WINHTTP_HEADER_NAME_BY_INDEX,
                              pctx->abRead, &cbRead,
                              WINHTTP_NO_HEADER_INDEX);
    
    if (!fOk)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "WinHttpQueryHeaders failed, hr = 0x%X", hr).cstr());
        goto error;
    }

    WCHAR * pwch = (WCHAR *)pctx->abRead;
    CHAR *  pch  = (CHAR *)pctx->abRead;
    UINT    cch  = cbRead / 2;
    
    for (UINT i = 0; i < cch; ++i)
        *pch++ = (CHAR)*pwch++;

    pctx->cbRead = cch;

    return(hr);

error:
    
    if (pctx->hreq != NULL)
    {
        WinHttpCloseHandle(pctx->hreq);
        pctx->hreq = NULL;
    }

    return(hr);
}

HRESULT TalkerReadData(TalkerContext * pctx)
{
    HRESULT hr = S_OK;
    BOOL    fOk;

    fOk = WinHttpReadData(pctx->hreq, pctx->abRead, sizeof(pctx->abRead), &pctx->cbRead);
    if (!fOk)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        NtEventLog(EVENT_UNEXPECTED_ERROR, CSmallStr().Format(
                   "WinHttpReadData failed, hr = 0x%X", hr).cstr());
        WinHttpCloseHandle(pctx->hreq);
        pctx->hreq = NULL;
    }
    else if (pctx->cbRead == 0)
    {
        WinHttpCloseHandle(pctx->hreq);
        pctx->hreq = NULL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\obj\i386\events.h ===
/*--

Copyright (c) Microsoft Corporation

Notes:

    This file is generated by the MC tool from the events.mc file.

--*/

#pragma once

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_INIT_INFO
//
// MessageText:
//
// LspHttpd has started. 
// %1
//
#define EVENT_INIT_INFO                  0x40000001L

//
// MessageId: EVENT_SHUTDOWN_INFO
//
// MessageText:
//
// LspHttpd has shutdown. 
// %1
//
#define EVENT_SHUTDOWN_INFO              0x40000002L

//
// MessageId: EVENT_CONFIG_INFO
//
// MessageText:
//
// %1
//
#define EVENT_CONFIG_INFO                0x40000003L

//
// MessageId: EVENT_CONFIG_WARNING
//
// MessageText:
//
// %1
//
#define EVENT_CONFIG_WARNING             0x80000004L

//
// MessageId: EVENT_CONFIG_ERROR
//
// MessageText:
//
// A configuration error was encountered: 
// 
// %1 
// 
// Please verify the configuration file lsphttpd.ini. It should be located in the same 
// directory as the directory of lsphttpd.exe. All settings mentioned in configuration 
// events are relative to the [LspProxy] section.
//
#define EVENT_CONFIG_ERROR               0xC0000065L

//
// MessageId: EVENT_CERT_ERROR
//
// MessageText:
//
// LspHttpd failed to initialize client certificate: 
// 
// %1 
// 
// Most errors related to the certificate have to do with the certificate not being installed correctly or to certificate settings in lsphttpd.ini not matching the corresponding certificate attributes. Please verify that the certificate is installed correctly on the store of the user that lsphttpd.exe is configured to run as, and that the certificate attributes are specified correctly in lsphttpd.ini.
//
#define EVENT_CERT_ERROR                 0xC0000066L

//
// MessageId: EVENT_INIT_ERROR
//
// MessageText:
//
// LspHttpd encountered an error during initialization: 
// 
// %1
//
#define EVENT_INIT_ERROR                 0xC0000067L

//
// MessageId: EVENT_NETWORK_ERROR
//
// MessageText:
//
// LspHttpd encountered a network error: 
// 
// %1
//
#define EVENT_NETWORK_ERROR              0xC0000068L

//
// MessageId: EVENT_UNEXPECTED_ERROR
//
// MessageText:
//
// LspHttpd encountered a unexpected error: 
// 
// %1
//
#define EVENT_UNEXPECTED_ERROR           0xC0000069L

//
// MessageId: EVENT_SERVER_NOT_ALLOWED
//
// MessageText:
//
// LspHttpd denied access to a server because its address not in the allowed list specified in lsphttpd.ini
// 
// %1
//
#define EVENT_SERVER_NOT_ALLOWED         0x8000006AL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\proxy\objd\i386\events.h ===
/*--

Copyright (c) Microsoft Corporation

Notes:

    This file is generated by the MC tool from the events.mc file.

--*/

#pragma once

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_INIT_INFO
//
// MessageText:
//
// LspHttpd has started. 
// %1
//
#define EVENT_INIT_INFO                  0x40000001L

//
// MessageId: EVENT_SHUTDOWN_INFO
//
// MessageText:
//
// LspHttpd has shutdown. 
// %1
//
#define EVENT_SHUTDOWN_INFO              0x40000002L

//
// MessageId: EVENT_CONFIG_INFO
//
// MessageText:
//
// %1
//
#define EVENT_CONFIG_INFO                0x40000003L

//
// MessageId: EVENT_CONFIG_WARNING
//
// MessageText:
//
// %1
//
#define EVENT_CONFIG_WARNING             0x80000004L

//
// MessageId: EVENT_CONFIG_ERROR
//
// MessageText:
//
// A configuration error was encountered: 
// 
// %1 
// 
// Please verify the configuration file lsphttpd.ini. It should be located in the same 
// directory as the directory of lsphttpd.exe. All settings mentioned in configuration 
// events are relative to the [LspProxy] section.
//
#define EVENT_CONFIG_ERROR               0xC0000065L

//
// MessageId: EVENT_CERT_ERROR
//
// MessageText:
//
// LspHttpd failed to initialize client certificate: 
// 
// %1 
// 
// Most errors related to the certificate have to do with the certificate not being installed correctly or to certificate settings in lsphttpd.ini not matching the corresponding certificate attributes. Please verify that the certificate is installed correctly on the store of the user that lsphttpd.exe is configured to run as, and that the certificate attributes are specified correctly in lsphttpd.ini.
//
#define EVENT_CERT_ERROR                 0xC0000066L

//
// MessageId: EVENT_INIT_ERROR
//
// MessageText:
//
// LspHttpd encountered an error during initialization: 
// 
// %1
//
#define EVENT_INIT_ERROR                 0xC0000067L

//
// MessageId: EVENT_NETWORK_ERROR
//
// MessageText:
//
// LspHttpd encountered a network error: 
// 
// %1
//
#define EVENT_NETWORK_ERROR              0xC0000068L

//
// MessageId: EVENT_UNEXPECTED_ERROR
//
// MessageText:
//
// LspHttpd encountered a unexpected error: 
// 
// %1
//
#define EVENT_UNEXPECTED_ERROR           0xC0000069L

//
// MessageId: EVENT_SERVER_NOT_ALLOWED
//
// MessageText:
//
// LspHttpd denied access to a server because its address not in the allowed list specified in lsphttpd.ini
// 
// %1
//
#define EVENT_SERVER_NOT_ALLOWED         0x8000006AL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\http.h ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Server Lib HTTP Wrapper functions and associated definitions.

Module Name:

    http.h

--*/
#ifndef __HTTP_H
#define __HTTP_H

HRESULT XOnlineServerHttpPost(
    DWORD               dwServiceID,
    DWORD               dwTitleID,
    LPCWSTR             szTargetPath, 
    PBYTE               pbBuffer,
    DWORD               *pcbBuffer, 
    PBYTE               pbExtraHeaders,
    DWORD               cbExtraHeaders,
    PBYTE               pbDataToUpload,
    DWORD               cbDataToUpload,
    DWORD               dwTimeout
    );

#endif // __HTTP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\lspservr.cpp ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Implements entry point when this code is compiled as a DLL

Module Name:

    xonservr.cpp

--*/

#include "precomp.h"
#include <stdio.h>


BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD dwReason, LPVOID lpvReserved)
{
    if( DLL_PROCESS_ATTACH == dwReason )
    {
        DisableThreadLibraryCalls( hDLLInst );
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\http.cpp ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Module implementing generic HTTP routines on top of WinHTTP

Module Name:

    match.cpp

--*/

#include "precomp.h"
#include <stdio.h>
#include <xboxverp.h>

#define SERVICES_SECTION    L"SERVICES"
#define NULL_CHAR           L'\0'
#define BACKSLASH_CHAR      L'\\'
#define CONFIG_FILE_NAME    L"lspservr.ini"

#define MAX_SERVICE_IP_LEN 32
#define MAX_SERVICE_INFOS  4

typedef struct
{
    DWORD           dwServiceID;
    HINTERNET       hSession;
    WCHAR           szServiceIP[MAX_SERVICE_IP_LEN];
    INTERNET_PORT   nServerPort;
}
SERVICE_INFO, *PSERVICE_INFO;

//
//  Globals
//

bool                g_bInitialized = false;
LPCWSTR             g_szConfigFileName = CONFIG_FILE_NAME;
SERVICE_INFO        g_ServiceInfo[ MAX_SERVICE_INFOS ];
DWORD               g_cServiceInfos = 0;
WCHAR               g_szMatchContentType[16];
WCHAR               g_szContentTypeHeader[64];


//
// Simple array accessor methods
//
BOOL InsertServiceInfo( DWORD dwServiceID, SERVICE_INFO servInfo )
{
    if( g_cServiceInfos >= MAX_SERVICE_INFOS )
    {
        return( FALSE );
    }

    g_ServiceInfo[ g_cServiceInfos ] = servInfo;
    g_ServiceInfo[ g_cServiceInfos++ ].dwServiceID = dwServiceID;

    return( TRUE );
}

SERVICE_INFO *LookupServiceInfo( DWORD dwServiceID )
{
    for( DWORD i = 0; i < g_cServiceInfos; i++ )
    {
        if( g_ServiceInfo[ i ].dwServiceID == dwServiceID )
        {
            return( &g_ServiceInfo[ i ] );
        }
    }

    return( NULL );
}


//
//  Create a WinHTTP session handle for the specified service.
//

HINTERNET GetHttpSession(
    DWORD   dwServiceID
    )
{
    HINTERNET   hSession;
    WCHAR       szUserAgent[32];

    //
    //  Format the user agent string
    //

    _snwprintf(szUserAgent, 31, L"%d/%S", dwServiceID, VER_PRODUCTVERSION_STR);
    szUserAgent[31] = L'\0';

    //
    //  Initialize a WinHttp session
    //

    hSession = WinHttpOpen(szUserAgent,
                       WINHTTP_ACCESS_TYPE_NO_PROXY,
                       NULL,
                       NULL,
                       0);

    return hSession;
}

//
//  Load the current configuration.
//

HRESULT LoadConfiguration()
{
    HRESULT hr = S_OK;
    WCHAR   szConfigFilePath[MAX_PATH];
    WCHAR   szServiceKeys[256];
    LPWSTR  sz;
    LPWSTR  szCurKey;

    //
    //  First get path of executing module
    //

    if(GetModuleFileNameW(NULL, 
                          szConfigFilePath, 
                          sizeof(szConfigFilePath)/sizeof(WCHAR)) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Make config file path
    //

    sz = wcsrchr(szConfigFilePath, BACKSLASH_CHAR);
    if(sz != NULL)
    {
        ++sz;
        lstrcpyW(sz, g_szConfigFileName);
    }
    else
    {
        lstrcpyW(szConfigFilePath, g_szConfigFileName);
    }

    //
    //  Read in the keys from the SERVICES section so we can enumerate them.
    //

    if(GetPrivateProfileStringW(SERVICES_SECTION, 
                                NULL, 
                                NULL, 
                                szServiceKeys, 
                                sizeof(szServiceKeys)/sizeof(WCHAR), 
                                szConfigFilePath) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Now for each key in the SERVICES section, read in the service ip/port
    //  Make sure that each key is a number
    //

    szCurKey = szServiceKeys;
    while(*szCurKey != NULL_CHAR)
    {
        LPWSTR  szEndPtr;
        ULONG ulServiceID = wcstoul(szCurKey, &szEndPtr, 10);

        //
        //  If the terminating character was not null, then the key name contained non-numeric chars.
        //

        if(*szEndPtr == NULL_CHAR)
        {
            WCHAR                           szServiceIP[MAX_SERVICE_IP_LEN];
            SERVICE_INFO                    ServiceInfo;

            // szCurKey points to a valid number, read in the IP string
            GetPrivateProfileStringW(SERVICES_SECTION, szCurKey, NULL, szServiceIP, MAX_SERVICE_IP_LEN, szConfigFilePath);

            ServiceInfo.hSession = GetHttpSession(ulServiceID);
            if(ServiceInfo.hSession != NULL)
            {
                LPWSTR szPort = wcschr(szServiceIP, L':');
                if(szPort == NULL)
                {
                    ServiceInfo.nServerPort = 80;
                }
                else
                {
                    *(szPort++) = L'\0';
                    ServiceInfo.nServerPort = (INTERNET_PORT)wcstoul(szPort, &szEndPtr, 10);
                    if(szEndPtr == szPort)
                        ServiceInfo.nServerPort = 80;
                }

                lstrcpynW(ServiceInfo.szServiceIP, szServiceIP, MAX_SERVICE_IP_LEN);

                InsertServiceInfo( ulServiceID, ServiceInfo );
            }
        }

        //
        //  Next key
        //

        szCurKey = wcschr(szCurKey, NULL_CHAR);
        if(szCurKey == NULL)
            break;

        ++szCurKey;
    }


Cleanup:

    return hr;
}


HINTERNET HttpConnect(
    HINTERNET       hSession,
    LPCWSTR         szServer,
    INTERNET_PORT   nServerPort
    )
{
    HINTERNET   hConnection;
    
    hConnection = WinHttpConnect(hSession,
                                 szServer,
                                 nServerPort,
                                 0);

    return hConnection;
}


HRESULT XOnlineServerInitialize()
{
    HRESULT hr;

    if(g_bInitialized == true)
    {
        hr = S_OK;
        goto Cleanup;
    }

    //
    //  Read the configuration file
    //

    hr = LoadConfiguration();

    //
    //  Format content type string
    //

    swprintf(g_szMatchContentType, L"xon/%d", XONLINE_MATCHMAKING_SERVICE);
    swprintf(g_szContentTypeHeader, L"Content-Type: xon/%d\r\n", XONLINE_MATCHMAKING_SERVICE);

Cleanup:

    if(hr == S_OK)
        g_bInitialized = true;

    return hr;
}


void XOnlineServerShutdown()
{
    if(!g_bInitialized)
        return;

    for( DWORD i = 0; i < g_cServiceInfos; i++ )
    {
        WinHttpCloseHandle( g_ServiceInfo[ i ].hSession );
    }

    g_cServiceInfos = 0;
    memset( g_ServiceInfo, 0, sizeof( g_ServiceInfo ) );

    g_bInitialized = false;
}


HRESULT XOnlineServerHttpPost(
    DWORD               dwServiceID,
    DWORD               dwTitleID,
    LPCWSTR             szTargetPath, 
    PBYTE               pbBuffer,
    DWORD               *pcbBuffer, 
    PBYTE               pbExtraHeaders,
    DWORD               cbExtraHeaders,
    PBYTE               pbDataToUpload,
    DWORD               cbDataToUpload,
    DWORD               dwTimeout
    )
{
    HRESULT         hr;
    HINTERNET       hConnection = NULL;
    HINTERNET       hRequest    = NULL;
    DWORD           dwBufLen;
    DWORD           dwStatusCode;
    DWORD           dwBytesAvailable;

    static LPCWSTR  ppszAcceptTypes[] = { g_szMatchContentType, NULL };
    static DWORD    dwOptions = WINHTTP_DISABLE_KEEP_ALIVE |
                                WINHTTP_DISABLE_REDIRECTS |
                                WINHTTP_DISABLE_COOKIES |
                                WINHTTP_DISABLE_AUTHENTICATION;

    //
    //  Look up the service info
    //

    SERVICE_INFO* pServiceInfo = LookupServiceInfo(dwServiceID);
    if(pServiceInfo == NULL)
    {
        hr = XONLINE_E_INVALID_SERVICE_ID;
        goto Cleanup;
    }

    //
    //  Connect to the server, getting back a connection handle
    //

    hConnection = HttpConnect(pServiceInfo->hSession, 
                              pServiceInfo->szServiceIP,
                              pServiceInfo->nServerPort);
    if(hConnection == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Create and initialize the request
    //

    
    hRequest = WinHttpOpenRequest(hConnection,
                                  L"POST",
                                  szTargetPath,
                                  L"HTTP/1.0",
                                  NULL,
                                  ppszAcceptTypes,
                                  0);
    if(hRequest == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  Disable keep-alive, cookies, redirects, auth
    //

    if(!WinHttpSetOption(hRequest, 
                         WINHTTP_OPTION_DISABLE_FEATURE,
                         (LPVOID)&dwOptions,
                         sizeof(DWORD)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    // Set the same timeout for all the different request stages.
    //

    if(!WinHttpSetTimeouts(hRequest,
                            dwTimeout,
                            dwTimeout,
                            dwTimeout,
                            dwTimeout))
    {
        DWORD dwError = GetLastError();
        hr = E_FAIL;
        goto Cleanup;
    }

    WCHAR szHeaders[sizeof(g_szContentTypeHeader) + sizeof("Title-Id: FFFFFFFF")];
    swprintf(szHeaders, L"Title-Id: %X\r\n%ws", dwTitleID, g_szContentTypeHeader);

    if(!WinHttpSendRequest(hRequest,
                           szHeaders,
                           -1,
                           (LPVOID)pbDataToUpload,
                           cbDataToUpload,
                           cbDataToUpload,
                           0))
    {
        DWORD dwError = GetLastError();
        hr = E_FAIL;
        goto Cleanup;
    }

    if(!WinHttpReceiveResponse(hRequest, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    dwBufLen = sizeof(DWORD);
    if(!WinHttpQueryHeaders(hRequest,
                            WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                            NULL,
                            &dwStatusCode,
                            &dwBufLen,
                            NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    //
    //  If the returned status code is 500, then look for an X-Err header
    //

    if(dwStatusCode == 500)
    {
        WCHAR szErrBuf[32];
        dwBufLen = sizeof(szErrBuf);

        if(WinHttpQueryHeaders(hRequest,
                               WINHTTP_QUERY_CUSTOM,
                               L"X-Err",
                               szErrBuf,
                               &dwBufLen,
                               NULL))
            hr = wcstoul(szErrBuf, NULL, 16);
        else
            hr = E_FAIL; // Didn't get an X-Err header, generic failure code.

        goto Cleanup;
    }

    //
    //  If status code is not 200, bail.
    //

    if(dwStatusCode != 200)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

#if 0 
    // BUGBUG: this piece of code makes this function unusable by other services other than Match. 
    //         Besides that, IIS will not return the content type if the content-size is 0, so even if we fix this
    //         to work with other services it will still break on some conditions.

    //
    //  Find and verify content type
    //

    {
        WCHAR szContentTypeBuf[256];

        dwBufLen = sizeof(szContentTypeBuf);
        if(!WinHttpQueryHeaders(hRequest,
                                WINHTTP_QUERY_CONTENT_TYPE,
                                NULL,
                                szContentTypeBuf,
                                &dwBufLen,
                                NULL))
        {
            DWORD dwError = GetLastError();
            hr = E_FAIL;
            goto Cleanup;
        }

        if(lstrcmpW(szContentTypeBuf, g_szMatchContentType) != 0)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
#endif


    //  Read the response into the provided buffer.

    if(pbBuffer != NULL)
    {
        DWORD cbWritten = 0;

        for(;;)
        {
            if(!WinHttpQueryDataAvailable(hRequest, &dwBytesAvailable))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }

            if( dwBytesAvailable != 0 // If there is more data available
                && *pcbBuffer - cbWritten > 0 // and there is still buffer left
            )
            {
                DWORD dwBytesRead;

                WinHttpReadData(hRequest, 
                                pbBuffer + cbWritten, 
                                __min(dwBytesAvailable, *pcbBuffer - cbWritten), 
                                &dwBytesRead);
                
                cbWritten += dwBytesRead;
            }
            else
            {
                break;
            }
        }

        *pcbBuffer = cbWritten;
    }

    hr = S_OK;

Cleanup:

    if(hRequest)
        WinHttpCloseHandle(hRequest);
    if(hConnection)
        WinHttpCloseHandle(hConnection);

    return hr;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\precomp.h ===
#pragma once
#ifndef __PRECOMP_H
#define __PRECOMP_H

#include <winsockx.h>
#include <windows.h>
#include <stdlib.h>

#include <winhttp.h>

#include <xonlinep.h>

#include "lspservr.h"
#include "http.h"

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\lspservr.h ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Game server library definitions and prototypes.

Module Name:

    xonservr.h

--*/

#ifndef __XONSERVR_H
#define __XONSERVR_H

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack1.h>


//////////////////////////////////////////////////////////////////////////////
//
// Xbox Matchmaking definitions
//

//
//  Attribute definition structure
//

#ifndef __XONLINE__ // if xonlinep.h is included, we already have this definition

//  Errors returned by matchmaking
#define XONLINE_E_MATCH_INVALID_SESSION_ID             _HRESULT_TYPEDEF_(0x80155100L)  // specified session id does not exist
#define XONLINE_E_MATCH_INVALID_TITLE_ID               _HRESULT_TYPEDEF_(0x80155101L)  // specified title id is zero, or does not exist
#define XONLINE_E_MATCH_INVALID_DATA_TYPE              _HRESULT_TYPEDEF_(0x80155102L)  // attribute ID or parameter type specifies an invalid data type
#define XONLINE_E_MATCH_REQUEST_TOO_SMALL              _HRESULT_TYPEDEF_(0x80155103L)  // the request did not meet the minimum length for a valid request
#define XONLINE_E_MATCH_REQUEST_TRUNCATED              _HRESULT_TYPEDEF_(0x80155104L)  // the self described length is greater than the actual buffer size
#define XONLINE_E_MATCH_INVALID_SEARCH_REQ             _HRESULT_TYPEDEF_(0x80155105L)  // the search request was invalid
#define XONLINE_E_MATCH_INVALID_OFFSET                 _HRESULT_TYPEDEF_(0x80155106L)  // one of the attribute/parameter offsets in the request was invalid.  Will be followed by the zero based offset number.
#define XONLINE_E_MATCH_INVALID_ATTR_TYPE              _HRESULT_TYPEDEF_(0x80155107L)  // the attribute type was something other than user or session
#define XONLINE_E_MATCH_INVALID_VERSION                _HRESULT_TYPEDEF_(0x80155108L)  // bad protocol version in request
#define XONLINE_E_MATCH_OVERFLOW                       _HRESULT_TYPEDEF_(0x80155109L)  // an attribute or parameter flowed past the end of the request
#define XONLINE_E_MATCH_INVALID_RESULT_COL             _HRESULT_TYPEDEF_(0x8015510AL)  // referenced stored procedure returned a column with an unsupported data type
#define XONLINE_E_MATCH_INVALID_STRING                 _HRESULT_TYPEDEF_(0x8015510BL)  // string with length-prefix of zero, or string with no terminating null
#define XONLINE_E_MATCH_STRING_TOO_LONG                _HRESULT_TYPEDEF_(0x8015510CL)  // string exceeded 400 characters
#define XONLINE_E_MATCH_BLOB_TOO_LONG                  _HRESULT_TYPEDEF_(0x8015510DL)  // blob exceeded 800 bytes
#define XONLINE_E_MATCH_PUID_MISMATCH                  _HRESULT_TYPEDEF_(0x8015510EL)  // PUIDS did not match in attribute when added/changing players in a session
#define XONLINE_E_MATCH_INVALID_PLAYER                 _HRESULT_TYPEDEF_(0x8015510FL)  // player is not in the current session
#define XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID           _HRESULT_TYPEDEF_(0x80155110L)  // attribute id is invalid
#define XONLINE_E_MATCH_PLAYER_ALREADY_EXISTS          _HRESULT_TYPEDEF_(0x80155111L)  // player already exists in the db
#define XONLINE_E_MATCH_SESSION_ALREADY_EXISTS         _HRESULT_TYPEDEF_(0x80155112L)  // session id already exists in the db
#define XONLINE_E_MATCH_NO_TITLES                      _HRESULT_TYPEDEF_(0x80155113L)  // no titles in the db
#define XONLINE_E_MATCH_TITLE_ALREADY_EXISTS           _HRESULT_TYPEDEF_(0x80155114L)  // title already exists in the db
#define XONLINE_E_MATCH_CRITICAL_DB_ERR                _HRESULT_TYPEDEF_(0x80155115L)  // critical error in db
#define XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS             _HRESULT_TYPEDEF_(0x80155116L)  // search result set had too few columns
#define XONLINE_E_MATCH_PERMISSION_DENIED              _HRESULT_TYPEDEF_(0x80155117L)  // incorrect permissions set on search sp
#define XONLINE_E_MATCH_INVALID_PART_SCHEME            _HRESULT_TYPEDEF_(0x80155118L)  // title specified an invalid partitioning scheme
#define XONLINE_E_MATCH_INVALID_PARAM                  _HRESULT_TYPEDEF_(0x80155119L)  // bad parameter passed to sp
#define XONLINE_E_MATCH_USE_SETPLAYER_PROC             _HRESULT_TYPEDEF_(0x8015511AL)  // attempt to use p_match_set_int_attribute to add/change player in session
#define XONLINE_E_MATCH_PLAYER_REQUIRED                _HRESULT_TYPEDEF_(0x8015511BL)  // attempt to set a per-player attribute with invalid PUID
#define XONLINE_E_MATCH_PLAYER_NOT_NEEDED              _HRESULT_TYPEDEF_(0x8015511CL)  // attempt to set a session attribute with non-zero PUID
#define XONLINE_E_MATCH_DATA_TYPE_MISMATCH             _HRESULT_TYPEDEF_(0x8015511DL)  // data type specified in attr id did not match type of attr being set
#define XONLINE_E_MATCH_SERVER_ERROR                   _HRESULT_TYPEDEF_(0x8015511EL)  // error on server not correctable by client
#define XONLINE_E_MATCH_NO_USERS                       _HRESULT_TYPEDEF_(0x8015511FL)  // no authenticated users in search request.
#define XONLINE_E_MATCH_INVALID_BLOB                   _HRESULT_TYPEDEF_(0x80155120L)  // invalid blob attribute


typedef struct _XONLINE_ATTRIBUTE
{
    DWORD dwAttributeID;
    BOOL fChanged;
    union {
        struct {
            ULONGLONG      qwValue;
        } integer;
        struct {
            LPWSTR         lpValue;
        } string;
        struct {
            PVOID          pvValue;
            DWORD          dwLength;
        } blob;
    } info;
} XONLINE_ATTRIBUTE, *PXONLINE_ATTRIBUTE;

#define X_MAX_STRING_ATTRIBUTE_LEN         400
#define X_MAX_BLOB_ATTRIBUTE_LEN           800

#define X_ATTRIBUTE_SCOPE_MASK             0x80000000
#define X_ATTRIBUTE_SCOPE_GLOBAL           0x80000000
#define X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC   0x00000000

#define X_ATTRIBUTE_DATATYPE_MASK          0x00F00000
#define X_ATTRIBUTE_DATATYPE_INTEGER       0x00000000
#define X_ATTRIBUTE_DATATYPE_STRING        0x00100000
#define X_ATTRIBUTE_DATATYPE_BLOB          0x00200000
#define X_ATTRIBUTE_DATATYPE_NULL          0x00F00000

#define X_ATTRIBUTE_ID_MASK                0x0000FFFF

typedef struct
{
    BYTE ab[8];
} XNKID;

#endif

//
//  Session definition structure.
//

typedef struct _XONLINE_SERVER_SESSION
{
    DWORD   dwTitleID;
    IN_ADDR HostAddress;
    WORD    wHostPort;
    XNKID   SessionID;
} XONLINE_SERVER_SESSION, *PXONLINE_SERVER_SESSION;

//
//  APIs
//

HRESULT __stdcall XOnlineServerInitialize(void);
void __stdcall XOnlineServerShutdown(void);

HRESULT __stdcall XOnlineServerSessionCreate(
    IN OUT  PXONLINE_SERVER_SESSION pServerSession,
    IN      DWORD                   dwPublicFilled,
    IN      DWORD                   dwPublicOpen,
    IN      DWORD                   dwPrivateFilled,
    IN      DWORD                   dwPrivateOpen,
    IN      DWORD                   dwNumAttributes,
    IN      PXONLINE_ATTRIBUTE      pAttributes,
    IN      DWORD                   dwReserved
    );

HRESULT __stdcall XOnlineServerSessionUpdate(
    IN      PXONLINE_SERVER_SESSION pServerSession,
    IN      DWORD                   dwPublicFilled,
    IN      DWORD                   dwPublicOpen,
    IN      DWORD                   dwPrivateFilled,
    IN      DWORD                   dwPrivateOpen,
    IN      DWORD                   dwNumAttributes,
    IN      PXONLINE_ATTRIBUTE      pAttributes,
    IN      DWORD                   dwReserved
    );

HRESULT __stdcall XOnlineServerSessionDelete(
    IN      PXONLINE_SERVER_SESSION pServerSession,
    IN      DWORD                   dwReserved
    );


//////////////////////////////////////////////////////////////////////////////
//
// Xbox Security Gateway (SG) auth protocol definitions
//

#define XONLINE_MAX_LOGON_USERS     4
#define XONLINE_MAX_NUMBER_SERVICE_PER_TICKET  12
#define XONLINE_SG_MESSAGE_PORT     0xFFFF

#define SGMSG_TYPE_AUTHDATA_REQ     0x4700
#define SGMSG_TYPE_AUTHDATA_REP     0x4701
#ifndef __XONLINE__ // if xonlinep.h is included, we already have this definition
#define SGMSG_TYPE_AUTHDATA         0x4780
#define XONLINE_AUTHDATA_VERSION    1
#endif

#define XONLINE_USER_COUNTRY_MASK           0x0000ff00
#define XONLINE_USER_GUEST_MASK             0x00000003
#define XONLINE_USER_VOICE_NOT_ALLOWED      0x00010000
#define XONLINE_USER_PURCHASE_NOT_ALLOWED   0x00020000
#define XONLINE_USER_NICKNAME_NOT_ALLOWED   0x00040000

#define XOnlineIsUserVoiceAllowed(dwUserFlags)      (((dwUserFlags) & XONLINE_USER_VOICE_NOT_ALLOWED) == 0)
#define XOnlineIsUserPurchaseAllowed(dwUserFlags)   (((dwUserFlags) & XONLINE_USER_PURCHASE_NOT_ALLOWED) == 0)
#define XOnlineIsUserNicknameAllowed(dwUserFlags)   (((dwUserFlags) & XONLINE_USER_NICKNAME_NOT_ALLOWED) == 0)
#define XOnlineIsUserGuest(dwUserFlags)             (((dwUserFlags) & XONLINE_USER_GUEST_MASK) != 0)
#define XOnlineUserGuestNumber(dwUserFlags)         ((dwUserFlags) & XONLINE_USER_GUEST_MASK)
#define XOnlineUserCountryId(dwUserFlags)           ((BYTE)(((dwUserFlags) & XONLINE_USER_COUNTRY_MASK) >> 8))


//
// SG Auth protocol description
//
// A game server sends the SG_AUTH_REQUEST message in a UDP datagram to the
// data center (DMZ) IP address from which a new client connection originates,
// but targeted to the XONLINE_SG_MESSAGE_PORT.  The dwReqNum used should be
// unique for this particular client connection, as to avoid confusing responses.
// If no response is received within 2 seconds, the message should be retransmitted.
//
// The Security Gateway will respond back to the sending socket's IP:port with a
// UDP datagram containing either an SG_AUTH_RESPONSE (if the referenced client is
// no longer connected) with fNotFound = TRUE, or SG_AUTH_RESPONSE + XBOX_AUTHDATA
// (if the client info was found).
//
// Use SGInitAuthRequest to properly fill in the request message before sending.
//
// Use SGParseAuthResponse to validate and understand the basic information from
// a Security Gateway response packet.  Make sure to double-check via dwReqNum
// which request this response is for.  The XOnlineIsUserXXX and XOnlineUserXXX
// macros above can be used to check for particular properties of each user.
//
typedef struct _SG_AUTH_REQUEST
{
    WORD  wType;        // == SGMSG_TYPE_AUTHDATA_REQ
    WORD  cbRequest;    // == sizeof( SG_AUTH_REQUEST )
    DWORD dwReqNum;     // auth request cookie, passed back in response
    DWORD dwIpaZ;       // Data center (DMZ) IP address of incoming client
    WORD  wPortZ;       // Data center (DMZ) port of incoming client
} SG_AUTH_REQUEST;

typedef struct _SG_AUTH_RESPONSE
{
    WORD  wType;        // == SGMSG_TYPE_AUTHDATA_REP
    WORD  cbResponse;   // == sizeof( SG_AUTH_RESPONSE )
    DWORD dwReqNum;     // same value as request's dwReqNum field
    DWORD dwIpaZ;       // Data center (DMZ) IP address for this auth data
    WORD  wPortZ;       // Data center (DMZ) port for this auth data
    WORD  wPortI;       // Internet port of the Xbox (as seen by the SG)
    DWORD dwIpaI;       // Internet IP of the Xbox (as seen by the SG)
    BYTE  sgaddr[20];
    BYTE  fNotFound;    // If true, this client is no longer connected to the SG
                        // If false, there is an XBOX_AUTHDATA structure immediately
                        // following this response structure containing client info.
} SG_AUTH_RESPONSE;

#ifndef __XONLINE__ // if xonlinep.h is included, we already have this definition

typedef struct _XUID
{
    ULONGLONG qwUserID; // Xbox User Account ID
    DWORD dwUserFlags;  // See XONLINE_USER_ definitions above
} XUID;

#endif

typedef struct _XBOX_AUTHDATA
{
    WORD        wType;                  // == SGMSG_TYPE_AUTHDATA
    WORD        cbAuthData;             // == sizeof( XBOX_AUTHDATA )
    WORD        wAuthDataVersion;       // == XONLINE_AUTHDATA_VERSION
    WORD        wAuthDataSize;
    WORD        wMajorVersion;          // | These four fields indicate the client's XBE
    WORD        wMinorVersion;          // | version information.
    WORD        wBuildNumber;           // |
    WORD        wQFENumber;             // |
    DWORD       dwTitleID;              //  | These three fields indicate the client's
    DWORD       dwTitleVersion;         //  | title and version info.
    DWORD       dwTitleRegion;          //  |
    ULONGLONG   qwXboxID;               // Client Xbox Machine Account ID
    XUID        users[XONLINE_MAX_LOGON_USERS];     // Info on up to four users or guests
    DWORD       dwNumServices;          // How many service IDs are in the next array
    DWORD       dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
} XBOX_AUTHDATA;


//
// APIs
//
HRESULT __stdcall SGInitAuthRequest(
    IN  DWORD               dwReqNum,           // Unique cookie value used to match up responses
    IN  IN_ADDR             ipaZ,               // Data center IP address in question
    IN  WORD                wPortZ,             // Data center port in question
    OUT SG_AUTH_REQUEST    *pReq
    );

HRESULT __stdcall SGParseAuthResponse(
    IN  DWORD               cbResponseData,     // Response packet payload size
    IN  const BYTE         *pbResponseData,     // Response packet payload data
    OUT DWORD              *pdwReqNum,          // Request cookie value to match this response against
    OUT BOOL               *pfClientWasFound,   // Was this address:port still connected?
    OUT OPTIONAL IN_ADDR   *pipaI,              // Internet IP of the Xbox (as seen by the SG)
    OUT OPTIONAL WORD      *pwPortI,            // Internet port of the Xbox (as seen by the SG)
    OUT OPTIONAL ULONGLONG *pqwXboxID,          // Xbox Machine Account ID
    OUT OPTIONAL XUID      *pUser1,             // User info for controller #1
    OUT OPTIONAL XUID      *pUser2,             // User info for controller #2
    OUT OPTIONAL XUID      *pUser3,             // User info for controller #3
    OUT OPTIONAL XUID      *pUser4              // User info for controller #4
    );

#include <poppack.h>

#ifdef __cplusplus
}
#endif

#endif // __XONSERVR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\match.cpp ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Module implementing game server Xbox Matchmaking APIs

Module Name:

    match.cpp

--*/

#include "precomp.h"

BOOL IsValidAttributeID(DWORD dwAttributeID, BOOL fSessionCreate);

BOOL ValidateAttributeIDs(
    IN DWORD dwNumAttributes,
    IN const XONLINE_ATTRIBUTE* pAttributes,
    IN BOOL fSessionCreate
    );

//
// Server configuration information for matchmaking POST requests
// to front doors.
//
typedef struct
{
    DWORD dwService;                  // Service ID number
    WCHAR * szUrl;                    // relative URL of ISAPI front door
} XMATCH_SERVERS, *PXMATCH_SERVERS;

const XMATCH_SERVERS g_MatchServers[3] =
{
    { XONLINE_MATCHMAKING_SERVICE, L"/xmatch/xmatchhost.srf",      },
    { XONLINE_MATCHMAKING_SERVICE, L"/xmatch/xmatchclient.srf",    },
    { XONLINE_MATCHMAKING_SERVICE, L"/xmatch/xmatchhostdelete.srf" }
};

enum SERVER_TYPE
{
    serverMatchHost = 0,
    serverMatchClient,
    serverMatchHostDelete
};

//
// Timeout for POST requests.  After 30 seconds, requests will timeout with a failure.
//
#define DW_POST_TIMEOUT         30000

//
// Defines for attribute information.  Makes it easier to incorporate changes to these types.
//
#define ATTRIBUTE_OFFSET_TYPE        DWORD
#define ATTRIBUTE_ID_TYPE            DWORD
#define ATTRIBUTE_STRING_LENGTH_TYPE WORD
#define ATTRIBUTE_BLOB_LENGTH_TYPE   WORD

//
// Type of matchmaking request
//
enum XMATCH_TYPE
{
    xmatchCreate = 0,                           // Session creation/advertisment
    xmatchSearch,                               // Session search
    xmatchDelete                                // Session delete
};

//
// Extended task handle structure
//
typedef struct
{
    XMATCH_TYPE          Type;                  // Type of matchmaking request
    XNKID                SessionID;             // Session ID of new session                               
    DWORD                dwResponseCode;        // Response from server
    BYTE                 *pbResultsBuffer;      // Buffer of search results
    UINT                  cbResultsBufferAlloc; // Allocated size of results buffer
    BYTE                 *pbBuffer;             // Send buffer
} XMATCH_HANDLE, *PXMATCH_HANDLE;

//
// Write an Attribute Offset and increment the pointer to next Attribute offset
//
#define WriteAndIncAttributeOffset(pdwOffset, pbOffset) { *pdwOffset = (DWORD) pbOffset; pdwOffset += 1; }

//
// Write an Attribute ID and increment the pointer to next Attribute ID
//
#define WriteAndIncAttributeID(pByte, dwAttributeID)    { *((DWORD *)pByte) = dwAttributeID; pByte += sizeof(DWORD); }

//
// Write an Integer Attribute and increment the pointer to next Integer Attribute
//
#define WriteAndIncInt(pByte, qwInt)                    { *((ULONGLONG *)pByte) = qwInt; pByte += sizeof(ULONGLONG); }

//
// Write an Attribute String Length and increment the pointer to next Attribute String Length
//
#define WriteAndIncStringLen(pByte, cLength)            { *((ATTRIBUTE_STRING_LENGTH_TYPE *)pByte) = cLength; pByte += sizeof(ATTRIBUTE_STRING_LENGTH_TYPE); }

//
// Write an Attribute Blob Length and increment the pointer to next Attribute Blob Length
//
#define WriteAndIncBlobLen(pByte, cLength)              { *((ATTRIBUTE_BLOB_LENGTH_TYPE *)pByte) = cLength; pByte += sizeof(ATTRIBUTE_BLOB_LENGTH_TYPE); }

//
// Retrieve the Attribute ID
//
#define GetAttributeID(pByte)                           *((DWORD *) pByte)

//
// Retrieve the Attribute String Size
//
#define GetAttributeStringSize(pByte)                   *((ATTRIBUTE_STRING_LENGTH_TYPE *) (pByte+sizeof(DWORD)))

//
// Retrieve the Attribute Blob Size
//
#define GetAttributeBlobSize(pByte)                     *((ATTRIBUTE_BLOB_LENGTH_TYPE *) (pByte+sizeof(DWORD)))

//
// Return TRUE if the SessionID specified is not Zero
//
// Note:  This assumes that XNKID will always be a ULONGLONG type.  If this
// ever changes, we have to modify this.
//
#define IsSessionIDAvailable(SessionID)              (*((ULONGLONG *) &SessionID) != 0)

//
// Debug signature for extra validation
//
#define XMATCH_SIGNATURE                             'XMAT'
#define IsValidXMatchHandle(TaskHandle)             (((PXMATCH_HANDLE)TaskHandle)->dwSignature == XMATCH_SIGNATURE)              

//
//  Global constants
//

const XNKID g_SessionIDCreate = { XNET_XNKID_ONLINE_SERVER, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const XNKID g_SessionIDNull   = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

//---------------------------------------------------------------------------
//
// TotalAttributeSize
//
// Private API.
//
// Calculate size of all attributes, including attribute offsets and
// attribute IDs.
//
HRESULT TotalAttributeSize(
    IN  DWORD dwNumAttributes,
    IN  PXONLINE_ATTRIBUTE pAttributes,
    OUT DWORD& dwTotalAttributeSize
    )
{
    HRESULT hr;
    DWORD i = 0;

    dwTotalAttributeSize = 0;

    //
    // Loop through all attributes and add size of attribute to dwSize.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        if (pAttributes[i].fChanged == FALSE)
        {
            continue;
        }

        dwTotalAttributeSize += sizeof(ATTRIBUTE_OFFSET_TYPE) + sizeof(ATTRIBUTE_ID_TYPE);
        
        switch (pAttributes[i].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
        {
            case X_ATTRIBUTE_DATATYPE_INTEGER:
            {
                //
                // Integer attributes are just a ULONGLONG
                //
                dwTotalAttributeSize += sizeof(ULONGLONG);

                break;
            }

            case X_ATTRIBUTE_DATATYPE_STRING:
            {
                //
                // String attributes are string length + UTF8 string, including NULL.
                //
                if(IsBadStringPtr(pAttributes[i].info.string.lpValue, X_MAX_STRING_ATTRIBUTE_LEN * 4))
                {
                    hr = E_POINTER;
                    goto Cleanup;
                }

                dwTotalAttributeSize += sizeof(ATTRIBUTE_STRING_LENGTH_TYPE) + WideCharToMultiByte( CP_UTF8, 0, pAttributes[i].info.string.lpValue, lstrlenW(pAttributes[i].info.string.lpValue)+1, NULL, 0, NULL, NULL );

                break;
            }

            case X_ATTRIBUTE_DATATYPE_BLOB:
            {
                //
                // Blob attributes are blob length + size of blob
                //
                if(IsBadReadPtr(pAttributes[i].info.blob.pvValue, pAttributes[i].info.blob.dwLength))
                {
                    hr = E_POINTER;
                    goto Cleanup;
                }

                dwTotalAttributeSize += sizeof(ATTRIBUTE_BLOB_LENGTH_TYPE) + pAttributes[i].info.blob.dwLength;

                break;
            }

            default:
            {
                // BUGBUG: Get rid of this case.  Do validation at top of every public function
                ////Assert(FALSE);
                break;
            }
        }
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//---------------------------------------------------------------------------
//
// WriteAttributes
//
// Private API.
//
// Function to write attributes to message buffer.  It assumes that the
// message buffer is big enough to hold all attributes.
//
HRESULT WriteAttributes(
    IN PBYTE pbBufferStart,               // Beginning of buffer, used to calculate offsets
    IN DWORD dwNumAttributes,             // Number of attributes
    IN PXONLINE_ATTRIBUTE pAttributes,    // Array of attribute structures
    IN DWORD *pdwAttributeOffset,         // Pointer to beginning of attribute offsets
    IN PBYTE pbAttribute                  // Pointer to beginning of attributes
    )
{
    HRESULT hr;
    DWORD   i = 0;
    DWORD   dwUTF8Length = 0;

    //
    // Loop through all attributes
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        //
        // Only write an attribute to the buffer if it has changed (fChanged == TRUE).
        // In the case of a session CREATE request, all of the fChanged flags are set to
        // true before calling this function.
        //
        if (pAttributes[i].fChanged == TRUE)
        {
            //
            // Reset the fChanged flag so we know which flags have changed since the last update.
            //
            pAttributes[i].fChanged = FALSE;

            //
            // Write the actual attributes to the buffer
            //
            switch (pAttributes[i].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
            {
                case X_ATTRIBUTE_DATATYPE_INTEGER:
                {
                    //
                    // Write the attribute offset and increment the pointer to the next attribute offset
                    //
                    WriteAndIncAttributeOffset(pdwAttributeOffset, (pbAttribute - pbBufferStart));

                    //
                    // Write the integer attribute ID and the integer.  Increment
                    // the pointer to the next attribute.
                    //
                    WriteAndIncAttributeID(pbAttribute, pAttributes[i].dwAttributeID);
                    WriteAndIncInt(pbAttribute, pAttributes[i].info.integer.qwValue);

                    break;
                }

                case X_ATTRIBUTE_DATATYPE_STRING:
                {
                    if(pAttributes[i].info.string.lpValue == NULL)
                    {
                        hr = XONLINE_E_MATCH_INVALID_STRING;
                        goto Cleanup;
                    }

                    if(lstrlenW(pAttributes[i].info.string.lpValue) > X_MAX_STRING_ATTRIBUTE_LEN)
                    {
                        hr = XONLINE_E_MATCH_STRING_TOO_LONG;
                        goto Cleanup;
                    }

                    //
                    // Write the attribute offset and increment the pointer to the next attribute offset
                    //
                    WriteAndIncAttributeOffset(pdwAttributeOffset, (pbAttribute - pbBufferStart));

                    //
                    // Calculate the length of the UTF8 string.
                    //
                    dwUTF8Length = WideCharToMultiByte( CP_UTF8, 0, pAttributes[i].info.string.lpValue, lstrlenW(pAttributes[i].info.string.lpValue)+1, NULL, 0, NULL, NULL );
                    //
                    // Write the string attribute ID
                    //
                    WriteAndIncAttributeID(pbAttribute, pAttributes[i].dwAttributeID);

                    //
                    // Write the string length
                    //
                    WriteAndIncStringLen(pbAttribute, (ATTRIBUTE_STRING_LENGTH_TYPE) (dwUTF8Length));

                    //
                    // Write the UTF8 string
                    //
                    WideCharToMultiByte( CP_UTF8, 0, pAttributes[i].info.string.lpValue, lstrlenW(pAttributes[i].info.string.lpValue)+1, (LPSTR)pbAttribute, dwUTF8Length, NULL, NULL );

                    //
                    // Increment the pointer to the next attribute
                    //
                    pbAttribute += dwUTF8Length;

                    break;
                }
                                              
                case X_ATTRIBUTE_DATATYPE_BLOB:
                {
                    if(pAttributes[i].info.blob.pvValue == NULL)
                    {
                        hr = XONLINE_E_MATCH_INVALID_BLOB;
                        goto Cleanup;
                    }

                    if(pAttributes[i].info.blob.dwLength > X_MAX_BLOB_ATTRIBUTE_LEN)
                    {
                        hr = XONLINE_E_MATCH_BLOB_TOO_LONG;
                        goto Cleanup;
                    }

                    //
                    // Write the attribute offset and increment the pointer to the next attribute offset
                    //
                    WriteAndIncAttributeOffset(pdwAttributeOffset, (pbAttribute - pbBufferStart));

                    //
                    // Write the blob attribute ID
                    //
                    WriteAndIncAttributeID(pbAttribute, pAttributes[i].dwAttributeID);

                    //
                    // Write the blob length
                    //
                    WriteAndIncBlobLen(pbAttribute, (ATTRIBUTE_BLOB_LENGTH_TYPE) pAttributes[i].info.blob.dwLength);

                    //
                    // If the blob specified is not NULL, write the blob and increment the pointer to the next attribute
                    //
                    if (pAttributes[i].info.blob.pvValue != NULL)
                    {
                        memcpy( pbAttribute, pAttributes[i].info.blob.pvValue, pAttributes[i].info.blob.dwLength );
                        pbAttribute += pAttributes[i].info.blob.dwLength;
                    }

                    break;
                }

                default:
                {
                    // BUGBUG: Should never get here since the attribute list has been validated already
                    break;
                }
            }
        }
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//---------------------------------------------------------------------------
//
// SessionCreate
//
// Private API.  Called by MatchSessionCreate() and MatchSessionUpdate().
//
// Function to open a session creation request.
//
HRESULT SessionCreate(
    IN OUT PXONLINE_SERVER_SESSION pServerSession,
    IN DWORD dwPublicFilled,
    IN DWORD dwPublicOpen,
    IN DWORD dwPrivateFilled,
    IN DWORD dwPrivateOpen,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN DWORD dwReserved
    )
{
    HRESULT                 hr                     = S_OK;
    LPBYTE                  pbRequest              = NULL;
    LPBYTE                  pbResponse             = NULL;
    PXMATCH_SESSION         pHeader                = NULL;
    DWORD                   dwRequestLength        = 0;
    DWORD                   dwResponseLength       = 0;
    DWORD                   dwNumUpdatedAttributes = 0;
    DWORD                   dwCurAttr;

    //
    // Determine how big the message buffer should be to hold complete post
    // request.
    //

    //
    // Count the number of attributes with the fChanged flag set to TRUE.
    //
    for (dwCurAttr = 0; dwCurAttr < dwNumAttributes; ++dwCurAttr)
    {
        if (pAttributes[dwCurAttr].fChanged == TRUE)
        {
            dwNumUpdatedAttributes += 1;
        }
    }

    hr = TotalAttributeSize(dwNumAttributes, pAttributes, dwRequestLength);
    if(FAILED(hr))
        goto Cleanup;

    dwRequestLength += sizeof(XMATCH_SESSION);

    //
    //  Allocate the request buffer.
    //
    pbRequest = (LPBYTE)LocalAlloc(LPTR, dwRequestLength);
    if(pbRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Fill in session create protocol structure
    //
    pHeader = (PXMATCH_SESSION) pbRequest;

    pHeader->dwMessageLength         = dwRequestLength;
    pHeader->dwTitleID               = pServerSession->dwTitleID;
    pHeader->HostAddress.inaOnline   = pServerSession->HostAddress;
    pHeader->HostAddress.wPortOnline = pServerSession->wHostPort;

    //
    // Initially set public and private available slots to zero.
    //
    pHeader->dwPublicOpen  = dwPublicOpen;
    pHeader->dwPrivateOpen = dwPrivateOpen;
    pHeader->dwPublicFilled    = dwPublicFilled;
    pHeader->dwPrivateFilled   = dwPrivateFilled;
    pHeader->dwNumAttributes    = dwNumUpdatedAttributes;

    //
    //  Is this a session create request?  If so, pass in a buffer to receive the session id and key.
    //

    if(memcmp(&pServerSession->SessionID, &g_SessionIDNull, sizeof(XNKID)) == 0)
    {
        CopyMemory(&pHeader->SessionID, &g_SessionIDCreate, sizeof(XNKID));

        dwResponseLength = sizeof(XMATCH_SESSION_INFO);
        pbResponse = (LPBYTE)LocalAlloc(LPTR, sizeof(XMATCH_SESSION_INFO));
    }
    else
    {
        CopyMemory(&pHeader->SessionID, &pServerSession->SessionID, sizeof(XNKID));

        dwResponseLength = 0;
        pbResponse = NULL;
    }


    //
    // Call function that will parse session attributes and add them to our POST request buffer
    //
    hr = WriteAttributes(pbRequest, 
                         dwNumAttributes, 
                         pAttributes, 
                         (DWORD *) (pbRequest + sizeof(XMATCH_SESSION)), 
                         pbRequest + sizeof(XMATCH_SESSION) + (dwNumUpdatedAttributes * sizeof(ATTRIBUTE_OFFSET_TYPE)));
    if(FAILED(hr))
        goto Cleanup;

    //
    // POST our session creation request.  Timeout after 30 seconds.
    //
    hr = XOnlineServerHttpPost( g_MatchServers[serverMatchHost].dwService,
                                pServerSession->dwTitleID,
                                g_MatchServers[serverMatchHost].szUrl,
                                pbResponse, 
                                &dwResponseLength,
                                NULL, 
                                0,
                                pbRequest, 
                                dwRequestLength,
                                DW_POST_TIMEOUT );

    //
    //  If the POST succeeded, and this was a session create request, save away the new session ID.
    //
    if(dwResponseLength != 0 && hr == S_OK)
    {
        CopyMemory(&pServerSession->SessionID, &((PXMATCH_SESSION_INFO)pbResponse)->SessionID, sizeof(XNKID));
    }

Cleanup:

    if(pbRequest != NULL)
        LocalFree((HLOCAL)pbRequest);
    if(pbResponse != NULL)
        LocalFree((HLOCAL)pbResponse);

    return(hr);
}


//---------------------------------------------------------------------------
//
// XOnlineServerSessionCreate
//
// Public API
//
// Function to create/advertize a session
//
HRESULT
XOnlineServerSessionCreate(
    IN OUT PXONLINE_SERVER_SESSION pServerSession,
    IN DWORD dwPublicFilled,
    IN DWORD dwPublicOpen,
    IN DWORD dwPrivateFilled,
    IN DWORD dwPrivateOpen,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN DWORD /* dwReserved */
    )
{
    HRESULT hr;
    DWORD   dwCurrAttr;

    if(pServerSession == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if( ( dwNumAttributes != 0 ) && ( pAttributes == NULL ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(IsBadReadPtr(pAttributes, dwNumAttributes * sizeof(XONLINE_ATTRIBUTE)))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(memcmp(&pServerSession->SessionID, &g_SessionIDNull,   sizeof(XNKID)) != 0 &&
       memcmp(&pServerSession->SessionID, &g_SessionIDCreate, sizeof(XNKID)) != 0)
    {
        hr = XONLINE_E_MATCH_INVALID_SESSION_ID;
        goto Cleanup;
    }

    if( !ValidateAttributeIDs(dwNumAttributes, pAttributes, TRUE) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Since this is a session CREATE request, the fChanged flag
    // is set for every attribute so that all attributes get sent
    // up with the create request.
    //
    for (dwCurrAttr = 0; dwCurrAttr < dwNumAttributes; ++dwCurrAttr)
    {
        pAttributes[dwCurrAttr].fChanged = TRUE;
    }

    //
    // Call private function that creates and/or updates session
    //

    hr = (SessionCreate( pServerSession, 
                          dwPublicFilled, 
                          dwPublicOpen, 
                          dwPrivateFilled, 
                          dwPrivateOpen, 
                          dwNumAttributes, 
                          pAttributes, 
                          0));

Cleanup:

    return hr;
}

//---------------------------------------------------------------------------
//
// XOnlineServerSessionUpdate
//
// Public API
//
// Function to update a session advertisement
//
HRESULT
XOnlineServerSessionUpdate(
    IN PXONLINE_SERVER_SESSION pServerSession,
    IN DWORD dwPublicFilled,
    IN DWORD dwPublicOpen,
    IN DWORD dwPrivateFilled,
    IN DWORD dwPrivateOpen,
    IN DWORD dwNumAttributes,
    IN PXONLINE_ATTRIBUTE pAttributes,
    IN DWORD /* dwReserved */
    )
{
    HRESULT hr;

    if(pServerSession == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if( ( dwNumAttributes != 0 ) && ( pAttributes == NULL ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(IsBadReadPtr(pAttributes, dwNumAttributes * sizeof(XONLINE_ATTRIBUTE)))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(memcmp(&pServerSession->SessionID, &g_SessionIDNull,   sizeof(XNKID)) == 0 ||
       memcmp(&pServerSession->SessionID, &g_SessionIDCreate, sizeof(XNKID)) == 0)
    {
        hr = XONLINE_E_MATCH_INVALID_SESSION_ID;
        goto Cleanup;
    }

    if( !ValidateAttributeIDs(dwNumAttributes, pAttributes, TRUE) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Call private function that creates and/or updates session
    //

    hr = (SessionCreate( pServerSession, 
                          dwPublicFilled, 
                          dwPublicOpen, 
                          dwPrivateFilled, 
                          dwPrivateOpen, 
                          dwNumAttributes, 
                          pAttributes, 
                          0));

Cleanup:

    return hr;
}


//---------------------------------------------------------------------------
//
// XOnlineServerSessionDelete
//
// Public API
//
// Function to delete session.
//
HRESULT
XOnlineServerSessionDelete(
    IN PXONLINE_SERVER_SESSION pServerSession,
    IN DWORD /* dwReserved */
    )
{
    HRESULT                 hr              = S_OK;
    LPBYTE                  pbRequest       = NULL;
    PXMATCH_SESSION_DELETE  pHeader         = NULL;
    DWORD                   dwBufferLen     = 0;

    if(pServerSession == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // Create and fill in the session delete request
    //
    pbRequest = (LPBYTE)LocalAlloc(LPTR, sizeof(XMATCH_SESSION_DELETE));
    if(pbRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Fill in the delete request protocol structure
    //
    pHeader = (PXMATCH_SESSION_DELETE) pbRequest;

    pHeader->dwMessageLength   = sizeof(XMATCH_SESSION_DELETE);
    pHeader->dwTitleID         = pServerSession->dwTitleID;

    memcpy(&pHeader->SessionID, &pServerSession->SessionID, sizeof(XNKID));

    //
    // Post delete request to the server.  Timeout after 30 seconds.
    //
    hr = XOnlineServerHttpPost( g_MatchServers[serverMatchHostDelete].dwService, 
                                pServerSession->dwTitleID,
                                g_MatchServers[serverMatchHostDelete].szUrl,
                                NULL, 
                                &dwBufferLen,
                                NULL, 
                                0,
                                pbRequest, 
                                sizeof(XMATCH_SESSION_DELETE),
                                DW_POST_TIMEOUT );

Cleanup:

    return hr;
}


//---------------------------------------------------------------------------
//
// ValidateAttributeIDs
//
// Private API.
//
// Validate that attribute IDs are correct
//
BOOL ValidateAttributeIDs(
    IN DWORD dwNumAttributes,
    IN const XONLINE_ATTRIBUTE* pAttributes,
    IN BOOL fSessionCreate
    )
{
    DWORD i = 0;

    //
    // Loop through all attributes and verify that the attribute ID is correct.
    //
    for (i = 0; i < dwNumAttributes; i += 1)
    {
        if (IsValidAttributeID(pAttributes[i].dwAttributeID, fSessionCreate) == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------
//
// IsValidAttributeID()
//
// Private API
//
// Validate attribute ID.
//
BOOL IsValidAttributeID(DWORD dwAttributeID, BOOL fSessionCreate)
{
    if (!fSessionCreate)
    {
        //
        // bit 31     Global or Title Specific must be zero for session search
        //
        if ((dwAttributeID & X_ATTRIBUTE_SCOPE_MASK) != 0)
        {
            return FALSE;
        }
    }

    //
    // bit 20-23  Attribute Data Type
    //   0000 = integer
    //   0001 = string
    //   0010 = binary blob
    //   0011-1111 = reserved for future use
    //
    if ((dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK) > X_ATTRIBUTE_DATATYPE_NULL)
    {
        return FALSE;
    }

    //
    // bit 28-30  Reserved for future use, must be zero
    //
    if ((dwAttributeID & X_ATTRIBUTE_RESERVED1_MASK) != 0)
    {
        return FALSE;
    }

    //
    // bit 16-19  Reserved for future use, must be zero
    //
    if ((dwAttributeID & X_ATTRIBUTE_RESERVED2_MASK) != 0)
    {
        return FALSE;
    }

    //
    // bit 24-27  reserved for future use
    //
    if ((dwAttributeID & X_ATTRIBUTE_RESERVED3_MASK) != 0)
    {
        return FALSE;
    }

    return TRUE;
}


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\serverlibtest\main.cpp ===
//  Unit tests for XMatch
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#include "precomp.h"

#define MY_TITLE_ID 0xFFEDAAB2
#define SAMPLE_TITLE_ID 0xFFFF010D

HRESULT NullTests()
{
    HRESULT hr;

    //
    //  Don't care about return codes, just checking to make sure we don't crash
    //

    XOnlineServerSessionCreate(NULL, 0, 0, 0, 0, 0, NULL, 0);
    XOnlineServerSessionUpdate(NULL, 0, 0, 0, 0, 0, NULL, 0);
    XOnlineServerSessionDelete(NULL, 0);

    return S_OK;
}

HRESULT SessionWithNoAttributes(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(MY_TITLE_ID);

    //
    //  Insert a new session
    //

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Now update that session
    //

    Session.SetPublicCurrent(7);
    Session.SetPublicAvailable(2);
    Session.SetPrivateCurrent(2);
    Session.SetPrivateAvailable(3);
    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Update it again
    //

    Session.SetPublicCurrent(9);
    Session.SetPublicAvailable(0);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(1);
    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithOneIntAttr(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            654321);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithOneStringAttr(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"Hi Mom!!!");

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;
    
    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"Eat my shorts...!");

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithOneBlobAttr(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob1[] = {
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0        
    };
    static BYTE blob2[] = {
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0        
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob1),
                             blob1);

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob2),
                             blob2);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithThreeAttrs1(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"SessionWithThreeAttrs1");

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob),
                             blob);

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithThreeAttrs2(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob),
                             blob);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"SessionWithThreeAttrs2");

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithThreeAttrs3(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob),
                             blob);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"SessionWithThreeAttrs3");

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithThreeAttrs4(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob),
                             blob);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"SessionWithThreeAttrs4");

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithThreeAttrs5(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"SessionWithThreeAttrs5");

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob),
                             blob);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionWithThreeAttrs6(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"SessionWithThreeAttrs6");

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_SESSION |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x1003,
                             sizeof(blob),
                             blob);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionPlayerIntAttrNoPlayer()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                            X_ATTRIBUTE_TYPE_USER |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x0001,
                            1);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_PLAYER_REQUIRED) ? S_OK : S_FALSE;

    return hr;
}


HRESULT SessionPlayerStrAttrNoPlayer()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                               X_ATTRIBUTE_TYPE_USER |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x0001,
                               L"Hoo Haaah!");

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_PLAYER_REQUIRED) ? S_OK : S_FALSE;

    return hr;
}


HRESULT SessionPlayerBlobAttrNoPlayer()
{
    HRESULT                 hr;
    XSessionInfo            Session;
    BYTE                    Blob[] = { 0x01 };

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                             X_ATTRIBUTE_TYPE_USER |
                             X_ATTRIBUTE_DATATYPE_BLOB |
                             0x0001,
                             1,
                             Blob);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_PLAYER_REQUIRED) ? S_OK : S_FALSE;

    return hr;
}


HRESULT SessionBadTitleID()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(0x7FFFFFFF);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_INVALID_TITLE_ID) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionUseReservedAttrBits()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC |
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x700F0001,
                            0x1234123412341234);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionBogusNoAttrs()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);
    Session.SetSessionID(0x11111111111111F1); // F is an illegal first digit

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_INVALID_SESSION_ID) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionBogusOneIntAttr()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);
    Session.SetSessionID(0x22222222222222F2); // F is an illegal first digit

    Session.AddIntAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            123456);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_INVALID_SESSION_ID) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionEmptyStringAttr(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1001,
                               L"");

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionIDDataMismatch1()
{
    HRESULT                 hr;
    XONLINE_SERVER_SESSION  sess;
    XONLINE_ATTRIBUTE       attr;

    memset(&sess, 0, sizeof(XONLINE_SERVER_SESSION));
    sess.dwTitleID = MY_TITLE_ID;
    sess.wHostPort = 666;

    attr.dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                         X_ATTRIBUTE_TYPE_SESSION |
                         X_ATTRIBUTE_DATATYPE_STRING |
                         0x1002;
    attr.fChanged = TRUE;
    attr.info.integer.qwValue = 123456;

    hr = XOnlineServerSessionCreate(&sess, 0, 5, 0, 5, 1, &attr, 0);
    hr = (hr == E_POINTER) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionIDDataMismatch2()
{
    HRESULT                 hr;
    XONLINE_SERVER_SESSION  sess;
    XONLINE_ATTRIBUTE       attr;

    memset(&sess, 0, sizeof(XONLINE_SERVER_SESSION));
    sess.dwTitleID = MY_TITLE_ID;
    sess.wHostPort = 666;

    attr.dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                         X_ATTRIBUTE_TYPE_SESSION |
                         X_ATTRIBUTE_DATATYPE_BLOB |
                         0x1002;
    attr.fChanged = TRUE;
    attr.info.integer.qwValue = 0xABABABABABAB;

    hr = XOnlineServerSessionCreate(&sess, 0, 5, 0, 5, 1, &attr, 0);
    hr = (hr == E_POINTER) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionIDDataMismatch3(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            L"This is a really long string eh?  I don't think so.");

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionIDDataMismatch4(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(MY_TITLE_ID);

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_BLOB |
                            0x1002,
                            L"Another fun string for testing funky behavior ha ha ha.");

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionIDDataMismatch5(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;
    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };


    Session.SetTitleID(MY_TITLE_ID);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_INTEGER |
                            0x1002,
                            sizeof(blob),
                            blob);

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionIDDataMismatch6(
    XSessionInfo&  Session
    )
{
    HRESULT                 hr;
    static BYTE blob[] = 
    {
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
    };


    Session.SetTitleID(MY_TITLE_ID);

    Session.AddBlobAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                            X_ATTRIBUTE_TYPE_SESSION |
                            X_ATTRIBUTE_DATATYPE_STRING |
                            0x1002,
                            sizeof(blob),
                            blob);

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT SessionStringTooLong()
{
    HRESULT                 hr;
    WCHAR                   szString[X_MAX_STRING_ATTRIBUTE_LEN + 1];
    int                     i;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);

    for(i = 0; i < X_MAX_STRING_ATTRIBUTE_LEN; ++i)
        szString[i] = L'a';
    szString[i] = L'\0';

    Session.AddStringAttribute(X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | 
                               X_ATTRIBUTE_TYPE_SESSION |
                               X_ATTRIBUTE_DATATYPE_STRING |
                               0x1002,
                               szString);

    Session.SetPublicCurrent(0);
    Session.SetPublicAvailable(5);
    Session.SetPrivateCurrent(0);
    Session.SetPrivateAvailable(5);

    hr = Session.SendSession();
    hr = (hr == XONLINE_E_MATCH_STRING_TOO_LONG) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionUpdateWithNullSession()
{
    HRESULT                 hr;
    WCHAR                   szString[X_MAX_STRING_ATTRIBUTE_LEN + 1];
    int                     i;
    XONLINE_SERVER_SESSION  sess;
    XONLINE_ATTRIBUTE       attr;
    HCRYPTPROV              hProv;

    sess.dwTitleID = MY_TITLE_ID;
    sess.wHostPort = 666;
    memset(&sess.SessionID, 0, sizeof(XNKID));

    if(CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
    {
        CryptGenRandom(hProv, sizeof(IN_ADDR), (LPBYTE)&(sess.HostAddress));
        CryptReleaseContext(hProv, 0);
    }

    hr = XOnlineServerSessionUpdate(&sess, 0, 5, 0, 5, 0, &attr, 0);
    hr = (hr == XONLINE_E_MATCH_INVALID_SESSION_ID) ? S_OK : S_FALSE;

    return hr;
}

HRESULT SessionSampleInsert(
    ULONGLONG   ulGameType,
    LPCWSTR     szSessionName,
    LPCWSTR     szPlayerLevel,
    LPBYTE      pGameStyle,
    ULONG       ulGameStyleLen,
    XSessionInfo& Session
    )
{
    HRESULT                 hr;

    Session.SetTitleID(SAMPLE_TITLE_ID);

    Session.AddIntAttribute(0x01000001, ulGameType);
    Session.AddStringAttribute(0x01100002, szPlayerLevel);
    Session.AddStringAttribute(0x01100003, szSessionName);
    Session.AddBlobAttribute(0x01200004, ulGameStyleLen, pGameStyle);

    Session.SetPublicCurrent(4);
    Session.SetPublicAvailable(8);
    Session.SetPrivateCurrent(6);
    Session.SetPrivateAvailable(0);

    hr = Session.SendSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}

HRESULT CloseSession(
    XSessionInfo&   Session
    )
{
    HRESULT                 hr;

    hr = Session.DeleteSession();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    return hr;
}


HRESULT CloseBogusSession()
{
    HRESULT                 hr;
    XSessionInfo            Session;

    Session.SetTitleID(MY_TITLE_ID);
    Session.SetSessionID(0x33333333333333F3);
    
    hr = Session.DeleteSession();
    hr = (hr == XONLINE_E_MATCH_INVALID_SESSION_ID) ? S_OK : S_FALSE;

    return hr;
}


//
//  Each unit test should return S_OK or S_FALSE
//

int __cdecl main(int argc, char** argv)
{
    HRESULT     hr;
    ULONG       ulSessionIndex = 0;

    XSessionInfo Sessions[512];

    hr = XOnlineServerInitialize();
    if(FAILED(hr))
    {
        printf("XOnlineServerInitialize failed with hr = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    hr = NullTests();
    printf("Unit test NullTests.                    Result = %s\r\n",
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithNoAttributes(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithNoAttributes.      Result = %s\r\n",
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithOneStringAttr(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithOneStringAttr.     Result = %s\r\n",
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithOneIntAttr(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithOneIntAttr.        Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithOneBlobAttr(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithOneBlobAttr.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithThreeAttrs1(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithThreeAttrs1.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithThreeAttrs2(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithThreeAttrs2.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithThreeAttrs3(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithThreeAttrs3.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithThreeAttrs4(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithThreeAttrs4.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithThreeAttrs5(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithThreeAttrs5.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionWithThreeAttrs6(Sessions[ulSessionIndex++]);
    printf("Unit test SessionWithThreeAttrs6.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionPlayerIntAttrNoPlayer();
    printf("Unit test SessionPlayerIntAttrNoPlayer. Result = %s\r\n",
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionPlayerStrAttrNoPlayer();
    printf("Unit test SessionPlayerStrAttrNoPlayer. Result = %s\r\n",
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionPlayerBlobAttrNoPlayer();
    printf("Unit test SessionPlayerBlobAttrNoPlayer.Result = %s\r\n",
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionBadTitleID();
    printf("Unit test SessionBadTitleID.            Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionUseReservedAttrBits();
    printf("Unit test SessionUseReservedAttrBits.   Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionBogusNoAttrs();
    printf("Unit test SessionBogusNoAttrs.          Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionBogusOneIntAttr();
    printf("Unit test SessionBogusOneIntAttr.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionEmptyStringAttr(Sessions[ulSessionIndex++]);
    printf("Unit test SessionEmptyStringAttr.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionIDDataMismatch1();
    printf("Unit test SessionIDDataMismatch1.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionIDDataMismatch2();
    printf("Unit test SessionIDDataMismatch2.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionIDDataMismatch3(Sessions[ulSessionIndex++]);
    printf("Unit test SessionIDDataMismatch3.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionIDDataMismatch4(Sessions[ulSessionIndex++]);
    printf("Unit test SessionIDDataMismatch4.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionIDDataMismatch5(Sessions[ulSessionIndex++]);
    printf("Unit test SessionIDDataMismatch5.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionIDDataMismatch6(Sessions[ulSessionIndex++]);
    printf("Unit test SessionIDDataMismatch6.       Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionStringTooLong();
    printf("Unit test SessionStringTooLong.         Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    hr = SessionUpdateWithNullSession();
    printf("Unit test SessionUpdateWithNullSession. Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    //
    //  Add a bunch more sessions
    //

    for(ULONG ul = 0; ul < 100; ul++)
    {
        SessionWithNoAttributes(Sessions[ulSessionIndex++]);
    }

    //
    //  Add some sessions for the sample too
    //

    SessionSampleInsert(1, L"Session1", L"Novice", (LPBYTE)L"Easy", sizeof(L"Easy"), Sessions[ulSessionIndex++]);
    SessionSampleInsert(2, L"Session2", L"Intermediate", (LPBYTE)L"Medium", sizeof(L"Medium"), Sessions[ulSessionIndex++]);
    SessionSampleInsert(3, L"Session3", L"Expert", (LPBYTE)L"Hard", sizeof(L"Hard"), Sessions[ulSessionIndex++]);

    //
    //  Close a bogus session, in this case, one that's already been closed
    //

    hr = CloseBogusSession();
    printf("Unit test CloseBogusSession.            Result = %s\r\n", 
           (hr == S_OK ? "Success" : "Failure!!!"));

    //
    //  Close all the sessions we opened.
    //

    printf("\r\n");
    for(DWORD dwCurrentSession = 0; dwCurrentSession < ulSessionIndex; ++dwCurrentSession)
    {
        hr = CloseSession(Sessions[dwCurrentSession]);
        printf("Close session id 0x%016I64X.\tResult = %s\r\n",
            Sessions[dwCurrentSession].GetSessionID(),
               (hr == S_OK ? "Success" : "Failure!!!"));
    }

Cleanup:

    XOnlineServerShutdown();

    return 0;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\serverlibtest\precomp.h ===
//  Precompiled headers.
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

#ifndef __PRECOMP_H
#define __PRECOMP_H

#include <windows.h>
#include <winhttp.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlconv.h>

#include <xalloc.h>
#include <wsockntp.h>
#include <xonlinep.h> // real clients of xonservr will use xonline.h, not xonlinep.h

#include "..\lspservr.h"

#include "SessionInfo.h"

//
//  String helper macros
//

#define REQUIRED_BUFFER(sz) WideCharToMultiByte(CP_UTF8,0,sz,-1,NULL,0,NULL,NULL)
#define W2UTF8(src,dst,n) WideCharToMultiByte(CP_UTF8,0,src,-1,dst,n,NULL,NULL)

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\sgauth.cpp ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Module implementing Security Gateway APIs

Module Name:

    sgauth.cpp

--*/

#include "precomp.h"


//////////////////////////////////////////////////////////////////////////////
//
// SGInitAuthRequest: simple helper to properly initialize the request message
//                    before sending to the Security Gateway
//
HRESULT __stdcall SGInitAuthRequest(
    IN  DWORD               dwReqNum,
    IN  IN_ADDR             ipaZ,
    IN  WORD                wPortZ,
    OUT SG_AUTH_REQUEST    *pReq
    )
{
    if( NULL == pReq )
    {
        return( E_POINTER );
    }

    pReq->wType = SGMSG_TYPE_AUTHDATA_REQ;
    pReq->cbRequest = sizeof( *pReq );
    pReq->dwReqNum = dwReqNum;
    pReq->dwIpaZ = ipaZ.S_un.S_addr;
    pReq->wPortZ = wPortZ;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////
//
// SGParseAuthResponse: use to parse SG response packet and retrieve standard
//                      set of authentication information.
//
HRESULT __stdcall SGParseAuthResponse(
    IN  DWORD               cbResponseData,
    IN  const BYTE         *pbResponseData,
    OUT DWORD              *pdwReqNum,
    OUT BOOL               *pfClientWasFound,
    OUT OPTIONAL IN_ADDR   *pipaI,
    OUT OPTIONAL WORD      *pwPortI,
    OUT OPTIONAL ULONGLONG *pqwXboxID,
    OUT OPTIONAL XUID      *pUser1,
    OUT OPTIONAL XUID      *pUser2,
    OUT OPTIONAL XUID      *pUser3,
    OUT OPTIONAL XUID      *pUser4
    )
{
    //
    // Validate parameters and incoming buffer size
    //
    if( ( NULL == pbResponseData ) || ( NULL == pdwReqNum ) || ( NULL == pfClientWasFound ) )
    {
        return( E_POINTER );
    }

    if( ( cbResponseData != sizeof( SG_AUTH_RESPONSE ) &&
        ( cbResponseData != ( sizeof( SG_AUTH_RESPONSE ) + sizeof( XBOX_AUTHDATA ) ) ) ) )
    {
        return( E_FAIL );
    }

    //
    // Validate message fields
    //
    const SG_AUTH_RESPONSE *pResp = (const SG_AUTH_RESPONSE *) pbResponseData;

    if( ( pResp->wType != SGMSG_TYPE_AUTHDATA_REP ) ||
        ( pResp->cbResponse != sizeof( SG_AUTH_RESPONSE ) ) )
    {
        return( E_INVALIDARG );
    }

    *pdwReqNum = pResp->dwReqNum;
    *pfClientWasFound = !pResp->fNotFound;

    if( pResp->fNotFound )
    {
        //
        // Fail if there's any extra data beyond a response that didn't find a client
        //
        return( ( cbResponseData > sizeof( SG_AUTH_RESPONSE ) ) ? E_FAIL : S_OK );
    }

    //
    // Optionally parse the client auth info
    //
    const XBOX_AUTHDATA *pAuth = (const XBOX_AUTHDATA *)( pResp + 1 );

    if( ( pAuth->wType != SGMSG_TYPE_AUTHDATA ) ||
        ( pAuth->cbAuthData != sizeof( XBOX_AUTHDATA ) ) ||
        ( pAuth->wAuthDataVersion != XONLINE_AUTHDATA_VERSION ) )
    {
        return( E_INVALIDARG );
    }

    //
    // Give back any info the client is interested in
    //
    if( NULL != pipaI )     *pipaI = *(IN_ADDR *) &pResp->dwIpaI;
    if( NULL != pwPortI )   *pwPortI = pResp->wPortI;
    if( NULL != pqwXboxID ) *pqwXboxID = pAuth->qwXboxID;
    if( NULL != pUser1 )    *pUser1 = pAuth->users[ 0 ];
    if( NULL != pUser2 )    *pUser2 = pAuth->users[ 1 ];
    if( NULL != pUser3 )    *pUser3 = pAuth->users[ 2 ];
    if( NULL != pUser4 )    *pUser4 = pAuth->users[ 3 ];

    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\stats.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved

Description:
    Module implementing Xbox Statistics server APIs

Module Name:
    stats.cpp

--*/

#include "precomp.h"

//
// Debugging and error handling stuff. Wouldn't it be cool if we could unify all
// this stuff in serverlib?
//

#ifdef _DEBUG

    void StTrace(char* pszFmt, ...)
    {
    	va_list args;
    	va_start(args, pszFmt);
    	char szBuffer[2048];
    	_vsnprintf(szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), pszFmt, args);
    	va_end(args);
    	OutputDebugStringA(szBuffer);
    }

    #define STTRACE StTrace

#else

    #define STTRACE

#endif

#define GOTO_LDONE_IF_FAILED_HR(op) \
    if(FAILED(hr = (op))) \
    { \
        STTRACE("%s failed, File:%s, Line:%d, hr = 0x%08x", \
            #op, __FILE__, __LINE__, hr); \
        goto lDone; \
    } 

#define GOTO_LDONE_IF_FAILED_ALLOC(op) \
    if(NULL == (op)) \
    { \
        hr = E_OUTOFMEMORY; \
        STTRACE("%s failed, File:%s, Line:%d", \
            #op, __FILE__, __LINE__); \
        goto lDone; \
    } 

#define GOTO_LDONE_IF_FAILED_ASSERT(op) \
    if(!(op)) \
    { \
        hr = E_UNEXPECTED; \
        STTRACE("%s failed, File:%s, Line:%d", \
            #op, __FILE__, __LINE__); \
        goto lDone; \
    } 

#define GOTO_LDONE_IF(op, hrIf) \
    if(op) \
    { \
        hr = hrIf; \
        STTRACE("%s failed, File:%s, Line:%d", \
            #op, __FILE__, __LINE__); \
        goto lDone; \
    } 


//
// Request types
//

enum XSTATS_TYPE
{
    xstatsSetData = 0,
    xstatsGetData,
    xstatsEnumLb,
    xstatsReset
};

#define DW_POST_TIMEOUT         30000  
    // Timeout for POST requests.  After 30 seconds, requests will timeout with a failure.

#define DW_LEN_SENDBUFFER 175
    // Size of the send buffer -- including headers.

//
// XRL Requests
// 

#define XRL_ENTRY(cnst, srvid, url, cnttp) 

#define XRL_STUFF() \
    XRL_ENTRY(serverStatsSetData, XONLINE_STATISTICS_SERVICE, L"/xstats/xstatsset.ashx", "Content-Type: xon/7\r\n") \
    XRL_ENTRY(serverStatsGetData, XONLINE_STATISTICS_SERVICE, L"/xstats/xstatsget.ashx", "Content-Type: xon/7\r\n") \
    XRL_ENTRY(serverStatsEnumLb,  XONLINE_STATISTICS_SERVICE, L"/xstats/xstatsenumlb.ashx", "Content-Type: xon/7\r\n") \
    XRL_ENTRY(serverStatsReset,   XONLINE_STATISTICS_SERVICE, L"/xstats/xstatsreset.ashx", "Content-Type: xon/7\r\n") \

//
// Use XRL_STUFF to build the XRL_TYPE enumeration and the XRL_ENTRY struct array 
//

typedef struct
{
    DWORD dwService;                // Service ID number
    WCHAR * wszUrl;                   // relative URL of ISAPI front door
    CHAR * szContentType;           // Service content type
    DWORD dwContentType;            // Size of the service content type
} XRL_SERVERS, *PXRL_SERVERS;

#undef XRL_ENTRY
#define XRL_ENTRY(cnst, srvid, url, cnttp) \
    cnst, 

enum XRL_TYPE
{
    XRL_STUFF()
};

#undef XRL_ENTRY
#define XRL_ENTRY(cnst, srvid, url, cnttp) \
    { srvid, url, cnttp, (sizeof(cnttp) / sizeof(cnttp[0])) - 1 },

static const XRL_SERVERS g_XRLServers[] =
{
    XRL_STUFF()        
};

//
// Attribute type sizes
//

static const DWORD c_rgdwAttrSizes[] =
{
	/*XONLINE_STAT_NONE*/           0,
	/*XONLINE_STAT_LONG*/           sizeof(DWORD),
	/*XONLINE_STAT_LONGLONG*/       sizeof(ULONGLONG),
	/*XONLINE_STAT_DOUBLE*/         sizeof(double),
	/*XONLINE_STAT_LPCWSTR*/        (XONLINE_STAT_MAX_NICKNAME_LENGTH * sizeof(WCHAR)) + sizeof(BYTE)
};

static const DWORD c_dwMaxAttrType = sizeof(c_rgdwAttrSizes) / sizeof(c_rgdwAttrSizes[0]);

//
// Local functions declaration
//

HRESULT 
ProcessGetResponse(
    BYTE* pbUpload,
    DWORD cbUpload,
    DWORD dwNumStatSpecs,
    PXONLINE_STAT_SPEC pStatSpecs,
    DWORD dwExtraBufferSize,
    BYTE* pExtraBuffer );

HRESULT
ProcessEnumerateResults(
    BYTE* pbUpload,
    DWORD cbUpload,
    IN DWORD dwUserCount,
	OUT PXONLINE_STAT_USER pUsers,
	IN DWORD dwStatCount,
	OUT PXONLINE_STAT pStats,
    OUT DWORD *pdwLeaderboardSize,
    OUT DWORD *pdwReturnedResults );


//
//
//

HRESULT
WINAPI
XOnlineServerStatSet(
    IN DWORD dwTitleId,
    IN DWORD dwNumStatsSpecs,
    IN PXONLINE_STAT_SPEC pStatSpecs
)
{
    DWORD dwSpecNdx;
    DWORD dwAttrNdx;
    BYTE* pbPostBuffer = NULL;
    DWORD cbPostBuffer;
    HRESULT hr = S_OK;

    //
    // Calculate the size of the POST buffer
    //

    cbPostBuffer = 0;

    for(dwSpecNdx=0; dwSpecNdx < dwNumStatsSpecs; dwSpecNdx++)
    {
        cbPostBuffer += sizeof(XSTATS_MSG_SETDATA);
        
        for(dwAttrNdx=0; dwAttrNdx < pStatSpecs[dwSpecNdx].dwNumStats; dwAttrNdx++)
        {
            GOTO_LDONE_IF_FAILED_ASSERT(
                pStatSpecs[dwSpecNdx].pStats[dwAttrNdx].type <= c_dwMaxAttrType);
            
            cbPostBuffer += sizeof(XSTATS_MSG_ATTRIBUTEDATA) + c_rgdwAttrSizes[pStatSpecs[dwSpecNdx].pStats[dwAttrNdx].type];
        }
    }

    //
    // Alloc POST buffer
    //

    GOTO_LDONE_IF_FAILED_ALLOC(
        pbPostBuffer = (BYTE*) LocalAlloc(LPTR, cbPostBuffer) );

    //
    // Fill out the request
    //

    cbPostBuffer = 0;

    for(dwSpecNdx=0; dwSpecNdx < dwNumStatsSpecs; dwSpecNdx++)
    {
        XSTATS_MSG_SETDATA* pMsg;
        XONLINE_STAT* pStat;

        //
        // Main body
        //

        pMsg = (XSTATS_MSG_SETDATA*) (pbPostBuffer + cbPostBuffer);
        pMsg->dwTitleId = dwTitleId;
        pMsg->ullUserId = (ULONGLONG) pStatSpecs[dwSpecNdx].xuidUser.qwUserID;
        pMsg->dwLeaderBoardType = pStatSpecs[dwSpecNdx].dwLeaderBoardID;
        pMsg->dwAttrCount = pStatSpecs[dwSpecNdx].dwNumStats;
        cbPostBuffer += sizeof(XSTATS_MSG_SETDATA);

        //
        // Attributes
        //

        for(dwAttrNdx=0; dwAttrNdx < pStatSpecs[dwSpecNdx].dwNumStats; dwAttrNdx++)
        {
            XSTATS_MSG_ATTRIBUTEDATA* pMsgAttr;

            // Write attribute Id and type

            pMsgAttr = (XSTATS_MSG_ATTRIBUTEDATA*) (pbPostBuffer + 
                cbPostBuffer);
            pMsgAttr->wAttrId = pStatSpecs[dwSpecNdx].pStats[dwAttrNdx].wID;
            pMsgAttr->bAttrType = (BYTE) pStatSpecs[dwSpecNdx].pStats[dwAttrNdx].type;
            cbPostBuffer += sizeof(XSTATS_MSG_ATTRIBUTEDATA);

            // Write attribute data

            pStat = &(pStatSpecs[dwSpecNdx].pStats[dwAttrNdx]);
            
            // Cannot update read-only attributes
            
            GOTO_LDONE_IF_FAILED_ASSERT(
                pStat->wID != XONLINE_STAT_RANK &&
                pStat->wID != XONLINE_STAT_LEADERBOARD_SIZE);

            // Check valid type
        
            GOTO_LDONE_IF_FAILED_ASSERT(
                pStat->type < c_dwMaxAttrType);

            if(pStat->wID == XONLINE_STAT_NICKNAME)
            {
                // Nickname is the special case. It's the only attribute
                // that can be a string.
                
                if(pStat->type == XONLINE_STAT_LPCWSTR)
                {
                    int iNicknameSize = wcslen(pStat->pwszString);

                    GOTO_LDONE_IF_FAILED_ASSERT(
                        iNicknameSize < XONLINE_STAT_MAX_NICKNAME_LENGTH);

                    iNicknameSize *= sizeof(WCHAR);
                    *(pbPostBuffer + cbPostBuffer) = (BYTE) iNicknameSize;
                    cbPostBuffer++;
                    memcpy(pbPostBuffer + cbPostBuffer, pStat->pwszString, iNicknameSize);
                    cbPostBuffer += iNicknameSize;
                }
            }
            else
            {
                // All other attributes cannot be strings.
                
                GOTO_LDONE_IF_FAILED_ASSERT(
                    pStat->type != XONLINE_STAT_LPCWSTR);
                
                memcpy(pbPostBuffer + cbPostBuffer, &(pStat->llValue),
                    c_rgdwAttrSizes[pStat->type]);
                cbPostBuffer += c_rgdwAttrSizes[pStat->type];
            }
        }
    }

    //
    // Make the request
    //

    GOTO_LDONE_IF_FAILED_HR(
        XOnlineServerHttpPost(
          g_XRLServers[serverStatsSetData].dwService, 
          g_XRLServers[serverStatsSetData].wszUrl,
          NULL, 
          NULL,
          (PBYTE) g_XRLServers[serverStatsSetData].szContentType, 
          g_XRLServers[serverStatsSetData].dwContentType,
          pbPostBuffer, 
          cbPostBuffer,
          DW_POST_TIMEOUT) );

lDone:

    //
    // Cleanup
    //

    if(pbPostBuffer != NULL)
    {
        LocalFree(pbPostBuffer);
    }

    return hr;
}

//
//
//

HRESULT 
WINAPI
XOnlineServerStatGet(
    IN DWORD dwTitleId,
    IN DWORD dwNumStatsSpecs,
    IN OUT PXONLINE_STAT_SPEC pStatSpecs,
    IN DWORD dwExtraBufferSize,
    IN OUT BYTE* pExtraBuffer
)
{
    HRESULT hr = S_OK;
    DWORD dwSpecNdx;
    DWORD dwAttrCount = 0;
    DWORD dwAttrNdx;
    WORD* pwAttrId;
    BYTE* pbRespBuffer = NULL;
    DWORD cbRespBuffer;
    BYTE* pbPostBuffer = NULL;
    DWORD cbPostBuffer;

    //
    // Calculate total number of attributes so we can allocate the request
    // buffer.
    //

    for(dwSpecNdx=0; dwSpecNdx < dwNumStatsSpecs; dwSpecNdx++)
    {
        dwAttrCount += pStatSpecs[dwSpecNdx].dwNumStats;
    }
    
    //
    // Calculate the size of the POST request and of the response buffer
    //

    cbPostBuffer = (sizeof(XSTATS_MSG_GETDATA) * dwNumStatsSpecs) +
        ( sizeof(WORD) * dwAttrCount);

    //
    // Calculate the size of the response
    //

    cbRespBuffer = 0;

    for(dwSpecNdx=0; dwSpecNdx < dwNumStatsSpecs; dwSpecNdx++)
    {
        cbRespBuffer += sizeof(XSTATS_MSG_RESP_GETDATA);
        
        for(dwAttrNdx=0; dwAttrNdx < pStatSpecs[dwSpecNdx].dwNumStats; dwAttrNdx++)
        {
            if(pStatSpecs[dwSpecNdx].pStats[dwAttrNdx].wID != XONLINE_STAT_NICKNAME)
            {
                cbRespBuffer += sizeof(XSTATS_MSG_ATTRIBUTEDATA) + sizeof(ULONGLONG);
            }
            else
            {
                cbRespBuffer += sizeof(XSTATS_MSG_ATTRIBUTEDATA) + c_rgdwAttrSizes[XONLINE_STAT_LPCWSTR];
            }
        }
    }

    //
    // Allocate POST and response buffers
    //

    GOTO_LDONE_IF_FAILED_ALLOC(
        pbRespBuffer = (BYTE*) LocalAlloc(LPTR, cbRespBuffer) );

    GOTO_LDONE_IF_FAILED_ALLOC(
        pbPostBuffer = (BYTE*) LocalAlloc(LPTR, cbPostBuffer) );

    //
    // Fillout the request
    //

    cbPostBuffer = 0;
    
    for(dwSpecNdx=0; dwSpecNdx < dwNumStatsSpecs; dwSpecNdx++)
    {
        XSTATS_MSG_GETDATA* pMsg;
 
        //
        // Main body
        //

        pMsg = (XSTATS_MSG_GETDATA*) (pbPostBuffer + cbPostBuffer);
        pMsg->dwTitleId = dwTitleId;
        pMsg->ullUserId = (ULONGLONG) pStatSpecs[dwSpecNdx].xuidUser.qwUserID;
        pMsg->dwLeaderBoardType = pStatSpecs[dwSpecNdx].dwLeaderBoardID;
        pMsg->dwAttrCount = pStatSpecs[dwSpecNdx].dwNumStats;
        cbPostBuffer += sizeof(XSTATS_MSG_GETDATA);

        //
        // Attribute IDs
        //

        for(dwAttrNdx=0; dwAttrNdx < pStatSpecs[dwSpecNdx].dwNumStats; dwAttrNdx++)
        {
            pwAttrId = (WORD*) (pbPostBuffer + cbPostBuffer);
            *pwAttrId = pStatSpecs[dwSpecNdx].pStats[dwAttrNdx].wID;
            cbPostBuffer += sizeof(WORD);
        }
    }

    //
    // Post the request

    GOTO_LDONE_IF_FAILED_HR(
        XOnlineServerHttpPost(
          g_XRLServers[serverStatsGetData].dwService, 
          g_XRLServers[serverStatsGetData].wszUrl,
          pbRespBuffer, 
          &cbRespBuffer,
          (PBYTE) g_XRLServers[serverStatsGetData].szContentType, 
          g_XRLServers[serverStatsGetData].dwContentType,
          pbPostBuffer, 
          cbPostBuffer,
          DW_POST_TIMEOUT) );

    //
    // Process the response
    //

    GOTO_LDONE_IF_FAILED_HR(
        ProcessGetResponse(pbRespBuffer, cbRespBuffer, dwNumStatsSpecs, 
        pStatSpecs, dwExtraBufferSize, pExtraBuffer) );

lDone:

    //
    // Clean-up
    //

    if(pbRespBuffer != NULL)
    {
        LocalFree(pbRespBuffer);
    }

    if(pbPostBuffer != NULL)
    {
        LocalFree(pbPostBuffer);
    }
    
    return hr;
}

//
//
//

static 
HRESULT 
ProcessGetResponse(
    BYTE* pbUpload,
    DWORD cbUpload,
    DWORD dwNumStatSpecs,
    PXONLINE_STAT_SPEC pStatSpecs,
    DWORD dwExtraBufferSize,
    BYTE* pExtraBuffer
)
{
    HRESULT hr = S_OK;
    XSTATS_MSG_ATTRIBUTEDATA* pAttrMsg;
    XONLINE_STAT* pStat;
    DWORD dwRespSpecNdx;
    DWORD dwSpecNdx;
    DWORD dwSpecAttrNdx;
    DWORD dwRespAttrNdx;
    DWORD cbProcessed = 0;
    DWORD dwUsedExtraBuffer =0;

    //
    // Parse response
    //

    for(dwSpecNdx=0; dwSpecNdx < dwNumStatSpecs; dwSpecNdx++)
    {
        XSTATS_MSG_RESP_GETDATA* pMsg;
        XONLINE_STAT_SPEC* pSpec;

        // Do we have enough space?
        
        GOTO_LDONE_IF(
            cbUpload - cbProcessed < sizeof(XSTATS_MSG_RESP_GETDATA),
            E_FAIL );

        // Map the message

        pMsg = (XSTATS_MSG_RESP_GETDATA*) (pbUpload + cbProcessed);
        cbProcessed += sizeof(XSTATS_MSG_RESP_GETDATA);

        // The message must match the specs in the passed order

        pSpec = &(pStatSpecs[dwSpecNdx]);

        GOTO_LDONE_IF(
            ( pSpec->xuidUser.qwUserID != pMsg->ullUserId ||
            pSpec->dwLeaderBoardID != pMsg->dwLeaderBoardType ),
            E_FAIL );

        // Process attributes

        for(dwRespAttrNdx=0; dwRespAttrNdx < pSpec->dwNumStats; dwRespAttrNdx++)
        {
            // Map attribute

            GOTO_LDONE_IF(
                (cbUpload - cbProcessed < sizeof(XSTATS_MSG_ATTRIBUTEDATA)),
                E_FAIL);

			pAttrMsg = (XSTATS_MSG_ATTRIBUTEDATA*)(pbUpload + cbProcessed);
			cbProcessed += sizeof(XSTATS_MSG_ATTRIBUTEDATA);
			
			// Match the attributes with the requests from the caller.
            
            pStat = NULL;
            for(dwSpecAttrNdx=0; dwSpecAttrNdx < pSpec->dwNumStats; dwSpecAttrNdx++)
            {
                if(pSpec->pStats[dwSpecAttrNdx].wID == pAttrMsg->wAttrId)
                {
                    pStat = &(pSpec->pStats[dwSpecAttrNdx]);
                    break;
                }
            }

            GOTO_LDONE_IF(
                (NULL == pStat),
                E_FAIL);

            // Copy the data

            GOTO_LDONE_IF(
                (pAttrMsg->bAttrType >= c_dwMaxAttrType),
                E_FAIL);

            pStat->type = (XONLINE_STAT_TYPE) pAttrMsg->bAttrType;

            if(pStat->type != XONLINE_STAT_LPCWSTR)
            {
                GOTO_LDONE_IF(
                    (cbUpload - cbProcessed < c_rgdwAttrSizes[pAttrMsg->bAttrType]),
                    E_FAIL);

                memcpy(&(pStat->llValue), pbUpload + cbProcessed, 
                    c_rgdwAttrSizes[pAttrMsg->bAttrType]);
                cbProcessed += c_rgdwAttrSizes[pAttrMsg->bAttrType];
            }
            else
            {
                unsigned int uiStrLen;
                
                GOTO_LDONE_IF(
                    (cbUpload - cbProcessed < sizeof(BYTE)),
                    E_FAIL);

                uiStrLen = (unsigned int) *(pbUpload + cbProcessed);
                cbProcessed++;

                GOTO_LDONE_IF(
                    (cbUpload - cbProcessed < uiStrLen),
                    E_FAIL);

                //
                // Strings go into the extra buffer. Do we have space there
                // for that?
                //

                GOTO_LDONE_IF(
                    (dwExtraBufferSize - dwUsedExtraBuffer < uiStrLen + sizeof(WCHAR)),
                    E_FAIL );

                pStat->pwszString = (LPCWSTR) (pExtraBuffer + dwUsedExtraBuffer);

                memcpy(pExtraBuffer + dwUsedExtraBuffer, pbUpload + cbProcessed,
                    uiStrLen);

                *((WCHAR*)(pExtraBuffer + dwUsedExtraBuffer + uiStrLen)) = L'\0';

                dwUsedExtraBuffer += uiStrLen + sizeof(WCHAR);
                cbProcessed += uiStrLen;
            }
        }
    }

lDone:

    return hr;
}

//
//
//

HRESULT
WINAPI
XOnlineServerStatLeaderEnumerate(
    IN DWORD dwTitleId,
	IN XUID* pxuidPagePivot,                           
	IN DWORD dwPageStart,                                              
	IN DWORD dwPageSize,
	IN DWORD dwLeaderboardID,
	IN DWORD dwNumStatsPerUser,
	IN WORD *pStatsPerUser,
	OUT PXONLINE_STAT_USER pUsers,
	OUT PXONLINE_STAT pStats,
	OUT DWORD *pdwLeaderboardSize,
	OUT DWORD *pdwReturnedResults
)
{
    HRESULT hr = S_OK;
    XSTATS_MSG_ENUMLEADERBOARD* pMsg;
    WORD* prgwAttrIds;
    BYTE* pbPostBuffer = NULL;
    DWORD cbPostBuffer;
    BYTE* pbRespBuffer = NULL;
    DWORD cbRespBuffer;
    DWORD dwAttrNdx;
    DWORD dwUserNdx;

    //
    // Parameter check
    //

    GOTO_LDONE_IF( 
        (0 == dwPageSize || dwPageSize > 100),
        E_INVALIDARG);

    GOTO_LDONE_IF(
        (dwNumStatsPerUser > 256),
        E_INVALIDARG);

    //
    // Calculate request buffer size
    //

    cbPostBuffer = sizeof(XSTATS_MSG_ENUMLEADERBOARD) + sizeof(WORD) * dwNumStatsPerUser;

    //
    // Calculate response buffer size
    //

    cbRespBuffer = (sizeof(XSTATS_MSG_RESP_ENUMLEADERBOARD) * dwPageSize) +
        (sizeof(XSTATS_MSG_RESP_ENUMLEADERBOARD_USER) * dwPageSize) +
        (XONLINE_XBOXLIVEID_SIZE * dwPageSize) + 
        (XONLINE_STAT_MAX_NICKNAME_LENGTH * dwPageSize) +
        ((sizeof(XSTATS_MSG_ATTRIBUTEDATA) + sizeof(ULONGLONG)) * dwPageSize * dwNumStatsPerUser);

    //
    // Allocate POST and response buffers
    //

    GOTO_LDONE_IF_FAILED_ALLOC(
        pbRespBuffer = (BYTE*) LocalAlloc(LPTR, cbRespBuffer) );

    GOTO_LDONE_IF_FAILED_ALLOC(
        pbPostBuffer = (BYTE*) LocalAlloc(LPTR, cbPostBuffer) );


    //
    // Fill out the message
    //

    cbPostBuffer = 0;
    
    pMsg = (XSTATS_MSG_ENUMLEADERBOARD*) (pbPostBuffer + cbPostBuffer);
    
    pMsg->dwTitleId = dwTitleId;
    pMsg->dwLeaderBoardType = dwLeaderboardID;

    if(pxuidPagePivot != NULL)
    {
        pMsg->ullPivot = pxuidPagePivot->qwUserID;
        pMsg->fUser = 1;
    }
    else
    {
        pMsg->ullPivot = dwPageStart;
        pMsg->fUser = 0;
    }

    pMsg->dwPageSize = dwPageSize;
    pMsg->dwAttrCount = dwNumStatsPerUser;

    cbPostBuffer += sizeof(XSTATS_MSG_ENUMLEADERBOARD);

    // attributes

    prgwAttrIds = (WORD*) (pbPostBuffer + cbPostBuffer);
    memcpy(prgwAttrIds, pStatsPerUser, sizeof(WORD) * dwNumStatsPerUser);
    cbPostBuffer += sizeof(WORD) * dwNumStatsPerUser;
    
    //
    // Post the request
    //

    GOTO_LDONE_IF_FAILED_HR(
        XOnlineServerHttpPost(
            g_XRLServers[serverStatsEnumLb].dwService, 
            g_XRLServers[serverStatsEnumLb].wszUrl,
            pbRespBuffer, 
            &cbRespBuffer,
            (PBYTE) g_XRLServers[serverStatsEnumLb].szContentType, 
            g_XRLServers[serverStatsEnumLb].dwContentType,
            pbPostBuffer, 
            cbPostBuffer,
            DW_POST_TIMEOUT) );

    GOTO_LDONE_IF_FAILED_HR(
        ProcessEnumerateResults(pbRespBuffer, cbRespBuffer, dwPageSize, pUsers, 
            dwPageSize * dwNumStatsPerUser, pStats, pdwLeaderboardSize, 
            pdwReturnedResults) );
    
lDone:

    //
    // Clean-up
    //

    if(pbRespBuffer != NULL)
    {
        LocalFree(pbRespBuffer);
    }

    if(pbPostBuffer != NULL)
    {
        LocalFree(pbPostBuffer);
    }
    
    return hr;
}

//
//
//

static
HRESULT
ProcessEnumerateResults(
    BYTE* pbUpload,
    DWORD cbUpload,
    IN DWORD dwUserCount,
	OUT PXONLINE_STAT_USER pUsers,
	IN DWORD dwStatCount,
	OUT PXONLINE_STAT pStats,
    OUT DWORD *pdwLeaderboardSize,
    OUT DWORD *pdwReturnedResults
)
{
    HRESULT hr = S_OK;
    XSTATS_MSG_RESP_ENUMLEADERBOARD* pResp;
    XSTATS_MSG_RESP_ENUMLEADERBOARD_USER* pRespUser;
    XSTATS_MSG_ATTRIBUTEDATA* pAttr;
    PXONLINE_STAT_USER pUser;
    PXONLINE_STAT pStat;
    DWORD cbProcessed = 0;
    DWORD dwUserNdx;
    DWORD dwAttrNdx;

    //
    // Read the first part of the response: XSTATS_MSG_RESP_ENUMLEADERBOARD
    //

    GOTO_LDONE_IF(
        (cbUpload - cbProcessed < sizeof(XSTATS_MSG_RESP_ENUMLEADERBOARD)),
        E_FAIL );

    pResp = (XSTATS_MSG_RESP_ENUMLEADERBOARD*) (pbUpload + cbProcessed);
    cbProcessed += sizeof(XSTATS_MSG_RESP_ENUMLEADERBOARD);

    STTRACE( 
        "pResp->dwLeaderboardSize = %d\n"
        "pResp->dwRespUserCount = %d\n"
        "pResp->dwAttrPerUser = %d\n",
        pResp->dwLeaderboardSize, 
        pResp->dwRespUserCount, 
        pResp->dwAttrPerUser);

    //
    // Do some sanity check
    //

    GOTO_LDONE_IF(
        (pResp->dwRespUserCount > dwUserCount),
        E_FAIL);

    GOTO_LDONE_IF(
        (pResp->dwAttrPerUser > (dwStatCount / dwUserCount)),
        E_FAIL);

    *pdwLeaderboardSize = pResp->dwLeaderboardSize;
    *pdwReturnedResults = pResp->dwRespUserCount;

    //
    // Read the second part of the response: one or more 
    // XSTATS_MSG_RESP_ENUMLEADERBOARD_USER blocks. The number of blocks 
    // returned was indicated in the previous message, in the dwRespUserCount 
    // field.
    //

    dwUserNdx = 0;

    while(cbProcessed < cbUpload && dwUserNdx < pResp->dwRespUserCount)
    {
        GOTO_LDONE_IF(
            (cbUpload - cbProcessed < sizeof(XSTATS_MSG_RESP_ENUMLEADERBOARD_USER)),
            E_FAIL );

        pRespUser = (XSTATS_MSG_RESP_ENUMLEADERBOARD_USER*) (pbUpload + cbProcessed);
        cbProcessed += sizeof(XSTATS_MSG_RESP_ENUMLEADERBOARD_USER);

        pUser = &(pUsers[dwUserNdx]);
        pUser->dwRank = pRespUser->dwRank;
        pUser->llRating = pRespUser->llRating;
        pUser->xuidUser.dwUserFlags = 0;
        pUser->xuidUser.qwUserID = pRespUser->ullUserId;

        // Process xname

        GOTO_LDONE_IF(
            (pRespUser->bXNameSize >= XONLINE_XBOXLIVEID_SIZE),
            E_FAIL );

        GOTO_LDONE_IF(
            (cbUpload - cbProcessed < pRespUser->bXNameSize),
            E_FAIL );

        memcpy(pUser->szUsername, pbUpload + cbProcessed, pRespUser->bXNameSize);
        pUser->szUsername[pRespUser->bXNameSize] = '\0';
        cbProcessed += pRespUser->bXNameSize;

        // Process nickname

        GOTO_LDONE_IF(
            (pRespUser->bNicknameSize >= XONLINE_STAT_MAX_NICKNAME_LENGTH * sizeof(WCHAR)),
            E_FAIL );

        GOTO_LDONE_IF(
            (cbUpload - cbProcessed < pRespUser->bNicknameSize),
            E_FAIL);

        memcpy(pUser->wszNickname, pbUpload + cbProcessed, pRespUser->bNicknameSize);
        pUser->wszNickname[pRespUser->bNicknameSize / sizeof(WCHAR)] = L'\0';
		cbProcessed += pRespUser->bNicknameSize;

        //
        // Attributes
        //

        for(dwAttrNdx=0; dwAttrNdx < pResp->dwAttrPerUser; dwAttrNdx++)
        {
            GOTO_LDONE_IF(
                (cbUpload - cbProcessed < sizeof(XSTATS_MSG_ATTRIBUTEDATA)),
                E_FAIL );

            pAttr = (XSTATS_MSG_ATTRIBUTEDATA*)(pbUpload + cbProcessed);
            cbProcessed += sizeof(XSTATS_MSG_ATTRIBUTEDATA);

            pStat = &(pStats[pResp->dwAttrPerUser * dwUserNdx + dwAttrNdx]);
            pStat->wID = pAttr->wAttrId;
            pStat->type = (XONLINE_STAT_TYPE) pAttr->bAttrType;

            GOTO_LDONE_IF(
                (cbUpload - cbProcessed < c_rgdwAttrSizes[pAttr->bAttrType]),
                E_FAIL );

            memcpy(&(pStat->llValue), pbUpload + cbProcessed, 
                c_rgdwAttrSizes[pAttr->bAttrType]);
            cbProcessed += c_rgdwAttrSizes[pAttr->bAttrType];
        }

        dwUserNdx++;
    }

lDone:

    return hr;
}

//
//
//

HRESULT 
WINAPI    
XOnlineServerStatReset(
    IN DWORD dwTitleId,
    IN XUID xuid,
    IN DWORD dwLeaderBoardId
)
{
    HRESULT hr = S_OK;
    XSTATS_MSG_RESET* pMsg;
    DWORD cbPostBuffer;
    BYTE* pbPostBuffer = NULL;
    
    //
    // Alloc POST buffer
    //

    cbPostBuffer = sizeof(XSTATS_MSG_RESET);

    GOTO_LDONE_IF_FAILED_ALLOC(
        pbPostBuffer = (BYTE*) LocalAlloc(LPTR, cbPostBuffer) );

    //
    // Fill out the request
    //

    pMsg = (XSTATS_MSG_RESET*) (pbPostBuffer);
    pMsg->dwTitleId = dwTitleId;
    pMsg->ullUserId = xuid.qwUserID;
    pMsg->dwLeaderBoardType = dwLeaderBoardId;

    //
    // Post the request
    //

    GOTO_LDONE_IF_FAILED_HR(
        XOnlineServerHttpPost(
          g_XRLServers[serverStatsReset].dwService, 
          g_XRLServers[serverStatsReset].wszUrl,
          NULL, 
          NULL,
          (PBYTE) g_XRLServers[serverStatsReset].szContentType, 
          g_XRLServers[serverStatsReset].dwContentType,
          pbPostBuffer, 
          cbPostBuffer,
          DW_POST_TIMEOUT) );

lDone:

    //
    // Clean-up
    //

    if(pbPostBuffer != NULL)
    {
        LocalFree(pbPostBuffer);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\serverlibtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XStorageSmoke.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\serverlibtest\SessionInfo.h ===
#ifndef __SESSIONINFO_H
#define __SESSIONINFO_H
#pragma once

//
//  Attribute
//

typedef struct
{
    DWORD       dwAttributeID;
    USHORT      nLen;
    BOOL        fChanged;

    union
    {
        ULONGLONG   qwVal;
        LPWSTR      strVal;
        LPBYTE      pVal;
    } val;
} ATTRIBUTE, *PATTRIBUTE;

//
//  Map class for holding attributes
//

template<>
class CElementTraits< ATTRIBUTE > :
	public CElementTraitsBase< T >
{
public:
	static ULONG Hash( INARGTYPE attr )
	{
        return( attr.dwAttributeID );
	}

  	static bool CompareElements( INARGTYPE attr1, INARGTYPE attr2 )
	{
        return (attr1.dwAttributeID == attr2.dwAttributeID);
	}

};

typedef CAtlMap<ATTRIBUTE, ATTRIBUTE> XATTRMAP;

//
//  This class contains all client-side session information.
//

class XSessionInfo
{
public:

    XSessionInfo();
    ~XSessionInfo();

    void AddIntAttribute(DWORD dwAttributeID, ULONGLONG qwAttributeValue);
    void AddStringAttribute(DWORD dwAttributeID, LPCWSTR szAttributeValue);
    void AddBlobAttribute(DWORD dwAttributeID, DWORD dwAttributeLen, LPBYTE pAttributeValue);

    HRESULT SendSession(void);
    HRESULT DeleteSession(void);

    void SetTitleID(DWORD dwTitleID);
    void SetSessionID(ULONGLONG qwSessionID);
    ULONGLONG GetSessionID(void);

    void SetPublicCurrent(ULONG ulPublicCurrent)       { m_ulPublicCurrent    = ulPublicCurrent;    }
    void SetPublicAvailable(ULONG ulPublicAvailable)   { m_ulPublicAvailable  = ulPublicAvailable;  }
    void SetPrivateCurrent(ULONG ulPrivateCurrent)     { m_ulPrivateCurrent   = ulPrivateCurrent;   }
    void SetPrivateAvailable(ULONG ulPrivateAvailable) { m_ulPrivateAvailable = ulPrivateAvailable; }

    DWORD GetAttributeCount(void) { return m_AttrMap.GetCount(); }

    PXONLINE_ATTRIBUTE      GetAttributes();
    PXONLINE_SERVER_SESSION GetSession() { return &m_Session; }

protected:

    XONLINE_SERVER_SESSION  m_Session;  
    XATTRMAP                m_AttrMap;
    ULONG                   m_ulPublicCurrent;
    ULONG                   m_ulPublicAvailable;
    ULONG                   m_ulPrivateCurrent;
    ULONG                   m_ulPrivateAvailable;
};

#endif // __SESSIONINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\serverlibtest\SessionInfo.cpp ===
#include "precomp.h"

XNKID NullSession = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

XSessionInfo::XSessionInfo() : m_ulPublicCurrent(0),
                               m_ulPublicAvailable(0),
                               m_ulPrivateCurrent(0),
                               m_ulPrivateAvailable(0)
{
    HCRYPTPROV  hProv;

    ZeroMemory(&m_Session, sizeof(XONLINE_SERVER_SESSION));
    
    if(CryptAcquireContext(&hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))
    {
        CryptGenRandom(hProv, sizeof(IN_ADDR), (LPBYTE)&(m_Session.HostAddress));
        CryptReleaseContext(hProv, 0);
    }

    m_Session.wHostPort = 666;
}

XSessionInfo::~XSessionInfo()
{
    //
    //  Clear attribute map and XFree up any memory
    //

    while(m_AttrMap.GetCount() != 0)
    {
        POSITION pos;
        ATTRIBUTE attr;

        pos = m_AttrMap.GetStartPosition();
        attr = m_AttrMap.GetValueAt(pos);

        switch(attr.dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
        {
        case X_ATTRIBUTE_DATATYPE_STRING:
            XFree(attr.val.strVal);
            break;

        case X_ATTRIBUTE_DATATYPE_BLOB:
            XFree(attr.val.pVal);
            break;
        }

        m_AttrMap.RemoveAtPos(pos);
    }
}

void XSessionInfo::AddIntAttribute(
    DWORD       dwAttributeID,
    ULONGLONG   qwAttributeValue
    )
{
    ATTRIBUTE attr;

    attr.dwAttributeID = dwAttributeID;
    attr.nLen = sizeof(ULONGLONG);
    attr.fChanged = TRUE;

    attr.val.qwVal = qwAttributeValue;

    m_AttrMap.SetAt(attr, attr);
}

void XSessionInfo::AddStringAttribute(
    DWORD       dwAttributeID,
    LPCWSTR     szAttributeValue
    )
{
    ATTRIBUTE attr;
    ATTRIBUTE attrExists;

    attr.dwAttributeID = dwAttributeID;
    attr.nLen = (lstrlenW(szAttributeValue) + 1) * sizeof(WCHAR);
    attr.fChanged = TRUE;

    attr.val.strVal = (LPWSTR)XAlloc(attr.nLen);
    lstrcpyW(attr.val.strVal, szAttributeValue);

    if(m_AttrMap.Lookup(attr, attrExists))
        XFree(attrExists.val.strVal);
    
    m_AttrMap.SetAt(attr, attr);
}

void XSessionInfo::AddBlobAttribute(
    DWORD       dwAttributeID,
    DWORD       dwAttributeLen,
    LPBYTE      pAttributeValue
    )
{
    ATTRIBUTE attr;
    ATTRIBUTE attrExists;

    attr.dwAttributeID = dwAttributeID;
    attr.nLen = (USHORT)(dwAttributeLen + sizeof(USHORT));
    attr.fChanged = TRUE;

    attr.val.pVal = (LPBYTE)XAlloc(dwAttributeLen);
    CopyMemory(attr.val.pVal, pAttributeValue, dwAttributeLen);

    if(m_AttrMap.Lookup(attr, attrExists))
        XFree(attrExists.val.pVal);
    
    m_AttrMap.SetAt(attr, attr);
}

HRESULT XSessionInfo::SendSession()
{
    HRESULT             hr;
    PXONLINE_ATTRIBUTE  pAttributes;

    pAttributes = GetAttributes();
    if(pAttributes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(memcmp(&m_Session.SessionID, &NullSession, sizeof(XNKID)) == 0)
    {
        hr = XOnlineServerSessionCreate(&m_Session,
                                        m_ulPublicCurrent,
                                        m_ulPublicAvailable,
                                        m_ulPrivateCurrent,
                                        m_ulPrivateAvailable,
                                        m_AttrMap.GetCount(),
                                        pAttributes,
                                        0);
    }
    else
    {
        hr = XOnlineServerSessionUpdate(&m_Session,
                                        m_ulPublicCurrent,
                                        m_ulPublicAvailable,
                                        m_ulPrivateCurrent,
                                        m_ulPrivateAvailable,
                                        m_AttrMap.GetCount(),
                                        pAttributes,
                                        0);
    }

Cleanup:

    if(pAttributes != NULL)
        XFree(pAttributes);

    return hr;
}

HRESULT XSessionInfo::DeleteSession()
{
    HRESULT hr;

    hr = XOnlineServerSessionDelete(&m_Session, 0);

    return hr;
}


void XSessionInfo::SetTitleID(
    DWORD       dwTitleID
    )
{
    m_Session.dwTitleID = dwTitleID;
}

void XSessionInfo::SetSessionID(
    ULONGLONG   qwSessionID
    )
{
    CopyMemory(&m_Session.SessionID, &qwSessionID, sizeof(XNKID));
}

ULONGLONG XSessionInfo::GetSessionID()
{
    return *(PULONGLONG)&(m_Session.SessionID);
}

//
//  Format all attributes and session info into a buffer suitable for
//  sending to the matchmaking server.  Caller is responsible for calling
//  XFree() on the returned pointer.
//

PXONLINE_ATTRIBUTE XSessionInfo::GetAttributes()
{
    POSITION pos;
    PXONLINE_ATTRIBUTE pAttributes;

    //
    //  First we need to calculate the necessary buffer length which is
    //
    //      sizeof(XMATCH_SESSION) + (sizeof(DWORD) * N * 2) + sizeof(ATTRIBUTES)
    //
    //  Where sizeof(ATTRIBUTES) includes space for length prefix in case of string/blob
    //  attributes
    //

    DWORD   dwRequiredBuffer = sizeof(XONLINE_ATTRIBUTE) * m_AttrMap.GetCount();

    //
    //  Allocate the buffer, copy the base structure and put in the attributes.
    //

    pAttributes = (PXONLINE_ATTRIBUTE)XAlloc(dwRequiredBuffer);

    //
    //  Fill in attributes and offsets
    //

    DWORD dwCurAttr;
    for(pos = m_AttrMap.GetStartPosition(), dwCurAttr = 0; pos != NULL; m_AttrMap.GetNext(pos))
    {
        pAttributes[dwCurAttr].dwAttributeID = m_AttrMap.GetValueAt(pos).dwAttributeID;
        pAttributes[dwCurAttr].fChanged = m_AttrMap.GetValueAt(pos).fChanged;

        // now set the attribute value
        switch(m_AttrMap.GetValueAt(pos).dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
        {
        case X_ATTRIBUTE_DATATYPE_INTEGER:
            pAttributes[dwCurAttr].info.integer.qwValue = m_AttrMap.GetValueAt(pos).val.qwVal;
            break;

        case X_ATTRIBUTE_DATATYPE_STRING:
            pAttributes[dwCurAttr].info.string.lpValue = m_AttrMap.GetValueAt(pos).val.strVal;
            break;

        case X_ATTRIBUTE_DATATYPE_BLOB:
            pAttributes[dwCurAttr].info.blob.pvValue = m_AttrMap.GetValueAt(pos).val.pVal;
            pAttributes[dwCurAttr].info.blob.dwLength = m_AttrMap.GetValueAt(pos).nLen - sizeof(USHORT);
            break;
        }

        m_AttrMap.GetValueAt(pos).fChanged = FALSE;

        ++dwCurAttr;
    }

    return pAttributes;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\serverlib\sgquery\SGQuery.cpp ===
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>

#include "xonservr.h"


void __cdecl main( int argc, char *argv[] )
{
    //
    // Parse command line arguments
    //
    IN_ADDR inaSG = { 0 };
    WORD wPort = 3074;
    char *pchColon = NULL;
    char szColonPort[10] = "";

    if( argc == 2 )
    {
        pchColon = strchr( argv[ 1 ], ':' );

        if( pchColon != NULL )
        {
            *pchColon = '\0';
            wPort = (WORD) atoi( pchColon + 1 );
            sprintf( szColonPort, ":%d", wPort );
        }

        inaSG.S_un.S_addr = inet_addr( argv[ 1 ] );
    }

    if( argc != 2 )
    {
        puts( "Usage: SGQuery <IP[:port]>\n" );
        puts( "Sends an SG Auth request to the Security Gateway at IP:65535, asking for info" );
        puts( "about IP or IP:port.  Example command lines: SGQuery 1.2.3.4, or SGQuery 1.2.3.4:56" );
        return;
    }

    printf( "Retrieving Security Gateway information about %s%s\n", inet_ntoa( inaSG ), szColonPort );

    //
    // Initialize networking support and create our request message
    //
    WSADATA wsa;
    if( 0 != WSAStartup( MAKEWORD( 2, 2 ), &wsa ) )
    {
        printf( "Error %d initializing Winsock!\n", WSAGetLastError() );
        return;
    }

    SOCKET sock = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if( sock == INVALID_SOCKET )
    {
        printf( "Error %d creating UDP socket!\n", WSAGetLastError() );
        return;
    }

    int msTimeout = 2000;
    setsockopt( sock, SOL_SOCKET, SO_RCVTIMEO, (char*) &msTimeout, sizeof( msTimeout ) );

    SOCKADDR_IN saSG;
    saSG.sin_family = AF_INET;
    saSG.sin_addr = inaSG;
    saSG.sin_port = 0xFFFF;

    HRESULT hr;
    SG_AUTH_REQUEST msgRequest;

    //
    // For this application, a constant dwReqNum value is used.  In real applications, do something like this:
    // DWORD dwReqNum = (DWORD) InterlockedIncrement( (PLONG) &m_dwMasterSGReqNum );
    //
    DWORD dwReqNum = 0x12345678;

    hr = SGInitAuthRequest( dwReqNum, inaSG, wPort, &msgRequest );

    if( FAILED( hr ) )
    {
        printf( "SGInitAuthRequest failed (%X)\n", hr );
        return;
    }

    //
    // Now loop sending it, waiting for a response up to two seconds, and then retrying if necessary.
    // In real applications, all of this network I/O should be done asynchronously to avoid blocking
    // threads during delays due to lost packets.
    //
    const int NUM_RETRIES = 3;

    for( int i = 0; i < NUM_RETRIES; i++ )
    {
        int iRes = sendto( sock, (char *) &msgRequest, sizeof( msgRequest ), 0, (const sockaddr *) &saSG, sizeof( saSG ) );

        if( iRes < 0 )
        {
            printf( "UDP send failed w/ error %d\n", WSAGetLastError() );
            return;
        }

        BYTE rgbData[ 0x400 ];

        iRes = recv( sock, (char *) rgbData, sizeof( rgbData ), 0 );

        if( ( iRes < 0 ) && ( WSAETIMEDOUT == WSAGetLastError() ) )
        {
            printf( "Auth info request #%d failed! %s...\n",
                i + 1, i < NUM_RETRIES - 1 ? "Retrying" : "Giving up" );
            continue;
        }

        if( iRes < 0 )
        {
            if( WSAECONNRESET == WSAGetLastError() )
            {
                printf( "UDP receive returned WSAECONNRESET, which means an ICMP_PORT_UNREACHABLE was sent." );
            }
            else
            {
                printf( "UDP receive failed w/ error %d\n", WSAGetLastError() );
            }
            return;
        }

        DWORD dwRespReqNum = 0;
        BOOL fFound = FALSE;
        IN_ADDR inaI = { 0 };
        WORD wPortI = 0;
        ULONGLONG qwXboxID = 0;
        XUID xuid1 = { 0 }, xuid2 = { 0 }, xuid3 = { 0 }, xuid4 = { 0 };

        hr = SGParseAuthResponse(
                        iRes,
                        rgbData,
                        &dwRespReqNum,
                        &fFound, 
                        &inaI,
                        &wPortI,
                        &qwXboxID,
                        &xuid1,
                        &xuid2,
                        &xuid3,
                        &xuid4 );

        if( FAILED( hr ) )
        {
            printf( "Parsing of auth response failed (%X)\n", hr );
            return;
        }

        if( dwRespReqNum != dwReqNum )
        {
            printf( "Received mismatched request number %x in response (!= %x)\n", dwRespReqNum, dwReqNum );
            continue;
        }

        if( fFound )
        {
            char *pszGuestChars = "-123";
            char szDCIP[ 0x20 ];
            strcpy( szDCIP, inet_ntoa( inaSG ) );

            printf( "SG sez:  Data Center %s%s = Internet %s:%d\n",
                szDCIP, szColonPort, inet_ntoa( inaI ), wPortI );

            printf( "         Xbox Machine Account = 0x%I64X\n", qwXboxID );

            if( 0 != xuid1.qwUserID )
            {
                printf( "         Controller Slot 1 = User Account 0x%I64X [V%c,P%c,N%c,G%c,C=%d]\n",
                    xuid1.qwUserID,
                    XOnlineIsUserVoiceAllowed( xuid1.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserPurchaseAllowed( xuid1.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserNicknameAllowed( xuid1.dwUserFlags ) ? '+' : '-',
                    pszGuestChars[ XOnlineUserGuestNumber( xuid1.dwUserFlags ) ],
                    XOnlineUserCountryId( xuid1.dwUserFlags ) );
            }

            if( 0 != xuid2.qwUserID )
            {
                printf( "         Controller Slot 2 = User Account 0x%I64X [V%c,P%c,N%c,G%c,C=%d]\n",
                    xuid2.qwUserID,
                    XOnlineIsUserVoiceAllowed( xuid2.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserPurchaseAllowed( xuid2.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserNicknameAllowed( xuid2.dwUserFlags ) ? '+' : '-',
                    pszGuestChars[ XOnlineUserGuestNumber( xuid2.dwUserFlags ) ],
                    XOnlineUserCountryId( xuid2.dwUserFlags ) );
            }

            if( 0 != xuid3.qwUserID )
            {
                printf( "         Controller Slot 3 = User Account 0x%I64X [V%c,P%c,N%c,G%c,C=%d]\n",
                    xuid3.qwUserID,
                    XOnlineIsUserVoiceAllowed( xuid3.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserPurchaseAllowed( xuid3.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserNicknameAllowed( xuid3.dwUserFlags ) ? '+' : '-',
                    pszGuestChars[ XOnlineUserGuestNumber( xuid3.dwUserFlags ) ],
                    XOnlineUserCountryId( xuid3.dwUserFlags ) );
            }

            if( 0 != xuid4.qwUserID )
            {
                printf( "         Controller Slot 4 = User Account 0x%I64X [V%c,P%c,N%c,G%c,C=%d]\n",
                    xuid4.qwUserID,
                    XOnlineIsUserVoiceAllowed( xuid4.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserPurchaseAllowed( xuid4.dwUserFlags ) ? '+' : '-',
                    XOnlineIsUserNicknameAllowed( xuid4.dwUserFlags ) ? '+' : '-',
                    pszGuestChars[ XOnlineUserGuestNumber( xuid4.dwUserFlags ) ],
                    XOnlineUserCountryId( xuid4.dwUserFlags ) );
            }
        }
        else
        {
            printf( "SG sez:  %s%s is no longer connected / not found\n", inet_ntoa( inaSG ), szColonPort );
        }

        break;
    }

    WSACleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\Suite.cs ===
using ServerTestFramework;

[assembly:RootNode(typeof(XLSPAuthDataLibTest.XLSPAuthDataLibTest))]

namespace XLSPAuthDataLibTest
{
    [Owner("LukeL"), TestFrequency("Regression")]
    public class XLSPAuthDataLibTest: TestNode
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\OverallProperties.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.protocol;

namespace XLSPAuthDataLibTest
{
    [TestGroup, Description("Read the top-level properties of the managed AuthData class")]
    public class OverallProperties: TestNode
    {
        public static string[] RequestAuthDataProperty(SgClient sg, string []name)
        {
            return RequestAuthDataProperty(sg, null, name);
        }

        public static string[] RequestAuthDataProperty(SgClient sg, string outterName, string []name)
        {
            return RequestAuthDataProperty(sg, outterName, null, name);
        }

        public static string[] RequestAuthDataProperty(SgClient sg, string outterName, string middleName, string []name)
        {
            byte []rawReply;
            if (outterName==null)
            {
                rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetProperty, Util.CreateNullStringSequence(name));
            }
            else
            {
                if (middleName==null)
                {
                    string []pass=new string[name.Length+1];
                    pass[0]=outterName;
                    System.Array.Copy(name, 0, pass, 1, name.Length);
                    rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetSubProperty, Util.CreateNullStringSequence(pass));
                }
                else
                {
                    string []pass=new string[name.Length+2];
                    pass[0]=outterName;
                    pass[1]=middleName;
                    System.Array.Copy(name, 0, pass, 2, name.Length);
                    rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetSubSubProperty, Util.CreateNullStringSequence(pass));
                }
            }

            byte []data;
            string error;
            Util.ParseResponse(rawReply, out data, out error);
            if (error!=null)
            {
                throw new UnexpectedTestResultException(error);
            }

            string []ret=Util.ParseNullStringSequence(data, 0, data.Length);
            if (ret.Length!=name.Length)
            {
                throw new System.Exception("Expected "+name.Length+" strings back from the reflector but got "+ret.Length);
            }

            Global.RO.Debug("Reflector returned data: "+ServerTestFramework.Utilities.StringUtils.MakeCommaSeparatedList(ret));
            return ret;
        }

        // --

        [TestCase]
        public void SecurityGatewayPort()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //tell the reflector to request authdata and check it
            string []ret=RequestAuthDataProperty(sg, new string[]{"SecurityGatewayPort"});
            int retParsed=int.Parse(ret[0]);

            if (retParsed<=0)
            {
                throw new UnexpectedTestResultException("Did not expect sg port to be <=0");
            }

            if (retParsed>65535)
            {
                throw new UnexpectedTestResultException("Did not expect sg port to be > 65535");
            }
        }

        [TestCase]
        public void SessionID()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //tell the reflector to request authdata; there are no invalid values for this field
            string []ret=RequestAuthDataProperty(sg, new string[]{"SessionID"});
            ulong retParsed=ulong.Parse(ret[0]);
        }

        [TestCase]
        public void SessionStartTime()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //tell the reflector to request authdata
            string []ret=RequestAuthDataProperty(sg, new string[]{"SessionStartTime"});
            ulong retParsed=ulong.Parse(ret[0]);

            System.DateTime sessionStartConverted=System.DateTime.FromFileTime((long)retParsed);
            ValueCheck.Test("SessionStartTime", System.DateTime.UtcNow, sessionStartConverted, new System.TimeSpan(0, 1, 0));
            Global.RO.Debug("Interpreted time: "+sessionStartConverted);
        }

        [TestCase]
        public void SecurityGatewayIP()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //tell the reflector to request authdata
            string []ret=RequestAuthDataProperty(sg, new string[]{"SecurityGatewayIP"});
            System.Net.IPAddress retParsed=System.Net.IPAddress.Parse(ret[0]);

            string []ipParts=ret[0].Split(new char[]{'.'});
            if (ipParts[0]=="0" || ipParts[0]=="255")
            {
                throw new UnexpectedTestResultException("IP address returned is probably not valid");
            }
        }

        [TestCase]
        public void Title_TitleID()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            SgClient.SetDefaults(ctx);
            sg.SetupForFakeSignInXkdc();
            ((Authdata_Xenon)ctx.Authdata).dwTitleID=0xfeedbac4;
            sg.SignInSG();

            //tell the reflector to request authdata
            string []ret=RequestAuthDataProperty(sg, "Title", new string[]{"TitleID"});
            uint retParsed=uint.Parse(ret[0]);
            ValueCheck.Test("TitleID", 0xfeedbac4, retParsed);
        }

        [TestCase]
        public void Title_Version()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            SgClient.SetDefaults(ctx);
            sg.SetupForFakeSignInXkdc();
            ((Authdata_Xenon)ctx.Authdata).dwTitleVersion=0xfaceb004;
            sg.SignInSG();

            //tell the reflector to request authdata
            string []ret=RequestAuthDataProperty(sg, "Title", new string[]{"Version"});
            uint retParsed=uint.Parse(ret[0]);
            ValueCheck.Test("Version", 0xfaceb004, retParsed);
        }

        [TestCase]
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon, "Xbox360")]
        [CompoundCase("Xbox1", AuthContext.ClientTypes.Xbox, "Xbox1")]
        [CompoundCase("Fusion", AuthContext.ClientTypes.XenonBackCompat, "Xbox1")]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama, "PC")]
        public class Client_Platform: TestNode
        {
            public override void Run()
            {
                AuthContext.ClientTypes curType=(AuthContext.ClientTypes)MyValues[0];
                string expectedPlatform=(string)MyValues[1];

                //connect to the SG
                AuthContext ctx=new AuthContext(curType);
                SgClient sg=new SgClient(ctx);
                sg.SignInSG();

                //verify the platform in the authdata
                string []ret=RequestAuthDataProperty(sg, "Client", new string[]{"Platform"});
                string retParsed=ret[0];
                ValueCheck.Test("Client.Platform", expectedPlatform, retParsed);
            }
        }

        [TestCase]
        public void Client_IPAddress()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //tell the reflector to request authdata
            string []ret=RequestAuthDataProperty(sg, "Client", new string[]{"IPAddress"});
            System.Net.IPAddress retParsed=System.Net.IPAddress.Parse(ret[0]);

            //check that this IP is us
            System.Net.IPHostEntry usIPs=System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName());
            foreach (System.Net.IPAddress ip in usIPs.AddressList)
            {
                if (ip.ToString()==retParsed.ToString())
                {
                    return;
                }
            }

            throw new UnexpectedTestResultException("IP "+retParsed+" returned from AuthData is not the IP of this client machine.");
        }

        [TestCase]
        public void Client_Port()
        {
            //connect to the SG
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //tell the reflector to request authdata
            string []ret=RequestAuthDataProperty(sg, "Client", new string[]{"Port"});
            int retParsed=int.Parse(ret[0]);
            if (retParsed==0 || retParsed==65535)
            {
                throw new UnexpectedTestResultException("Bad client port: "+retParsed);
            }
        }

        [TestGroup]
        public class Client_Language: TestNode
        {
            [TestCase]
            public void English()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).wLanguageID=1;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataProperty(sg, "Client", "Language", new string[]{"LanguageCode","Name"});
                string retLangId=ret[0];
                string retLangCode=ret[1];

                ValueCheck.Test("Client.Language.LanguageCode", "English", retLangId);
                ValueCheck.Test("Client.Language.Name", "en", retLangCode);

                //verify that System.Globalization.CultureInfo can ingest this
                string rfc1766Code=retLangCode+"-US";
                System.Globalization.CultureInfo ci=new System.Globalization.CultureInfo(rfc1766Code);
                ValueCheck.Test("System.Globalization.CultureInfo.EnglishName for "+rfc1766Code, "English (United States)", ci.EnglishName);
                Global.RO.Info("System.Globalization.CultureInfo.EnglishName for "+rfc1766Code+" is "+ci.EnglishName);
            }

            [TestCase]
            public void Norwegian()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).wLanguageID=15; //Norwegian
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataProperty(sg, "Client", "Language", new string[]{"LanguageCode","Name"});
                string retLangId=ret[0];
                string retLangCode=ret[1];

                ValueCheck.Test("Client.Language.LanguageCode", "Norwegian", retLangId);
                //ValueCheck.Test("Client.Language.Name", "no", retLangCode);

                //verify that System.Globalization.CultureInfo can ingest this
                string rfc1766Code=retLangCode+"-NO";
                System.Globalization.CultureInfo ci=new System.Globalization.CultureInfo(rfc1766Code);
                ValueCheck.Test("System.Globalization.CultureInfo.EnglishName for "+rfc1766Code, "Norwegian, Bokml (Norway)", ci.EnglishName);
                Global.RO.Info("System.Globalization.CultureInfo.EnglishName for "+rfc1766Code+" is "+ci.EnglishName);
            }

            [TestCase, Description("We will likely add new languages in the future, need to handle it gracefully")]
            public void Higher()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).wLanguageID=999;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataProperty(sg, "Client", "Language", new string[]{"LanguageCode","Name"});
                string retLangId=ret[0];
                string retLangCode=ret[1];

                ValueCheck.Test("Client.Language.LanguageCode", "Unknown", retLangId);
                ValueCheck.Test("Client.Language.Name", "XX", retLangCode);
            }
        }

        [TestCase]
        [CompoundCase("True",  true)]
        [CompoundCase("False", false)]
        public class CanPlayMultiplayer: TestNode
        {
            public override void Run()
            {
                bool doSet=(bool)MyValues[0];

                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                Util.SetPrivilege((Authdata_Xenon)ctx.Authdata, 254, doSet); //254=XPRIVILEGE_MULTIPLAYER_SESSIONS
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataProperty(sg, new string[]{"CanPlayMultiplayer"});
                ValueCheck.Test("CanPlayMultiplayer", Name, ret[0]);
            }
        }

        [TestCase]
        [CompoundCase("True",  true)]
        [CompoundCase("False", false)]
        public class CanAuthorContent: TestNode
        {
            public override void Run()
            {
                bool doSet=(bool)MyValues[0];

                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                Util.SetPrivilege((Authdata_Xenon)ctx.Authdata, 222, doSet); //222=XPRIVILEGE_CONTENT_AUTHOR
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataProperty(sg, new string[]{"CanAuthorContent"});
                ValueCheck.Test("CanAuthorContent", Name, ret[0]);
            }
        }

        [TestCase]
        public class CheckPrivacySetting: TestNode
        {
            protected override void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
            {
                string []settingNames=new string[]{"Communications", "ViewProfile", "UserGeneratedContent", "Presence", "VideoCommunications"};
                int []settingValues=new int[]     {0,                1,             2,                       3,         4};

                int []settingPrivPublic=new int[] {252,              249,           247,                     244,       235};
                int []settingPrivPrivate=new int[]{251,              248,           246,                     243,       234};

                string []results=new string[]{"Blocked", "FriendsOnly", "Everyone"};

                for (int settingInd=0; settingInd<settingNames.Length; ++settingInd)
                {
                    foreach (string result in results)
                    {
                        string ccaName=settingNames[settingInd]+"_"+result;

                        bool setPublic=(result=="Everyone");
                        bool setPrivate=(result=="FriendsOnly");

                       object []ccaParams=new object[6]{settingValues[settingInd], settingPrivPublic[settingInd], setPublic, settingPrivPrivate[settingInd], setPrivate, result};

                        CompoundCaseAttribute cca=new CompoundCaseAttribute(ccaName, ccaParams);
                        instances.Add(cca);
                    }
                }
            }

            public override void Run()
            {
                int setting=(int)MyValues[0];
                int priv0=(int)MyValues[1];
                bool priv0Value=(bool)MyValues[2];
                int priv1=(int)MyValues[3];
                bool priv1Value=(bool)MyValues[4];
                string expect=(string)MyValues[5];

                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                Util.SetPrivilege((Authdata_Xenon)ctx.Authdata, priv0, priv0Value);
                Util.SetPrivilege((Authdata_Xenon)ctx.Authdata, priv1, priv1Value);
                sg.SignInSG();

                //tell the reflector to request authdata
                byte []rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataCheckPrivacySetting, Util.CreateNullStringSequence(new string[]{setting.ToString()}));

                byte []data;
                string error;
                Util.ParseResponse(rawReply, out data, out error);
                if (error!=null)
                {
                    throw new UnexpectedTestResultException(error);
                }

                string []ret=Util.ParseNullStringSequence(data, 0, data.Length);
                if (ret.Length!=1)
                {
                    throw new System.Exception("Expected 1 string back from the reflector but got "+ret.Length);
                }
                Global.RO.Debug("Reflector returned data: "+ServerTestFramework.Utilities.StringUtils.MakeCommaSeparatedList(ret));

                ValueCheck.Test("Privary Setting", expect, ret[0]);
            }
        }

        //Note: CheckPrivilege is inherenently tested by some of the accessors and by CheckPrivacySetting
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\ReferenceCheck.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.protocol;

namespace XLSPAuthDataLibTest
{
    [TestGroup]
    public class ReferenceCheck: TestNode
    {
        [TestCase, Description("Verifies that the assembly makes no references to internal xbl libraries.")]
        public void VerifyNoXblReferences()
        {
            //connect to the sg
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            sg.SignInSG();

            //request list of assembly names from the reflector
            byte []rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetAssemblyReferences, new byte[0]);
            byte []data;
            string error;
            Util.ParseResponse(rawReply, out data, out error);
            if (error!=null)
            {
                throw new UnexpectedTestResultException(error);
            }

            //get the list of strings
            string []assemblyNameList=Util.ParseNullStringSequence(data, 0, data.Length);
            foreach (string s in assemblyNameList)
            {
                Global.RO.Info("Assembly reference: "+s);
            }

            //verify all names
            foreach (string name in assemblyNameList)
            {
                if (name.ToLower().Contains("xbl") || name.ToLower().Contains("xbox"))
                {
                    throw new UnexpectedTestResultException("The XLSP AuthData assembly is making a reference to an xbl assembly that it should not be: "+name);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\RequestBasic.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

using xonline.common.protocol;

namespace XLSPAuthDataLibTest
{
    [TestGroup]
    public class RequestBasic: TestNode
    {
        [TestCase, Description("Just requests authdata and verifies that no exception was thrown")]
        [CompoundCase("Xbox360", AuthContext.ClientTypes.Xenon)]
        [CompoundCase("Xbox1", AuthContext.ClientTypes.Xbox)]
        [CompoundCase("Fusion", AuthContext.ClientTypes.XenonBackCompat)]
        [CompoundCase("PC", AuthContext.ClientTypes.Panorama)]
        public class SimpleRequestValid: TestNode
        {
            public override void Run()
            {
                //connect to the sg
                AuthContext ctx=new AuthContext((AuthContext.ClientTypes)MyValues[0]);
                SgClient sg=new SgClient(ctx);
                sg.SignInSG();

                //tell the reflector to request authdata
                byte []rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataSimpleRequest, new byte[0]);
                byte []data;
                string error;
                Util.ParseResponse(rawReply, out data, out error);
                if (error!=null)
                {
                    throw new UnexpectedTestResultException(error);
                }
            }
        }

        //Ignored for now; changing the site's authdata version seems to "pollute" something used by SgClient in most other tests randomly.
        [TestCase, Ignore, Description("Make a request after connecting with an old version of AuthData")]
        public void OldAuthdataVersion()
        {
            //connect to the SG with an old authdata version
            AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
            SgClient sg=new SgClient(ctx);
            SgClient.SetDefaults(ctx);
            ctx.Site.authdataVersion=2;
            sg.SetupForFakeSignInXkdc();
            sg.FakeSignInXkdc();
            sg.SignInSG();

            //tell the reflector to request authdata
            byte []rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataSimpleRequest, new byte[0]);
            byte []data;
            string error;
            Util.ParseResponse(rawReply, out data, out error);
            if (error!=null)
            {
                throw new UnexpectedTestResultException(error);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\UserProperties.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;

using xonline.common.protocol;

namespace XLSPAuthDataLibTest
{
    [TestGroup, Description("Read the top-level properties of the managed AuthData class")]
    public class UserProperties: TestNode
    {
        public static string[] RequestAuthDataUserProperty(SgClient sg, ulong user, int occurance, string []name)
        {
            return RequestAuthDataUserProperty(sg, user, occurance, null, name);
        }

        public static string[] RequestAuthDataUserProperty(SgClient sg, ulong user, int occurance, string outterName, string []name)
        {
            return RequestAuthDataUserProperty(sg, user, occurance, outterName, null, name);
        }

        public static string[] RequestAuthDataUserProperty(SgClient sg, ulong user, int occurance, string outterName, string middleName, string []name)
        {
            byte []rawReply;
            if (outterName==null)
            {
                string []pass=new string[name.Length+2];
                pass[0]=user.ToString();
                pass[1]=occurance.ToString();
                System.Array.Copy(name, 0, pass, 2, name.Length);
                rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetUserProperty, Util.CreateNullStringSequence(pass));
            }
            else
            {
                if (middleName==null)
                {
                    string []pass=new string[name.Length+3];
                    pass[0]=user.ToString();
                    pass[1]=occurance.ToString();
                    pass[2]=outterName;
                    System.Array.Copy(name, 0, pass, 3, name.Length);
                    rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetUserSubProperty, Util.CreateNullStringSequence(pass));
                }
                else
                {
                    string []pass=new string[name.Length+4];
                    pass[0]=user.ToString();
                    pass[1]=occurance.ToString();
                    pass[2]=outterName;
                    pass[3]=middleName;
                    System.Array.Copy(name, 0, pass, 4, name.Length);
                    rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetUserSubSubProperty, Util.CreateNullStringSequence(pass));
                }
            }

            byte []data;
            string error;
            Util.ParseResponse(rawReply, out data, out error);
            if (error!=null)
            {
                throw new UnexpectedTestResultException(error);
            }

            string []ret=Util.ParseNullStringSequence(data, 0, data.Length);
            if (ret.Length!=name.Length)
            {
                throw new System.Exception("Expected "+name.Length+" strings back from the reflector but got "+ret.Length);
            }

            Global.RO.Debug("Reflector returned data for user "+user+" occurance "+occurance+": "+ServerTestFramework.Utilities.StringUtils.MakeCommaSeparatedList(ret));
            return ret;
        }

        public static ulong[] RequestAuthDataUserList(SgClient sg)
        {
            byte []rawReply=Util.CallReflectorThroughSG(sg, TestReflAction.XlspAuthDataGetUserList, new byte[0]);
            byte []data;
            string error;
            Util.ParseResponse(rawReply, out data, out error);
            if (error!=null)
            {
                throw new UnexpectedTestResultException(error);
            }

            string []puidStrings=Util.ParseNullStringSequence(data, 0, data.Length);
            System.Collections.Generic.List<ulong> puids=new System.Collections.Generic.List<ulong>();
            foreach (string s in puidStrings)
            {
                if (s.Length>0)
                {
                    Global.RO.Debug(string.Format("UserPuid returned: "+s));
                    puids.Add(ulong.Parse(s));
                }
            }

            if (puids.Count==0)
            {
                Global.RO.Debug("No user puids returned.");
            }

            return puids.ToArray();
        }

        // --

        [TestGroup, Description("Tests that retrieve a list of all user puids in the authdata")]
        public class UserList: TestNode
        {
            [TestCase]
            public void NoUsers()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 0, puids.Length);
            }

            [TestCase]
            public void OneUser()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123456789012;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 1, puids.Length);
                ValueCheck.Test("User0 puid", 0x0900123456789012, puids[0]);
            }

            [TestCase]
            public void TwoUsers_Adjacent()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[1].qwUserID=0x0900123400000001;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 2, puids.Length);
                ValueCheck.Test("User0 puid", 0x0900123400000000, puids[0]);
                ValueCheck.Test("User1 puid", 0x0900123400000001, puids[1]);
            }

            [TestCase]
            public void TwoUsers_Disjointed()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[3].qwUserID=0x0900123400000001;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 2, puids.Length);
                ValueCheck.Test("User0 puid", 0x0900123400000000, puids[0]);
                ValueCheck.Test("User1 puid", 0x0900123400000001, puids[1]);
            }

            [TestCase]
            public void FourUsers()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[1].qwUserID=0x0900123400000001;
                ((Authdata_Xenon)ctx.Authdata).users[2].qwUserID=0x0900123400000002;
                ((Authdata_Xenon)ctx.Authdata).users[3].qwUserID=0x0900123400000003;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 4, puids.Length);
                ValueCheck.Test("User0 puid", 0x0900123400000000, puids[0]);
                ValueCheck.Test("User1 puid", 0x0900123400000001, puids[1]);
                ValueCheck.Test("User2 puid", 0x0900123400000002, puids[2]);
                ValueCheck.Test("User3 puid", 0x0900123400000003, puids[3]);
            }

            [TestCase]
            public void OneUserOneGuest()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                //flags here from a halo3 sg log
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700;
                ((Authdata_Xenon)ctx.Authdata).users[2].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[2].dwUserFlags=0x42606701;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 2, puids.Length);
                ValueCheck.Test("User0 puid", 0x0900123400000000, puids[0]);
                ValueCheck.Test("User1 puid", 0x0900123400000000, puids[1]);
            }

            [TestCase]
            public void DuplicateNonGuestUser() //not supposed to be possible, but we've seen it happen due to bugs
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[1].qwUserID=0x0900123400000000;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 2, puids.Length);
                ValueCheck.Test("User0 puid", 0x0900123400000000, puids[0]);
                ValueCheck.Test("User1 puid", 0x0900123400000000, puids[1]);
            }

            [TestCase]
            public void SanityCheck_RealKDC()
            {
                //go through the real KDC with an actual user for this to make sure we get it right
                UserEditor ue=UserEditor.CreateNew();
                ue.RemoveAllSubscriptions(true);
                ue.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                Global.RO.Debug("Created new user: "+ue.Puid);

                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                ctx.SetUser(ue, 0);
                XkdcClient kdc=new XkdcClient(ctx);
                kdc.SignInXkdc();

                //connect to the SG
                SgClient sg=new SgClient(ctx);
                sg.bUseRealXKDC=true;
                sg.SignInSG();

                //tell the reflector to request authdata
                ulong []puids=RequestAuthDataUserList(sg);
                ValueCheck.Test("Number of users", 1, puids.Length);
                ValueCheck.Test("User0 puid", ue.Puid, puids[0]);
            }
        }

        [TestGroup, Description("Tests that check properties of a user")]
        public class Checks: TestNode
        {
            [TestCase]
            public void XUID()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123456789012;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123456789012, 0, new string[]{"XUID"});
                ulong retParsed=ulong.Parse(ret[0]);
                ValueCheck.Test("XUID", 0x0900123456789012, retParsed);
            }

            [TestCase]
            public void Tier_Silver()
            {
                //go through the real KDC with an actual user for this to make sure we get it right
                UserEditor ue=UserEditor.CreateNew();
                ue.RemoveAllSubscriptions(true);
                ue.AddBaseSubscription(BaseSubscriptions.Xbox360Silver);
                Global.RO.Debug("Created new user: "+ue.Puid);

                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                ctx.SetUser(ue, 0);
                XkdcClient kdc=new XkdcClient(ctx);
                kdc.SignInXkdc();

                //connect to the SG
                SgClient sg=new SgClient(ctx);
                sg.bUseRealXKDC=true;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, ue.Puid, 0, new string[]{"Tier"});
                ValueCheck.Test("Tier", "Silver", ret[0]);
            }

            [TestCase]
            public void Tier_Gold()
            {
                //go through the real KDC with an actual user for this to make sure we get it right
                UserEditor ue=UserEditor.CreateNew();
                ue.RemoveAllSubscriptions(true);
                ue.AddBaseSubscription(BaseSubscriptions.Xbox360Gold);
                Global.RO.Debug("Created new user: "+ue.Puid);

                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                ctx.SetUser(ue, 0);
                XkdcClient kdc=new XkdcClient(ctx);
                kdc.SignInXkdc();

                //connect to the SG
                SgClient sg=new SgClient(ctx);
                sg.bUseRealXKDC=true;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, ue.Puid, 0, new string[]{"Tier"});
                ValueCheck.Test("Tier", "Gold", ret[0]);
            }

            [TestCase, Description("Tier in the user flags is 4 bits, 3=silver and 6=gold.  But since we could add new tiers later, we must handle this gracefully; in this case that means returning the highest tier we know about.")]
            public void Tier_15()
            {
                //can't use the real KDC for this as it doesn't exist yet
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42F06700; //tier 15 (tier mask is 0x00F00000)
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"Tier"});
                ValueCheck.Test("Tier", "Gold", ret[0]);
            }

            [TestCase, Description("Tier in the user flags is 4 bits, 3=silver and 6=gold.  But since we could add new tiers later, we must handle this gracefully; in this case that means returning the highest tier not greater than the actual tier value.")]
            public void Tier_5()
            {
                //can't use the real KDC for this as it doesn't exist yet
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42506700; //tier 5 (tier mask is 0x00F00000)
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"Tier"});
                ValueCheck.Test("Tier", "Silver", ret[0]);
            }

            [TestCase, Description("Tier in the user flags is 4 bits, 3=silver and 6=gold.  But since we could add new tiers later, we must handle this gracefully; in this case that means returning the lowest valid tier we know about.")]
            public void Tier_2()
            {
                //can't use the real KDC for this as it doesn't exist yet
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42206700; //tier 2 (tier mask is 0x00F00000)
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"Tier"});
                ValueCheck.Test("Tier", "Silver", ret[0]);
            }

            [TestCase, Description("Tier in the user flags is 4 bits, 3=silver and 6=gold.  But since we could add new tiers later, we must handle this gracefully; in this case that means returning the lowest valid tier we know about.")]
            public void Tier_0()
            {
                //can't use the real KDC for this as it doesn't exist yet
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42006700; //tier 0 (tier mask is 0x00F00000)
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"Tier"});
                ValueCheck.Test("Tier", "Silver", ret[0]);
            }

            [TestCase]
            public void Language_English() //1
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700; //language mask is 0x3E000000
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Language", new string[]{"LanguageCode", "Name"});
                ValueCheck.Test("Language.LanguageCode", "English", ret[0]);
                ValueCheck.Test("Language.Name", "en", ret[1]);
            }

            [TestCase]
            public void Language_Swedish() //17
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x62606700; //language mask is 0x3E000000
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Language", new string[]{"LanguageCode", "Name"});
                ValueCheck.Test("Language.LanguageCode", "Swedish", ret[0]);
                ValueCheck.Test("Language.Name", "sv", ret[1]);
            }

            [TestCase, Description("Currently we have languages 1-17 but we will likely add newer ones at some point.  We have 5 bits available.")]
            public void Language_Higher() //30
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x7C606700; //language mask is 0x3E000000
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Language", new string[]{"LanguageCode", "Name"});
                ValueCheck.Test("Language.LanguageCode", "Unknown", ret[0]);
                ValueCheck.Test("Language.Name", "XX", ret[1]);
            }

            [TestCase]
            public void Country_UnitedStates() //103
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700; //country mask is 0x0000ff00
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Country", new string[]{"CountryCode", "Name"});
                ValueCheck.Test("Country.CountryCode", "UnitedStates", ret[0]);
                ValueCheck.Test("Country.Name", "US", ret[1]);
            }

            [TestCase]
            public void Country_UnitedArabEmirates() //1
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42600100; //country mask is 0x0000ff00
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Country", new string[]{"CountryCode", "Name"});
                ValueCheck.Test("Country.CountryCode", "UnitedArabEmirates", ret[0]);
                ValueCheck.Test("Country.Name", "AE", ret[1]);
            }

            [TestCase]
            public void Country_Zimbabwe() //110
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606E00; //country mask is 0x0000ff00
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Country", new string[]{"CountryCode", "Name"});
                ValueCheck.Test("Country.CountryCode", "Zimbabwe", ret[0]);
                ValueCheck.Test("Country.Name", "ZW", ret[1]);
            }

            [TestCase, Description("Currently we have languages 1-110 but we will likely add newer ones at some point.  We have 8 bits available.")]
            public void Country_Higher() //254
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x4260FE00; //country mask is 0x0000ff00
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, "Country", new string[]{"CountryCode", "Name"});
                ValueCheck.Test("Country.CountryCode", "Unknown", ret[0]);
                ValueCheck.Test("Country.Name", "XX", ret[1]);
            }

            [TestCase]
            public void GuestNumber_Adjacent_OneUserOneGuest()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                //flags here from a halo3 sg log
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700;
                ((Authdata_Xenon)ctx.Authdata).users[1].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[1].dwUserFlags=0x42606701;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"IsGuest", "GuestNumber"});
                ValueCheck.Test("user0 IsGuest", "False", ret[0]);
                ValueCheck.Test("user0 GuestNumber", "0", ret[1]);

                ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 1, new string[]{"IsGuest", "GuestNumber"});
                ValueCheck.Test("user1 IsGuest", "True", ret[0]);
                ValueCheck.Test("user1 GuestNumber", "1", ret[1]);
            }

            [TestCase]
            public void GuestNumber_Disjointed_OneUserOneGuest_GuestLast()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700;
                ((Authdata_Xenon)ctx.Authdata).users[3].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[3].dwUserFlags=0x42606701;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"IsGuest", "GuestNumber"});
                ValueCheck.Test("user0 IsGuest", "False", ret[0]);
                ValueCheck.Test("user0 GuestNumber", "0", ret[1]);

                ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 1, new string[]{"IsGuest", "GuestNumber"});
                ValueCheck.Test("user1 IsGuest", "True", ret[0]);
                ValueCheck.Test("user1 GuestNumber", "1", ret[1]);
            }

            [TestCase]
            public void GuestNumber_Disjointed_OneUserOneGuest_GuestFirst()
            {
                //connect to the SG
                AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                SgClient sg=new SgClient(ctx);
                SgClient.SetDefaults(ctx);
                sg.SetupForFakeSignInXkdc();
                ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606701;
                ((Authdata_Xenon)ctx.Authdata).users[3].qwUserID=0x0900123400000000;
                ((Authdata_Xenon)ctx.Authdata).users[3].dwUserFlags=0x42606700;
                sg.SignInSG();

                //tell the reflector to request authdata
                string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"IsGuest", "GuestNumber"});
                ValueCheck.Test("user0 IsGuest", "True", ret[0]);
                ValueCheck.Test("user0 GuestNumber", "1", ret[1]);

                ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 1, new string[]{"IsGuest", "GuestNumber"});
                ValueCheck.Test("user1 IsGuest", "False", ret[0]);
                ValueCheck.Test("user1 GuestNumber", "0", ret[1]);
            }

            [TestCase]
            [CompoundCase("True", true)]
            [CompoundCase("False", false)]
            public class IsVoiceBanned: TestNode
            {
                public override void Run()
                {
                    uint orFlags=(uint)(((bool)MyValues[0])?0x00010000:0); //0x00010000 is the voice banned bit

                    //connect to the SG
                    AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                    SgClient sg=new SgClient(ctx);
                    SgClient.SetDefaults(ctx);
                    sg.SetupForFakeSignInXkdc();
                    ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                    ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700|orFlags;
                    sg.SignInSG();

                    //tell the reflector to request authdata
                    string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"IsVoiceBanned"});
                    ValueCheck.Test("IsVoiceBanned", Name, ret[0]);
                }
            }

            [TestCase]
            [CompoundCase("True", true)]
            [CompoundCase("False", false)]
            public class IsChildAccount: TestNode
            {
                public override void Run()
                {
                    uint orFlags=(uint)(((bool)MyValues[0])?0x01000000:0); //0x01000000 is the parentally controlled bit

                    //connect to the SG
                    AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                    SgClient sg=new SgClient(ctx);
                    SgClient.SetDefaults(ctx);
                    sg.SetupForFakeSignInXkdc();
                    ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                    ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700|orFlags;
                    sg.SignInSG();

                    //tell the reflector to request authdata
                    string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"IsChildAccount"});
                    ValueCheck.Test("IsChildAccount", Name, ret[0]);
                }
            }

            [TestCase]
            //                              guest setbit expectation
            [CompoundCase("Normal Allowed", 0,    false, true)]
            [CompoundCase("Guest Allowed",  3,    false, false)]
            [CompoundCase("Normal Blocked", 0,    true,  false)]
            [CompoundCase("Guest Blocked",  3,    true,  false)]
            public class CanPurchaseContent: TestNode
            {
                public override void Run()
                {
                    uint guest=(uint)(int)MyValues[0];
                    uint orFlags=(uint)(((bool)MyValues[1])?0x00020000:0); //0x00020000 is the purchase not allowed bit
                    bool expect=(bool)MyValues[2];

                    //connect to the SG
                    AuthContext ctx=new AuthContext(AuthContext.ClientTypes.Xenon);
                    SgClient sg=new SgClient(ctx);
                    SgClient.SetDefaults(ctx);
                    sg.SetupForFakeSignInXkdc();
                    ((Authdata_Xenon)ctx.Authdata).users[0].qwUserID=0x0900123400000000;
                    ((Authdata_Xenon)ctx.Authdata).users[0].dwUserFlags=0x42606700|orFlags|guest;
                    if (guest!=0)
                    {
                        ((Authdata_Xenon)ctx.Authdata).users[1].qwUserID=0x0900123400000000; //need a real user for the guest cases
                    }
                    sg.SignInSG();

                    //tell the reflector to request authdata
                    string []ret=RequestAuthDataUserProperty(sg, 0x0900123400000000, 0, new string[]{"CanPurchaseContent"});
                    ValueCheck.Test("CanPurchaseContent", (expect?"True":"False"), ret[0]);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\LSPProxyTest\GetSiteInfoNegativeStressTests.cs ===
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.QueryAndLsp;

namespace xonline.server.query.test.LSPProxyTest.GetSiteInfoTests {

	/// <summary>
	/// This TestNode represents a set of negative stress test cases for 
	/// the LSP proxy GetSiteInfo request. If the request returns false, then
	/// the test passes.
	/// </summary>
	[TestGroup]
	public class GetSiteInfoNegativeStressTests : TestNode {

		// Default values for the fields of a XRLLSPProxyGetSiteInfoRequest
		public static readonly uint DEFAULT_SITEID = 0xFFFF0072;

		/// <summary>
		/// The IPEndPoint of the LSP proxy server that these tests will be 
		/// run on.
		/// </summary>
		public static readonly IPEndPoint
			LSPPROXY_ENDPOINT = new IPEndPoint(IPAddress.Parse("10.20.200.39"), 8001);


		[StressTest]
        [StressInstantiate]
		public class BadSiteIDTest : TestBase {

			protected override void Execute () {
				XRLLSPProxyGetSiteInfoRequest request = new XRLLSPProxyGetSiteInfoRequest(0);

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				ResultCode = result? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\LSPProxyTest\GetSiteInfoPositiveStressTests.cs ===
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.QueryAndLsp;

namespace xonline.server.query.test.LSPProxyTest.GetSiteInfoTests {

	/// <summary>
	/// This TestNode represents a set of positive test cases for the LSP 
	/// Proxy GetSiteInfo request. If the request returns true, then the test 
	/// passes.
	/// </summary>
	[TestGroup]
	public class GetSiteInfoPositiveStressTests : TestNode {

		// Default values for the fields of a XRLLSPProxyGetSiteInfoRequest
		public static readonly uint DEFAULT_SITEID = 0xFFFF0072;

		/// <summary>
		/// The IPEndPoint of the LSP proxy server that these tests will be 
		/// run on.
		/// </summary>
		public static readonly IPEndPoint
			LSPPROXY_ENDPOINT = new IPEndPoint(IPAddress.Parse("10.20.200.39"), 8001);


		[StressTest]
        [StressInstantiate]
		public class SimpleTest : TestBase {

			protected override void Execute () {
				XRLLSPProxyGetSiteInfoRequest request = new XRLLSPProxyGetSiteInfoRequest(DEFAULT_SITEID);

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				ResultCode = result? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\AuthDataLibTest\Util.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;

using xonline.common.protocol;

namespace XLSPAuthDataLibTest
{
    public class Util
    {
        public static byte[] CallReflectorThroughSG(SgClient client, TestReflAction action, byte []data)
        {
            byte []msg=new byte[data.Length+1];
            msg[0]=(byte)action;
            System.Array.Copy(data, 0, msg, 1, data.Length);

            ushort srcPort=(ushort)ServerTestFramework.Utilities.RandomEx.GlobalRandGen.Next();
            ushort dstPort=(ushort)ServerTestFramework.LiveService.Auth.SGFakeService.IServicePort.TestRefl;

            Global.RO.Debug("Sending a "+msg.Length+" byte xsp payload...");
            client.XspSendData(msg, XspHeader.XSP_TYPE_UDP_2, srcPort, dstPort);
            return ReceiveSgData(client, 5000);
        }

        private static byte[] ReceiveSgData(SgClient client, int timeoutInMs)
        {
            System.DateTime startTime=System.DateTime.UtcNow;
            while ((System.DateTime.UtcNow-startTime).TotalMilliseconds<timeoutInMs)
            {
                XspPacket xsp=client.XspRecv(1000);
                if (xsp!=null)
                {
                    if (xsp.Message!=null)
                    {
                        byte []msg=new byte[xsp.MessageLength];
                        System.Array.Copy(xsp.Message, 0, msg, 0, xsp.MessageLength);

                        Global.RO.Debug("Received a "+msg.Length+" byte xsp payload.");
                        return msg;
                    }
                }
            }

            throw new System.Exception("Timed out receiving data from the SG after "+(System.DateTime.UtcNow-startTime).TotalMilliseconds+"ms.");
        }

        public static void ParseResponse(byte []inBlob, out byte []data, out string error)
        {
            error=null;
            data=null;

            if (inBlob.Length==0)
            {
                throw new System.Exception("No data");
            }

            if (inBlob[0]==0) //success
            {
                data=new byte[inBlob.Length-1];
                System.Array.Copy(inBlob, 1, data, 0, data.Length);
            }
            else
            {
                error="Error "+(int)inBlob[0]+" returned from testrefl: ";
                error+=ServerTestFramework.Utilities.ByteEncoding.Instance.GetString(inBlob, 1, inBlob.Length-1);
            }
        }

        public static string[] ParseNullStringSequence(byte []blob, int offset, int length)
        {
            System.Collections.Generic.List<string> list=new System.Collections.Generic.List<string>();

            System.Text.StringBuilder cur=new System.Text.StringBuilder();
            for (int l=0; l<length; ++l)
            {
                byte b=blob[offset+l];
                if (b==0)
                {
                    list.Add(cur.ToString());
                    cur=new System.Text.StringBuilder();
                }
                else
                {
                    cur.Append((char)b);
                }
            }

            if (cur.ToString().Length!=0)
            {
                throw new System.Exception("Partially complete string found at end of buffer: "+cur.ToString());
            }

            return list.ToArray();
        }

        public static byte[] CreateNullStringSequence(string []strings)
        {
            int totalLen=0;
            foreach (string s in strings)
            {
                totalLen+=s.Length;
            }
            totalLen+=strings.Length; //for nulls

            byte []data=new byte[totalLen];
            int dataInd=0;
            foreach (string s in strings)
            {
                for (int i=0; i<s.Length; ++i)
                {
                    data[dataInd++]=(byte)s[i];
                }
                data[dataInd++]=0;
            }

            return data;
        }

        public static void SetPrivilege(Authdata_Xenon ad, int privNumber, bool enable)
        {
            int whichDword=privNumber/32;
            int whichBit=privNumber%32;
            bool setBefore=(ad.dwPrivileges[whichDword]&(1<<whichBit))!=0;

            if (enable)
            {
                ad.dwPrivileges[whichDword]|=(uint)(1<<whichBit);

                 if (!setBefore)
                 {
                     ++ad.wNumPrivileges;
                 }
            }
            else
            {
                ad.dwPrivileges[whichDword]&=(uint)~(1<<whichBit);

                if (setBefore)
                {
                    --ad.wNumPrivileges;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\LSPProxyTest\AdvertiseNegativeStressTests.cs ===
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.QueryAndLsp;

namespace xonline.server.query.test.LSPProxyTest.AdvertiseTests
{

    /// <summary>
    /// The following group of tests represent negative test cases for the LSP 
    /// proxy. Because of the way the fields are set in the 
    /// XRLLSPProxyAdvertiseRequest, the request should fail. If the request 
    /// fails the ResultCode of the test will be set to PASSED.
    /// </summary>
    [TestGroup]
    public class AdvertiseNegativeStressTests : TestNode
    {

        private static readonly uint DEFAULT_TITLEID = 0xFFFF0072;
        private static readonly uint DEFAULT_TTL = 10;
        private static readonly uint DEFAULT_IP_SGLSP = 1;
        private static readonly uint DEFAULT_FLAGS = 0;
        private static readonly string DEFAULT_USERDATA = "My Advertisement";
        private static readonly byte[]
            DEFAULT_XNKID = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
        private static readonly byte[]
            DEFAULT_XNKEY = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
										 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

        /// <summary>
        /// The IPEndPoint of the LSP proxy server that these tests will be 
        /// run on.
        /// </summary>
        public static readonly IPEndPoint
            LSPPROXY_ENDPOINT = new IPEndPoint(IPAddress.Parse("10.20.200.39"), 8001);


        [StressTest, StressInstantiate]
        public class BadTitleIDTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = 0;
                request.ttlInSeconds = DEFAULT_TTL;
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class RestrictedTitleIDTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = 100;	//something valid but not 1234
                request.ttlInSeconds = DEFAULT_TTL;
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class SmallTTLTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = 5;	// min. for ttl is 10
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class ZeroTTLTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = 0;	// min. for ttl is 10
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class LargeTTLTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = 100001;	// max. for ttl is 100000
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class ExtraLargeTTLTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = 0xFFFFFFFF;	// max. for ttl is 100000
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class BadIPTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = DEFAULT_TTL;
                request.userData = DEFAULT_USERDATA;
                request.ipSgLsp = 0;	// min. is 1
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }

        [StressTest, StressInstantiate]
        public class NullTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class LongUserDataTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = DEFAULT_TTL;
                request.userData = new string('?', 201);	// max is 200 chars
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }


        [StressTest, StressInstantiate]
        public class ExtraLongUserDataTest : TestBase
        {
            protected override void Execute()
            {
                XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

                request.titleId = DEFAULT_TITLEID;
                request.ttlInSeconds = DEFAULT_TTL;
                request.userData = new string('?', 5000);	// max is 200 chars
                request.ipSgLsp = DEFAULT_IP_SGLSP;
                request.flags = DEFAULT_FLAGS;
                request.xnkid = DEFAULT_XNKID;
                request.xnkey = DEFAULT_XNKEY;

                ResultCode = TEST_RESULTS.NOT_EXECUTED;

                bool result = request.Execute(LSPPROXY_ENDPOINT);

                ResultCode = result ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\LSPProxyTest\LSPProxySimpleTests.cs ===
using System;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.QueryAndLsp;

namespace xonline.server.query.test.LSPProxyTest.SimpleTests {

	/// <summary>
	/// This test group represents some simple functional tests for the LSP 
	/// Proxy.
	/// </summary>
	[TestGroup]
	public class SimpleTests : TestNode {

		public static readonly IPAddress IP_ADDR = IPAddress.Parse("10.20.200.39");
		public static readonly int PORT = 8001;
		public static readonly UInt32 DEFAULT_TITLEID = 0xFFFF0072;
		public static readonly UInt32 DEFAULT_LSPSG_IP = 0x00000001;
		public static readonly UInt32 DEFAULT_TTL = 60;
		public static readonly string USER_DATA = "MyUserData";
		public static readonly byte[] DEFAULT_XN_KID = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
		public static readonly byte[] DEFAULT_XN_KEY = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
																	0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

		private static XRLLSPProxyAdvertiseRequest CreateDefaultAdvertiseRequest() 
		{
			XRLLSPProxyAdvertiseRequest advertiseRequest = new XRLLSPProxyAdvertiseRequest();
			advertiseRequest.titleId = DEFAULT_TITLEID;
			advertiseRequest.ipSgLsp = DEFAULT_LSPSG_IP;
			advertiseRequest.ttlInSeconds = DEFAULT_TTL;
			advertiseRequest.flags = 0;
			advertiseRequest.userData = USER_DATA;
			advertiseRequest.xnkey = DEFAULT_XN_KEY;
			advertiseRequest.xnkid = DEFAULT_XN_KID;

			return advertiseRequest;
		}

		/// <summary>
		/// This test simply advertises a title through the LSP Proxy.
		/// </summary>
		[TestCase]
		public class AdvertiseTest : TestBase {

			protected override void Execute () {

				IPEndPoint endPoint = new IPEndPoint(IP_ADDR, PORT);

				// Advertise this server on Live
				XRLLSPProxyAdvertiseRequest advertiseRequest = CreateDefaultAdvertiseRequest();
				Console.WriteLine("Sending advertisement.");
				bool advertiseSuccess = advertiseRequest.Execute(endPoint);

				if (!advertiseSuccess) {
					Console.WriteLine("Advertisement not registered.");
					Console.WriteLine("Error code: "+advertiseRequest.XErr.ToString());
					Console.WriteLine("HTTP status: "+advertiseRequest.httpStatus.ToString());
					//Console.WriteLine(advertiseRequest.getResponse().ToString());
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		/// <summary>
		/// This test simply calls GetSiteInfo through the LSP Proxy.
		/// </summary>
		[TestCase]
		public class GetSiteInfoTest : TestBase {

			protected override void Execute () {

				IPEndPoint endPoint = new IPEndPoint(IP_ADDR, PORT);

				// Advertise this server on Live
				XRLLSPProxyGetSiteInfoRequest getSiteInfoRequest = new XRLLSPProxyGetSiteInfoRequest(DEFAULT_TITLEID);
				Console.WriteLine("Requesting site info.");
				bool requestSuccess = getSiteInfoRequest.Execute(endPoint);

				if (!requestSuccess) {
					Console.WriteLine("Request unsuccessful.");
					Console.WriteLine("Error code: "+getSiteInfoRequest.XErr.ToString());
					Console.WriteLine("HTTP status: "+getSiteInfoRequest.httpStatus.ToString());
					ResultCode = TEST_RESULTS.FAILED;
					return;
				}

				Console.WriteLine("Response Time: "+getSiteInfoRequest.response.time);

				foreach (XRLKeyInfo key in getSiteInfoRequest.response.keys) {
					Console.WriteLine("Response Version: "+key.version+" Key: "+key.key);
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\LSPProxyTest\AdvertisePositiveStressTests.cs ===
using System;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.QueryAndLsp;

namespace xonline.server.query.test.LSPProxyTest.AdvertiseTests {

	/// <summary>
	/// This TestNode represents a group of functional tests designed to 
	/// be stress tested. Each test creates a XRLLSPProxyAdvertiseRequest to 
	/// advertise a title on the Live server. It then fills out the fields of 
	/// the request with some interesting, but valid, data. It then calls 
	/// XRLLSPProxyAdvertiseRequest.Execute which sends the request the 
	/// specified LSP proxy server. The return value of the Execute call 
	/// indicates whether the advertise request was successful or not. A value 
	/// of true indicates a successful advertisement of the server.
	/// </summary>
	[TestGroup]
	public class AdvertisePositiveStressTests : TestNode {

		public static void printError (XRLLSPProxyAdvertiseRequest request) {
			Console.WriteLine("XErr: "+request.XErr.ToString());
			Console.WriteLine("HTTP Status: "+request.httpStatus.ToString());
		}

		// Default values for the fields of a XRLLSPProxyAdvertiseRequest
		public static readonly uint DEFAULT_TITLEID = 0xFFFF0072;
		public static readonly uint DEFAULT_TTL = 10;
		public static readonly uint DEFAULT_IP_SGLSP = 1;
		public static readonly uint DEFAULT_FLAGS = 0;
		public static readonly string DEFAULT_USERDATA = "My Advertisement";
		public static readonly byte[]
			DEFAULT_XNKID = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
		public static readonly byte[]
			DEFAULT_XNKEY = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
										 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

		/// <summary>
		/// The IPEndPoint of the LSP proxy server that these tests will be 
		/// run on.
		/// </summary>
		public static readonly IPEndPoint 
			LSPPROXY_ENDPOINT = new IPEndPoint(IPAddress.Parse("10.20.200.39"), 8001);

		
		[StressTest, StressInstantiate]
		public class SimpleTest : TestBase {
			protected override void Execute () {
				XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

				request.titleId = DEFAULT_TITLEID;
				request.ttlInSeconds = DEFAULT_TTL;
				request.userData = DEFAULT_USERDATA;
				request.ipSgLsp = DEFAULT_IP_SGLSP;
				request.flags = DEFAULT_FLAGS;
				request.xnkid = DEFAULT_XNKID;
				request.xnkey = DEFAULT_XNKEY;

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				if (!result) printError(request);

				ResultCode = result? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}


		[StressTest, StressInstantiate]
		public class LongTTLTest : TestBase {
			protected override void Execute () {
				XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

				request.titleId = DEFAULT_TITLEID;
				request.ttlInSeconds = 100;
				request.userData = "My Advertisement";
				request.ipSgLsp = DEFAULT_IP_SGLSP;
				request.flags = DEFAULT_FLAGS;
				request.xnkid = DEFAULT_XNKID;
				request.xnkey = DEFAULT_XNKEY;

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				ResultCode = result? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}


		[StressTest, StressInstantiate]
		public class StrangeUserDataTest : TestBase {
			protected override void Execute () {
				XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

				request.titleId = DEFAULT_TITLEID;
				request.ttlInSeconds = DEFAULT_TTL;
				request.userData = "!@#$%^&*() INSERT users foo hello<>?<xml><html></html></xml>";
				request.ipSgLsp = DEFAULT_IP_SGLSP;
				request.flags = DEFAULT_FLAGS;
				request.xnkid = DEFAULT_XNKID;
				request.xnkey = DEFAULT_XNKEY;

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				ResultCode = result? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}


		[StressTest, StressInstantiate]
		public class LocalIPTest : TestBase {
			protected override void Execute () {
				XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

				request.titleId = DEFAULT_TITLEID;
				request.ttlInSeconds = DEFAULT_TTL;
				request.userData = DEFAULT_USERDATA;
				request.ipSgLsp = 0x7F000001;	// "127.0.0.1"
				request.flags = DEFAULT_FLAGS;
				request.xnkid = DEFAULT_XNKID;
				request.xnkey = DEFAULT_XNKEY;

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				ResultCode = result? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}


		[StressTest, StressInstantiate]
		public class SetFlagsTest : TestBase {
			protected override void Execute () {
				XRLLSPProxyAdvertiseRequest request = new XRLLSPProxyAdvertiseRequest();

				request.titleId = DEFAULT_TITLEID;
				request.ttlInSeconds = DEFAULT_TTL;
				request.userData = DEFAULT_USERDATA;
				request.ipSgLsp = DEFAULT_IP_SGLSP;
				request.flags = 5; //arbitrary number
				request.xnkid = DEFAULT_XNKID;
				request.xnkey = DEFAULT_XNKEY;

				ResultCode = TEST_RESULTS.NOT_EXECUTED;

				bool result = request.Execute(LSPPROXY_ENDPOINT);

				ResultCode = result? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\LSPProxyTest\LSPProxyTestSuite.cs ===
using ServerTestFramework;


namespace xonline.server.query.test.LSPProxyTest {

	/// <summary>
	/// <para>
	/// This TestSuite tests the LSP proxy server which is distributed to game 
	/// developers. Right now the only two requests that can be made 
	/// through the LSP proxy are the Advertise request and the GetSiteInfo 
	/// request. This test suite includes a set of stress tests that tests both
	/// of these requests against an LSP proxy server.
	/// </para>
	/// <para>
	/// The LSP proxy is tested indirectly by sending the requests through the 
	/// proxy, to a WebSG and ultimately to the front door LSP server in the 
	/// Live Service. Future tests should isolate the LSP proxy and intercept 
	/// the requests made to the WebSG. This would require a service that 
	/// returns valid responses just as the LSP front door server would.
	/// </para>
	/// </summary>
	public class LSPProxyTestSuite : TestSuite { }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\titleserver\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\lsptestfunctional.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;

using xonline.common.diagnostics;
using xonline.common.lsp;
//using xonline.common.nUnit;
//using xonline.common.protocol;
//using xonline.common.service;
//using xonline.common.stfutil;
//using xonline.common.mgmt;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.QueryAndLsp;
using ServerTestFramework.Utilities;

namespace xonline.server.query.test.dvt
{
    public partial class CacheUnawareTests
    {
        [TestGroup]
        public class LspPositive : LspTestBaseGroup_Negative  // yah, i know it says Negative
        {

            [TestCase]
            public void P_Advertise_Mainline_StfXrl ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Advertise_Ttl_10 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 10, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Advertise_Ttl_99999 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 99999, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Advertise_Ttl_100000 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 100000, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase, Description("0.0.0.1")]
            public void P_Advertise_Ip_0x00000001 ()
            {
                SafeAdvertiseAndVerify(defTitleId, 0x00000001, defTtl, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase, Description("128.0.0.0")]
            public void P_Advertise_Ip_0x80000000 ()
            {
                SafeAdvertiseAndVerify(defTitleId, 0x80000000, defTtl, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase, Description("0.0.0.128")]
            public void P_Advertise_Ip_0x00000080 ()
            {
                SafeAdvertiseAndVerify(defTitleId, 0x00000080, defTtl, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase, Description("255.255.255.254")]
            public void P_Advertise_Ip_0xFFFFFFFE ()
            {
                SafeAdvertiseAndVerify(defTitleId, 0xFFFFFFFE, defTtl, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase, Description("255.255.255.255")]
            public void P_Advertise_Ip_0xFFFFFFFF ()
            {
                SafeAdvertiseAndVerify(defTitleId, 0xFFFFFFFF, defTtl, 0, "LspFunctional", defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Advertise_UserData_Empty ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, string.Empty, defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Advertise_UserData_1 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, "", defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Advertise_UserData_200 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, new string('a', 200), defXnkid, defXnkey, true);
            }

            [TestCase, Ignore]
            public void P_Advertise_UserData_200_Zeroes ()
            {
                char[] c = new char[200];
                for (int i = 0; i < c.Length; i++)
                    c[i] = (char)(0);
                string s = new string(c);
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, s, defXnkid, defXnkey, true);
            }

            [TestCase]
            public void P_Enumerate_SetOne_GetOne ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Enumerate", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1, true);
                Assert.IsTrue(info.Length == 1);
            }

            [TestCase]
            public void P_Enumerate_Userdata_CaseSensitivity ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp + 123, defTtl, 0, "ENUMerate", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "enumerate", 0, 1, true);
                Assert.IsTrue(info.Length == 1);
                Assert.IsTrue(info[0].userData == "ENUMerate");
            }

            [TestCase]
            public void P_Enumerate_Userdata_CaseSensitivity2 ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp + 123, defTtl, 0, "ENUMerate", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "enumeRATe", 0, 1, true);
                Assert.IsTrue(info.Length == 1);
                Assert.IsTrue(info[0].userData == "ENUMerate");
            }

            [TestCase]
            public void P_Enumerate_1000Advertised ()
            {
                int i;
                LspLib.RemoveAll(defTitleId);
                for (i = 0; i < 1000; i++)
                {
                    CallAdvertise(defTitleId, (UInt32)(defIp + i), 1000, 0, "UserData" + i, defXnkid, defXnkey, true);
                }
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 1000);
                for (i = 0; i < 1000; i++)
                {
                    Assert.IsTrue(info[i].ipSgLsp == defIp + i);
                    Assert.IsTrue(info[i].userData == "UserData" + i);
                }
            }

            [TestCase]
            public void P_Enumerate_UserData200_FunkyChars ()
            {
                // 200 funky chars
                string userData = @"abasdflkj;[]1-2039218598767fkjgkjbhvlxxmbc./c.b,?><':L}{P_*((*Y!@#$%$%^&)(ASDFAZBBCSAFGSJDFGAwkjsdhkgfh3q04534-=5932523|DF}{[]d[9874213210.asdlfakjoi45987dfs.dfssjn1%$^@~``~212X<>/';}{|sdfs9076+_!23D";
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, userData, defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 1 && info[0].userData == userData);
                info = CallEnumerate(defTitleId, userData, 0, 1000, true);
                Assert.IsTrue(info.Length == 1 && info[0].userData == userData);
            }

            [TestCase]
            public void P_Scenario_SameUserdata_NoVip ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Scenario1", defXnkid, defXnkey, true);
                CallAdvertise(defTitleId, defIp + 1, defTtl, 0, "Scenario1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 2);
                Assert.IsTrue(info[0].userData == "Scenario1");
                Assert.IsTrue(info[1].userData == "Scenario1");
            }

            [TestCase]
            public void P_Scenario_DiffUserdata_NoVip ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Scenario1", defXnkid, defXnkey, true);
                CallAdvertise(defTitleId, defIp + 1, defTtl, 0, "Scenario2", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 2);
                Assert.IsTrue(info[0].userData == "Scenario1");
                Assert.IsTrue(info[1].userData == "Scenario2");
            }

            [TestCase]
            public void P_Scenario_SameUserdata_Vip ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Scenario1", defXnkid, defXnkey, true);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Scenario1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 1);
                Assert.IsTrue(info[0].userData == "Scenario1");
            }

            [TestCase]
            public void P_Scenario_DiffUserdata_Vip ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Scenario1", defXnkid, defXnkey, true);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "Scenario2", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 1);
                Assert.IsTrue(info[0].userData == "Scenario1" || info[0].userData == "Scenario2");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\lsptestnegative.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;

using xonline.common.diagnostics;
using xonline.common.lsp;
//using xonline.common.nUnit;
//using xonline.common.protocol;
//using xonline.common.service;
//using xonline.common.stfutil;
//using xonline.common.mgmt;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.QueryAndLsp;
using ServerTestFramework.Utilities;

namespace xonline.server.query.test.dvt
{
    public partial class CacheUnawareTests
    {
        [TestGroup, TestCasePriority(3)]
        public class LspNegative : LspTestBaseGroup_Negative
        {
            [TestCase]
            public void Advertise_Title_0xC0FE0800 ()
            {
                // Not in bucket
                try
                {
                    SafeAdvertiseAndVerify(0xC0FE0800, defIp, defTtl, 0, "LspFunctional", defXnkid, defXnkey, false);
                }
                catch
                {
                    return;
                }
                Fail("Advertise titleId 0xC0FE0800 (not in bucket) succeeded");
            }

            [TestCase]
            public void Advertise_Ttl_0 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 0, 0, "LspFunctional", defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_Ttl_1 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 1, 0, "LspFunctional", defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_Ttl_100001 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 100001, 0, "LspFunctional", defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_Ttl_0xFFFFFFFF ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, 0xFFFFFFFF, 0, "LspFunctional", defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_Ip_0x00000000 ()
            {
                SafeAdvertiseAndVerify(defTitleId, 0x00000000, defTtl, 0, "LspFunctional", defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_UserData_201 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, new string('a', 201), defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_UserData_600 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, new string('a', 600), defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_UserData_601 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, new string('a', 601), defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_UserData_65534 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, new string('a', 65534), defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_UserData_65000 ()
            {
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, new string('a', 65000), defXnkid, defXnkey, false);
            }


            [TestCase]
            public void Advertise_UserData_21845_Randomish ()
            {
                // Random data chokes the UTF8 encoding.
                char[] c = new char[21845];
                for (int i = 0; i < c.Length; i++)
                    c[i] = (char)((i * 3) % char.MaxValue);
                string s = new string(c);
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, s, defXnkid, defXnkey, false);
            }

            [TestCase]
            public void Advertise_UserData_200_Randomish ()
            {
                // Random data seems to get interpreted as UTF8 and expanded to nearly 3X the size
                char[] c = new char[200];
                for (int i = 0; i < c.Length; i++)
                    c[i] = (char)((i * 3) % char.MaxValue);
                string s = new string(c);
                SafeAdvertiseAndVerify(defTitleId, defIp, defTtl, 0, s, defXnkid, defXnkey, false);
            }


            [TestCase]
            public void Enumerate_Count1001 ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1001, false);
            }

            [TestCase]
            public void Enumerate_CountMax ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, UInt32.MaxValue, false);
            }

            [TestCase]
            public void Enumerate_Count0 ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 0, false);
            }

            [TestCase]
            public void Enumerate_IndexMax_Count2 ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, UInt32.MaxValue, 2, true);
                Assert.IsTrue(info == null || info.Length == 0);
            }

            [TestCase]
            public void Enumerate_IndexMax_CountMax ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, UInt32.MaxValue, UInt32.MaxValue, false);
            }

            [TestCase]
            public void Enumerate_NoneAdvertised_NoUserdata ()
            {
                LspLib.RemoveAll(defTitleId);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info == null || info.Length == 0);
            }

            [TestCase]
            public void Enumerate_1001Advertised ()
            {
                int i;
                LspEnumerateServerInfo[] info;
                LspLib.RemoveAll(defTitleId);
                for (i = 0; i < 1001; i++)
                {
                    CallAdvertise(defTitleId, (UInt32)(defIp + i), 1000, 0, "UserData" + i, defXnkid, defXnkey, true);
                }
                // 1001 should be too large of an input parameters
                info = CallEnumerate(defTitleId, string.Empty, 0, 1001, false);
                Assert.IsTrue(info.Length == 0);
                info = CallEnumerate(defTitleId, string.Empty, 0, 1000, true);
                Assert.IsTrue(info.Length == 1000);
                for (i = 0; i < 1000; i++)
                {
                    Assert.IsTrue(info[i].ipSgLsp == defIp + i);
                    Assert.IsTrue(info[i].userData == "UserData" + i);
                }
                info = CallEnumerate(defTitleId, string.Empty, 1000, 1000, true);
                Assert.IsTrue(info.Length == 1);
            }

            [TestCase]
            public void Enumerate_UserData201 ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, new string('a', 201), 0, 1000, false);
                Assert.IsTrue(info.Length == 0);
            }

            [TestCase]
            public void Enumerate_UserData65535 ()
            {
                LspLib.RemoveAll(defTitleId);
                CallAdvertise(defTitleId, defIp, defTtl, 0, "UserData1", defXnkid, defXnkey, true);
                LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, new string('a', 65535), 0, 1000, false);
                Assert.IsTrue(info.Length == 0);
            }

            [TestCase]
            public void Enumerate_BadTitle ()
            {
                CallEnumerate(0x12345678, string.Empty, 0, 100, false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\lsptest.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;

using xonline.common.diagnostics;
using xonline.common.lsp;
//using xonline.common.nUnit;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;
using xonline.common.mgmt;

using ServerTestFramework;
using stfls = ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Utilities;

namespace xonline.server.query.test.dvt
{

    /// <summary>
    /// LspTestBaseGroup for positive cases and DVTs. Uses the real server protocol definition.
    /// </summary>
    public class LspTestBaseGroup : TestNode
    {
        public const uint _titleId = 0xFFFF0083;
        public static byte[] _xnkid = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
        public static byte[] _xnkey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                                   0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

        public static void CallAdvertise(
            UInt32      titleId,
            UInt32      ipSgLsp,
            UInt32      ttlInSeconds,
            UInt32      flags,
            string      userData,
            byte[]      xnkid,
            byte[]      xnkey
            )
        {
            LspAdvertiseRequest req = new LspAdvertiseRequest();

            req.titleId         = titleId;
            req.ipSgLsp         = ipSgLsp;
            req.ttlInSeconds    = ttlInSeconds;
            req.flags           = flags;
            req.userData        = userData;
            req.xnkid           = xnkid;
            req.xnkey           = xnkey;

            MemoryStream reqBytes = new MemoryStream();
            req.WriteStream(reqBytes);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            byte[] repbuf;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, true, req.Xrl, reqBytes.ToArray(), out repbuf);

            if(HResult.Failed(hr))
            {
                throw new LspTestXrlException(req.Xrl, hr);
            }
        }

        public static void Populate(
            uint        startingIndex,
            uint        count,
            uint        ttlInSeconds)
        {
            byte[] xnkid = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
            byte[] xnkey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                          0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };
            for(uint i=0; i < count; i++)
            {
                uint entryIndex = startingIndex + i;

                xnkid[0] = (byte)entryIndex;
                xnkey[0] = (byte)entryIndex;

                CallAdvertise(_titleId,
                    0xFF000000 + entryIndex, 
                    ttlInSeconds,
                    0xFE000000 + entryIndex, 
                    "userData"+(entryIndex % 4).ToString(),
                    xnkid,
                    xnkey);

            }
        }

        public static void VerifyEnumerate(
            uint        startingIndex,
            uint        count,
            int         group)
        {
            Assert.IsTrue(group == -1 || (group >= 0 && group <= 3));

            byte[] xnkid = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
            byte[] xnkey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                          0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

            string userData = group == -1 ? string.Empty : "userData"+group.ToString();

            LspEnumerateReply reply;
            CallEnumerate(_titleId,
                userData,
                startingIndex,
                100,
                out reply);

            Assert.IsTrue(reply.lspInfoCount == count, 
                String.Format("Reply count does not match expectation: {0} != {1}",
                reply.lspInfoCount, count));
            // I suspect this assert cannot fire because WireData will have used reply.lspInfoCount
            // to set the length
            Assert.IsTrue(reply.lspInfo.Length == count,
                String.Format("Reply array length does not match expectation: {0} != {1}",
                reply.lspInfo.Length, count));

            Hashtable ht = new Hashtable((int)count);
            for(uint i=0; i < reply.lspInfo.Length; i++)
            {
                LspEnumerateServerInfo info = reply.lspInfo[i];
                
                uint entryIndex =  info.ipSgLsp - 0xFF000000;

                if(group == -1)
                {
                    Assert.IsTrue(entryIndex >= startingIndex && entryIndex < startingIndex + count);
                }
                else
                {
                    Assert.IsTrue(entryIndex >= startingIndex && entryIndex < startingIndex + count * 4 && entryIndex % 4 == group);
                }

                // detect duplicates - 'Add' throws on duplicates
                ht.Add(entryIndex, null);

                xnkid[0] = (byte)entryIndex;
                xnkey[0] = (byte)entryIndex;

                Assert.IsTrue(info.ipSgLsp  == 0xFF000000 + entryIndex);
                Assert.IsTrue(info.flags    == 0xFE000000 + entryIndex);
                Assert.IsTrue(info.userData == "userData"+(entryIndex % 4).ToString());
            }
        }

        public static void CallEnumerate(
            UInt32      titleId,
            string      userData,
            UInt32      resultIndex,
            UInt32      resultCount,
            out LspEnumerateReply reply)
        {
            LspEnumerateRequest req = new LspEnumerateRequest();

            req.titleId     = titleId;
            req.userData    = userData;
            req.resultIndex = resultIndex;
            req.resultCount = resultCount;
            
            MemoryStream reqBytes = new MemoryStream();
            req.WriteStream(reqBytes);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            byte[] repbuf;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, req.Xrl, reqBytes.ToArray(), out repbuf);

            if(HResult.Failed(hr))
            {
                throw new LspTestXrlException(req.Xrl, hr);
            }
            
            reply = new LspEnumerateReply();
            reply.ReadStream(new MemoryStream(repbuf));
        }

        public static void CallQuerySearch(
            uint                    titleId,
            uint                    datasetId,
            uint                    procIndex,
            uint                    page,
            uint                    resultsPerPage,
            QueryAttribute[]        inputAttributes,
            QueryAttributeSpec[]    specs,
            out uint                totalResults,
            out uint                returnedResults,
            out QueryAttribute[]    outputAttributes
            )
        {
            SearchRequest req = new SearchRequest();

            req.titleId         = titleId;
            req.datasetId       = datasetId;
            req.procIndex       = procIndex;
            req.page            = page;
            req.resultsPerPage  = resultsPerPage;
            req.specs           = specs;
            req.attribs         = inputAttributes;
            
            MemoryStream reqBytes = new MemoryStream();
            req.WriteStream(reqBytes);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleId;
            byte[] repbuf;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Query, false, req.GetXRL(), reqBytes.ToArray(), out repbuf);

            if(HResult.Failed(hr))
            {
                throw new LspTestXrlException(req.GetXRL(), hr);
            }

            SearchResponse reply = new SearchResponse();
            reply.ReadStream(new MemoryStream(repbuf));

            totalResults = reply.totalResults;
            returnedResults = reply.returnedResults;
            outputAttributes = reply.attribs;
        }
        
        public static void VerifyQuerySearch(
            uint        page,
            uint        count,
            int         group,
            uint        expectedReturnedResults,
            uint        expectedTotalResults)
        {
            Assert.IsTrue(group == -1 || (group >= 0 && group <= 3));
            
            uint startingIndex = page * count;

            byte[] xnkid = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
            byte[] xnkey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                          0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

            string userData = group == -1 ? string.Empty : "userData"+group.ToString();

            uint totalResults;
            uint returnedResults;
            
            QueryAttributeSpec[] specs = new QueryAttributeSpec[4];
            specs[0] = new QueryAttributeSpec(LspProtocolConstants.XONLINE_LSP_ATTR_TSADDR);
            specs[1] = new QueryAttributeSpec(LspProtocolConstants.XONLINE_LSP_ATTR_XNKID);
            specs[2] = new QueryAttributeSpec(LspProtocolConstants.XONLINE_LSP_ATTR_KEK);
            specs[3] = new QueryAttributeSpec(LspProtocolConstants.XONLINE_LSP_ATTR_USER);

            QueryAttribute[] inputAttributes;
            if(group == -1)
            {
                inputAttributes = new QueryAttribute[0];
            }
            else
            {
                inputAttributes = new QueryAttribute[1];
                inputAttributes[0] = new QueryAttribute(
                    LspProtocolConstants.XONLINE_LSP_ATTR_PARAM_USER,
                    userData);
            }
            
            QueryAttribute[] outputAttributes;

            CallQuerySearch(_titleId,
                LspProtocolConstants.XONLINE_LSP_DEFAULT_DATASET,
                1,
                page,
                count,
                inputAttributes,
                specs,
                out totalResults,
                out returnedResults,
                out outputAttributes);
            
            Assert.AreEqual(returnedResults, outputAttributes.Length / specs.Length);
            Assert.AreEqual(returnedResults, expectedReturnedResults);
            Assert.AreEqual(totalResults, expectedTotalResults);

            Hashtable ht = new Hashtable((int)count);
            uint attrIndex = 0;
            
            for(uint i=0; i < returnedResults; i++)
            {
                uint ipSgLsp;
                byte[] tsAddr;
                string userDataRead;
                byte[] xnkidRead;
                byte[] xnkeyRead;
                
                Assert.AreEqual(outputAttributes[attrIndex].Id, 
                    LspProtocolConstants.XONLINE_LSP_ATTR_TSADDR);

                tsAddr = outputAttributes[attrIndex].binValue;
                VerifyTsAddr(tsAddr, out ipSgLsp);
                attrIndex++;

                Assert.AreEqual(outputAttributes[attrIndex].Id,
                    LspProtocolConstants.XONLINE_LSP_ATTR_XNKID);
                xnkidRead = outputAttributes[attrIndex].binValue;
                attrIndex++;

                Assert.AreEqual(outputAttributes[attrIndex].Id,
                    LspProtocolConstants.XONLINE_LSP_ATTR_KEK);
                xnkeyRead = outputAttributes[attrIndex].binValue;
                attrIndex++;

                Assert.AreEqual(outputAttributes[attrIndex].Id,
                    LspProtocolConstants.XONLINE_LSP_ATTR_USER);
                userDataRead = outputAttributes[attrIndex].strValue;
                attrIndex++;
                
                uint entryIndex =  ipSgLsp - 0xFF000000;

                if(group == -1)
                {
                    Assert.IsTrue(entryIndex >= startingIndex && entryIndex < startingIndex + count);
                }
                else
                {
                    Assert.IsTrue(entryIndex >= startingIndex && entryIndex < startingIndex + count * 4 && entryIndex % 4 == group);
                }

                // detect duplicates - 'Add' throws on duplicates
                ht.Add(entryIndex, null);

                xnkid[0] = (byte)entryIndex;
                xnkey[0] = (byte)entryIndex;

                Assert.IsTrue(ipSgLsp  == 0xFF000000 + entryIndex);
                Assert.IsTrue(userDataRead == "userData"+(entryIndex % 4).ToString());
                Assert.IsTrue(CompareByteArray(xnkid, xnkidRead));
                Assert.IsTrue(CompareByteArray(xnkey, xnkeyRead));
            }
        }

        public static void VerifyTsAddr(byte[] tsAddr, out uint ipSgLsp)
        {
            ushort port;

            Assert.AreEqual(tsAddr.Length, 36);
            MemoryStream ms = new MemoryStream(tsAddr);
            BinaryReader br = new BinaryReader(ms);

            VerifyAllZeros(br.ReadBytes(4));
            ipSgLsp = (uint)IPAddress.NetworkToHostOrder(br.ReadInt32());
            port = (ushort)IPAddress.NetworkToHostOrder(br.ReadInt16());

            Assert.AreEqual(port, 3074);
            VerifyAllZeros(br.ReadBytes(26));
        }

        public static void VerifyAllZeros(byte[] bin)
        {
            for(int i=0; i < bin.Length; i++)
            {
                Assert.IsTrue(bin[i] == 0);
            }
        }

        public static bool CompareByteArray(byte[] array1, byte[] array2)
        {
            if(array1.Length != array2.Length)
                return false;

            for(int i=0; i < array1.Length; i++)
            {
                if(array1[i] != array2[i])
                    return false;
            }

            return true;
        }

        public static VerifyStatus VerifyExists(
            UInt32      titleId,
            UInt32      ipSgLsp,
            UInt32      flags,
            string      userData,
            byte[]      xnkid,
            byte[]      xnkey
            )
        {
            LspLib.LspInfo[] lspInfo;
            uint totalResults;

            LspLib.Enumerate(titleId, null, 0, 100, out lspInfo, out totalResults);

            for(int i=0; i < lspInfo.Length; i++)
            {
                LspLib.LspInfo info = lspInfo[i];

                if(info.ipSgLsp != ipSgLsp)
                    continue;

                if(info.flags == flags 
                    && info.userData == userData
                    && CompareByteArray(info.xnkid, xnkid)
                    && CompareByteArray(info.xnkey, xnkey))
                {
                    return VerifyStatus.Ok;
                }
                else
                {
                    return VerifyStatus.DataMismatch;
                }
            }

            return VerifyStatus.NotFound;
        }

        [TestGroupSetup]
        public void Setup()
        {
            xonline.common.config.Config.NpdbServer = xonline.common.config.Config.NpdbServer;
        }
    }

    // Because this uses _titleId + n, I am putting it on ignore by default
    [TestGroup, Ignore, DVT, Owner("johnmcp"), TestFrequency("Daily"), TestCasePriority(3)]
    class LspCacheAwareDVT : LspTestBaseGroup
    {
        private static int _idxAdvert1 = 0;
        private static int _idxAdvert2 = 0;
        private static int _idxAdvert3 = 0;

        [TestCase]
        public void Manual_Advertise_Title1_Ip1 ()
        {
            string userData = String.Format("title:1 ip:1 idx:{0}", _idxAdvert1++);
            CallAdvertise(_titleId + 1, 0x10101020, 60, 0xf, userData, _xnkid, _xnkey);
        }

        [TestCase]
        public void Manual_Advertise_Title1_Ip2 ()
        {
            string userData = String.Format("title:1 ip:2 idx:{0}", _idxAdvert2++);
            CallAdvertise(_titleId + 1, 0x10101030, 60, 0xf, userData, _xnkid, _xnkey);
        }

        [TestCase]
        public void Manual_Advertise_Title2_Ip3 ()
        {
            string userData = String.Format("title:2 ip:3 idx:{0}", _idxAdvert3++);
            CallAdvertise(_titleId + 2, 0x10101040, 60, 0xf, userData, _xnkid, _xnkey);
        }

        [TestCase]
        public void Manual_Enumerate_Title0 ()
        {
            LspEnumerateReply reply;
            CallEnumerate(_titleId, null, 0, 100, out reply);
            Global.RO.Debug("Enumerate: {0} results", reply.lspInfoCount);
            for (int i = 0; i < reply.lspInfoCount; i++)
            {
                LspEnumerateServerInfo info = reply.lspInfo[i];
                Global.RO.Debug("  ip: 0x{0:X}, userdata: {1}", info.ipSgLsp, info.userData);
            }
        }

        [TestCase]
        public void Manual_Enumerate_Title1 ()
        {
            LspEnumerateReply reply;
            CallEnumerate(_titleId + 1, null, 0, 100, out reply);
            Global.RO.Debug("Enumerate: {0} results", reply.lspInfoCount);
            for (int i = 0; i < reply.lspInfoCount; i++)
            {
                LspEnumerateServerInfo info = reply.lspInfo[i];
                Global.RO.Debug("  ip: 0x{0:X}, userdata: {1}", info.ipSgLsp, info.userData);
            }
        }

        [TestCase]
        public void Manual_Enumerate_Title2 ()
        {
            LspEnumerateReply reply;
            CallEnumerate(_titleId + 2, null, 0, 100, out reply);
            Global.RO.Debug("Enumerate: {0} results", reply.lspInfoCount);
            for (int i = 0; i < reply.lspInfoCount; i++)
            {
                LspEnumerateServerInfo info = reply.lspInfo[i];
                Global.RO.Debug("  ip: 0x{0:X}, userdata: {1}", info.ipSgLsp, info.userData);
            }
        }
    }

    public partial class CacheUnawareTests
    {
        [TestGroup, DVT, TestCasePriority(3)]
        public class Lsp : LspTestBaseGroup
        {
            [TestCase]
            public void Advertise ()
            {
                byte[] xnkid = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
                byte[] xnkey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                        0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

                LspLib.RemoveAll(_titleId);

                // first call to Advertise will test the insert code path
                CallAdvertise(_titleId, 1, 60, 0xf, "first call", xnkid, xnkey);
                Assert.IsTrue(VerifyStatus.Ok == VerifyExists(_titleId, 1, 0xf, "first call", xnkid, xnkey));

                // second call to Advertise will test the update code path
                Array.Reverse(xnkid);
                Array.Reverse(xnkey);
                CallAdvertise(_titleId, 0xf0000001, 60, 0xf0000000, "second call", xnkid, xnkey);
                Assert.IsTrue(VerifyStatus.Ok == VerifyExists(_titleId, 0xf0000001, 0xf0000000, "second call", xnkid, xnkey));
            }

            [TestCase]
            public void EnumerateAskManyReturnOne ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 1, 60);
                VerifyEnumerate(0, 1, -1);
            }

            [TestCase]
            public void EnumerateAskManyReturnMany ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 150, 60);
                VerifyEnumerate(0, 100, -1);
                VerifyEnumerate(100, 50, -1);
            }

            [TestCase]
            public void EnumerateAskManyReturnNone ()
            {
                LspLib.RemoveAll(_titleId);
                VerifyEnumerate(0, 0, -1);
            }

            [TestCase]
            public void EnumerateExpired ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 10, 60);
                Populate(10, 10, 10);
                VerifyEnumerate(0, 20, -1);

                Thread.Sleep(10500);

                VerifyEnumerate(0, 10, -1);
            }

            [TestCase]
            public void EnumerateByUserData ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 400, 60);
                VerifyEnumerate(0, 100, 0);
                VerifyEnumerate(0, 100, 1);
                VerifyEnumerate(0, 100, 2);
                VerifyEnumerate(0, 100, 3);
            }

            [TestCase, Ignore]
            public void QEnumerateAskManyReturnOne ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 1, 60);
                VerifyQuerySearch(0, 1, -1, 1, 1);
            }

            [TestCase, Ignore]
            public void QEnumerateAskManyReturnMany ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 150, 60);
                VerifyQuerySearch(0, 100, -1, 100, 150);
                VerifyQuerySearch(1, 100, -1, 50, 150);
            }

            [TestCase, Ignore]
            public void QEnumerateAskManyReturnNone ()
            {
                LspLib.RemoveAll(_titleId);
                VerifyQuerySearch(0, 100, -1, 0, 0);
            }

            [TestCase, Ignore]
            public void QEnumerateExpired ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 10, 60);
                Populate(10, 10, 10);
                VerifyQuerySearch(0, 100, -1, 20, 20);

                Thread.Sleep(10500);

                VerifyQuerySearch(0, 100, -1, 10, 10);
            }

            [TestCase, Ignore]
            public void QEnumerateByUserData ()
            {
                LspLib.RemoveAll(_titleId);
                Populate(0, 80, 60);
                VerifyQuerySearch(0, 100, 0, 20, 20);
                VerifyQuerySearch(0, 100, 1, 20, 20);
                VerifyQuerySearch(0, 100, 2, 20, 20);
                VerifyQuerySearch(0, 100, 3, 20, 20);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\lspteststress.cs ===
using System;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService.QueryAndLsp;

namespace xonline.server.query.test.dvt
{
    [TestGroup]
    public class LspFdStressTests : TestNode {

        private static readonly byte[] DEFAULT_XNKID = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
        private static readonly byte[] DEFAULT_XNKEY = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                                                   0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

        private const uint StressTitleID = 0xFFFF0083;

        private static Report ro = new Report("LspFd");

        public static void Fail(string format, params object[] args)
        {
            ro.Warn(String.Format(format, args));
        }

        [StressTest, StressInstantiate]
        public class Advertise : TestBase
        {
            static int count = 0;

            protected override void Execute ()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int idx = System.Threading.Interlocked.Increment(ref count);
                if (count > 1000)
                    count = 0;

                XRLLspAdvertiseRequest req = new XRLLspAdvertiseRequest();

                req.titleId         = StressTitleID;
                req.ipSgLsp         = (uint)idx;
                req.ttlInSeconds    = 60;
                req.flags           = 0;
                req.userData        = "LspFd Stress Test " + idx;
                req.xnkid           = DEFAULT_XNKID;
                req.xnkey           = DEFAULT_XNKEY;

                bool bRet = req.Execute();
                if (!bRet)
                {
                    Fail("[Add] XRLLspAdvertiseRequest failed XErr=0x{0:X8} HTTPStatus={1}",
                         req.XErr,
                         req.httpStatus
                        );
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }


        [StressTest, StressInstantiate]
        public class Enumerate_1 : TestBase
        {
            static int count = 0;

            protected override void Execute ()
            {
                ResultCode = TEST_RESULTS.PASSED;
                int idx = System.Threading.Interlocked.Increment(ref count);
                if (count > 1000)
                    count = 0;

                XRLLspEnumerateRequest req = new XRLLspEnumerateRequest();

                req.titleId         = StressTitleID;
                req.userData        = "LspFd Stress Test " + idx;
                req.resultIndex     = 0;
                req.resultCount     = 100;

                bool bRet = req.Execute();
                if (!bRet)
                {
                    Fail("[Add] XRLLspEnumerateRequest failed XErr=0x{0:X8} HTTPStatus={1}",
                         req.XErr,
                         req.httpStatus
                        );
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                if (req.Response.lspInfoCount == 1)
                {
                    if (req.Response.lspInfo[0].ipSgLsp != (uint)idx)
                    {
                        Fail("Expecting IP to be {0}, got {1}", idx, req.Response.lspInfo[0].ipSgLsp);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                else if (req.Response.lspInfoCount != 0)
                {
                    // anything but 1 or 0 is strange...
                    Fail("Enumerate 1 got {0} responses", req.Response.lspInfoCount);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
        [StressTest, StressInstantiate]
        public class Enumerate_100 : TestBase
        {
            protected override void Execute ()
            {
                ResultCode = TEST_RESULTS.PASSED;
                XRLLspEnumerateRequest req = new XRLLspEnumerateRequest();

                req.titleId         = StressTitleID;
                req.userData        = String.Empty;
                req.resultIndex     = 0;
                req.resultCount     = 100;

                bool bRet = req.Execute();
                if (!bRet)
                {
                    Fail("[Add] XRLLspEnumerateRequest failed XErr=0x{0:X8} HTTPStatus={1}",
                         req.XErr,
                         req.httpStatus
                        );
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        // CoD4 is no longer special
#if false
        // CoD4 tests
        [StressTest, StressInstantiate]
        public class AdvertiseCoD4 : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                XRLLspAdvertiseRequest req = new XRLLspAdvertiseRequest();

                req.titleId = 0x415607e6;
                req.ipSgLsp = 0x00000001;
                req.ttlInSeconds = 120;
                req.flags = 0;
                req.userData = "";
                req.xnkid = DEFAULT_XNKID;
                req.xnkey = DEFAULT_XNKEY;

                bool bRet = req.Execute();
                if (!bRet)
                {
                    Fail("[Add] XRLLspAdvertiseRequest failed XErr=0x{0:X8} HTTPStatus={1}",
                         req.XErr,
                         req.httpStatus
                        );
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }


        [StressTest, StressInstantiate]
        public class EnumerateCoD4 : TestBase
        {
            public override TEST_RESULTS Run ()
            {
                XRLLspEnumerateRequest req = new XRLLspEnumerateRequest();

                req.titleId = 0x415607e6;
                req.userData = "";
                req.resultIndex = 0;
                req.resultCount = 50;

                bool bRet = req.Execute();
                if (!bRet)
                {
                    Fail("[Add] XRLLspEnumerateRequest failed XErr=0x{0:X8} HTTPStatus={1}",
                         req.XErr,
                         req.httpStatus
                        );
                    return TEST_RESULTS.FAILED;
                }

                return TEST_RESULTS.PASSED;
            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\titleserver\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\lsptestcommon.cs ===
using System;
using System.Collections;
using System.IO;
using System.Net;
using System.Text;
//using System.Threading;
using xonline.common.diagnostics;
using xonline.common.lsp;
//using xonline.common.nUnit;
//using xonline.common.protocol;
//using xonline.common.service;
//using xonline.common.stfutil;
//using xonline.common.mgmt;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.QueryAndLsp;
using ServerTestFramework.Utilities;

using xonline.common.config;

[assembly: RootNode(typeof(xonline.server.query.test.dvt.LspTestSuite))]

namespace xonline.server.query.test.dvt
{
    public class LspTestSuite : TestNode
    {
        public override void PreRun ()
        {
            if (!ServerTestFramework.STFTools.LiveTitle.CheckIfTitleIsPropped(LspTestBaseGroup._titleId))
            {
                throw new Exception("Title 0x" + LspTestBaseGroup._titleId.ToString("X8") + " is not propped, these tests cannot run without it.");
            }
        }
    }

    public class LspTestXrlException : Exception
    {
        public LspTestXrlException(string req, uint hr) : 
            base(string.Format("Request {0} failed. Hr = 0x{1:x8}", req, hr))
        {}
    }

    public class LspTestXrlException2 : Exception
        {
        public LspTestXrlException2(string format, params object[] args) : 
            base(String.Format(format, args)) 
        {}
    }

    public enum VerifyStatus
    {
        Ok              = 0,
        NotFound        = 1,
        DataMismatch    = 2
    };

    [TestGroup, Owner("johnmcp"), TestFrequency("Daily"), TestCasePriority(2)]
    public partial class CacheUnawareTests : TestNode
    {
        private SettingState _prev_cache_setting = null;

        public override void PreRun (RUN_TYPE runType)
        {
            // disable caching
            _prev_cache_setting = Global.XEnv.OverrideSetting(Component.lspfd, "ALL", 
                Setting.lspfd_databaseCachingEnabled, "0");

            // force it to be picked up
            Global.XEnv.ForceConfigReload(Interface.lspfd);

            // flush cache
            Global.XEnv.ExecuteXmgmtCommand(Interface.lspfd, "e :" + Component.lspfd + " enumcacheflush");
        }

        public override void PostRun (RUN_TYPE runType)
        {
            // return to previous value
            if (_prev_cache_setting.wasoverriden)
            {
                Global.XEnv.OverrideSetting(Component.lspfd, "ALL", Setting.lspfd_databaseCachingEnabled, 
                    _prev_cache_setting.oldvalue);
            }
            else
            {
                Global.XEnv.DeleteOverrideSetting(Component.lspfd, "ALL", Setting.lspfd_databaseCachingEnabled);
            }

            // force it to be picked up
            Global.XEnv.ForceConfigReload(Interface.lspfd);
        }
    }

    /// <summary>
    /// LspTestBaseGroup for negative cases. Uses the STF protocols.  
    /// By "negative", I mean it uses the STF protocols that have no wiredata bound checks.
    /// </summary>
    public class LspTestBaseGroup_Negative : TestNode
    {
        //protected UInt32 defTitleId       = 0xC0FE0800;
        protected UInt32 defTitleId       = 0xFFFF0083;
        protected UInt32 defIp            = 0x00000001;
        protected UInt32 defTtl           = 60;

        protected byte[] defXnkid = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 };
        protected byte[] defXnkey = new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
                                                 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10 };

        protected static Report ro = new Report("Lsp");

        public static void Fail(string format, params object[] args)
        {
            ro.Warn(String.Format(format, args));
            throw new LspTestXrlException2(format, args);
        }

        public static XRLLspAdvertiseRequest CallAdvertise(
            UInt32      titleId,
            UInt32      ipSgLsp,
            UInt32      ttlInSeconds,
            UInt32      flags,
            string      userData,
            byte[]      xnkid,
            byte[]      xnkey,
            bool        bExpectSuccess
            )
        {
            XRLLspAdvertiseRequest req = new XRLLspAdvertiseRequest();

            req.titleId         = titleId;
            req.ipSgLsp         = ipSgLsp;
            req.ttlInSeconds    = ttlInSeconds;
            req.flags           = flags;
            req.userData        = userData;
            req.xnkid           = xnkid;
            req.xnkey           = xnkey;

            bool bRet = req.Execute();
            // Sucess
            if (bExpectSuccess && bRet)
                return req;
            if (!bExpectSuccess && !bRet)
                return req;
            // Failure
            if (bRet)
            {
                Fail("CallAdvertise succeeded, expected failure");
            }
            else
            {
                Fail("[Add] XRLLspAdvertiseRequest failed XErr=0x{0:X8} HTTPStatus={1} for titleId=0x{2:X8}, ip=0x{3:X8}, ttl={4}, flags=0x{5:X8}, userData={6}, xnkid={7}, xnkey={8}",
                    req.XErr,
                    req.httpStatus,
                    titleId,
                    ipSgLsp,
                    ttlInSeconds,
                    flags,
                    userData,
                    Hexer.tohex(xnkid),
                    Hexer.tohex(xnkey)
                    );
            }
            return req;
        }

        public static LspEnumerateServerInfo[] CallEnumerate(
            UInt32      titleId,
            string      userData,
            UInt32      resultIndex,
            UInt32      resultCount,
            bool        bExpectSuccess
            )
        {
            XRLLspEnumerateRequest req = new XRLLspEnumerateRequest();

            req.titleId         = titleId;
            req.userData        = userData;
            req.resultIndex     = resultIndex;
            req.resultCount     = resultCount;

            bool bRet = req.Execute();

            // Sucess
            if (bExpectSuccess && bRet)
                return req.Response.lspInfo;
            if (!bExpectSuccess && !bRet)
                return new LspEnumerateServerInfo[0];

            // Failures
            if (!bExpectSuccess && bRet)
            {
                Fail("CallEnumerate succeeded, expected failure");
            }
            if (bExpectSuccess && (!bRet || req.Response == null))
            {
                Fail("[Add] XRLLspEnumerateRequest failed XErr=0x{0:X8} HTTPStatus={1} for titleId=0x{2:X8},userData={3}, resultIndex={4}, resultCount={5}",
                    req.XErr,
                    req.httpStatus,
                    titleId,
                    userData,
                    resultIndex,
                    resultCount
                    );
            }
            return null;
        }
                
        public static void Populate(
            uint        startingIndex,
            uint        count,
            uint        ttlInSeconds)
        {
            LspTestBaseGroup.Populate(startingIndex, count, ttlInSeconds);
        }

        public static VerifyStatus VerifyExists(
            UInt32      titleId,
            UInt32      ipSgLsp,
            UInt32      flags,
            string      userData,
            byte[]      xnkid,
            byte[]      xnkey
            )
        {
            return LspTestBaseGroup.VerifyExists(titleId, ipSgLsp, flags, userData, xnkid, xnkey);
        }

        public static void SafeAdvertiseAndVerify(
            UInt32          titleId,
            UInt32          ipSgLsp,
            UInt32          ttlInSeconds,
            UInt32          flags,
            string          userData,
            byte[]          xnkid,
            byte[]          xnkey,
            bool            bExpectSuccess
            )
        {
            //VerifyStatus status;
            LspEnumerateServerInfo[] lspInfo;

            // Remove all traces of previous tests
            LspLib.RemoveAll(titleId);

            // Advertise
            CallAdvertise(titleId, ipSgLsp, ttlInSeconds, flags, userData, xnkid, xnkey, bExpectSuccess);

            // Enumerate
            lspInfo = CallEnumerate(titleId, string.Empty, 0, 1000, true);

            // Done if advertise failed and enumerate failed
            if (!bExpectSuccess && (lspInfo == null || lspInfo.Length == 0))
            {
                return;
            }

            // Fail if advertise succeed but enumerate failed
            if (bExpectSuccess && (lspInfo == null || lspInfo.Length == 0))
            {
                Fail("Advertise succeeded but enumerate returned no results");
            }

            // Fail if advertise failed but enumerate succeeded
            if (!bExpectSuccess && (lspInfo != null && lspInfo.Length > 0))
            {
                Fail("Advertise failed but enumerate returned {0} results", lspInfo.Length);
            }

            // If advertise succeeded and enumerate succeeded, verify results
            for (int i=0; i < lspInfo.Length; i++)
            {
                LspEnumerateServerInfo info = lspInfo[i];
                userData = userData.TrimEnd(new char[] { '\0' });

                Assert.IsTrue(info.ipSgLsp == ipSgLsp, 
                    String.Format("Reply IP does not match expectation: {0} != {1}",
                    new IPAddress((long)info.ipSgLsp), new IPAddress((long)ipSgLsp)));
                Assert.IsTrue(info.flags == flags);
                Assert.IsTrue(info.userData.Length == userData.Length,
                    String.Format("Reply user data length does not match expectation: {0} != {1}", 
                    info.userData.Length, userData.Length));
                if (userData.Length > 0)
                {
                    Assert.IsTrue(info.userData == userData);
                }
//                    Fail("Enumerated values don't match advertised values for info #{0}; input[ipSgLsp=0x{1:X8}, flags={2}, userData={3}], results[ipSgLsp=0x{4:X8}, flags={5}, userData={6}]",
//                        i,
//                        ipSgLsp,
//                        flags,
//                        userData,
//                        info.ipSgLsp,
//                        info.flags,
//                        info.userData);
            }

            // Let's double verify by hitting the DB directly.
            // Comment out for now since this is mysteriously failing.
            // TODO: why is this failing now?
#if false
            status = VerifyExists(titleId, ipSgLsp, flags, userData, xnkid, xnkey);
            if (status != VerifyStatus.Ok)
            {
                Fail("VerifyExists (direct db hit) failed");
            }
#endif
        }



#if false
        public static void RemoveAllBruteForce(uint titleId)
        {
            SqlConnection connection = null;
            SqlCommand cmd = null;
            string[] queryIps = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.querydb);

            try
            {
                foreach (string ip in queryIps)
                {
                    connection = new SqlConnection("server=" + ip +";database=QueryDB;Integrated Security=SSPI"); 
                    cmd = new SqlCommand("dbo.p_lsp_remove_all", connection);
                    cmd.CommandType = System.Data.CommandType.StoredProcedure;
                    cmd.Parameters.Add("@i_title_id", System.Data.SqlDbType.Int).Value = titleId;
                    cmd.ExecuteNonQuery();
                    connection.Close();
                }
            }
            catch
            {
                connection.Close();
                throw;
            }
        }
#endif


        [TestGroupSetup]
        public void Setup()
        {
            xonline.common.config.Config.NpdbServer = xonline.common.config.Config.NpdbServer;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\lsptest\lspcaching.cs ===
using System;

using ServerTestFramework;
using ServerTestFramework.LiveService.QueryAndLsp;

using xonline.server.query.test.dvt;
using xonline.common.diagnostics;

namespace LspTest
{
    [TestGroup, Owner("johnmcp"), TestFrequency("Daily")]
    class LspCacheAware : LspTestBaseGroup_Negative
    {
        [TestCase, Description("A simple advertise/enumerate pair."), TestCasePriority(1)]
        public void P_Mainline ()
        {
            CallAdvertise(defTitleId, defIp, defTtl, 0, "Mainline", defXnkid, defXnkey, true);
            LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "Mainline", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == defIp);
        }

        [TestCase, Description("Verify that we are caching by enumerating the old value after an advertise, then the new value after the expiry."), TestCasePriority(1)]
        public void P_CacheChange ()
        {
            CallAdvertise(defTitleId, defIp, 30, 0, "CacheChange", defXnkid, defXnkey, true);
            LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "CacheChange", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == defIp);

            // advertise again with different ip, watch for cache
            uint newip = 0x12345678;

            CallAdvertise(defTitleId, newip, 180, 0, "CacheChange", defXnkid, defXnkey, true);
            info = CallEnumerate(defTitleId, "CacheChange", 0, 1000, true);
            Assert.IsTrue(info.Length == 1, 
                String.Format("Enumerated a different number of servers than expected: {0} != 1", 
                info.Length));
            Assert.IsTrue(info[0].ipSgLsp == defIp);

            // wait 2 minutes for cache to expire
            System.Threading.Thread.Sleep(32 * 1000);

            info = CallEnumerate(defTitleId, "CacheChange", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == newip,
                String.Format("Enumerated a different ip than expected: {0} != {1} (was it {2}?)",
                info[0].ipSgLsp, newip, defIp));
        }

        [TestCase, Description("Change the UserData in the enumerate to verify that the previously cached value is not returned."), TestCasePriority(1)]
        public void P_CacheChange_Bypass_Cache_UserData ()
        {
            CallAdvertise(defTitleId, defIp, 120, 0, "UserData", defXnkid, defXnkey, true);
            LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "UserData", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == defIp);

            // advertise again with different ip, watch for cache
            uint newip = 0x12345678;

            CallAdvertise(defTitleId, newip, 180, 0, "UserData2", defXnkid, defXnkey, true);
            info = CallEnumerate(defTitleId, "UserData2", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == newip);
        }

        [TestCase, Description("Change the Start in the enumerate to verify that the previously cached value is not returned."), TestCasePriority(1)]
        public void P_CacheChange_Bypass_Cache_Start ()
        {
            CallAdvertise(defTitleId, defIp, 120, 0, "Start", defXnkid, defXnkey, true);
            LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "Start", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == defIp);

            // advertise again with different ip, watch for cache
            uint newip = 0x12345678;

            CallAdvertise(defTitleId, newip, 180, 0, "Start", defXnkid, defXnkey, true);
            info = CallEnumerate(defTitleId, "Start", 1, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == newip);
        }

        [TestCase, Description("Change the Total in the enumerate to verify that the previously cached value is not returned."), TestCasePriority(1)]
        public void P_CacheChange_Bypass_Cache_Total ()
        {
            CallAdvertise(defTitleId, defIp, 120, 0, "Total", defXnkid, defXnkey, true);
            LspEnumerateServerInfo[] info = CallEnumerate(defTitleId, "Total", 0, 1000, true);
            Assert.IsTrue(info.Length == 1);
            Assert.IsTrue(info[0].ipSgLsp == defIp);

            // advertise again with different ip, watch for cache
            uint newip = 0x12345678;

            CallAdvertise(defTitleId, newip, 180, 0, "Total", defXnkid, defXnkey, true);
            info = CallEnumerate(defTitleId, "Total", 0, 200, true);
            Assert.IsTrue(info.Length == 2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\titleserver\EchoThread.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.IO;
using System.Text;

namespace LSPTitleServer
{
    public class HttpHeaders
    {
        enum HeaderState {Scanning, FirstCR, FirstLF, SecondCR, Done};

        public static bool ReadHeaders(NetworkStream ns, out Int32 httpCode)
        {
            HeaderState readState = HeaderState.Scanning;

            httpCode = 0;
            byte [] currentHeader = new byte[2048];
            Int32 i = 0, currentByte = 0;
            while(true)
            {
                currentByte = ns.ReadByte();

                // If we reach the end of the net stream w/o finding end of headers, fail
                if(currentByte == -1)
                    return false;

                currentHeader[i] = (byte) currentByte;

                switch(readState)
                {
                    case HeaderState.Scanning:
                        if(currentByte == (Int32) Byte.Parse("\r"))
                            readState = HeaderState.FirstCR;
                        break;
                    case HeaderState.FirstCR:
                        if(currentByte == (Int32) Byte.Parse("\n"))
                            readState = HeaderState.FirstLF;
                        else
                            readState = HeaderState.Scanning;
                        break;
                    case HeaderState.FirstLF:
                        if(currentByte == (Int32) Byte.Parse("\r"))
                            readState = HeaderState.SecondCR;
                        else
                            readState = HeaderState.Scanning;
                        break;
                    case HeaderState.SecondCR:
                        if(currentByte == (Int32) Byte.Parse("\n"))
                            readState = HeaderState.Done;
                        else
                            readState = HeaderState.Scanning;
                        break;
                }

                if(readState == HeaderState.FirstLF)
                {
                    // Process this header
                    currentHeader[i + 1] = 0;

                    // Start reading in the next header
                    i = 0;

                    string httpHeader = "HTTP/1.1 ";
                    string headerString = Encoding.ASCII.GetString(currentHeader);
                    int httpIndex = headerString.IndexOf(httpHeader);
                    if(httpIndex == 0)
                    {
                        // Check the http code value just after the HTTP header
                        httpCode = Int32.Parse(headerString.Substring(httpHeader.Length, httpHeader.Length + 3));
                    }
                }

                if(readState == HeaderState.Done)
                    return true;

                if(i++ > currentHeader.Length - 1)
                    return false;
            }
        }
    }

    /// <summary>
    /// 
    /// </summary>
    public abstract class EchoThread 
    {
        // Event to signal that the sever needs to be shutdown
        protected ManualResetEvent shutdownServer = new ManualResetEvent(false);
        protected Thread mainThread = null;
        protected IPAddress listenIPAddress = IPAddress.Parse("127.0.0.1");
        protected int listenPort = 0;

        // These functions will be implemented in derived classes
        public abstract void Startup();
        public abstract void Shutdown();
    }

    public class TCPEchoThread : EchoThread
    {
        public class StateObject 
        {
            // Client  socket.
            public Socket workSocket = null;
            // Size of receive buffer.
            public const int BufferSize = 8192;
            // Receive buffer.
            public byte[] buffer = new byte[BufferSize];
        }

        // Keep an array of connected sockets so we can close them
        // when signalled by the main app thread
        private ArrayList activeSocketsList = new ArrayList();
        private System.Windows.Forms.Label activeCountLabel = null;
        private System.Windows.Forms.TextBox textDebug = null;

        public TCPEchoThread(System.Windows.Forms.Label label, System.Windows.Forms.TextBox text, int port, IPAddress address) 
        {
            // TODO - add the ability to configure the NIC and port that is bound to

            activeCountLabel = label;
            textDebug = text;
            listenPort = port;
            listenIPAddress = address;
        }

        // Overridden public functions
        public override void Startup()
        {
            shutdownServer.Reset();
            mainThread = new Thread(new ThreadStart(this.ListeningThread));
            mainThread.Start();
        }

        public override void Shutdown()
        {
            shutdownServer.Set();
            if(!mainThread.Join(2000))
            {
                mainThread.Abort();
            }

            // Close all connected sockets
            lock(activeSocketsList)
            {
                foreach(Socket client in activeSocketsList)
                {
                    client.Shutdown(SocketShutdown.Both);
                    client.Close();
                }
            }

        }

        public int ActiveClientCount()
        {
            int activeClientCount = 0;                

            lock(activeSocketsList)
            {
                activeClientCount = activeSocketsList.Count;
            }

            return activeClientCount;
        }


        public void ListeningThread() 
        {
            // Determine the local interface to listen on
            IPEndPoint localEndPoint = new IPEndPoint(listenIPAddress, listenPort);

            // Create a TCP/IP socket.
            Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp );

            lock(textDebug)
            {
                textDebug.Text += "TCP Socket: " + listener.GetHashCode() + " created\r\n";
            }

            // Bind the socket to the local endpoint and listen for incoming connections.
            try 
            {
                // Start listening for inbound connections
                listener.Bind(localEndPoint);
                listener.Listen(1000);

                // As long as we haven't been told to shut-down, continue accepting sockets
                while(!shutdownServer.WaitOne(0, false)) 
                {
                    // Poll for 100 ms at a time to see if there are incoming sockets pending
                    if(!listener.Poll(100000, SelectMode.SelectRead))
                        continue;

                    // If so, then accept the new socket
                    Socket newClient = listener.Accept();

                    lock(textDebug)
                    {
                        textDebug.Text += "Incoming TCP connection: " + newClient.GetHashCode() + " accepted\r\n";
                    }

                    lock(activeSocketsList)
                    {
                        activeSocketsList.Add(newClient);
                        activeCountLabel.Text = activeSocketsList.Count.ToString();
                    }

                    // Create the state object.
                    StateObject state = new StateObject();
                    state.workSocket = newClient;
                    newClient.BeginReceive( state.buffer, 0, StateObject.BufferSize, 0,
                        new AsyncCallback(this.ReadCallback), state);
                }

            } 
            catch (Exception e) 
            {
                Console.WriteLine(e.ToString());
                lock(textDebug)
                {
                    textDebug.Text += "Exception: " + 3 + "\r\n";
                }
            }

            listener.Close();

            return;
        }

        public void ReadCallback(IAsyncResult ar) 
        {
            String content = String.Empty;
        
            // Retrieve the state object and the handler socket
            // from the asynchronous state object.
            StateObject state = (StateObject) ar.AsyncState;
            Socket receivingSocket = state.workSocket;

            // Read data from the client socket. 
            int bytesRead = receivingSocket.EndReceive(ar);

            if (bytesRead > 0) 
            {
                // We recieved some data, echo it back
                receivingSocket.Send(state.buffer, bytesRead, SocketFlags.None);

                // Now start the next receive
                receivingSocket.BeginReceive(state.buffer, 0, StateObject.BufferSize, 0,
                    new AsyncCallback(ReadCallback), state);
            }
            else
            {
                // The other side closed the connection
                lock(activeSocketsList)
                {
                    activeSocketsList.Remove(receivingSocket);
                    activeCountLabel.Text = activeSocketsList.Count.ToString();;
                }
            }
        }    
    }

    public class UDPEchoThread : EchoThread
    {
        // Keep a dictionary of endpoints that are sending data
        protected Timer endpointTimer = null;
        protected EndPointDictionary activeEndPoints = new EndPointDictionary();
        private System.Windows.Forms.Label activeCountLabel = null;
        private System.Windows.Forms.TextBox textDebug = null;

        void ProcessActiveEndPoints(Object state)
        {
            /*            DateTime currentTime = DateTime.UtcNow;
                        TimeSpan timeSinceLastPacket;

                        lock(activeEndPoints)
                        {
                            // Remove all clients that haven't sent data to us in the last 10 seconds
                            foreach(IPEndPoint currentEndPoint in activeEndPoints)
                            {
                                timeSinceLastPacket = currentTime - activeEndPoints[currentEndPoint].lastDataReceivedTime;
                                if(timeSinceLastPacket.TotalSeconds > (double) 10.0)
                                {
                                    activeEndPoints.Remove(currentEndPoint);
                                    activeCountLabel.Text = activeEndPoints.Count.ToString();
                                }
                            }
                        }
            */
        }

        public UDPEchoThread(System.Windows.Forms.Label label, System.Windows.Forms.TextBox text, int port, IPAddress address) 
        {
            // TODO - add the ability to configure the NIC and port that is bound to
            // TODO - add the time threshold for how often connections must send data to be considered "active"

            activeCountLabel = label;
            textDebug = text;
            listenPort = port;
            listenIPAddress = address;
        }

        // Overridden public functions
        public override void Startup()
        {
            shutdownServer.Reset();
            mainThread = new Thread(new ThreadStart(this.EchoThread));
            mainThread.Start();
            TimerCallback timerDelegate = new TimerCallback(ProcessActiveEndPoints);
            endpointTimer = new Timer(timerDelegate, null, 1000, 1000);
        }

        public override void Shutdown()
        {
            endpointTimer.Dispose();
            endpointTimer = null;

            shutdownServer.Set();
            if(!mainThread.Join(2000))
            {
                mainThread.Abort();
            }
        }

        public int ActiveClientCount()
        {
            int activeClientCount = 0;                

            /*            lock(activeEndPoints)
                        {
                            activeClientCount = activeEndPoints.Count;
                        }
            */

            return activeClientCount;
        }


        public void EchoThread() 
        {
            // Determine the local interface to listen on
            IPEndPoint localEndPoint = new IPEndPoint(listenIPAddress, listenPort);
            IPEndPoint remoteIPEndPoint = new IPEndPoint(IPAddress.Any, 0);
            EndPoint remoteEndPoint = (EndPoint) remoteIPEndPoint;
            byte[] buffer = new byte[1500];

            // Create a UDP socket.
            Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            lock(textDebug)
            {
                textDebug.Text += "UDP Socket: " + listener.GetHashCode() + " created\r\n";
            }

            // Bind the socket to the local endpoint and listen for incoming connections.
            try 
            {
                // Start listening for inbound connections
                listener.Bind(localEndPoint);

                // As long as we haven't been told to shut-down, continue accepting sockets
                while(!shutdownServer.WaitOne(0, false)) 
                {
                    // Poll for 100 ms at a time to see if there are incoming datagrams pending
                    if(!listener.Poll(100000, SelectMode.SelectRead))
                        continue;

                    int bytesReceived = listener.ReceiveFrom(buffer, ref remoteEndPoint);
                    ulong uBytesRead = 0;
                    try
                    {
                        uBytesRead = Convert.ToUInt64(bytesReceived);
                    }
                    catch(System.OverflowException e)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "Exception: " + e + "\r\n";
                        }
                    }

                    lock(textDebug)
                    {
                        textDebug.Text += "Received " + uBytesRead + " bytes from " + remoteEndPoint.ToString() + "\r\n";
                    }

                    remoteIPEndPoint = (IPEndPoint) remoteEndPoint;

                    /*                    lock(activeEndPoints)
                                        {
                                            if(activeEndPoints.Contains(remoteIPEndPoint))
                                            {
                                                // We've seen this client before, update their existing statistics
                                                EndPointAssociatedData currentEndPointData = activeEndPoints[remoteIPEndPoint];
                                                currentEndPointData.lastDataReceivedTime = DateTime.UtcNow;
                                                currentEndPointData.totalBytesReceived += uBytesRead;
                                                activeEndPoints[remoteIPEndPoint] = currentEndPointData;
                                            }
                                            else
                                            {
                                                // This is a new client, add a new batch of statistics
                                                EndPointAssociatedData newEndPointData = new EndPointAssociatedData();
                                                newEndPointData.firstDataReceivedTime = DateTime.UtcNow;
                                                newEndPointData.lastDataReceivedTime = DateTime.UtcNow;
                                                newEndPointData.totalBytesReceived = uBytesRead;
                                                activeEndPoints[remoteIPEndPoint] = newEndPointData;
                                                activeCountLabel.Text = activeEndPoints.Count.ToString();
                                            }
                                        }
                    */

                    lock(textDebug)
                    {
                        textDebug.Text += "Sending " + bytesReceived + " bytes to " + remoteIPEndPoint.ToString() + "\r\n";
                    }

                    listener.SendTo(buffer, bytesReceived, SocketFlags.None, remoteIPEndPoint);
                }

            } 
            catch (Exception e) 
            {
                Console.WriteLine(e.ToString());
            }

            listener.Close();

            return;
        }

    }

    public class AuthReqEchoThread : EchoThread
    {
        private System.Windows.Forms.Label labelAuthReq = null;
        private System.Windows.Forms.TextBox textDebug = null;

        public AuthReqEchoThread(System.Windows.Forms.Label label, System.Windows.Forms.TextBox text, int port, IPAddress address) 
        {
            // TODO - add the ability to configure the NIC and port that is bound to
            // TODO - add the time threshold for how often connections must send data to be considered "active"

            labelAuthReq = label;
            textDebug = text;
            listenPort = port;
            listenIPAddress = address;
        }

        // Overridden public functions
        public override void Startup()
        {
            shutdownServer.Reset();
            mainThread = new Thread(new ThreadStart(this.EchoThread));
            mainThread.Start();
        }

        public override void Shutdown()
        {
            shutdownServer.Set();
            if(!mainThread.Join(2000))
            {
                mainThread.Abort();
            }
        }

        public void EchoThread() 
        {
            // Determine the local interface to listen on
            IPEndPoint localEndPoint = new IPEndPoint(listenIPAddress, listenPort);
            IPEndPoint remoteIPEndPoint = new IPEndPoint(IPAddress.Any, 0);
            EndPoint remoteEndPoint = (EndPoint) remoteIPEndPoint;
            byte[] recvBuffer = new byte[128];

            // Create a UDP socket.
            Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            lock(textDebug)
            {
                textDebug.Text += "Auth Req Socket: " + listener.GetHashCode() + " created\r\n";
            }

            // Bind the socket to the local endpoint and listen for incoming connections.
            try 
            {
                // Start listening for inbound connections
                listener.Bind(localEndPoint);

                // As long as we haven't been told to shut-down, continue accepting sockets
                while(!shutdownServer.WaitOne(0, false)) 
                {
                    // Poll for 100 ms at a time to see if there are incoming datagrams pending
                    if(!listener.Poll(100000, SelectMode.SelectRead))
                        continue;

                    int bytesReceived = listener.ReceiveFrom(recvBuffer, ref remoteEndPoint);
                    
                    // Just make sure that the packet isn't empty, the request won't matter though
                    if(bytesReceived <= 0)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "Auth Req Socket: Received empty packet\r\n";
                        }

                        continue;
                    }
                    
                    remoteIPEndPoint = (IPEndPoint) remoteEndPoint;

                    lock(textDebug)
                    {
                        textDebug.Text += "Auth Req Socket: Received auth request from client " + remoteIPEndPoint.ToString() + "\r\n";
                    }

                    ushort wPort = (ushort) remoteIPEndPoint.Port;
                    SGInfo authInfo = new SGInfo(remoteIPEndPoint.Address, wPort);
                    MemoryStream ms = new MemoryStream();
                    BinaryWriter wr = new BinaryWriter(ms);

                    wr.Write(authInfo.TitleId);
                    wr.Write(authInfo.TitleVersion);
                    wr.Write(authInfo.LogonUsers[0].qwUserID);
                    wr.Write(authInfo.LogonUsers[1].qwUserID);
                    wr.Write(authInfo.LogonUsers[2].qwUserID);
                    wr.Write(authInfo.LogonUsers[3].qwUserID);
                    byte [] respBuffer = ms.ToArray();

                    lock(textDebug)
                    {
                        textDebug.Text += "Auth Req Socket: Sending auth data back to client " + remoteIPEndPoint.ToString() + "\r\n";
                    }

                    listener.SendTo(respBuffer, respBuffer.Length, SocketFlags.None, remoteIPEndPoint);
                }

            } 
            catch (Exception e) 
            {
                Console.WriteLine(e.ToString());
            }

            listener.Close();

            return;
        }

    }

    public class GamerTagLookupEchoThread : EchoThread
    {
        private System.Windows.Forms.Label labelGTLookupReq = null;
        private System.Windows.Forms.TextBox textDebug = null;
        IPAddress lspProxyAddr = null;
        UInt16 lspProxyPort = 0;

        public GamerTagLookupEchoThread(System.Windows.Forms.Label label, System.Windows.Forms.TextBox text, string proxyAddr, string proxyPort, int port, IPAddress address) 
        {
            // TODO - add the ability to configure the NIC and port that is bound to
            // TODO - add the time threshold for how often connections must send data to be considered "active"

            labelGTLookupReq = label;
            textDebug = text;
            listenPort = port;
            listenIPAddress = address;
            lspProxyAddr = IPAddress.Parse(proxyAddr);
            lspProxyPort = UInt16.Parse(proxyPort);
        }

        // Overridden public functions
        public override void Startup()
        {
            shutdownServer.Reset();
            mainThread = new Thread(new ThreadStart(this.EchoThread));
            mainThread.Start();
        }

        public override void Shutdown()
        {
            shutdownServer.Set();
            if(!mainThread.Join(2000))
            {
                mainThread.Abort();
            }
        }

        public void EchoThread() 
        {
            // Determine the local interface to listen on
            IPEndPoint localEndPoint = new IPEndPoint(listenIPAddress, listenPort);
            IPEndPoint remoteIPEndPoint = new IPEndPoint(IPAddress.Any, 0);
            EndPoint remoteEndPoint = (EndPoint) remoteIPEndPoint;
            byte[] recvDatagram = new byte[8];

            // Create a UDP socket.
            Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            lock(textDebug)
            {
                textDebug.Text += "GT Lookup Socket: " + listener.GetHashCode() + " created\r\n";
            }

            // Bind the socket to the local endpoint and listen for incoming connections.
            try 
            {
                // Start listening for inbound connections
                listener.Bind(localEndPoint);

                // As long as we haven't been told to shut-down, continue accepting sockets
                while(!shutdownServer.WaitOne(0, false)) 
                {
                    MemoryStream ms;
                    BinaryReader re;
                    BinaryWriter wr;

                    // Poll for 100 ms at a time to see if there are incoming datagrams pending
                    if(!listener.Poll(100000, SelectMode.SelectRead))
                        continue;

                    int bytesReceived = listener.ReceiveFrom(recvDatagram, ref remoteEndPoint);
                    
                    if(bytesReceived < 8)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "GamerTag Lookup Socket: Received " + bytesReceived + " bytes, expected 8\r\n";
                        }
                        continue;
                    }

                    // Read the binary values from the memory stream (this will be more
                    // useful when we start sending larger structures)
                    ms = new MemoryStream(recvDatagram);
                    re = new BinaryReader(ms);

                    // For right now, we're just reading one PUID and forwarding it
                    uint countPuids = 1;
                    ulong puid = re.ReadUInt64();

                    lock(textDebug)
                    {
                        textDebug.Text += "GamerTag Lookup Socket: Received lookup request for 0x" + puid.ToString("X") + "\r\n";
                    }

                    remoteIPEndPoint = (IPEndPoint) remoteEndPoint;

                    // Build the body of our puid lookup request
                    ms = new MemoryStream();
                    wr = new BinaryWriter(ms);

                    // Convert to ASCII because that's all the client understands
                    wr.Write(countPuids);
                    wr.Write(puid);

                    byte [] gamerTagReqBody = ms.ToArray();

                    // Build the headers for the lookup request
                    StringBuilder headers = new StringBuilder("POST /LiveProxy/LookupPUID.aspx HTTP/1.1\r\n");
                    headers.Append("Title-id: FFFFAB22\r\n");
                    headers.Append("Content-Type: xon/0\r\n");
                    headers.Append("Content-Length: " + gamerTagReqBody.Length + "\r\n");
                    headers.Append("Expect: 100-continue\r\n");
                    headers.Append("Host: " + lspProxyAddr.ToString() + "\r\n");
                    headers.Append("User-Agent: 0/1.00.65535\r\n");
                    headers.Append("\r\n");

                    // Conver the headers to ASCII
                    byte [] gamerTagReqHeaders = Encoding.Convert(Encoding.Unicode,
                        Encoding.ASCII,
                        Encoding.Unicode.GetBytes(headers.ToString()));

                    TcpClient gamerTagReqClient = new TcpClient();
                    gamerTagReqClient.Connect(lspProxyAddr, lspProxyPort);
                    NetworkStream ns = gamerTagReqClient.GetStream();

                    lock(textDebug)
                    {
                        textDebug.Text += "GamerTag Lookup Socket: Sending GamerTag lookup to " + lspProxyAddr.ToString() + " for PUID 0x" + puid.ToString("X") + "\r\n";
                    }

                    // Send the headers and the body
                    ns.Write(gamerTagReqHeaders, 0, gamerTagReqHeaders.Length);
                    ns.Write(gamerTagReqBody, 0, gamerTagReqBody.Length);
    
                    // Read off the http headers
                    Int32 httpCode;
                    if(!HttpHeaders.ReadHeaders(ns, out httpCode))
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "GamerTag Lookup Socket: Failed reading response headers\r\n";
                        }
                        continue;
                    }

                    if(httpCode != 200)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "GamerTag Lookup Socket: HTTP " + httpCode.ToString() + " returned\r\n";
                        }
                        continue;
                    }

                    lock(textDebug)
                    {
                        textDebug.Text += "GamerTag Lookup Socket: HTTP 200 returned\r\n";
                    }

                    // Use a BinaryReader on the network stream to read the response
                    re = new BinaryReader(ns);

                    // Right now we're only going to parse one GamerTag
                    uint countGamerTags = re.ReadUInt32();
                    if(countGamerTags == 0)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "GamerTag Lookup Socket: No GamerTags returned by LSP Proxy\r\n";
                        }
                        continue;
                    }

                    // This containst the raw 32 bytes of the unicode gamertag
                    byte [] rawGamerTag = re.ReadBytes(32);

                    // Put them into a unicode string so we can display them easily
                    string unicodeGamerTag = Encoding.Unicode.GetString(rawGamerTag);

                    lock(textDebug)
                    {
                        textDebug.Text += "GamerTag Lookup Socket: Sending back GamerTag " + unicodeGamerTag + " for PUID 0x" + puid.ToString("8X") + "\r\n";
                    }

                    // Now prepare the datagram to send back to the client
                    ms = new MemoryStream();
                    wr = new BinaryWriter(ms);

                    // Convert to ASCII because that's all the client understands
                    wr.Write(Encoding.Convert(Encoding.Unicode, Encoding.ASCII, rawGamerTag, 0, 32));

                    byte [] sendDatagram = ms.ToArray();

                    // Send the response from the LSP proxy back to the Xbox client
                    listener.SendTo(sendDatagram, remoteIPEndPoint);

                    // Update the form UI to show that we completed one more request
                    lock(labelGTLookupReq)
                    {
                        int gtReqs = Int32.Parse(labelGTLookupReq.Text);
                        ++gtReqs;
                        labelGTLookupReq.Text = gtReqs.ToString();
                    }
                }

            } 
            catch (Exception e) 
            {
                Console.WriteLine(e.ToString());
            }

            listener.Close();

            return;
        }

    }

    public class PUIDLookupEchoThread : EchoThread
    {
        private System.Windows.Forms.Label labelPUIDLookupReq = null;
        private System.Windows.Forms.TextBox textDebug = null;
        IPAddress lspProxyAddr = null;
        UInt16 lspProxyPort = 0;

        public PUIDLookupEchoThread(System.Windows.Forms.Label label, System.Windows.Forms.TextBox text, string proxyAddr, string proxyPort, int port, IPAddress address) 
        {
            // TODO - add the ability to configure the NIC and port that is bound to
            // TODO - add the time threshold for how often connections must send data to be considered "active"

            labelPUIDLookupReq = label;
            textDebug = text;
            listenPort = port;
            listenIPAddress = address;
            lspProxyAddr = IPAddress.Parse(proxyAddr);
            lspProxyPort = UInt16.Parse(proxyPort);
        }

        // Overridden public functions
        public override void Startup()
        {
            shutdownServer.Reset();
            mainThread = new Thread(new ThreadStart(this.EchoThread));
            mainThread.Start();
        }

        public override void Shutdown()
        {
            shutdownServer.Set();
            if(!mainThread.Join(2000))
            {
                mainThread.Abort();
            }
        }

        public void EchoThread() 
        {
            // Determine the local interface to listen on
            IPEndPoint localEndPoint = new IPEndPoint(listenIPAddress, listenPort);
            IPEndPoint remoteIPEndPoint = new IPEndPoint(IPAddress.Any, 0);
            EndPoint remoteEndPoint = (EndPoint) remoteIPEndPoint;
            byte[] recvDatagram = new byte[16];

            // Create a UDP socket.
            Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );

            lock(textDebug)
            {
                textDebug.Text += "PUID Lookup Socket: " + listener.GetHashCode() + " created\r\n";
            }

            // Bind the socket to the local endpoint and listen for incoming connections.
            try 
            {
                // Start listening for inbound connections
                listener.Bind(localEndPoint);

                // As long as we haven't been told to shut-down, continue accepting sockets
                while(!shutdownServer.WaitOne(0, false)) 
                {
                    MemoryStream ms;
                    BinaryReader re;
                    BinaryWriter wr;

                    // Poll for 100 ms at a time to see if there are incoming datagrams pending
                    if(!listener.Poll(100000, SelectMode.SelectRead))
                        continue;

                    int bytesReceived = listener.ReceiveFrom(recvDatagram, ref remoteEndPoint);
                    
                    // Just make sure that the packet isn't empty, the request won't matter though
                    if(bytesReceived <= 16)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "PUID Lookup Socket: Received " + bytesReceived + " bytes from Xbox client, expected a GamerTag\r\n";
                        }

                        continue;
                    }
                    
                    // Read the binary values from the memory stream (this will be more
                    // useful when we start sending larger structures)
                    ms = new MemoryStream(recvDatagram);
                    re = new BinaryReader(ms);

                    // For right now, just read one gamertag and convert it to Unicode
                    uint countGamerTags = 1;
                    byte [] gamerTag = re.ReadBytes(16);

                    lock(textDebug)
                    {
                        textDebug.Text += "PUID Lookup Socket: Received lookup request for  " + Encoding.ASCII.GetString(gamerTag) + "\r\n";
                    }

                    remoteIPEndPoint = (IPEndPoint) remoteEndPoint;

                    // Build the body of our puid lookup request
                    ms = new MemoryStream();
                    wr = new BinaryWriter(ms);

                    // Convert to ASCII because that's all the client understands
                    wr.Write(countGamerTags);
                    wr.Write(Encoding.Convert(Encoding.ASCII, Encoding.Unicode, gamerTag, 0, 16));

                    byte [] puidReqBody = ms.ToArray();

                    // Build the headers for the lookup request
                    StringBuilder headers = new StringBuilder("POST /LiveProxy/LookupGamertag.aspx HTTP/1.1\r\n");
                    headers.Append("Title-id: FFFFAB22\r\n");
                    headers.Append("Content-Type: xon/0\r\n");
                    headers.Append("Content-Length: " + puidReqBody.Length + "\r\n");
                    headers.Append("Expect: 100-continue\r\n");
                    headers.Append("Host: " + lspProxyAddr.ToString() + "\r\n");
                    headers.Append("User-Agent: 0/1.00.65535\r\n");
                    headers.Append("\r\n");

                    // Conver the headers to ASCII
                    byte [] puidReqHeaders = Encoding.Convert(Encoding.Unicode,
                        Encoding.ASCII,
                        Encoding.Unicode.GetBytes(headers.ToString()));

                    TcpClient puidReqClient = new TcpClient();
                    puidReqClient.Connect(lspProxyAddr, lspProxyPort);
                    NetworkStream ns = puidReqClient.GetStream();

                    lock(textDebug)
                    {
                        textDebug.Text += "PUID Lookup Socket: Sending PUID lookup to " + lspProxyAddr.ToString() + " for GamerTag" + Encoding.ASCII.GetString(gamerTag) + "\r\n";
                    }

                    // Send the headers and the body
                    ns.Write(puidReqHeaders, 0, puidReqHeaders.Length);
                    ns.Write(puidReqBody, 0, puidReqBody.Length);

                    // Read off the http headers
                    Int32 httpCode;
                    if(!HttpHeaders.ReadHeaders(ns, out httpCode))
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "PUID Lookup Socket: Failed reading response headers\r\n";
                        }
                        continue;
                    }

                    if(httpCode != 200)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "PUID Lookup Socket: HTTP " + httpCode.ToString() + " returned\r\n";
                        }
                        continue;
                    }

                    lock(textDebug)
                    {
                        textDebug.Text += "PUID Lookup Socket: HTTP 200 returned\r\n";
                    }

                    // Use a BinaryReader on the network stream to read the response
                    re = new BinaryReader(ns);
                    
                    // Right now we're only going to read one puid
                    uint countPUIDs = re.ReadUInt32();
                    if(countPUIDs == 0)
                    {
                        lock(textDebug)
                        {
                            textDebug.Text += "PUID Lookup Socket: No PUIDs returned by LSP Proxy\r\n";
                        }
                        continue;
                    }

                    // This contains the raw 32 bytes of the unicode gamertag
                    ulong puid = re.ReadUInt64();

                    // We're done reading the response, close the stream
                    ns.Close();

                    lock(textDebug)
                    {
                        textDebug.Text += "PUID Lookup Socket: Sending back PUID " + puid + " for GamerTag " + Encoding.ASCII.GetString(gamerTag) + "\r\n";
                    }

                    // Now prepare the datagram to send back to the client
                    ms = new MemoryStream();
                    wr = new BinaryWriter(ms);

                    // Write the puid to the to the datagram buffer
                    wr.Write(puid);
                    byte [] sendDatagram = ms.ToArray();

                    // Send the response from the LSP proxy back to the Xbox client
                    listener.SendTo(sendDatagram, remoteIPEndPoint);

                    // Update the form UI to show that we completed one more request
                    lock(labelPUIDLookupReq)
                    {
                        int puidReqs = Int32.Parse(labelPUIDLookupReq.Text);
                        ++puidReqs;
                        labelPUIDLookupReq.Text = puidReqs.ToString();
                    }
                }

            } 
            catch (Exception e) 
            {
                Console.WriteLine(e.ToString());
            }

            listener.Close();

            return;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\titleserver\LSPTitleServer.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Threading;
using System.Net;
using System.Net.Sockets;

namespace LSPTitleServer
{
    /// <summary>
    /// Summary description for LSPTitleServer.
    /// </summary>
    public class LSPTitleServerForm : System.Windows.Forms.Form
    {
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Button buttonStartStop;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        private bool serverIsRunning = false;
        private System.Windows.Forms.Label labelTCPClients1000;
        private System.Windows.Forms.Label labelUDPClients1000;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.Label labelUDPClients1001;
        private System.Windows.Forms.Label labelTCPClients1001;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.GroupBox groupBox2;
        private TCPEchoThread tcpServer1000 = null;
        private TCPEchoThread tcpServer1001 = null;
        private UDPEchoThread udpServer1000 = null;
        private UDPEchoThread udpServer1001 = null;
        private AuthReqEchoThread arEcho1002 = null;
        private PUIDLookupEchoThread plEcho1003 = null;
        private GamerTagLookupEchoThread gtlEcho1004 = null;
        private System.Windows.Forms.ComboBox comboIPSelect;
        private System.Windows.Forms.TextBox textDebug;
        private System.Windows.Forms.GroupBox groupBox3;
        private System.Windows.Forms.GroupBox groupBox4;
        private System.Windows.Forms.GroupBox groupBox5;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.Label labelAuthReq;
        private System.Windows.Forms.Label labelPUIDLookup;
        private System.Windows.Forms.Label labelGamerTagLookups;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.TextBox textProxyAddr;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.TextBox textProxyPort;
        private System.Windows.Forms.Label label3;
        private int BasePort;

        public LSPTitleServerForm(int baseport)
        {
            BasePort = baseport;
            String hostName = "";


            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // Initialize the IP combobox
            //

            // First, get our local hostname for use with DNS
            try 
            {
                // Get the local computer host name.
                hostName = Dns.GetHostName();
            }
            catch(SocketException e) 
            {
                System.Windows.Forms.MessageBox.Show("SocketException caught!!!  Source : " + e.Source + ", Message : " + e.Message);
            }
            catch(Exception e)
            {
                System.Windows.Forms.MessageBox.Show("Exception caught!!!  Source : " + e.Source + ", Message : " + e.Message);
            }

            try 
            {
                IPHostEntry hostInfo = Dns.GetHostEntry(hostName);
                // Get the IP address list that resolves to the host names contained in the 
                // Alias property.
                IPAddress[] address = hostInfo.AddressList;

                for(int index=0; index < address.Length; index++) 
                {
                    comboIPSelect.Items.Add(address[index]);
                }
            }
            catch(SocketException e) 
            {
                System.Windows.Forms.MessageBox.Show("SocketException caught!!!  Source : " + e.Source + ", Message : " + e.Message);
            }
            catch(Exception e)
            {
                System.Windows.Forms.MessageBox.Show("SocketException caught!!!  Source : " + e.Source + ", Message : " + e.Message);
            }

            // If there are no IP addresses... then add the loopback address
            if(comboIPSelect.Items.Count == 0)
            {
                comboIPSelect.Items.Add(IPAddress.Parse("127.0.0.1"));
            }

            comboIPSelect.SelectedIndex = 0;

            groupBox1.Text = "Port " + (BasePort + 0).ToString();
            groupBox2.Text = "Port " + (BasePort + 1).ToString();
            groupBox3.Text = "Port " + (BasePort + 2).ToString();
            groupBox4.Text = "Port " + (BasePort + 3).ToString();
            groupBox5.Text = "Port " + (BasePort + 4).ToString();
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }

                if(tcpServer1000 != null)
                {
                    tcpServer1000.Shutdown();
                    tcpServer1000 = null;
                }

                if(tcpServer1001 != null)
                {
                    tcpServer1001.Shutdown();
                    tcpServer1001 = null;
                }

                if(udpServer1000 != null)
                {
                    udpServer1000.Shutdown();
                    udpServer1000 = null;
                }

                if(udpServer1001 != null)
                {
                    udpServer1001.Shutdown();
                    udpServer1001 = null;
                }

                if(arEcho1002 != null)
                {
                    arEcho1002.Shutdown();
                    arEcho1002 = null;
                }

                if(plEcho1003 != null)
                {
                    plEcho1003.Shutdown();
                    plEcho1003 = null;
                }

                if(gtlEcho1004 != null)
                {
                    gtlEcho1004.Shutdown();
                    gtlEcho1004 = null;
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.labelTCPClients1000 = new System.Windows.Forms.Label();
            this.labelUDPClients1000 = new System.Windows.Forms.Label();
            this.buttonStartStop = new System.Windows.Forms.Button();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.labelUDPClients1001 = new System.Windows.Forms.Label();
            this.labelTCPClients1001 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.comboIPSelect = new System.Windows.Forms.ComboBox();
            this.label3 = new System.Windows.Forms.Label();
            this.textDebug = new System.Windows.Forms.TextBox();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.labelAuthReq = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.groupBox4 = new System.Windows.Forms.GroupBox();
            this.labelPUIDLookup = new System.Windows.Forms.Label();
            this.label7 = new System.Windows.Forms.Label();
            this.groupBox5 = new System.Windows.Forms.GroupBox();
            this.labelGamerTagLookups = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.textProxyAddr = new System.Windows.Forms.TextBox();
            this.label10 = new System.Windows.Forms.Label();
            this.textProxyPort = new System.Windows.Forms.TextBox();
            this.groupBox3.SuspendLayout();
            this.groupBox4.SuspendLayout();
            this.groupBox5.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(32, 144);
            this.label1.Name = "label1";
            this.label1.TabIndex = 0;
            this.label1.Text = "Active TCP clients:";
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(32, 176);
            this.label2.Name = "label2";
            this.label2.TabIndex = 1;
            this.label2.Text = "Active UDP clients:";
            // 
            // labelTCPClients1000
            // 
            this.labelTCPClients1000.Location = new System.Drawing.Point(152, 144);
            this.labelTCPClients1000.Name = "labelTCPClients1000";
            this.labelTCPClients1000.TabIndex = 2;
            this.labelTCPClients1000.Text = "0";
            // 
            // labelUDPClients1000
            // 
            this.labelUDPClients1000.Location = new System.Drawing.Point(152, 176);
            this.labelUDPClients1000.Name = "labelUDPClients1000";
            this.labelUDPClients1000.TabIndex = 3;
            this.labelUDPClients1000.Text = "0";
            // 
            // buttonStartStop
            // 
            this.buttonStartStop.Location = new System.Drawing.Point(8, 480);
            this.buttonStartStop.Name = "buttonStartStop";
            this.buttonStartStop.TabIndex = 4;
            this.buttonStartStop.Text = "Start server";
            this.buttonStartStop.Click += new System.EventHandler(this.buttonStartStop_Click);
            // 
            // groupBox1
            // 
            this.groupBox1.Location = new System.Drawing.Point(8, 120);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(272, 88);
            this.groupBox1.TabIndex = 5;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Port 1000";
            // 
            // labelUDPClients1001
            // 
            this.labelUDPClients1001.Location = new System.Drawing.Point(152, 272);
            this.labelUDPClients1001.Name = "labelUDPClients1001";
            this.labelUDPClients1001.TabIndex = 9;
            this.labelUDPClients1001.Text = "0";
            // 
            // labelTCPClients1001
            // 
            this.labelTCPClients1001.Location = new System.Drawing.Point(152, 240);
            this.labelTCPClients1001.Name = "labelTCPClients1001";
            this.labelTCPClients1001.TabIndex = 8;
            this.labelTCPClients1001.Text = "0";
            // 
            // label5
            // 
            this.label5.Location = new System.Drawing.Point(32, 272);
            this.label5.Name = "label5";
            this.label5.TabIndex = 7;
            this.label5.Text = "Active UDP clients:";
            // 
            // label6
            // 
            this.label6.Location = new System.Drawing.Point(32, 240);
            this.label6.Name = "label6";
            this.label6.TabIndex = 6;
            this.label6.Text = "Active TCP clients:";
            // 
            // groupBox2
            // 
            this.groupBox2.Location = new System.Drawing.Point(8, 216);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(272, 88);
            this.groupBox2.TabIndex = 10;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Port 1001";
            // 
            // comboIPSelect
            // 
            this.comboIPSelect.Location = new System.Drawing.Point(8, 32);
            this.comboIPSelect.Name = "comboIPSelect";
            this.comboIPSelect.Size = new System.Drawing.Size(264, 21);
            this.comboIPSelect.TabIndex = 11;
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(8, 8);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(100, 16);
            this.label3.TabIndex = 12;
            this.label3.Text = "Local IP Address";
            // 
            // textDebug
            // 
            this.textDebug.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.textDebug.Location = new System.Drawing.Point(288, 8);
            this.textDebug.Multiline = true;
            this.textDebug.Name = "textDebug";
            this.textDebug.ReadOnly = true;
            this.textDebug.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.textDebug.Size = new System.Drawing.Size(336, 498);
            this.textDebug.TabIndex = 13;
            this.textDebug.Text = "";
            this.textDebug.WordWrap = false;
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.labelAuthReq);
            this.groupBox3.Controls.Add(this.label4);
            this.groupBox3.Location = new System.Drawing.Point(8, 312);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(272, 48);
            this.groupBox3.TabIndex = 14;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "Port 1002";
            // 
            // labelAuthReq
            // 
            this.labelAuthReq.Location = new System.Drawing.Point(144, 16);
            this.labelAuthReq.Name = "labelAuthReq";
            this.labelAuthReq.TabIndex = 9;
            this.labelAuthReq.Text = "0";
            // 
            // label4
            // 
            this.label4.Location = new System.Drawing.Point(24, 16);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(104, 23);
            this.label4.TabIndex = 7;
            this.label4.Text = "Auth requests:";
            // 
            // groupBox4
            // 
            this.groupBox4.Controls.Add(this.labelPUIDLookup);
            this.groupBox4.Controls.Add(this.label7);
            this.groupBox4.Location = new System.Drawing.Point(8, 368);
            this.groupBox4.Name = "groupBox4";
            this.groupBox4.Size = new System.Drawing.Size(272, 48);
            this.groupBox4.TabIndex = 15;
            this.groupBox4.TabStop = false;
            this.groupBox4.Text = "Port 1003";
            // 
            // labelPUIDLookup
            // 
            this.labelPUIDLookup.Location = new System.Drawing.Point(144, 13);
            this.labelPUIDLookup.Name = "labelPUIDLookup";
            this.labelPUIDLookup.TabIndex = 10;
            this.labelPUIDLookup.Text = "0";
            // 
            // label7
            // 
            this.label7.Location = new System.Drawing.Point(24, 16);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(104, 23);
            this.label7.TabIndex = 8;
            this.label7.Text = "PUID lookups:";
            // 
            // groupBox5
            // 
            this.groupBox5.Controls.Add(this.labelGamerTagLookups);
            this.groupBox5.Controls.Add(this.label8);
            this.groupBox5.Location = new System.Drawing.Point(8, 424);
            this.groupBox5.Name = "groupBox5";
            this.groupBox5.Size = new System.Drawing.Size(272, 48);
            this.groupBox5.TabIndex = 16;
            this.groupBox5.TabStop = false;
            this.groupBox5.Text = "Port 1004";
            // 
            // labelGamerTagLookups
            // 
            this.labelGamerTagLookups.Location = new System.Drawing.Point(144, 13);
            this.labelGamerTagLookups.Name = "labelGamerTagLookups";
            this.labelGamerTagLookups.TabIndex = 10;
            this.labelGamerTagLookups.Text = "0";
            // 
            // label8
            // 
            this.label8.Location = new System.Drawing.Point(24, 16);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(104, 23);
            this.label8.TabIndex = 9;
            this.label8.Text = "GamerTag lookups:";
            // 
            // label9
            // 
            this.label9.Location = new System.Drawing.Point(8, 64);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(128, 16);
            this.label9.TabIndex = 18;
            this.label9.Text = "LSP Proxy IP:";
            // 
            // textProxyAddr
            // 
            this.textProxyAddr.Location = new System.Drawing.Point(8, 88);
            this.textProxyAddr.Name = "textProxyAddr";
            this.textProxyAddr.Size = new System.Drawing.Size(128, 20);
            this.textProxyAddr.TabIndex = 19;
            this.textProxyAddr.Text = "10.10.0.2";
            // 
            // label10
            // 
            this.label10.Location = new System.Drawing.Point(152, 64);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(128, 16);
            this.label10.TabIndex = 20;
            this.label10.Text = "LSP Proxy IP:";
            // 
            // textProxyPort
            // 
            this.textProxyPort.Location = new System.Drawing.Point(152, 88);
            this.textProxyPort.Name = "textProxyPort";
            this.textProxyPort.Size = new System.Drawing.Size(128, 20);
            this.textProxyPort.TabIndex = 21;
            this.textProxyPort.Text = "8000";
            // 
            // LSPTitleServerForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(624, 512);
            this.Controls.Add(this.textProxyPort);
            this.Controls.Add(this.label10);
            this.Controls.Add(this.textProxyAddr);
            this.Controls.Add(this.label9);
            this.Controls.Add(this.groupBox5);
            this.Controls.Add(this.groupBox4);
            this.Controls.Add(this.groupBox3);
            this.Controls.Add(this.textDebug);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.comboIPSelect);
            this.Controls.Add(this.labelUDPClients1001);
            this.Controls.Add(this.labelTCPClients1001);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label6);
            this.Controls.Add(this.groupBox2);
            this.Controls.Add(this.buttonStartStop);
            this.Controls.Add(this.labelUDPClients1000);
            this.Controls.Add(this.labelTCPClients1000);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.groupBox1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.Name = "LSPTitleServerForm";
            this.Text = "LSP Title Server";
            this.groupBox3.ResumeLayout(false);
            this.groupBox4.ResumeLayout(false);
            this.groupBox5.ResumeLayout(false);
            this.ResumeLayout(false);

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() 
        {
            int baseport = 1000;
            string[] args = System.Environment.GetCommandLineArgs();
            if (args.Length >= 2)
            {
                try
                {
                    baseport = int.Parse(args[1]);
                }
                catch
                {
                    baseport = 1000;
                    MessageBox.Show("Unable to parse base port\nUsage: EchoTitleServer [baseport]\nDefault baseport is 1000", "EchoTitleServer", MessageBoxButtons.OK);
                }
            }
                
            Application.Run(new LSPTitleServerForm(baseport));
        }

        private void buttonStartStop_Click(object sender, System.EventArgs e)
        {
            if(serverIsRunning)
            {
                StopServer();
                buttonStartStop.Text = "&Start server";
                serverIsRunning = false;
            }
            else
            {
                StartServer();
                buttonStartStop.Text = "&Stop server";
                serverIsRunning = true;
            }
        }

        private bool StartServer()
        {
            bool success = true;

            tcpServer1000 = new TCPEchoThread(labelTCPClients1000, textDebug, BasePort + 0, (IPAddress) comboIPSelect.SelectedItem);
            tcpServer1000.Startup();

            udpServer1000 = new UDPEchoThread(labelUDPClients1000, textDebug, BasePort + 0, (IPAddress) comboIPSelect.SelectedItem);
            udpServer1000.Startup();

            tcpServer1001 = new TCPEchoThread(labelTCPClients1000, textDebug, BasePort + 1, (IPAddress) comboIPSelect.SelectedItem);
            tcpServer1001.Startup();

            udpServer1001 = new UDPEchoThread(labelUDPClients1000, textDebug, BasePort + 1, (IPAddress) comboIPSelect.SelectedItem);
            udpServer1001.Startup();

            arEcho1002 = new AuthReqEchoThread(labelAuthReq, textDebug, BasePort + 2, (IPAddress) comboIPSelect.SelectedItem);
            arEcho1002.Startup();

            plEcho1003 = new PUIDLookupEchoThread(labelPUIDLookup, textDebug, textProxyAddr.Text, textProxyPort.Text, BasePort + 3, (IPAddress) comboIPSelect.SelectedItem);
            plEcho1003.Startup();

            gtlEcho1004 = new GamerTagLookupEchoThread(labelGamerTagLookups, textDebug, textProxyAddr.Text, textProxyPort.Text, BasePort + 4, (IPAddress) comboIPSelect.SelectedItem);
            gtlEcho1004.Startup();

            return success;
        }

        private bool StopServer()
        {
            bool success = true;

            tcpServer1000.Shutdown();
            udpServer1000.Shutdown();
            tcpServer1001.Shutdown();
            udpServer1001.Shutdown();
            arEcho1002.Shutdown();
            plEcho1003.Shutdown();
            gtlEcho1004.Shutdown();

            tcpServer1000 = null;
            udpServer1000 = null;
            tcpServer1001 = null;
            udpServer1001 = null;
            arEcho1002 = null;
            plEcho1003 = null;
            gtlEcho1004 = null;

            return success;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\XLSP\AuthData.cs ===
//
// AuthData.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a class that exposes ticket/auth client data from the security gateway.
//
//  To use it, simply instantiate AuthData call RequestAuthData with the IP and port of the client connection you
//  are interested in, and then use the gettable properties on this object.
//

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;

using xonline.common.service;

namespace Microsoft.XboxLive.XLSP
{
    public sealed class AuthData 
    {
        // the following structures are defined in xonline.x for the XSGInfo stuff.
        // they are mirrored here.                                      
        //
        private const ushort SGMSG_TYPE_SPIDATA_REQ = 0x4710;   // sgMessageSpiRequest
        private const ushort SGMSG_TYPE_SPIDATA_REP = 0x4711;   // sgMessageSpiResponse
        private const ushort SGMSG_TYPE_SPIDATA     = 0x4782;   // CSgMsgSpiData in the payload
        private const ushort SGMSG_TYPE_AUTHDATA    = 0x4783;   // CAuthData3 in the payload
        private struct sgMessageHeader 
        {
            public ushort _wType;
            public ushort _cbEnt;
        }
        const int sizeMessageHeader = 4;

        //------------------------------------------------------------------------------
        // Request packet
        //------------------------------------------------------------------------------

        private struct sgMessageSpiRequest
        {
            public uint   _dwReqNum;    // request number from requester
            public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
            public ushort _ipportZ;     // IP port of client on DMZ
        }
        const int sizeMessageSpiRequest = 10 + sizeMessageHeader;

        private const int XONLINE_SG_MESSAGE_PORT       = 0xFFFF;
        private const ushort XONLINE_XENON_AUTHDATA_VERSION = 0x03;

        //------------------------------------------------------------------------------
        // Start of reply packet
        //------------------------------------------------------------------------------

        private struct sgMessageSpiResponse
        {
            public uint   _dwReqNum;
            public uint   _ipaZ;
            public ushort _ipportZ;
            public byte   _fNotFound;
            // SpiData, see member variables below
            // AuthData, see member variables below
        }
        const int sizeMessageSpiResponse = 11 + sizeMessageHeader;
        
        //------------------------------------------------------------------------------
        // SPIDATA Part of reply packet
        //------------------------------------------------------------------------------

        /// struct CSgMsgSpiData
        /// {
        /// #define SGMSG_TYPE_SPIDATA          0x4782      // CSgMsgSpiData in the payload
        ///     WORD            _wType;                     // See SGMSG_TYPE_* above
        ///     WORD            _cbEnt;                     // Size of this entry (including header)
        ///     WORD            _ipportI;                   // IP port of the client on the Internet
        ///     IN_ADDR         _ipaI;                      // IP address of the client on the Internet
        ///     SGADDR          _sgaddr;                    // SGADDR of the client
        ///     WORD            _wVersionKeyEx;             // KeyEx version of the client
        ///     WORD            _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        ///     LARGE_INTEGER   _liNonce;                   // A random nonce associated with this session
        ///     LARGE_INTEGER   _liTimeInit;                // FILETIME marking session initiation
        ///     BOOL            _fCs;                       // TRUE if SG is providing connection services
        /// };
        /// 
        private ushort  ipportI;
        private uint    ipaI;                               // property
        private byte[]  sgaddr;
        private ushort  wVersionKeyEx;
        private ushort  wFlagsKeyEx;
        private ulong   liNonce;                            // property
        private ulong   liTimeInit;                         // property
        private uint    fCs;

        // size of the spidata structure
        private const int sizeSpiData = 54;

        //------------------------------------------------------------------------------
        // AUTHDATA Part of reply packet
        //------------------------------------------------------------------------------

        /// struct CSgMsgAuthdata
        /// {
        /// #define SGMSG_TYPE_AUTHDATA         0x4783      // CAuthData3 in the payload
        ///     WORD            _wType;                     // See SGMSG_TYPE_* above
        ///     WORD            _cbEnt;                     // Size of this entry (including header)
        ///     XKERB_AD_XENON  _authData;                  // The client's authdata
        /// };

        /// typedef struct _XKERB_AD_XENON
        /// {
        ///     #define XONLINE_XENON_AUTHDATA_VERSION 3
        ///     WORD                     wAuthDataVersion;
        ///     WORD                     wAuthDataSize;
        ///     WORD                     wMajorVersion;         // clientVersion
        ///     WORD                     wMinorVersion;         // clientVersion
        ///     WORD                     wBuildNumber;          // clientVersion
        ///     WORD                     wQFENumber;            // clientVersion
        ///     DWORD                    dwTitleID;
        ///     DWORD                    dwTitleVersion;
        ///     DWORD                    dwTitleRegion;
        ///     DWORD                    dwConsoleRegion;
        ///     DWORD                    dwMediaID;
        ///     WORD                     wLanguageID;
        ///     DWORD                    dwAuthDataFlags;       // see XONLINE_AUTHDATA_FLAGS_* above
        ///     WORD                     wNumPrivileges;
        ///     DWORD                    dwPrivileges[8];
        ///     ULONGLONG                qwXBoxID;              
        ///     XUID                     users[4];              // per user
        ///     FLOAT                    afltTrustFactor[4];    // per user
        ///     WORD                     wNumDwordServices;
        ///     DWORD                    dwServiceID[4];
        ///     DWORD                    dwAltTitleID[4];
        ///     BYTE                     abKey[16];
        /// } XKERB_AD_XENON, *PXKERB_AD_XENON;
        
        private ushort    wAuthDataVersion;         
        private ushort    wAuthDataSize;
        private ushort    wMajorVersion;
        private ushort    wMinorVersion;
        private ushort    wBuildNumber;
        private ushort    wQFENumber;
        private uint      dwTitleID;                        // Title property
        private uint      dwTitleVersion;                   // Title property
        private uint      dwReserved;                       // dwTitleRegion
        //private uint      dwConsoleRegion;
        //private uint      dwMediaID;
        private ushort    wLanguageID;                      // property
        //private uint      dwAuthDataFlags;
        private ushort    wNumPrivileges;
        private uint[]    dwPrivileges = new uint[XOn.XONLINE_NUM_PRIVILEGE_DWORDS];
        private ulong     qwReserved;
        private Platforms platform;                         // Client.Platform property
        private List<User> users = new List<User>((int)XOn.XONLINE_MAX_LOGON_USERS);  // Users property
        //private ushort    wNumDwordServices;
        //private uint[]    dwServiceID = new uint[XOn.XONLINE_MAX_DWORD_SERVICEIDS];     // IsServicePresent helper
        //private uint[]    dwAltTitleID = new uint[XOn.XONLINE_MAX_ALTERNATE_TITLE_ID];
        //private byte[]    abKey;    // Key used for signing data within a session

        private const int sizeAuthData = 194 + sizeMessageHeader;

        private const ulong XONLINE_PLATFORM_MASK        = 0xFFFF000000000000;
        private const ulong XONLINE_PLATFORM_XENONBASE   = 0xFA00000000000000;
        private const ulong XONLINE_PLATFORM_XBOX1BASE   = 0x0009000000000000;
        private const ulong XONLINE_PLATFORM_PCBASE      = 0xFB00000000000000;

        //------------------------------------------------------------------------------
        // Other
        //------------------------------------------------------------------------------

        private const int XONLINE_SG_REQ_RETRIES        = 4;        // Number of retries. Each retry doubles prevous timeout.
        private const int XONLINE_SG_REQ_TIMEOUT        = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
                                                                    // Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
        
        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        private static int staticRequestNumber = 0;
        
        // the instance reqnum, set when a request is first made.
        private uint thisRequestNumber;
                
        // config settings
        // 
        private static int maxRetries = XONLINE_SG_REQ_RETRIES;
        private static int sgTimeout = XONLINE_SG_REQ_TIMEOUT; 

        // SG ip
        private IPAddress secureGatewayIP;
        private int secureGatewayPort;

        //------------------------------------------------------------------------------
        // constructor
        //------------------------------------------------------------------------------

        private AuthData()
        {
            Debug.Assert(false);
        }

        private AuthData(IPAddress ipVirtual, ushort port, uint requestNumber)
        {
            thisRequestNumber = requestNumber;
            secureGatewayIP = ipVirtual;
            secureGatewayPort = port;
        }

        //------------------------------------------------------------------------------
        // Implementation: public
        //------------------------------------------------------------------------------
#region Implementation Public
        /// <summary>
        /// RequestAuthData
        /// Request the SG Info for the given ip address and port.  The process involves:
        /// Building the request, sending the UDP message, wait for the response, and finally
        /// deserialize the response data.
        /// 
        /// </summary>
        /// <param name="ipVirtual"></param>
        /// <param name="port"></param>
        static public AuthData RequestAuthData(IPAddress ipVirtual, ushort port)
        {
            BinaryReader reader = null;
            ushort srcPort;
            uint requestNumber;

            srcPort = (ushort)IPAddress.HostToNetworkOrder((short)port);
     
            byte[] sgRequest;
            byte[] sgResponse = null;
            int recBytes = 0;

            using (Socket sock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp ))
            {
                sock.Blocking = false;
                IPEndPoint SgMsgPort = new IPEndPoint(ipVirtual, XONLINE_SG_MESSAGE_PORT);
                sock.Connect(SgMsgPort);
                    
                // build SG request.
                sgRequest = BuildRequest(ipVirtual, srcPort, out requestNumber);

                // clear any unread data sitting on the socket
                while ( 0 != sock.Available )
                {
                    sgResponse = new byte[sock.Available];
                    sock.Receive(sgResponse);
                    sgResponse = null;
                }

                for(int i=0; i < maxRetries && 0 == recBytes; i++ ) 
                {
                    // send the request         
                    sock.Send(sgRequest);

                    // wait for the response
                    if(sock.Poll(sgTimeout * (1 << i), SelectMode.SelectRead)) 
                    {
                        int available = sock.Available;
                        sgResponse = new byte[available];

                        // read the response
                        recBytes = sock.Receive(sgResponse);                                
                    }
                }
                
                sock.Shutdown(SocketShutdown.Both);
                sock.Close();
            }

            // Process the request
            if ( null != sgResponse && 0 < recBytes )
            {
                reader = new BinaryReader(new MemoryStream(sgResponse));
                AuthData pThis = new AuthData( ipVirtual, port, requestNumber );

                pThis.ReadReply(reader);
                pThis.ReadSpiData(reader);
                pThis.ReadAuthData(reader);

                return pThis;
            }
            else
            {
                string errmsg = String.Format("AUTHDATA ERROR: No response for request: {0}.", requestNumber);
                throw new Exception(errmsg);
            }
        }
#endregion //Implementation Public

        //------------------------------------------------------------------------------
        // Implementation: private
        //------------------------------------------------------------------------------
#region Implementation Private

        /// <summary>
        /// ReadReply
        /// Deserialize CSgMsgSpiRep structure
        /// struct CSgMsgSpiRep
        /// {
        /// #define SGMSG_TYPE_SPIDATA_REP      0x4711      // CSgMsgSpiRep
        ///     WORD            _wType;                     // See SGMSG_TYPE_* above
        ///     WORD            _cbEnt;                     // Size of this entry (including header)
        ///     DWORD           _dwReqNum;                  // Copy of _dwReqNum from request
        ///     IN_ADDR         _ipaZ;                      // IP address of the client on the DMZ
        ///     WORD            _ipportZ;                   // IP port of the client on the DMZ
        ///     BYTE            _fNotFound;                 // TRUE if client not found (no auth-data enclosed)
        ///     CSgMsgSpiData   _spidata;                   // The spidata structure
        ///     CSgMsgAuthData  _authdata;                  // The authdata structure
        /// };
        /// /// </summary>
        /// <param name="reader"></param>
        /// 
        private void ReadReply(BinaryReader reader)
        {
            sgMessageHeader header;
            sgMessageSpiResponse reply;

            header._wType = reader.ReadUInt16();
            if (SGMSG_TYPE_SPIDATA_REP != header._wType) 
            {   // Not the Response Type we expected
                string errmsg = String.Format("AUTHDATA ERROR: Invalid Response Type. Response type: {0}.", header._wType);
                throw new InvalidDataException(errmsg);
            }

            header._cbEnt = reader.ReadUInt16();
            if (sizeMessageSpiResponse != header._cbEnt) 
            {   // Response size is not what we expected
                string errmsg = String.Format("AUTHDATA ERROR: Invalid Response Size. Response size: {0}.", header._cbEnt);
                throw new InvalidDataException(errmsg);
            }

            reply._dwReqNum = reader.ReadUInt32();
            if (thisRequestNumber != reply._dwReqNum) 
            {   // This is not the response for the request we sent
                string errmsg = String.Format("AUTHDATA ERROR: Invalid Request Number. Response request number: {0} expecting: {1}.", reply._dwReqNum, thisRequestNumber);
                throw new InvalidDataException(errmsg);
            }

            reply._ipaZ = reader.ReadUInt32();
            reply._ipportZ = reader.ReadUInt16();
            reply._fNotFound = reader.ReadByte();
            if (0 != reply._fNotFound) 
            {   // The client we requested was not found
                IPAddress ipZ = new IPAddress (reply._ipaZ);
                string errmsg = String.Format("AUTHDATA ERROR: Client Not Found. Client: {0}:{1}.", ipZ, IPAddress.NetworkToHostOrder(reply._ipportZ));
                throw new Exception(errmsg);
            }
        }
        
        /// <summary>
        /// Deserialize CSgMsgSpiData structure
        /// struct CSgMsgSpiData
        /// {
        /// #define SGMSG_TYPE_SPIDATA          0x4782      // CSgMsgSpiData in the payload
        ///     WORD            _wType;                     // See SGMSG_TYPE_* above
        ///     WORD            _cbEnt;                     // Size of this entry (including header)
        ///     WORD            _ipportI;                   // IP port of the client on the Internet
        ///     IN_ADDR         _ipaI;                      // IP address of the client on the Internet
        ///     SGADDR          _sgaddr;                    // SGADDR of the client
        ///     WORD            _wVersionKeyEx;             // KeyEx version of the client
        ///     WORD            _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        ///     LARGE_INTEGER   _liNonce;                   // A random nonce associated with this session
        ///     LARGE_INTEGER   _liTimeInit;                // FILETIME marking session initiation
        ///     BOOL            _fCs;                       // TRUE if SG is providing connection services
        /// };
        /// </summary>
        /// <param name="reader"></param>
        private void ReadSpiData(BinaryReader reader)
        {
            sgMessageHeader header;

            // read the auth data header.
            header._wType = reader.ReadUInt16();
            if(SGMSG_TYPE_SPIDATA != header._wType) 
            {   // Not the SPIDATA Response Type we expected
                string errmsg = String.Format("AUTHDATA ERROR: Invalid SPIDATA Type. Type: {0}.", header._wType);
                throw new InvalidDataException(errmsg);
            }

            header._cbEnt = reader.ReadUInt16();
            if ( sizeSpiData != header._cbEnt ) 
            {   // Response size is not what we expected
                string errmsg = String.Format("AUTHDATA ERROR: Invalid SPIDATA Size. Size: {0}.", header._cbEnt);
                throw new InvalidDataException(errmsg);
            }

            // read the spi.
            ipportI = (ushort)IPAddress.NetworkToHostOrder((short)reader.ReadUInt16());
            ipaI = reader.ReadUInt32();
            sgaddr = reader.ReadBytes(20);
            wVersionKeyEx = reader.ReadUInt16();
            wFlagsKeyEx = reader.ReadUInt16();
            liNonce = reader.ReadUInt64();
            liTimeInit = reader.ReadUInt64();
            fCs = reader.ReadUInt32();
        }

        /// <summary>
        /// ReadAuthData
        /// Deserialize CSgMsgAuthdata structure
        /// struct CSgMsgAuthdata
        /// {
        /// #define SGMSG_TYPE_AUTHDATA         0x4783      // CAuthData3 in the payload
        ///     WORD            _wType;                     // See SGMSG_TYPE_* above
        ///     WORD            _cbEnt;                     // Size of this entry (including header)
        ///     XKERB_AD_XENON  _authData;                  // The client's authdata
        /// };
        /// typedef struct _XKERB_AD_XENON
        /// {
        ///     #define XONLINE_XENON_AUTHDATA_VERSION 3
        ///     WORD                     wAuthDataVersion;
        ///     WORD                     wAuthDataSize;
        ///     WORD                     wMajorVersion;         // clientVersion
        ///     WORD                     wMinorVersion;         // clientVersion
        ///     WORD                     wBuildNumber;          // clientVersion
        ///     WORD                     wQFENumber;            // clientVersion
        ///     DWORD                    dwTitleID;
        ///     DWORD                    dwTitleVersion;
        ///     DWORD                    dwTitleRegion;
        ///     DWORD                    dwConsoleRegion;
        ///     DWORD                    dwMediaID;
        ///     WORD                     wLanguageID;
        ///     DWORD                    dwAuthDataFlags;       // see XONLINE_AUTHDATA_FLAGS_* above
        ///     WORD                     wNumPrivileges;
        ///     DWORD                    dwPrivileges[8];
        ///     ULONGLONG                qwXBoxID;
        ///     XUID                     users[4];              // per user
        ///     FLOAT                    afltTrustFactor[4];    // per user
        ///     WORD                     wNumDwordServices;
        ///     DWORD                    dwServiceID[4];
        ///     DWORD                    dwAltTitleID[4];
        ///     BYTE                     abKey[16];
        /// } XKERB_AD_XENON, *PXKERB_AD_XENON;
        /// </summary>
        /// <param name="reader"></param>
        /// 
        private void ReadAuthData(BinaryReader reader)
        {
            sgMessageHeader header;

            // read the auth data header.
            header._wType = reader.ReadUInt16();
            if(SGMSG_TYPE_AUTHDATA != header._wType) 
            {   // Not the AUTHDATA Type we expected
                string errmsg = String.Format("AUTHDATA ERROR: Invalid AUTHDATA Type. Type: {0}.", header._wType);
                throw new InvalidDataException(errmsg);
            }

            header._cbEnt = reader.ReadUInt16();
            if ( sizeAuthData != header._cbEnt ) 
            {   // Response size is not what we expected
                string errmsg = String.Format("AUTHDATA ERROR: Invalid AUTHDATA Size. Size: {0}.", header._cbEnt);
                throw new InvalidDataException(errmsg);
            }

            ///     WORD  2(2)               wAuthDataVersion;
             wAuthDataVersion = reader.ReadUInt16();
            if ( XONLINE_XENON_AUTHDATA_VERSION != wAuthDataVersion )
            {
                string errmsg = String.Format("AUTHDATA ERROR: Unsupported AuthDataVersion. Message contained version: {0}.", wAuthDataVersion);
                throw new InvalidDataException(errmsg);
            }
            ///     WORD  2(4)               wAuthDataSize;
            wAuthDataSize = reader.ReadUInt16();
            ///     WORD  2(6)               wMajorVersion;         // clientVersion
            wMajorVersion = reader.ReadUInt16();
            ///     WORD  2(8)               wMinorVersion;         // clientVersion
            wMinorVersion = reader.ReadUInt16();
            ///     WORD  2(10)              wBuildNumber;          // clientVersion
            wBuildNumber = reader.ReadUInt16();
            ///     WORD  2(12)              wQFENumber;            // clientVersion
            wQFENumber = reader.ReadUInt16();
            ///     DWORD 4(16)              dwTitleID;
            dwTitleID = reader.ReadUInt32();
            ///     DWORD 4(20)              dwTitleVersion;
            dwTitleVersion = reader.ReadUInt32();
            ///     DWORD 4(24)              dwTitleRegion;
            dwReserved = reader.ReadUInt32();
            ///     DWORD 4(28)              dwConsoleRegion;
            dwReserved = reader.ReadUInt32();
            ///     DWORD 4(32)              dwMediaID;
            dwReserved = reader.ReadUInt32();
            ///     WORD  2(34)              wLanguageID;
            wLanguageID = reader.ReadUInt16();
            ///     DWORD 4(38)              dwAuthDataFlags;       // see XONLINE_AUTHDATA_FLAGS_* above
            dwReserved = reader.ReadUInt32();
            ///     WORD  2(40)              wNumPrivileges;
            wNumPrivileges   = reader.ReadUInt16();
            ///     DWORD 4*8(72)            dwPrivileges[8];
            for (int i = 0; i < XOn.XONLINE_NUM_PRIVILEGE_DWORDS; i++)
            {
                dwPrivileges[i] = reader.ReadUInt32();
            }
            ///     ULONGLONG 8(80)          qwXBoxID;
            qwReserved = reader.ReadUInt64();

            // Determine platform from qwXboxId
            switch (qwReserved & XONLINE_PLATFORM_MASK)
            {
                case (XONLINE_PLATFORM_XENONBASE):
                    platform = Platforms.Xbox360;
                    break;
                case(XONLINE_PLATFORM_PCBASE):
                    platform = Platforms.PC;
                    break;
                case(XONLINE_PLATFORM_XBOX1BASE):
                    platform = Platforms.Xbox1;
                    break;
                default:
                {
                    string errmsg = String.Format("AUTHDATA ERROR: Invalid platform type. Message contained type: {0}.", qwReserved & XONLINE_PLATFORM_MASK);
                    throw new InvalidDataException(errmsg);
                }
            }

            ///     XUID  (8+4)*4(128)       users[4];              // per user
            User[] rawUserData = new User[XOn.XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                rawUserData[i] = new User(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
            }
            ///     FLOAT 4*4(144)           afltTrustFactor[4];    // per user
            for( int i = 0; i < XOn.XONLINE_MAX_LOGON_USERS; i++ )
            {
                // set the user trust factor.
                rawUserData[i].userTrust = reader.ReadSingle();
                if ( 0 != rawUserData[i].XUID )
                    users.Add( rawUserData[i] );
            }

            // Don't need the rest
            /*
            ///     WORD  2(146)             wNumDwordServices;
            wNumDwordServices = reader.ReadUInt16();
            ///     DWORD 4*4(162)           dwServiceID[4];
            for (int i = 0; i < XOn.XONLINE_MAX_DWORD_SERVICEIDS; i++)
            {
                dwServiceID[i] = reader.ReadUInt32();
            }
            ///     DWORD 4*4(178)           dwAltTitleID[4];
            for (int i = 0; i < XOn.XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                dwAltTitleID[i] = reader.ReadUInt32();
            }
            ///     BYTE 16(194)             abKey[16];
            abKey = reader.ReadBytes((int)XOn.XONLINE_KEY_LENGTH);
            */
        }
        
        /// <summary>
        /// BuildRequest
        /// Build the request message that will be sent to the SG.
        /// </summary>
        /// <param name="ip">IP Address of the client we want AuthData for</param>
        /// <param name="port">Port of the client we want AuthData for</param>
        static private byte[] BuildRequest(IPAddress ip, ushort port, out uint requestNumber ) 
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter wr = new BinaryWriter(ms);
            sgMessageHeader header;
            sgMessageSpiRequest request;
            byte[] reqSize;

            // build the data into structs for clean maintenance
            header._wType = SGMSG_TYPE_SPIDATA_REQ;
            header._cbEnt = sizeMessageSpiRequest;
            requestNumber = (uint) Interlocked.Increment(ref staticRequestNumber);
            request._dwReqNum = requestNumber;

            byte[] addr = ip.GetAddressBytes();
            request._ipaZ     = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);
            request._ipportZ  = port;

            // now stream the structs out into a byte array.
            wr.Write(header._wType);
            wr.Write(header._cbEnt);
            wr.Write(request._dwReqNum);
            wr.Write(request._ipaZ);
            wr.Write(request._ipportZ);

            reqSize = ms.ToArray();
            Debug.Assert(reqSize.Length == header._cbEnt);

            return reqSize;
        }

#endregion //Implementation Private

        //------------------------------------------------------------------------------
        // public accessors
        //------------------------------------------------------------------------------
#region Accessors

        /// <summary>
        /// Can the currently logged in users author content using XNA Game Studio?
        /// </summary>
        public bool CanAuthorContent
        {
            get { return CheckPrivilege(Privilege.ContentAuthor); }
        }
        
        /// <summary>
        /// Can the currently logged in users play multiplayer games? This can be limited due to subscription tier or parental controls.
        /// </summary>
        public bool CanPlayMultiplayer
        {
            get { return CheckPrivilege(Privilege.MultiplayerSessions); } // Should I also be checking XPRIVILEGE_MULTIPLAYER_ENABLED_BY_TIER?
        }
        
        /// <summary>
        /// Data specific to the client device. Xbox 360 is currently the only supported platform.
        /// </summary>
        public Client Client
        {
            get { return new Client( platform, new IPAddress(ipaI), ipportI, new Language( (LanguageCode)wLanguageID )); }
        }
        
        /// <summary>
        /// Reflection of SG IP Address passed into the constructor
        /// </summary>
        public IPAddress SecurityGatewayIP
        {
            get { return new IPAddress(secureGatewayIP.GetAddressBytes()); }
        }
        
        /// <summary>
        /// Reflection of the SG Port passed into the constructor
        /// </summary>
        public int SecurityGatewayPort
        {
            get { return secureGatewayPort; }
        }

        /// <summary>
        /// A unique id per connection w/ SG. Derived from nonce from AuthData
        /// </summary>
        public ulong SessionID
        {
            get { return liNonce; }
        }

        /// <summary>
        /// Time in ticks of the session initiation
        /// </summary>
        public ulong SessionStartTime
        {
            get { return liTimeInit; }
        }

        /// <summary>
        /// Data specific to the title currently being played.
        /// </summary>
        public Title Title
        {
            get { return new Title( dwTitleID, dwTitleVersion ); }
        }

        /// <summary>
        /// Array of all users currently logged into the client device
        /// </summary>
        public ReadOnlyCollection<User> Users
        {
            get { return new ReadOnlyCollection<User>(users); }
        }
#endregion //Accessors
       
        //------------------------------------------------------------------------------
        // public helper methods
        //------------------------------------------------------------------------------
#region Helpers

        /// <summary>
        /// Returns the privilege bit for the specified Privilege.
        /// </summary>
        /// <param name="privilege">Privilege bit to retrieve</param>
        public bool CheckPrivilege(Privilege privilege)
        {
            int nIndex    = ((byte)privilege) / 32;
            int nbitIndex = ((byte)privilege) % 32;
            uint mask    = ((uint)1) << nbitIndex;

            return ( 0 != (dwPrivileges[nIndex] & mask) );
        }
        
        /// <summary>
        /// Returns the current privacy setting for the passed in feature.
        /// </summary>
        /// <param name="setting">The feature to retrieve the current privacy setting value</param>
        /// <returns>Blocked, Friends Only, or Everyone</returns>
        public PrivacyValues CheckPrivacySetting(PrivacySettings privSetting)
        {
            PrivacyValues privValue = PrivacyValues.Blocked;
            
            switch (privSetting) 
            {
                case PrivacySettings.Communications:
                    if ( CheckPrivilege(Privilege.Communications))
                        privValue = PrivacyValues.Everyone;
                    else if ( CheckPrivilege(Privilege.CommunicationsFriendsOnly))
                        privValue = PrivacyValues.FriendsOnly;
                    break;
                case PrivacySettings.ViewProfile:
                    if ( CheckPrivilege(Privilege.ProfileViewing))
                        privValue = PrivacyValues.Everyone;
                    else if ( CheckPrivilege(Privilege.ProfileViewingFriendsOnly))
                        privValue = PrivacyValues.FriendsOnly;
                    break;
                case PrivacySettings.UserGeneratedContent:
                    if ( CheckPrivilege(Privilege.UserCreatedContent))
                        privValue = PrivacyValues.Everyone;
                    else if ( CheckPrivilege(Privilege.UserCreatedContentFriendsOnly))
                        privValue = PrivacyValues.FriendsOnly;
                    break;
                case PrivacySettings.Presence:
                    if ( CheckPrivilege(Privilege.Presence))
                        privValue = PrivacyValues.Everyone;
                    else if ( CheckPrivilege(Privilege.PresenceFriendsOnly))
                        privValue = PrivacyValues.FriendsOnly;
                    break;
                case PrivacySettings.VideoCommunications:
                    if ( CheckPrivilege(Privilege.VideoCommunications))
                        privValue = PrivacyValues.Everyone;
                    else if ( CheckPrivilege(Privilege.VideoCommunicationsFriendsOnly))
                        privValue = PrivacyValues.FriendsOnly;
                    break;
                default:
                    throw new ArgumentException( "CheckPrivacySetting(PrivacySettings privSetting)" );
            }

            return privValue;
        }

        /// <summary>
        /// Provide an override of the default GetHashCode method derived from the Nounce
        /// </summary>
        public override int GetHashCode()
        {
            // Converting the 8 random byte Nounce to a 4 random byte hash code.
            // This should be sufficient
            return liNonce.GetHashCode();
        }
#endregion //Helpers
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\XLSP\User.cs ===
//
// User.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides helper classes and enums used by AuthData to help Auth information.
//

using System;
using System.Diagnostics;

namespace Microsoft.XboxLive.XLSP
{
    public sealed class User : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK           = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK         = 0x0000FF00;
        private const uint XONLINE_USER_TIER_MASK            = 0x00F00000;
        private const uint XONLINE_USER_PARENTAL_CONTROLLED  = 0x01000000;
        private const uint XONLINE_USER_LANGUAGE_MASK        = 0x3E000000;

        private ulong    userXUID;
        private uint     dwUserFlags;
        internal float   userTrust;

        //------------------------------------------------------------------------------
        // constructor
        //------------------------------------------------------------------------------

        internal User(ulong userID, uint userFlags, float paramUserTrust)
        {
            userXUID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }
        
        public int CompareTo(object obj)
        {
            return userXUID.CompareTo(((User) obj).userXUID);
        }

        //------------------------------------------------------------------------------
        // public accessors
        //------------------------------------------------------------------------------

        /// <summary>
        /// Is the user allowed to purchase content?
        /// </summary>
        public bool CanPurchaseContent
        {
            get { return (0 == (dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED))); }
        }

        /// <summary>
        /// Is the user < 18? We do not make a differenation between Minor or Teen accounts.
        /// </summary>
        public bool IsChildAccount
        {
            get { return (0 == (dwUserFlags & XONLINE_USER_PARENTAL_CONTROLLED)); }
        }

        /// <summary>
        /// Is the user a guest account?
        /// </summary>
        public bool IsGuest
        {
            get { return ( 0 != (dwUserFlags & XONLINE_USER_GUEST_MASK)); }
        }

        /// <summary>
        /// Is the user currently voice banned due to violation of Terms of Service
        /// </summary>
        public bool IsVoiceBanned
        {
            get { return (0 == (dwUserFlags & XONLINE_USER_VOICE_NOT_ALLOWED)); }
        }

        /// <summary>
        /// Which guest account is this user (0 - 3)?
        /// </summary>
        public uint GuestNumber
        {
            get { return ( dwUserFlags & XONLINE_USER_GUEST_MASK ); }
        }
        
        /// <summary>
        /// User's Country
        /// </summary>
        public Country Country
        {
            get { 
                return new Country( (CountryCode)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8) );
            }
        }

        /// <summary>
        /// User's Language
        /// </summary>
        public Language Language
        {
            get { 
                return new Language( (LanguageCode)((dwUserFlags & XONLINE_USER_LANGUAGE_MASK) >> 25) );
            }
        }

        /// <summary>
        /// Either Gold or Silver
        /// </summary>
        public SubscriptionTier Tier           // dwFlags bits 20 - 23
        {
            get {
                SubscriptionTier tier;
                uint tierValue = ((dwUserFlags & XONLINE_USER_TIER_MASK) >> 20);

                if ( (uint) SubscriptionTier.Gold < tierValue )
                    tier = SubscriptionTier.Gold;
                else
                    tier = (SubscriptionTier) tierValue;
                Debug.Assert( SubscriptionTier.Gold == tier || SubscriptionTier.Silver == tier || SubscriptionTier.NewUser == tier );

                return tier;
            }
        }

        /// <summary>
        /// Decimal representation of the users Xbox LIVE User ID (XUID)
        /// </summary>
        public ulong XUID
        {
            get { return userXUID; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\titleserver\EndPointDictionary.cs ===
using System;
using System.Net;
using System.Collections;

namespace LSPTitleServer
{
    // This class holds the statisctics that we associate with each UDP endpoint
    public class EndPointAssociatedData
    {
        public DateTime        firstDataReceivedTime;
        public DateTime        lastDataReceivedTime;
        public ulong        totalBytesReceived;
    }

    /// <summary>
    /// Summary description for EndPointDictionary.
    /// </summary>
    public class EndPointDictionary : DictionaryBase  
    {
        // These are just added to enable basic dictionary functionality with the custom value type
        public EndPointAssociatedData this[ IPEndPoint key ]  
        {
            get  
            {
                return( (EndPointAssociatedData) Dictionary[key] );
            }
            set  
            {
                Dictionary[key] = value;
            }
        }

        public ICollection Keys  
        {
            get  
            {
                return( Dictionary.Keys );
            }
        }

        public ICollection Values  
        {
            get  
            {
                return( Dictionary.Values );
            }
        }

        public void Add( IPEndPoint key, EndPointAssociatedData value )  
        {
            Dictionary.Add( key, value );
        }

        public bool Contains( IPEndPoint key )  
        {
            return( Dictionary.Contains( key ) );
        }

        public void Remove( IPEndPoint key )  
        {
            Dictionary.Remove( key );
        }


        // These are added just to ensure dictionary data integrity
        protected override void OnInsert( Object key, Object value )  
        {
            if ( key.GetType() != Type.GetType("System.Net.IPEndPoint") )
                throw new ArgumentException( "key must be of type Net.IPEndpoint", "key" );
            else if ( value.GetType() != Type.GetType("EndPointAssociatedData") )
                throw new ArgumentException( "value must be of type EndPointAssociatedData.", "value" );
        }

        protected override void OnRemove( Object key, Object value )  
        {
            if ( key.GetType() != Type.GetType("System.Net.IPEndPoint") )
                throw new ArgumentException( "key must be of type Net.IPEndpoint", "key" );
            else if ( value.GetType() != Type.GetType("EndPointAssociatedData") )
                throw new ArgumentException( "value must be of type EndPointAssociatedData.", "value" );
        }

        protected override void OnSet( Object key, Object oldValue, Object newValue )  
        {

            if ( key.GetType() != Type.GetType("System.Net.IPEndPoint") )
                throw new ArgumentException( "key must be of type Net.IPEndpoint", "key" );
            else if ( oldValue.GetType() != Type.GetType("EndPointAssociatedData") )
                throw new ArgumentException( "oldValue must be of type EndPointAssociatedData.", "value" );
            else if ( newValue.GetType() != Type.GetType("EndPointAssociatedData") )
                throw new ArgumentException( "newValue must be of type EndPointAssociatedData.", "value" );
        }

        protected override void OnValidate( Object key, Object value )  
        {
            if ( key.GetType() != Type.GetType("System.Net.IPEndPoint") )
                throw new ArgumentException( "key must be of type Net.IPEndpoint", "key" );
            else if ( value.GetType() != Type.GetType("EndPointAssociatedData") )
                throw new ArgumentException( "value must be of type EndPointAssociatedData.", "value" );
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\test\titleserver\SGInfo.cs ===
//
// SGInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a class that exposes ticket/auth client data from the security gateway.
//
//  To use it, simply instantiate SGInfo with the IP and port of the client connection you
//  are interested in, and then use the gettable properties on this object.
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Text;
using System.Net.Sockets;
using System.Collections.Specialized;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using System.Security.Cryptography;

using LSPTitleServer;

namespace LSPTitleServer
{
    public struct XUIDAndTrust : IComparable
    {
        private const uint XONLINE_USER_GUEST_MASK      = 0x00000003;
        private const uint XONLINE_USER_VOICE_NOT_ALLOWED    = 0x00010000;
        private const uint XONLINE_USER_PURCHASE_NOT_ALLOWED = 0x00020000;
        private const uint XONLINE_USER_COUNTRY_MASK    = 0x0000FF00;

        public ulong    qwUserID;
        public uint     dwUserFlags;
        public float    userTrust;

        public XUIDAndTrust(ulong userID, uint userFlags, float paramUserTrust)
        {
            qwUserID = userID;
            dwUserFlags = userFlags;
            userTrust = paramUserTrust;
        }
        
        public int CompareTo(object obj)
        {
            return qwUserID.CompareTo(((XUIDAndTrust) obj).qwUserID);
        }

        public uint GuestNumber()
        {
            return dwUserFlags & XONLINE_USER_GUEST_MASK;
        }

        public bool IsGuest()
        {
            return (GuestNumber() != 0);
        }

        public byte UserCountry()
        {
            return (byte)((dwUserFlags & XONLINE_USER_COUNTRY_MASK) >> 8);
        }

        public bool CanPurchase()
        {
            return ((dwUserFlags & (XONLINE_USER_GUEST_MASK | XONLINE_USER_PURCHASE_NOT_ALLOWED)) == 0);
        }

    }

    public class SGInfo 
    {

        // the following structures are defined in xonline.x for the XSGInfo stuff.
        // they are mirrored here.                                      
        //
        private struct sgMessageHeader 
        {
            public ushort _wType;
            public ushort _cbEnt;
        }
        const int sizeMessageHeader = 4;

        private struct sgMessageSpiRequest
        {
            public uint   _dwReqNum;    // request number from requester
            public uint   _ipaZ;        // this is an IN_ADDR with just the "long" part exposed
            public ushort _ipportZ;     // IP port of client on DMZ
        }
        const int sizeMessageSpiRequest = 10;

        private struct sgMessageSpiResponse
        {
            public uint   _dwReqNum;
            public uint   _ipaZ;
            public ushort _ipportZ;
            public byte   _fNotFound;
        }
        const int sizeMessageSpiResponse = 11;
        
        protected const int XONLINE_MAX_LOGON_USERS       = 4;
        protected const int XONLINE_MAX_ALTERNATE_TITLE_ID = 4;
        protected const int XONLINE_MAX_NUMBER_SERVICE_PER_TICKET = 12;
        protected const int XONLINE_KEY_LENGTH = 16;
        protected const int XONLINE_SG_MESSAGE_PORT       = 0xFFFF;
        protected const int XONLINE_SG_REQ_RETRIES        = 4;        // Number of retries. Each retry doubles prevous timeout.
        protected const int XONLINE_SG_REQ_TIMEOUT        = 200000;   // 200 milliseconds timeout for first request, doubled every subsequent request
                                                                      // Net result is 4 requests with timeouts of 200, 400, 800, and 1600 milliseconds
        protected const ushort XONLINE_AUTHDATA_VERSION   = 0x02 ;
        protected const ushort SGMSG_TYPE_SPIDATA_REQ     = 0x470E;  // CSgMsgSpiReq
        protected const ushort SGMSG_TYPE_SPIDATA_REP     = 0x470F;  // CSgMsgSpiRep
        protected const ushort SGMSG_TYPE_SPIDATA_REQ2    = 0x4710;  // CSgMsgSpiReq2
        protected const ushort SGMSG_TYPE_SPIDATA_REP2    = 0x4711;  // CSgMsgSpiRep2

        protected const ushort SGMSG_TYPE_AUTHDATA        = 0x4780;  // CAuthData in the payload
        protected const ushort SGMSG_TYPE_SPIDATA         = 0x4781;  // CSgMsgSpiData in the payload
        protected const ushort SGMSG_TYPE_SPIDATA2        = 0x4782;  // CSgMsgSpiData2 in the payload
        protected const ushort SGMSG_TYPE_AUTHDATA2       = 0x4783;  // CAuthData2 in the payload

        //  the following fields are in the SG Info structure. (XKERB_AD_XBOX)
        //
        
        protected ushort    wAuthDataVersion;         
        protected ushort    wAuthDataSize;        // Size of this struct in bytes
        
        // XBOX_LIBRARY_VERSION     clientVersion;
        protected ushort    wMajorVersion;
        protected ushort    wMinorVersion;
        protected ushort    wBuildNumber;
        protected ushort    wQFENumber;
        //    
    
        protected uint      dwTitleID;
        protected uint      dwTitleVersion;
        protected uint      dwTitleRegion;
        protected ulong     qwXboxID;

        //List of alternate title IDs
        //DWORD dwAltTitleID[XONLINE_MAX_ALTERNATE_TITLE_ID]
        protected uint[]    dwAltTitleID;

        // Key used for signing data within a session
        protected byte[]    key;
        
        // The high 16 bits of dwUserFlags should come from the UODB User Table.
        protected XUIDAndTrust[]   xUsers;
       
        protected uint     dwNumServices;

        //DWORD dwServiceID[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
        protected uint[]   dwServiceIds;        
        //
    
        // the rest of the spidata structure (CSgMsgSpiData)

        protected ushort  _ipportI;                   // IP port of the client on the Internet
        protected uint    _ipaI;                      // IP address of the client on the Internet
        protected byte[]  _sgaddr;                    // SGADDR of the client
        protected ushort  _wVersionKeyEx;             // KeyEx version of the client
        protected ushort  _wFlagsKeyEx;               // Flags sent in KeyEx initiator
        protected ulong   _liNonce;                   // A random nonce associated with this session
        protected ulong   _liTimeInit;                // FILETIME marking session initiation
        protected uint    _fCs;                       // TRUE if SG is providing connection services
        
        // size of the spidata structure
        protected const int sizeSpiData = 186;
        protected const int sizeSpiData2 = 54;

        
        // the following is the STATIC request number.  it is initialized to 0, and
        // should only be used with the Interlocked.Increment protection
        //
        protected static int staticRequestNumber = 0;
        
        // the instance reqnum, set when a request is first made.
        protected int thisRequestNumber;
                
        // config settings
        // 
        protected static int maxRetries;
        protected static int sgTimeout; 

        // SG ip
        protected IPAddress _srcIP;      
        
        static SGInfo()
        {
            // load config settings
            maxRetries = XONLINE_SG_REQ_RETRIES;
            sgTimeout = XONLINE_SG_REQ_TIMEOUT;
        }
                                   
        /// <summary>
        /// The default constructor will create a new SGInfo with all the current information from
        /// the security gateway.
        /// </summary>       
        public SGInfo(IPAddress ipVirtual, ushort port)
        {              
            BinaryReader sgInfo = null;
            ushort srcPort;

            _srcIP = ipVirtual;
            srcPort = (ushort)IPAddress.HostToNetworkOrder(port);
     
            Socket sock;               
            byte[] sgRequest;
            byte[] sgResponse = null;                 
            bool haveData = false;
            int recBytes = 0;

            try
            {
                sock = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp );
                sock.Blocking = false;
                IPEndPoint SgMsgPort = new IPEndPoint(_srcIP, XONLINE_SG_MESSAGE_PORT);
                sock.Connect(SgMsgPort);
                    
                // build SG request.
                sgRequest = BuildRequest(_srcIP, srcPort);            

                try
                {
                    for(int i=0; i < maxRetries; i++ ) 
                    {
                        //send the request         
                        sock.Send(sgRequest);
                            
                        if(sock.Poll(sgTimeout * (1 << i), SelectMode.SelectRead)) 
                        {
                            int available = sock.Available;
                            sgResponse = new byte[available];
                                
                            recBytes = sock.Receive(sgResponse);                                
                            break;
                        }

                    }
                    
                    sock.Shutdown(SocketShutdown.Both);
                    sock.Close();
                }
                catch(Exception)
                {
                    // TODO - display info no the exception that occured
                }
                    
                if(sgResponse != null && recBytes > 0)
                {
                    sgInfo = new BinaryReader(new MemoryStream(sgResponse));             

                    // we've succeeded in getting results if we're here.
                    // see if they're meaningful.                    
                    haveData = VerifyResponse(sgInfo);
                }
                else
                {
                    // TODO - we didn't get a response from the SG
                }
               
                // make sure we have valid data.
                if (haveData == false) 
                {
                    // TODO - we have data from the SG, but it doesn't make sense
                }
                 
                ReadSgInfo(sgInfo, false);                    
            }
            catch(Exception)
            {
                // TODO - display info on the exception that occurred
            }
            finally
            {
            }  
        }
        
        private void ReadSgInfo(BinaryReader reader, bool onlyAuthData)
        {
            sgMessageHeader authHdr;

            // if we're getting more than authdata then get ready to read the spy.
            if (!onlyAuthData)
            {
                _ipportI         = reader.ReadUInt16();
                _ipaI            = reader.ReadUInt32();
                _sgaddr          = reader.ReadBytes(20);
                _wVersionKeyEx   = reader.ReadUInt16();
                _wFlagsKeyEx     = reader.ReadUInt16();
                _liNonce         = reader.ReadUInt64();
                _liTimeInit      = reader.ReadUInt64();
                _fCs             = reader.ReadUInt32();

                // read the spi header.
                authHdr._wType   = reader.ReadUInt16();
                authHdr._cbEnt   = reader.ReadUInt16();
            }            
            else
            {
                // set the default to the original auth data.
                authHdr._wType = SGMSG_TYPE_AUTHDATA2;
            }

            wAuthDataVersion = reader.ReadUInt16();
            if(wAuthDataVersion != XONLINE_AUTHDATA_VERSION) 
            {
                // TODO - We got an unexpected authdata version
            }            

            wAuthDataSize    = reader.ReadUInt16();
            wMajorVersion    = reader.ReadUInt16();
            wMinorVersion    = reader.ReadUInt16();
            wBuildNumber     = reader.ReadUInt16();
            wQFENumber       = reader.ReadUInt16();
            dwTitleID        = reader.ReadUInt32();
            dwTitleVersion   = reader.ReadUInt32();
            dwTitleRegion    = reader.ReadUInt32();
            qwXboxID         = reader.ReadUInt64();

            // read users (XUIDAndTrust)
            xUsers = new XUIDAndTrust[XONLINE_MAX_LOGON_USERS];
            for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {   
                xUsers[i] = new XUIDAndTrust(reader.ReadUInt64(), reader.ReadUInt32(), 0.0F);
            }
    
            // read services
            dwNumServices = reader.ReadUInt32();    
            dwServiceIds = new uint[XONLINE_MAX_NUMBER_SERVICE_PER_TICKET];
            for( int i = 0; i < XONLINE_MAX_NUMBER_SERVICE_PER_TICKET; i++ ) 
            {
                dwServiceIds[i]  = reader.ReadUInt32();
            }


            dwAltTitleID = new uint[XONLINE_MAX_ALTERNATE_TITLE_ID];

            //  read additional auth data information for later auth data structures.
            if ( authHdr._wType  == SGMSG_TYPE_AUTHDATA2 )
            {
                // read user truct factors.
                for( int i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
                {   
                    // set the user trust factor.
                    xUsers[i].userTrust = reader.ReadSingle();
                }                

                // read alternate title IDs
                for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ ) 
                {   
                    dwAltTitleID[i] = reader.ReadUInt32();
                }                

                // read ticket key
                key = reader.ReadBytes(XONLINE_KEY_LENGTH);
            }
            else
            {
                for( int i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++ ) 
                {
                    dwAltTitleID[i] = 0;
                }
                key = new byte[XONLINE_KEY_LENGTH];
            }
        }
        

        private byte[] BuildRequest(IPAddress ip, ushort port) 
        {
            MemoryStream ms = new MemoryStream();
            BinaryWriter wr = new BinaryWriter(ms);
            sgMessageHeader header;
            sgMessageSpiRequest req;
            byte[] reqSize;

            // build the data into structs for clean maintenance
            header._wType = SGMSG_TYPE_SPIDATA_REQ2;
            header._cbEnt = sizeMessageHeader + sizeMessageSpiRequest;
            thisRequestNumber = Interlocked.Increment(ref staticRequestNumber);
            req._dwReqNum = (uint)thisRequestNumber;

            byte[] addr = ip.GetAddressBytes();
            req._ipaZ     = ((uint)addr[0]) + ((uint)addr[1] << 8) + ((uint)addr[2] << 16) + ((uint)addr[3] << 24);
            req._ipportZ  = port;

            // now stream the structs out into a byte array.
            wr.Write(header._wType);
            wr.Write(header._cbEnt);
            wr.Write(req._dwReqNum);
            wr.Write(req._ipaZ);
            wr.Write(req._ipportZ);

            reqSize = ms.ToArray();
            Debug.Assert (reqSize.Length == header._cbEnt);

            return reqSize;
        }

        bool VerifyResponse(BinaryReader br)
        {
            sgMessageHeader header;
            sgMessageSpiResponse reply;

            header._wType = br.ReadUInt16();
            if (header._wType != SGMSG_TYPE_SPIDATA_REP2) 
            {
                //TODO - throw an exception
            }

            header._cbEnt = br.ReadUInt16();
            if (header._cbEnt != (sizeMessageHeader + sizeMessageSpiResponse)) 
            {
                //TODO - throw an exception
            }

            reply._dwReqNum = br.ReadUInt32();
            reply._ipaZ = br.ReadUInt32();
            reply._ipportZ = br.ReadUInt16();
            reply._fNotFound = br.ReadByte();

            if (reply._fNotFound != 0) 
            {
                IPAddress ipZ = new IPAddress (reply._ipaZ);
                // TODO - throw an exception
            }

            // make sure reqnum is the same as the request we sent.
            if (reply._dwReqNum != (uint)thisRequestNumber) 
            {
                return false;
            }
            
            // next reade the header on the auth data itself (as distinct from the
            // header on the SG reply, which is read above).
            header._wType = br.ReadUInt16();                     
            if (header._wType != SGMSG_TYPE_SPIDATA2) 
            {
                // TODO - throw an exception
            }

            header._cbEnt = br.ReadUInt16();
            if ( header._cbEnt != sizeSpiData2 ) 
            {
                // TODO - throw an exception
            }

            // if we made it this far, we should be ready to roll.
            return true;
        }
        
        public override string ToString()
        {
            try
            {
                int i;
                bool b;
                StringBuilder bldr = new StringBuilder();


                bldr.Append("Current SGInfo("+_srcIP+"):\r\n");
                bldr.Append("  TitleId:    0x" + TitleId.ToString("X") + "\r\n");
                bldr.Append("  TitleVer:   ");
                bldr.Append(dwTitleVersion.ToString("X"));
                bldr.Append("\r\n  TitleRgn:   ");
                bldr.Append(dwTitleRegion.ToString("X"));
                
                bldr.Append("\r\n  XboxLibVer: ");
                bldr.Append(wMajorVersion);
                bldr.Append(".");
                bldr.Append(wMinorVersion);
                bldr.Append(".");
                bldr.Append(wBuildNumber);
                bldr.Append(".");
                bldr.Append(wQFENumber);     
                
                bldr.Append("\r\n  MachineId: 0x" + MachineId.ToString("X") + "\r\n");
                bldr.Append("  ClientIP:  " + ClientIP.ToString() + "\r\n");

                b = false;
                for (i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
                {
                    if (xUsers[i].qwUserID != 0)
                    {
                        bldr.Append("  U" + i.ToString() + ": 0x" + xUsers[i].qwUserID.ToString("X") + " (" + xUsers[i].dwUserFlags.ToString("X") + "," + xUsers[i].userTrust.ToString() + ")\r\n");
                        b = true;
                    }
                    
                }
                if (b == false)
                {
                    bldr.Append("  no users present.\r\n");
                }
                    
                b = false;
                for (i = 0; i < XONLINE_MAX_NUMBER_SERVICE_PER_TICKET; i++)
                {
                    if (dwServiceIds[i] != 0)
                    {
                        bldr.Append("  SVC" + i.ToString() + ": 0x" + dwServiceIds[i].ToString("X") + "\r\n");
                        b = true;
                    }
                }
                if (b == false)
                {
                    bldr.Append("  no services present (!!!! WTF ??? How did this get through SG ???)\r\n");
                }
                
                b = false;
                for (i = 0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
                {
                    if (dwAltTitleID[i] != 0)
                    {
                        bldr.Append("  AltTitleID" + i.ToString() + ": 0x" + dwAltTitleID[i].ToString("X") + "\r\n");
                        b = true;
                    }
                }
                if (b == false)
                {
                    bldr.Append("  no AltTitleID present\r\n");
                }
                
                return bldr.ToString();
            }
            catch(Exception e)
            {
                return "Error building SGInfo.ToString(): " + e.ToString();
            }
        }

        // public accessors and helper methods
        public uint TitleId 
        {
            get { return dwTitleID; }
        }

        public uint TitleVersion
        {
            get { return dwTitleVersion; }
        }

        public ulong MachineId
        {
            get { return qwXboxID; }
        }

        public IPAddress ClientIP
        {
            get { return new IPAddress(_ipaI); }
        }

        public ulong TimeSessionStarted
        {
            get { return _liTimeInit; }
        }

        public XUIDAndTrust[] LogonUsers
        {
            get { return xUsers; }
        }
       
        public ulong Nonce
        {
            get { return _liNonce; }
        }

        public bool IsUserPresent(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return true;
                }
            }

            return false;
        }

        public bool CanUserPurchase(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId) 
                {
                    if(xUsers[i].CanPurchase())
                    {
                        return true;
                    }                     
                }
            }
            
            // user not found, or can't purchase
            return false;
        }

        public byte GetUserCountry(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return (xUsers[i].UserCountry());
                }
            }

            // user not found
            return 0;             
        }

        public float GetUserTrust(ulong passportId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_LOGON_USERS; i++ ) 
            {
                if(xUsers[i].qwUserID == passportId && !xUsers[i].IsGuest())
                {
                    return (xUsers[i].userTrust);
                }
            }

            // user not found
            return Single.NaN;             
        }

        public bool IsServicePresent(uint serviceId)
        {
            int i;
            for(i = 0; i < XONLINE_MAX_NUMBER_SERVICE_PER_TICKET; i++ ) 
            {
                if(dwServiceIds[i] == serviceId) 
                {
                    return true;
                }
            }

            // service not found
            return false;             
        }

        public byte[] SignWithKey( byte[] data, int offset, int count )
        {
            HMACSHA1 shaM = new HMACSHA1(key);
            
            shaM.ComputeHash(data, offset, count);
             
            return shaM.Hash;
        }

        public byte[] ConstructAuthData()
        {
            int i;
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            w.Write(wAuthDataVersion);
            w.Write(wAuthDataSize);
            w.Write(wMajorVersion);
            w.Write(wMinorVersion);
            w.Write(wBuildNumber);
            w.Write(wQFENumber);
            w.Write(dwTitleID);
            w.Write(dwTitleVersion);
            w.Write(dwTitleRegion);
            w.Write(qwXboxID);
            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].qwUserID);
                w.Write(xUsers[i].dwUserFlags);
            }

            w.Write(dwNumServices);
            for (i=0; i < dwServiceIds.Length; i++)
            {
                w.Write(dwServiceIds[i]);
            }

            for (i=0; i < xUsers.Length; i++)
            {
                w.Write(xUsers[i].userTrust);
            }

            for (i=0; i < XONLINE_MAX_ALTERNATE_TITLE_ID; i++)
            {
                w.Write(dwAltTitleID[i]);
            }

            w.Write(key);
            
            return m.ToArray();
        }
                
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\lsp\XLSP\Types.cs ===
//
// Types.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a helper classes used by AuthData to help manage the XUID information.
//
//  To use it, retrieve it from the Users property of AuthData, and then use the gettable properties on this object.
//

using System;
using System.Net;

using xonline.common.offer;     // TierEnum (common/marketplace/offer/offer.cs)
using xonline.common.service;   // XOn (common/core/service/xon.cs)

namespace Microsoft.XboxLive.XLSP
{
#region Client
    /// <summary>
    /// Data specific to the device that initiated the connection
    /// </summary>
    public sealed class Client
    {
        private Platforms platform;
        private IPAddress ip;
        private int port;
        private Language language;
        
        internal Client( Platforms clientPlatform, IPAddress clientIP, int clientPort, Language clientLanguage )
        {
            platform = clientPlatform;
            ip = clientIP;
            port = clientPort;
            language = clientLanguage;
        }
        
        /// <summary>
        /// Device type that is calling into LIVE via SG
        /// </summary>
        public Platforms Platform
        {
            get { return platform; }
        }

        /// <summary>
        /// The public IP address of the client device
        /// </summary>
        public IPAddress IPAddress
        {
            get { return new IPAddress(ip.GetAddressBytes()); }
        }

        /// <summary>
        /// The public port of the client device
        /// </summary>
        public int Port
        {
            get { return port; }
        }

        /// <summary>
        /// Refers to the device language. Users also have their own language, which may not match the console language.
        /// </summary>
        public Language Language
        {
            get { return language; }
        }
    }
#endregion //Client

#region Country
    /// <summary>
    /// Structure containing country data
    /// </summary>
    public sealed class Country
    {
        // Note 17 - "CB" not used
        // Note 94 - "SP" not used
        static private string[] ISO3166Array = {
            "AE", "AL", "AM", "AR", "AT", "AU", "AZ", "BE", "BG", "BH", 
            "BN", "BO", "BR", "BY", "BZ", "CA", "CB", "CH", "CL", "CN", 
            "CO", "CR", "CZ", "DE", "DK", "DO", "DZ", "EC", "EE", "EG", 
            "ES", "FI", "FO", "FR", "GB", "GE", "GR", "GT", "HK", "HN", 
            "HR", "HU", "ID", "IE", "IL", "IN", "IQ", "IR", "IS", "IT", 
            "JM", "JO", "JP", "KE", "KG", "KR", "KW", "KZ", "LB", "LI", 
            "LT", "LU", "LV", "LY", "MA", "MC", "MK", "MN", "MO", "MV", 
            "MX", "MY", "NI", "NL", "NO", "NZ", "OM", "PA", "PE", "PH", 
            "PK", "PL", "PR", "PT", "PY", "QA", "RO", "RU", "SA", "SE", 
            "SG", "SI", "SK", "SP", "SV", "SY", "TH", "TN", "TR", "TT", 
            "TW", "UA", "US", "UY", "UZ", "VE", "VN", "YE", "ZA", "ZW"
            };
        
        private CountryCode countryCode;  // Xboxlive country/region code
        private string name;    // ISO 3166 two-ketter country/region code

        internal Country( CountryCode country )
        {
            countryCode = country;
            name = ISO3166Array[(int)countryCode-1];
        }
        
        /// <summary>
        /// Xbox LIVE numeric country id
        /// </summary>
        public CountryCode CountryCode
        {
            get { return countryCode; }
        }

        /// <summary>
        /// 2 character ISO 3166 code. Can be passed directly to System.Globalization.RegionInfo constructor.
        /// </summary>
        public string Name
        {
            get { return name; }
        }

    }
#endregion //Country

#region Language
    /// <summary>
    /// Structure containing language data
    /// </summary>
    public sealed class Language
    {
        static private string[] ISO639Array = {
            "XX", "en", "ja", "de", "fr", "es", "it", "ko", "zh", "pt", "zh", 
            "pl", "ru", "da", "fi", "nb", "nl", "sv", 
             };
        // According to t_languages in UODB Norwegian is "nb"
        // According to ISO 639-1 it should be "no", being consistent with the UODB
        
        private LanguageCode languageCode;  // Xboxlive language code
        private string name;    // ISO 639-1 two-ketter country/region code

        internal Language( LanguageCode language )
        {
            languageCode = language;
            name = ISO639Array[(int)languageCode];
        }
        
        /// <summary>
        /// Xbox LIVE numeric country id
        /// </summary>
        public LanguageCode LanguageCode
        {
            get { return languageCode; }
        }

        /// <summary>
        /// 2 character ISO 639-1 language identifier
        /// When paired with the Country Code (RFC 1766), you can pass this directly to System.Globalization.CultureInfo constructor
        /// </summary>
        public string Name
        {
            get { return name; }
        }

    }
#endregion //Language

#region Misc
    /// <summary>
    /// Xbox LIVE Supported Platforms
    /// </summary>
    public enum Platforms
    {
        Xbox1,
        Xbox360,
        PC
    }
   
    /// <summary>
    /// List of features that can be controlled via privacy settings. The most restrictive settings are applied for all logged in users.
    /// </summary>
    public enum PrivacySettings
    {
        /// <summary>
        /// Who can communicate via text or voice with the logged in users?
        /// </summary>
        Communications,
        /// <summary>
        /// Which users can view your profile?
        /// </summary>
        ViewProfile,
        /// <summary>
        /// Which content can be viewed by the currently logged in users? 
        /// </summary>
        UserGeneratedContent,
        /// <summary>
        /// Which users can view the current presence state of the logged in users?
        /// </summary>
        Presence,
        /// <summary>
        /// Who can communicate via video with the logged in users?
        /// </summary>
        VideoCommunications
    }

    /// <summary>
    /// Privacy settings that can be applied to any of the features enumerated in PrivacySettings
    /// </summary>
    public enum PrivacyValues
    {
        Blocked,
        FriendsOnly,
        Everyone
    }

    /// <summary>
    /// Privacy settings that can be applied to any of the features enumerated in PrivacySettings
    /// </summary>
    public enum Privilege
    {
        Communications                      = XOn.XPRIVILEGE_COMMUNICATIONS,
        CommunicationsFriendsOnly           = XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY,
        ProfileViewing                      = XOn.XPRIVILEGE_PROFILE_VIEWING,
        ProfileViewingFriendsOnly           = XOn.XPRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY,
        UserCreatedContent                  = XOn.XPRIVILEGE_USER_CREATED_CONTENT,
        UserCreatedContentFriendsOnly       = XOn.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY,
        Presence                            = XOn.XPRIVILEGE_PRESENCE,
        PresenceFriendsOnly                 = XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY,
        VideoCommunications                 = XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS,
        VideoCommunicationsFriendsOnly      = XOn.XPRIVILEGE_VIDEO_COMMUNICATIONS_FRIENDS_ONLY,

        ContentAuthor                       = XOn.XPRIVILEGE_CONTENT_AUTHOR,
        MultiplayerSessions                 = XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS,
    }

    public enum SubscriptionTier
    {
        NewUser = (int) TierEnum.NewUser,
        Silver = (int) TierEnum.Silver,
        Gold = (int) TierEnum.Gold,
        FamilyGold = (int) TierEnum.FamilyGold,
    }
#endregion //Misc

#region Title
    /// <summary>
    /// Data specific to the currently running title on the client device
    /// </summary>
    public sealed class Title
    {
        private uint titleID;
        private uint version;
        
        internal Title( uint id, uint ver )
        {
            titleID = id;
            version = ver;
        }
        
        /// <summary>
        /// Decimal representation of hex title id
        /// </summary>
        public uint TitleID
        {
            get { return titleID; }
        }

        /// <summary>
        /// Current version of the title attempting to connect
        /// </summary>
        public uint Version
        {
            get { return version; }
        }
    }
#endregion //Title


#region Country Constants
    /// <summary>
    /// XLSP Country Code - authoritative source is .\common\core\genx\xon\inc\xonline.x
    /// </summary>
    public enum CountryCode
    {
        UnitedArabEmirates      = 1,
        Albania                 = 2,
        Armenia                 = 3,
        Argentina               = 4,
        Austria                 = 5,
        Australia               = 6,
        Aserbaijan              = 7,
        Belgium                 = 8,
        Bulgaria                = 9,
        Bahrain                 = 10,
        BruneiDarussalam        = 11,
        Bolivia                 = 12,
        Brazil                  = 13,
        Belarus                 = 14,
        Belize                  = 15,
        Canada                  = 16,
        Switzerland             = 18,
        Chile                   = 19,
        China                   = 20,
        Colombia                = 21,
        CostaRica               = 22,
        CzechRepublic           = 23,
        Germany                 = 24,
        Denmark                 = 25,
        DominicanRepublic       = 26,
        Algeria                 = 27,
        Ecuador                 = 28,
        Estonia                 = 29,
        Egypt                   = 30,
        Spain                   = 31,
        Finland                 = 32,
        FaroeIslands            = 33,
        France                  = 34,
        GreatBritain            = 35,
        Georgia                 = 36,
        Greece                  = 37,
        Guatemala               = 38,
        HongKong                = 39,
        Honduras                = 40,
        Croatia                 = 41,
        Hungary                 = 42,
        Indonesia               = 43,
        Ireland                 = 44,
        Isreal                  = 45,
        India                   = 46,
        Iraq                    = 47,
        Iran                    = 48,
        Iceland                 = 49,
        Italy                   = 50,
        Jamaica                 = 51,
        Jordan                  = 52,
        Japan                   = 53,
        Kenya                   = 54,
        Kyrgyzstan              = 55,
        Korea                   = 56,
        Kuwait                  = 57,
        Kazakhstan              = 58,
        Lebanon                 = 59,
        Liechtenstein           = 60,
        Lithuania               = 61,
        Luxembourg              = 62,
        Latvia                  = 63,
        Libya                   = 64,
        Morocco                 = 65,
        Monaco                  = 66,
        Macedonia               = 67,
        Mongolia                = 68,
        Macau                   = 69,
        Maldives                = 70,
        Mexico                  = 71,
        Malaysia                = 72,
        Nicaragua               = 73,
        Netherlands             = 74,
        Norway                  = 75,
        NewZealand              = 76,
        Oman                    = 77,
        Panama                  = 78,
        Peru                    = 79,
        Philippines             = 80,
        Pakistan                = 81,
        Poland                  = 82,
        PuertoRico              = 83,
        Portugal                = 84,
        Paraguay                = 85,
        Qatar                   = 86,
        Romania                 = 87,
        RussianFederation       = 88,
        SaudiArabia             = 89,
        Sweden                  = 90,
        Singapore               = 91,
        Slovenia                = 92,
        SlovakRepublic          = 93,
        ElSalvador              = 95,
        Syria                   = 96,
        Thailand                = 97,
        Tunisia                 = 98,
        Turkey                  = 99,
        TrinidadAndTobago       = 100,
        Taiwan                  = 101,
        Ukraine                 = 102,
        UnitedStates            = 103,
        Uruguay                 = 104,
        Uzbekistan              = 105,
        Venezuela               = 106,
        VietNam                 = 107,
        Yemen                   = 108,
        SouthAfrica             = 109,
        Zimbabwe                = 110,
    }
#endregion
    
#region Language Constants
    /// <summary>
    /// XLSP Language Code - Authoritative source is t_languages in UODB
    /// </summary>
    public enum LanguageCode
    {
        Unknown                 = 0,
        English                 = 1,
        Japanese                = 2,
        German                  = 3,
        French                  = 4,
        Spanish                 = 5,
        Italian                 = 6,
        Korean                  = 7,
        Chinese                 = 8,
        Portuguese              = 9,        
        SimplifiedChinese       = 10,
        Polish                  = 11,
        Russian                 = 12,
        Danish                  = 13,
        Finnish                 = 14,
        Norwegian               = 15,
        Dutch                   = 16,
        Swedish                 = 17,
    }
#endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\fd\Service\MarketplaceCatalogPerfCounters.cs ===
using System;
using System.Data;
using System.Diagnostics;
using System.Text;
using System.Web;
using System.Collections;
using System.Reflection;
using System.Collections.Generic;
using System.Xml;
using System.Configuration.Install;

using xonline.common.config;
using xonline.common.utilities;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.installer;

namespace xonline.server.marketplacecatalog.fd.service
{
    [XomPerformanceCounterCategoryAttr("Marketplace Catalog FD: Marketplace Catalog Perf Counters", "Counters for Marketplace Catalog")]
    public class MarketplaceCatalogPerfCounters : XomPerformanceCounterCategory
    {
        static public MarketplaceCatalogPerfCounters counters = new MarketplaceCatalogPerfCounters();

        [XomPerformanceCounterAttr(
        "Marketplace Catalog: Number of Product query calls",
        "The number of times the product query has been called.",
        PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter NumberOfQueryCalls;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\fd\Service\global.asax.cs ===
using System;
using System.Web;

using xonline.server.mgmt.soap;
using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.feapp;

namespace xonline.server.marketplacecatalog.fd.service
{
    public class MarketplaceCatalogApp : SoapFrontEndApp
    {
        /// <summary>
        /// Default constructor
        /// </summary>
        public MarketplaceCatalogApp()
            : base()
        {

        }

        public override void Application_Start(object sender, EventArgs eventArgs)
        {
            //Call the base 
            base.Application_Start(sender, eventArgs);

            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);

            XBanc.Init();
        }

        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            try 
            {
                switch(args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(
                            "Marketplace Catalog help:\r\n" +
                            "  flush [methodName] -- flushes catalog results cache\r\n" +
                            "\r\n",
                            args.RequestId
                        );

                        args.Handled = true;
                        break;

                    case "flush":
                        if ((args.CommandArgs == null) || (args.CommandArgs.Length == 0))
                            MarketplaceCatalogV1.Flush(null);
                        else if ((args.CommandArgs != null) && (args.CommandArgs.Length == 1))
                            MarketplaceCatalogV1.Flush(args.CommandArgs[0]);
                        else
                        {
                            XomControlConnection.SendMessage(
                                "Invalid arguments,  must specify 0 or 1 methodNames\r\n", args.RequestId
                            );

                            args.Handled = true;
                            break;
                        }

                        XomControlConnection.SendMessage(
                            "MarketplaceCatalog results cache has been flushed\r\n", args.RequestId
                        );

                        args.Handled = true;
                        break;
                }
            } catch (Exception e) {
                HResult hr = XRLException.ToHResult(e, HResult.XONLINE_E_CATALOG_ERROR); //TODO update error code
                XomControlConnection.SendMessage(
                    string.Format("Error: {0}, hr = {1}\r\n\r\n", e.ToString(), hr),
                    args.RequestId
                );
            }
        }

        /// <summary>
        /// Handles being requests
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public override void Application_BeginRequest(object sender, EventArgs e)
        {
            base.Application_BeginRequest(sender, e);
            if (HttpContext.Current.Request.CurrentExecutionFilePath.ToLower() == "/marketplacecatalog/marketplacecatalogv1.svc")
            {
                HttpContext.Current.Items["ActiveAuthPolicyId"] = "/MarketplaceCatalog/MarketplaceCatalogV1.svc/v1/{resource}/{locale}/{guid}";
            }            
            FrontEndCompression.Compress(HttpContext.Current);
        }

        /// <summary>
        /// Handles errors
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_OnError(object sender, EventArgs ea)
        {
            
        }

        /// <summary>
        /// Formats the return request
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_EndRequest(object sender, EventArgs ea)
        {
            base.Application_EndRequest(sender, ea);

            // Header not needed
            Context.Response.Headers.Remove("X-AspNet-Version");

            // Change content type to atom if it is being set back as a stream
            // This is because WCF requires us to return the XML as a serializable class, and
            // a stream allows this. However, we want the content-type to be of atom+xml
            String contentType = Context.Response.Headers["Content-Type"];
            if(contentType != null && contentType.ToLower().CompareTo("application/octet-stream") == 0)
            {
                Context.Response.Headers.Set("Content-Type", "application/atom+xml; charset=UTF-8");
            }
        }

        // added just to initialize AAInfo
        public override void Application_PostAuthenticateRequest(object sender, EventArgs eventArgs)
        {
            base.Application_PostAuthenticateRequest(sender, eventArgs);

            // Init the Context cache, so errors/events can use the base AAInfo object
            AAInfo aa = AAInfoInternetTier.Current;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\fd\Service\MarketplaceCatalogHealthBlock.cs ===
using System;
using System.Collections.Specialized;
using System.Collections.Generic;

using Com.FastSearch.Esp.Search;
using Com.FastSearch.Esp.Search.Query;
using Com.FastSearch.Esp.Search.Result;
using Com.FastSearch.Esp.Search.View;

using xonline.common.health;
using xonline.common.config;

namespace xonline.server.marketplacecatalog.fd.service
{

    public class MarketplaceCatalogHealthBlock : IHealthBlock
    {
        public MarketplaceCatalogHealthBlock()
        {
            // leave this empty
        }

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(
            HealthBlockManager  blockManager, 
            NameValueCollection blockParams,
            HealthReport        report
        )
        {            
            report.HealthStatus = HealthStatusEnum.Red;

            try
            {
                IVirtualInterfaceInfo interfaceInfo = Config.GetVirtualInterface(Component.fastEspMarketplaceSearch);
                report.ExtendedReport = new MarketplaceCatalogExtendedReport()
                {
                    searchIp = interfaceInfo.IPAddressString,
                    collectionName = interfaceInfo.Info1.ToLower(),
                    searchPort = interfaceInfo.Port
                };

                NameValueCollection configuration = new NameValueCollection();
                configuration.Add("Com.FastSearch.Esp.Search.Http.QRServers", String.Format("{0}:{1}", interfaceInfo.IPAddressString, interfaceInfo.Port));

                ISearchFactory searchFactory = SearchFactory.NewInstance(configuration);
                ISearchView searchView = searchFactory.GetSearchView(interfaceInfo.Info1.ToLower());

                // If we get here, we know that we have received a search view meaning that we can reach the query server and
                // that the collection is in place
                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception ex)
            {
                report.ErrorDetails = ex.ToString();
            }
        }

        public class MarketplaceCatalogExtendedReport : IExtendedHealthReport
        {
            public string searchIp;
            public string collectionName;
            public int searchPort;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\fd\Contracts\ServiceContractV1.cs ===
using System;
using System.Xml;
using System.ServiceModel;
using System.ServiceModel.Web;
using System.IO;

namespace xonline.server.marketplacecatalog.fd.contract
{
    [ServiceContract(Name = "MarketplaceCatalog", Namespace = "http://marketplacecatalog/V1")]
    public interface IMarketplaceCatalogV1
    {
        [WebGet(UriTemplate = "v1/{resource}/{locale}/{guid}")]
        [OperationContract(Name = "ResourceQueryOnProduct")]
        Stream ResourceQueryOnProduct(string resource, string locale, string guid);

        [WebGet(UriTemplate = "v1/{resource}/{locale}")]
        [OperationContract(Name = "ResourceQuery")]
        Stream ResourceQuery(string resource, string locale);

        // Post equals
        [WebInvoke(Method = "POST", UriTemplate = "v1/{resource}/{locale}")]
        [OperationContract(Name = "ResourceQueryPost")]
        Stream ResourceQueryPost(string resource, string locale, Stream input);

        [WebInvoke(Method = "POST", UriTemplate = "v1/{resource}/{locale}/{guid}")]
        [OperationContract(Name = "ResourceQueryOnProductPost")]
        Stream ResourceQueryOnProductPost(string resource, string locale, string guid, Stream input);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\fd\Service\MarketplaceCatalogV1.svc.cs ===
using System;
using System.Xml;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.Web;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ServiceModel.Channels;
using System.ServiceModel.Web;
using System.ServiceModel.Description;
using System.ServiceModel.Syndication;
using System.ServiceModel.Activation;
using System.Runtime.Serialization;
using System.Collections;
using System.IO;

using xonline.server.mgmt.soap;
using xonline.common.fse;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.catalogutil;
using xonline.server.marketplacecatalog.fd.contract;
using xonline.common.marketplace.marketplacecatalogutil;

[assembly: XomIisInstallerAttribute(Interface.marketplacecatalog)]
[assembly: XomIisInstallerAttribute(Interface.marketplacecatalog_int)]
[assembly: ConfigAttribute(Component.marketplacecatalog)]
[assembly: XomAreaDefinition(XomAreaName.marketplacecatalog)]

namespace xonline.server.marketplacecatalog.fd.service
{
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MarketplaceCatalogV1 : IMarketplaceCatalogV1
    {
        private static FseService          _service = null;
        private static MarketplaceCatalogDelegates _cd = null;
        private static readonly string versionString = string.Intern("v1");
        private static readonly string emptyGuid = string.Intern(Guid.Empty.ToString());

        static MarketplaceCatalogV1()
        {
            _service = new FseService("MarketplaceCatalog", "npdb", new MarketplaceCatalogResultHandler(), new MarketplaceCatalogPageHandler());

            _cd = new MarketplaceCatalogDelegates();
            // Add application specific delegates
            _service.AddParamDelegate("editorialprivilege", new FseParamDelegate(_cd.EditorialPrivilegeDelegate));
            _service.AddParamDelegate("mediavisibilitydate", new FseParamDelegate(_cd.AdjustBookmarkDelegate));
            _service.AddParamDelegate("startdate", new FseParamDelegate(_cd.AdjustBookmarkDelegate));
            _service.AddParamDelegate("enddate", new FseParamDelegate(_cd.AdjustBookmarkDelegate));
            _service.AddParamDelegate("visibilitylevel", new FseParamDelegate(_cd.AdjustVisibilityLevelDelegate));
            _service.AddParamDelegate("bodytypes", new FseParamDelegate(_cd.AdjustAvatarBodyTypeDelegate));
            _service.AddParamDelegate("platformtypes", new FseParamDelegate(_cd.AdjustPlatformTypesDelegate));        
        }

        /// <summary>
        /// Resource query on a given media
        /// </summary>
        public Stream ResourceQueryOnProduct(string resource, string locale, string guid)
        {
            NameValueCollection queryParameters = WebOperationContext.Current.IncomingRequest.UriTemplateMatch.QueryParameters;

            return Query(resource, locale, guid, queryParameters);
        }

        /// <summary>
        /// Resource query with no media
        /// </summary>
        public Stream ResourceQuery(string resource, string locale)
        {
            NameValueCollection queryParameters = WebOperationContext.Current.IncomingRequest.UriTemplateMatch.QueryParameters;

            // Passing the parameters to the ResourceQueryOnMedia with an empty guid 
            // will cause the guid parameter to not be added, but the rest of the query string to be used
            return Query(resource, locale, emptyGuid, queryParameters);
        }

        /// <summary>
        /// Post equal of ResourceQuery
        /// </summary>
        public Stream ResourceQueryPost(string resource, string locale, Stream input)
        {
            StreamReader sr = new StreamReader(input); 
            string s = sr.ReadToEnd(); 
            sr.Dispose();
            NameValueCollection queryParameters = HttpUtility.ParseQueryString(s);

            return Query(resource, locale, emptyGuid, queryParameters);
        }

        /// <summary>
        /// Post equal of ResourceQueryOnProduct
        /// </summary>
        public Stream ResourceQueryOnProductPost(string resource, string locale, string guid, Stream input)
        {
            StreamReader sr = new StreamReader(input);
            string s = sr.ReadToEnd();
            sr.Dispose();
            NameValueCollection queryParameters = HttpUtility.ParseQueryString(s);

            return Query(resource, locale, guid, queryParameters);
        }

        /// <summary>
        /// Queries the service in the back end
        /// </summary>
        private Stream Query(string resource, string locale, string guid, NameValueCollection queryParameters)
        {
            try
            {
                List<string> Names = new List<string>(3);
                List<string> Values = new List<string>(3);

                resource = (resource + versionString).ToLower();

                this.AddParameter("resource", resource, Names, Values);
                this.AddParameter("locale", locale, Names, Values);

                // Only add the guid if it was passed in. If it was not passed in, it will default to an empty guid           
                if (!guid.Equals(emptyGuid))
                {
                    this.AddParameter("guid", guid, Names, Values);
                }                

                foreach (string queryName in queryParameters.Keys)
                {
                    this.AddParameter(queryName, queryParameters[queryName], Names, Values);
                }

                MarketplaceCatalogPerfCounters.counters.NumberOfQueryCalls.Increment();

                return MarketplaceCatalogHelper.Query(_service, resource, Names.ToArray(), Values.ToArray());
            }
            catch (Exception ex)
            {
                SoapFrontEndApp.LogException(ex);
                Xom.Log(XomAreaName.marketplacecatalog, String.Format("Error calling Marketplace Catalog FD: {0}", ex.ToString()));
                throw new XRLException(HResult.XONLINE_E_MARKETPLACECATALOG_UNKNOWN_ERROR, xonline.common.service.XEvent.Id.MARKETPLACECATALOG_ERROR, String.Format("Error calling Marketplace Catalog FD: {0}", ex.ToString()), ex);
            }
        }

        /// <summary>
        /// Add parameter to the parameter list
        /// </summary>
        /// <param name="parameterName">Name of the parameter</param>
        /// <param name="parameterValue">Value of the parameter</param>
        /// <param name="parameterNameList">Parameter name list</param>
        /// <param name="parameterValueList">Parameter value list</param>
        private void AddParameter(string parameterName, string parameterValue, List<string> parameterNameList, List<string> parameterValueList)
        {           
            parameterNameList.Add(parameterName);
            if (parameterValue != null)
            {
                parameterValueList.Add(parameterValue);
            }
        }

        /// <summary>
        /// Flushes the cache
        /// </summary>
        /// <param name="methodName">Method of cache to flush</param>
        public static void Flush(string methodName)
        {
            _service.Flush(methodName, null, null, false);
        }
    }

    /// <summary>
    /// Maps all incoming content to be raw. See this blog page for details on why this is needed:
    /// http://blogs.msdn.com/b/carlosfigueira/archive/2008/04/17/wcf-raw-programming-model-receiving-arbitrary-data.aspx
    /// 
    /// In short, the content type referenced below is for the data contained in the post that is being passed up. If 
    /// we see that we are being posted some text/xml type we actually want that to be RAW so it shows up in our stream
    /// </summary>
    public class ContentTypeMapper : WebContentTypeMapper
    {
        public override WebContentFormat GetMessageFormatForContentType(string contentType)
        {
            if (contentType == "text/xml")
            {
                return WebContentFormat.Raw;
            }
            else
            {
                return WebContentFormat.Default;
            }
        }
    }    

    /// <summary>
    /// When the WCF service is created, a factory is used to create the ServiceHost. Currently, 
    /// WCF does not support two ports being binded to the same website. This custom factory ensures 
    /// that only the publicly facing WCF port is used for binding. The other port is internal only, 
    /// and uses ASP back compat mode when called for the internal only health check. This means 
    /// that it does not need to be hosted on the same ServiceHost.
    /// 
    /// Note that in the next version, 4.0, multiple ports can be hosted at the same site. A setting
    /// can be added to the web.config to turn this setting on:
    /// <serviceHostingEnvironment multipleSiteBindingsEnabled="true" />
    /// 
    /// </summary>
    public class CatalogCustomServiceHostFactory : ServiceHostFactory
    {
        protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            Uri[] address = GetAppropriateBase(baseAddresses);
            ServiceHost host = base.CreateServiceHost(serviceType, address);
            host.AddServiceEndpoint(typeof(xonline.server.marketplacecatalog.fd.contract.IMarketplaceCatalogV1), GetBinding(), "").Behaviors.Add(new WebHttpBehavior());

            return host;
        }

        private Uri[] GetAppropriateBase(Uri[] baseAddresses)
        {
            IVirtualInterfaceInfo interfaceInfo = Config.GetVirtualInterface(Component.marketplacecatalog);

            var retAddress = from b in baseAddresses
                             where b.Port == interfaceInfo.Port
                             select b;

            return retAddress.ToArray();
        }

        public static Binding GetBinding()
        {
            CustomBinding result = new CustomBinding(new WebHttpBinding());
            WebMessageEncodingBindingElement webMEBE = result.Elements.Find<WebMessageEncodingBindingElement>();
            webMEBE.ContentTypeMapper = new ContentTypeMapper();
            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\Multisetting.cs ===
//------------------------------------------------------------------------------
// <copyright file="Multisetting.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace xonline.server.marketplace.test
{

    using System;
    using System.Collections.Generic;
    using System.Xml.Serialization;

    /// <summary>
    /// Multisettings class
    /// </summary>
    [Serializable]
    public class Multisettings
    {
        [XmlElement(ElementName = "Multisetting")]
        public List<Multisetting> multisettings { get; set;}

        /// <summary>
        /// Multisettings class constructor
        /// </summary>
        public Multisettings()
        {
            multisettings = new List<Multisetting>();
        }
    }

    /// <summary>
    /// Multisetting class
    /// </summary>
    [Serializable]
    public class Multisetting
    {
        public string Setting { get; set; }
        public string Value { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\MarketplaceCatalogSpellCheckResubmit.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarketplaceCatalogSpellCheckResubmit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using System.Xml;
using System.Xml.XPath;
using System.Text;

using Marketplace.Test.Common.Service;
using ServerTestFramework;

namespace xonline.server.marketplace.test
{
    public class TestSpellCheckMultiSetting
    {
        public const string environment = "xblob";
        public const string component = "ALL";
        public const string site = "-1";
        public const string server = "ALL";
        public const string multisetting = "fastEspSpellCheckLanguage";
        public const string value = "";
    }

    [TestGroup, Owner("jeremyj"), TestFrequency("Daily")]
    public class MarketplaceCatalogSpellCheckDisabled
    {
        private static string marketplaceCatalogUrl = string.Empty;

        [TestGroupSetup]
        public void Setup()
        {
            marketplaceCatalogUrl = string.Format("http://{0}/marketplacecatalog/v1/product/en-us", Global.XEnv.GetInterface("marketplacecatalog")[0]);
        }

        [TestGroupTearDown]
        public void Shutdown() { }

        [TestCase, TestCasePriority(1)]
        public class P_Validate_SpellCheck_Disabled_Result : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    //Disable the spellcheck
                    Global.XEnv.MultiSettingAdd(TestSpellCheckMultiSetting.environment, TestSpellCheckMultiSetting.component, TestSpellCheckMultiSetting.site, TestSpellCheckMultiSetting.server, TestSpellCheckMultiSetting.multisetting, TestSpellCheckMultiSetting.value);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.marketplacecatalog, "e :marketplacecatalog configcacherefresh");

                    HttpWebRequest request = null;
                    Uri uri = new Uri(marketplaceCatalogUrl + "?" + "tiers=2.3&searchterm=afull");
                    Global.RO.Info("Url: {0}", uri.AbsoluteUri);

                    request = (HttpWebRequest)WebRequest.Create(uri);
                    request.Method = "GET";

                    string result = string.Empty;
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        using (Stream responseStream = response.GetResponseStream())
                        {
                            using (StreamReader readStream = new StreamReader(responseStream, Encoding.UTF8))
                            {
                                result = readStream.ReadToEnd();
                            }
                        }
                    }

                    if (result.Contains("<totalItems>0</totalItems>") && result.Contains("<numItems>0</numItems>"))
                    {
                        Global.RO.Info("Passed!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("FAIL!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                }
                catch (Exception ex)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error(
                        String.Format(
                            "Not able to query URL, received exception: {0}",
                            ex.ToString()));

                    return;
                }
                finally
                {
                    //Renable the spellcheck
                    Global.XEnv.MultiSettingDeleteValue(TestSpellCheckMultiSetting.environment, TestSpellCheckMultiSetting.component, TestSpellCheckMultiSetting.site, TestSpellCheckMultiSetting.server, TestSpellCheckMultiSetting.multisetting, TestSpellCheckMultiSetting.value);
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.marketplacecatalog, "e :marketplacecatalog configcacherefresh");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\MarketplaceFrontDoorTest.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarketplaceFrontDoorTest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#region References...

using System;
using ServerTestFramework;

#endregion

namespace xonline.server.marketplace.test
{
    public class MarketplaceFrontDoorTest : TestNode
    {
        private string testcaseName = String.Empty;

        public MarketplaceFrontDoorTest(string name)
            : base(name)
        {
            this.testcaseName = name;
        }

        public override void Run()
        {
            //TODO: ExecuteTestCase should be changed to return void and throw.  Changing this here to fix the build for now.
            TEST_RESULTS result = MarketplaceCatalogTests.ExecuteTestCase(this.testcaseName);
            if (result==TEST_RESULTS.FAILED)
            {
                throw new UnexpectedTestResultException("ExecuteTestCase returned FAILED");
            }
            else if (result==TEST_RESULTS.NOT_EXECUTED)
            {
                throw new DidNotExecuteException("ExecuteTestCase returned NOT_EXECUTED");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\MarketplaceCatalogHealthCheck.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarketplaceCatalogHealthCheck.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using System.Xml;
using System.Xml.XPath;
using Marketplace.Test.Common.Service;
using ServerTestFramework;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("MP-Costco"), TestFrequency("Daily"), EnvRequirement("Xblob")]
    public class MarketplaceCatalogHealthCheck
    {
        private const string healthCheckURLTemplate = "http://{0}:11230/marketplacecatalog/health.ashx?op=status";

        /// <summary>
        /// Gets the IPEndpoint for the Environment
        /// </summary>
        private static IPEndPoint EnvironmentIPEndPoint
        {
            get { return Global.XEnv.GetInterface("marketplacecatalog")[0]; }
        }

        [TestGroupSetup]
        public void Setup() { }

        [TestGroupTearDown]
        public void Shutdown() { }

        [TestCase, TestCasePriority(1)]
        public class HealthCheckIsResponsive : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string results = String.Empty;
                string healthCheckURL = String.Format(
                    healthCheckURLTemplate,
                    EnvironmentIPEndPoint.Address.ToString());

                Global.RO.Info(
                    String.Format(
                        "Test case will attempt to contac the health check at the following URL: {0}",
                        healthCheckURL));

                Global.RO.Info("Opening connection to the health check URL");

                try
                {
                    WebClient client = new WebClient();
                    Stream stream = client.OpenRead(healthCheckURL);
                    StreamReader reader = new StreamReader(stream);
                    results = reader.ReadToEnd();
                    reader.Close();
                }
                catch (Exception ex)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error(
                        String.Format(
                            "There was a problem opening the health check URL: {0}",
                            ex.ToString()));

                    return;
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class HealthCheckIsGreen : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.PASSED;

                string results = String.Empty;
                
                string healthCheckURL = String.Format(
                    healthCheckURLTemplate,
                    EnvironmentIPEndPoint.Address.ToString());

                Global.RO.Info(
                    String.Format(
                        "Test case will attempt to contac the health check at the following URL: {0}",
                        healthCheckURL));

                Global.RO.Info("Opening connection to the health check URL");

                try
                {
                    WebClient client = new WebClient();
                    Stream stream = client.OpenRead(healthCheckURL);
                    StreamReader reader = new StreamReader(stream);
                    results = reader.ReadToEnd();
                    reader.Close();
                }
                catch (Exception ex)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error(
                        String.Format(
                            "There was a problem opening the health check URL: {0}",
                            ex.ToString()));

                    return;
                }

                XmlDocument document = new XmlDocument();
                document.LoadXml(results);

                XPathNavigator navigator = document.CreateNavigator();
                XPathNodeIterator nodes = navigator.Select("/Healthcheck");
                if (nodes.Count == 0)
                {
                    Global.RO.Error("Invalid health check response received!");
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }
                else
                {
                    nodes.MoveNext();
                    results = nodes.Current.GetAttribute("HealthStatus", String.Empty);

                    if (results != "Green")
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                        Global.RO.Error("Health check is not in a Green state!");

                        navigator = document.CreateNavigator();
                        nodes = navigator.Select("/Healthcheck/Reports/HealthReport");
                        while (nodes.MoveNext())
                        {
                            if ("Red" == nodes.Current.GetAttribute("HealthStatus", String.Empty))
                            {
                                Global.RO.Error(
                                    String.Format(
                                        "{0} is currently Red in the health check.",
                                        nodes.Current.GetAttribute("Name", String.Empty)));
                            }
                        }

                        return;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\MarketplaceCatalogPostTest.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarketplaceCatalogHealthCheck.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using System.Xml;
using System.Xml.XPath;
using System.Text;

using Marketplace.Test.Common.Service;
using ServerTestFramework;
using ServerTestFramework.LiveService;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("craigta"), TestFrequency("Daily"), EnvRequirement("Xblob")]
    public class MarketplaceCatalogPost
    {
        private static string marketplaceCatalogUrl = string.Empty;

        [TestGroupSetup]
        public void Setup() 
        {
            marketplaceCatalogUrl = string.Format("http://{0}/marketplacecatalog/v1/product/en-us", Global.XEnv.GetInterface("marketplacecatalog")[0]);
        }

        [TestGroupTearDown]
        public void Shutdown() { }

        [TestCase, TestCasePriority(1)]
        public class p_Check_Post : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;               
                try
                {
                    HttpWebRequest request = null;
                    Uri uri = new Uri(marketplaceCatalogUrl);
                    Global.RO.Info("Url: {0}", uri.AbsoluteUri);
                    String postData = "tiers=1.2.3";

                    request = (HttpWebRequest) WebRequest.Create(uri);
                    request.Method = "POST";
                    request.ContentType = "application/x-www-form-urlencoded";
                    request.ContentLength = postData.Length;

                    using(Stream writeStream = request.GetRequestStream())
                    {
                        UTF8Encoding encoding = new UTF8Encoding();
                        byte[] bytes = encoding.GetBytes(postData);
                        writeStream.Write(bytes, 0, bytes.Length);
                    }

                    string result = string.Empty;
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        using (Stream responseStream = response.GetResponseStream())
                        {
                            using (StreamReader readStream = new StreamReader(responseStream, Encoding.UTF8))
                            {
                                result = readStream.ReadToEnd();
                            }
                        }
                    }

                    if (result.Contains("<a:title>Query Result</a:title>"))
                    {
                        Global.RO.Info("Passed!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("FAIL!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    
                }
                catch (Exception ex)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error(
                        String.Format(
                            "Not able to query URL, received exception: {0}",
                            ex.ToString()));

                    return;
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class p_Check_Get : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                try
                {
                    HttpWebRequest request = null;
                    Uri uri = new Uri(marketplaceCatalogUrl + "?" + "tiers=1.2.3");
                    Global.RO.Info("Url: {0}", uri.AbsoluteUri);

                    request = (HttpWebRequest)WebRequest.Create(uri);
                    request.Method = "GET";

                    string result = string.Empty;
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        using (Stream responseStream = response.GetResponseStream())
                        {
                            using (StreamReader readStream = new StreamReader(responseStream, Encoding.UTF8))
                            {
                                result = readStream.ReadToEnd();
                            }
                        }
                    }

                    if (result.Contains("<a:title>Query Result</a:title>"))
                    {
                        Global.RO.Info("Passed!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("FAIL!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }

                }
                catch (Exception ex)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error(
                        String.Format(
                            "Not able to query URL, received exception: {0}",
                            ex.ToString()));

                    return;
                }
            }
        }

        [TestCase, TestCasePriority(1)]
        public class p_Check_Xslt_post : TestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                String expectedResult = "<a:feed xmlns:a=\"http://www.w3.org/2005/Atom\" xmlns=\"http://marketplace.xboxlive.com/resource/product/v1\">"
+  "<totalItems>1</totalItems>"
+ "  <numItems>1</numItems>"
+  "  <locale>en-us</locale>"
+  "  <a:entry itemNum=\"1\" xmlns:a=\"http://www.w3.org/2005/Atom\" xmlns=\"http://marketplace.xboxlive.com/resource/product/v1\">"
+  "    <a:id>urn:uuid:00000000-0000-4060-8019-18b7169dd556</a:id>"
+  "  </a:entry>"
+  "</a:feed>";

                // Update/add setting override for fastEsp_allow_debug_xslt
                SettingState xsltSettingState = Global.XEnv.OverrideSetting("MarketplaceCatalog", "ALL", "fastEsp_allow_debug_xslt", "true");
                MarketplaceCatalogTests.RecycleMarketplaceCatalogAppPool();

                try
                {
                    HttpWebRequest request = null;
                    Uri uri = new Uri(marketplaceCatalogUrl);
                    Global.RO.Info("Url: {0}", uri.AbsoluteUri);
                    String postData = "products=00000000-0000-4060-8019-18b7169dd556&Tiers=2.3&offerfilter=1&xslt=%3Cxsl%3Astylesheet%20xmlns%3Axsl%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2FXSL%2FTransform%22%20xmlns%3Amsxsl%3D%22urn%3Aschemas-microsoft-com%3Axslt%22%20xmlns%3Aa%3D%22http%3A%2F%2Fwww.w3.org%2F2005%2FAtom%22%20xmlns%3Ab%3D%22http%3A%2F%2Fmarketplace.xboxlive.com%2Fresource%2Fproduct%2Fv1%22%20xmlns%3D%22http%3A%2F%2Fmarketplace.xboxlive.com%2Fresource%2Fproduct%2Fv1%22%20version%3D%221.0%22%20exclude-result-prefixes%3D%22msxsl%20b%22%3E%20%3Cxsl%3Aoutput%20method%3D%22xml%22%20indent%3D%22yes%22%20%2F%3E%20%3Cxsl%3Atemplate%20match%3D%22b%3Adetaillevel5%22%3E%20%3Cdetaillevelepix%3E%20%3Cxsl%3Acopy-of%20select%3D%22a%3Aid%22%20%2F%3E%20%3C%2Fdetaillevelepix%3E%20%3C%2Fxsl%3Atemplate%3E%20%3C%2Fxsl%3Astylesheet%3E";

                    request = (HttpWebRequest)WebRequest.Create(uri);
                    request.Method = "POST";
                    request.ContentType = "application/x-www-form-urlencoded";
                    request.ContentLength = postData.Length;

                    using (Stream writeStream = request.GetRequestStream())
                    {
                        UTF8Encoding encoding = new UTF8Encoding();
                        byte[] bytes = encoding.GetBytes(postData);
                        writeStream.Write(bytes, 0, bytes.Length);
                    }

                    string result = string.Empty;
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        using (Stream responseStream = response.GetResponseStream())
                        {
                            using (StreamReader readStream = new StreamReader(responseStream, Encoding.UTF8))
                            {
                                result = readStream.ReadToEnd();
                            }
                        }
                    }

                    MarketplaceCatalogTests.FilterXmlResults(ref result, "/a:feed/def:totalItems|/a:feed/def:numItems|/a:feed/def:locale|/a:feed/a:entry|/a:feed/a:entry/a:title|/a:feed/a:entry/a:id");

                    if (MarketplaceCatalogTests.CompareXml(result, expectedResult))
                    {
                        Global.RO.Info("Passed!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                    else
                    {
                        Global.RO.Error("FAIL!");
                        Global.RO.Info(result);
                        ResultCode = TEST_RESULTS.PASSED;
                    }

                }
                catch (Exception ex)
                {
                    ResultCode = TEST_RESULTS.FAILED;

                    Global.RO.Error(
                        String.Format(
                            "Not able to query URL, received exception: {0}",
                            ex.ToString()));

                }
                finally
                {
                    // restore fastEsp_allow_debug_xslt
                    Global.XEnv.RestoreOverrideSettingState(xsltSettingState);                    
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\MarketplaceCatalogCachingTests.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarketplaceCatalogCachingTests.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using System.Xml;
using System.Xml.XPath;
using System.Text;

using Marketplace.Test.Common.Service;
using ServerTestFramework;
using System.Data.SqlClient;
using xonline.common.config;
using System.Management;
using System.Threading;
using System.IO.Compression;

namespace xonline.server.marketplace.test
{
    [TestGroup, Owner("wirosas"), TestFrequency("Daily"), EnvRequirement("Xblob")]
    public class MarketplaceCatalogCachingTests
    {
        #region Constants

        private const string SELECT_CACHE_DURATION = "SELECT i_cache_duration FROM t_fse_methods WHERE vc_api_name = 'marketplacecatalog' AND vc_method_name = 'productv1'";
        private const string UPDATE_CACHE_DURATION = "UPDATE t_fse_methods SET i_cache_duration = {0} WHERE vc_api_name = 'marketplacecatalog' AND vc_method_name = 'productv1'";

        private const string QUERY_PAGESIZE1_PAGENUM1 = "http://{0}/marketplacecatalog/v1/product/en-us?tiers=2.3&stores=1&pagesize=1&pagenum=1";
        private const string QUERY_PAGESIZE1_PAGENUM2 = "http://{0}/marketplacecatalog/v1/product/en-us?tiers=2.3&stores=1&pagesize=1&pagenum=2";
        private const string QUERY_PAGESIZE2_PAGENUM1 = "http://{0}/marketplacecatalog/v1/product/en-us?tiers=2.3&stores=1&pagesize=2&pagenum=1";
        private const string QUERY_PAGESIZE2_PAGENUM2 = "http://{0}/marketplacecatalog/v1/product/en-us?tiers=2.3&stores=1&pagesize=2&pagenum=2";

        private const string QUERY_SPECIFIC_MEDIAID = "http://{0}/marketplacecatalog/v1/product/en-us?tiers=2.3&stores=1&products={1}";
        private const string REFRESH_MEDIAID = "http://{0}/cron/command.ashx?assembly=CatalogWatcherPlugin.dll&classname=xonline.server.cron.plugins.CatalogWatcherPlugin.CatalogWatcherCronWrapper&op=RefreshProductMediaIds&p1={1}";
        private const string UPDATE_MEDIA_TITLE = "UPDATE MediaLocale SET reducedTitle = '{0}' WHERE mediaId = '{1}' AND lcid = 1033";
        private const string SELECT_MEDIA_COUNT = "SELECT COUNT(*) FROM MediaLocale WHERE mediaId = '{0}' AND lcid = 1033";
        #endregion

        private static string mpCatalogMachineName = string.Empty;
        private static string cronMachineName = string.Empty;
        private static int originalCacheDuration = 0;

        [TestGroupSetup]
        public void Setup()
        {
            Global.RO.Info("----------Starting Setup----------");
            cronMachineName = Global.XEnv.GetVirtualInterface("cron_int").ToString();
            mpCatalogMachineName = Global.XEnv.GetVirtualInterface("marketplacecatalog").ToString();

            originalCacheDuration = GetCurrentCacheTime();

            //The cache might be off, so enable it (and set it to a reasonable time) for testing.
            SetCacheTime(600);

            //Recycle the app pool to pick up the changes to NPDB.
            RecycleAppPool();

            //Give the server a few seconds to catch up after recycling the app pool
            Sleep(15);

            //Executing a query to jump-start the system
            ExecuteQuery(string.Format(QUERY_PAGESIZE2_PAGENUM2, mpCatalogMachineName));

            Sleep(10);

            //Flush the cache
            FlushCache();
            Global.RO.Info("----------Ending Setup----------");
        }

        [TestGroupTearDown]
        public void Shutdown()
        {
            Global.RO.Info("----------Starting Shutdown----------");
            //On shutdown, reset the cache time to what it was before we mucked with it.
            Global.RO.Info("Done running tests, reverting cache time to its original value.");
            SetCacheTime(originalCacheDuration);

            //Recycle the app pool so the change is picked up
            RecycleAppPool();
            Global.RO.Info("----------Ending Shutdown----------");
        }

        [TestCase, Owner("wirosas"), TestCasePriority(1), TestFrequency("Daily"), EnvRequirement("Xblob")]
        public class P_CachingEnabled : TestBase
        {
            /* Goal of this test:
             * Make a query and get its cache expiration date.
             * Execute the same query again and make sure the cache expiration date is the same.
             * Flush Xbanc.
             * Execute the same query again, and make sure the expiration date is different.
             */
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                //Flush the cache to make sure our results are fresh.
                FlushCache();

                Sleep(5);

                string query = string.Format(QUERY_PAGESIZE1_PAGENUM1, mpCatalogMachineName);
                HttpWebResponse response = null;

                Global.RO.Info("Making first request: {0}", query);
                response = ExecuteQuery(query);

                DateTime firstExpirationDate = GetExpirationDateTime(response);

                Global.RO.Info("Wait a few seconds before making the next query");
                Sleep(10);

                Global.RO.Info("Making second request: {0}", query);
                response = ExecuteQuery(query);

                DateTime secondExpirationDate = GetExpirationDateTime(response);

                if (!DateTimesAreEqual(firstExpirationDate, secondExpirationDate))
                {
                    Global.RO.Error("Expiration dates do not match but they should!");
                    Global.RO.Error("First Query Expiration:  {0}", firstExpirationDate);
                    Global.RO.Error("Second Query Expiration: {0}", secondExpirationDate);
                    return;
                }

                Global.RO.Info("Query was cached successfully");
                Global.RO.Info("Flushing cache...");
                FlushCache();

                Global.RO.Info("Wait a few seconds before making the next query");
                Sleep(10);

                Global.RO.Info("Making third request: {0}", query);
                response = ExecuteQuery(query);

                DateTime thirdExpirationDate = GetExpirationDateTime(response);
                if (DateTimesAreEqual(secondExpirationDate, thirdExpirationDate))
                {
                    Global.RO.Error("Expiration dates should not match but they do!");
                    Global.RO.Error("Second Query Expiration: {0}", secondExpirationDate);
                    Global.RO.Error("Third Query Expiration:  {0}", thirdExpirationDate);
                    Global.RO.Error("Xbanc was flushed, so we would expect the cached query to be removed.");
                    return;
                }

                //Success!
                Global.RO.Info("Test Passed Successfully!");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("wirosas"), TestCasePriority(2), TestFrequency("Daily"), EnvRequirement("Xblob")]
        public class P_DifferentQueries_DifferentResults_DifferentExpirations_PageNum : TestBase
        {
            /* Goal of this test:
             * Make a query with pageNum=1
             * Make another query with pageNum=2
             * Verifies the response data is different (different queries, should not go to cache).
             */
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                //Flush the cache to make sure our results are fresh.
                FlushCache();

                string query = string.Empty; 
                HttpWebResponse response = null;

                query = string.Format(QUERY_PAGESIZE1_PAGENUM1, mpCatalogMachineName);
                Global.RO.Info("Making first unique request: {0}", query);
                response = ExecuteQuery(query);

                DateTime firstExpirationDate = GetExpirationDateTime(response);
                string firstResults = GetResponseData(response);

                Global.RO.Info("Wait a few seconds before making the next query");
                Sleep(10);

                query = string.Format(QUERY_PAGESIZE1_PAGENUM2, mpCatalogMachineName);
                Global.RO.Info("Making second unique request: {0}", query);
                response = ExecuteQuery(query);

                DateTime secondExpirationDate = GetExpirationDateTime(response);
                string secondResults = GetResponseData(response);

                if (DateTimesAreEqual(firstExpirationDate, secondExpirationDate))
                {
                    Global.RO.Error("Expiration dates should not match but they do!");
                    Global.RO.Error("First Query Expiration:  {0}", firstExpirationDate);
                    Global.RO.Error("Second Query Expiration: {0}", secondExpirationDate);
                    return;
                }

                if (firstResults == secondResults)
                {
                    Global.RO.Error("The queries provided should result in different results and they do not!");
                    Global.RO.Error("First results:");
                    Global.RO.Error(firstResults); 
                    Global.RO.Error("Second results:");
                    Global.RO.Error(secondResults);
                    return;
                }


                //Success!
                Global.RO.Info("Test Passed Successfully!");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("wirosas"), TestCasePriority(2), TestFrequency("Daily"), EnvRequirement("Xblob")]
        public class P_DifferentQueries_DifferentResults_DifferentExpirations_PageSize : TestBase
        {
            /* Goal of this test:
             * Make a query with pageSize=1
             * Make another query with pageSize=2
             * Verifies the response data is different (different queries, should not go to cache).
             */
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                //Flush the cache to make sure our results are fresh.
                FlushCache();

                string query = string.Empty;
                HttpWebResponse response = null;

                query = string.Format(QUERY_PAGESIZE1_PAGENUM1, mpCatalogMachineName);
                Global.RO.Info("Making first unique request: {0}", query);
                response = ExecuteQuery(query);

                DateTime firstExpirationDate = GetExpirationDateTime(response);
                string firstResults = GetResponseData(response);

                Global.RO.Info("Wait a few seconds before making the next query");
                Sleep(10);

                query = string.Format(QUERY_PAGESIZE2_PAGENUM1, mpCatalogMachineName);
                Global.RO.Info("Making second unique request: {0}", query);
                response = ExecuteQuery(query);

                DateTime secondExpirationDate = GetExpirationDateTime(response);
                string secondResults = GetResponseData(response);

                if (DateTimesAreEqual(firstExpirationDate, secondExpirationDate))
                {
                    Global.RO.Error("Expiration dates should not match but they do!");
                    Global.RO.Error("First Query Expiration:  {0}", firstExpirationDate);
                    Global.RO.Error("Second Query Expiration: {0}", secondExpirationDate);
                    return;
                }

                if (firstResults == secondResults)
                {
                    Global.RO.Error("The queries provided should result in different results and they do not!");
                    Global.RO.Error("First results:");
                    Global.RO.Error(firstResults);
                    Global.RO.Error("Second results:");
                    Global.RO.Error(secondResults);
                    return;
                }


                //Success!
                Global.RO.Info("Test Passed Successfully!");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Owner("wirosas"), TestCasePriority(2), TestFrequency("Daily"), EnvRequirement("Xblob")]
        public class P_UpdatedMedia_OldCachedDataReturned : TestBase
        {
            /* Test Goal:
             * Query for an item (it gets cached).
             * Update the item and document.
             * Query for the item again.  
             * The item should retain the old data because it was cached.
             * Flush the cache
             * Query again.
             * The item should have the new data.
             */
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                HttpWebResponse response = null;
                string mediaId = "66acd000-77fe-1000-9115-D802958B069D";

                Global.RO.Info("Ensuring expected test data is present...");
                int count = ExecuteRawCatalogDBCommand(string.Format(SELECT_MEDIA_COUNT, mediaId));
                if (count < 0)
                {
                    Global.RO.Error("Test Media does not exist in the DB!");
                    Global.RO.Error("Please make sure the acceptance data has been propped.");
                    Global.RO.Error("MediaId: {0}", mediaId);
                    return;
                }
                Global.RO.Info("Test data present!");

                string query = string.Format(QUERY_SPECIFIC_MEDIAID, mpCatalogMachineName, mediaId);

                Global.RO.Info("Making first query, {0}", query);
                response = ExecuteQuery(query);
                string firstResponse = GetResponseData(response);
                DateTime firstExpirationDate = GetExpirationDateTime(response);

                Global.RO.Info("Updating media to have a different title");
                string randomTitle = Path.GetRandomFileName();
                string updateCommand = string.Format(UPDATE_MEDIA_TITLE, randomTitle, mediaId);
                ExecuteRawCatalogDBCommand(updateCommand);
                Sleep(30); //give it time to execute and replicate.

                Global.RO.Info("Pushing media to FAST");
                string refreshQuery = string.Format(REFRESH_MEDIAID, cronMachineName, mediaId);
                Global.RO.Info(refreshQuery);
                ExecuteQuery(refreshQuery);
                Sleep(180); //this could take a while

                Global.RO.Info("Executing second query, {0}", query);
                response = ExecuteQuery(query);
                string secondResponse = GetResponseData(response);
                DateTime secondExpirationDate = GetExpirationDateTime(response);

                if (!DateTimesAreEqual(firstExpirationDate, secondExpirationDate))
                {
                    Global.RO.Error("Expiration dates should match but they don't!");
                    Global.RO.Error("First Query Expiration:  {0}", firstExpirationDate);
                    Global.RO.Error("Second Query Expiration: {0}", secondExpirationDate);
                    return;
                }

                if (firstResponse != secondResponse)
                {
                    Global.RO.Error("Responses are different when we expect them to be the same!");
                    Global.RO.Error("First response:");
                    Global.RO.Error(firstResponse);
                    Global.RO.Error("Second response:");
                    Global.RO.Error(secondResponse);
                    return;
                }

                Global.RO.Info("Cached result returned and correct.");

                Global.RO.Info("Flushing Cache");
                FlushCache();

                Sleep(10);

                Global.RO.Info("Executing third query, {0}", query);
                response = ExecuteQuery(query);
                string thirdResponse = GetResponseData(response);
                DateTime thirdExpirationDate = GetExpirationDateTime(response);

                if (DateTimesAreEqual(secondExpirationDate, thirdExpirationDate))
                {
                    Global.RO.Error("Expiration dates should not match but they do!");
                    Global.RO.Error("Second Query Expiration: {0}", secondExpirationDate);
                    Global.RO.Error("Third Query Expiration:  {0}", thirdExpirationDate);
                    return;
                }

                if (secondResponse == thirdResponse)
                {
                    Global.RO.Error("Responses are the same when we expect them to be different!");
                    Global.RO.Error("Second response:");
                    Global.RO.Error(secondResponse);
                    Global.RO.Error("Third response:");
                    Global.RO.Error(thirdResponse);
                    return;
                }

                Global.RO.Info("Test Passed Successfully!");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        #region Helper Functions

        /// <summary>
        /// At the moment, the cache time for MarketplaceCatalog is defaulted to 0.
        /// We need to give it a value to test caching, and do an iisreset to get the
        /// new value picked up.
        /// </summary>
        /// <param name="cacheDurationInSeconds">Number of seconds to store query results in XBanc.</param>
        public static void SetCacheTime(int cacheDurationInSeconds)
        {
            Global.RO.Info("Setting cache time to {0} seconds.", cacheDurationInSeconds);
            ExecuteNPDBCommand(string.Format(UPDATE_CACHE_DURATION, cacheDurationInSeconds));
        }

        /// <summary>
        /// Get the current value for the cache duration from NPDB.  For later when it's not set to 0,
        /// we can change it to a shorter duration, run our tests, and reset it later.
        /// </summary>
        /// <returns></returns>
        public static int GetCurrentCacheTime()
        {
            return ExecuteNPDBCommand(SELECT_CACHE_DURATION);
        }

        public static int ExecuteNPDBCommand(string npdbCommand)
        {
            try
            {
                SqlConnection connection = new SqlConnection(ConfigUtil.NpdbConnectionString);
                connection.Open();

                SqlDataReader reader = null;
                int returnValue = 0;

                using (SqlCommand cmd = connection.CreateCommand())
                {
                    cmd.CommandText = npdbCommand;
                    cmd.CommandType = System.Data.CommandType.Text;
                    Global.RO.Info("Executing command: {0}", cmd.CommandText);
                    reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        returnValue = (int)reader[0];
                    }
                    connection.Close();
                    return returnValue;
                }
            }
            catch (Exception e)
            {
                Global.RO.Info("ExecuteNPDBCommand threw an exception! {0}", e.Message);
                throw e;
            }

        }

        public static int ExecuteRawCatalogDBCommand(string rawCatalogCommand)
        {
            try
            {
                //There isn't a pre-existing connection string for RawCatalog that I have found.  
                //I want to use STF as much as possible, so I'm taking the FECatalog connection 
                //string from STF and replacing FE with Raw.
                string rawCatalogDBConnectionString = Config.GetSingleInterface(Interface.ContentIngestionCatalogDB).SqlConnectionString;

                SqlConnection connection = new SqlConnection(rawCatalogDBConnectionString);
                connection.Open();

                SqlDataReader reader = null;
                int returnValue = 0;

                using (SqlCommand cmd = connection.CreateCommand())
                {
                    cmd.CommandText = rawCatalogCommand;
                    cmd.CommandType = System.Data.CommandType.Text;
                    Global.RO.Info("Executing command: {0}", cmd.CommandText);
                    reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        returnValue = (int)reader[0];
                    }
                    connection.Close();
                    return returnValue;
                }
            }
            catch (Exception e)
            {
                Global.RO.Info("ExecuteRawCatalogDBCommand threw an exception! {0}", e.Message);
                throw e;
            }

        }

        public static HttpWebResponse ExecuteQuery(string query)
        {
            //build our web request
            string marketplaceCatalogUrl = query;
            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(marketplaceCatalogUrl);

            //get our response using the web request
            HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();
            return webResponse;
        }

        /// <summary>
        /// Gets the expiration time of the request.
        /// </summary>
        /// <param name="response">The response returned from the service.</param>
        /// <returns></returns>
        public static DateTime GetExpirationDateTime(HttpWebResponse response)
        {
            return Convert.ToDateTime(response.Headers["Expires"]);
        }

        public static string GetResponseData(HttpWebResponse response)
        {
            string results = string.Empty;
            using (StreamReader reader = new StreamReader(response.GetResponseStream()))
            {
                results = reader.ReadToEnd();
            }

            return results;
        }

        /// <summary>
        /// Flush the MarketplaceCatalog cache in Xbanc.
        /// </summary>
        public static void FlushCache()
        {
                try
                {
                    Global.XEnv.ExecuteXmgmtCommand(xonline.common.config.Interface.marketplacecatalog, "e :marketplacecatalog flush");
                    return;
                }
                catch (Exception e)
                {
                    Global.RO.Error("Failed to flush the cache: {0}", e.Message);
                }
            
        }

        /// <summary>
        /// Recycle the app pool to pick up new changes in NPDB.
        /// </summary>
        public static void RecycleAppPool()
        {
            try
            {
                Global.RO.Info("Recycling MarketplaceCatalog App Pool...");
                ConnectionOptions co = new ConnectionOptions();
                co.Impersonation = ImpersonationLevel.Impersonate;
                co.Authentication = AuthenticationLevel.PacketPrivacy;
                string objPath = "IISApplicationPool.Name='W3SVC/AppPools/MarketplaceCatalog-MarketplaceCatalog'";
                ManagementScope scope = new ManagementScope(@"\\" + mpCatalogMachineName.Split(':')[0] + @"\root\MicrosoftIISV2", co);
                using (ManagementObject mc = new ManagementObject(objPath))
                {
                    mc.Scope = scope;
                    mc.InvokeMethod("Recycle", null, null);
                    Global.RO.Info("Recycled!");
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Failed to recycle app pool! Error: {0}", e.Message);
            }
        }

        public static bool DateTimesAreEqual(DateTime first, DateTime second)
        {
            //As long as the two times are within 2 seconds of each other, return true.
            //I've seen the values off by only 1 second (may be a rounding issue), so give
            //a little wiggle room to be sure.
            if ((second - first) > TimeSpan.FromSeconds(-5) &&
                (second - first) < TimeSpan.FromSeconds(5))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Pauses execution of the system for the desired number of seconds.
        /// </summary>
        /// <param name="seconds">Time to sleep.</param>
        public static void Sleep(int seconds)
        {
            Thread.Sleep(seconds * 1000);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\QueryTestEnvironmentException.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryTestEnvironmentException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace xonline.server.marketplace.test
{
    #region References...

    using System;
    using System.Runtime.Serialization;

    #endregion

    /// <summary>
    /// Bind Exception
    /// </summary>
    [global::System.Serializable]
    public class QueryTestEnvironmentException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the QueryTestEnvironmentException class
        /// </summary>
        public QueryTestEnvironmentException()
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTestEnvironmentException class
        /// </summary>
        /// <param name="message">The message that describes the error</param>
        public QueryTestEnvironmentException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTestEnvironmentException class
        /// </summary>
        /// <param name="message">The message that describes the error</param>
        /// <param name="innerException">The exception that is the cause of the current exception</param>
        public QueryTestEnvironmentException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        /// <summary>
        /// Initializes a new instance of the QueryTestEnvironmentException class
        /// </summary>
        /// <param name="info">The System.Runtime.SerializationInfo that holds the serialized object data about the exception being thrown</param>
        /// <param name="context">The System.Runtime.StreamingContext that contains contextual information about the source or desitnation</param>
        protected QueryTestEnvironmentException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\setting.cs ===
//------------------------------------------------------------------------------
// <copyright file="Setting.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace xonline.server.marketplace.test
{

    using System;
    using System.Collections.Generic;
    using System.Xml.Serialization;

    /// <summary>
    /// Settings class
    /// </summary>
    [Serializable]
    public class Settings
    {
        [XmlElement(ElementName = "Setting")]
        public List<Setting> settings { get; set;}

        /// <summary>
        /// Settings class constructor
        /// </summary>
        public Settings()
        {
            settings = new List<Setting>();
        }
    }

    /// <summary>
    /// Setting class
    /// </summary>
    [Serializable]
    public class Setting
    {
        public string SettingName { get; set; }
        public string Value { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\TestCase.cs ===
//------------------------------------------------------------------------------
// <copyright file="TestCase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

#region References...

using System;
using System.Net;
using System.Xml.Serialization;

#endregion

namespace xonline.server.marketplace.test
{
    /// <summary>
    /// Serialized class used to define the test case
    /// </summary>
    [Serializable]
    public class TestCase
    {
        /// <summary>
        /// Initializes a new instance of the TestCase class
        /// </summary>
        public TestCase()
        {
            // Initialize
            this.Name = String.Empty;
            this.Description = String.Empty;
            this.QueryString = String.Empty;
            this.ExpectedResultsXPathFilter = String.Empty;
            this.ExpectedResults = String.Empty;
            this.WebResponseStatusCode = 200; // OK
            this.Multisettings = new Multisettings();
            this.Settings = new Settings();
            this.IgnoreXpath = String.Empty;

            // Set defaults
            this.Priority = 1;
            this.AddGzipRequestHeader = false;
            this.Owner = "wirosas";
            this.Frequency = "Daily";
            this.Requirement = "Catalog";   
        }

        #region Properties...

        /// <summary>
        /// Gets or sets the test case name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the test case description
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets the test case query command
        /// </summary>
        public string QueryString { get; set; }

        /// <summary>
        /// Gets or sets the xpath to ignore when diffing.
        /// </summary>
        public string IgnoreXpath { get; set; }

        /// <summary>
        /// Gets or sets the test case priority
        /// </summary>
        /// <remarks>Default is 1</remarks>
        public int Priority { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to add the request header for 'gzip' compression
        /// </summary>
        public bool AddGzipRequestHeader { get; set; }

        /// <summary>
        /// Gets or sets the test case query results filter xpath
        /// </summary>
        public string ExpectedResultsXPathFilter { get; set; }

        /// <summary>
        /// Gets or sets the test case query results
        /// </summary>
        public string ExpectedResults { get; set; }

        /// <summary>
        /// Gets or sets the test case expected http response code
        /// </summary>
        /// <remarks>Default is 200(OK)</remarks>
        public int WebResponseStatusCode { get; set; }

        /// <summary>
        /// Gets or sets the test case meta attribute owner
        /// </summary>
        /// <remarks>Default is 'MP-Costco'</remarks>
        [XmlIgnore]
        public string Owner { get; set; }

        /// <summary>
        /// Gets or sets the test case meta attribute frequency
        /// </summary>
        /// <remarks>Default is 'Daily'</remarks>
        [XmlIgnore]
        public string Frequency { get; set; }

        /// <summary>
        /// Gets or sets the test case meta attribute requirement
        /// </summary>
        /// <remarks>Default is 'Xblob, Catalog'</remarks>
        [XmlIgnore]
        public string Requirement { get; set; }

        /// <summary>
        /// Gets or sets the Multisettings to be added to the environment for the test case
        /// </summary>
        public Multisettings Multisettings { get; set; }

        /// <summary>
        /// Gets or sets the Settings to be added to the environment for the test case
        /// </summary>
        public Settings  Settings { get; set; }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\TestGroup.cs ===
//------------------------------------------------------------------------------
// <copyright file="TestGroup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace xonline.server.marketplace.test
{
    #region References...

    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Xml.Serialization;
    using ServerTestFramework;

    #endregion

    /// <summary>
    /// Group of common tests
    /// </summary>
    [Serializable]
    public class TestGroup
    {
        #region Constructor...

        /// <summary>
        /// Initializes a new instance of the TestGroup class
        /// </summary>
        public TestGroup()
        {
            // Initialize
            this.Name = String.Empty;
            this.Description = String.Empty;
            this.TestCases = new Collection<TestCase>();
        }

        #endregion

        #region Properties...

        /// <summary>
        /// Gets or sets the test group name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the test group description
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Gets or sets the collection of test cases
        /// </summary>
        [XmlElement(ElementName = "TestCase")]
        public Collection<TestCase> TestCases { get; set; }

        /// <summary>
        /// Gets the collection of test tree nodes
        /// </summary>
        [XmlIgnore]
        public Collection<TestNode> TestNodes
        {
            get
            {
                // Convert each test case into a test node
                Collection<TestNode> testNodes = new Collection<TestNode>();
                foreach (TestCase currentTestCase in this.TestCases)
                {
                    MarketplaceFrontDoorTest node = new MarketplaceFrontDoorTest(currentTestCase.Name);
                    node.TaggingData.AddTagValue("Priority", currentTestCase.Priority.ToString());
                    node.TaggingData.AddTagValue("Owner", currentTestCase.Owner);
                    node.TaggingData.AddTagValue("Requirement", currentTestCase.Requirement);
                    node.TaggingData.AddTagValue("Frequency", currentTestCase.Frequency);
                    node.Desc = currentTestCase.Description;
                    testNodes.Add(node);
                }

                return testNodes;
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\MarketplaceCatalog\test\MarketplaceCatalogTests.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarketplaceCatalogTests.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

[assembly: ServerTestFramework.RootNode(typeof(xonline.server.marketplace.test.MarketplaceCatalogTests))]

namespace xonline.server.marketplace.test
{
    #region References...

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.IO.Compression;
    using System.Linq;
    using System.Management;
    using System.Net;
    using System.Reflection;
    using System.Threading;
    using System.Xml;
    using System.Xml.Serialization;
    using Microsoft.XmlDiffPatch;
    using ServerTestFramework;
    using ServerTestFramework.LiveService;

    #endregion

    /// <summary>
    ///  Test cases for the Marketplace Catalog
    /// </summary>
    public class MarketplaceCatalogTests : TestNode
    {
        #region Constants...

        /// <summary>
        /// Interface for marketplace catalog
        /// </summary>
        private const string MarketCatalogInterface = "marketplacecatalog";

        #endregion

        #region Fields

        /// <summary>
        /// Keep session data on reloading test suite
        /// </summary>
        private static bool persistSessionData;

        /// <summary>
        /// Local path to the test cases
        /// </summary>
        private static string testcasesPath;

        /// <summary>
        /// Catalog IP address
        /// </summary>
        private static string catalogIPAddress;

        /// <summary>
        /// Lookup table for test cases by name
        /// </summary>
        private static Dictionary<string, TestCase> TestCases;

        /// <summary>
        /// Lookup table of valid response headers and values
        /// </summary>
        private static Dictionary<HttpResponseHeader, string> ValidHeaders;

        #endregion

        #region Constructor...

        /// <summary>
        /// Initializes a new instance of the MarketplaceCatalogTests class
        /// </summary>
        public MarketplaceCatalogTests()
        {            
            // Initialize test groups
            TestCases = new Dictionary<string, TestCase>();
            this.TestGroups = new Dictionary<string, TestGroup>();
            TestGroup genericGroup = new TestGroup()
            {
                Description = "General Tests"
            };
            this.TestGroups.Add(String.Empty, genericGroup);

            this.LoadTestCases();

            // Build the test node tree
            List<TestNode> testNodes = new List<TestNode>();
            foreach (TestGroup currentGroup in this.TestGroups.Values)
            {
                testNodes.Add(new TestNode(currentGroup.Description, currentGroup.TestNodes, true, false));
            }

            TestNode testNode = new TestNode("Marketplace Query Tests", testNodes, true, false);
            this.AddChild(testNode);
        }

        #endregion

        #region Properties...

        /// <summary>
        /// Gets the IPEndpoint for the Environment
        /// </summary>
        private static IPEndPoint EnvironmentIPEndPoint
        {
            get { return Global.XEnv.GetInterface(MarketCatalogInterface)[0]; }
        }

        /// <summary>
        /// Gets or sets the table containing the test groups
        /// </summary>
        private Dictionary<string, TestGroup> TestGroups { get; set; }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Recycle the app pool to pick up new changes in NPDB.
        /// </summary>
        public static void RecycleMarketplaceCatalogAppPool()
        {
            try
            {
                Global.RO.Info("Recycling the MarketplaceCatalog app pool...");
                string marketplaceCatalogMachineName = Global.XEnv.GetVirtualInterface("marketplacecatalog").ToString();

                ConnectionOptions co = new ConnectionOptions();
                co.Impersonation = ImpersonationLevel.Impersonate;
                co.Authentication = AuthenticationLevel.PacketPrivacy;
                string objPath = "IISApplicationPool.Name='W3SVC/AppPools/MarketplaceCatalog-MarketplaceCatalog'";
                ManagementScope scope = new ManagementScope(@"\\" + marketplaceCatalogMachineName.Split(':')[0] + @"\root\MicrosoftIISV2", co);
                using (ManagementObject mc = new ManagementObject(objPath))
                {
                    mc.Scope = scope;
                    mc.InvokeMethod("Recycle", null, null);
                    Global.RO.Info("Sucessfully recycled the app pool!");
                }

                Global.RO.Info("Sleeping for 15 seconds after recycling the app pool...");
                Thread.Sleep(TimeSpan.FromSeconds(15));
            }
            catch (Exception e)
            {
                Global.RO.Error("Failed to recycle app pool! Error: {0}", e.Message);
            }
        }

        /// <summary>
        /// Adds the specified settings and corresponding values to the environment
        /// </summary>
        /// <param name="settings">A List object containing Setting objects</param>
        /// <param name="forceAppPoolRecycle">Boolean value indicated whether or not the MarketplaceCatalog config cache should be forced to reload</param>
        private static List<SettingState> AddSettings(List<Setting> settings, bool forceAppPoolRecycle)
        {
            List<SettingState> previousSettings = new List<SettingState>();
            foreach (Setting setting in settings)
            {
                Global.RO.Info("Adding setting: {0}={1}", setting.SettingName, setting.Value);
                SettingState previousSettingState = Global.XEnv.OverrideSetting("MarketplaceCatalog", "ALL", setting.SettingName, setting.Value);
                previousSettings.Add(previousSettingState);
            }

            if (forceAppPoolRecycle)
            {
                // Recycle the MarketplaceCatalog app pool to force the latest NPDB settings to be used
                RecycleMarketplaceCatalogAppPool();
            }

            return previousSettings;
        }

        /// <summary>
        /// Restores the settings based on SettingState object
        /// </summary>
        /// <param name="settingStates">Setting state to restore</param>
        /// <param name="forceAppPoolRecycle">Boolean value indicated whether or not the MarketplaceCatalog config cache should be forced to reload</param>
        private static void RestoreSettings(List<SettingState> settingStates, bool forceAppPoolRecycle)
        {
            foreach (SettingState settingState in settingStates)
            {
                Global.RO.Info("Restore setting: {0}", settingState.Setting);
                Global.XEnv.RestoreOverrideSettingState(settingState); 
            }

            if (forceAppPoolRecycle)
            {
                // Recycle the MarketplaceCatalog app pool to force the latest NPDB settings to be used
                RecycleMarketplaceCatalogAppPool();
            }
        }

        /// <summary>
        /// Adds the specified multisettings and corresponding values to the environment
        /// </summary>
        /// <param name="multisettings">A List object containing Multisetting objects</param>
        /// <param name="forceAppPoolRecycle">Boolean value indicated whether or not the MarketplaceCatalog config cache should be forced to reload</param>
        private static void AddMultisettings(List<Multisetting> multisettings, bool forceAppPoolRecycle)
        {
            foreach (Multisetting multisetting in multisettings)
            {
                Global.RO.Info("Adding multisetting: {0}={1}", multisetting.Setting, multisetting.Value);
                Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), "ALL", "1", "ALL", multisetting.Setting, multisetting.Value);
            }

            if (forceAppPoolRecycle)
            {
                // Recycle the MarketplaceCatalog app pool to force the latest NPDB settings to be used
                RecycleMarketplaceCatalogAppPool();
            }
        }

        /// <summary>
        /// Removes the specified multisettings with the corresponding values from the environment
        /// </summary>
        /// <param name="multisettings">A List object containing Multisetting objects</param>
        /// <param name="forceAppPoolRecycle">Boolean value indicated whether or not the MarketplaceCatalog config cache should be forced to reload</param>
        private static void DeleteMultisettings(List<Multisetting> multisettings, bool forceAppPoolRecycle)
        {
            foreach (Multisetting multisetting in multisettings)
            {
                Global.RO.Info("Deleting multisetting: {0}={1}", multisetting.Setting, multisetting.Value);
                Global.XEnv.MultiSettingDeleteValue(Global.XEnv.GetEnv(), "ALL", "1", "ALL", multisetting.Setting, multisetting.Value);
            }

            if (forceAppPoolRecycle)
            {
                // Recycle the MarketplaceCatalog app pool to force the latest NPDB settings to be used
                RecycleMarketplaceCatalogAppPool();
            }
        }

        /// <summary>
        /// Execute the test case
        /// </summary>
        /// <param name="name">Test case name</param>
        /// <returns>Pass if test is successful</returns>
        public static TEST_RESULTS ExecuteTestCase(string name)
        {
            List<SettingState> previousSettings = new List<SettingState>();
            // Get the specific test case data
            TestCase executingTest = TestCases[name];

            // Display test description
            DisplayTestDescription(executingTest.Description);

            bool multisettingsPresent = executingTest.Multisettings.multisettings.Count > 0;
            bool settingsPresent = executingTest.Settings.settings.Count > 0;

            try
            {
                // Flush cache
                FlushCache(false);

                // Environment pre-checks
                ValidateQueryEnvironment();

                // Add settings specified by the test to the environment                 
                if (settingsPresent)
                {
                    // Only recycle the app pool if no multisettings are present, to avoid having to do it twice in a row
                    previousSettings = AddSettings(executingTest.Settings.settings, multisettingsPresent ? false : true);
                }

                // Add multisettings specified by the test to the environment 
                if (multisettingsPresent)
                {
                    AddMultisettings(executingTest.Multisettings.multisettings, true);
                }               

                Global.RO.Info("Executing: {0}",executingTest.QueryString);
                Uri testQuery = new Uri(executingTest.QueryString);
                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(testQuery);
                HttpWebResponse webResponse = null;
                string returnedResults = String.Empty;

                if (executingTest.AddGzipRequestHeader)
                {
                    webRequest.Headers.Add(HttpRequestHeader.AcceptEncoding, "gzip");
                    webResponse = (HttpWebResponse)webRequest.GetResponse();
                    using (StreamReader reader = new StreamReader(new GZipStream(webResponse.GetResponseStream(), CompressionMode.Decompress)))
                    {
                        returnedResults = reader.ReadToEnd();
                    }
                }
                else
                {
                    webResponse = (HttpWebResponse)webRequest.GetResponse();
                    using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
                    {
                        returnedResults = reader.ReadToEnd();
                    }
                }

                // Validate response headers
                bool allHeadersValid = ValidateResponseHeaders(webResponse.Headers, executingTest.AddGzipRequestHeader);
                if (!allHeadersValid)
                {
                    return TEST_RESULTS.FAILED;
                }

                // Validate the response results against what was expected
                TEST_RESULTS testcaseResult = TEST_RESULTS.NOT_EXECUTED;
                if ((HttpStatusCode)executingTest.WebResponseStatusCode == HttpStatusCode.OK)
                {
                    // If test case has a xpath filter, apply it
                    if (!String.IsNullOrEmpty(executingTest.ExpectedResultsXPathFilter))
                    {
                        FilterXmlResults(ref returnedResults, executingTest.ExpectedResultsXPathFilter);
                    }

                    testcaseResult = CompareXml(executingTest.ExpectedResults, returnedResults, executingTest.IgnoreXpath) ? TEST_RESULTS.PASSED : TEST_RESULTS.FAILED;
                }
                else
                {
                    Global.RO.Error("Web Response Status code expected an exception to be thrown but a http response was returned");
                    testcaseResult = TEST_RESULTS.FAILED;
                }

                if (testcaseResult != TEST_RESULTS.PASSED)
                {
                    string output = testcasesPath + @"\Output";
                    string expected = testcasesPath + @"\Output\ExpectedResults";
                    string returned = testcasesPath + @"\Output\ReturnedResults";

                    // If directory exists, this is a NOP
                    Directory.CreateDirectory(output);
                    Directory.CreateDirectory(expected);
                    Directory.CreateDirectory(returned);

                    // Output the expected and returned results for debugging of failures
                    string expectedFileName = String.Format(@"{0}\{1}.txt", expected, name);
                    using (StreamWriter writer = new StreamWriter(expectedFileName))
                    {
                        writer.Write(executingTest.ExpectedResults);
                        writer.Flush();
                    }

                    string returnedFileName = String.Format(@"{0}\{1}.txt", returned, name);
                    using (XmlTextWriter xmlWriter = new XmlTextWriter(returnedFileName, System.Text.Encoding.UTF8))
                    {
                        xmlWriter.Formatting = Formatting.Indented;
                        XmlDocument document = new XmlDocument();

                        try
                        {
                            document.LoadXml(returnedResults);
                            document.WriteTo(xmlWriter);
                        }
                        catch
                        {
                            using (StreamWriter writer = new StreamWriter(returnedFileName))
                            {
                                writer.Write(returnedResults);
                                writer.Flush();
                            }
                        }
                    }
                }

                return testcaseResult;
            }
            catch (WebException webEx)
            {
                if ((HttpStatusCode)executingTest.WebResponseStatusCode == ((HttpWebResponse)webEx.Response).StatusCode)
                {
                    return TEST_RESULTS.PASSED;
                }

                throw;
            }
            finally
            {
                if (previousSettings.Count > 0)
                {
                    RestoreSettings(previousSettings, multisettingsPresent ? false : true);
                }

                //Remove any multisettings from the environment that were added by the test
                if (multisettingsPresent)
                {
                    DeleteMultisettings(executingTest.Multisettings.multisettings, true);
                }
            }
        }

        /// <summary>
        /// Display the test description in formatted box
        /// </summary>
        /// <param name="testDescription">Test case description</param>
        private static void DisplayTestDescription(string testDescription)
        {
            Global.RO.Info("= Test Description ".PadRight(125, '='));
            if (!String.IsNullOrEmpty(testDescription))
            {
                // Display on 1 or 2 lines?
                if (testDescription.Length <= 123)
                {
                    Global.RO.Info("= {0}", testDescription);
                }
                else
                {
                    int spaceIndex = testDescription.Substring(0, 123).LastIndexOf(' ');
                    Global.RO.Info("= {0}", testDescription.Substring(0, spaceIndex));
                    Global.RO.Info("= {0}", testDescription.Substring(spaceIndex + 1));
                }
            }
            else
            {
                Global.RO.Warn("= {0}", "No test case description defined");
            }

            Global.RO.Info(String.Empty.PadLeft(125, '='));
        }

        /// <summary>
        /// Validate the response headers are correct
        /// </summary>
        /// <param name="responseHeaders">Web Response headers</param>
        /// <param name="checkGzipHeader">True to check for content encoding gzip in the headers</param>
        /// <returns>True if headers are correct</returns>
        private static bool ValidateResponseHeaders(WebHeaderCollection responseHeaders, bool checkGzipHeader)
        {
            // Headers found to validate?
            if (!responseHeaders.HasKeys())
            {
                Global.RO.Error("No response headers found.");
                return false;
            }

            // Initialize
            bool allHeadersValid = true;
            Dictionary<HttpResponseHeader, string> checkHeaders = new Dictionary<HttpResponseHeader, string>(ValidHeaders);
            if (checkGzipHeader)
            {
                checkHeaders.Add(HttpResponseHeader.ContentEncoding, "gzip");
            }

            // Compare the expected headers vs the actual
            for (int headerIndex = 0; headerIndex < responseHeaders.Count; headerIndex++)
            {
                string cleanedHeader = responseHeaders.GetKey(headerIndex).Replace("-", String.Empty);
                try
                {
                    // Get actual header key/values
                    HttpResponseHeader currentHeaderKey = (HttpResponseHeader)Enum.Parse(typeof(HttpResponseHeader), cleanedHeader, true);
                    string currentHeaderValue = responseHeaders.Get(headerIndex);

                    // Header expected?
                    if (!checkHeaders.ContainsKey(currentHeaderKey))
                    {
                        Global.RO.Error("Unexpected header found: {0}", currentHeaderKey);
                        allHeadersValid = false;
                        continue;
                    }

                    // Remove matching headers
                    string expectedValue = checkHeaders[currentHeaderKey];
                    checkHeaders.Remove(currentHeaderKey);

                    // Skip if no expected value to validate
                    if (String.IsNullOrEmpty(expectedValue))
                    {
                        continue;
                    }

                    // Ending value will vary if ends with '='
                    if (expectedValue.EndsWith("="))
                    {
                        currentHeaderValue = currentHeaderValue.Substring(0, currentHeaderValue.LastIndexOf("=") + 1);
                    }

                    // Compare values
                    if (!currentHeaderValue.Equals(expectedValue, StringComparison.OrdinalIgnoreCase))
                    {
                        Global.RO.Error("Header [{0}] contains unexpected value - Expected:'{1}' ; Actual:'{2}'", currentHeaderKey, expectedValue, currentHeaderValue);
                        allHeadersValid = false;
                        continue;
                    }
                }
                catch (ArgumentException)
                {
                    Global.RO.Error("Unable to parse header {0}", cleanedHeader);
                }
            }

            // Validate all expected headers found
            foreach (KeyValuePair<HttpResponseHeader, string> currentPair in checkHeaders)
            {
                Global.RO.Error("Expected Header not found: {0}:{1}", currentPair.Key, currentPair.Value);
                allHeadersValid = false;
            }

            // All headers correct?
            if (allHeadersValid)
            {
                Global.RO.Success("Request Headers are correct.");
            }

            return allHeadersValid;
        }

        /// <summary>
        /// Load all the test cases
        /// </summary>
        private void LoadTestCases()
        {
            Assembly currentAssembly = Assembly.GetExecutingAssembly();

            testcasesPath = currentAssembly.Location;
            testcasesPath = testcasesPath.Substring(0, testcasesPath.LastIndexOf('\\'));
            testcasesPath = Path.Combine(testcasesPath, "MarketplaceCatalogTestCases");

            catalogIPAddress = String.Format("{0}:{1}", EnvironmentIPEndPoint.Address.ToString(), EnvironmentIPEndPoint.Port.ToString());

            // Only on first loading - clear output directory
            if (!persistSessionData)
            {
                string output = Path.Combine(testcasesPath, "Output");
                if (Directory.Exists(output))
                {
                    Directory.Delete(output, true);
                }

                persistSessionData = true;
            }

            // Initialize valid headers
            ValidHeaders = new Dictionary<HttpResponseHeader, string>();
            ValidHeaders.Add(HttpResponseHeader.Vary, "Accept-Encoding");
            ValidHeaders.Add(HttpResponseHeader.ContentLength, String.Empty);
            ValidHeaders.Add(HttpResponseHeader.CacheControl, "public, must-revalidate, max-age=");
            ValidHeaders.Add(HttpResponseHeader.ContentType, "application/atom+xml; charset=UTF-8");
            ValidHeaders.Add(HttpResponseHeader.Date, String.Empty);
            ValidHeaders.Add(HttpResponseHeader.Expires, String.Empty);
            ValidHeaders.Add(HttpResponseHeader.Server, String.Empty);

            // Loop through all potential test cases
            string[] embeddedResources = currentAssembly.GetManifestResourceNames();
            foreach (string currentResource in embeddedResources)
            {
                if (!currentResource.EndsWith(".xml"))
                {
                    continue;
                }

                // Deserialize the XML
                XmlSerializer serializer = new XmlSerializer(typeof(TestGroup));
                TestGroup currentTestGroup = null;
                try
                {
                    using (Stream xmlStream = currentAssembly.GetManifestResourceStream(currentResource))
                    {
                        currentTestGroup = (TestGroup)serializer.Deserialize(xmlStream);
                    }
                }
                catch (InvalidOperationException)
                {
                    Global.RO.Warn("File deserialization error - SKIPPING: {0}", currentResource);
                    continue;
                }

                if (currentTestGroup.TestCases.Count < 1)
                {
                    continue;
                }

                // Add test group
                if (String.IsNullOrEmpty(currentTestGroup.Name))
                {
                     Global.RO.Warn("File does not have test group name defined; {0}", currentResource);
                }

                // Make sure group name is unique - unless generic test cases
                if (!this.TestGroups.ContainsKey(currentTestGroup.Name))
                {
                    this.TestGroups.Add(currentTestGroup.Name, currentTestGroup);
                }
                else if (!String.IsNullOrEmpty(currentTestGroup.Name))
                {
                    Global.RO.Warn("Test group: {0} has duplicated name", currentTestGroup.Name);
                } 

                // Add all test cases to the test case table
                foreach (TestCase currentTestCase in currentTestGroup.TestCases)
                {
                    // Verify that each test case has a unique name
                    if (TestCases.ContainsKey(currentTestCase.Name))
                    {
                        Global.RO.Warn("Test case name is used multiple times: " + currentTestCase.Name);
                        Global.RO.Warn("Only the first case will be used!");
                        continue;
                    }

                    // Update query string with IP
                    currentTestCase.QueryString = String.Format(currentTestCase.QueryString, catalogIPAddress);

                    // Clear CData
                    currentTestCase.ExpectedResults = currentTestCase.ExpectedResults.Replace("<![CDATA[", String.Empty);
                    currentTestCase.ExpectedResults = currentTestCase.ExpectedResults.Replace("]]>", String.Empty);

                    // Add test case - lookup table
                    TestCases.Add(currentTestCase.Name, currentTestCase);

                    // Add test case - generic group
                    if (String.IsNullOrEmpty(currentTestGroup.Name))
                    {
                        this.TestGroups[String.Empty].TestCases.Add(currentTestCase);
                    }
                }
            }
        }

        /// <summary>
        /// Flush the cache for the queue
        /// </summary>
        /// <param name="isRetry">False if first call attempt</param>
        private static void FlushCache(bool isRetry)
        {
            Global.RO.Info("Flushing Cache...");

            // Initialize
            string flushOutput = String.Empty;

            // Execute flush
            bool flushResults = ManagementConsole.Execute(EnvironmentIPEndPoint, String.Format("e :{0} flush productv1", MarketCatalogInterface), out flushOutput);
            Global.RO.Info(flushOutput);

            // Process the epic fail
            if (!flushResults)
            {
                if (isRetry)
                {
                    throw new QueryTestEnvironmentException("Unable to flush results cache");
                }

                ResetMarketplaceHealthCheck();
                FlushCache(true);
            }
        }

        /// <summary>
        /// Reset the marketplace health check
        /// </summary>
        private static void ResetMarketplaceHealthCheck()
        {
            Global.RO.Info("Resetting Marketplace health check...");

            // Initialize
            string healthCheckQuery = String.Format("http://{0}:11230/{1}/health.ashx", EnvironmentIPEndPoint.Address.ToString(), MarketCatalogInterface);

            // Validate response
            if (ExecuteQuery(healthCheckQuery) != HttpStatusCode.OK)
            {
                throw new QueryTestEnvironmentException("Health check reset fail.");
            }
        }

        /// <summary>
        /// Execute a query
        /// </summary>
        /// <param name="query">Query to execute</param>
        /// <returns>Status code</returns>
        private static HttpStatusCode ExecuteQuery(string query)
        {
            // Initialize
            string results = String.Empty;
            return ExecuteQuery(query, out results);
        }

        /// <summary>
        /// Execute a query
        /// </summary>
        /// <param name="query">Query to execute</param>
        /// <param name="results">Results of query</param>
        /// <returns>Status code</returns>
        private static HttpStatusCode ExecuteQuery(string query, out string results)
        {
            // Initialize
            results = String.Empty;
            Uri executeUri = new Uri(query);

            // Send query
            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(executeUri);
            HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();
            using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
            {
                results = reader.ReadToEnd();
            }

            return webResponse.StatusCode;
        }

        /// <summary>
        /// Validate the environment to execute a query is functional
        /// </summary>
        private static void ValidateQueryEnvironment()
        {
            // Intialize
            const string BogusGuid = "00000000-0000-1111-1111-123456654321";
            const string FormatQuery = "http://{0}/MarketplaceCatalog/v1/product/en-us?tiers=3&products={1}";

            // Build query
            string validateQuery = String.Format(FormatQuery, catalogIPAddress, BogusGuid);

            try
            {
                // Initialize
                XmlDocument resultsXml = new XmlDocument();

                // Send valid query
                Global.RO.Info("Environment Validation Query: " + validateQuery);
                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(validateQuery);
                HttpWebResponse webResponse = (HttpWebResponse)webRequest.GetResponse();
                using (StreamReader reader = new StreamReader(webResponse.GetResponseStream()))
                {
                    resultsXml.Load(reader);
                }

                // Verify results
                int itemCount = Int32.Parse(resultsXml["a:feed"]["totalItems"].InnerText);
                if (itemCount != 0)
                {
                    throw new QueryTestEnvironmentException("Query test environment validation failed; Validation Item count != 0");
                }

                Global.RO.Info("Query environment is ready.");
            }
            catch (WebException wex)
            {
                throw new QueryTestEnvironmentException("Query test environment validation failed; Server error: " + wex.Status.ToString());
            }
            catch (ArgumentNullException)
            {
                throw new QueryTestEnvironmentException("Query test environment validation failed; Validation Response [totalItems] not found");
            }
        }

        /// <summary>
        /// Compares the expected Xml and the actual Xml
        /// </summary>
        /// <param name="expectedResults">Expected Xml results</param>
        /// <param name="returnedResults">Actual Xml results</param>
        /// <returns></returns>
        public static bool CompareXml(string expectedResults, string returnedResults)
        {
            return CompareXml(expectedResults, returnedResults, null);
        }

        /// <summary>
        /// Compares the expected Xml and the actual Xml
        /// </summary>
        /// <param name="expectedResults">Expected Xml results</param>
        /// <param name="returnedResults">Actual Xml results</param>
        /// <param name="ignoreXpath">Xpath to ignore during the comparison</param>
        /// <returns>True if equal</returns>
        public static bool CompareXml(string expectedResults, string returnedResults, string ignoreXpath)
        {
            // Load xml into documents to work with XmlDiffReport
            XmlDocument expectedDocument = new XmlDocument();
            XmlDocument returnedDocument = new XmlDocument();
            expectedDocument.LoadXml(expectedResults);
            returnedDocument.LoadXml(returnedResults);

            XmlDiffReport xmlDiffReport = new XmlDiffReport();
            xmlDiffReport.IgnoreXPath(".//feed/updated");
            xmlDiffReport.IgnoreXPath(".//feed/entry/updated");
            xmlDiffReport.IgnoreXPath(".//feed/entry/categories");
            xmlDiffReport.IgnoreXPath(".//feed/categories");

            if (!string.IsNullOrEmpty(ignoreXpath))
            {
                string[] toIgnore = ignoreXpath.Split('|');
                foreach (string ignore in toIgnore)
                {
                    xmlDiffReport.IgnoreXPath(ignore);
                }
            }

            //Categories have a bad habit of coming back in different orders.
            //We tell XmlDiffReport to ignore the categories field and do a comparison ourselves.
            XmlNodeList expectedCategories = expectedDocument.GetElementsByTagName("categoryId");
            XmlNodeList actualCategories = returnedDocument.GetElementsByTagName("categoryId");

            if (expectedCategories.Count != actualCategories.Count)
            {
                Global.RO.Error("Expected {0} categories, but actually got {1} categories!", expectedCategories.Count, actualCategories.Count);
                return false;
            }

            if (expectedCategories.Count != 0 && actualCategories.Count != 0)
            {
                Global.RO.Info("Comparing categories...");

                for (int i = 0; i < expectedCategories.Count; ++i)
                {
                    bool found = false;

                    for (int k = 0; k < actualCategories.Count; ++k)
                    {
                        if (expectedCategories[i].InnerText == actualCategories[k].InnerText)
                        {
                            found = true;
                            break;
                        }
                    }

                    if (!found)
                    {
                        Global.RO.Error("Categories not the same!");
                        Global.RO.Error("Expected Categories:");
                        foreach (XmlNode category in expectedCategories)
                        {
                            Global.RO.Error("{0}", category.InnerText);
                        }
                        Global.RO.Error("Actual Categories:");
                        foreach (XmlNode category in actualCategories)
                        {
                            Global.RO.Error("{0}", category.InnerText);
                        }
                        return false;
                    }
                }
            }

            Global.RO.Info("Comparing xml documents...");

            xmlDiffReport.Compare(expectedDocument.DocumentElement, returnedDocument.DocumentElement);

            // If no differences then the check passes
            if (xmlDiffReport.Details.Count == 0)
            {
                return true;
            }

            // Output the differences if there were any
            foreach (XmlDiffDetail xmlDiffDetail in xmlDiffReport.Details)
            {
                Global.RO.Error("XmlDiffDetail:");
                Global.RO.Error("  Difference: " + xmlDiffDetail.Difference);

                if (null != xmlDiffDetail.Source)
                {
                    Global.RO.Error("  Source:");
                    Global.RO.Error("    XPath: " + xmlDiffDetail.Source.XPath);
                    Global.RO.Error("    XPathLocation: " + xmlDiffDetail.Source.XPathLocation);
                    Global.RO.Error("    Value: " + xmlDiffDetail.Source.Value);
                }

                if (null != xmlDiffDetail.Destination)
                {
                    Global.RO.Error("  Destination:");
                    Global.RO.Error("    XPath: " + xmlDiffDetail.Destination.XPath);
                    Global.RO.Error("    XPathLocation: " + xmlDiffDetail.Destination.XPathLocation);
                    Global.RO.Error("    Value: " + xmlDiffDetail.Destination.Value);
                }
            }

            return false;
        }

        /// <summary>
        /// Filter the query results with the xpath. 
        /// Adding the node paths into a union xpath will return just the data to confirm the test is working.
        /// Adding the names of the XmlNode to the list will only pull in the XmlElement name and not the contents, reducing the data volume.
        /// </summary>
        /// <param name="returnedResults">Full set of results to be filtered</param>
        /// <param name="xpathFilter">XPath to filter results from</param>
        public static void FilterXmlResults(ref string returnedResults, string xpathFilter)
        {
            // Unfiltered results
            XmlDocument unfilteredXmlDoc = new XmlDocument();
            unfilteredXmlDoc.LoadXml(returnedResults);

            // Create base results
            XmlDocument filteredXmlDoc = new XmlDocument();
            const string BaseXml = "<a:feed xmlns:a=\"http://www.w3.org/2005/Atom\" xmlns=\"http://marketplace.xboxlive.com/resource/product/v1\"></a:feed>";
            filteredXmlDoc.LoadXml(BaseXml);
            XmlDeclaration xdecl = filteredXmlDoc.CreateXmlDeclaration("1.0", null, null);
            XmlElement root = filteredXmlDoc.DocumentElement;
            filteredXmlDoc.InsertBefore(xdecl, root);

            // Setup namespace manager
            XmlNamespaceManager manager = new XmlNamespaceManager(unfilteredXmlDoc.NameTable);
            manager.AddNamespace("a", "http://www.w3.org/2005/Atom");
            manager.AddNamespace("def", "http://marketplace.xboxlive.com/resource/product/v1");

            // Add XmlNode names to this list to specify which nodes should only have the shell copied and not the contents
            List<string> namesUsingShallowCopy = new List<string>();
            namesUsingShallowCopy.Add("a:entry");
            namesUsingShallowCopy.Add("offerInstance");
            namesUsingShallowCopy.Add("offerInstances");
            Stack<XmlNode> parentStack = new Stack<XmlNode>();

            // Query actual results using xpath
            XmlNodeList nodes = unfilteredXmlDoc.SelectNodes(xpathFilter, manager);
            XmlNode currentParent = filteredXmlDoc.DocumentElement;
            parentStack.Push(filteredXmlDoc.DocumentElement);
            foreach (XmlNode currentChild in nodes)
            {
                bool useDeepCopy = !namesUsingShallowCopy.Contains(currentChild.Name);
                XmlNode childNode = filteredXmlDoc.ImportNode(currentChild, useDeepCopy);
                XmlNode parentNode = parentStack.Peek();
                if (useDeepCopy)
                {
                    parentNode.AppendChild(childNode);
                    continue;
                }

                while (parentStack.Contains(childNode, new XmlNodeNameComparer()))
                {
                    parentStack.Pop();
                }

                parentNode = parentStack.Peek();
                parentStack.Push(childNode);
                parentNode.AppendChild(childNode);
            }

            // Reset results to filtered xml
            returnedResults = filteredXmlDoc.OuterXml;
        }

        #endregion
    }

    /// <summary>
    /// XmlNode comparison object using Name equality
    /// </summary>
    public class XmlNodeNameComparer : IEqualityComparer<XmlNode>
    {
        /// <summary>
        /// Compare if both the XmlNodes have the same name
        /// </summary>
        /// <param name="leftNode">Left comparison XmlNode</param>
        /// <param name="rightNode">Right comparison XmlNode</param>
        /// <returns>True if the names are the same</returns>
        public bool Equals(XmlNode leftNode, XmlNode rightNode)
        {
            return leftNode.Name == rightNode.Name;
        }

        /// <summary>
        /// Get the has code for the XmlNode object
        /// </summary>
        /// <param name="node">Comparison XmlNode</param>
        /// <returns>Hash code value</returns>
        public int GetHashCode(XmlNode node)
        {
            return node.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\AssemblyInfo.cs ===
[assembly: System.Reflection.AssemblyTitle("Xbox Live Matchmaking Front Door")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\deadxbox.cs ===
//
// DeadXbox.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 3/21/2005, pnewson
//

using System;
using System.Collections;
using System.IO;
using System.Web;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.match.fd
{

// --------------------------------------------------------------------------
// DeadXbox class - handles dead Xbox requests
// --------------------------------------------------------------------------
public class DeadXbox : IHttpHandler
{
    // ----------------------------------------------------------------------
    // ProcessRequest - entry point for HTTP request
    // ----------------------------------------------------------------------
    public void ProcessRequest(HttpContext ctx)
    {
        uint seqNum = MatchApp.NewSeqNum();
        HResult hr = HResult.S_OK;
        uint dwMsgCount = 0;

        DeadXboxPerfCountersStart();
        try
        {
            CSgMsgNotifyCliDelete request = new CSgMsgNotifyCliDelete();

             Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8") + "): starting.");

            // validate service request on XRL post
            if(!XRLUtil.IsValidXOnlineRequest(
                ctx.Request, XOService.Matchmaking))
            {
                // The service ID in the request is incorrect (all other
                // failures throw an XrlException)
                throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE,
                    XEvent.Id.MATCH_HACK_0,
                    "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                    + "): Request has invalid service id.");
            }

            // The data for a dead xbox request is an array of
            // CSgMsgNotifyCliDelete structures, each of which  may be a
            // notification of a dead xbox, or a notification of a dead
            // SG.
            // First we make sure there's at least enough data to fill
            // one CSgMsgNotifyCliDelete structure.
            if(ctx.Request.InputStream.Length < request.Size())
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                    XEvent.Id.MATCH_HACK_1,
                    "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                    + "): Request too small ("
                    + ctx.Request.InputStream.Length.ToString() + " < "
                    + request.Size().ToString() + ")");
            }

            // This tests to ensure that the data we've been passed is an
            // exact multiple of the length of a CSgMsgNotifyCliDelete
            // structure.
            if(0 != ctx.Request.InputStream.Length % request.Size())
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                    XEvent.Id.MATCH_HACK_2,
                    "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                    + "): Request size is not a multiple of CSgMsgNotifyCliDelete size ("
                    + ctx.Request.InputStream.Length.ToString() + ", "
                    + request.Size().ToString() + ")");
            }

            BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

            request.ReadStream(reader);

            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.DeadXbox.ProcessRequest("
                + seqNum.ToString("X8") + ")\n"
                + request.ToString(0));

            // Callers will batch up requests, find out how many we have.
            // Note that each request may be either a dead xbox or a dead sg
            // message, and we won't know which until we crack it open.
            dwMsgCount = (uint)(ctx.Request.TotalBytes / request.header._cbEnt);

            Exception lastException = null;
            Exception lastLoggableException = null;
            for(int iMsg = 0; iMsg < dwMsgCount; iMsg++)
            {
                // On the first pass we already read in the message above
                if(0 != iMsg)
                {
                    // Read the next message from the input stream
                    // Note that below, we passed a reference to
                    // request._sgaddr to a new DeadXboxMsg object.
                    // We don't want to change the value of that SGADDR
                    // object, so we create a new request here.
                    request = new CSgMsgNotifyCliDelete();
                    request.ReadStream(reader);
                    Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.DeadXbox.ProcessRequest("
                        + seqNum.ToString("X8") + ")\n"
                        + request.ToString(0));
                }

                if(request.header._cbEnt != request.Size())
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                        XEvent.Id.MATCH_HACK_3,
                        "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Size contained in request is incorrect ("
                        + request.header._cbEnt.ToString() + " != "
                        + request.Size().ToString() + ")");
                }

                if((ushort)SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL
                    != request.header._wType)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                        XEvent.Id.MATCH_HACK_4,
                        "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Request has unexpected type ("
                        + request.header._wType.ToString() + " != "
                        + SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL.ToString()
                        + ")");
                }

                try
                {
                    // See if we have a dead xbox or a dead SG
                    if (DeadXboxMsg.IsDeadSgMsg(request._sgaddr))
                    {
                        DeadSGRecordPerfCounters();
                        hr = DBLayer.DeadSg(request._sgaddr, seqNum);
                    }
                    else
                    {
                        // Only go to the database if this title has been configured
                        // for matchmaking. Otherwise just increment some perf counters
                        // and move along. Note that we do not log these dead xbox records,
                        // since they do not affect the database in any way.
                        TitleInfo ti = DBLayer.GetTitleInfo(request._dwTitleId, seqNum, true);
                        if (ti != null)
                        {
                            DeadXboxRecordPerfCounters(true);
                            // DBLayer.DeadXbox always throws on error, so this hr is most likely ignored.
                            // But leaving it here just in case.
                            hr = DBLayer.DeadXbox(ti, request._sgaddr, "DeadXbox", seqNum);
                        }
                        else
                        {
                            DeadXboxRecordPerfCounters(false);
                        }
                    }
                }
                catch(Exception e)
                {
                    Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                        "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Unexpected Exception: " + e.Message);
                    lastException = e;

                    // grab a copy of the exception if it's loggable
                    if (!(e is ExceptionWithoutEvent))
                    {
                        lastLoggableException = e;
                    }
                    // don't rethrow, continue processing through the list of requests
                }
            }
            if (lastException != null)
            {
                // We've finished processing all the deadxbox or deadsg records and something went wrong somewhere.

                // update the app level failure counters here, because we know the failures at this point are from the app level.
                MatchDeadXboxCounters.Counters.TotalRequestsDeadXboxFailed.Increment();
                MatchDeadXboxCounters.Counters.RequestsPerSecDeadXboxFailed.Increment();

                if (lastLoggableException == null)
                {
                    // all the exceptions were "ExceptionWithoutEvent".  Throw an XRLExceptionWithoutEvent for the last exception.
                    hr = XRLException.ToHResult(lastException, HResult.XONLINE_E_MATCH_SERVER_ERROR);
                    throw new XRLExceptionWithoutEvent(
                        hr,
                        "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Failure when executing some portion of a deadxbox batch.  See exception for details.", lastException);
                }
                else
                {
                    // get the hr from the exception, or use a default value 
                    hr = XRLException.ToHResult(lastLoggableException, HResult.XONLINE_E_MATCH_SERVER_ERROR);
                    throw new XRLException(
                        hr,
                        XEvent.Id.MATCH_CODE_35,
                        "XMatchFD.DeadXbox.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Failure when executing some portion of a deadxbox batch.  See exception for details.", lastLoggableException);
                }
            }

            MatchApp.SendResponse(ctx.Response, 0, hr, null);

            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.DeadXbox.ProcessRequest("
                + seqNum.ToString("X8") + "): hr = " + hr);
        }
        finally
        {
            DeadXboxPerfCountersEnd();
        }
    }

    // ----------------------------------------------------------------------
    // DeadXboxPerfCountersStart - updates perf counters at the start
    // of an dead xbox operation
    // ----------------------------------------------------------------------
    private static void DeadXboxPerfCountersStart()
    {
        MatchDeadXboxCounters.Counters.RequestsInProgressDeadXbox.Increment();
        MatchDeadXboxCounters.Counters.AverageRecordsPerRequestBaseDeadXbox.Increment();
        MatchDeadXboxCounters.Counters.AverageRecordsPerRequestBaseDeadXboxMatch.Increment();
        MatchDeadXboxCounters.Counters.AverageRecordsPerRequestBaseDeadXboxNonMatch.Increment();
        MatchDeadXboxCounters.Counters.AverageRecordsPerRequestBaseDeadSG.Increment();
     }

    // ----------------------------------------------------------------------
    // DeadXboxPerfCountersEnd - updates perf counters at the end
    // of an insert session operation
    // ----------------------------------------------------------------------
    private static void DeadXboxPerfCountersEnd()
    {
        MatchDeadXboxCounters.Counters.RequestsInProgressDeadXbox.Decrement();
        MatchDeadXboxCounters.Counters.TotalRequestsDeadXbox.Increment();
        MatchDeadXboxCounters.Counters.RequestsPerSecDeadXbox.Increment();
        MatchDeadXboxCounters.Counters.AverageExecutionTimeDeadXbox.IncrementBy(MatchApp.TimeElapsed);
        MatchDeadXboxCounters.Counters.AverageExecutionTimeBaseDeadXbox.Increment();
     }

    // ----------------------------------------------------------------------
    // DeadXboxRecordPerfCounters - updates perf counters for each dead
    // xbox record in the dead xbox request
    // ----------------------------------------------------------------------
    private static void DeadXboxRecordPerfCounters(bool isMatchTitle)
    {
        MatchDeadXboxCounters.Counters.TotalRecordsDeadXbox.Increment();
        MatchDeadXboxCounters.Counters.RecordsPerSecDeadXbox.Increment();
        MatchDeadXboxCounters.Counters.AverageRecordsPerRequestDeadXbox.Increment();
        if (isMatchTitle)
        {
            MatchDeadXboxCounters.Counters.TotalRecordsDeadXboxMatch.Increment();
            MatchDeadXboxCounters.Counters.RecordsPerSecDeadXboxMatch.Increment();
            MatchDeadXboxCounters.Counters.AverageRecordsPerRequestDeadXboxMatch.Increment();
        }
        else
        {
            MatchDeadXboxCounters.Counters.TotalRecordsDeadXboxNonMatch.Increment();
            MatchDeadXboxCounters.Counters.RecordsPerSecDeadXboxNonMatch.Increment();
            MatchDeadXboxCounters.Counters.AverageRecordsPerRequestDeadXboxNonMatch.Increment();
        }
     }

    // ----------------------------------------------------------------------
    // DeadSGRecordPerfCounters - updates perf counters for each dead
    // xbox record in the dead xbox request
    // ----------------------------------------------------------------------
    private static void DeadSGRecordPerfCounters()
    {
        MatchDeadXboxCounters.Counters.TotalRecordsDeadSG.Increment();
        MatchDeadXboxCounters.Counters.RecordsPerSecDeadSG.Increment();
        MatchDeadXboxCounters.Counters.AverageRecordsPerRequestDeadSG.Increment();
     }

    // ----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // ----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\matchxomcallback.cs ===
// 
// MatchXomCallback.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
// 
// Author: masonb
//

using System;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.match;
using xonline.common.service;


namespace xonline.server.match.fd
{
    // -----------------------------------------------------------------------------------
    // MatchXomCallback class - XMgmt callback handler class
    // -----------------------------------------------------------------------------------
    public class MatchXomCallback
    {
        // -------------------------------------------------------------------------------
        // OnControlRequest - called by XMgmt when a control request is sent
        // -------------------------------------------------------------------------------
        public static void OnControlRequest( object sender, ControlRequestEventArgs args )
        {
            try
            {
                // Log all mgmt activity to the event log
                Xom.NtEvent(XEvent.Id.MATCH_INFO_0,
                    "XMatchFD.MatchApp.OnControlRequest: Received xmgmt command - "
                    + args.FullCommand);

                switch(args.Command)
                {
                case MatchXmgmtCommand.HELP:
                    XomControlConnection.SendMessage( 
                        "XMatchFD help:\r\n" +
                        "  " + MatchXmgmtCommand.RELOADTITLEINFO + "         - reload the title map from the database\r\n" +
                        "  " + MatchXmgmtCommand.GETCACHEEXPIRATION + "      - get the search cache expiration in milliseconds\r\n" +
                        "\r\n"
                        , args.RequestId );
                    args.Handled = true;
                    break;
                case MatchXmgmtCommand.RELOADTITLEINFO:
                    DBLayer.ReInitialize();
                    XomControlConnection.SendMessage(
                        "Title info and other configuration data will reload when the next Matchmaking request arrives.\r\n",
                        args.RequestId);
                    args.Handled = true;
                    break;
                case MatchXmgmtCommand.GETCACHEEXPIRATION:
                    XomControlConnection.SendMessage(
                        "Current cache expiration="
                        + Config.GetSetting(Setting.xmatchfd_sessioncacheexpiration)
                        + "\r\n", args.RequestId);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

    } // class MatchXomCallback

} // namespace xonline.server.match.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\matchapp.cs ===
// 
// MatchApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
// 
// Author: masonb
//

using System;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.match;
using xonline.common.health;
using xonline.common.protocol;

[assembly: XomSrfInstallerAttribute( Interface.xmatchfd )]
[assembly: XomSrfInstallerAttribute( Interface.xmatchfd_int )]
[assembly: ConfigAttribute(Component.xmatchfd)]

[assembly: XomAreaDefinition(XomAreaName.matchtrace)]
[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.Reporting_v2)]
[assembly: XomAreaDefinition(XomAreaName.matchprestrace)]

namespace xonline.server.match.fd
{
    public class MatchConfigHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager blockManager,
            NameValueCollection blockParams,
            HealthReport        report
        )
        {
            // if not initialized, try to initialize.
            if(!DBLayer.fInitialized)
            {
                DBLayer.InitCheck(0 /*seqNum doesn't apply to this case */);
            }

            // if we're still not initialized, it's a failure
            if(DBLayer.fInitialized)
            {
                report.HealthStatus = HealthStatusEnum.Green;
            }
            else
            {
                report.HealthStatus = HealthStatusEnum.Red;
            }
        }
    }

// This health block validates that very basic session operations against the titlsql
// server for a single title are functioning.
public class MatchSessionHealthBlock : IHealthBlock
{
    public ResourceTypeEnum ResourceType 
    { 
        get { return ResourceTypeEnum.Remote; }
    }

    // create a session, find it by ID, and then delete the session
    // if any of these fail, the health check fails.
    public void DoCheck(
        HealthBlockManager blockManager,
        NameValueCollection blockParams,
        HealthReport        report
    )
    {
        // failure by default. This gets set to green at the end, if all went well.  
        report.HealthStatus = HealthStatusEnum.Red;
        HResult hr = HResult.E_FAIL;

        uint seqNum = MatchApp.NewSeqNum();
        ulong qwSessionId = 0;
        byte[] rgbKeyExchangeKey;
        MatchAttribute [ ] rgHostAttribs = null;
        MatchAttribute [ ] rgSearchAttribs = null;
        uint dwTitleId = 0;
        uint dwGameType = 0;
        uint dwGameMode = 0;
        string strHostname = "";
        byte bNatType = MatchDefs.XONLINE_NAT_OPEN;
        byte bServerType = MatchDefs.XNET_XNKID_ONLINE_SERVER;
        uint dwProcedureIndex = MatchDefs.X_SSINDEX_GET_SESSION;
        SearchResult[] results;

        try
        {
            // make sure the DBLayer is initialized.  This is checked by another health block, but 
            // we check it here so that the failure will happen ASAP.
            if(!DBLayer.fInitialized)
            {
                throw new ApplicationException("Match Config not initialized.  Cannot do session health checks.");
            }
            
            // grab the uint params for this block
            dwTitleId = GetUIntValueFromCollection(blockParams, "titleid", NumberStyles.HexNumber);
            dwGameType = GetUIntValueFromCollection(blockParams, "gametype", NumberStyles.HexNumber);
            dwGameMode = GetUIntValueFromCollection(blockParams, "gamemode", NumberStyles.HexNumber);

            // grab the hostname that may have been passed in.  The created session will exist under this gamertag.
            // if none was passed, we default to something sensible.
            strHostname =  blockParams["hostname"];
            if(!String.IsNullOrEmpty(strHostname))
            {
                if(strHostname.IndexOf(",") > -1)
                {
                    throw new ArgumentException("More than 1 hostname specified for MatchSessionHealthBlock.  Value was: " + strHostname);
                }
            }
            else
            {
                strHostname = "HealthCheckTest";
            }

            // Set up a fake XNADDR
            XNADDR HostAddress = new XNADDR();
            HostAddress.ina = 0;
            HostAddress.inaOnline = 0;
            HostAddress.wPortOnline = 0;
            HostAddress.abEnet = new byte[ 6 ];
            HostAddress.sgaddr = new SGADDR();
            HostAddress.sgaddr.inaSg = 0;
            HostAddress.sgaddr.dwSpiSg = 0;
            HostAddress.sgaddr.qwXboxId = 0;
            HostAddress.sgaddr.abReserved = 0;

            // Set up the attributes for the created session
            rgHostAttribs = new MatchAttribute[ 5 ];
            rgHostAttribs[0] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, 1);
            rgHostAttribs[1] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_PUID, 0);
            rgHostAttribs[2] = new MatchAttribute((MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME | MatchDefs.X_ATTRIBUTE_DATATYPE_STRING), strHostname);
            rgHostAttribs[3] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE, dwGameType);
            rgHostAttribs[4] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_MODE, dwGameMode);

            // Call the database layer to create the session
            hr = DBLayer.InsertSession(
                    bServerType,
                    bNatType,
                    dwTitleId,
                    HostAddress,
                    0, //dwPublicOpen
                    0, // dwPrivateOpen 
                    0, // dwPublicFilled
                    1, // dwPrivateFilled 
                    rgHostAttribs,
                    MatchXrl.health_ashx, 
                    out qwSessionId,
                    out rgbKeyExchangeKey, 
                    seqNum);

            if(HResult.Failed(hr)) 
            {
                throw new ApplicationException("InsertSession failed -- hr = " + hr);
            }

            if(qwSessionId == 0)
            {
                throw new ApplicationException("InsertSession failed -- sessionid of 0 returned.");
            }
            else  // otherwise, we created a session, so search for it.
            {
                TitleInfo ti = DBLayer.GetTitleInfo(dwTitleId, seqNum);

                rgSearchAttribs = new MatchAttribute[1];
                rgSearchAttribs[0] = new MatchAttribute(MatchDefs.X_ATTRIBUTE_SESSION_ID, qwSessionId);

                hr = DBLayer.FindSessionByIdXenon(
                                        bNatType,
                                        dwTitleId,
                                        ti,
                                        dwProcedureIndex,
                                        HostAddress, // normally this is the client address, but it's not important in this case.
                                        1, // wNumUsers
                                        rgSearchAttribs,
                                        out results,
                                        seqNum);

                if(HResult.Failed(hr))
                {
                    throw new ApplicationException("FindByID failed -- hr = " + hr);
                }
                else if(results.Length != 1)
                {
                    throw new ApplicationException("FindByID failed -- 1 result not returned (" + results.Length.ToString() + ")");
                }
                else if(results[0].qwSessionId != qwSessionId) 
                {
                    throw new ApplicationException("FindByID failed -- returned sessionid does not match queried sessionid (" + results[0].qwSessionId + "/" + qwSessionId + ")");
                }

                // if we got this far, we created and found the session.  Set success...
                report.HealthStatus = HealthStatusEnum.Green;
            }
        }
        catch(Exception e)
        {
            report.HealthStatus = HealthStatusEnum.Red;  // should already be red, but just to be sure...
            report.ErrorDetails += "[" + e.ToString() + "]";
        }
        finally
        {
            // clean up the created session, if there's any chance it exists.
            // catch any failures during the cleanup so that they can be properly formatted.
            try
            {
                if(qwSessionId != 0)
                {
                    hr = DBLayer.DeleteSession(
                                            dwTitleId,
                                            qwSessionId,
                                            MatchXrl.health_ashx,
                                            seqNum);

                    if(HResult.Failed(hr))
                    {
                        throw new ApplicationException("DeleteSession failed -- hr = " + hr);
                    }
                }
                
            }
            catch(Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails += "[" + e.ToString() + "]";
            }
        }
    }

    private static uint GetUIntValueFromCollection(NameValueCollection nvc, string strName, NumberStyles ns)
    {
        // grab the value for the name that was passed in.  If there wasn't one, that's fatal.
        uint dwValue = 0;
        string strValue =  nvc[strName];
        if(!String.IsNullOrEmpty(strValue))
        {
            if(strValue.IndexOf(",") > -1)
            {
                throw new ArgumentException("More than 1 " + strName + " specified for MatchSessionHealthBlock.  Value was: " + strValue);
            }
            dwValue = uint.Parse(strValue, ns);
        }
        else
        {
            throw new ArgumentException("Missing " + strName + " param in MatchSessionHealthBlock.");
        }
        return dwValue;
    }
    
}


// -----------------------------------------------------------------------------------
// MatchXrl enum - defines the list of known match entry points
// -----------------------------------------------------------------------------------
public enum MatchXrl
{
    xmatchhost_srf,
    xmatchhostdelete_srf,
    xmatchclient_srf,
    xmatchhost2_ashx,
    xmatchhostdelete2_ashx,
    xmatchclient2_ashx,
    xmatchsplit_ashx,
    deadxbox_ashx,
    titlechange_ashx,
    health_ashx
}

// -----------------------------------------------------------------------------------
// MatchApp class - the main application class
// -----------------------------------------------------------------------------------
public class MatchApp : FrontEndApp
{
    private static int m_seqNum;

    // -------------------------------------------------------------------------------
    // Application_Start - called once when the front door starts up
    // -------------------------------------------------------------------------------
    protected override void OnApplicationStart()
    {
        // we want each server to start with a random sequence number,
        // so they are not likely to use the same sequence number at the
        // same time.
        Random random = new Random();
        m_seqNum = random.Next();
        
        // Tell XMgmt that we want our handler called for control requests
        XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler( MatchXomCallback.OnControlRequest );

        // load the configuration required by the matchmaking front door.
        uint seqNum = MatchApp.NewSeqNum();
        DBLayer.InitCheck(seqNum); 

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "Matchmaking front door started");
    }

    // -------------------------------------------------------------------------------
    // Application_BeginRequest - called at the beginning of every request
    // -------------------------------------------------------------------------------
    public override void Application_BeginRequest( object sender, EventArgs e )
    {
        // Call the base class
        base.Application_BeginRequest( sender, e );

        MatchAllCounters.Counters.RequestsInProgress.Increment();

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "BeginRequest(" + HttpContext.Current.Request.RawUrl + ")");
    }

    // -------------------------------------------------------------------------------
    // Application_EndRequest - called at the end of every request
    // -------------------------------------------------------------------------------
    public override void Application_EndRequest( object sender, EventArgs e )
    {
        DBLayer.CompleteAllDBUsage();
        
        MatchAllCounters.Counters.RequestsInProgress.Decrement();
        MatchAllCounters.Counters.TotalRequests.Increment();
        MatchAllCounters.Counters.RequestsPerSec.Increment();

        MatchAllCounters.Counters.AverageExecutionTime.IncrementBy(TimeElapsed);
        MatchAllCounters.Counters.AverageExecutionTimeBase.Increment();

        // 500 is the "internal error" code that's set in SendResponse when Failed(hr)
        // put the perf counters here to keep global request perf counters together.
        if (HttpContext.Current.Response.StatusCode == 500)
        {
            MatchAllCounters.Counters.TotalRequestsFailed.Increment();
            MatchAllCounters.Counters.RequestsPerSecFailed.Increment();
        }


        // Call the base class
        base.Application_EndRequest(sender, e);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "EndRequest(" + HttpContext.Current.Request.RawUrl + "), "
            + MillisecondsElapsed.ToString() + " ms");
    }

    // -------------------------------------------------------------------------------
    // NewSeqNum - generates a sequence number where the lower 24 bits increment with 
    // each call, and the top 8 bits contain the server id of the current machine
    // -------------------------------------------------------------------------------
    public static uint NewSeqNum()
    {
        // get a sequence number in a thread safe fashion
        uint seqNum = unchecked((uint)Interlocked.Increment(ref m_seqNum));
        if (seqNum == 0)
        {
            // we never want to use 0 as a seqNum because it confuses
            // presence. So get a different one until it is not zero.
            seqNum = NewSeqNum();
        }
        return seqNum;
    }

    // -------------------------------------------------------------------------------
    // SendResponse - send a reply and log the outgoing response
    // -------------------------------------------------------------------------------
    public static void SendResponse( HttpResponse response, uint dwTitleId, HResult hr, XRLObject2 reply )
    {
        XRLUtil.SetXRLResponse( response, XOService.Matchmaking, dwTitleId, hr, reply );
    }

    // -------------------------------------------------------------------------------
    // BytesToString - returns a string representation of a byte array
    // -------------------------------------------------------------------------------
    public static string BytesToString( byte[] rgb )
    {
        StringBuilder sb = new StringBuilder();
        if (null != rgb)
        {
            foreach( byte b in rgb )
            {
                sb.Append( b.ToString( "X2" ) );
            }
        }
        return sb.ToString();
    }
} // class MatchApp

} // namespace xonline.server.match.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\fdutil.cs ===
using System;
using System.Net;
using System.Web;
using System.Collections.Generic;

using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.match.fd
{
    class MatchFdUtil
    {
        public static MatchAttribute[] AddPlatformAttributes(
                HttpContext ctx, 
                TitleInfo ti, 
                MatchAttribute []rgAttributes)
        {
            // Nothing to do
            if(!ti.SupportsCrossPlatform)
            {
                return rgAttributes;
            }

            // Construct our new list
            List<MatchAttribute> newAttributes = new List<MatchAttribute>(rgAttributes.Length);
            newAttributes.AddRange(rgAttributes);

            //
            // First add the platform type, if the client passed it up just overwrite it
            //
            SGInfo sginfo = SGInfo.Current;

            MatchAttribute typeAttr = LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE);
            if(null == typeAttr)
            {
                typeAttr = new MatchAttribute(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE, (ulong)0);
                newAttributes.Add(typeAttr);
            }

            typeAttr.qwValue = (ulong)sginfo.GetPlatformType();

            //
            // Combine the client lock attribute, title lock setting and priv into the lock attribute
            //
            bool hasCrossPlatformPriv = SGInfo.HasPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);
            MatchAttribute lockAttr = LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
            if(null == lockAttr)
            {
                lockAttr = new MatchAttribute(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK, (ulong)0);
                newAttributes.Add(lockAttr);
            }

            lockAttr.qwValue = 
                (ulong)((byte)(lockAttr.qwValue & (ulong)0x1)
                        |       (byte)(ti.RevokeCrossPlatform ? 1 : 0) 
                        |       (byte)(hasCrossPlatformPriv ? 0 : 1));

            return newAttributes.ToArray();
        }

        public static MatchAttribute LookupAttribute(MatchAttribute []rgAttributes, uint id)
        {
            MatchAttribute attr = null;

            foreach(MatchAttribute search in rgAttributes)
            {
                if(id == search.dwAttributeId)
                {
                    attr = search;
                    break;
                }
            }

            return attr;
        }

        public static void ValidateSGInfo(uint dwTitleId, XNADDR xnaddr, MatchAttribute []rgAttributes)
        {
            MatchAttribute attr;

            if(!DBLayer.EnableAuthCheck)
            {
                goto lbDone;
            }

            // Verify basic passed properties
            SGInfo.VerifyTitleIdOrAlternate(dwTitleId);

            // Not all requests provide a valid XNADDR
            if(null != xnaddr)
            {
                SGInfo.VerifyMachineId(xnaddr.sgaddr.qwXboxId);

                SGInfo sginfo = SGInfo.Current;
                IPAddress clientIP = new IPAddress(xnaddr.inaOnline);

                if(!sginfo.ClientIP.Equals(clientIP))
                {
                    throw new XRLException(
                            HResult.XONLINE_E_MATCH_SERVER_ERROR,
                            XEvent.Id.MATCH_HACK_MISMATCH_CLIENT_IPADDR,
                            String.Format(
                                "MatchFdUtil.ValidateSGInfo: XNADDR.inaOnline: {0} does not match SGInfo.ClientIP: {1}",
                                clientIP.ToString(),
                                sginfo.ClientIP.ToString()
                                )
                            );
                }
            }

            // All attribute checks follow, skip if the request type does not specify any
            // attributes (e.g. MatchDeleteMsg)
            if(null == rgAttributes)
            {
                goto lbDone;
            }

            // Check that a passed gamer puid attribute matches a user in the ticket
            // When we have a valid passed gamer puid we will also attempt to validate other
            // aspects of the user's settings
            attr = LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_GAMER_PUID);
            if(null != attr)
            {
                ulong userId = attr.qwValue;
                SGInfo.VerifyUserId(attr.qwValue);

                // Check that passed country attribute matches
                attr = LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY);
                if(null != attr)
                {
                    SGInfo.VerifyUserCountryId(userId, (byte)attr.qwValue);
                }

                // Check that passed language attribute matches
                attr = LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE);
                if(null != attr)
                {
                    SGInfo sginfo = SGInfo.Current;
                    byte attrLanguageId = (byte)attr.qwValue;
                    if(         attrLanguageId != sginfo.LanguageID 
                            &&  attrLanguageId != sginfo.GetUserLanguage(userId))
                    {
                        throw new XRLException(
                                HResult.XONLINE_E_MATCH_SERVER_ERROR,
                                XEvent.Id.MATCH_HACK_MISMATCH_LANGUAGE_ATTR,
                                String.Format(
                                    "MatchFdUtil.ValidateSGInfo: X_ATTRIBUTE_GAMER_LANGUAGE does not match " +
                                    "SGInfo.LanguageID: {0} or SGInfo.UserLanguageID[{1:X}]: {2}",
                                    sginfo.LanguageID,
                                    userId,
                                    sginfo.GetUserLanguage(userId)
                                    )
                                );
                    }
                }
            }

lbDone:
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\sessiondelete.cs ===
//
// SessionDelete.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 3/17/2005, pnewson
//

using System;
using System.IO;
using System.Web;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.match.fd
{

// ---------------------------------------------------------------------------
// XMatchHostDelete class - entry point for xbox 1 session deletion
// ---------------------------------------------------------------------------
public class XMatchHostDelete : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionDelete.ProcessRequest(ctx, MatchXrl.xmatchhostdelete_srf);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// XMatchHostDelete2 class - entry point for xenon session deletion
// ---------------------------------------------------------------------------
public class XMatchHostDelete2 : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionDelete.ProcessRequest(ctx, MatchXrl.xmatchhostdelete2_ashx);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// SessionDelete class - handles session delete requests
// ---------------------------------------------------------------------------
public class SessionDelete
{
    // -----------------------------------------------------------------------
    // ProcessRequest - entry point for HTTP request
    // -----------------------------------------------------------------------
    public static void ProcessRequest(HttpContext ctx, MatchXrl matchXrl)
    {
        uint seqNum = MatchApp.NewSeqNum();
        MatchDeleteMsg request = new MatchDeleteMsg();
        HResult hr = HResult.S_OK;

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
            "XMatchFD.SessionDelete.ProcessRequest(" + seqNum.ToString("X8")
            + "): starting.");

        // validate service request on XRL post
        if(!XRLUtil.IsValidXOnlineRequest(ctx.Request,
            XOService.Matchmaking))
        {
            // The service ID in the request is incorrect (all other 
            // failures throw an XrlException)
            throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE,
                XEvent.Id.MATCH_HACK_5, 
                "XMatchFD.SessionDelete.ProcessRequest(" + seqNum.ToString("X8")
                + "): Request is invalid");
        }

        if(ctx.Request.InputStream.Length < request.GetBaseSize())
        {
            // Request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_6,
                "XMatchFD.SessionDelete.ProcessRequest(" + seqNum.ToString("X8")
                + "): Request too small ("
                + ctx.Request.InputStream.Length.ToString() + " < "
                + request.GetBaseSize().ToString() + ")");
        }

        request.ReadFromRequest(ctx.Request);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionDelete.ProcessRequest("
            + seqNum.ToString("X8") + ")\n" + request.ToString(0));

        if(ctx.Request.InputStream.Length < request.dwMessageLength)
        {
            // Actual size smaller than embedded size
            throw new XRLException(HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                XEvent.Id.MATCH_HACK_7,
                "XMatchFD.SessionDelete.ProcessRequest(" + seqNum.ToString("X8")
                + "): Actual size smaller than size embedded in request ("
                + ctx.Request.InputStream.Length.ToString()
                + " < " + request.dwMessageLength.ToString()
                + "). TitleID=0x" + request.dwTitleId.ToString("X8"));
        }

        if(request.dwMessageLength < ctx.Request.InputStream.Position)
        {
            // Size in request too small
            throw new XRLException(HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_8,
                "XMatchFD.SessionDelete.ProcessRequest(" + seqNum.ToString("X8")
                + "): Size embedded in request is smaller than data read ("
                + request.dwMessageLength.ToString() + " < "
                + ctx.Request.InputStream.Position.ToString()
                + "). TitleID=0x" + request.dwTitleId.ToString("X8"));
        }

        // Sanity check the sginfo to secure the database write
        MatchFdUtil.ValidateSGInfo(request.dwTitleId, null, null);

        hr = DBLayer.DeleteSession(request.dwTitleId, request.qwSessionId,
            matchXrl, seqNum);

        MatchApp.SendResponse(ctx.Response, request.dwTitleId, hr, null);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.SessionDelete.ProcessRequest("
            + seqNum.ToString("X8") + "): hr = " + hr);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\sessionhost.cs ===
//
// SessionHost.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 3/17/2005, pnewson
//

using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.match.fd
{

// ---------------------------------------------------------------------------
// XMatchHost class - entry point for xbox 1 session creation and updates
// ---------------------------------------------------------------------------
public class XMatchHost : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionHost.ProcessRequest(ctx, MatchXrl.xmatchhost_srf);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// XMatchHost2 class - entry point for xbox 1 session deletion
// ---------------------------------------------------------------------------
public class XMatchHost2 : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionHost.ProcessRequest(ctx, MatchXrl.xmatchhost2_ashx);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// SessionHost class - performs the session creation and updates
// ---------------------------------------------------------------------------
public class SessionHost
{
    // -----------------------------------------------------------------------
    // ProcessRequest - entry point for HTTP request
    // -----------------------------------------------------------------------
    public static void ProcessRequest(HttpContext ctx, MatchXrl matchXrl)
    {
        uint seqNum = MatchApp.NewSeqNum();
        MatchSessionMsg matchSessionMsg = new MatchSessionMsg();

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
            "XMatchFD.SessionHost.ProcessRequest(" + seqNum.ToString("X8") + "): starting.");

        try
        {
            ValidateRequest(ctx.Request, seqNum);

            matchSessionMsg.ReadFromRequest(ctx.Request);

            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionHost.ProcessRequest("
                + seqNum.ToString("X8") + ")\n"
                + matchSessionMsg.ToString(0));

            ValidateMatchSessionMsg(ctx.Request, matchSessionMsg, seqNum);

            // Sanity check the sginfo to secure the database write
            MatchFdUtil.ValidateSGInfo(
                    matchSessionMsg.dwTitleId,
                    matchSessionMsg.HostAddress,
                    matchSessionMsg.rgAttributes);

            if(IsNewSessionRequest(matchSessionMsg))
            {
                InsertSession(ctx, matchSessionMsg, matchXrl, seqNum);
            }
            else
            {
                UpdateSession(ctx, matchSessionMsg, matchXrl, seqNum);
            }
        }
        finally
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                "XMatchFD.SessionHost.ProcessRequest(" + seqNum.ToString("X8") + "): complete.");
        }
    }

    // -----------------------------------------------------------------------
    // Checks that the httpRequest is marked for consumption by matchmaking
    // and that it is at least as large as the minimum size for a 
    // MatchSessionMsg.
    // -----------------------------------------------------------------------
    private static void ValidateRequest(HttpRequest httpRequest, uint seqNum)
    {
        MatchSessionMsg matchSessionMsg = new MatchSessionMsg();

        // validate service request on XRL post
        if(!XRLUtil.IsValidXOnlineRequest(httpRequest, XOService.Matchmaking))
        {
            // The service ID in the request is incorrect (all other
            // failures throw an XrlException)
            throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE,
                XEvent.Id.MATCH_HACK_9,
                "XMatchFD.SessionHost.ValidateRequest(" + seqNum.ToString("X8")
                + "): Request is invalid");
        }

        if(httpRequest.InputStream.Length < matchSessionMsg.GetBaseSize())
        {
            // Request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_10,
                "XMatchFD.SessionHost.ValidateRequest(" + seqNum.ToString("X8")
                + "): Request too small ("
                + httpRequest.InputStream.Length.ToString()
                + " < " + matchSessionMsg.GetBaseSize().ToString()
                + ")");
        }
    }

    // -----------------------------------------------------------------------
    // Checks that the httpRequest sizes embedded in the matchSessionMsg
    // are the same as reported by the httpRequest, that there are no more
    // than the allowed number of attributes, and it checks the attribute
    // offsets for correctness.
    // -----------------------------------------------------------------------
    private static void ValidateMatchSessionMsg(
        HttpRequest httpRequest,
        MatchSessionMsg matchSessionMsg,
        uint seqNum)
    {
        if(httpRequest.InputStream.Length < matchSessionMsg.dwMessageLength)
        {
            // Actual size smaller than embedded size
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                XEvent.Id.MATCH_HACK_11,
                "XMatchFD.SessionHost.ValidateMatchSessionMsg(" + seqNum.ToString("X8")
                + "): Actual size smaller than size embedded in request ("
                + httpRequest.InputStream.Length.ToString()
                + " < " + matchSessionMsg.dwMessageLength.ToString()
                + "). TitleID=0x" + matchSessionMsg.dwTitleId.ToString("X8"));
        }

        if(matchSessionMsg.dwMessageLength
            < httpRequest.InputStream.Position)
        {
            // Size in request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_12,
                "XMatchFD.SessionHost.ValidateMatchSessionMsg(" + seqNum.ToString("X8") +
                "): Size embedded in request is smaller than data read ("
                + matchSessionMsg.dwMessageLength.ToString()
                + " < " + httpRequest.InputStream.Position.ToString()
                + "). TitleID=0x" + matchSessionMsg.dwTitleId.ToString("X8"));
        }

        // Make sure the number of attributes is within the allowed range
        if(MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS < matchSessionMsg.dwNumAttributes)
        {
            throw new XRLException(HResult.XONLINE_E_MATCH_OVERFLOW,
                XEvent.Id.MATCH_HACK_13,
                "XMatchFD.SessionHost.ValidateMatchSessionMsg(" + seqNum.ToString("X8")
                + "): Too many attributes in request ("
                + matchSessionMsg.dwNumAttributes.ToString() + " > "
                + MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS.ToString()
                + "). TitleID=0x" + matchSessionMsg.dwTitleId.ToString("X8"));
        }

        // Validate that the attribute offsets are correct
        // XeM4: Is this really neccesary? If the offsets were wrong
        // wouldn't the deserialize operation already have thrown an
        // index out of range exception?
        uint dwAttrOffset = matchSessionMsg.GetBaseSize()
            + (4 * matchSessionMsg.dwNumAttributes);
        for(int iAttrib = 0;
            iAttrib < matchSessionMsg.dwNumAttributes;
            iAttrib++)
        {
            if(dwAttrOffset != matchSessionMsg.rgdwAttrOffsets[iAttrib])
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_OFFSET,
                    XEvent.Id.MATCH_HACK_14,
                    "XMatchFD.SessionHost.ValidateMatchSessionMsg(" + seqNum.ToString("X8")
                    + "): Attribute offset is invalid ("
                    + dwAttrOffset.ToString() + " != "
                    + matchSessionMsg.rgdwAttrOffsets[iAttrib].ToString()
                    + ", attribute=" + iAttrib.ToString()
                    + "). TitleID=0x"
                    + matchSessionMsg.dwTitleId.ToString("X8"));
            }
            dwAttrOffset += matchSessionMsg.rgAttributes[iAttrib].GetSize();
        }
    }

    // -----------------------------------------------------------------------
    // Returns true if matchSessionMsg is a request for a new session to be
    // created, false if matchSessionMsg is a request to update an existing
    // session.
    // -----------------------------------------------------------------------
    private static bool IsNewSessionRequest(MatchSessionMsg matchSessionMsg)
    {
        // We know if this is a new session request vs an update request
        // by looking at the session id passed by the client. If the session
        // id is all zeros, except for the bits reserved in
        // MatchDefs.XNET_XNKID_MASK to tell us the server type and nat type
        // then this is a new session request.
        return 0 == (matchSessionMsg.qwSessionId &
            ~(ulong)MatchDefs.XNET_XNKID_MASK);
    }

    // -----------------------------------------------------------------------
    // Handes a request to create a new session
    // -----------------------------------------------------------------------
    private static void InsertSession(
        HttpContext ctx,
        MatchSessionMsg matchSessionMsg,
        MatchXrl matchXrl,
        uint seqNum)
    {
        // Retrieve the platform type
        byte bServerType 
            = MatchDefs.XNetXnKidGetServerType(matchSessionMsg.qwSessionId);
        byte bNatType 
            = MatchDefs.XNetXnKidGetNatType(matchSessionMsg.qwSessionId);

        TitleInfo ti = DBLayer.GetTitleInfo(matchSessionMsg.dwTitleId, seqNum);

        if(MatchDefs.XNET_XNKID_SYSTEM_LINK == bServerType)
        {
            if ((matchXrl == MatchXrl.xmatchhost_srf && !ti.ForceXenonBehavior)
                || DBLayer.RelaxXenonValidation)
            {
                // We shouldn't be getting system link sessions advertized
                // in matchmaking. Unfortunately, some versions of the
                // Xbox 1 client libraries had a bug where they would
                // always pass zeros for the server type, which maps to
                // XNET_XNKID_SYSTEM_LINK. So for Xbox clients only, we'll
                // map this to XNET_XNKID_ONLINE_PEER on their behalf.
                bServerType = MatchDefs.XNET_XNKID_ONLINE_PEER;
            }
            else
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_FLAGS,
                    XEvent.Id.MATCH_TITLEBUG_47,
                    "XMatchFD.SessionHost.InsertSession(" + seqNum.ToString("X8")
                    + "): system link session type in insert request.");
            }
        }

        // Add platform type and lock based on client platform type, cross platform
        // privilege and title revokation of cross platform privilege
        MatchAttribute []rgAttributes = MatchFdUtil.AddPlatformAttributes(
                ctx, 
                ti, 
                matchSessionMsg.rgAttributes);

        MatchSessionReply matchSessionReply = new MatchSessionReply();
        HResult hr = DBLayer.InsertSession(
                bServerType, 
                bNatType,
                matchSessionMsg.dwTitleId, 
                matchSessionMsg.HostAddress,
                matchSessionMsg.dwPublicOpen,
                matchSessionMsg.dwPrivateOpen, 
                matchSessionMsg.dwPublicFilled,
                matchSessionMsg.dwPrivateFilled, 
                rgAttributes,
                matchXrl, 
                out matchSessionReply.qwSessionId,
                out matchSessionReply.rgbKeyExchangeKey, 
                seqNum);

        MatchApp.SendResponse(ctx.Response, matchSessionMsg.dwTitleId,
            hr, matchSessionReply);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.SessionHost.InsertSession("
            + seqNum.ToString("X8") + "): hr = "
            + hr);
        if (matchSessionReply != null)
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionHost.InsertSession("
                + seqNum.ToString("X8") + "):\n"
                + matchSessionReply.ToString(0));
        }
    }

    // -----------------------------------------------------------------------
    // Handes a request to update an existing session
    // -----------------------------------------------------------------------
    private static void UpdateSession(
        HttpContext ctx,
        MatchSessionMsg matchSessionMsg,
        MatchXrl matchXrl,
        uint seqNum)
    {
        TitleInfo ti = DBLayer.GetTitleInfo(matchSessionMsg.dwTitleId, seqNum);

        // Add platform type and lock based on client platform type, cross platform
        // privilege and title revokation of cross platform privilege
        //
        // Only lock is relevant for the actual update call but the platform type will
        // also be logged.
        MatchAttribute []rgAttributes = MatchFdUtil.AddPlatformAttributes(
                ctx, 
                ti, 
                matchSessionMsg.rgAttributes);

        HResult hr = DBLayer.UpdateSession(
                matchSessionMsg.qwSessionId,
                matchSessionMsg.dwTitleId,
                matchSessionMsg.dwPublicOpen,
                matchSessionMsg.dwPrivateOpen,
                matchSessionMsg.dwPublicFilled,
                matchSessionMsg.dwPrivateFilled,
                rgAttributes,
                matchXrl,
                seqNum);

        // Success, update returns no data
        MatchApp.SendResponse(ctx.Response,
            matchSessionMsg.dwTitleId, hr, null);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.SessionHost.UpdateSession("
            + seqNum.ToString("X8") + "): hr = "
            + hr);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\perfcounters.cs ===
// 
// PerfCounters.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
// 
// Author: masonb
//

using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.match.fd
{
    [XomPerformanceCounterCategoryAttr( "Match FD: All Requests", "Xbox Matchmaking Server Performance Counters - All Requests" )]
    public class MatchAllCounters : XomPerformanceCounterCategory
    {
        static public MatchAllCounters Counters = new MatchAllCounters();

        public virtual MatchAllCounters this[uint titleId]
        {
            get
            {
                return (MatchAllCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Totals across all requests served by the match front door
        // (except health checks)
        [XomPerformanceCounterAttr(
             "Requests: Total", 
             "Total number of requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequests;

        [XomPerformanceCounterAttr(
             "Requests: In Progress", 
             "Number of requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgress;

        [XomPerformanceCounterAttr(
             "Requests: Per Sec", 
             "Number of requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSec;

        [XomPerformanceCounterAttr(
             "Requests: Avg. Execution Time", 
             "Average request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTime;

        [XomPerformanceCounterAttr(
             "Requests: Avg. Execution Time Base", 
             "Base for the average request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBase;

        [XomPerformanceCounterAttr(
             "Requests: Total Failed", 
             "Total number of requests that failed with a 500 error.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsFailed;

        [XomPerformanceCounterAttr(
             "Requests: Failed Per Sec", 
             "Number of requests that failed with a 500 error, per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecFailed;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: Insert Requests", "Xbox Matchmaking Server Performance Counters - Insert Requests" )]
    public class MatchInsertCounters : XomPerformanceCounterCategory
    {
        static public MatchInsertCounters Counters = new MatchInsertCounters();

        public virtual MatchInsertCounters this[uint titleId]
        {
            get
            {
                return (MatchInsertCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Insert Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: Total", 
             "Total number of Xbox 360 session insert requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360Insert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: In Progress", 
             "Number of Xbox 360 session insert requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360Insert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: Per Sec", 
             "Number of Xbox 360 session insert requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360Insert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: Avg. Execution Time", 
             "Average Xbox 360 session insert request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360Insert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: Avg. Execution Time Base", 
             "Base for the average Xbox 360 session insert request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360Insert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: Failed: Total", 
             "Total number of Xbox 360 session insert requests failed at the application level.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360InsertFailed;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: All: Failed: Per Sec", 
             "Number of Xbox 360 session insert requests failed at the applicatio level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360InsertFailed;

        // Xbox 360 Insert Ranked Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Ranked: Total", 
             "Total number of Xbox 360 ranked session insert requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360InsertRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Ranked: In Progress", 
             "Number of Xbox 360 ranked session insert requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360InsertRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Ranked: Per Sec", 
             "Number of Xbox 360 ranked session insert requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360InsertRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Ranked: Avg. Execution Time", 
             "Average Xbox 360 ranked session insert request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360InsertRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Ranked: Avg. Execution Time Base", 
             "Base for the average Xbox 360 ranked session insert request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360InsertRanked;

        // Xbox 360 Insert Standard Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Standard: Total", 
             "Total number of Xbox 360 standard session insert requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360InsertStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Standard: In Progress", 
             "Number of Xbox 360 standard session insert requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360InsertStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Standard: Per Sec", 
             "Number of Xbox 360 standard session insert requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360InsertStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Standard: Avg. Execution Time", 
             "Average Xbox 360 standard session insert request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360InsertStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Insert: Standard: Avg. Execution Time Base", 
             "Base for the average Xbox 360 standard session insert request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360InsertStandard;

        // Xbox Insert Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: Total", 
             "Total number of Xbox session insert requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxInsert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: In Progress", 
             "Number of Xbox session insert requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXboxInsert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: Per Sec", 
             "Number of Xbox session insert requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxInsert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: Avg. Execution Time", 
             "Average Xbox session insert request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXboxInsert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: Avg. Execution Time Base", 
             "Base for the average Xbox session insert request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXboxInsert;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: Failed: Total", 
             "Total number of Xbox session insert requests failed at the application level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxInsertFailed;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Insert: Failed: Per Sec", 
             "Number of Xbox session insert requests failed at the application level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxInsertFailed;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: Insert Retries", "Xbox Matchmaking Server Performance Counters - Insert Retries" )]
    public class MatchInsertRetryCounters : XomPerformanceCounterCategory
    {
        static public MatchInsertRetryCounters Counters = new MatchInsertRetryCounters();

        public virtual MatchInsertRetryCounters this[uint titleId]
        {
            get
            {
                return (MatchInsertRetryCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Insert Retries
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Insert: All: Total", 
             "Total number of Xbox 360 session insert retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360InsertRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Insert: All: Per Sec", 
             "Number of Xbox 360 session insert retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360InsertRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Insert: All: Total", 
             "Total number of Xbox 360 session insert retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360InsertRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Insert: All: Per Sec", 
             "Number of Xbox 360 session insert retry failures per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360InsertRetryFailures;

        // Xbox Insert Retries
        [XomPerformanceCounterAttr(
             "Retries: Xbox: Insert: Total", 
             "Total number of Xbox session insert retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXboxInsertRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox: Insert: Per Sec", 
             "Number of Xbox session insert retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXboxInsertRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox: Insert: Total", 
             "Total number of Xbox session insert retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXboxInsertRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox: Insert: Per Sec", 
             "Number of Xbox session insert retry failures per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXboxInsertRetryFailures;
    } // class MatchmakingCounter


    [XomPerformanceCounterCategoryAttr( "Match FD: Update Requests", "Xbox Matchmaking Server Performance Counters - Update Requests" )]
    public class MatchUpdateCounters : XomPerformanceCounterCategory
    {
        static public MatchUpdateCounters Counters = new MatchUpdateCounters();

        public virtual MatchUpdateCounters this[uint titleId]
        {
            get
            {
                return (MatchUpdateCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Update Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: All: Total", 
             "Total number of Xbox 360 session update requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360Update;

        // begin total counters that track what Breadcrumb stuff happened during the update
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: All: BCUpdateOriginal: Total",
             "Total number of Xbox 360 session update requests that updated the original row.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateBCUpdateOriginal;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCCreateRemoteRow: Total",
             "Total number of Xbox 360 session update requests that created a new remote data row.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateBCCreateInitialSW;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCUpdateRemoteRow: Total",
             "Total number of Xbox 360 session update requests that updated the remote data row.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateBCUpdateExistingSW;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCMoveRemoteRow: Total",
             "Total number of Xbox 360 session update requests that moved the remote data row.  (delete + insert)",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateBCMoveRemoteRow;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCUnBreadcrumb: Total",
             "Total number of Xbox 360 session update requests that moved the data back to the original location.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateBCUnBreadcrumb;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCPreemptedByDelete: Total",
             "Total number of Xbox 360 session update requests that were preempted by deletes of the session.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateBCPreemptedByDelete;
        // end total counters that track what Breadcrumb stuff happened during the update

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: All: In Progress", 
             "Number of Xbox 360 session update requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360Update;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: All: Per Sec", 
             "Number of Xbox 360 session update requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360Update;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Failed: Total", 
             "Total number of Xbox 360 session update requests that failed at the app level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateFailed;

                [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Failed: Per Sec", 
             "Number of Xbox 360 session update requests that failed at the app level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateFailed;


        // begin rate counters that track what Breadcrumb stuff happened during the update
        [XomPerformanceCounterAttr(
           "Requests: Xbox 360: Update: All: BCUpdateOriginal: Per Sec",
           "Number of Xbox 360 session update requests completed per second that updated the original row.",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateBCUpdateOriginal;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCCreateRemoteRow: Per Sec",
            "Number of Xbox 360 session update requests completed per second that created a new remote data row.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateBCCreateInitialSW;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCUpdateRemoteRow: Per Sec",
            "Number of Xbox 360 session update requests completed per second that updated the remote data row.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateBCUpdateExistingSW;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCMoveRemoteRow: Per Sec",
            "Number of Xbox 360 session update requests completed per second that moved the remote data row.  (delete + insert)",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateBCMoveRemoteRow;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCUnBreadcrumb: Per Sec",
            "Number of Xbox 360 session update requests completed per second that moved the data back to the original location.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateBCUnBreadcrumb;

        [XomPerformanceCounterAttr(
            "Requests: Xbox 360: Update: All: BCPreemptedByDelete: Per Sec",
            "Number of Xbox 360 session update requests completed per second that were preempted by deletes of the session.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateBCPreemptedByDelete;
        // end rate counters that track what Breadcrumb stuff happened during the update

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: All: Avg. Execution Time", 
             "Average Xbox 360 session update request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360Update;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: All: Avg. Execution Time Base", 
             "Base for the average Xbox 360 session update request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360Update;

        // Xbox 360 Update Ranked Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Ranked: Total", 
             "Total number of Xbox 360 ranked session update requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Ranked: In Progress", 
             "Number of Xbox 360 ranked session update requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360UpdateRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Ranked: Per Sec", 
             "Number of Xbox 360 ranked session update requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Ranked: Avg. Execution Time", 
             "Average Xbox 360 ranked session update request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360UpdateRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Ranked: Avg. Execution Time Base", 
             "Base for the average Xbox 360 ranked session update request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360UpdateRanked;

        // Xbox 360 Update Standard Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Standard: Total", 
             "Total number of Xbox 360 standard session update requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360UpdateStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Standard: In Progress", 
             "Number of Xbox 360 standard session update requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360UpdateStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Standard: Per Sec", 
             "Number of Xbox 360 standard session update requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360UpdateStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Standard: Avg. Execution Time", 
             "Average Xbox 360 standard session update request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360UpdateStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Update: Standard: Avg. Execution Time Base", 
             "Base for the average Xbox 360 standard session update request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360UpdateStandard;

        // Xbox Update Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: Total", 
             "Total number of Xbox session update requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxUpdate;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: In Progress", 
             "Number of Xbox session update requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXboxUpdate;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: Per Sec", 
             "Number of Xbox session update requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxUpdate;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: Avg. Execution Time", 
             "Average Xbox session update request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXboxUpdate;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: Avg. Execution Time Base", 
             "Base for the average Xbox session update request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXboxUpdate;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: Failed: Total", 
             "Total number of Xbox session update requests failed at the app level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxUpdateFailed;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Update: Failed: Per Sec", 
             "Number of Xbox session update requests failed at the app level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxUpdateFailed;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: Delete Requests", "Xbox Matchmaking Server Performance Counters - Delete Requests" )]
    public class MatchDeleteCounters : XomPerformanceCounterCategory
    {
        static public MatchDeleteCounters Counters = new MatchDeleteCounters();

        public virtual MatchDeleteCounters this[uint titleId]
        {
            get
            {
                return (MatchDeleteCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Delete Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: All: Total", 
             "Total number of Xbox 360 session delete requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360Delete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: All: In Progress", 
             "Number of Xbox 360 session delete requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360Delete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: All: Per Sec", 
             "Number of Xbox 360 session delete requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360Delete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: All: Avg. Execution Time", 
             "Average Xbox 360 session delete request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360Delete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: All: Avg. Execution Time Base", 
             "Base for the average Xbox 360 session delete request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360Delete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Failed: Total", 
             "Total number of Xbox 360 session delete requests that failed at the app level.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360DeleteFailed;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Failed: Per Sec", 
             "Number of Xbox 360 session delete requests the failed at the app level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360DeleteFailed;

        // Xbox 360 Delete Ranked Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Ranked: Total", 
             "Total number of Xbox 360 ranked session delete requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360DeleteRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Ranked: In Progress", 
             "Number of Xbox 360 ranked session delete requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360DeleteRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Ranked: Per Sec", 
             "Number of Xbox 360 ranked session delete requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360DeleteRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Ranked: Avg. Execution Time", 
             "Average Xbox 360 ranked session delete request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360DeleteRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Ranked: Avg. Execution Time Base", 
             "Base for the average Xbox 360 ranked session delete request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360DeleteRanked;

        // Xbox 360 Delete Standard Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Standard: Total", 
             "Total number of Xbox 360 standard session delete requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360DeleteStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Standard: In Progress", 
             "Number of Xbox 360 standard session delete requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360DeleteStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Standard: Per Sec", 
             "Number of Xbox 360 standard session delete requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360DeleteStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Standard: Avg. Execution Time", 
             "Average Xbox 360 standard session delete request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360DeleteStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Delete: Standard: Avg. Execution Time Base", 
             "Base for the average Xbox 360 standard session delete request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360DeleteStandard;

        // Xbox Delete Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: Total", 
             "Total number of Xbox session delete requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxDelete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: In Progress", 
             "Number of Xbox session delete requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXboxDelete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: Per Sec", 
             "Number of Xbox session delete requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxDelete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: Avg. Execution Time", 
             "Average Xbox session delete request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXboxDelete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: Avg. Execution Time Base", 
             "Base for the average Xbox session delete request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXboxDelete;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: Failed: Total", 
             "Total number of Xbox session delete requests failed in the app layer", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxDeleteFailed;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Delete: Failed: Per Sec", 
             "Number of Xbox session delete requests failed in the app layer per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxDeleteFailed;
    } // class MatchmakingCounter


    [XomPerformanceCounterCategoryAttr( "Match FD: Search Requests", "Xbox Matchmaking Server Performance Counters - Search Requests" )]
    public class MatchSearchCounters : XomPerformanceCounterCategory
    {
        static public MatchSearchCounters Counters = new MatchSearchCounters();

        public virtual MatchSearchCounters this[uint titleId]
        {
            get
            {
                return (MatchSearchCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Search Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: Total", 
             "Total number of Xbox 360 session search requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360Search;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: In Progress", 
             "Number of Xbox 360 session search requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360Search;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: Per Sec", 
             "Number of Xbox 360 session search requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360Search;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: Avg. Execution Time", 
             "Average Xbox 360 session search request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360Search;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: Avg. Execution Time Base", 
             "Base for the average Xbox 360 session search request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360Search;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: Failed: Total", 
             "Total number of Xbox 360 session search requests failed at the application level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360SearchFailed;


        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: All: Failed: Per Sec", 
             "Number of Xbox 360 session search requests failed at the application level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360SearchFailed;

        // Xbox 360 Search FindById Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindById: Total", 
             "Total number of Xbox 360 FindById session search requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360SearchFindById;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindById: In Progress", 
             "Number of Xbox 360 FindById session search requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360SearchFindById;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindById: Per Sec", 
             "Number of Xbox 360 FindById session search requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360SearchFindById;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindById: Avg. Execution Time", 
             "Average Xbox 360 FindById session search request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360SearchFindById;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindById: Avg. Execution Time Base", 
             "Base for the average Xbox 360 FindById session search request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360SearchFindById;

        // Xbox 360 Search FindByIds Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Total",
             "Total number of Xbox 360 FindByIds session search requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: In Progress",
             "Number of Xbox 360 FindByIds session search requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Per Sec",
             "Number of Xbox 360 FindByIds session search requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Avg. Execution Time",
             "Average Xbox 360 FindByIds session search request execution time in milliseconds",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Avg. Execution Time Base",
             "Base for the average Xbox 360 FindByIds session search request excution time",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Avg. Request Count",
             "Average number of IDs per request by Xbox 360 FindByIds session search",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageIdsPerRequestXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Avg. Request Count Base",
             "Base for the average number of IDs per request for Xbox 360 FindByIds session search",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageIdsPerRequestBaseXbox360SearchFindByIds;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: FindByIds: Last Request Count",
             "Number of IDs requested by the last Xbox 360 FindByIds session search",
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter IdsPerRequestXbox360SearchFindByIds;

        // Weighted Search Counters.  (has standard and ranked)

        // Xbox 360 Weighted Search Ranked Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Ranked: Total",
             "Total number of Xbox 360 weighted ranked session search requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360WeightedSearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Ranked: In Progress",
             "Number of Xbox 360 weighted ranked session search requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360WeightedSearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Ranked: Per Sec",
             "Number of Xbox 360 weighted ranked session search requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360WeightedSearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Ranked: Avg. Execution Time",
             "Average Xbox 360 weighted ranked session search request execution time in milliseconds",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360WeightedSearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Ranked: Avg. Execution Time Base",
             "Base for the average Xbox 360 weighted ranked session search request excution time",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360WeightedSearchRanked;

        // Xbox 360 Weighted Search Standard Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Standard: Total",
             "Total number of Xbox 360 weighted standard session search requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360WeightedSearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Standard: In Progress",
             "Number of Xbox 360 weighted standard session search requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360WeightedSearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Standard: Per Sec",
             "Number of Xbox 360 weighted standard session search requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360WeightedSearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Standard: Avg. Execution Time",
             "Average Xbox 360 weighted standard session search request execution time in milliseconds",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360WeightedSearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: WeightedSearch: Standard: Avg. Execution Time Base",
             "Base for the average Xbox 360 weighted standard session search request excution time",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360WeightedSearchStandard;

        // Non-weighted Search Counters.  (has standard and ranked)

        // Xbox 360 Weighted Search Ranked Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Ranked: Total", 
             "Total number of Xbox 360 ranked session search requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360SearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Ranked: In Progress", 
             "Number of Xbox 360 ranked session search requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360SearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Ranked: Per Sec", 
             "Number of Xbox 360 ranked session search requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360SearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Ranked: Avg. Execution Time", 
             "Average Xbox 360 ranked session search request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360SearchRanked;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Ranked: Avg. Execution Time Base", 
             "Base for the average Xbox 360 ranked session search request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360SearchRanked;

        // Xbox 360 Search Standard Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Standard: Total", 
             "Total number of Xbox 360 standard session search requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXbox360SearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Standard: In Progress", 
             "Number of Xbox 360 standard session search requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXbox360SearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Standard: Per Sec", 
             "Number of Xbox 360 standard session search requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXbox360SearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Standard: Avg. Execution Time", 
             "Average Xbox 360 standard session search request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXbox360SearchStandard;

        [XomPerformanceCounterAttr(
             "Requests: Xbox 360: Search: Standard: Avg. Execution Time Base", 
             "Base for the average Xbox 360 standard session search request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXbox360SearchStandard;

        // Xbox Search Requests
        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: Total", 
             "Total number of Xbox session search requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxSearch;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: In Progress", 
             "Number of Xbox session search requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressXboxSearch;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: Per Sec", 
             "Number of Xbox session search requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxSearch;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: Avg. Execution Time", 
             "Average Xbox session search request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeXboxSearch;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: Avg. Execution Time Base", 
             "Base for the average Xbox session search request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseXboxSearch;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: Failed: Total", 
             "Total number of Xbox session search requests failed at the application level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsXboxSearchFailed;

        [XomPerformanceCounterAttr(
             "Requests: Xbox: Search: Failed: Per Sec", 
             "Number of Xbox session search requests failed at the application level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecXboxSearchFailed;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: Search Retries", "Xbox Matchmaking Server Performance Counters - Search Retries" )]
    public class MatchSearchRetryCounters : XomPerformanceCounterCategory
    {
        static public MatchSearchRetryCounters Counters = new MatchSearchRetryCounters();

        public virtual MatchSearchRetryCounters this[uint titleId]
        {
            get
            {
                return (MatchSearchRetryCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Search Requests
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: All: Total", 
             "Total number of Xbox 360 session search retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: All: Per Sec", 
             "Number of Xbox 360 session search retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: All: Total", 
             "Total number of Xbox 360 session search retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: All: Per Sec", 
             "Number of Xbox 360 session search retry failures per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchRetryFailures;

        // Xbox 360 Search FindById Requests
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: FindById: Total", 
             "Total number of Xbox 360 FindById session search retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchFindByIdRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: FindById: Per Sec", 
             "Number of Xbox 360 FindById session search retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchFindByIdRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: FindById: Total", 
             "Total number of Xbox 360 FindById session search retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchFindByIdRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: FindById: Per Sec", 
             "Number of Xbox 360 FindById session search retry failrues per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchFindByIdRetryFailures;

        // Xbox 360 Search FindByIds Requests
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: FindByIds: Total",
             "Total number of Xbox 360 FindByIds session search retries",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchFindByIdsRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: FindByIds: Per Sec",
             "Number of Xbox 360 FindByIds session search retries per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchFindByIdsRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: FindByIds: Total",
             "Total number of Xbox 360 FindByIds session search retry failures",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchFindByIdsRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: FindByIds: Per Sec",
             "Number of Xbox 360 FindByIds session search retry failrues per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchFindByIdsRetryFailures;


        // xbox 360 Weighted Search Retry counters (has standard and ranked)

        // Xbox 360 Search Ranked retries
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: WeightedSearch: Ranked: Total",
             "Total number of Xbox 360 ranked session weighted search retries",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360WeightedSearchRankedRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: WeightedSearch: Ranked: Per Sec",
             "Number of Xbox 360 ranked session weighted search retries per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360WeightedSearchRankedRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: WeightedSearch: Ranked: Total",
             "Total number of Xbox 360 ranked session weighted search retry failures",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360WeightedSearchRankedRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: WeightedSearch: Ranked: Per Sec",
             "Number of Xbox 360 ranked session weighted search retry failures per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360WeightedSearchRankedRetryFailures;

        // Xbox 360 Search Standard Requests
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: WeightedSearch: Standard: Total",
             "Total number of Xbox 360 standard session weighted search retries",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360WeightedSearchStandardRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: WeightedSearch: Standard: Per Sec",
             "Number of Xbox 360 standard session weighted search retries per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360WeightedSearchStandardRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: WeightedSearch: Standard: Total",
             "Total number of Xbox 360 standard session weighted search retry failures",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360WeightedSearchStandardRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: WeightedSearch: Standard: Per Sec",
             "Number of Xbox 360 standard session weighted search retry failures per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360WeightedSearchStandardRetryFailures;


        // xbox 360 NON-Weighted Search Retry counters (has standard and ranked)

        // Xbox 360 Search Ranked retries
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: Ranked: Total", 
             "Total number of Xbox 360 ranked session search retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchRankedRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: Ranked: Per Sec", 
             "Number of Xbox 360 ranked session search retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchRankedRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: Ranked: Total", 
             "Total number of Xbox 360 ranked session search retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchRankedRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: Ranked: Per Sec", 
             "Number of Xbox 360 ranked session search retry failures per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchRankedRetryFailures;

        // Xbox 360 Search Standard Requests
        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: Standard: Total", 
             "Total number of Xbox 360 standard session search retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchStandardRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox 360: Search: Standard: Per Sec", 
             "Number of Xbox 360 standard session search retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchStandardRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: Standard: Total", 
             "Total number of Xbox 360 standard session search retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXbox360SearchStandardRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox 360: Search: Standard: Per Sec", 
             "Number of Xbox 360 standard session search retry failures per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXbox360SearchStandardRetryFailures;

        // Xbox Search Requests
        [XomPerformanceCounterAttr(
             "Retries: Xbox: Search: Total", 
             "Total number of Xbox session search retries", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXboxSearchRetries;

        [XomPerformanceCounterAttr(
             "Retries: Xbox: Search: Per Sec", 
             "Number of Xbox session search retries per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXboxSearchRetries;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox: Search: Total", 
             "Total number of Xbox session search retry failures", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalXboxSearchRetryFailures;

        [XomPerformanceCounterAttr(
             "Retry Failures: Xbox: Search: Per Sec", 
             "Number of Xbox session search retry failures per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter PerSecXboxSearchRetryFailures;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: Search Results", "Xbox Matchmaking Server Performance Counters - Search Results" )]
    public class MatchResultCounters : XomPerformanceCounterCategory
    {
        static public MatchResultCounters Counters = new MatchResultCounters();

        public virtual MatchResultCounters this[uint titleId]
        {
            get
            {
                return (MatchResultCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Xbox 360 Search Results
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: All: Total", 
             "Total number of Xbox 360 session search results", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360Search;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: All: Per Sec", 
             "Number of Xbox 360 session search results per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360Search;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: All: Avg. Per Request", 
             "Average number of Xbox 360 session search results per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360Search;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: All: Avg. Per Request Base", 
             "Base for average number of Xbox 360 session search results per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360SearchBase;

        // Xbox 360 Weighted Search Results Counters (has ranked and standard, but no affiliates)

        // Xbox 360 Weighted Ranked Search Results
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedRanked: Total",
             "Total number of Xbox 360 ranked session weighted search results",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360WeightedRankedSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedRanked: Per Sec",
             "Number of Xbox 360 ranekd session weighted search results per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360WeightedRankedSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedRanked: Avg. Per Request",
             "Average number of Xbox 360 ranked session weighted search results per request",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360WeightedRankedSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedRanked: Avg. Per Request Base",
             "Base for average number of Xbox 360 ranked session weighted search results per request",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360WeightedRankedSearchBase;

        // Xbox 360 Weighted Standard Search Results
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedStandard: All: Total",
             "Total number of Xbox 360 standard session weighted search results",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360WeightedStandardSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedStandard: All: Per Sec",
             "Number of Xbox 360 standard session weighted search results per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360WeightedStandardSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedStandard: All: Avg. Per Request",
             "Average number of Xbox 360 standard session weighted search results per request",
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360WeightedStandardSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: WeightedStandard: All: Avg. Per Request Base",
             "Base for average number of Xbox 360 standard session weighted search results per request",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360WeightedStandardSearchBase;

        // Xbox 360 NON-Weighted Search Results Counters

        // Xbox 360 Ranked Search Results
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Ranked: Total", 
             "Total number of Xbox 360 ranked session search results", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360RankedSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Ranked: Per Sec", 
             "Number of Xbox 360 ranekd session search results per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360RankedSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Ranked: Avg. Per Request", 
             "Average number of Xbox 360 ranked session search results per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360RankedSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Ranked: Avg. Per Request Base", 
             "Base for average number of Xbox 360 ranked session search results per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360RankedSearchBase;

        // Xbox 360 Standard Search Results
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: All: Total", 
             "Total number of Xbox 360 standard session search results", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360StandardSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: All: Per Sec", 
             "Number of Xbox 360 standard session search results per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360StandardSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: All: Avg. Per Request", 
             "Average number of Xbox 360 standard session search results per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360StandardSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: All: Avg. Per Request Base", 
             "Base for average number of Xbox 360 standard session search results per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360StandardSearchBase;

        // Xbox 360 Standard Search Results: Affiliates, In Zone
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: In Zone: Total", 
             "Total number of Xbox 360 standard session search results for affiliates in the same gamer zone", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360StandardAffiliateInZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: In Zone: Per Sec", 
             "Number of Xbox 360 standard session search results for affiliates in the same gamer zone per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360StandardAffiliateInZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: In Zone: Avg. Per Req", 
             "Average number of Xbox 360 standard session search results for affiliates in the same gamer zone per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360StandardAffiliateInZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: In Zone: Avg. Per Req Base", 
             "Base for average number of Xbox 360 standard session search results for affiliates in the same gamer zone per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360StandardAffiliateInZoneSearchBase;

        // Xbox 360 Standard Search Results: Non Affiliates, In Zone, Same Lang, Same Country
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In ZoneLangCtry: Total", 
             "Total number of Xbox 360 standard session search results for non affiliates in the same gamer zone, language and country", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In ZoneLangCtry: Per Sec", 
             "Number of Xbox 360 standard session search results for non affiliates in the same gamer zone, language and country per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In ZoneLangCtry:AvgPerReq", 
             "Average number of Xbox 360 standard session search results for non affiliates in the same gamer zone, language and country per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate:In ZoneLangCtry:AvgPerReqBase", 
             "Base for average number of Xbox 360 standard session search results for non affiliates in the same gamer zone, language and country per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearchBase;

        // Xbox 360 Standard Search Results: Non Affiliates, In Zone
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In Zone: Total", 
             "Total number of Xbox 360 standard session search results for non affiliates in the same gamer zone", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360StandardNonAffiliateInZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In Zone: Per Sec", 
             "Number of Xbox 360 standard session search results for non affiliates in the same gamer zone per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360StandardNonAffiliateInZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In Zone: Avg. Per Req", 
             "Average number of Xbox 360 standard session search results for non affiliates in the same gamer zone per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360StandardNonAffiliateInZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: In Zone: Avg. Per Req Base", 
             "Base for average number of Xbox 360 standard session search results for non affiliates in the same gamer zone per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360StandardNonAffiliateInZoneSearchBase;

        // Xbox 360 Standard Search Results: Affiliates, Different Zone
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: Out Zone: Total", 
             "Total number of Xbox 360 standard session search results for affiliates in a different gamer zone", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360StandardAffiliateOutZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: Out Zone: Per Sec", 
             "Number of Xbox 360 standard session search results for affiliates in a different gamer zone per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360StandardAffiliateOutZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: Out Zone: Avg. Per Req", 
             "Average number of Xbox 360 standard session search results for affiliates in a different gamer zone per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360StandardAffiliateOutZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Affiliate: Out Zone: Avg. Per Req Base", 
             "Base for average number of Xbox 360 standard session search results for affiliates in a different gamer zone per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360StandardAffiliateOutZoneSearchBase;

        // Xbox 360 Standard Search Results: Non Affiliates, Different Zone
        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: Out Zone: Total", 
             "Total number of Xbox 360 standard session search results for non affiliates in a different gamer zone", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXbox360StandardNonAffiliateOutZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: Out Zone: Per Sec", 
             "Number of Xbox 360 standard session search results for non affiliates in a different gamer zone per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXbox360StandardNonAffiliateOutZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: Out Zone: Avg. Per Req", 
             "Average number of Xbox 360 standard session search results for non affiliates in a different gamer zone per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXbox360StandardNonAffiliateOutZoneSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox 360: Standard: Non Affiliate: Out Zone: Avg. Per Req Base", 
             "Base for average number of Xbox 360 standard session search results for non affiliates in a different gamer zone per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXbox360StandardNonAffiliateOutZoneSearchBase;

        // Xbox Search Results
        [XomPerformanceCounterAttr(
             "Search Results: Xbox: Total", 
             "Total number of Xbox session search results", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalResultsXboxSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox: Per Sec", 
             "Number of Xbox session search results per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ResultsPerSecXboxSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox: Avg. Per Request", 
             "Average number of Xbox session search results per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageResultsXboxSearch;

        [XomPerformanceCounterAttr(
             "Search Results: Xbox: Avg. Per Request Base", 
             "Base for average number of Xbox session search results per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageResultsXboxSearchBase;

    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: Affiliates", "Xbox Matchmaking Server Performance Counters - Search Results" )]
    public class MatchAffiliateCounters : XomPerformanceCounterCategory
    {
        static public MatchAffiliateCounters Counters = new MatchAffiliateCounters();

        public virtual MatchAffiliateCounters this[uint titleId]
        {
            get
            {
                return (MatchAffiliateCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // Affiliate records from presence server
        [XomPerformanceCounterAttr(
             "Affiliate Records: Total", 
             "Total number of affiliate records returned by the presence front door for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateRecords;

        [XomPerformanceCounterAttr(
             "Affiliate Records: Per Sec", 
             "Number of affiliate records returned by the presence front door per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateRecordsPerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Records: Avg Per Request", 
             "Average number of affiliate records returned by the presence front door per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateRecordsPerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Records: Avg Per Request Base", 
             "Base for average number of affiliate records returned by the presence front door per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateRecordsPerRequestBase;

        [XomPerformanceCounterAttr(
             "Affiliate Queries: Avg. Execution Time", 
             "Average affiliate query request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeAffiliateQuery;

        [XomPerformanceCounterAttr(
             "Affiliate Queries: Avg. Execution Time Base", 
             "Base for the average affiliate query request execution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseAffiliateQuery;

        // Affiliate sessions calculated from affiliate records
        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Positive: Total", 
             "Total number of positive affiliate sessions returned by the presence front door for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateSessionsPositive;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Positive: Per Sec", 
             "Number of positive affiliate sessions returned by the presence front door per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateSessionsPositivePerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Positive: Avg Per Request", 
             "Average number of positive affiliate sessions returned by the presence front door per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateSessionsPositivePerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Positive: Avg Per Request Base", 
             "Base for average number of positive affiliate sessions returned by the presence front door per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateSessionsPositivePerRequestBase;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Negative: Total", 
             "Total number of negative affiliate sessions returned by the presence front door for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateSessionsNegative;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Negative: Per Sec", 
             "Number of negative affiliate sessions returned by the presence front door per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateSessionsNegativePerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Negative: Avg Per Request", 
             "Average number of negative affiliate sessions returned by the presence front door per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateSessionsNegativePerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Sessions: Negative: Avg Per Request Base", 
             "Base for average number of negative affiliate sessions returned by the presence front door per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateSessionsNegativePerRequestBase;

        // Affiliate results found in database
        [XomPerformanceCounterAttr(
             "Affiliate Results: In Zone: Total", 
             "Total number of positive affiliate results in the same gamer zone available for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateResultsInZone;

        [XomPerformanceCounterAttr(
             "Affiliate Results: In Zone: Per Sec", 
             "Number of positive affiliate results in the same gamer zone available per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateResultsInZonePerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Results: In Zone: Avg Per Request", 
             "Average number of positive affiliate in the same gamer zone results available per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateResultsInZonePerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Results: In Zone: Avg Per Request Base", 
             "Base for average number of positive affiliate results in the same gamer zone available per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateResultsInZonePerRequestBase;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Out Zone: Total", 
             "Total number of negative affiliate results in a different gamer zone available for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateResultsOutZone;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Out Zone: Per Sec", 
             "Number of negative affiliate results in a different gamer zone available per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateResultsOutZonePerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Out Zone: Avg Per Request", 
             "Average number of negative affiliate results in a different gamer zone available per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateResultsOutZonePerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Out Zone: Avg Per Request Base", 
             "Base for average number of negative affiliate results in a different gamer zone available per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateResultsOutZonePerRequestBase;

        // results filtered out due to negative affiliate session value
        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone, Same Lang, Same Country: Total", 
             "Total number of affiliate results in the same gamer zone, language and country filtered out by negative session values for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateResultsFilteredInZoneSameLangSameCountry;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone, Same Lang, Same Country: Per Sec", 
             "Number of positive affiliate results in the same gamer zone, language and country filtered out by negative session values per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateResultsFilteredInZoneSameLangSameCountryPerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone, Same Lang, Same Country: Avg Per Request", 
             "Average number of positive affiliate results in the same gamer zone, language and country filtered out by negative session values per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateResultsFilteredInZoneSameLangSameCountryPerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone, Same Lang, Same Country: Avg Per Req Base", 
             "Base for average number of positive affiliate results in the same gamer zone, language and country filtered out by negative session values per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateResultsFilteredInZoneSameLangSameCountryPerRequestBase;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone: Total", 
             "Total number of affiliate results in the same gamer zone filtered out by negative session values for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateResultsFilteredInZone;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone: Per Sec", 
             "Number of positive affiliate results in the same gamer zone filtered out by negative session values per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateResultsFilteredInZonePerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone: Avg Per Request", 
             "Average number of positive affiliate results in the same gamer zone filtered out by negative session values per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateResultsFilteredInZonePerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: In Zone: Avg Per Request Base", 
             "Base for average number of positive affiliate results in the same gamer zone filtered out by negative session values per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateResultsFilteredInZonePerRequestBase;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: Out Zone: Total", 
             "Total number of affiliate results in a different gamer zone filtered out by negative session values for Xbox 360 standard session searches", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalAffiliateResultsFilteredOutZone;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: Out Zone: Per Sec", 
             "Number of positive affiliate results in a different gamer zone filtered out by negative session values per second for Xbox 360 standard session searches", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter AffiliateResultsFilteredOutZonePerSec;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: Out Zone: Avg Per Request", 
             "Average number of positive affiliate results in a different gamer zone filtered out by negative session values per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageAffiliateResultsFilteredOutZonePerRequest;

        [XomPerformanceCounterAttr(
             "Affiliate Results: Filtered: Out Zone: Avg Per Request Base", 
             "Base for average number of positive affiliate results in a different gamer zone filtered out by negative session values per request for Xbox 360 standard session searches", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageAffiliateResultsFilteredOutZonePerRequestBase;

    }

    [XomPerformanceCounterCategoryAttr( "Match FD: DeadXbox Requests", "Xbox Matchmaking Server Performance Counters - DeadXbox Requests" )]
    public class MatchDeadXboxCounters : XomPerformanceCounterCategory
    {
        static public MatchDeadXboxCounters Counters = new MatchDeadXboxCounters();

        public virtual MatchDeadXboxCounters this[uint titleId]
        {
            get
            {
                return (MatchDeadXboxCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // DeadXbox Requests
        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: Total", 
             "Total number of DeadXbox requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsDeadXbox;

        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: In Progress", 
             "Number of DeadXbox requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressDeadXbox;

        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: Per Sec", 
             "Number of DeadXbox requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecDeadXbox;

        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: Total Failed", 
             "Total number of DeadXbox requests failed at the app level.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsDeadXboxFailed;

        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: Failed Per Sec", 
             "Number of DeadXbox requests failed at the app level per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecDeadXboxFailed;

        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: Avg. Execution Time", 
             "Average DeadXbox request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeDeadXbox;

        [XomPerformanceCounterAttr(
             "Requests: DeadXbox: Avg. Execution Time Base", 
             "Base for the average DeadXbox request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseDeadXbox;

        // DeadXbox Records
        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Total", 
             "Total number of DeadXbox records", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsDeadXbox;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Per Sec", 
             "Number of DeadXbox records per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecDeadXbox;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Avg. Per Request", 
             "Average DeadXbox records per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestDeadXbox;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Avg. Per Request Base", 
             "Base for the average DeadXbox records per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseDeadXbox;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Match Title: Total", 
             "Total number of DeadXbox records for Match enabled titles ", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsDeadXboxMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Match Title: Per Sec", 
             "Number of DeadXbox records for Match enabled titles per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecDeadXboxMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Match Title: Avg. Per Request", 
             "Average DeadXbox records for Match enabled titles per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestDeadXboxMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Match Title: Avg. Per Request Base", 
             "Base for the average DeadXbox records for Match enabled titles per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseDeadXboxMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Non Match Title: Total", 
             "Total number of DeadXbox records for Non-Match enabled titles", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsDeadXboxNonMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Non Match Title: Per Sec", 
             "Number of DeadXbox records per second for Non-Match enabled titles", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecDeadXboxNonMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Non Match Title: Avg. Per Request", 
             "Average DeadXbox records for Non-Match enabled titles per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestDeadXboxNonMatch;

        [XomPerformanceCounterAttr(
             "Records: DeadXbox: Non Match Title: Avg. Per Request Base", 
             "Base for the average DeadXbox records for Non-Match enabled titles per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseDeadXboxNonMatch;

        // DeadSG Records
        [XomPerformanceCounterAttr(
             "Records: DeadSG: Total", 
             "Total number of DeadSG records", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsDeadSG;

        [XomPerformanceCounterAttr(
             "Records: DeadSG: Per Sec", 
             "Number of DeadSG records per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecDeadSG;

        [XomPerformanceCounterAttr(
             "Records: DeadSG: Avg. Per Request", 
             "Average DeadSG records per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestDeadSG;

        [XomPerformanceCounterAttr(
             "Records: DeadSG: Avg. Per Request Base", 
             "Base for the average DeadSG records per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseDeadSG;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: TitleChange Requests", "Xbox Matchmaking Server Performance Counters - TitleChange Requests" )]
    public class MatchTitleChangeCounters : XomPerformanceCounterCategory
    {
        static public MatchTitleChangeCounters Counters = new MatchTitleChangeCounters();

        public virtual MatchTitleChangeCounters this[uint titleId]
        {
            get
            {
                return (MatchTitleChangeCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // TitleChange Requests
        [XomPerformanceCounterAttr(
             "Requests: TitleChange: Total", 
             "Total number of TitleChange requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsTitleChange;

        [XomPerformanceCounterAttr(
             "Requests: TitleChange: In Progress", 
             "Number of TitleChange requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressTitleChange;

        [XomPerformanceCounterAttr(
             "Requests: TitleChange: Per Sec", 
             "Number of TitleChange requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecTitleChange;

        [XomPerformanceCounterAttr(
             "Requests: TitleChange: Avg. Execution Time", 
             "Average TitleChange request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeTitleChange;

        [XomPerformanceCounterAttr(
             "Requests: TitleChange: Avg. Execution Time Base", 
             "Base for the average TitleChange request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseTitleChange;

        [XomPerformanceCounterAttr(
             "Requests: TitleChange: Failed: Total", 
             "Total number of TitleChange requests that failed at the app level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsTitleChangeFailed;

        [XomPerformanceCounterAttr(
             "Requests: TitleChange: Failed: Per Sec", 
             "Number of TitleChange requests that failed at the app level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecTitleChangeFailed;

        // TitleChange Records
        [XomPerformanceCounterAttr(
             "Records: TitleChange: Total", 
             "Total number of TitleChange records", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsTitleChange;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Per Sec", 
             "Number of TitleChange records per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecTitleChange;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Avg. Per Request", 
             "Average TitleChange records per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestTitleChange;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Avg. Per Request Base", 
             "Base for the average TitleChange records per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseTitleChange;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Match: Total", 
             "Total number of TitleChange records for Match enabled titles", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsTitleChangeMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Match: Per Sec", 
             "Number of TitleChange records for Match enabled titles per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecTitleChangeMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Match: Avg. Per Request", 
             "Average TitleChange records for Match enabled titles per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestTitleChangeMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Match: Avg. Per Request Base", 
             "Base for the average TitleChange records for Match enabled titles per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseTitleChangeMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Non Match: Total", 
             "Total number of TitleChange records for Non-Match enabled titles", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRecordsTitleChangeNonMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Non Match: Per Sec", 
             "Number of TitleChange records for Non-Match enabled titles per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RecordsPerSecTitleChangeNonMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Non Match: Avg. Per Request", 
             "Average TitleChange records for Non-Match enabled titles per request", 
             PerformanceCounterType.AverageCount64)]
        public PerformanceCounter AverageRecordsPerRequestTitleChangeNonMatch;

        [XomPerformanceCounterAttr(
             "Records: TitleChange: Non Match: Avg. Per Request Base", 
             "Base for the average TitleChange records for Non-Match enabled titles per request", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageRecordsPerRequestBaseTitleChangeNonMatch;
    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: SplitSession Requests", "Xbox Matchmaking Server Performance Counters - SplitSession Requests" )]
    public class MatchSplitSessionCounters : XomPerformanceCounterCategory
    {
        static public MatchSplitSessionCounters Counters = new MatchSplitSessionCounters();

        public virtual MatchSplitSessionCounters this[uint titleId]
        {
            get
            {
                return (MatchSplitSessionCounters) GetInstance("0x"+titleId.ToString("X8"));
            }
        }

        // SplitSession Requests
        [XomPerformanceCounterAttr(
             "Requests: SplitSession: Total", 
             "Total number of SplitSession requests", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsSplitSession;

        [XomPerformanceCounterAttr(
             "Requests: SplitSession: In Progress", 
             "Number of SplitSession requests in progress", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RequestsInProgressSplitSession;

        [XomPerformanceCounterAttr(
             "Requests: SplitSession: Per Sec", 
             "Number of SplitSession requests completed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecSplitSession;

        [XomPerformanceCounterAttr(
             "Requests: SplitSession: Avg. Execution Time", 
             "Average SplitSession request execution time in milliseconds", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter AverageExecutionTimeSplitSession;

        [XomPerformanceCounterAttr(
             "Requests: SplitSession: Avg. Execution Time Base", 
             "Base for the average SplitSession request excution time", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter AverageExecutionTimeBaseSplitSession;

        [XomPerformanceCounterAttr(
             "Requests: SplitSession: Failed: Total", 
             "Total number of SplitSession requests failed at the app level", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalRequestsSplitSessionFailed;

        [XomPerformanceCounterAttr(
             "Requests: SplitSession: Failed: Per Sec", 
             "Number of SplitSession requests failed at the app level per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecSplitSessionFailed;


    } // class MatchmakingCounter

    [XomPerformanceCounterCategoryAttr( "Match FD: failures due to fastfail", "Xbox Matchmaking Server Performance Counters - Failures due to fastfail." )]
    public class MatchFastFailCounters : XomPerformanceCounterCategory
    {
        static public MatchFastFailCounters Counters = new MatchFastFailCounters();

        public virtual MatchFastFailCounters this[string strServerName]
        {
            get
            {
                return (MatchFastFailCounters) GetInstance(strServerName);
            }
        }

        // FastFail rejected titlsql connections
        [XomPerformanceCounterAttr(
             "FastFail count", 
             "Total number of titlsql connection attempts rejected due to fastfail.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TotalConnectsFailed;

        [XomPerformanceCounterAttr(
             "FastFail rate", 
             "rate per second of titlsql connection attempts rejected due to fastfail", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter ConnectsPerSecFailed;

    } // class MatchmakingCounter


} // namespace xonline.server.match.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\sessionsplit.cs ===
//
// SessionSplit.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 5/22/2005, jacobr
//

using System;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Caching;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.match.fd
{

// ---------------------------------------------------------------------------
// XMatchSplit class - entry point for session split requests
// ---------------------------------------------------------------------------
public class XMatchSplit : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionSplit.ProcessRequest(ctx, MatchXrl.xmatchsplit_ashx);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// SessionSplit class - handles session split requests
// ---------------------------------------------------------------------------
public class SessionSplit
{
    // -----------------------------------------------------------------------
    // ProcessRequest - entry point for HTTP request
    // -----------------------------------------------------------------------
    public static void ProcessRequest(HttpContext ctx, MatchXrl matchXrl)
    {
        uint seqNum = MatchApp.NewSeqNum();
        HResult hr = HResult.S_OK;
        MatchSplitMsg matchSplitMsg = new MatchSplitMsg();
        MatchSplitReply matchSplitReply = null;

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
            "XMatchFD.SessionSplit.ProcessRequest(" + seqNum.ToString("X8")
            + "): starting.");

        ValidateRequest(ctx.Request, seqNum);

        matchSplitMsg.ReadFromRequest(ctx.Request);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionSplit.ProcessRequest("
            + seqNum.ToString("X8") + ")\n"
            + matchSplitMsg.ToString(0));

        ValidateMatchSplitMsg(ctx.Request, matchSplitMsg, seqNum);
    
        // Get the new server type and nat type from the request
        byte bServerType     = MatchDefs.XNetXnKidGetServerType(matchSplitMsg.qwSessionId);
        byte bNatType        = MatchDefs.XNetXnKidGetNatType(matchSplitMsg.qwSessionId);

        // Validate that it is not a system link server type
        if(MatchDefs.XNET_XNKID_SYSTEM_LINK == bServerType)
        {
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_FLAGS,
                    XEvent.Id.MATCH_TITLEBUG_51,
                    "XMatchFD.SessionHost.SplitSession(" + seqNum.ToString("X8")
                    + "): system link session type in split request.");
        }

        // Sanity check the sginfo to secure the database write
        MatchFdUtil.ValidateSGInfo(
                matchSplitMsg.dwTitleId,
                matchSplitMsg.HostAddress,
                matchSplitMsg.rgAttributes);

        // Lookup titleinfo for platform attribute overrides
        TitleInfo ti = DBLayer.GetTitleInfo(matchSplitMsg.dwTitleId, seqNum);

        // Add platform attributes if required
        MatchAttribute []rgAttributes = MatchFdUtil.AddPlatformAttributes(
                ctx, 
                ti, 
                matchSplitMsg.rgAttributes);

        // Send the request on to the database layer. All message fields
        // have been validated now.
        SearchResult session;
        hr = DBLayer.SplitSession(
                matchSplitMsg.qwSplitSessionId,
                bServerType,
                bNatType,
                matchSplitMsg.dwTitleId,
                matchSplitMsg.HostAddress,
                rgAttributes, 
                matchXrl,
                out session,
                seqNum);
        
        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.SessionSplit.ProcessRequest("
            + seqNum.ToString("X8") + "): hr = " + hr);

        matchSplitReply = new MatchSplitReply();
        matchSplitReply.Session = session;

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionSplit.ProcessRequest("
                + seqNum.ToString("X8") + ")\n"
                + matchSplitReply.ToString(0));

        // Success, return the split session data
        MatchApp.SendResponse(
                ctx.Response, 
                matchSplitMsg.dwTitleId,
                hr, 
                matchSplitReply);
    }

    // -----------------------------------------------------------------------
    // Checks that the httpRequest is marked for consumption by matchmaking
    // and that it is at least as large as the minimum size for a 
    // MatchSplitMsg.
    // -----------------------------------------------------------------------
    private static void ValidateRequest(HttpRequest httpRequest, uint seqNum)
    {
        MatchSplitMsg matchSplitMsg = new MatchSplitMsg();

        // validate service request on XRL post
        if(!XRLUtil.IsValidXOnlineRequest(httpRequest, XOService.Matchmaking))
        {
            // The service ID in the request is incorrect (all other
            // failures throw an XrlException)
            throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE,
                XEvent.Id.MATCH_HACK_28, 
                "XMatchFD.SessionSplit.ValidateRequest(" + seqNum.ToString("X8")
                + "): Request is invalid.");
        }

        if(httpRequest.InputStream.Length < matchSplitMsg.GetBaseSize())
        {
            // Request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_29,
                "XMatchFD.SessionSplit.ValidateRequest(" + seqNum.ToString("X8")
                + "): Request too small ("
                + httpRequest.InputStream.Length.ToString() + " < "
                + matchSplitMsg.GetBaseSize().ToString() + ")");
        }
    }

    // -----------------------------------------------------------------------
    // Checks that the httpRequest sizes embedded in the matchSplitMsg
    // are the same as reported by the httpRequest, plus additional
    // validity checks on the context of the split request
    // -----------------------------------------------------------------------
    private static void ValidateMatchSplitMsg(
        HttpRequest httpRequest,
        MatchSplitMsg matchSplitMsg,
        uint seqNum)
    {
        if(httpRequest.InputStream.Length < matchSplitMsg.dwMessageLength)
        {
            // Actual size smaller than embedded size
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                XEvent.Id.MATCH_HACK_30,
                "XMatchFD.SessionSplit.ValidateMatchSplitMsg(" + seqNum.ToString("X8")
                + "): Actual size smaller than size embedded in request ("
                + httpRequest.InputStream.Length.ToString()
                + " < " + matchSplitMsg.dwMessageLength.ToString()
                + "). TitleID=0x" + matchSplitMsg.dwTitleId.ToString("X8"));
        }

        if(matchSplitMsg.dwMessageLength < httpRequest.InputStream.Length)
        {
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_OVERFLOW,
                    XEvent.Id.MATCH_HACK_SPLIT_SIZE_OVERFLOW,
                    "XMatchFD.SessionSplit.ValidateMatchSplitMsg(" + seqNum.ToString("X8")
                    + "): Extra data in payload was not deserialized as part of the split session message, data left: "
                    + (httpRequest.InputStream.Length - matchSplitMsg.dwMessageLength).ToString()
                    + ". TitleID=0x" + matchSplitMsg.dwTitleId.ToString("X8"));
        }

        if(matchSplitMsg.dwMessageLength < httpRequest.InputStream.Position)
        {
            // Size in request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_31,
                "XMatchFD.SessionSplit.ValidateMatchSplitMsg(" + seqNum.ToString("X8")
                + "): Size embedded in request is smaller than data read ("
                + matchSplitMsg.dwMessageLength.ToString() + " < "
                + httpRequest.InputStream.Position.ToString()
                + "). TitleID=0x" + matchSplitMsg.dwTitleId.ToString("X8"));
        }

        // Make sure the number of attributes is within the allowed range
        if(MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS < matchSplitMsg.dwNumAttributes)
        {
            throw new XRLException(HResult.XONLINE_E_MATCH_OVERFLOW,
                XEvent.Id.MATCH_HACK_32,
                "XMatchFD.SessionHost.ValidateMatchSplitMsg(" + seqNum.ToString("X8")
                + "): Too many attributes in request ("
                + matchSplitMsg.dwNumAttributes.ToString() + " > "
                + MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS.ToString()
                + "). TitleID=0x" + matchSplitMsg.dwTitleId.ToString("X8"));
        }

        // Validate that the attribute offsets are correct
        uint dwAttrOffset = matchSplitMsg.GetBaseSize()
            + (4 * matchSplitMsg.dwNumAttributes);
        for(int iAttr = 0; iAttr < matchSplitMsg.dwNumAttributes; iAttr++)
        {
            if(dwAttrOffset != matchSplitMsg.rgdwAttrOffsets[iAttr])
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_OFFSET,
                    XEvent.Id.MATCH_HACK_33,
                    "XMatchFD.SessionSplit.ValidateMatchSplitMsg(" + seqNum.ToString("X8")
                    + "): Attribute offset is invalid ("
                    + dwAttrOffset.ToString() + " != "
                    + matchSplitMsg.rgdwAttrOffsets[iAttr].ToString()
                    + ", attr=" + iAttr.ToString()
                    + "). TitleID=0x" + matchSplitMsg.dwTitleId.ToString("X8"));
            }
            dwAttrOffset += matchSplitMsg.rgAttributes[iAttr].GetSize();
        }

        // If the new session passed contains bits other than the XNET_XNKID_MASK then
        // likely the qwSessionId has some invalid data in it.
        if(0 != (matchSplitMsg.qwSessionId & ~(ulong)MatchDefs.XNET_XNKID_MASK))
        {
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_FLAGS,
                    XEvent.Id.MATCH_TITLEBUG_49,
                    "XMatchFD.SessionHost.SplitSession(" + seqNum.ToString("X8")
                    + "): invalid high-order flags specified in the new session id (" +
                    matchSplitMsg.qwSessionId.ToString("X16") + ").");
        }

        // If the existing session ID and the new session ID flags are the same at this point
        // then the exist session ID is not a real session ID.
        if(matchSplitMsg.qwSessionId == matchSplitMsg.qwSplitSessionId)
        {
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_FLAGS,
                    XEvent.Id.MATCH_TITLEBUG_50,
                    "XMatchFD.SessionHost.SplitSession(" + seqNum.ToString("X8")
                    + "): existing session id (" +
                    matchSplitMsg.qwSplitSessionId.ToString("X16") + 
                    ") and new session id flags (" + 
                    matchSplitMsg.qwSessionId.ToString("X16") +
                    ") should not be the same.");
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\dvt\AffiliateState.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace PresenceTest
{
	[Flags]
	enum AffiliateFlags : uint {
		// Actual Affiliate Lists
		Encountered      = 0x00000001, 
		CompletedGame    = 0x00000002,
		PositiveFeedback = 0x00000004,
		NegativeFeedback = 0x00000008,
		AvoidingMe       = 0x00000010,
		// Emulated Affiliate Lists
		Friend           = 0x00010000, 
		Block            = 0x00020000, 
		Mute             = 0x00040000, 
		Any              = 0xffffffff
	}
	
	// Affiliate state tracks affialiation for a given user. This is 
	// a heavy class but intended to be used across tests to do deep validation
	// of affiliation records
	public class AffiliateState
	{

		//
		// One item indexed into multiple hash tables based on the 
		// loaded or populated Add() calls
		//
		public class AffiliateHashItem
		{
			void ClearMembers()
			{
				User         = null;
				AffiliateId  = 0;
				ListFlags    = 0;
				TitleId      = 0;
				SessionId    = 0;
				DateUpdated  = 0;
				GamerTag     = null;
			}

			public AffiliateHashItem()
			{
				ClearMembers();
			}

			public AffiliateHashItem(PNUser user)
			{
				ClearMembers();
				User = user;
				if(null != User.Xbox)
				{
					TitleId = User.Xbox.TitleId;
				}

				SessionId = User.MatchSessionId;
				GamerTag = User.Name;
				AffiliateId = User.UserId;
			}

			public AffiliateHashItem(PNUser user, QueryAffiliatesReplyData replyData)
			{
				this.User 		= user;
				AffiliateId 	= replyData.qwAffiliateID;
				ListFlags 	    = replyData.dwListFlags;
				TitleId 		= replyData.dwTitleID;
				SessionId 	    = replyData.qwSessionID;
				DateUpdated 	= replyData.mtDateUpdated;
				GamerTag 		= replyData.szGamerTag;
			}

			public PNUser	User;
			public ulong 	AffiliateId;
			public uint 	ListFlags;
			public uint 	TitleId;
			public ulong 	SessionId;
			public uint 	DateUpdated;
			public string 	GamerTag;
		}

		static Report _Report = new Report(typeof(AffiliateState).Name);

		FriendsCommon _FriendsCommon;
		PNUser _Owner;
		Hashtable _Unknown;            // Should not be in any affiliate list
		Hashtable _All;                // All affiliations stored (the master list)
		Hashtable _Encountered;        // Was Encountered
		Hashtable _CompletedGame;      // Was Preferred player
		Hashtable _PositiveFeedback;   // Feedback Server: Positive
		Hashtable _NegativeFeedback;   // Feedback Server: Negative
		//Hashtable _AvoidingMe;         // Feedback Server: Negative (reverse assoc)

		bool _Initialized;
		int _AddPostSleep = 2000;

		//------------------------------------------------------------------------------
		// 
		// Internal methods
		//
		void CheckInitialized()
		{
			if(!_Initialized)
			{
				throw new UnexpectedTestResultException("AffiliatesState was not correctly initialized"); 
			}
		}

		void CheckExists(string tableName, Hashtable table, ulong [] list)
		{
			foreach(ulong puid in list)
			{
				if(!table.Contains(puid))
				{
					throw new UnexpectedTestResultException("User: " + puid.ToString("x") + " not found in table: " + tableName);
				}
			}
		}

		void CheckNotExists(string tableName, Hashtable table, ulong [] list)
		{
			foreach(ulong puid in list)
			{
				if(table.Contains(puid))
				{
					throw new UnexpectedTestResultException("User: " + puid.ToString("x") + " should not not found in table: " + tableName);
				}
			}
		}

		void AddToHash(Hashtable table, PNUser [] list, uint flags, uint titleId)
		{
			foreach(PNUser u in list) 
			{
				// First ensure that the hash item is in the global index, notify
				// the test client if the flags or title ID is changing.
				AffiliateHashItem hashItem = _All[u.UserId] as AffiliateHashItem;
				if(null != hashItem)
				{
					uint preFlags = hashItem.ListFlags;
					uint preTitleId = hashItem.TitleId;

					hashItem.ListFlags |= flags;
					hashItem.TitleId = titleId;

					if(hashItem.ListFlags != preFlags)
					{
						_Report.Debug("AddToHash(): Modifying HashItem[{0:x}].ListFlags: {1:x8}->{2:x8}", 
								u.UserId, preFlags, hashItem.ListFlags);
					}
					if(hashItem.TitleId != preTitleId)
					{
						_Report.Debug("AddToHash(): Modifying HashItem[{0:x}].TitleId: {1:x8}->{2:x8}", 
								u.UserId, preTitleId, hashItem.TitleId);
					}
				}
				else
				{
					hashItem = new AffiliateHashItem(u);
					hashItem.ListFlags = flags;
					hashItem.TitleId = titleId;
					_All[u.UserId] = hashItem;
				}

				// Index the new or existing hash item into the request hash table
				table[u.UserId] = hashItem;
			}
		}

		void RemoveFromHash(Hashtable table, PNUser[] list, uint flags)
		{
			foreach(PNUser u in list)
			{
				AffiliateHashItem hashItem = _All[u.UserId] as AffiliateHashItem;
				if(null != hashItem)
				{
					uint preFlags = hashItem.ListFlags;
					hashItem.ListFlags &= ~flags;
					_Report.Debug("RemoveFromHash(): HashItem[{0:x}].ListFlags: {1:x8}->{2:x8}", 
							u.UserId, preFlags, hashItem.ListFlags);
				}
				else
				{
					_Report.Warn("RemoveFromHash() on non-hashed user: {0:x}", u.UserId);
				}

				table.Remove(u.UserId);
			}
		}


		//------------------------------------------------------------------------------
		//
		// Public methods
		//

		public AffiliateState()
		{
		}

		public AffiliateState(PNUser user)
		{
			Initialize(user);
		}


		public AffiliateState(AffiliateState copyState)
		{
			Initialize(copyState);
		}


		public void Initialize()
		{
			Initialize((PNUser)null);
		}

		public void Initialize(AffiliateState copyState)
		{
			Initialize(copyState._Owner);
		}

		public void Initialize(PNUser owner)
		{
			if(!_Initialized)
			{
				_FriendsCommon = new FriendsCommon();

				if(null == owner)
				{
					_Owner = _FriendsCommon.CreateXenonUser(true);
				}
				else
				{
					_Owner = owner;
				}

				_Unknown = new Hashtable();
				_All = new Hashtable();
				_Encountered = new Hashtable();
				_CompletedGame = new Hashtable();
				_PositiveFeedback = new Hashtable();
				_NegativeFeedback = new Hashtable();
				_Report.Debug("Initialized state Owner Puid: " + _Owner.UserId.ToString("x") + ", TitleId: " + _Owner.Xbox.TitleId);
				_Initialized = true;
			}
		}

		// Clear all of the user hashes and reload them from the actual
		// server supplied data.
		public void Restore()
		{
			// Clear all hashes
			ClearHashTables();

			// Load hashtables
			Load(UInt32.MaxValue, false);
		}

		public void SetAddPostSleep(int millis)
		{
			_AddPostSleep = millis;
		}


		// Compare this state with another state. This would be used for
		// loading state from the query API and populating another state
		// from the Add API and comparing them piece by piece.
		public void Compare(AffiliateState inputState)
		{
			Compare(inputState, (uint)AffiliateFlags.Any);
		}

		public void Compare(AffiliateState inputState, uint flags)
		{
			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				// Compare each item in the hash tables to the input state
				foreach(AffiliateHashItem hashItem in _Encountered.Values)
				{
					if(!inputState._Encountered.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the encountered players table");
					}
				}
			}

			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				foreach(AffiliateHashItem hashItem in _CompletedGame.Values)
				{
					if(!inputState._CompletedGame.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the CompletedGame players table");
					}
				}
			}

			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				foreach(AffiliateHashItem hashItem in _PositiveFeedback.Values)
				{
					if(!inputState._PositiveFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the positive feedback table");
					}

					if(inputState._NegativeFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state contains positive AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the negative feedback table");
					}
				}
			}

			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				foreach(AffiliateHashItem hashItem in _NegativeFeedback.Values)
				{
					if(!inputState._NegativeFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state does not contain AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the negative feedback table");
					}

					if(inputState._PositiveFeedback.Contains(hashItem.AffiliateId))
					{
						throw new UnexpectedTestResultException("The input state contains negative AffiliateId: " + 
								hashItem.AffiliateId.ToString("x") + ", in the positive feedback table");
					}
				}
			}
		}



		//------------------------------------------------------------------------------
		// 
		// User management
		//

		public PNUser[] GetFreeUserList(uint count)
		{
			return GetFreeUserList(count, false);
		}

		public PNUser[] GetFreeUserList(uint count, bool alive)
		{
			PNUser[] list = new PNUser[count];
			for(uint i = 0; i < count; ++i)
			{
				list[i] = GetFreeUser(alive);
			}

			return list;
		}

		public PNUser GetFreeUser()
		{
			return GetFreeUser(false);
		}

		public PNUser GetFreeUser(bool alive)
		{
			// Do the alive here (non-fatal)
			PNUser user = _FriendsCommon.CreateUser(false);
			if(alive && !user.LoggedOn)
			{
				uint hr = user.Alive();
				if(HResult.Failed(hr))
				{
					_Report.Debug("Alive failed for user {0}, hr: {1}", user.UserId, hr);
				}
			}

			return user;
		}

		public void ReleaseUsers(PNUser[] list)
		{
			_FriendsCommon.ReleaseUsers(list);	
		}

		public void ReleaseUser(PNUser user)
		{
			_FriendsCommon.ReleaseUser(user);
		}


		//------------------------------------------------------------------------------
		// 
		// Load existing affiliate properties
		//
		
		void ValidateAndLoadHash(string name, uint flags, PQueryAffiliatesReplyMsgData replyData, Hashtable hashTable)
		{
			if(HResult.Failed(replyData.hr))
			{
				throw new HResultException(replyData.hr, "Failed to load affiliates data: "  + name);
			}

			_Report.Debug("ValidateAndLoadHash: "  + name + ", count: " + replyData.cdwResults);	

			for(uint i = 0; i < replyData.cdwResults; ++i)
			{
				QueryAffiliatesReplyData data = replyData.rgResults[i];
					
				// Validate the affiliate flags
				if((data.dwListFlags & flags) == 0)
				{
					throw new UnexpectedTestResultException("The list flags did not match the queried flags: " + name + ", " + data.dwListFlags.ToString("x"));
				}

				// TODO: these items require peer presence
				// Validate the affiliate ID
				// Validate the affiliate session ID
				// Validate the affiliate date updated
				
				// Find an existing hash item matching the input data
				AffiliateHashItem hashItem = _All[data.qwAffiliateID] as AffiliateHashItem;
				if(null == hashItem)
				{
				 	hashItem = new AffiliateHashItem(null, data);
					_All[data.qwAffiliateID] = hashItem;
				}
				else
				{
					_Report.Debug("Updating existing hash item for AffiliateId: " + data.qwAffiliateID.ToString("x"));

					hashItem.ListFlags = data.dwListFlags;
					hashItem.TitleId = data.dwTitleID;
					hashItem.SessionId = data.qwSessionID;
					hashItem.DateUpdated = data.mtDateUpdated;
				}

				// Store off the affiliate hash item
				hashTable[data.qwAffiliateID] = hashItem;
			}
		}

		// Default load ignores TitleId and grabs as much as possible
		public void Load()
		{
			Load(UInt32.MaxValue, false);
		}

		public PQueryAffiliatesReplyMsgData LoadExternal(uint limit, bool useTitleId, uint flags)
		{
			uint queryTitleId = useTitleId ? _Owner.Xbox.TitleId : 0;

			PMsgQueryAffiliates request = new PMsgQueryAffiliates(_Owner, limit, flags, queryTitleId);
			PNMsg replyMsg;
			PQueryAffiliatesReplyMsgData replyData;
            request.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;

			return replyData;
		}

		public void Load(uint limit, bool useTitleId)
		{
			// This could all be done in one shot but I'm going to validate that each query only returns the set of players
			// that I'm interested in. Also going to query all to compare against what I got from individual queries.
			
			uint queryTitleId = useTitleId ? _Owner.Xbox.TitleId : 0;

			// Create the query messages
			PMsgQueryAffiliates queryEncountered = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.Encountered, queryTitleId);
			PMsgQueryAffiliates queryCompletedGame = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.CompletedGame, queryTitleId);
			PMsgQueryAffiliates queryPositive = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.PositiveFeedback, queryTitleId);
			PMsgQueryAffiliates queryNegative = new PMsgQueryAffiliates(_Owner, limit, (uint)AffiliateFlags.NegativeFeedback, queryTitleId);
			PMsgQueryAffiliates queryAll = new PMsgQueryAffiliates(_Owner, limit, 0xffffffff, queryTitleId);
			

			// Issue all of the messages, validate and load them into the correct hash table
			PNMsg replyMsg;
			PQueryAffiliatesReplyMsgData replyData;

            queryEncountered.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("Encountereds", (uint)AffiliateFlags.Encountered, replyData, _Encountered);

            queryPositive.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("PositiveFeedback", (uint)AffiliateFlags.PositiveFeedback, replyData, _PositiveFeedback);

            queryCompletedGame.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("CompletedGames", (uint)AffiliateFlags.CompletedGame, replyData, _CompletedGame);

            queryNegative.TransactFD(out replyMsg);
			replyData = (PQueryAffiliatesReplyMsgData)replyMsg.Data;
			ValidateAndLoadHash("NegativeFeedback", (uint)AffiliateFlags.NegativeFeedback, replyData, _NegativeFeedback);

			// Do a full query and make sure that there aren't any users that are with unsupported flags
			
		}

		public void ClearHashTables()
		{
			_Unknown.Clear();
			_PositiveFeedback.Clear();
			_NegativeFeedback.Clear();
			_Encountered.Clear();
			_CompletedGame.Clear();
			_All.Clear();
		}

		public void ValidateAllServerAffiliates()
		{
			_Report.Debug("Validating all affiliates on server using IsAffiliate query");
			foreach(AffiliateHashItem hashItem in _All.Values)
			{
				PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, hashItem.AffiliateId);
				PNMsg reply;
                request.TransactFD(out reply);
				PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;

				if(HResult.Failed(data.hr))
				{
					throw new HResultException(data.hr, "IsAffiliate query failed");
				}
				if(data.hr == HResult.S_FALSE)
				{
					throw new HResultException(data.hr, "IsAffiliate return S_FALSE for affiliate that should exist.");
				}

				ValueCheck.Test("AffiliateId", hashItem.AffiliateId, data.qwAffiliateID);
				ValueCheck.Test("ListFlags", hashItem.ListFlags, data.dwListFlags);

				// Make sure that the user is in the appropriate hash tables
				Check(hashItem.AffiliateId, data.dwListFlags);

				_Report.Debug("Matched: " + data.qwAffiliateID.ToString("x") + ", dwListFlags: " + data.dwListFlags.ToString("x"));
			}
		}

		//------------------------------------------------------------------------------
		//
		// Affiliate list management
		//

		public void Add(PNUser user, uint flags)
		{
			Add(new PNUser[]{user}, flags, _Owner.Xbox.TitleId);
		}

		public void Add(PNUser user, uint flags, uint titleId)
		{
			Add(new PNUser[]{user}, flags, titleId);
		}

		public void Add(PNUser [] list, uint flags)
		{
			Add(list, flags, _Owner.Xbox.TitleId);
		}

		public void Add(PNUser [] list, uint flags, uint titleId)
		{
			CheckInitialized();

			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				AddToHash(_Encountered, list, flags, titleId);
			}
			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				RemoveFromHash(_NegativeFeedback, list, (uint)AffiliateFlags.NegativeFeedback);
				AddToHash(_PositiveFeedback, list, flags, titleId);
			}
			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				RemoveFromHash(_PositiveFeedback, list, (uint)AffiliateFlags.PositiveFeedback);
				AddToHash(_NegativeFeedback, list, flags, titleId);
			}
			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				// If you complete a game you also belong in the set of encountered
				// players
				AddToHash(_CompletedGame, list, (uint)AffiliateFlags.CompletedGame, titleId);
				AddToHash(_Encountered, list, (uint)AffiliateFlags.Encountered, titleId);
			}

			PMsgAddAffiliates req = new PMsgAddAffiliates(
					_Owner, 
					flags,
					titleId, 
					list);
            req.TransactFD();

			// Give the server time to complete the async transaction
			Thread.Sleep(_AddPostSleep);
		}

		public void Check(PNUser user, uint flags)
		{
			if(null == user)
			{
				throw new NullReferenceException("user");
			}

			Check(new PNUser[]{user}, flags);
		}

		public void Check(ulong userId, uint flags)
		{
			Check(new ulong[]{userId}, flags);
		}

		public void Check(PNUser[] list, uint flags)
		{
			if(null == list)
			{
				throw new NullReferenceException("list");
			}
			
			ulong []puids = new ulong[list.Length];
			uint count = 0;
			foreach(PNUser u in list)
			{
				puids[count++] = u.UserId;
			}
			
		}

		public void Check(ulong[] list, uint flags)
		{
			CheckExists("All users", _All, list);

			if(0 != (flags & (uint)AffiliateFlags.Encountered))
			{
				CheckExists("Encountered", _Encountered, list);
			}
			if(0 != (flags & (uint)AffiliateFlags.CompletedGame))
			{
				CheckExists("CompletedGame", _CompletedGame, list);
			}
			if(0 != (flags & (uint)AffiliateFlags.PositiveFeedback))
			{
				CheckNotExists("NegativeFeedback", _NegativeFeedback, list);
				CheckExists("PositiveFeedback", _PositiveFeedback, list);
			}
			if(0 != (flags & (uint)AffiliateFlags.NegativeFeedback))
			{
				CheckNotExists("PositiveFeedback", _PositiveFeedback, list);
				CheckExists("NegativeFeedback", _NegativeFeedback, list);
			}
		}


		public void ValidateIsAffiliate(PNUser[] list)
		{
			foreach(PNUser user in list)
			{
				ValidateIsAffiliate(user);
			}
		}

		public void ValidateIsAffiliate(PNUser user)
		{
			PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, user);
			PNMsg reply;
            request.TransactFD(out reply);
			PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;
			if(HResult.Failed(data.hr))
			{
				throw new HResultException(data.hr, "IsAffiliate query failed");
			}

			ValueCheck.Test("IsAffiliate.AffiliateId mismatch", user.UserId, data.qwAffiliateID);
			ValueCheck.TestNonZero("IsAffiliate.ListFlags non-zero", data.dwListFlags);
		}

		public void ValidateIsNotAffiliate(PNUser []list)
		{
			foreach(PNUser user in list)
			{
				ValidateIsNotAffiliate(user);
			}
		}

		public void ValidateIsNotAffiliate(PNUser user)
		{
			PMsgIsAffiliate request = new PMsgIsAffiliate(_Owner, user);
			PNMsg reply;
            request.TransactFD(out reply);
			PIsAffiliateReplyMsgData data = (PIsAffiliateReplyMsgData)reply.Data;
			if(HResult.Failed(data.hr))
			{
				throw new HResultException(data.hr, "IsAffiliate query failed");
			}

			if(data.qwAffiliateID != user.UserId)
			{
				throw new UnexpectedTestResultException("IsAffiliate AffiliateId mismatch: " + data.qwAffiliateID + " != " + user.UserId);
			}

			ValueCheck.Test("IsAffiliate.ListFlags zero", 0, data.dwListFlags);
			ValueCheck.Test("IsAffiliateHR(S_FALSE)", HResult.S_FALSE, data.hr);
		}

		public void ValidateAffiliateFlags(PNUser []list, uint flags)
		{
			foreach(PNUser user in list)
			{
				ValidateAffiliateFlags(user, flags);
			}
		}

		public void ValidateAffiliateFlags(PNUser user, uint flags)
		{
			bool found = false;
			PQueryAffiliatesReplyMsgData data = LoadExternal(UInt32.MaxValue, false, flags);
			foreach(QueryAffiliatesReplyData item in data.rgResults)
			{
				if(item.qwAffiliateID == user.UserId)
				{
					found = true;
					if((item.dwListFlags & flags) == 0)
					{
						throw new UnexpectedTestResultException("ValidateAffiliateFlags(): Affiliate found but dwListFlags: " + 
								item.dwListFlags.ToString("x") + " do not match input flags: " + flags.ToString("x"));
					}
					else
					{
						break;
					}
				}
			}

			if(!found)
			{
				throw new UnexpectedTestResultException("ValidateAffiliateFlags(): Affiliate not found: " + user.UserId.ToString("x")  +
								" for Owner: " + _Owner.UserId.ToString("x"));
			}
		}

		// Get the actual number of combined instances across all of the
		// specified lists in the flags 
		public uint GetInstanceCount(uint flags)
		{
			uint count = 0;


			CheckInitialized();

			count += (uint)_Encountered.Count;
			count += (uint)_CompletedGame.Count;
			count += (uint)_PositiveFeedback.Count;
			count += (uint)_NegativeFeedback.Count;

			return count;
		}

		public PNUser GetOwner()
		{
			CheckInitialized();
			return _Owner;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\titleinfo.cs ===
using System;
using System.Collections;
using xonline.common.config;
using xonline.common.service;

namespace xonline.server.match.fd
{
    // ----------------------------------------------------------------------
    // RRIDInfo class (struct)
    // contains info about the round robin servers for a given partition.
    // max is the highest round robin index.  (0 based)
    // counter is used to track which RRIndex was used last.
    // ----------------------------------------------------------------------
    class RRIDInfo
    {
        public byte bMaxAll;
        public byte bCounterAll;
        public byte bMaxNotDraining;
        public byte bCounterNotDraining;
    }

    // ----------------------------------------------------------------------
    // TitleInfo class - encapsulates title info needed by DBLayer class
    // ----------------------------------------------------------------------
    public class TitleInfo
    {
        // Constant for title config rows not supporting cross 
        // platform play
        public const byte INVALID_CROSS_PLATFORM_REVOKE = 0xff;

        // Flag used to mark a bucket as draining
        public const string DRAIN_FLAG = "drain";

        // a counter that gets incremented each time DBLayer asks for a database 
        // number for this title. This is not an index into m_rgstrDatabase!
        private byte m_bDbCounter = 0;

        // An array of the databases this title uses. Each member of this array is 
        // a string suitable for use as a "Data Source" in a SQL connection string.
        private string[] m_rgstrDatabases;

        // The title id this object contains data about
        private uint m_dwTitleId;

        // The value this title uses for session expiration in match session
        // records
        private uint m_dwSessionExpiration;

        // If this is set, then Xenon code paths are always run, even if 
        // the xbox 1 xrl was used as an entry point. This allows us to reuse
        // some older tests.
        private bool m_fForceXenonBehavior;

        // If this value is non-zero we will delay the deletion of the session
        // until the specified number of seconds in the future. When it is zero
        // we do not pass it as a parameter to old sprocs as they may not have
        // been generated with this parameter.
        private uint m_dwDeleteDelaySeconds;

        // stores a map of game type + mode -> a count of buckets.  This is for
        // Xenon titles only, at least for now.
        private Hashtable m_hashPartitions;

        private byte m_bRevokeCrossPlatform;

        public TitleInfo(
                uint dwTitleId,
                uint dwSessionExpiration,
                bool fForceXenonBehavior,
                string[] rgstrDatabases,
                Hashtable hashPartitions,
                uint dwDeleteDelaySeconds,
                byte bRevokeCrossPlatform)
        {
            m_dwTitleId             = dwTitleId;
            m_dwSessionExpiration   = dwSessionExpiration;
            m_rgstrDatabases        = rgstrDatabases;
            m_hashPartitions        = hashPartitions;
            m_fForceXenonBehavior   = fForceXenonBehavior;
            m_dwDeleteDelaySeconds  = dwDeleteDelaySeconds;
            m_bRevokeCrossPlatform  = bRevokeCrossPlatform;
        }

        public uint TitleId
        {
            get { return m_dwTitleId; }
        }

        public uint SessionExpiration
        {
            get { return m_dwSessionExpiration; }
        }

        // -------------------------------------------------------------------
        // GetNextRRIndexForPartition
        // Given a type and mode, checks gets the next Round Robin server
        // index.  
        // -------------------------------------------------------------------
        public byte GetNextRRIndexForPartition(byte bType, byte bMode, bool bIncludeDrainingBuckets, uint seqNum)
        {
            uint dwPartition = ((uint)(bType << 16)) | ((uint)(bMode << 8));  // TODOTHEOM: put these bit masks in a const.
            RRIDInfo rri = (RRIDInfo)m_hashPartitions[dwPartition];
            if (rri == null) // it wasn't in the hash
            {
                string err = string.Format("XMatchFD.TitleInfo.GetNextRRIndexForPartition({0:X8}): Could not find Partition for type={1} mode={2} bIncludeDrainingBuckets={3} within Title {4:X8}", 
                                           seqNum, bType, bMode, bIncludeDrainingBuckets, m_dwTitleId);
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_PARAM,
                    XEvent.Id.MATCH_TITLEBUG_34,  // TODO2THEOM: new event id here?
                    err);

                //throw new System.ArgumentException("GetNextRRIndexForPartition: Could not find Partition for type="
                //    + bType + " mode=" + bMode
                //    + " within Title " + m_dwTitleId);
            }

            if (bIncludeDrainingBuckets == false)
            {
                return (byte)(++rri.bCounterNotDraining % (rri.bMaxNotDraining + 1));
            }

            return (byte)(++rri.bCounterAll % (rri.bMaxAll + 1));
        }

        // -------------------------------------------------------------------
        // GetNextRRBucketForPartition
        // Given a type and mode, returns the next Round Robin bucket that 
        // should be used.  Also returns the RRID of that server by ref.
        // -------------------------------------------------------------------
        public IBucketServer GetNextRRBucketForPartition(byte bType, byte bMode, bool bIncludeDrainingBuckets, ref byte bRRID, uint seqNum)
        {
            uint dwPartition = ((uint)(bType << 16)) | ((uint)(bMode << 8));  // TODOTHEOM: put these bit masks in a const.
            
            // GetTitleBucketServer will throw if the bucket is not found.
            try
            {
                // Get the next RRID and create the bucket ID for it
                bRRID = GetNextRRIndexForPartition(bType, bMode, bIncludeDrainingBuckets, seqNum);
                uint dwBucketID = dwPartition | bRRID;

                // Get the server matching the bucketID
                IBucketServer server = Config.GetTitleBucketServer(Interface.xmatch, m_dwTitleId, dwBucketID);
                return (server);
            }
            catch (ApplicationException e)  // TODO2THEOM: modify config to throw a more specific exception
            {
                string msg = string.Format("XMatchFD.TitleInfo.GetNextRRIndexForPartition({0:X8}): Could not find Partition for type={1} mode={2} within Title {3:X8}", seqNum, bType, bMode, m_dwTitleId);
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_PARAM,
                    XEvent.Id.MATCH_TITLEBUG_34,  // TODO2THEOM: new event id here?
                    msg, e);            
            }
        }

        // -------------------------------------------------------------------
        // GetNextRRBucketForPartition
        // override for callers who don't want the RRID back.
        // -------------------------------------------------------------------
        public IBucketServer GetNextRRBucketForPartition(byte bType, byte bMode, bool bIncludeDrainingBuckets, uint seqNum)
        {
            byte bRRID = 0;
            // GetNextRRBucketForPartition will throw if the bucket is not found.
            return GetNextRRBucketForPartition(bType, bMode, bIncludeDrainingBuckets, ref bRRID, seqNum);
        }

        // -------------------------------------------------------------------
        // GetRRCountForPartition
        // returns how many Round Robin servers there are for this type/mode.
        // -------------------------------------------------------------------
        public byte GetRRCountForPartition(byte bType, byte bMode, uint seqNum)
        {
            uint dwPartition = ((uint)(bType << 16)) | ((uint)(bMode << 8));  // TODOTHEOM: put these bit masks (shifts) in a const.
            RRIDInfo rri = (RRIDInfo)m_hashPartitions[dwPartition];
            if (rri == null) // it wasn't in the hash
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_PARAM,
                    XEvent.Id.MATCH_TITLEBUG_34,  // TODO2THEOM: new event id here?
                    "XMatchFD.TitleInfo.GetNextRRIndexForPartition(" + seqNum.ToString("X8")
                    + "): Could not find Partition for type="
                    + bType + " mode=" + bMode
                    + " within Title " + m_dwTitleId.ToString("X8"));
            }
            return (byte)(rri.bMaxAll+1);
        }

        // -------------------------------------------------------------------
        // GetBucketForPartitionAndRRID
        // Given a type, mode, and Round Robin ID, return the bucket.
        // -------------------------------------------------------------------
        public IBucketServer GetBucketForPartitionAndRRID(byte bType, byte bMode, byte bRRID, uint seqNum)
        {
            uint dwBucketID = ((uint)(bType << 16)) | ((uint)(bMode << 8)) | bRRID;  // TODOTHEOM: put these bit masks in a const.
            // GetTitleBucketServer will throw if the bucket is not found.
            try
            {
                return (Config.GetTitleBucketServer(Interface.xmatch, m_dwTitleId, dwBucketID));
            }
            catch (ApplicationException e)// TODO2THEOM: modify config to throw a more specific exception
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_PARAM,
                    XEvent.Id.MATCH_TITLEBUG_34,  // TODO2THEOM: new event id here?
                    "XMatchFD.TitleInfo.GetNextRRIndexForPartition(" + seqNum.ToString("X8")
                    + "): Could not find Partition for type="
                    + bType + " mode=" + bMode
                    + " within Title " + m_dwTitleId.ToString("X8"), e);
            }
        }


        // -------------------------------------------------------------------
        // NextDBIndex, DBCount, and GetDB exist only to support the DeadXbox
        // code path, which needs to open connection to all server for a title.
        // -------------------------------------------------------------------
        public byte NextDBIndex
        {
            get { return (byte)(++m_bDbCounter % DBCount); }
        }

        public byte DBCount
        {
            get { return (byte)m_rgstrDatabases.Length; }
        }

        public string GetDB(byte bIndex)
        {
            return m_rgstrDatabases[bIndex];
        }

        public bool ForceXenonBehavior
        {
            get { return m_fForceXenonBehavior; }
        }

        public uint DeleteDelaySeconds
        {
            get { return m_dwDeleteDelaySeconds; }
        }

        public bool SupportsCrossPlatform
        {
            get { return INVALID_CROSS_PLATFORM_REVOKE != m_bRevokeCrossPlatform; }
        }

        public bool RevokeCrossPlatform
        {
            get { return 1 == m_bRevokeCrossPlatform; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\sessionsearch.cs ===
//
// SessionSearch.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 3/18/2005, pnewson
//

using System;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Caching;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.match.fd
{

// ---------------------------------------------------------------------------
// XMatchClient class - entry point for xbox 1 session search
// ---------------------------------------------------------------------------
public class XMatchClient : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionSearch.ProcessRequest(ctx, MatchXrl.xmatchclient_srf);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// XMatchClient2 class - entry point for xenon session search
// ---------------------------------------------------------------------------
public class XMatchClient2 : IHttpHandler
{
    public void ProcessRequest(HttpContext ctx)
    {
        SessionSearch.ProcessRequest(ctx, MatchXrl.xmatchclient2_ashx);
    }

    // -----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // -----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

// ---------------------------------------------------------------------------
// SessionSearch class - handles session search requests
// ---------------------------------------------------------------------------
public class SessionSearch
{
    // -----------------------------------------------------------------------
    // ProcessRequest - entry point for HTTP request
    // -----------------------------------------------------------------------
    public static void ProcessRequest(HttpContext ctx, MatchXrl matchXrl)
    {
        uint seqNum = MatchApp.NewSeqNum();
        HResult hr = HResult.S_OK;
        MatchSearchMsg matchSearchMsg = new MatchSearchMsg();
        MatchSearchReply matchSearchReply = null;

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
            "XMatchFD.SessionSearch.ProcessRequest(" + seqNum.ToString("X8")
            + "): starting.");

        ValidateRequest(ctx.Request, seqNum);

        // grab the schema version from the http header, before parsing the wiredata.
        // this helps the wiredata parser do its job.
        matchSearchMsg.SchemaVersion = WireData.GetSchemaVersion(ctx.Request);

        matchSearchMsg.ReadFromRequest(ctx.Request);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionSearch.ProcessRequest("
            + seqNum.ToString("X8") + ")\n"
            + matchSearchMsg.ToString(0));

        ValidateMatchSearchMsg(ctx.Request, matchSearchMsg, seqNum);

        string strQueryCacheKey = null;
        matchSearchReply = GetCachedSummaryReply(ctx, matchSearchMsg,
            out strQueryCacheKey);

        // Only go to the database if we didn't find a reply in the cache
        if(matchSearchReply == null)
        {
            string emulatorUrl = GetAlternatePresenceDestinationHeader(ctx, seqNum);

            TitleInfo ti = DBLayer.GetTitleInfo(matchSearchMsg.dwTitleId, seqNum);

            // Add platform type and lock based on parameters, client platform type, 
            // cross platform privilege and title revokation of cross platform privilege
            MatchAttribute []rgParameters = MatchFdUtil.AddPlatformAttributes(
                    ctx,
                    ti,
                    matchSearchMsg.rgParameters);

            SearchResult[] rgResults;
            hr = DBLayer.FindSession(
                    MatchDefs.SearchFlagsNatType(matchSearchMsg.wFlags), 
                    emulatorUrl,
                    matchSearchMsg.dwTitleId, 
                    matchSearchMsg.dwProcedureIndex,
                    matchSearchMsg.ClientAddress, 
                    matchSearchMsg.wNumUsers,
                    rgParameters, 
                    matchSearchMsg.rgWeightedParameters, // this will be a zero-length array except when wFlags has XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT
                    matchXrl, 
                    (matchSearchMsg.wFlags & MatchDefs.XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT) > 0,
                    out rgResults, 
                    seqNum);

            // By past convention, we don't return any reply data if no 
            // sessions were found
            if(rgResults != null && rgResults.Length != 0)
            {
                matchSearchReply = new MatchSearchReply();
                matchSearchReply.dwMessageLength
                    = matchSearchReply.GetBaseSize();
                for(int iResult = 0; iResult < rgResults.Length; iResult++)
                {
                    matchSearchReply.dwMessageLength
                        += rgResults[iResult].dwResultLength;
                }
                matchSearchReply.wNumSearchResults = (ushort)rgResults.Length;
                matchSearchReply.wFlags = 0;
                matchSearchReply.dwLoggingThreshold = 0;
                matchSearchReply.rgResults = rgResults;

                // If this session is one that should be cached, add the
                // current reply to the cache
                if(null != strQueryCacheKey)
                {
                    // Get the cache expiration from NPDB
                    uint dwExpirationMilliseconds = DBLayer.SessionCacheExpiration;

                    // At the specified expiration time the item will be
                    // removed from the cache and the next request for that
                    // query will hit the database
                    ctx.Cache.Insert(strQueryCacheKey, matchSearchReply, null,
                        DateTime.Now.AddMilliseconds(dwExpirationMilliseconds),
                        Cache.NoSlidingExpiration);
                }
            }
        }
        else
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                "XMatchFD.SessionSearch.ProcessRequest(" + seqNum.ToString("X8")
                + "): Replying with cached session for query id="
                + matchSearchMsg.dwProcedureIndex.ToString()
                + ". TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));

            StringBuilder sb = new StringBuilder();
            sb.Append("MatchSearchXboxCached|");
            sb.Append(seqNum.ToString("X8")); sb.Append("|");
            sb.Append(MatchApp.MillisecondsElapsed.ToString()); sb.Append("|");
            sb.Append(hr.ToString()); sb.Append("|");
            sb.Append(matchSearchMsg.dwTitleId.ToString("X8")); sb.Append("|");
            sb.Append(matchSearchMsg.dwProcedureIndex.ToString()); sb.Append("|");
            sb.Append(MatchDefs.SearchFlagsNatType(matchSearchMsg.wFlags).ToString()); sb.Append("|");
            sb.Append(matchSearchMsg.wNumUsers.ToString()); sb.Append("|");
            sb.Append(matchSearchMsg.rgParameters.Length.ToString()); sb.Append("|");
            sb.Append(matchSearchReply.rgResults == null ? "0" : matchSearchReply.rgResults.Length.ToString()); sb.Append("|");
            sb.Append(DBLayer.ByteSwap(matchSearchMsg.ClientAddress.ina).ToString("X8")); sb.Append("|");
            sb.Append(DBLayer.ByteSwap(matchSearchMsg.ClientAddress.inaOnline).ToString("X8")); sb.Append("|");
            sb.Append(DBLayer.ByteSwap(matchSearchMsg.ClientAddress.wPortOnline).ToString()); sb.Append("|");
            sb.Append(DBLayer.ByteSwap(matchSearchMsg.ClientAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
            sb.Append(DBLayer.ByteSwap(matchSearchMsg.ClientAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
            sb.Append(DBLayer.ByteSwap(matchSearchMsg.ClientAddress.sgaddr.qwXboxId).ToString("X16"));

            string line = sb.ToString();

            Xom.Log(XomAreaName.log, line);
            Xom.Log(XomAreaName.Reporting_v2, line);
        }

        // Success, return the sessions
        MatchApp.SendResponse(ctx.Response, matchSearchMsg.dwTitleId,
            hr, matchSearchReply);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.SessionSearch.ProcessRequest("
            + seqNum.ToString("X8") + "): hr = " + hr);
        if (matchSearchReply != null)
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.SessionSearch.ProcessRequest("
                + seqNum.ToString("X8") + ")\n"
                + matchSearchReply.ToString(0));
        }
    }

    // -----------------------------------------------------------------------
    // Checks that the httpRequest is marked for consumption by matchmaking
    // and that it is at least as large as the minimum size for a 
    // MatchSessionMsg.
    // -----------------------------------------------------------------------
    private static void ValidateRequest(HttpRequest httpRequest, uint seqNum)
    {
        MatchSearchMsg matchSearchMsg = new MatchSearchMsg();

        // validate service request on XRL post
        if(!XRLUtil.IsValidXOnlineRequest(httpRequest, XOService.Matchmaking))
        {
            // The service ID in the request is incorrect (all other
            // failures throw an XrlException)
            throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE,
                XEvent.Id.MATCH_HACK_15, 
                "XMatchFD.SessionSearch.ValidateRequest(" + seqNum.ToString("X8")
                + "): Request is invalid.");
        }

        if(httpRequest.InputStream.Length < matchSearchMsg.GetBaseSize())
        {
            // Request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_16,
                "XMatchFD.SessionSearch.ValidateRequest(" + seqNum.ToString("X8")
                + "): Request too small ("
                + httpRequest.InputStream.Length.ToString() + " < "
                + matchSearchMsg.GetBaseSize().ToString() + ")");
        }
    }

    // -----------------------------------------------------------------------
    // Checks that the httpRequest sizes embedded in the matchSearchMsg
    // are the same as reported by the httpRequest, plus additional
    // validity checks on the context of the search request
    // -----------------------------------------------------------------------
    private static void ValidateMatchSearchMsg(
        HttpRequest httpRequest,
        MatchSearchMsg matchSearchMsg,
        uint seqNum)
    {
        if(httpRequest.InputStream.Length < matchSearchMsg.dwMessageLength)
        {
            // Actual size smaller than embedded size
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                XEvent.Id.MATCH_HACK_17,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): Actual size smaller than size embedded in request ("
                + httpRequest.InputStream.Length.ToString()
                + " < " + matchSearchMsg.dwMessageLength.ToString()
                + "). TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
        }

        if(matchSearchMsg.dwMessageLength < httpRequest.InputStream.Position)
        {
            // Size in request too small
            throw new XRLException(
                HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                XEvent.Id.MATCH_HACK_18,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): Size embedded in request is smaller than data read ("
                + matchSearchMsg.dwMessageLength.ToString() + " < "
                + httpRequest.InputStream.Position.ToString()
                + "). TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
        }

        if(!MatchDefs.AreSearchFlagsValid(matchSearchMsg.wFlags))
        {
            // Invalid flags were passed in
            throw new XRLException(HResult.XONLINE_E_MATCH_INVALID_FLAGS,
                XEvent.Id.MATCH_HACK_19,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): Invalid flags - 0x"
                + matchSearchMsg.wFlags.ToString("X4")
                + ". TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
        }

        if(0 == matchSearchMsg.wNumUsers)
        {
            // No users were passed in
            throw new XRLException(HResult.XONLINE_E_MATCH_NO_USERS,
                XEvent.Id.MATCH_HACK_21,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): No users. TitleID=0x"
                + matchSearchMsg.dwTitleId.ToString("X8"));
        }

        if(MatchDefs.X_MATCH_MAX_QUERY_PARAMS < (matchSearchMsg.dwNumParameters + matchSearchMsg.dwNumWeightedParameters))
        {
            throw new XRLException(HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                XEvent.Id.MATCH_HACK_SEARCH_NUM_PARAMS,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): Too many parameters ("
                + matchSearchMsg.dwNumParameters.ToString() + " > "
                + MatchDefs.X_MATCH_MAX_QUERY_PARAMS.ToString()
                + "). TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
        }

        if (MatchDefs.X_MATCH_MAX_WEIGHTED_QUERY_PARAMS_PER_REQ < matchSearchMsg.dwNumWeightedParameters)
        {
            throw new XRLException(HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                XEvent.Id.MATCH_HACK_SEARCH_NUM_PARAMS,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): Too many weighted parameters ("
                + matchSearchMsg.dwNumWeightedParameters.ToString() + " > "
                + MatchDefs.X_MATCH_MAX_WEIGHTED_QUERY_PARAMS_PER_REQ.ToString()
                + "). TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
        }

        // Validate that the parameter offsets are correct
        uint dwParamOffset = matchSearchMsg.GetBaseSize()
            + (4 * matchSearchMsg.dwNumParameters);
        for(int iParam = 0; iParam < matchSearchMsg.dwNumParameters; iParam++)
        {
            if(dwParamOffset != matchSearchMsg.rgdwParamOffsets[iParam])
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_OFFSET,
                    XEvent.Id.MATCH_HACK_22,
                    "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                    + "): Parameter offset is invalid ("
                    + dwParamOffset.ToString() + " != "
                    + matchSearchMsg.rgdwParamOffsets[iParam].ToString()
                    + ", param=" + iParam.ToString()
                    + "). TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
            }
            dwParamOffset += matchSearchMsg.rgParameters[iParam].GetSize();
        }

        if (!MatchDefs.IsWeightedSortFlagSet(matchSearchMsg.wFlags) &&
            (matchSearchMsg.dwNumWeightedParameters > 0))
        {
            throw new XRLException(HResult.XONLINE_E_MATCH_INVALID_PARAM, 
                XEvent.Id.MATCH_HACK_SEARCH_NUM_PARAMS,
                "XMatchFD.SessionSearch.ValidateMatchSearchMsg(" + seqNum.ToString("X8")
                + "): Weighted params passed without the XONLINE_MATCH_SEARCH_FLAG_WEIGHTEDSORT flag. " 
                + "TitleID=0x" + matchSearchMsg.dwTitleId.ToString("X8"));
        }        
    }

    // -----------------------------------------------------------------------
    // Checks the cache of HttpContext for a cached reply to a summary query.
    // The key used to check the cache is returned in strQueryCacheKey
    // If the query is not a summary query, strQueryCacheKey will be null.
    // If the query is not a summary query, or if the summary query is not
    // in the cache, the return value will be null. If the query is a summary
    // query and is in the cache, the cached MatchSearchReply is returned.
    // -----------------------------------------------------------------------
    private static MatchSearchReply GetCachedSummaryReply(
        HttpContext ctx,
        MatchSearchMsg matchSearchMsg,
        out string strQueryCacheKey)
    {
        strQueryCacheKey = null;
        MatchSearchReply matchSearchReply = null;

        // Only Summary queries are cached
        if (MatchDefs.IsSearchSummaryQuery(matchSearchMsg.dwProcedureIndex))
        {
            // Build up a unique key that represents this query and its 
            // parameters
            strQueryCacheKey = matchSearchMsg.dwTitleId.ToString("X8")
                + ":" + matchSearchMsg.dwProcedureIndex;
            foreach(MatchAttribute param in matchSearchMsg.rgParameters)
            {
                // NOTE: Summary queries only have integer parameters
                strQueryCacheKey += ":" + param.dwAttributeId.ToString("X8")
                    + ":" + param.qwValue.ToString();
            }

            // Look for previous results for this query
            // NOTE: As a special case for testing, we allow a flag that turns
            // off the cache for this request only, however we still want to
            // build the key so that we can take the latest results from this
            // query and put those in the cache.
            if(!MatchDefs.IsSearchFlagNoCacheSet(matchSearchMsg.wFlags))
            {
                matchSearchReply
                    = (MatchSearchReply)ctx.Cache.Get(strQueryCacheKey);
            }
        }
        return matchSearchReply;
    }

    // -----------------------------------------------------------------------
    // Returns the value of the X-PresenceEmulator header, or null if the
    // header was not provided in the http request. This is used to redirect
    // a match request to the presence emulator during stress.
    // -----------------------------------------------------------------------
    private static string GetAlternatePresenceDestinationHeader(
        HttpContext ctx,
        uint seqNum)
    {
        string url = ctx.Request.Headers[MatchDefs.AlternatePresenceDestinationHeaderName];
        if (url != null)
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW,
                "XMatchFD.SessionSearch.ProcessRequest(" + seqNum.ToString("X8")
                + "): found " + MatchDefs.AlternatePresenceDestinationHeaderName
                + " http header, value: " + url);
        }
        return url;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\titlechange.cs ===
//
// TitleChange.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//
// Reviewed: 3/21/2005, pnewson
//

using System;
using System.Collections;
using System.IO;
using System.Web;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.match.fd
{

// --------------------------------------------------------------------------
// TitleChange class - handles title change requests
// --------------------------------------------------------------------------
public class TitleChange : IHttpHandler
{
    // ----------------------------------------------------------------------
    // ProcessRequest - entry point for HTTP request
    // ----------------------------------------------------------------------
    public void ProcessRequest(HttpContext ctx)
    {
        uint seqNum = MatchApp.NewSeqNum();
        HResult hr = HResult.S_OK;

        TitleChangePerfCountersStart();
        try
        {
            CSgMsgNotifyCliTitleChange request = new CSgMsgNotifyCliTitleChange();

             Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                + "): starting.");

            if(!XRLUtil.IsValidXOnlineRequest(
                ctx.Request, XOService.Matchmaking))
            {
                // The service ID in the request is incorrect (all other
                // failures throw an XrlException)
                throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE,
                    XEvent.Id.MATCH_HACK_23, 
                    "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                    + "): Request has invalid service id.");
            }

            // The data for a title change request is an array of
            // CSgMsgNotifyCliTitleChange structures.
            // First we make sure there's at least enough data to fill
            // one CSgMsgNotifyCliTitleChange structure.
            if(ctx.Request.InputStream.Length < request.Size())
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_REQUEST_TOO_SMALL,
                    XEvent.Id.MATCH_HACK_24,
                    "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                    + "): Request too small ("
                    + ctx.Request.InputStream.Length.ToString()
                    + " < " + request.Size().ToString() + ")");
            }

            if(0 != ctx.Request.InputStream.Length % request.Size())
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                    XEvent.Id.MATCH_HACK_25,
                    "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                    + "): Request size is not "
                    + "a multiple of CSgMsgNotifyCliTitleChange size ("
                    + ctx.Request.InputStream.Length.ToString() + ", "
                    + request.Size().ToString() + ")");
            }

            BinaryReader reader = new BinaryReader(ctx.Request.InputStream);

            request.ReadStream(reader);

            // Callers will batch up requests, find out how many we have
            uint dwMsgCount 
                = (uint)(ctx.Request.TotalBytes / request.header._cbEnt);

            Exception lastException = null;
            Exception lastLoggableException = null;
            for(int iMsg = 0; iMsg < dwMsgCount; iMsg++)
            {
                // On the first pass we already read in the message above
                if(0 != iMsg)
                {
                    // Read the next message from the input stream
                    // Note that below, we passed a reference to
                    // request._sgaddr to a new DeadXboxMsg object.
                    // We don't want to change the value of that SGADDR
                    // object, so we create a new request here.
                    request = new CSgMsgNotifyCliTitleChange();
                    request.ReadStream(reader);
                }

                if(request.header._cbEnt != request.Size())
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                        XEvent.Id.MATCH_HACK_26,
                        "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Size contained in request is incorrect ("
                        + request.header._cbEnt.ToString()
                        + " != " + request.Size().ToString() + ")");
                }

                if((ushort)SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG
                    != request.header._wType)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_REQUEST_TRUNCATED,
                        XEvent.Id.MATCH_HACK_27,
                        "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Request has unexpected type ("
                        + request.header._wType.ToString() + " != "
                        + SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG.ToString()
                        + ")");
                }

                try
                {
                    // Fill in the data from this message that the DB layer expects
                    TitleInfo ti = DBLayer.GetTitleInfo(request._dwOldTitleId, seqNum, true /* nothrow */);
                    if (ti != null)
                    {
                        // update the perf counters first, because DBLayer may throw
                        TitleChangeRecordPerfCounters(true);
                        // DBLayer.DeadXbox always throws on error, so this hr is most likely ignored.
                        // But leaving it here just in case.
                        hr = DBLayer.DeadXbox(ti, request._sgaddr, "TitleChange", seqNum); 
                    }
                    else
                    {
                        TitleChangeRecordPerfCounters(false);
                    }
                }
                catch(Exception e)
                {
                   Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                        "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Unexpected Exception: " + e.Message);
                    lastException = e;

                    // grab a copy of the exception if it's loggable
                    if (!(e is ExceptionWithoutEvent))
                    {
                        lastLoggableException = e;
                    }
                    // don't rethrow, continue processing through the list of requests
                }
            }

            if (lastException != null)
            {
                // We've finished processing all the titlechanges and something went wrong somewhere. 

                // update the app level failure counters here, because we know the failures at this point are from the app level.
                MatchTitleChangeCounters.Counters.TotalRequestsTitleChangeFailed.Increment();
                MatchTitleChangeCounters.Counters.RequestsPerSecTitleChangeFailed.Increment();

                if (lastLoggableException == null)
                {
                    // all the exceptions were "ExceptionWithoutEvent".  Throw an XRLExceptionWithoutEvent for the last exception.
                    hr = XRLException.ToHResult(lastException, HResult.XONLINE_E_MATCH_SERVER_ERROR);
                    throw new XRLExceptionWithoutEvent(
                        hr,
                        "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Failure when executing some portion of a titlechange batch.  See exception for details.", lastException);
                }
                else
                {
                    // get the hr from the exception, or use a default value 
                    hr = XRLException.ToHResult(lastLoggableException, HResult.XONLINE_E_MATCH_SERVER_ERROR);
                    throw new XRLException(
                        hr,
                        XEvent.Id.MATCH_CODE_TITLECHANGE_ERROR,
                        "XMatchFD.TitleChange.ProcessRequest(" + seqNum.ToString("X8")
                        + "): Failure when executing some portion of a titlechange batch.  See exception for details.", lastLoggableException);
                }
            }


            MatchApp.SendResponse(ctx.Response, 0, hr, null);

            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW, "XMatchFD.TitleChange.ProcessRequest("
                + seqNum.ToString("X8") + "): hr = " + hr);
        }
        finally
        {
            TitleChangePerfCountersEnd();
        }
     }

    // ----------------------------------------------------------------------
    // TitleChangePerfCountersStart - updates perf counters at the start
    // of a title change operation
    // ----------------------------------------------------------------------
    private static void TitleChangePerfCountersStart()
    {
        MatchTitleChangeCounters.Counters.RequestsInProgressTitleChange.Increment();
        MatchTitleChangeCounters.Counters.AverageRecordsPerRequestBaseTitleChange.Increment();
        MatchTitleChangeCounters.Counters.AverageRecordsPerRequestBaseTitleChangeMatch.Increment();
        MatchTitleChangeCounters.Counters.AverageRecordsPerRequestBaseTitleChangeNonMatch.Increment();
     }

    // ----------------------------------------------------------------------
    // TitleChangePerfCountersEnd - updates perf counters at the end
    // of a title change operation
    // ----------------------------------------------------------------------
    private static void TitleChangePerfCountersEnd()
    {
        MatchTitleChangeCounters.Counters.RequestsInProgressTitleChange.Decrement();
        MatchTitleChangeCounters.Counters.TotalRequestsTitleChange.Increment();
        MatchTitleChangeCounters.Counters.RequestsPerSecTitleChange.Increment();
        MatchTitleChangeCounters.Counters.AverageExecutionTimeTitleChange.IncrementBy(MatchApp.TimeElapsed);
        MatchTitleChangeCounters.Counters.AverageExecutionTimeBaseTitleChange.Increment();
     }

    // ----------------------------------------------------------------------
    // TitleChangeRecordPerfCounters - updates perf counters for each title change 
    // record in the dead xbox request
    // ----------------------------------------------------------------------
    private static void TitleChangeRecordPerfCounters(bool isMatchTitle)
    {
        MatchTitleChangeCounters.Counters.TotalRecordsTitleChange.Increment();
        MatchTitleChangeCounters.Counters.RecordsPerSecTitleChange.Increment();
        MatchTitleChangeCounters.Counters.AverageRecordsPerRequestTitleChange.Increment();
        if (isMatchTitle)
        {
            MatchTitleChangeCounters.Counters.TotalRecordsTitleChangeMatch.Increment();
            MatchTitleChangeCounters.Counters.RecordsPerSecTitleChangeMatch.Increment();
            MatchTitleChangeCounters.Counters.AverageRecordsPerRequestTitleChangeMatch.Increment();
        }
        else
        {
            MatchTitleChangeCounters.Counters.TotalRecordsTitleChangeNonMatch.Increment();
            MatchTitleChangeCounters.Counters.RecordsPerSecTitleChangeNonMatch.Increment();
            MatchTitleChangeCounters.Counters.AverageRecordsPerRequestTitleChangeNonMatch.Increment();
        }
     }

    // ----------------------------------------------------------------------
    // IsReusable - allow reuse of this instance
    // ----------------------------------------------------------------------
    public bool IsReusable
    {
        get { return true; }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\dvt\RatingDist.cs ===
using System;

namespace xonline.server.match.test.dvt
{
    public partial class Util
    {
        // 52 buckets, rating starts at 50 and usually trends 
        // upwards and stays in the upper range, negative
        // feedback can move rating down
        static double []ratingDist = new double[] {
            4.13138E-05, 4.82676E-05, 3.76324E-05, 0.000136213,
            7.28104E-05, 0.012333594, 0.000256064, 0.006064535,
            0.001561334, 0.592345498, 0.009696057, 0.00815804,
            0.00662943, 0.006510806, 0.005071369, 0.004510156,
            0.004544925, 0.003862225, 0.003785733, 0.003596753,
            0.003179116, 0.003143938, 0.003271151, 0.002954549,
            0.002932869, 0.00284656, 0.00277784, 0.002734481,
            0.00271362, 0.002665761, 0.002651854, 0.002648172,
            0.00262772, 0.002743889, 0.002696031, 0.002761478,
            0.002855968, 0.003022042, 0.00311735, 0.003307966,
            0.003487537, 0.00369697, 0.004215642, 0.004543288,
            0.005246032, 0.006039993, 0.007305176, 0.009929214,
            0.014232392, 0.026170847, 0.117788445, 0.070429357
        };

        public static float RandomRating()
        {
            Random rand = new Random();
            double remain = rand.NextDouble();
            double rating = 100.0;
            uint bucket = 0;

            while(bucket < ratingDist.Length && remain > 0)
            {
                remain -= ratingDist[bucket];
                if(remain < 0)
                {
                    // Add some jitter in the bucket
                    rating = ((double)bucket + 48) + rand.NextDouble();
                    if(rating > 100.0)
                    {
                        rating = 100.0;
                    }

                    break;
                }
                bucket++;
            }

            return (float)rating;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\dvt\MatchDVT.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.IO;
using System.Threading;
using System.Xml;
using System.Diagnostics;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.diagnostics;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.match;
using xonline.tools.framework;

using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.LiveService.FakeSG;
using PresNotiCommon = ServerTestFramework.LiveService.PresNotiCommon;
using Presence = ServerTestFramework.LiveService.Presence;
using Notification = ServerTestFramework.LiveService.Notification;
using STFUtil = ServerTestFramework.Utilities;
using PresenceTest;

[assembly: RootNode(typeof(xonline.server.match.test.dvt.Suite))]

namespace xonline.server.match.test.dvt
{
    public class Suite : TestNode
    {
        public Suite()
        {
            AddChild(typeof(StressCreateSession));
            AddChild(typeof(StressUpdateSession));
            AddChild(typeof(StressDeleteSession));
            AddChild(typeof(StressSplitSession));
            AddChild(typeof(StressSearch));
            AddChild(typeof(StressSearchDirect));
        }

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                Config.ComponentName = "matchdvt";

                // Let the fake SG know where to send state updates
                IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xpnfd_presence);
                string endpoint = viInfo.IPAddressString + ":" + viInfo.Port.ToString();
                GlobalFakeSG.FakeSG.SetStateEndpoint(endpoint);

                // Setup default log targets
                XomLoggingControl.Init();
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                // Turn off debug and info spew from the session object
                Session.RO.SetLevelFilter(Report.FATAL|Report.ERROR);
            }
        }
    }

    [TestGroup, DVT]
    public class MatchDVT: TestNode
    {
        public const uint TITLEID = 0xffff2003;
        public const uint INTPROPERTYID = 0x10000001;

        [TestGroupSetup]
        public void Setup()
        {
            MatchReq.FindAndCleanupAllSessions(TITLEID);
            MatchReq.ClearSessionsForCleanup();
        }

        [TestGroupTearDown]
        public void TearDown()
        {
            MatchReq.CleanupSessions(); 
        }

        struct PackTestData<T>
        {
            public PackTestData(T i, ulong o)
            {
                Input = i;
                Output = o;
            } 

            public T Input;
            public ulong Output;
        }

        [TestCase]
        public void MatchAttributePackaging()
        {
            List<PackTestData<double>> doubleTestData = new List<PackTestData<double>>();
            List<PackTestData<float>> floatTestData = new List<PackTestData<float>>();

            doubleTestData.Add(new PackTestData<double>(1.0000000000000000E+000,     0x3FF0000000000000));
            doubleTestData.Add(new PackTestData<double>(1.5000000000000000E+001,     0x402E000000000000));
            doubleTestData.Add(new PackTestData<double>(2.5500000000000000E+002,     0x406FE00000000000));
            doubleTestData.Add(new PackTestData<double>(4.2949672950000000E+009,     0x41EFFFFFFFE00000));
            doubleTestData.Add(new PackTestData<double>(3.9062500000000000E-003,     0x3F70000000000000));
            doubleTestData.Add(new PackTestData<double>(2.3283064365386963E-010,     0x3DF0000000000000));
            doubleTestData.Add(new PackTestData<double>(1.2345678901230000E-300,     0x01AA74FE1C1E7E45));
            doubleTestData.Add(new PackTestData<double>(1.2345678901234500E-150,     0x20D02A36586DB4BB));
            doubleTestData.Add(new PackTestData<double>(1.2345678901234565E+000,     0x3FF3C0CA428C59FA));
            doubleTestData.Add(new PackTestData<double>(1.2345678901234567E+000,     0x3FF3C0CA428C59FB));
            doubleTestData.Add(new PackTestData<double>(1.2345678901234569E+000,     0x3FF3C0CA428C59FC));
            doubleTestData.Add(new PackTestData<double>(1.2345678901234569E+150,     0x5F182344CD3CDF9F));
            doubleTestData.Add(new PackTestData<double>(1.2345678901234569E+300,     0x7E3D7EE8BCBBD352));
            doubleTestData.Add(new PackTestData<double>(-1.7976931348623157E+308,    0xFFEFFFFFFFFFFFFF));
            doubleTestData.Add(new PackTestData<double>(1.7976931348623157E+308,     0x7FEFFFFFFFFFFFFF));
            doubleTestData.Add(new PackTestData<double>(4.9406564584124654E-324,     0x0000000000000001));
            doubleTestData.Add(new PackTestData<double>(double.NaN,                  0xFFF8000000000000));
            doubleTestData.Add(new PackTestData<double>(double.NegativeInfinity,     0xFFF0000000000000));
            doubleTestData.Add(new PackTestData<double>(double.PositiveInfinity,     0x7FF0000000000000));

            floatTestData.Add(new PackTestData<float>(1.0000000e+00f,                0x000000003F800000));
            floatTestData.Add(new PackTestData<float>(1.5000000e+01f,                0x0000000041700000));
            floatTestData.Add(new PackTestData<float>(2.5500000e+02f,                0x00000000437F0000));
            floatTestData.Add(new PackTestData<float>(4.2949672e+09f,                0x000000004F800000));
            floatTestData.Add(new PackTestData<float>(3.9062500e-03f,                0x000000003B800000));
            floatTestData.Add(new PackTestData<float>(2.3283064e-10f,                0x000000002F800000));
            floatTestData.Add(new PackTestData<float>(1.2345678e-20f,                0x000000001E693409));
            floatTestData.Add(new PackTestData<float>(1.2345678e-30f,                0x000000000DC851F1));
            floatTestData.Add(new PackTestData<float>(1.2345678e-40f,                0x0000000000015826));
            floatTestData.Add(new PackTestData<float>(1.2345678e+00f,                0x000000003F9E0651));
            floatTestData.Add(new PackTestData<float>(1.2345678e+00f,                0x000000003F9E0651));
            floatTestData.Add(new PackTestData<float>(1.2345678e+00f,                0x000000003F9E0651));
            floatTestData.Add(new PackTestData<float>(1.2345678e+10f,                0x000000005037F706));
            floatTestData.Add(new PackTestData<float>(1.2345678e+20f,                0x0000000060D629D3));
            floatTestData.Add(new PackTestData<float>(1.2345678e+30f,                0x00000000717951A9));
            floatTestData.Add(new PackTestData<float>(3.40282306e+38f,               0x000000007F7FFFFD));
            floatTestData.Add(new PackTestData<float>(-1.7976931e+38f,               0x00000000FF073E4F));
            floatTestData.Add(new PackTestData<float>(1.7976931e+38f,                0x000000007F073E4F));
            floatTestData.Add(new PackTestData<float>(4.9406564e-45f,                0x0000000000000004));
            floatTestData.Add(new PackTestData<float>(float.NaN,                     0x00000000FFC00000));
            floatTestData.Add(new PackTestData<float>(float.NegativeInfinity,        0x00000000FF800000));
            floatTestData.Add(new PackTestData<float>(float.PositiveInfinity,        0x000000007F800000));

            MatchAttribute attr = new MatchAttribute();
            foreach(PackTestData<double> test in doubleTestData)
            {
                attr.FromDouble(test.Input);
                STFUtil.ValueCheck.Test("FromDouble", test.Output, attr.qwValue);
                STFUtil.ValueCheck.Test("ToDouble", test.Input, attr.ToDouble());
            }
            foreach(PackTestData<float> test in floatTestData)
            {
                attr.FromSingle(test.Input);
                STFUtil.ValueCheck.Test("FromSingle", test.Output, attr.qwValue);
                STFUtil.ValueCheck.Test("ToSingle", test.Input, attr.ToSingle());
            }
        }

        [TestCase]
        public void ConfigureTitle()
        {
            LiveTitle liveTitle = null;
            string thispath = Path.GetFullPath(".");
            string titleid = TITLEID.ToString("x");
            string []paths = new string[] {
                "..\\tools\\titlesuite\\",
                    "..\\..\\tools\\titlesuite\\",
                    ".\\",
                    "suites\\",
                    "\\webroot\\xbltools\\",
                    "notfound"
            };

            // Find livetitle first
            foreach(string path in paths)
            {
                if("notfound" == path)
                {
                    throw new UnexpectedTestResultException("Could not find the livetitle.exe in the search paths");
                }

                string fullpath = path + "livetitle.exe";
                if(File.Exists(fullpath))
                {
                    liveTitle = new LiveTitle(fullpath);
                    break;
                }
            }


            // Make sure we have config files
            foreach(string path in paths)
            {
                if("notfound" == path )
                {
                    throw new UnexpectedTestResultException("No title configuration files for: " + titleid);
                }

                string ltc_fullpath = path + titleid + "_ltc.xml";
                string xlast_fullpath = path + titleid + ".xlast";

                // Just prop the xlast and ltc files
                if(File.Exists(ltc_fullpath) && File.Exists(xlast_fullpath))
                {
                    Debug.Assert(null != liveTitle);

                    liveTitle.WorkingDirectory = thispath;
                    liveTitle.LTCPath = ltc_fullpath;
                    liveTitle.XlastPath = xlast_fullpath;
                    liveTitle.DeployXbox360Title(TITLEID, false, false);

                    Global.RO.Debug("LiveTitle output: " + liveTitle.Output);
                    break;
                }
            }

            // ConfigureTitle relies on liveTitle succeeding
            Global.RO.Info("Calling MatchAdmin.ConfigureTitle generate tables and stored procs");
            MatchAdmin.ConfigureTitle(TITLEID, true, true, null);
        }

        [TestCase]
        public void HealthCheck()
        {
            MatchAdmin.HealthCheck();
        }

        [TestCase]
        public void ReloadTitleInfo()
        {
            MatchAdmin.ReloadTitleInfo();
        }

        [TestCase]
        public void GetAllGameConfigs()
        {
            Global.RO.Info("Calling MatchAdmin.GetAllGameConfigs");
            string[] gameConfigs = MatchAdmin.GetAllGameConfigs(new DateTime(2000, 1, 1));
            Global.RO.Info(gameConfigs.Length + " game configurations found");
        }

        [TestCase]
        public void GetAllMatchGameConfigs()
        {
            Global.RO.Info("Calling MatchAdmin.GetAllMatchGameConfigs");
            MatchGameConfig[] matchGameConfigs
                = MatchAdmin.GetAllMatchGameConfigs(new DateTime(2000,1,1));
            Global.RO.Info(matchGameConfigs.Length + " matchmaking configurations found");
            foreach (MatchGameConfig matchGameConfig in matchGameConfigs)
            {
                Global.RO.Info("titleid " + matchGameConfig.TitleId.ToString("X8")
                        + " has " + matchGameConfig.MatchQueries.Count
                        + " match queries.");
            }
        }

        [TestCase]
        public void BaseCaseRanked()
        {
            try
            {
                Session s = new Session();
                s.AttributeCollection.GenerateRankedAttributes();  
                s.dwPublicFilled = 0;
                s.dwPrivateFilled = 0;
                s.GamerPuid = 1234;
                s.GamerHostname = "user0";
                s.SetupSGInfo();

                s.Advertise();

                s.dwPublicOpen = 7;
                s.dwPrivateOpen = 7;
                s.dwPublicFilled = 1;
                s.dwPrivateFilled = 1;

                // set the game type attribute to NULL - you can't change it on update
                s.AttributeCollection.Remove(MatchDefs.X_ATTRIBUTE_GAME_TYPE);

                Global.RO.Info("Updating ranked session");
                s.Update();
                s.ValidateExistsOnServer(); 

                SessionCollection scol = new SessionCollection();
                scol.SearchTemplate = s;
                scol.SearchTemplate.GameType = MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED;
                scol.Search();
                scol.ValidateContains(s);
            }
            finally
            {
                MatchReq.CleanupSessions();
            }
        }

        [TestCase]
        public void BaseCaseStandard()
        {
            try
            {
                // Create some friends to get some affiliate value in the session
                // search results
                Presence.FriendsCommon fc = new Presence.FriendsCommon();
                PresNotiCommon.PNUser user1 = fc.CreateXenonUser(false);
                PresNotiCommon.PNUser user2 = fc.CreateXenonUser(false);
                user1.Xbox.ChangeTitle(TITLEID, 0, 0);
                user2.Xbox.ChangeTitle(TITLEID, 0, 0);
                fc.LogonUser(user1);
                fc.LogonUser(user2);
                fc.MakeFriend(user1, user2);

                Session s = new Session();
                s.AttributeCollection.GenerateStandardAttributes();  
                s.dwPublicFilled = 0;
                s.dwPrivateFilled = 0;
                s.GamerPuid = user1.UserId;
                s.GamerHostname = user1.Name;
                s.SetupSGInfo();
                s.Advertise();

                s.dwPublicOpen = 7;
                s.dwPrivateOpen = 7;
                s.dwPublicFilled = 1;
                s.dwPrivateFilled = 1;

                // set the game type attribute to NULL - you can't change it on update
                s.AttributeCollection.Remove(MatchDefs.X_ATTRIBUTE_GAME_TYPE);
                s.Update();
                s.ValidateExistsOnServer(); 

                SessionCollection scol = new SessionCollection();
                scol.SearchTemplate = s;
                scol.SearchTemplate.GamerPuid = user2.UserId;
                scol.SearchTemplate.GameType = MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD;
                scol.Search();
                scol.ValidateContains(s);
                scol.ValidateAffiliateValue(s, 4);
            }
            finally
            {
                MatchReq.CleanupSessions();
            }
        }

        [TestCase]
        public void AlternatePresenceDestination()
        {
            try
            {
                // create a user so we have a valid puid to pass in the match requests
                Presence.FriendsCommon fc = new Presence.FriendsCommon();
                PresNotiCommon.PNUser primary = fc.CreateXenonUser(false);
                primary.Xbox.ChangeTitle(TITLEID, 0, 0);
                fc.LogonUser(primary);
                primary.SetTitleData((ulong)0);

                Session s = new Session();
                s.GamerPuid = primary.UserId;
                s.SetupSGInfo();
                s.Advertise();

                SessionCollection scol = new SessionCollection();

                // Use the real presence server for the alternate presence definition... this way the
                // call should succeed. However you need to examine the trace messages to confirm the
                // alternate destination was actually used.
                IVirtualInterfaceInfo viinfo =
                    Config.GetVirtualInterface(VirtualInterface.xpnfd_presence_int);
                scol.PresenceDestination = viinfo.Url.ToString() + "xpnfront/xpresence.srf";
                scol.SearchTemplate = s;

                Global.RO.Info("Searching for standard session using AlternatePresenceDestination header: {0}",
                        scol.PresenceDestination);

                scol.Search();
                scol.ValidateContains(s);
            }
            finally
            {
                MatchReq.CleanupSessions();
            }
        }
        

        [TestCase]
        public void AffiliatesMatch()
        {
            try
            {
                Presence.FriendsCommon fc = new Presence.FriendsCommon();

                // this is the user who will be performing the match query
                PresNotiCommon.PNUser primary = fc.CreateXenonUser(false);
                primary.Xbox.ChangeTitle(TITLEID, 0, 0);
                fc.LogonUser(primary);
                primary.SetTitleData((ulong)0);

                // At this point, no users are affiliated to primary in any way
                // therefore, affiliates should have no effect on the sessions
                // returned by a match query.

                // Create 100 sessions in matchdb. The test query we're going to use
                // orders the returned sessions by attribute 0x10000001 in ascending
                // order, which we set to the index of the session in the sessionIds
                // array. With no affiliates, the sessionIds in sessionIds[0] to 
                // sessionIds[24] should be returned by the query. From this baseline,
                // we can put affiliates into these sessionIds, and look for the expected
                // changes in the result set.
                int sessionCount = 30;
                Session[] sessions = new Session[sessionCount];
                Global.RO.Info("Creating " + sessionCount + " standard sessions");
                for (int i = 0; i < sessionCount; ++i)
                {
                    Session s = sessions[i] = new Session();
                    s.AttributeCollection.GenerateStandardAttributes();
                    s.AttributeCollection.Add(new MatchAttribute(INTPROPERTYID, (ulong)i));
                    s.GamerPuid = new STFUtil.RandomEx().NextPuid();
                    s.SetupSGInfo();
                    s.Advertise();
                }

                // No affiliates yet, so a query should return sessionIds[0] to sessionIds[24]
                // because we have an order by clause on INTPROPERTYID
                SessionCollection scol = new SessionCollection();
                scol.SearchTemplate.AttributeCollection.GenerateStandardAttributes();
                scol.SearchTemplate.GamerPuid = primary.UserId;
                scol.SearchTemplate.SetupSGInfo();
                scol.Search();

                // we expect to see 25 search results that correspond to the first 25 sesisons in
                // the sessionIds array
                uint expectedResultCount = 25;
                STFUtil.ValueCheck.Test("Search result count", expectedResultCount, scol.Results.Count);
                for (int i = 0; i < expectedResultCount; ++i)
                {
                    Session s = scol.Results[i];
                    MatchAttribute attr = s.AttributeCollection[MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE];
                    STFUtil.ValueCheck.Test("Affiliate value", (ulong)0, attr.qwValue);

                    attr = s.AttributeCollection[INTPROPERTYID];
                    STFUtil.ValueCheck.Test("Int property value", (ulong)i, attr.qwValue);
                }

                // There are five affiliate types that match cares about:
                //
                // AffiliateFlags.CompletedGame
                // AffiliateFlags.PositiveFeedback
                // AffiliateFlags.NegativeFeedback
                // AffiliateFlags.AvoidingMe
                // AffiliateFlags.Friend
                //
                // Match does not care about these flags:
                // AffiliateFlags.Encountered
                // AffiliateFlags.Block
                // AffiliateFlags.Mute
                //
                // Since multiple flags can be set at the same time, you would think 
                // there are 32 possible combinations of affilications that match cares 
                // about. However, PositiveFeedback and NegativeFeedback are mutually
                // exclusive, and therefore there are actually only 24 combinations.

                // The users below will be placed in the same title as the primary
                // user, and are therefore candidates to be matched against. If all the
                // affiliations were independant, there would be 2^5 or 32 possible
                // affiliation states. However, it is not possible to submit both
                // positive and negative feedback on another user. Whatever action
                // was taken most recently is the state. This eliminates 8 possible
                // state combinations. We want to be able to look at the index into
                // the array that follows, and know by the bits in the array what
                // affiliations we expect that user to have. Therefore we assign
                // positive feedback to bit 3 (zero based), and negative feedback
                // to bit 4 (zero based), and chop off the last 8 entries, which would
                // be invalid anyway, because both bits 4 and 5 would be set.

                // create the 24 users, and sign them into the same title as
                // the primary user, but set their match session id to 0
                Global.RO.Info("Creating/logon/logoff on 24 Users");
                PresNotiCommon.PNUser[] sameTitle = new PresNotiCommon.PNUser[24];
                for (int i = 0; i < sameTitle.Length; ++i)
                {
                    sameTitle[i] = fc.CreateXenonUser(false);
                    sameTitle[i].Xbox.ChangeTitle(primary.Xbox.TitleId, 0, 0);
                    fc.LogonUser(sameTitle[i]);
                    sameTitle[i].SetTitleData((ulong)0);
                    fc.LogoffUser(sameTitle[i]);
                }

                // now set up the affiliations
                AffiliateState state = new AffiliateState(primary);
                state.SetAddPostSleep(0);
                int affiliationCount = 0;
                for (int i = 0; i < sameTitle.Length; ++i)
                {
                    // to get all possible combinations of affiliations that we care about
                    // we use the bits of i as flags:
                    // bit 0 - AffiliateFlags.CompletedGame
                    // bit 1 - AffiliateFlags.AvoidingMe
                    // bit 2 - AffiliateFlags.Friend
                    // bit 3 - AffiliateFlags.PositiveFeedback
                    // bit 4 - AffiliateFlags.NegativeFeedback
                    if ((i & 0x0001) != 0)
                    {
                        Global.RO.Info("Making " + sameTitle[i].UserId.ToString("X16")
                                + " a CompletedGame affiliate of " + primary.UserId.ToString("X16"));
                        state.Add(sameTitle[i],
                                (uint)AffiliateFlags.CompletedGame, primary.Xbox.TitleId);
                        ++affiliationCount;
                    }
                    if ((i & 0x0002) != 0)
                    {
                        Global.RO.Info("Making " + sameTitle[i].UserId.ToString("X16")
                                + " a AvoidingMe affiliate of " + primary.UserId.ToString("X16"));
                        state.Add(sameTitle[i],
                                (uint)AffiliateFlags.AvoidingMe, primary.Xbox.TitleId);
                    }
                    if ((i & 0x0004) != 0)
                    {
                        Global.RO.Info("Making " + sameTitle[i].UserId.ToString("X16")
                                + " a Friend affiliate of " + primary.UserId.ToString("X16"));
                        fc.MakeFriend(primary, sameTitle[i]);
                        ++affiliationCount;
                    }
                    if ((i & 0x0008) != 0)
                    {
                        Global.RO.Info("Making " + sameTitle[i].UserId.ToString("X16")
                                + " a PositiveFeedback affiliate of " + primary.UserId.ToString("X16"));
                        state.Add(sameTitle[i],
                                (uint)AffiliateFlags.PositiveFeedback, primary.Xbox.TitleId);
                        ++affiliationCount;
                    }
                    if ((i & 0x0010) != 0)
                    {
                        Global.RO.Info("Making " + sameTitle[i].UserId.ToString("X16")
                                + " a NegativeFeedback affiliate of " + primary.UserId.ToString("X16"));
                        state.Add(sameTitle[i],
                                (uint)AffiliateFlags.NegativeFeedback, primary.Xbox.TitleId);
                        ++affiliationCount;
                    }
                }

                new STFUtil.SleepInfo("Waiting for add affiliates to complete", 10000);

                // We now have 24 users affiliated in the 24 possible different
                // ways with the primary user. Now we can play around with dropping these
                // users into sessions, and seeing how that affects the match results.

                // first, let's try adding a user with no affiliations to the 25th
                // session - this should have no affect on the search results at all
                Global.RO.Info("Adding non affiliated user to the 25th session and requerying");
                sameTitle[0].Xbox.ChangeTitle(primary.Xbox.TitleId, 0, 0);
                fc.LogonUser(sameTitle[0]);
                sameTitle[0].SetTitleData(sessions[24].qwSessionId);

                scol.Search();
                STFUtil.ValueCheck.Test("Search result count", expectedResultCount, scol.Results.Count);
                for (int i = 0; i < expectedResultCount; ++i)
                {
                    Session s = scol.Results[i];
                    MatchAttribute attr = s.AttributeCollection[MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE];
                    STFUtil.ValueCheck.Test("Affiliate value", (ulong)0, attr.qwValue);

                    attr = s.AttributeCollection[INTPROPERTYID];
                    STFUtil.ValueCheck.Test("Int property value", (ulong)i, attr.qwValue);
                }

                // log the user out
                fc.LogoffUser(sameTitle[0]);

                // The rest of the test users all have some kind of positive or negative
                // affiliation. We add each of them, one at a time, in turn to the 25th
                // session. This should either make the 25th session jump to the top of the
                // result set, or it should make the 25th session disappear from the result
                // set and be replaced by the 26th session. Therefore we need two more 
                // expected result sets. One with session index 24, followed by 0 to 23,
                // and one with sessions 0 to 23, followed by 25.

                // the first result, when a positive affiliate is used, will be
                // the 25th session
             
                // now we can iterate through our collection of users of every possible
                // affiliation, and confirm that match returns the sessions we expect
                // and calculates the affiliate values we expect (for positive sessions).
                // Start at 1, since we already tested index 0 above.
                for (int i = 1; i < 24; ++i)
                {
                    Global.RO.Info("Adding user " + i.ToString()
                            + " (" + sameTitle[i].UserId.ToString("X16") + ") to 25th session.");
                    sameTitle[i].Xbox.ChangeTitle(primary.Xbox.TitleId, 0, 0);
                    fc.LogonUser(sameTitle[i]);
                    sameTitle[i].SetTitleData(sessions[24].qwSessionId);

                    // Serilize the state update on peer subscription state update to eliminate
                    // schleping.. err sleeping
                    primary.PeerSubscribe(sameTitle[i]);

                    DateTime timeout = DateTime.Now.AddSeconds(60);
                    PresNotiCommon.PNUser.PeerInfo peerInfo = primary.GetPeerInfo(sameTitle[i].UserId);
                    while(null == peerInfo.RichPresence || peerInfo.RichPresence.MatchSessionID != sessions[24].qwSessionId)
                    {
                        QValPacket qval = primary.WaitForQFlags(PresNotiCommon.XonPresNoti.QFLAG_MASK_PRESENCE_2);
                        primary.HandleQValPacket(qval);

                        if(DateTime.Now >= timeout)
                        {
                            throw new UnexpectedTestResultException("Timed out 60 seconds waiting to serialize presence queue data");
                        }
                    }


                    // bit 0 - AffiliateFlags.CompletedGame
                    // bit 1 - AffiliateFlags.AvoidingMe
                    // bit 2 - AffiliateFlags.Friend
                    // bit 3 - AffiliateFlags.PositiveFeedback
                    // bit 4 - AffiliateFlags.NegativeFeedback
                    int expectedAffiliateValue = 0;
                    if ((i & 0x0001) != 0)
                    {
                        Global.RO.Info("User " + i.ToString() + " is a CompletedGame affiliate.");
                        expectedAffiliateValue += 1;
                    }
                    if ((i & 0x0002) != 0)
                    {
                        Global.RO.Info("User " + i.ToString() + " is an AvoidingMe affiliate.");
                        expectedAffiliateValue -= 3;
                    }
                    if ((i & 0x0004) != 0)
                    {
                        Global.RO.Info("User " + i.ToString() + " is a Friend affiliate.");
                        expectedAffiliateValue += 4;
                    }
                    if ((i & 0x0008) != 0)
                    {
                        Global.RO.Info("User " + i.ToString() + " is a PositiveFeedback affiliate.");
                        expectedAffiliateValue += 2;

                    }
                    if ((i & 0x0010) != 0)
                    {
                        Global.RO.Info("User " + i.ToString() + " is a NegativeFeedback affiliate.");
                        expectedAffiliateValue -= 3;
                    }
                    Global.RO.Info("Expected affiliate value is " + expectedAffiliateValue.ToString());

                    // Collect session results
                    scol.Search();
                    STFUtil.ValueCheck.Test("Search result count", expectedResultCount, scol.Results.Count);
                    
                    if (expectedAffiliateValue < 0)
                    {
                        // 25th session should've been filtered out
                        scol.ValidateDoesNotContain(sessions[24]);
                    }
                    else
                    {
                        // 25th session should have been promoted to the first result
                        // fixup the expected affiliate value
                        MatchAttribute attr = scol.Results[0].AttributeCollection[MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE];
                        STFUtil.ValueCheck.Test("Session zero affiliate value", (ulong)expectedAffiliateValue, attr.qwValue);

                        attr = scol.Results[0].AttributeCollection[INTPROPERTYID];
                        STFUtil.ValueCheck.Test("Session zero index", (ulong)24, attr.qwValue);
                    }

                    Global.RO.Info("Removing user " + i.ToString()
                            + " (" + sameTitle[i].UserId.ToString("X16") + ") from 25th session.");
                    fc.LogoffUser(sameTitle[i]);
                }
            }
            finally
            {
                MatchReq.CleanupSessions();
            }
        }

        
        private static void AssertEqualSearchResults(SearchResult[] left, SearchResult[] right)
        {
            Assert.IsTrue(left != null);
            Assert.IsTrue(right != null);
            Assert.AreEqual(left.Length, right.Length);
            for (int i = 0; i < left.Length; ++i)
            {
                AssertEqualSearchResult(left[i], right[i]);
            }
        }

        private static void AssertEqualSearchResult(SearchResult left, SearchResult right)
        {
            Assert.IsTrue(left != null);
            Assert.IsTrue(right != null);

            // compare the attributes first, since session ids change every time,
            // it is easier to figure out what is going on when the attributes don't match
            AssertEqualMatchAttributes(left.rgAttributes, right.rgAttributes);

            Assert.AreEqual(left.qwSessionId, right.qwSessionId);
            AssertEqualXNADDR(left.HostAddress, right.HostAddress);
            AssertEqualByteArray(left.rgbKeyExchangeKey, right.rgbKeyExchangeKey);
            Assert.AreEqual(left.dwPublicOpen, right.dwPublicOpen);
            Assert.AreEqual(left.dwPrivateOpen, right.dwPrivateOpen);
            Assert.AreEqual(left.dwPublicFilled, right.dwPublicFilled);
            Assert.AreEqual(left.dwPrivateFilled, right.dwPrivateFilled);
            Assert.AreEqual(left.dwNumAttributes, right.dwNumAttributes);
        }

        private static void AssertEqualMatchAttributes(
                MatchAttribute[] left,
                MatchAttribute[] right)
        {
            Assert.IsTrue(left != null);
            Assert.IsTrue(right != null);
            Assert.AreEqual(left.Length, right.Length);
            for (int i = 0; i < left.Length; ++i)
            {
                AssertEqualMatchAttribute(left[i], right[i]);
            }
        }

        private static void AssertEqualMatchAttribute(MatchAttribute left, MatchAttribute right)
        {
            Assert.IsTrue(left != null);
            Assert.IsTrue(right != null);
            Assert.AreEqual(left.dwAttributeId, right.dwAttributeId);
            switch(left.dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK)
            {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    Assert.AreEqual(left.qwValue, right.qwValue);
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                    Assert.AreEqual(left.strValue, right.strValue);
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                    AssertEqualByteArray(left.rgbValue, right.rgbValue);
                    break;
                case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                    // no data to check
                    break;
                default:
                    throw new Exception("Unknown match datatype in attribute, id: "
                            + left.dwAttributeId.ToString("X8"));
            }
        }

        [TestCase]
        public void CreateRankedSessionsFD()
        {
            Session s = new Session();
            s.AttributeCollection.GenerateRankedAttributes();
            s.GamerPuid = 1234;

            int i = 0;
            for (i = 0; i < 100; ++i)
            {
                if (i % 10 == 0 && i > 0)
                {
                    Global.RO.Info(i.ToString() + " sessions created.");
                }

                // generate a random mu and sigma
                s.GamerMu = Util.RandomMu();
                s.GamerSigma = Util.RandomSigma();

                // generate a different xnaddr
                s.xnaddr = Util.CreateRandomXNADDR();
                s.SetupSGInfo();

                s.Advertise(); 
            }

            Global.RO.Info(i.ToString() + " sessions created.");
        }

        [TestCase]
        public void SplitSession()
        {
            Session s = new Session();
            s.AttributeCollection.GenerateStandardAttributes();
            s.GamerHostname = "user1";
            s.GamerPuid = 1;
            s.dwPublicOpen = 5;
            s.dwPrivateOpen = 3;
            s.dwPublicFilled = 4;
            s.dwPrivateFilled = 2;
            s.SetupSGInfo();
            s.Advertise();

            // Try to split the session using a new host
            Session s2 = (Session)s.Clone();
            s2.GamerHostname = "user2";
            s2.GamerPuid = 3;
            s2.xnaddr.ina          += 1;
            s2.xnaddr.inaOnline    += 1;
            s2.xnaddr.wPortOnline  += 1;

            Global.RO.Info("Splitting session");
            s2.SetupSGInfo();
            s2.Split(s);

            // Try to split the session as *NOT* the new host

            // Try to update the session properties as the new host

            // Try to update the session properties as the *OLD* host

            // Try to delete the session 
        }

        [TestCase]
        public void SplitSession_DeferredDeadXbox()
        {
            Session std = new Session();
            std.AttributeCollection.GenerateStandardAttributes();
            std.GamerHostname = "user1";
            std.GamerPuid = 1;
            std.SetupSGInfo();
            std.Advertise();

            Session rnk = new Session();
            rnk.AttributeCollection.GenerateRankedAttributes();
            rnk.GamerHostname = "user1";
            rnk.GamerPuid = 1;
            rnk.SetupSGInfo();
            rnk.Advertise();

            // Both sessions marked for delete
            std.DeadXbox();
            
            // Don't cleanup deadxbox'd sessions 
            MatchReq.ClearSessionsForCleanup();

            // Make sure findbyid can't see the session any more
            std.ValidateExistsOnServer(false);
            rnk.ValidateExistsOnServer(false);

            // Make sure we can split after deadxbox
            Session std2 = (Session)std.Clone();
            std2.GamerHostname = "user2";
            std2.GamerPuid = 2;
            std2.xnaddr.ina          += 1;
            std2.xnaddr.inaOnline    += 1;
            std2.xnaddr.wPortOnline  += 1;
            std2.SetupSGInfo();
            std2.Split(std);

            // Make sure we can split after deadxbox
            Session rnk2 = (Session)rnk.Clone();
            rnk2.GamerHostname = "user2";
            rnk2.GamerPuid = 2;
            rnk2.xnaddr.ina          += 1;
            rnk2.xnaddr.inaOnline    += 1;
            rnk2.xnaddr.wPortOnline  += 1;
            rnk2.SetupSGInfo();
            rnk2.Split(rnk);
        }

        [TestCase]
        public void PlatformSetting()
        {
            try
            {
                MatchReq.FindAndCleanupAllSessions(TITLEID);

                AttributeCollection standard = new AttributeCollection();
                AttributeCollection ranked = new AttributeCollection();
                AttributeCollection[] types = new AttributeCollection[2] { standard, ranked };
                standard.GenerateStandardAttributes();
                ranked.GenerateRankedAttributes();

                // Try each enable state
                foreach(CrossPlatformRevokeState revokeState in Enum.GetValues(typeof(CrossPlatformRevokeState)))
                {
                    // Change t_match_titles directly and reload the title info cache
                    MatchAdmin.SetCrossPlatformRevokeState(TITLEID, revokeState);
                    MatchAdmin.ReloadTitleInfo();

                    // Try each match type
                    foreach(AttributeCollection attrcol in types)
                    {
                        // Advertise an unlocked xenon session
                        Session s1 = new Session();
                        s1.AttributeCollection = (AttributeCollection)attrcol.Clone();
                        s1.GamerPuid = 1;
                        s1.PlatformType = XOn.XPLT_XBOX360;
                        s1.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            s1.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        s1.Advertise();
                        s1.ValidateExistsOnServer();

                        // Ensure that update works correctly
                        s1.GamerHostname = "host1";
                        s1.Update();

                        // Advertise a locked xenon session
                        Session s2 = new Session();
                        s2.AttributeCollection = (AttributeCollection)attrcol.Clone();
                        s2.GamerPuid = 2;
                        s2.PlatformType = XOn.XPLT_XBOX360;
                        s2.PlatformLock = 1;
                        s2.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            s2.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        s2.Advertise();
                        s2.ValidateExistsOnServer();

                        // Advertise an unlocked PC session
                        Session s3 = new Session();
                        s3.AttributeCollection = (AttributeCollection)attrcol.Clone();
                        s3.GamerPuid = 3;
                        s3.PlatformType = XOn.XPLT_PC;
                        s3.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            s3.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        s3.Advertise();
                        s3.ValidateExistsOnServer();

                        // Advertise a locked PC session
                        Session s4 = new Session();
                        s4.AttributeCollection = (AttributeCollection)attrcol.Clone();
                        s4.GamerPuid = 4;
                        s4.PlatformType = XOn.XPLT_PC;
                        s4.PlatformLock = 1;
                        s4.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            s4.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        s4.Advertise();
                        s4.ValidateExistsOnServer();

                        // Setup our basic search session
                        SessionCollection scol = new SessionCollection();
                        scol.SearchTemplate.AttributeCollection = (AttributeCollection)attrcol.Clone();
                        scol.SearchTemplate.PlatformType = XOn.XPLT_XBOX360;
                        scol.SearchTemplate.SetupSGInfo();
                        scol.dwProcedureIndex = 1;

                        // Find all unlocked sessions and xenon sessions
                        scol.Search();
                        switch(revokeState)
                        {
                            case CrossPlatformRevokeState.NotSupported:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 4, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Allow:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                scol.ValidateContains(s3);
                                STFUtil.ValueCheck.Test("Results", 3, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Revoke:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                STFUtil.ValueCheck.Test("Results", 2, scol.Results.Count);
                                break;
                        }

                        // Find only locked xenon sessions
                        scol.SearchTemplate.PlatformType = XOn.XPLT_XBOX360;
                        scol.SearchTemplate.PlatformLock = 1;
                        scol.SearchTemplate.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            scol.SearchTemplate.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        scol.Search();
                        switch(revokeState)
                        {
                            case CrossPlatformRevokeState.NotSupported:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 4, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Allow:
                                scol.ValidateContains(s2);
                                STFUtil.ValueCheck.Test("Results", 1, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Revoke:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                STFUtil.ValueCheck.Test("Results", 2, scol.Results.Count);
                                break;
                        }

                        // Find only xenon sessions due to missing privilege bit
                        scol.SearchTemplate.PlatformLock = 0;
                        scol.SearchTemplate.sginfo.UnsetPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            scol.SearchTemplate.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        scol.Search();
                        switch(revokeState)
                        {
                            case CrossPlatformRevokeState.NotSupported:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 4, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Allow:
                                scol.ValidateContains(s2);
                                STFUtil.ValueCheck.Test("Results", 1, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Revoke:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                STFUtil.ValueCheck.Test("Results", 2, scol.Results.Count);
                                break;
                        }

                        // Find only PC sessions
                        scol.SearchTemplate.PlatformType = XOn.XPLT_PC;
                        scol.SearchTemplate.PlatformLock = 1;
                        scol.SearchTemplate.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            scol.SearchTemplate.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        scol.Search();
                        switch(revokeState)
                        {
                            case CrossPlatformRevokeState.NotSupported:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 4, scol.Results.Count);
                                break; 
                            case CrossPlatformRevokeState.Allow:
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 1, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Revoke:
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 2, scol.Results.Count);
                                break;
                        }

                        // Find only PC sessions due to missing privilege bit
                        scol.SearchTemplate.PlatformLock = 0;
                        scol.SearchTemplate.sginfo.UnsetPrivilege(XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            scol.SearchTemplate.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        scol.Search();
                        switch(revokeState)
                        {
                            case CrossPlatformRevokeState.NotSupported:
                                scol.ValidateContains(s1);
                                scol.ValidateContains(s2);
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 4, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Allow:
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 1, scol.Results.Count);
                                break;
                            case CrossPlatformRevokeState.Revoke:
                                scol.ValidateContains(s3);
                                scol.ValidateContains(s4);
                                STFUtil.ValueCheck.Test("Results", 2, scol.Results.Count);
                                break;
                        }

                        // Check that locked sessions are not available to findbyid
                        Session findbyid = (Session)s2.Clone();
                        findbyid.PlatformType = XOn.XPLT_PC;
                        findbyid.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            findbyid.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        findbyid.ValidateExistsOnServer((CrossPlatformRevokeState.NotSupported == revokeState));

                        findbyid = (Session)s4.Clone();
                        findbyid.PlatformType = XOn.XPLT_XBOX360;
                        findbyid.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            findbyid.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        findbyid.ValidateExistsOnServer((CrossPlatformRevokeState.NotSupported == revokeState));

                        // Check that findbyid obeys the lock setting
                        findbyid = (Session)s1.Clone();
                        findbyid.PlatformLock = 1;
                        findbyid.PlatformType = XOn.XPLT_PC;
                        findbyid.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            findbyid.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        findbyid.ValidateExistsOnServer((CrossPlatformRevokeState.NotSupported == revokeState));

                        findbyid = (Session)s3.Clone();
                        findbyid.PlatformLock = 1;
                        findbyid.PlatformType = XOn.XPLT_XBOX360;
                        findbyid.SetupSGInfo();
                        if(CrossPlatformRevokeState.NotSupported == revokeState)
                        {
                            findbyid.AttributeCollection.RemoveAttributes(
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE,
                                    MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
                        }
                        findbyid.ValidateExistsOnServer((CrossPlatformRevokeState.NotSupported == revokeState));


                        MatchReq.CleanupSessions();
                    } // end session type loop
                } // end platform flag disable loop
            }
            finally
            {
                MatchReq.AuthData = null;
                MatchReq.CleanupSessions();
            }
        }

        [TestCase]
        public void FindMultipleIds()
        {
            Session []sessions = new Session[MatchDefs.X_MATCH_MAX_SESSION_LIST_IDS + 1];
            ulong []oneSession = new ulong[1];
            ulong []tenSessions = new ulong[10];
            ulong []sessionIds = new ulong[MatchDefs.X_MATCH_MAX_SESSION_LIST_IDS];
            ulong []sessionIdsTooMany = new ulong[MatchDefs.X_MATCH_MAX_SESSION_LIST_IDS + 1];

            for(int i = 0; i < 101; ++i)
            {
                // Create session and advertise it on the server
                sessions[i] = new Session();
                if((i & 1) == 0)
                {
                    sessions[i].AttributeCollection.GenerateStandardAttributes();
                }
                else
                {
                    sessions[i].AttributeCollection.GenerateRankedAttributes();
                }

                sessions[i].SetupSGInfo();
                sessions[i].Advertise();

                if(i < 1)
                {
                    oneSession[i] = sessions[i].qwSessionId;
                }
                if(i < 10)
                {
                    tenSessions[i] = sessions[i].qwSessionId;
                }
                if(i < 100)
                {
                    sessionIds[i] = sessions[i].qwSessionId;
                }
                
                sessionIdsTooMany[i] = sessions[i].qwSessionId;
            }

            SessionCollection col = new SessionCollection();
            col.SearchTemplate.SetupSGInfo();

            col.FindAllIds(oneSession);
            col.ValidateContains(oneSession);

            col.FindAllIds(tenSessions);
            col.ValidateContains(tenSessions);

            col.FindAllIds(sessionIds);
            col.ValidateContains(sessionIds);

            try
            {
                col.FindAllIds(sessionIdsTooMany);
            }
            catch(HResultException ex)
            {
                STFUtil.ValueCheck.TestHR("Oversized session ID list", HResult.XONLINE_E_MATCH_BLOB_TOO_LONG, ex.HR);
            }

            // No session IDs
            try
            {
                col.FindAllIds(new ulong[0]);
            }
            catch(HResultException ex)
            {
                STFUtil.ValueCheck.TestHR("0 session IDs in parameter", HResult.XONLINE_E_MATCH_INVALID_PARAM, ex.HR);
            }

            // First ID is bad
            try
            {
                col.FindAllIds(new ulong[] { 0x1234abcd1234abcd });
            }
            catch(HResultException ex)
            {
                STFUtil.ValueCheck.TestHR("Invalid session ID in parameter", HResult.XONLINE_E_MATCH_INVALID_SESSION_ID, ex.HR);
            }

            // First ID is good, Second ID is bad
            try
            {
                col.FindAllIds(new ulong[] { oneSession[0], 0x1234abcd1234abcd });
            }
            catch(HResultException ex)
            {
                STFUtil.ValueCheck.TestHR("Invalid session ID in parameter", HResult.XONLINE_E_MATCH_INVALID_SESSION_ID, ex.HR);
            }
        }

        private static void AssertEqualXNADDR(XNADDR left, XNADDR right)
        {
            Assert.IsTrue(left != null);
            Assert.IsTrue(right != null);
            Assert.AreEqual(left.ina, right.ina);
            Assert.AreEqual(left.inaOnline, right.inaOnline);
            Assert.AreEqual(left.wPortOnline, right.wPortOnline);
            AssertEqualByteArray(left.abEnet, right.abEnet);
            AssertEqualSGADDR(left.sgaddr, right.sgaddr);
        }

        private static void AssertEqualSGADDR(SGADDR left, SGADDR right)
        {
            Assert.IsTrue(left != null);
            Assert.IsTrue(right != null);
            Assert.AreEqual(left.inaSg, right.inaSg);
            Assert.AreEqual(left.qwXboxId, right.qwXboxId);
            Assert.AreEqual(left.abReserved, right.abReserved);
        }

        private static bool AssertEqualByteArray(byte[] left, byte[] right)
        {
            if (left == null) return false;
            if (right == null) return false;
            if (left.Length != right.Length) return false;
            for (int i = 0; i < left.Length; ++i)
            {
                if (left[i] != right[i]) return false;
            }
            return true;
        }

        
        private void VerifyResultExists(Presence.QueryAffiliatesReplyData[] results,
                ulong userId, AffiliateFlags flag)
        {
            for (int i = 0; i < results.Length; ++i)
            {
                if (results[i].qwAffiliateID == userId
                        && (results[i].dwListFlags & (uint)flag) != 0)
                {
                    // found a matching result, so return
                    return;
                }
            }
            // no match found, throw exception
            Global.RO.Info("Unable to find result for userid " + userId.ToString("X16")
                    + " for affiliate flag " + flag.ToString());
        }

        private void ValidateAffiliateResult(Presence.QueryAffiliatesReplyData data,
                PresNotiCommon.PNUser u, uint desiredTitleId, uint listFlags) 
        {
            STFUtil.ValueCheck.Test("User(" + u.UserId + ")-AffiliateId", u.UserId, data.qwAffiliateID);
            STFUtil.ValueCheck.Test("User(" + u.UserId + ")-ListFlags", listFlags, data.dwListFlags);
            STFUtil.ValueCheck.Test("User(" + u.UserId + ")-TitleId", desiredTitleId, data.dwTitleID);
            STFUtil.ValueCheck.Test("User(" + u.UserId + ")-SessionId", u.MatchSessionId, data.qwSessionID);
            STFUtil.ValueCheck.Test("User(" + u.UserId + ")-GamerString", u.Name, data.szGamerTag);
        }
    }

    public partial class Util
    {
        public static double RandomMu()
        {
            // we want the mu values to be in a moderate bell-like curve,
            // so generate and then sum six independant random numbers between
            // 0 and 1 to generate a value between 0 and 6, centered around 3
            Random random = new Random();
            double mu = random.NextDouble() + random.NextDouble() + random.NextDouble()
                + random.NextDouble() + random.NextDouble() + random.NextDouble();
            return mu;
        }

        public static void SetAttribute(MatchAttribute[] attrs, uint dwAttributeId, string strValue)
        {
            foreach(MatchAttribute attr in attrs)
            {
                if(attr.dwAttributeId == dwAttributeId)
                {
                    attr.strValue = strValue;
                    return;
                }
            }

            throw new Exception("No such attribute: 0x" + dwAttributeId.ToString("X") + " in attributes");
        }

        public static double RandomSigma()
        {
            // not sure what sigma will really look like, so I'll just use a 
            // slight bell curved shape centered at 0.5
            Random random = new Random();
            double sigma = (random.NextDouble() + random.NextDouble()) / 2.0;
            return sigma;
        }

        /*
        public static float RandomRating()
        {
            Random random = new Random();
            float rating = (float)(((random.NextDouble() + random.NextDouble()) / 2.0) * 100.0f);
            return rating;
        }
        */

        public static ulong RandomMachineId(byte bPlatformType)
        {
            Random rand = new Random();
            ulong machineId = ~XOn.XboxId.Mask & ((ulong)(uint)rand.Next() | (ulong)(uint)rand.Next());
            switch(bPlatformType)
            {
                case XOn.XPLT_XBOX1:
                    machineId |= XOn.XboxId.XboxMachineBase;
                    break;
                case XOn.XPLT_XBOX360:
                    machineId |= XOn.XboxId.XenonMachineBase;
                    break;
                case XOn.XPLT_PC:
                    machineId |= XOn.XboxId.PcMachineBase;
                    break;
                default: 
                    throw new UnexpectedTestResultException("Unexpected platform type: " + bPlatformType);
            }

            return machineId;
        }

        public static uint AddMatchDatatype(uint propertyId)
        {
            switch (MatchDefs.AttributeXenonDatatype(propertyId))
            {
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UNICODE:
                    return propertyId | MatchDefs.X_ATTRIBUTE_DATATYPE_STRING;

                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_BINARY:
                    return propertyId | MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB;
            }
            return propertyId;
        }

        public static XNADDR CreateTestXNADDR()
        {
            XNADDR xnaddr = new XNADDR();
            xnaddr.ina = IPAddressToUInt(IPAddress.Parse("1.2.3.4"));
            xnaddr.inaOnline = IPAddressToUInt(IPAddress.Parse("2.3.4.5"));
            xnaddr.wPortOnline = 3074;
            xnaddr.abEnet = new byte[6];
            xnaddr.abEnet[0] = 01;
            xnaddr.abEnet[1] = 02;
            xnaddr.abEnet[2] = 03;
            xnaddr.abEnet[3] = 04;
            xnaddr.abEnet[4] = 05;
            xnaddr.abEnet[5] = 06;
            xnaddr.sgaddr = new SGADDR();
            xnaddr.sgaddr.inaSg = IPAddressToUInt(IPAddress.Parse("3.4.5.6"));
            xnaddr.sgaddr.dwSpiSg = 0x12345678;
            xnaddr.sgaddr.qwXboxId =  XOn.XboxId.XenonConsoleBase | (ulong)0x12349abcdef0;
            xnaddr.sgaddr.abReserved = 0;
            return xnaddr;
        }

        public static XNADDR CreateRandomXNADDR()
        {
            Random random = new Random();
            XNADDR xnaddr = new XNADDR();
            xnaddr.ina = (uint)random.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.inaOnline = (uint)random.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.wPortOnline = (ushort)random.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.abEnet = new byte[6];
            random.NextBytes(xnaddr.abEnet);
            xnaddr.sgaddr = new SGADDR();
            xnaddr.sgaddr.inaSg = (uint)random.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.sgaddr.dwSpiSg = (uint)random.Next(Int32.MinValue, Int32.MaxValue);
            xnaddr.sgaddr.qwXboxId = Util.RandomMachineId(XOn.XPLT_XBOX360);
            xnaddr.sgaddr.abReserved = 0;
            return xnaddr;
        }

        public static uint IPAddressToUInt(IPAddress ipAddress)
        {
            // the .net framework frowns on treating ip addresses as uint, and therefore
            // no longer provides an easy way to do it.
            byte[] bytes = ipAddress.GetAddressBytes();
            if (bytes.Length != 4)
            {
                throw new Exception("IPAddress not 4 bytes in length");
            }
            return (uint)((bytes[3] << 24) + (bytes[2] << 16) + (bytes[1] << 8) + bytes[0]);
        }

        public static ulong RandomPuid()
        {
            return (ulong)0x0009000000000000 + (ulong)(uint)(new Random().Next());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\AssemblyInfo.cs ===
[assembly: System.Reflection.AssemblyTitle("Xbox Live Messaging Front Door")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\log\import\ImportMatchLog.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Globalization;

namespace xonline.server.match.test.log.import
{

class ImportMatchLog
{
    private static void Usage()
    {
        //                0.........1.........2.........3.........4.........5.........6.........7.........8
        Console.WriteLine("");
        Console.WriteLine("Imports one or more xmatchfd log files into the xmatchfd_logs database");
        Console.WriteLine("on localhost. Note that this is intened for troubleshooting purposes");
        Console.WriteLine("and is not a full reporting tool.");
        Console.WriteLine("");
        Console.WriteLine("Usage:");
        Console.WriteLine("    ImportMatchLog machinename.xmatchfd.[datetime].log ...");
        Console.WriteLine("");
        Console.WriteLine("    More than one log file can be specified on the command line, and");
        Console.WriteLine("    each will be processed in order. Note that the machinename is");
        Console.WriteLine("    expected to be in the filename before the first '.'. Whatever is");
        Console.WriteLine("    before the first dot will be takens as the machine name.");
        Console.WriteLine("    The rest of the filename is not signficant.");
        Console.WriteLine("");
    }

    public static int Main(string[] args)
    {
        if (args.Length < 1)
        {
            Usage();
            Console.WriteLine("Error: Incorrect number of command line arguments");
            return -1;
        }

        if (args[0] == "/?" || args[0] == "/help" || args[0] == "-?" || args[0] == "-help")
        {
            Usage();
            return -1;
        }

        string[] filenames = ExpandWildcards(args);

        try
        {
            ImportLogFiles(filenames);
        }
        catch (Exception e)
        {
            Console.WriteLine("Unexpected Exception. Details follow:");
            Console.WriteLine(e.Message);
            Console.WriteLine(e.StackTrace);
            return -1;
        }

        return 0;
    }

    private static string[] ExpandWildcards(string[] args)
    {
        ArrayList filenames = new ArrayList();

        foreach (string arg in args)
        {
            AddFiles(arg, ref filenames);
        }
        return (string[])filenames.ToArray(typeof(string));
    }

    private static void AddFiles(string arg, ref ArrayList filenames)
    {
        // Do file glob expansion and directory search
        if(arg.Contains("*"))
        {
            string dirPart = Path.GetDirectoryName(arg);
            string filePart = Path.GetFileName(arg);
            string[] files = Directory.GetFiles(dirPart, filePart);

            foreach(string file in files)
            {
                AddFiles(file, ref filenames);
            }
        }

        if(!File.Exists(arg) && !Directory.Exists(arg))
        {
            Console.WriteLine("File/Directory '{0}' does not exist", arg);
        }
        else
        {
            // Recurse into directories
            if(FileAttributes.Directory == (FileAttributes.Directory & File.GetAttributes(arg)))
            {
                string[] files = Directory.GetFiles(arg);
                filenames.AddRange(files);

                string[] directories = Directory.GetDirectories(arg);
                foreach(string dir in directories)
                {
                    AddFiles(dir, ref filenames);
                }
            }
            else
            {
                // Add the file
                filenames.Add(arg);
            }
        }
    }

    private const string ConnectionString 
        = "Server=localhost;Integrated Security=true;Database=xmatchfd_logs";

    private static void ImportLogFiles(string[] filenames)
    {
        using (SqlConnection cxn = new SqlConnection(ConnectionString))
        {
            cxn.Open();
            int totalLineCount = 0;
            foreach (string filename in filenames)
            {
                int fileLineCount = 0;
                try
                {
                    Console.WriteLine("Importing file " + filename);
                    fileLineCount = ImportLogFile(cxn, filename);
                }
                catch (SqlException e)
                {
                    Console.WriteLine(e.Message);
                    Console.WriteLine("Error Number: " + e.Number);
                    Console.WriteLine("Proceedure: " + e.Procedure);
                    Console.WriteLine("Server: " + e.Server);
                    Console.WriteLine(e.StackTrace);
                    Console.WriteLine("Error importing file '" + filename + "'. Continuing with next file");
               }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                    Console.WriteLine(e.StackTrace);
                    Console.WriteLine("Error importing file '" + filename + "'. Continuing with next file");
                    continue;
                }
                totalLineCount += fileLineCount;
            }
            cxn.Close();
            Console.WriteLine(totalLineCount.ToString() + " log lines imported across all files");
        }
    }

    private static int ImportLogFile(SqlConnection cxn, string filename)
    {
        StreamReader sr = new StreamReader(filename);

        string machinename = Path.GetFileName(filename).Split('.')[0].ToUpper();
        Console.WriteLine("Machine name is " + machinename);

        int lineCount = 0;
        int dupLineCount = 0;
        string line = null;
        while ((line = sr.ReadLine()) != null)
        {
            try
            {
                ImportLogLine(cxn, machinename, line);
            }
            catch (SqlException e)
            {
                if (e.Number == 2627)
                {
                    // primary key violation, just skip this row
                    dupLineCount++;
                }
            }
            catch (Exception)
            {
                Console.WriteLine("Exception parsing log line:");
                Console.WriteLine(line);
                throw;
            }
            lineCount++;
            if (lineCount % 25000 == 0)
            {
                Console.WriteLine(lineCount + " lines read...");
            }
        }

        Console.WriteLine(lineCount.ToString() + " log lines imported from " + filename);
        if (dupLineCount != 0)
        {
            Console.WriteLine(dupLineCount.ToString() 
                + " log lines were ignored as duplicates from " + filename);
        }

        return lineCount;
    }

    private static void ImportLogLine(SqlConnection cxn, string machinename, string line)
    {
        string[] splitLine = line.Split('|');
        string operation = splitLine[1].ToLower();

        switch (operation)
        {
        case "matchinsertxbox":
            ImportMatchInsertXbox(cxn, machinename, splitLine, line);
            break;

        case "matchinsertxbox360":
            ImportMatchInsertXbox360(cxn, machinename, splitLine, line);
            break;

        case "matchupdatexbox":
            ImportMatchUpdateXbox(cxn, machinename, splitLine, line);
            break;

        case "matchupdatexbox360":
            ImportMatchUpdateXbox360(cxn, machinename, splitLine, line);
            break;

        case "matchdeletexbox":
            ImportMatchDeleteXbox(cxn, machinename, splitLine, line);
            break;

        case "matchdeletexbox360":
            ImportMatchDeleteXbox360(cxn, machinename, splitLine, line);
            break;

        case "matchsearchxbox":
            ImportMatchSearchXbox(cxn, machinename, splitLine, line);
            break;

        case "matchsearchxboxcached":
            ImportMatchSearchXboxCached(cxn, machinename, splitLine, line);
            break;

        case "matchsearchbyidxbox360":
            ImportMatchSearchByIdXbox360(cxn, machinename, splitLine, line);
            break;

        case "matchsearchrankedxbox360":
            ImportMatchSearchRankedXbox360(cxn, machinename, splitLine, line);
            break;

        case "matchsearchstandardxbox360":
            ImportMatchSearchStandardXbox360(cxn, machinename, splitLine, line);
            break;

        case "matchsplitsession":
            ImportMatchSplitSession(cxn, machinename, splitLine, line);
            break;

        case "matchdeadxbox":
            ImportMatchDeadXbox(cxn, machinename, splitLine, line);
            break;

        case "matchdeadsg":
            ImportMatchDeadSg(cxn, machinename, splitLine, line);
            break;
        default:
            Console.WriteLine("Unrecognized log line: " + line);
            break;

        }
    }

    private static void ImportMatchInsertXbox(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 19)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_public_open", (Int32)UInt32.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_private_open", (Int32)UInt32.Parse(splitLine[8]));
        cmd.Parameters.AddWithValue("@i_public_filled", (Int32)UInt32.Parse(splitLine[9]));
        cmd.Parameters.AddWithValue("@i_private_filled", (Int32)UInt32.Parse(splitLine[10]));
        cmd.Parameters.AddWithValue("@ti_server_type", Byte.Parse(splitLine[11]));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[12]));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[13], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[14], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[15]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[16], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[17], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[18], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchInsertXbox360(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 29)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_public_open", (Int32)UInt32.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_private_open", (Int32)UInt32.Parse(splitLine[8]));
        cmd.Parameters.AddWithValue("@i_public_filled", (Int32)UInt32.Parse(splitLine[9]));
        cmd.Parameters.AddWithValue("@i_private_filled", (Int32)UInt32.Parse(splitLine[10]));
        cmd.Parameters.AddWithValue("@bi_puid", (Int32)UInt64.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@vc_gamer_hostname", splitLine[12]);
        cmd.Parameters.AddWithValue("@i_game_type", (Int32)UInt32.Parse(splitLine[13]));
        cmd.Parameters.AddWithValue("@bi_game_mode", (Int64)UInt64.Parse(splitLine[14]));
        cmd.Parameters.AddWithValue("@i_gamer_zone", (Int32)UInt32.Parse(splitLine[15]));
        cmd.Parameters.AddWithValue("@i_gamer_country", (Int32)UInt32.Parse(splitLine[16]));
        cmd.Parameters.AddWithValue("@i_gamer_language", (Int32)UInt32.Parse(splitLine[17]));
        cmd.Parameters.AddWithValue("@f_gamer_rating", Double.Parse(splitLine[18]));
        cmd.Parameters.AddWithValue("@f_gamer_mu", Double.Parse(splitLine[19]));
        cmd.Parameters.AddWithValue("@f_gamer_sigma", Double.Parse(splitLine[20]));
        cmd.Parameters.AddWithValue("@ti_server_type", Byte.Parse(splitLine[21]));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[22]));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[23], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[24], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[25]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[26], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[27], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[28], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchUpdateXbox(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 11)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_public_open", (Int32)UInt32.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_private_open", (Int32)UInt32.Parse(splitLine[8]));
        cmd.Parameters.AddWithValue("@i_public_filled", (Int32)UInt32.Parse(splitLine[9]));
        cmd.Parameters.AddWithValue("@i_private_filled", (Int32)UInt32.Parse(splitLine[10]));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchUpdateXbox360(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 21)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_public_open", (Int32)UInt32.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_private_open", (Int32)UInt32.Parse(splitLine[8]));
        cmd.Parameters.AddWithValue("@i_public_filled", (Int32)UInt32.Parse(splitLine[9]));
        cmd.Parameters.AddWithValue("@i_private_filled", (Int32)UInt32.Parse(splitLine[10]));
        cmd.Parameters.AddWithValue("@bi_puid", (Int64)UInt64.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@vc_gamer_hostname", splitLine[12]);
        cmd.Parameters.AddWithValue("@i_game_type", (Int32)UInt32.Parse(splitLine[13]));
        cmd.Parameters.AddWithValue("@bi_game_mode", (Int64)UInt64.Parse(splitLine[14]));
        cmd.Parameters.AddWithValue("@i_gamer_zone", (Int32)UInt32.Parse(splitLine[15]));
        cmd.Parameters.AddWithValue("@i_gamer_country", (Int32)UInt32.Parse(splitLine[16]));
        cmd.Parameters.AddWithValue("@i_gamer_language", (Int32)UInt32.Parse(splitLine[17]));
        cmd.Parameters.AddWithValue("@f_gamer_rating", Double.Parse(splitLine[18]));
        cmd.Parameters.AddWithValue("@f_gamer_mu", Double.Parse(splitLine[19]));
        cmd.Parameters.AddWithValue("@f_gamer_sigma", Double.Parse(splitLine[20]));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchDeleteXbox(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 7)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchDeleteXbox360(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 7)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchSearchXbox(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 17)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_proc_id", (Int32)UInt32.Parse(splitLine[6]));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_num_users", (Int32)UInt64.Parse(splitLine[8], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_attributes", (Int32)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_results", (Int32)UInt64.Parse(splitLine[10], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[12], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[13]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[14], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[15], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[16], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchSearchXboxCached(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 17)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_proc_id", (Int32)UInt32.Parse(splitLine[6]));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_num_users", (Int32)UInt64.Parse(splitLine[8], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_attributes", (Int32)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_results", (Int32)UInt64.Parse(splitLine[10], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[12], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[13]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[14], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[15], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[16], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchSearchByIdXbox360(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 18)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_proc_id", (Int32)UInt32.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_num_users", (Int32)UInt64.Parse(splitLine[8], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_attributes", (Int32)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_results", (Int32)UInt64.Parse(splitLine[10], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int32)UInt64.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[12], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[13], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[14]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[15], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[16], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[17], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchSearchRankedXbox360(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 37)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_proc_id", (Int32)UInt32.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_num_users", (Int32)UInt64.Parse(splitLine[8], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_attributes", (Int32)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_results", (Int32)UInt64.Parse(splitLine[10], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_max_results", (Int32)UInt64.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_puid", (Int64)UInt64.Parse(splitLine[12], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@vc_gamer_hostname", splitLine[13]);
        cmd.Parameters.AddWithValue("@i_game_type", (Int32)UInt32.Parse(splitLine[14]));
        cmd.Parameters.AddWithValue("@bi_game_mode", (Int64)UInt64.Parse(splitLine[15]));
        cmd.Parameters.AddWithValue("@i_gamer_zone", (Int32)UInt32.Parse(splitLine[16]));
        cmd.Parameters.AddWithValue("@i_gamer_country", (Int32)UInt32.Parse(splitLine[17]));
        cmd.Parameters.AddWithValue("@i_gamer_language", (Int32)UInt32.Parse(splitLine[18]));
        cmd.Parameters.AddWithValue("@f_gamer_rating", Double.Parse(splitLine[19]));
        cmd.Parameters.AddWithValue("@f_gamer_mu", Double.Parse(splitLine[20]));
        cmd.Parameters.AddWithValue("@f_gamer_sigma", Double.Parse(splitLine[21]));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[22], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[23], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[24]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[25], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[26], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[27], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_ranked_iterations", (Int32)UInt32.Parse(splitLine[28], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_ranked_row_count", (Int32)UInt32.Parse(splitLine[29], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@f_ranked_mu_range", Double.Parse(splitLine[30]));
        cmd.Parameters.AddWithValue("@f_ranked_mu_upper_bound",  Double.Parse(splitLine[31]));
        cmd.Parameters.AddWithValue("@f_ranked_mu_lower_bound",  Double.Parse(splitLine[32]));
        cmd.Parameters.AddWithValue("@i_ranked_lower_hash_bound1", (Int32)UInt32.Parse(splitLine[33], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_ranked_upper_hash_bound1", (Int32)UInt32.Parse(splitLine[34], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_ranked_lower_hash_bound2", (Int32)UInt32.Parse(splitLine[35], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_ranked_upper_hash_bound2", (Int32)UInt32.Parse(splitLine[36], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchSearchStandardXbox360(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 69)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_proc_id", (Int32)UInt32.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@i_num_users", (Int32)UInt64.Parse(splitLine[8], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_attributes", (Int32)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_results", (Int32)UInt64.Parse(splitLine[10], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_max_results", (Int32)UInt64.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_inzone_affiliate_results", (Int32)UInt64.Parse(splitLine[12], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_inzone_non_affiliate_results", (Int32)UInt64.Parse(splitLine[13], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_outzone_affiliate_results", (Int32)UInt64.Parse(splitLine[14], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_num_outzone_non_affiliate_results", (Int32)UInt64.Parse(splitLine[15], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_puid", (Int64)UInt64.Parse(splitLine[16], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@vc_gamer_hostname", splitLine[17]);
        cmd.Parameters.AddWithValue("@i_game_type", (Int32)UInt32.Parse(splitLine[18]));
        cmd.Parameters.AddWithValue("@bi_game_mode", (Int64)UInt64.Parse(splitLine[19]));
        cmd.Parameters.AddWithValue("@i_gamer_zone", (Int32)UInt32.Parse(splitLine[20]));
        cmd.Parameters.AddWithValue("@i_gamer_country", (Int32)UInt32.Parse(splitLine[21]));
        cmd.Parameters.AddWithValue("@i_gamer_language", (Int32)UInt32.Parse(splitLine[22]));
        cmd.Parameters.AddWithValue("@f_gamer_rating", Double.Parse(splitLine[23]));
        cmd.Parameters.AddWithValue("@f_gamer_mu", Double.Parse(splitLine[24]));
        cmd.Parameters.AddWithValue("@f_gamer_sigma", Double.Parse(splitLine[25]));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[26], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[27], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[28]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[29], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[30], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[31], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_friend_count", (Int32)UInt32.Parse(splitLine[32], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_pos_feedback_count", (Int32)UInt32.Parse(splitLine[33], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_completed_count", (Int32)UInt32.Parse(splitLine[34], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_neg_count", (Int32)UInt32.Parse(splitLine[35], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_avoiding_me_count", (Int32)UInt32.Parse(splitLine[36], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_pos_sessions_count", (Int32)UInt32.Parse(splitLine[37], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_neg_sessions_count", (Int32)UInt32.Parse(splitLine[38], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_neg_sessions_filtered_inzonelgctry_count", (Int32)UInt32.Parse(splitLine[39], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_neg_sessions_filtered_inzone_count", (Int32)UInt32.Parse(splitLine[40], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_neg_sessions_filtered_outzone_count", (Int32)UInt32.Parse(splitLine[41], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_iterations_inzonelgctry", (Int32)UInt32.Parse(splitLine[42], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_row_count_inzonelgctry", (Int32)UInt32.Parse(splitLine[43], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@f_std_rating_range_inzonelgctry", Double.Parse(splitLine[44]));
        cmd.Parameters.AddWithValue("@f_std_rating_upper_bound_inzonelgctry",  Double.Parse(splitLine[45]));
        cmd.Parameters.AddWithValue("@f_std_rating_lower_bound_inzonelgctry",  Double.Parse(splitLine[46]));
        cmd.Parameters.AddWithValue("@i_std_lower_hash_bound1_inzonelgctry", (Int32)UInt32.Parse(splitLine[47], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_upper_hash_bound1_inzonelgctry", (Int32)UInt32.Parse(splitLine[48], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_lower_hash_bound2_inzonelgctry", (Int32)UInt32.Parse(splitLine[49], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_upper_hash_bound2_inzonelgctry", (Int32)UInt32.Parse(splitLine[50], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_iterations_inzone", (Int32)UInt32.Parse(splitLine[51], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_row_count_inzone", (Int32)UInt32.Parse(splitLine[52], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@f_std_rating_range_inzone", Double.Parse(splitLine[53]));
        cmd.Parameters.AddWithValue("@f_std_rating_upper_bound_inzone",  Double.Parse(splitLine[54]));
        cmd.Parameters.AddWithValue("@f_std_rating_lower_bound_inzone",  Double.Parse(splitLine[55]));
        cmd.Parameters.AddWithValue("@i_std_lower_hash_bound1_inzone", (Int32)UInt32.Parse(splitLine[56], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_upper_hash_bound1_inzone", (Int32)UInt32.Parse(splitLine[57], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_lower_hash_bound2_inzone", (Int32)UInt32.Parse(splitLine[58], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_upper_hash_bound2_inzone", (Int32)UInt32.Parse(splitLine[59], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_iterations_outzone", (Int32)UInt32.Parse(splitLine[60], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_row_count_outzone", (Int32)UInt32.Parse(splitLine[61], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@f_std_rating_range_outzone", Double.Parse(splitLine[62]));
        cmd.Parameters.AddWithValue("@f_std_rating_upper_bound_outzone",  Double.Parse(splitLine[63]));
        cmd.Parameters.AddWithValue("@f_std_rating_lower_bound_outzone",  Double.Parse(splitLine[64]));
        cmd.Parameters.AddWithValue("@i_std_lower_hash_bound1_outzone", (Int32)UInt32.Parse(splitLine[65], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_upper_hash_bound1_outzone", (Int32)UInt32.Parse(splitLine[66], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_lower_hash_bound2_outzone", (Int32)UInt32.Parse(splitLine[67], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_std_upper_hash_bound2_outzone", (Int32)UInt32.Parse(splitLine[68], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchSplitSession(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 31)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_split_session_id", (Int64)UInt64.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@ti_server_type", Byte.Parse(splitLine[7]));
        cmd.Parameters.AddWithValue("@ti_nat_type", Byte.Parse(splitLine[8]));
        cmd.Parameters.AddWithValue("@bi_session_id", (Int64)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_public_open", (Int32)UInt64.Parse(splitLine[10], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_private_open", (Int32)UInt64.Parse(splitLine[11], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_public_filled", (Int32)UInt64.Parse(splitLine[12], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_private_filled", (Int32)UInt64.Parse(splitLine[13], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_attributes_len", (Int32)UInt64.Parse(splitLine[14], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_puid", (Int64)UInt64.Parse(splitLine[15], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@vc_gamer_hostname", splitLine[16]);
        cmd.Parameters.AddWithValue("@i_game_type", (Int32)UInt32.Parse(splitLine[17]));
        cmd.Parameters.AddWithValue("@bi_game_mode", (Int64)UInt64.Parse(splitLine[18]));
        cmd.Parameters.AddWithValue("@i_gamer_zone", (Int32)UInt32.Parse(splitLine[19]));
        cmd.Parameters.AddWithValue("@i_gamer_country", (Int32)UInt32.Parse(splitLine[20]));
        cmd.Parameters.AddWithValue("@i_gamer_language", (Int32)UInt32.Parse(splitLine[21]));
        cmd.Parameters.AddWithValue("@f_gamer_rating", Double.Parse(splitLine[22]));
        cmd.Parameters.AddWithValue("@f_gamer_mu", Double.Parse(splitLine[23]));
        cmd.Parameters.AddWithValue("@f_gamer_sigma", Double.Parse(splitLine[24]));
        cmd.Parameters.AddWithValue("@i_host_address", (Int32)UInt32.Parse(splitLine[25], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_host_address_online", (Int32)UInt32.Parse(splitLine[26], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_port_online", (Int32)UInt32.Parse(splitLine[27]));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[28], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[29], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[30], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchDeadXbox(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 10)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@vc_suboperation", splitLine[5]);
        cmd.Parameters.AddWithValue("@i_title_id", (Int32)UInt32.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[7], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[8], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[9], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static void ImportMatchDeadSg(SqlConnection cxn, string machinename,
        string[] splitLine, string line)
    {
        if (splitLine.Length != 8)
        {
            Console.WriteLine("Line has incorrect number of fields, skipping: " + line);
            return;
        }
        SqlCommand cmd = CreateInsertCommand(cxn);
        cmd.Parameters.AddWithValue("@vc_machinename", machinename);
        cmd.Parameters.AddWithValue("@dt_datetime", DateTime.Parse(splitLine[0]));
        cmd.Parameters.AddWithValue("@vc_operation", splitLine[1]);
        cmd.Parameters.AddWithValue("@i_seq_num", (Int32)UInt32.Parse(splitLine[2], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_elapsed_ms", (Int32)UInt32.Parse(splitLine[3]));
        cmd.Parameters.AddWithValue("@i_hr", (Int32)UInt32.Parse(splitLine[4], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_address", (Int32)UInt32.Parse(splitLine[5], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@i_sg_spi", (Int32)UInt32.Parse(splitLine[6], NumberStyles.HexNumber));
        cmd.Parameters.AddWithValue("@bi_xbox_id", (Int64)UInt64.Parse(splitLine[7], NumberStyles.HexNumber));
        cmd.ExecuteNonQuery();
    }

    private static SqlCommand CreateInsertCommand(SqlConnection cxn)
    {
        SqlCommand cmd = cxn.CreateCommand();
        cmd.CommandText = "p_insert_log_line";
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
     }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\dvt\Session.cs ===
using System;
using System.IO;
using System.Collections.Generic;

using xonline.common.protocol;
using xcs = xonline.common.service;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;

namespace xonline.server.match.test.dvt
{
    public class AttributeCollection : ICloneable
    {
        public List<MatchAttribute> Attributes;

        public AttributeCollection(int initialSize)
        {
            Attributes = new List<MatchAttribute>(initialSize);
        }

        public AttributeCollection()
        {
            Attributes = new List<MatchAttribute>();
        }

        public MatchAttribute this[uint id]
        {
            get 
            {
                foreach(MatchAttribute attr in Attributes)
                {
                    if(attr.dwAttributeId == id)
                    {
                        return attr;
                    }
                }
                return null;
            }
        }

        public void GenerateStandardAttributes()
        {
            GenerateAttributes(
                    (byte)MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                    0,
                    0,
                    103,
                    1,
                    0.0,
                    0.0,
                    0.0,
                    0);
        }

        public void GenerateRankedAttributes()
        {
            GenerateAttributes(
                    (byte)MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED,
                    0,
                    0,
                    103,
                    1,
                    0.0,
                    0.0,
                    0.0,
                    0);
        }

        public void GenerateAttributes(
                byte gameType, 
                byte gameMode, 
                byte zone, 
                byte country,
                byte lang,
                double rating, 
                double mu, 
                double sigma, 
                ulong puid)
        {
            Attributes.Clear();
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE, gameType));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_MODE, gameMode));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_ZONE, zone));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY, country));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, lang));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_RATING, (float)(0.0 != rating ? rating : Util.RandomRating())));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_MU, 0.0 != mu ? mu : Util.RandomMu()));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA, 0.0 != sigma ? sigma : Util.RandomSigma()));
            Attributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_PUID, puid));
            Attributes.Add(new MatchAttribute(Util.AddMatchDatatype(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME), ""));
        }

        public void Add(MatchAttribute attr)
        {
            if(Contains(attr))
            {
                throw new Exception("AttributeCollection already contains attribute: 0x" + attr.dwAttributeId.ToString("x"));
            }

            Attributes.Add(attr);
        }

        public bool Contains(MatchAttribute attr)
        {
            return Contains(attr.dwAttributeId);
        }

        public bool Contains(uint dwAttributeId)
        {
            foreach(MatchAttribute attr in Attributes)
            {
                if(attr.dwAttributeId == dwAttributeId)
                {
                    return true;
                }
            }

            return false;
        }

        public void SetOrAdd(MatchAttribute input)
        {
            if(!Contains(input))
            {
                Attributes.Add(input);
            }
            else
            {
                foreach(MatchAttribute attr in Attributes)
                {
                    if(attr.dwAttributeId == input.dwAttributeId)
                    {
                        switch(attr.dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK)
                        {
                            default:
                                throw new Exception("Unknown datatype for attribute ID: 0x" + input.dwAttributeId.ToString("x"));
                            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                                attr.qwValue = input.qwValue;
                                break;
                            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                                attr.strValue = input.strValue;
                                break;
                            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                                attr.rgbValue = input.rgbValue;
                                break;
                            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                                break;
                        }

                        // leave foreach
                        break;
                    }
                }
            }
        }

        public object Get(uint dwAttributeId, object defaultObj)
        {
            foreach(MatchAttribute attr in Attributes)
            {
                if(attr.dwAttributeId == dwAttributeId)
                {
                    switch(attr.dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                        default:
                            throw new Exception("Unknown datatype for attribute ID: 0x" + dwAttributeId.ToString("x"));
                        case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                            switch(attr.dwAttributeId & MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_MASK)
                            {
                                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT32:
                                    return attr.ToSingle();
                                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT64:
                                    return attr.ToDouble();
                                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT32:
                                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT:
                                    return (uint)attr.qwValue;
                                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT64:
                                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME:
                                default:
                                    break;
                            }
                            return attr.qwValue;
                        case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                            return attr.strValue;
                        case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                            return attr.rgbValue;
                        case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                            return null;
                    }
                }
            }

            return defaultObj;
        }

        public void Clear()
        {
            Attributes.Clear();
        }

        public void Remove(uint dwAttributeId)
        {
            int i = 0;
            while(i < Attributes.Count) 
            {
                MatchAttribute attr = Attributes[i];
                if(attr.dwAttributeId == dwAttributeId)
                {
                    Attributes.RemoveAt(i);
                    continue;
                }
                ++i;
            }
        }

        public void RemoveAttributes(params uint[] rgdwAttributeIds)
        {
            foreach(uint dwAttributeId in rgdwAttributeIds)
            {
                Remove(dwAttributeId);
            }
        }

        public object Clone()
        {
            // Duplicate all attribute objects
            AttributeCollection clone = new AttributeCollection(this.Attributes.Count);
            foreach(MatchAttribute attr in Attributes)
            {
                MatchAttribute newattr;

                switch(attr.dwAttributeId & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK)
                {
                    case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                        newattr = new MatchAttribute(attr.dwAttributeId, attr.qwValue);
                        break;
                    case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                        newattr = new MatchAttribute(attr.dwAttributeId, attr.strValue);
                        break;
                    case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                        newattr =  new MatchAttribute(attr.dwAttributeId, attr.rgbValue);
                        break;
                    case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                        newattr = new MatchAttribute(attr.dwAttributeId, 0);
                        break;
                    default:
                        throw new Exception("Unrecognized datatype in attribute ID: 0x" + attr.dwAttributeId.ToString());
                }

                clone.Attributes.Add(newattr);
            }
            return clone;
        }
    }

    //
    // Session wrapper represents a single session with all represented
    // data and operations on that session.
    //
    // Wrapper accessors are provided on the underlying attribute collection
    //
    // To use:
    // Session s = new Session();
    // s.GenerateStandardAttributes();
    // s.Advertise();
    //
    public class Session : ICloneable
    {

        public static Report RO = new Report("Session");

        public const byte PLATFORM_TYPE_XBOX1      = 0; 
        public const byte PLATFORM_TYPE_XENON      = 1; 
        public const byte PLATFORM_TYPE_PANORAMA   = 2; 

        public byte                 bServerType         = MatchDefs.XNET_XNKID_ONLINE_PEER;
        public byte                 bNatType            = MatchDefs.XONLINE_NAT_OPEN;
        public uint                 dwTitleId           = MatchDVT.TITLEID;
        public XNADDR               xnaddr              = Util.CreateRandomXNADDR();
        public uint                 dwPublicOpen        = 8;
        public uint                 dwPrivateOpen       = 0;
        public uint                 dwPublicFilled      = 4;
        public uint                 dwPrivateFilled     = 0;
        public ulong                qwSessionId         = 0;
        public byte[]               rgbKeyExchangeKey   = null;
        public AttributeCollection  AttributeCollection = new AttributeCollection();

        // For sginfo authenticated sessions
        public CSGInfo              sginfo;

        //------------------------------------------------------------------------------
        // Property accessors
        //------------------------------------------------------------------------------
        public MatchAttribute[] Attributes
        {
            get { return AttributeCollection.Attributes.ToArray(); }
        }

        public uint GameType
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_TYPE, value)); }
            get { return (uint)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAME_TYPE, (uint)0); }
        }

        public uint GameMode
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAME_MODE, value)); }
            get { return (uint)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAME_MODE, (uint)0); }
        }

        public byte GamerCountry
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY, (ulong)value)); }
            get { return (byte)(uint)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY, (uint)0); }
        }

        public byte GamerLanguage
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, (ulong)value)); }
            get { return (byte)(uint)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE, (uint)0); }
        }

        public string GamerHostname
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(Util.AddMatchDatatype(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME), value)); }
            get { return (string)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME, ""); }
        }

        public ulong GamerPuid
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_PUID, value)); }
            get { return (ulong)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_PUID, (ulong)0); }
        }

        public double GamerMu
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_MU, value)); }
            get { return (double)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_MU, (double)0.0); }
        }

        public double GamerSigma
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA, value)); }
            get { return (double)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA, (double)0.0); }
        }

        public float GamerRating
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_GAMER_RATING, value)); }
            get { return (float)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_GAMER_RATING, (float)0.0f); }
        }

        public ulong AffiliateValue
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE, value)); }
            get { return (ulong)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE, (ulong)0); }
        }

        public byte PlatformType
        {
            // Changing the platform type must recalculate the machine ID
            set 
            { 
                AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE, (ulong)value)); 
                xnaddr.sgaddr.qwXboxId = Util.RandomMachineId(value);
            }
            get { return (byte)(uint)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE, (uint)0); }
        }

        public byte PlatformLock
        {
            set { AttributeCollection.SetOrAdd(new MatchAttribute(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK, (ulong)value)); }
            get { return (byte)(uint)AttributeCollection.Get(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK, (uint)0); }
        }

        //------------------------------------------------------------------------------
        // Constructors
        //------------------------------------------------------------------------------
        public Session()
        {
            SetupSGInfo();
        }

        public Session(SearchResult sr)
        {
            qwSessionId             = sr.qwSessionId;
            xnaddr                  = sr.HostAddress.Copy();
            rgbKeyExchangeKey       = new byte[16];
            Array.Copy(sr.rgbKeyExchangeKey, rgbKeyExchangeKey, 16);
            dwPublicOpen            = sr.dwPublicOpen;
            dwPrivateOpen           = sr.dwPrivateOpen;
            dwPublicFilled          = sr.dwPublicFilled;
            dwPrivateFilled         = sr.dwPrivateFilled;
            AttributeCollection.Attributes.AddRange(sr.rgAttributes);

            SetupSGInfo();
        }


        public void SetupSGInfo()
        {
            sginfo = MatchReq.CreateSGInfo(
                    xnaddr,
                    GamerPuid,
                    xnaddr.sgaddr.qwXboxId,
                    0,
                    GamerCountry,
                    dwTitleId,  
                    GamerLanguage, 
                    0);
        }

        //------------------------------------------------------------------------------
        // Public methods
        //------------------------------------------------------------------------------
        public void Advertise()
        {
            uint hr;

            hr = MatchReq.InsertSession(
                    ref sginfo,
                    bServerType,
                    bNatType,
                    dwTitleId,
                    xnaddr,
                    dwPublicOpen,
                    dwPrivateOpen,
                    dwPublicFilled,
                    dwPrivateFilled,
                    Attributes,
                    out qwSessionId,
                    out rgbKeyExchangeKey);
            if(xcs.HResult.Failed(hr))
            {
                throw new HResultException(hr, "Session.Advertise failed, hr: " + hr.ToString("X8"));
            }

            Session.RO.Info("Advertised session id is {0:x}",  qwSessionId);
        }

        public void Update()
        {
            uint hr;

            hr = MatchReq.UpdateSession(
                    ref sginfo,
                    qwSessionId, 
                    dwTitleId, 
                    xnaddr, 
                    dwPublicOpen, 
                    dwPrivateOpen, 
                    dwPublicFilled, 
                    dwPrivateFilled, 
                    Attributes);
            if (xcs.HResult.Failed(hr))
            {
                throw new HResultException(hr, "Session.Update failed, hr: " + hr.ToString("X8"));
            }
        }

        public void Split(Session orig)
        {
            uint hr;

            SearchResult session;
            hr = MatchReq.SplitSession(
                    ref sginfo,
                    bServerType, 
                    bNatType,
                    dwTitleId,
                    xnaddr,
                    orig.qwSessionId,
                    Attributes,
                    out session);
            if(xcs.HResult.Failed(hr))
            {
                throw new HResultException(hr, "Session.Split failed, hr: " + hr.ToString("X"));
            }

            if(session.qwSessionId == qwSessionId)
            {
                throw new Exception("SessionId did not change after split");
            }

            {
                int i;
                for(i = 0; i < orig.rgbKeyExchangeKey.Length; ++i)
                {
                    if(session.rgbKeyExchangeKey != orig.rgbKeyExchangeKey)
                    {
                        break;
                    }
                }
                if(i > 0 && i == orig.rgbKeyExchangeKey.Length)
                {
                    throw new Exception("KEK did not change after split");
                }
            }

            if(        (session.HostAddress.ina == orig.xnaddr.ina) 
                    && (session.HostAddress.inaOnline == orig.xnaddr.inaOnline) 
                    && (session.HostAddress.wPortOnline == orig.xnaddr.wPortOnline) )
            {
                throw new Exception("HostAddress of new session did not change to new host address");
            }

            // Validate that slot info did not change
            ValueCheck.Test("Public open", dwPublicOpen, session.dwPublicOpen);
            ValueCheck.Test("Private open", dwPrivateOpen, session.dwPrivateOpen);
            ValueCheck.Test("Public filled", dwPublicFilled, session.dwPublicFilled);
            ValueCheck.Test("Private filled", dwPrivateFilled, session.dwPrivateFilled);

            // Test basic attribute values
            foreach(MatchAttribute attr in session.rgAttributes)
            {
                switch(attr.dwAttributeId)
                {
                    case MatchDefs.X_ATTRIBUTE_GAME_TYPE:
                    case MatchDefs.X_ATTRIBUTE_GAME_MODE:
                    case MatchDefs.X_ATTRIBUTE_GAMER_ZONE:
                    case MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY:
                    case MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE:
                    case MatchDefs.X_ATTRIBUTE_GAMER_RATING:
                    case MatchDefs.X_ATTRIBUTE_GAMER_MU:
                    case MatchDefs.X_ATTRIBUTE_GAMER_SIGMA:
                    case MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE:
                        // These attributes should stay the same as the original session
                        ValueCheck.Test(
                                "Standard attribute: 0x" + attr.dwAttributeId.ToString("X8"), 
                                orig.AttributeCollection[attr.dwAttributeId].qwValue, 
                                attr.qwValue);
                        break;
                    case MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME | MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                        // Hostname should change
                        if(orig.GamerHostname == attr.strValue)
                        {
                            throw new Exception("GamerHostname did not change after split");
                        }
                        break;
                    case MatchDefs.X_ATTRIBUTE_GAMER_PUID:
                        if(orig.GamerPuid == attr.qwValue)
                        {
                            throw new Exception("GamerPuid did not change after split");
                        }
                        break;
                    case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                        Session.RO.Debug("Null attribute");
                        break;
                    default:
                        Session.RO.Debug("Unchecked attribute: {0:x}", attr.dwAttributeId);
                        break;
                }
            }
        }

        public void Delete()
        {
        }


        // This will delete all sessions on the server tied to this xnaddr
        public void DeadXbox()
        {
            uint hr;

            // DeadXbox this user which will delete the session, we will have 5 minutes to split
            hr = MatchReq.DeadXbox(xnaddr.sgaddr, dwTitleId);
            if(xcs.HResult.Failed(hr))
            {
                throw new HResultException(hr, "Session.DeadXbox failed, hr: " + hr.ToString("X"));
            }
        }


        public object Clone()
        {
            Session clone = new Session();

            clone.bServerType               = bServerType;
            clone.bNatType                  = bNatType;
            clone.dwTitleId                 = dwTitleId;

            clone.xnaddr.ina                = xnaddr.ina;
            clone.xnaddr.inaOnline          = xnaddr.inaOnline;
            clone.xnaddr.wPortOnline        = xnaddr.wPortOnline;
            clone.xnaddr.abEnet             = new byte[6];
            Array.Copy(xnaddr.abEnet, clone.xnaddr.abEnet, 6);

            clone.xnaddr.sgaddr = new SGADDR();
            clone.xnaddr.sgaddr.inaSg       = xnaddr.sgaddr.inaSg;
            clone.xnaddr.sgaddr.dwSpiSg     = xnaddr.sgaddr.dwSpiSg;
            clone.xnaddr.sgaddr.qwXboxId    = xnaddr.sgaddr.qwXboxId; 
            clone.xnaddr.sgaddr.abReserved  = xnaddr.sgaddr.abReserved;

            clone.dwPublicOpen              = dwPublicOpen;
            clone.dwPrivateOpen             = dwPrivateOpen;
            clone.dwPublicFilled            = dwPublicFilled;
            clone.dwPrivateFilled           = dwPrivateFilled;
            clone.qwSessionId               = qwSessionId;
            clone.rgbKeyExchangeKey         = rgbKeyExchangeKey;

            clone.AttributeCollection = (AttributeCollection)AttributeCollection.Clone();

            return clone;
        }

        public void ValidateExistsOnServer()
        {
            ValidateExistsOnServer(true);
        }

        public void ValidateExistsOnServer(bool exists)
        {
            uint hr;
            ushort wNumUsers = 1;
            ushort wFlags = 0;
            ushort wNumSearchResults;
            ushort wFlagsOut;
            uint dwLoggingThreshold;
            SearchResult[] rgSearchResults;

            Session.RO.Info("{0}: 0x{1:x} exists on server", 
                exists ? "Validating session exists" : "Validating session does not exist",
                qwSessionId);

            hr = MatchReq.QuerySessionById(
                    ref sginfo,
                    qwSessionId, 
                    dwTitleId, 
                    xnaddr, 
                    wNumUsers, 
                    wFlags,
                    AttributeCollection.Contains(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK),
                    out wNumSearchResults, 
                    out wFlagsOut, 
                    out dwLoggingThreshold, 
                    out rgSearchResults);
            if (exists)
            {
                if(xcs.HResult.Failed(hr))
                {
                    throw new HResultException(hr, "MatchReq.QuerySessionById failed, hr: " + hr.ToString("X8"));
                }
                ValueCheck.Test("Number of findbyid results", (ushort)1, wNumSearchResults);
            }
            else
            {
                ValueCheck.Test("Number of findbyid results", (ushort)0, wNumSearchResults);
            }

            ValueCheck.Test("Search flags [out]", (ushort)0, wFlagsOut);
            ValueCheck.Test("Logging threshold [out]", (ushort)0, dwLoggingThreshold);
        }
    }

    public class SessionCollection
    {
        public string           PresenceDestination;
        public Session          SearchTemplate;
        public List<Session>    Results;
        public uint             dwTitleId;
        public uint             dwProcedureIndex;
        public XNADDR           xnaddr;
        public ushort           wNumUsers;
        public ushort           wFlags;

        public ushort           wOutNumSearchResults;
        public ushort           wOutFlags;
        public uint             dwOutLoggingThreshold;

        public SessionCollection()
            : this(new Session(), 0)
        {
        }

        public SessionCollection(Session template, uint procIndex)
        {
            SearchTemplate = template;

            dwTitleId           = template.dwTitleId;
            dwProcedureIndex    = procIndex;
            xnaddr              = template.xnaddr;
            wNumUsers           = 1;
            wFlags              = 0;

            Results = new List<Session>();
        }

        public void Search()
        {
            uint hr;
            ushort wOutNumSearchResults = 0;
            ushort wOutFlags = 0;
            uint dwOutLoggingThreshold = 0;

            Session.RO.Info("Searching for sessions for title: 0x{0:x}, proc: 0x{1:x}", 
                    dwTitleId, 
                    dwProcedureIndex);

            SearchResult []rgSearchResults;

            hr = MatchReq.QuerySession(
                    ref SearchTemplate.sginfo,
                    dwTitleId, 
                    dwProcedureIndex, 
                    xnaddr, 
                    wNumUsers, 
                    wFlags, 
                    SearchTemplate.Attributes, 
                    PresenceDestination,
                    out wOutNumSearchResults, 
                    out wOutFlags, 
                    out dwOutLoggingThreshold, 
                    out rgSearchResults);
            if (xcs.HResult.Failed(hr))
            {
                throw new HResultException(hr, "MatchReq.QuerySession failed, hr: " + hr.ToString("X8"));
            }

            Session.RO.Info("Search returned result count: {0}, flags: {1:x}, loggingThreshold: {2}",
                    wOutNumSearchResults,
                    wOutFlags,
                    dwOutLoggingThreshold);

            if(null != rgSearchResults && 0 != rgSearchResults.Length)
            {
                Results = new List<Session>(rgSearchResults.Length);
                // Convert the search results into session objects
                foreach(SearchResult result in rgSearchResults)
                {
                    Session session = new Session(result);
                    Results.Add(session);
                }
            }
            else
            {
                Results = new List<Session>();
            }
        }

        public void FindAllIds(ulong []sessionIds)
        {
            uint hr;
            ushort wOutNumSearchResults = 0;
            ushort wOutFlags = 0;
            uint dwOutLoggingThreshold = 0;

            dwProcedureIndex = MatchDefs.X_SSINDEX_GET_SESSION_LIST;

            Session.RO.Info("Searching for sessions for title: 0x{0:x}, proc: 0x{1:x}", 
                    dwTitleId, 
                    dwProcedureIndex);

            SearchResult []rgSearchResults;
            AttributeCollection attrCol = new AttributeCollection();
            attrCol.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST, 
                        MatchDefs.SessionIdListToBytes(sessionIds)));

            hr = MatchReq.QuerySession(
                    ref SearchTemplate.sginfo,
                    dwTitleId, 
                    dwProcedureIndex, 
                    xnaddr, 
                    wNumUsers, 
                    wFlags, 
                    attrCol.Attributes.ToArray(),
                    PresenceDestination,
                    out wOutNumSearchResults, 
                    out wOutFlags, 
                    out dwOutLoggingThreshold, 
                    out rgSearchResults);
            if (xcs.HResult.Failed(hr))
            {
                throw new HResultException(hr, "MatchReq.QuerySession failed, hr: " + hr.ToString("X8"));
            }

            Session.RO.Info("Search returned result count: {0}, flags: {1:x}, loggingThreshold: {2}",
                    wOutNumSearchResults,
                    wOutFlags,
                    dwOutLoggingThreshold);

            if(null != rgSearchResults && 0 != rgSearchResults.Length)
            {
                Results = new List<Session>(rgSearchResults.Length);
                // Convert the search results into session objects
                foreach(SearchResult result in rgSearchResults)
                {
                    Session session = new Session(result);
                    Results.Add(session);
                }
            }
            else
            {
                Results = new List<Session>();
            }
        }

        public void ValidateContains(ulong []ids)
        {
            if(ids.Length != Results.Count)
            {
                throw new UnexpectedTestResultException(
                        String.Format("Expected {0} results, got {1}",
                            ids.Length,
                            Results.Count));
            }

            for(int i = 0; i < ids.Length; ++i)
            {
                if(ids[i] != Results[i].qwSessionId)
                {
                    throw new UnexpectedTestResultException(
                            String.Format("Unexpected session: 0x{0:x8} unexpected at index: {1}, expected session: 0x{2:x8}",
                                Results[i].qwSessionId,
                                i,
                                ids[i]));
                }
            }
        }

        public void ValidateContains(Session s)
        {
            foreach(Session search in Results)
            {
                if(search.qwSessionId == s.qwSessionId)
                {
                    return;
                }
            }

            throw new UnexpectedTestResultException("Session: 0x" + s.qwSessionId.ToString("x") + " not found in results");
        }

        public void ValidateDoesNotContain(Session s)
        {
            foreach(Session search in Results)
            {
                if(search.qwSessionId == s.qwSessionId)
                {
                    throw new UnexpectedTestResultException("Session: 0x" + s.qwSessionId.ToString("x") + " found in results");
                }
            }

        }
        public void ValidateAffiliateValue(Session s, ulong affiliateValue)
        {
            foreach(Session result in Results)
            {
                if(result.qwSessionId == s.qwSessionId)
                {
                    ValueCheck.Test("Session: [0x" + result.qwSessionId.ToString("x") + "].AffiliateValue", 
                            affiliateValue, 
                            result.AffiliateValue);
                } 
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\dvt\MatchReq.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Collections.Generic;

using xsc = xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;

namespace xonline.server.match.test.dvt
{

    // 
    // Track a created session for deletion
    //
    public class SessionTracker
    {
        public ulong qwSessionId;
        public uint dwTitleId;

        public SessionTracker(ulong s, uint t)
        {
            qwSessionId = s;
            dwTitleId = t;
        }
    }

    //
    // Utility wrappers for making requests and replies as easy as a simple function call
    //
    public class MatchReq
    {
        //------------------------------------------------------------------------------
        // Global data
        //------------------------------------------------------------------------------
        private static List<SessionTracker> SessionsForCleanup  = new List<SessionTracker>();
        public static bool PrintResponseBytes                   = false;
        public static string AuthData                           = null;

        //------------------------------------------------------------------------------
        // Begin helper methods
        //------------------------------------------------------------------------------

        private static void PrintBytes(byte []data)
        {
            string[] lines = xsc.ByteConvert.ToFormattedStrings(data); 
            foreach(string line in lines)
            {
                Global.RO.Debug("{0}", line);
            }
        }

        // Query and clean until we have removed all sessions
        public static void FindAndCleanupAllSessions(uint dwTitleId)
        {
            uint hr;
            ushort numSearchResults;
            ushort flagsOut;
            uint loggingThreshold;
            SearchResult[] searchResults;
            MatchAttribute[] parameters = new MatchAttribute[9];
            XNADDR xnaddr = Util.CreateRandomXNADDR();

            CSGInfo sginfo = MatchReq.CreateSGInfo(
                    xnaddr,
                    1234,
                    Util.RandomMachineId(XOn.XPLT_XBOX360),
                    0,
                    0,
                    MatchDVT.TITLEID,
                    1,
                    0);

            parameters[0] = new MatchAttribute();
            parameters[0].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAME_TYPE;
            parameters[0].qwValue = MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD;
            parameters[1] = new MatchAttribute();
            parameters[1].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAME_MODE;
            parameters[1].qwValue = 0;
            parameters[2] = new MatchAttribute();
            parameters[2].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_ZONE;
            parameters[2].qwValue = 0;
            parameters[3] = new MatchAttribute();
            parameters[3].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY;
            parameters[3].qwValue = 0;
            parameters[4] = new MatchAttribute();
            parameters[4].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE;
            parameters[4].qwValue = 0;
            parameters[5] = new MatchAttribute();
            parameters[5].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_RATING;
            parameters[5].qwValue = 0;
            parameters[6] = new MatchAttribute();
            parameters[6].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_MU;
            parameters[6].qwValue = 0;
            parameters[7] = new MatchAttribute();
            parameters[7].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_SIGMA;
            parameters[7].qwValue = 0;
            parameters[8] = new MatchAttribute();
            parameters[8].dwAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_PUID;
            parameters[8].qwValue = 0;

            for(;;)
            {

                //
                // Standard match session cleanup
                //
                uint totalFound = 0;
                Global.RO.Info("Finding standard sessions to clean...");
                parameters[0].qwValue = MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD;
                hr = MatchReq.QuerySession(
                        ref sginfo,
                        dwTitleId, 
                        0, 
                        xnaddr, 
                        1,
                        MatchDefs.XONLINE_NAT_OPEN,
                        parameters,
                        null,
                        out numSearchResults,
                        out flagsOut,
                        out loggingThreshold,
                        out searchResults);
                if (xsc.HResult.Failed(hr))
                {
                    Global.RO.Error("QuerySession failed with hr: {0:x}, {1}",
                            hr,
                            Global.XErrToString(hr));
                    break;
                }

                if(0 != numSearchResults)
                {
                    foreach(SearchResult result in searchResults)
                    {
                        RegisterSessionForCleanup(result.qwSessionId, dwTitleId);
                    }

                    totalFound += numSearchResults;
                }

                // 
                // Ranked match session cleanup
                //
                Global.RO.Info("Finding ranked sessions to clean...");
                parameters[0].qwValue = MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED;
                hr = MatchReq.QuerySession(
                        ref sginfo,
                        dwTitleId,
                        0,
                        xnaddr,
                        1,
                        MatchDefs.XONLINE_NAT_OPEN,
                        parameters,
                        null,
                        out numSearchResults,
                        out flagsOut,
                        out loggingThreshold,
                        out searchResults);
                if (xsc.HResult.Failed(hr))
                {
                    Global.RO.Error("QuerySession failed with hr: {0:x}, {1}",
                            hr,
                            Global.XErrToString(hr));
                    break;
                }

                if(0 != numSearchResults)
                {
                    foreach(SearchResult result in searchResults)
                    {
                        RegisterSessionForCleanup(result.qwSessionId, dwTitleId);
                    }
                    totalFound += numSearchResults;
                }

                // Do the cleanup
                CleanupSessions();

                if(0 == totalFound)
                {
                    break;
                }
            }

            Global.RO.Info("FindAndCleanupAllSessions finished for title: {0:x}", dwTitleId);
        }

        // Just reset the list to a clean state
        public static void ClearSessionsForCleanup()
        {
            SessionsForCleanup.Clear();
        }

        // Register a session to cleanup
        public static void RegisterSessionForCleanup(ulong qwSessionId, uint dwTitleId)
        {
            SessionsForCleanup.Add(new SessionTracker(qwSessionId, dwTitleId));
        }

        // Cleanup any sessions that were created 
        public static void CleanupSessions()
        {
            Global.RO.Info("CleanupSessions: cleaning {0} sessions", SessionsForCleanup.Count);
            XNADDR xnaddr = Util.CreateRandomXNADDR();
            CSGInfo sginfo = MatchReq.CreateSGInfo(
                    xnaddr,
                    1234,
                    Util.RandomMachineId(XOn.XPLT_XBOX360),
                    0,
                    0,
                    MatchDVT.TITLEID,
                    1,
                    0);

            foreach(SessionTracker session in SessionsForCleanup)
            {
                try
                {
                    uint hr = MatchReq.DeleteSession(
                            ref sginfo,
                            session.qwSessionId,
                            session.dwTitleId);
                    if(xsc.HResult.Failed(hr))
                    {
                        Global.RO.Error("Failed to delete session: {0:x}, HR: 0x{1:x} ({2})",
                                session.qwSessionId,
                                hr,
                                Global.XErrToString(hr));
                    }
                }
                catch(Exception ex)
                {
                    Global.RO.Error("Unexpected exception trying to cleanup session: {0:x}, {1}",
                            session.qwSessionId,
                            ex.ToString());
                }
            }

            SessionsForCleanup.Clear();
        }

        // I needed an overload of PostXrlRequest that was not offered by XRLUtil
        // but I didn't want to modify that heavily shared class just for a single
        // test case in my DVT. Therefore I've added the utility function here.
        private static uint PostXrlRequest(
                ref CSGInfo slot,
                string viface,
                string path,
                xsc.XRLObject2 postOb,
                WebHeaderCollection reqHeaders,
                xsc.XRLObject2 respOb)
        {
            uint hr;
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            
            postOb.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);
            writer.Flush();

            byte[] requestData = stream.ToArray();

            /*
             * hr = XRLUtil.PostXrlRequest(viface, path, authData,
             *      stream.ToArray(), headers, out respData);
             */

            MemoryStream reqStream = new MemoryStream(requestData, 0, requestData.Length, true, true);

            string uri = "POST " + path + " HTTP/1.0\r\n";

            WebHeaderCollection headers = new WebHeaderCollection();
            headers.Add("Content-Type", "xon/" + ((int)xsc.XOService.Matchmaking).ToString("x"));
            headers.Add("User-Agent", ((int)xsc.XOService.Matchmaking).ToString("x")+"/1.0.4325");
            headers.Add("Content-Length", reqStream.Length.ToString());
            if (null != reqHeaders)
            {
                headers.Add(reqHeaders);
            }

            FDTransaction xAct = new FDTransaction();



            IVirtualInterfaceInfo fdInfo = Config.GetVirtualInterface(viface, Config.MainSiteId);
            string addr =  fdInfo.IPAddressString + ":" + fdInfo.Port;
            LiveServer ls = new LiveServer(xsc.XOService.Matchmaking.ToString(), addr);
            xAct.endPoint = ls.EPDefault;
            xAct.AppendSGIPPort = false;

            string headerString = uri + headers.ToString();
            ASCIIEncoding ascii = new ASCIIEncoding();
            byte[] headerBytes = ascii.GetBytes(headerString);

            bool retValue = xAct.Execute(headerBytes, reqStream, ref slot);

            hr = xAct.XErr;

            byte[] responseData = xAct.ResponseContents;

            if ( !retValue && xsc.HResult.Succeeded(hr) )
            {
                throw new Exception("MatchReq.PostXrlRequest: failed request: " + headerString);
            }

            if(respOb != null && responseData != null && responseData.Length != 0)
            {
                BinaryReader reader = new BinaryReader(new MemoryStream(responseData));
                if(PrintResponseBytes)
                {
                    Global.RO.Debug("Response payload: ");
                    PrintBytes(responseData);
                }

                respOb.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, responseData.Length, null);
            }

            return hr;
        }

        public static uint InsertSession(
                ref CSGInfo slot,
                byte bServerType,
                byte bNatType,
                uint dwTitleId,
                XNADDR xnaddr,
                uint dwPublicOpen,
                uint dwPrivateOpen,
                uint dwPublicFilled,
                uint dwPrivateFilled,
                MatchAttribute[] rgAttributes,
                out ulong qwSessionId,
                out byte[] rgbKeyExchangeKey)
        {
            MatchSessionMsg request = new MatchSessionMsg();
            MatchSessionReply response = new MatchSessionReply();

            // Build the request
            request.qwSessionId = (ulong) bServerType | (ulong) bNatType << 4;
            request.dwTitleId = dwTitleId;
            request.dwPublicOpen = dwPublicOpen;
            request.dwPrivateOpen = dwPrivateOpen;
            request.dwPublicFilled = dwPublicFilled;
            request.dwPrivateFilled = dwPrivateFilled;

            // Set up the XNADDR
            if( null == xnaddr )
            {
                xnaddr = new XNADDR();
                xnaddr.ina = 0;
                xnaddr.inaOnline = 0;
                xnaddr.wPortOnline = 0;
                xnaddr.abEnet = new byte[ 6 ];
                xnaddr.sgaddr = new SGADDR();
                xnaddr.sgaddr.inaSg = 0;
                xnaddr.sgaddr.dwSpiSg = 0;
                xnaddr.sgaddr.qwXboxId = 0;
                xnaddr.sgaddr.abReserved = 0;
            }
            request.HostAddress = xnaddr;

            // Set up the attributes
            if( null == rgAttributes )
            {
                rgAttributes = new MatchAttribute[ 0 ];
            }
            request.rgAttributes = rgAttributes;

            // Set up the attribute offsets
            uint dwTotalSize = request.GetBaseSize() + ( 4 * (uint) rgAttributes.Length );
            request.rgdwAttrOffsets = new uint[ rgAttributes.Length ];
            for( int iAttrib = 0; iAttrib < rgAttributes.Length; iAttrib++ )
            {
                request.rgdwAttrOffsets[ iAttrib ] = dwTotalSize;
                dwTotalSize += rgAttributes[ iAttrib ].GetSize();
            }

            // Store the total size
            request.dwMessageLength = dwTotalSize;

            // Call the front door to handle the request
            uint hr = PostXrlRequest(
                    ref slot,
                    VirtualInterface.xmatchfd,
                    "/xmatch/xmatchhost2.ashx", 
                    request,
                    null,
                    response);
            if( xsc.HResult.Failed( hr ) )
            {
                qwSessionId = 0;
                rgbKeyExchangeKey = null;

                return hr;
            }

            qwSessionId = response.qwSessionId;
            rgbKeyExchangeKey = response.rgbKeyExchangeKey;

            RegisterSessionForCleanup(qwSessionId, dwTitleId);

            return hr;
        }

        public static uint UpdateSession(
                ref CSGInfo slot,
                ulong qwSessionId,
                uint dwTitleId,
                XNADDR xnaddr,
                uint dwPublicOpen,
                uint dwPrivateOpen,
                uint dwPublicFilled,
                uint dwPrivateFilled,
                MatchAttribute[] rgAttributes)
        {
            MatchSessionMsg request = new MatchSessionMsg();
            MatchSessionReply response = new MatchSessionReply();

            // Build the request
            request.qwSessionId = qwSessionId;
            request.dwTitleId = dwTitleId;
            request.dwPublicOpen = dwPublicOpen;
            request.dwPrivateOpen = dwPrivateOpen;
            request.dwPublicFilled = dwPublicFilled;
            request.dwPrivateFilled = dwPrivateFilled;

            // Set up the XNADDR
            if( null == xnaddr )
            {
                xnaddr = new XNADDR();
                xnaddr.ina = 0;
                xnaddr.inaOnline = 0;
                xnaddr.wPortOnline = 0;
                xnaddr.abEnet = new byte[ 6 ];
                xnaddr.sgaddr = new SGADDR();
                xnaddr.sgaddr.inaSg = 0;
                xnaddr.sgaddr.dwSpiSg = 0;
                xnaddr.sgaddr.qwXboxId = 0;
                xnaddr.sgaddr.abReserved = 0;
            }
            request.HostAddress = xnaddr;

            // Set up the attributes
            if( null == rgAttributes )
            {
                rgAttributes = new MatchAttribute[ 0 ];
            }
            request.rgAttributes = rgAttributes;

            // Set up the attribute offsets
            uint dwTotalSize = request.GetBaseSize() + ( 4 * (uint) rgAttributes.Length );
            request.rgdwAttrOffsets = new uint[ rgAttributes.Length ];
            for( int iAttrib = 0; iAttrib < rgAttributes.Length; iAttrib++ )
            {
                request.rgdwAttrOffsets[ iAttrib ] = dwTotalSize;
                dwTotalSize += rgAttributes[ iAttrib ].GetSize();
            }

            // Store the total size
            request.dwMessageLength = dwTotalSize;

            // Call the front door to handle the request
            uint hr = PostXrlRequest(
                    ref slot,
                    VirtualInterface.xmatchfd,
                    "/xmatch/xmatchhost2.ashx",
                    request,
                    null,
                    response);
            return hr;
        }

        public static uint DeleteSession(
                ref CSGInfo slot,
                ulong qwSessionId,
                uint dwTitleId)
        {
            MatchDeleteMsg request = new MatchDeleteMsg();

            // Build the request
            request.qwSessionId = qwSessionId;
            request.dwTitleId = dwTitleId;
            request.dwMessageLength = request.GetBaseSize();

            // Call the front door to handle the request
            uint hr = PostXrlRequest(
                    ref slot,
                    VirtualInterface.xmatchfd,
                    "/xmatch/xmatchhostdelete2.ashx",
                    request,
                    null,
                    null);

            return hr;
        }

        public static uint QuerySession(
                ref CSGInfo slot,
                uint dwTitleId,
                uint dwProcedureIndex,
                XNADDR xnaddr,
                ushort wNumUsers,
                ushort wFlags,
                MatchAttribute[] rgParameters,
                string alternatePresenceDestination,
                out ushort wNumSearchResults,
                out ushort wFlagsOut,
                out uint dwLoggingThreshold,
                out SearchResult[] rgSearchResults)
        {
            MatchSearchMsg request = new MatchSearchMsg();
            MatchSearchReply response = new MatchSearchReply();

            // Build the request
            request.dwTitleId = dwTitleId;
            request.dwProcedureIndex = dwProcedureIndex;
            request.wNumUsers = wNumUsers;
            request.wFlags = wFlags;

            // Set up the XNADDR
            if( null == xnaddr )
            {
                xnaddr = new XNADDR();
                xnaddr.ina = 0;
                xnaddr.inaOnline = 0;
                xnaddr.wPortOnline = 0;
                xnaddr.abEnet = new byte[ 6 ];
                xnaddr.sgaddr = new SGADDR();
                xnaddr.sgaddr.inaSg = 0;
                xnaddr.sgaddr.dwSpiSg = 0;
                xnaddr.sgaddr.qwXboxId = 0;
                xnaddr.sgaddr.abReserved = 0;
            }
            request.ClientAddress = xnaddr;

            // Set up the parameters
            if(null == rgParameters)
            {
                rgParameters = new MatchAttribute[0];
            }
            request.rgParameters = rgParameters;

            // Set up the parameter offsets
            uint dwTotalSize = request.GetBaseSize() + (4 * (uint)rgParameters.Length);
            request.rgdwParamOffsets = new uint[rgParameters.Length];
            for(int iParam = 0; iParam < rgParameters.Length; iParam++)
            {
                request.rgdwParamOffsets[iParam] = dwTotalSize;
                dwTotalSize += rgParameters[iParam].GetSize();
            }

            // Store the total size
            request.dwMessageLength = dwTotalSize;

            // setup the AlternatePresenceDestination header, if passed
            WebHeaderCollection headers = null;
            if (alternatePresenceDestination != null)
            {
                headers = new WebHeaderCollection();
                headers.Add(MatchDefs.AlternatePresenceDestinationHeaderName,
                        alternatePresenceDestination);
            }

            // Call the front door to handle the request
            uint hr = PostXrlRequest(
                    ref slot,
                    VirtualInterface.xmatchfd,
                    "/xmatch/xmatchclient2.ashx",
                    request,
                    headers,
                    response);
            if(xsc.HResult.Failed(hr))
            {
                wNumSearchResults = 0;
                wFlagsOut = 0;
                dwLoggingThreshold = 0;
                rgSearchResults = new SearchResult[0];
                return hr;
            }

            wNumSearchResults = response.wNumSearchResults;
            wFlagsOut = response.wFlags;
            dwLoggingThreshold = response.dwLoggingThreshold;
            rgSearchResults = response.rgResults;
            return hr;
        }

        public static uint QuerySessionById(
                ref CSGInfo slot,
                ulong qwSessionId,
                uint dwTitleId,
                XNADDR xnaddr,
                ushort wNumUsers,
                ushort wFlags,
                bool fPlatformLock,
                out ushort wNumSearchResults,
                out ushort wFlagsOut,
                out uint dwLoggingThreshold,
                out SearchResult[] rgSearchResults)
        {
            MatchAttribute[] rgParameters; 

            if(fPlatformLock)
            {
                rgParameters = new MatchAttribute[2];
                rgParameters[0] = new MatchAttribute();
                rgParameters[0].dwAttributeId = MatchDefs.X_ATTRIBUTE_SESSION_ID;
                rgParameters[0].qwValue = qwSessionId;

                rgParameters[1] = new MatchAttribute();
                rgParameters[1].dwAttributeId = MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK;
                rgParameters[1].qwValue = 1;
            }
            else
            {
                rgParameters = new MatchAttribute[1];
                rgParameters[0] = new MatchAttribute();
                rgParameters[0].dwAttributeId = MatchDefs.X_ATTRIBUTE_SESSION_ID;
                rgParameters[0].qwValue = qwSessionId;
            }

            uint hr = QuerySession(
                    ref slot,
                    dwTitleId,
                    MatchDefs.X_SSINDEX_GET_SESSION,
                    xnaddr,
                    wNumUsers,
                    wFlags,
                    rgParameters,
                    null,
                    out wNumSearchResults,
                    out wFlagsOut,
                    out dwLoggingThreshold,
                    out rgSearchResults);

            return hr;
        }

        public static uint SplitSession(
                ref CSGInfo slot,
                byte bServerType,
                byte bNatType,
                uint dwTitleId,
                XNADDR xnaddr,
                ulong qwSplitSessionId,
                MatchAttribute[] rgAttributes,
                out SearchResult session)
        {
            MatchSplitMsg request = new MatchSplitMsg();
            MatchSplitReply response = new MatchSplitReply();
            session = null;

            // Build the request
            request.qwSessionId = (ulong) bServerType | (ulong) bNatType << 4;
            request.qwSplitSessionId = qwSplitSessionId;
            request.dwTitleId = dwTitleId;

            // Set up the XNADDR
            if( null == xnaddr )
            {
                xnaddr = new XNADDR();
                xnaddr.ina = 0;
                xnaddr.inaOnline = 0;
                xnaddr.wPortOnline = 0;
                xnaddr.abEnet = new byte[ 6 ];
                xnaddr.sgaddr = new SGADDR();
                xnaddr.sgaddr.inaSg = 0;
                xnaddr.sgaddr.dwSpiSg = 0;
                xnaddr.sgaddr.qwXboxId = 0;
                xnaddr.sgaddr.abReserved = 0;
            }
            request.HostAddress = xnaddr;

            // Set up the attributes
            if( null == rgAttributes )
            {
                rgAttributes = new MatchAttribute[ 0 ];
            }
            request.rgAttributes = rgAttributes;

            // Set up the attribute offsets
            uint dwTotalSize = request.GetBaseSize() + ( 4 * (uint) rgAttributes.Length );
            request.rgdwAttrOffsets = new uint[ rgAttributes.Length ];
            for( int iAttrib = 0; iAttrib < rgAttributes.Length; iAttrib++ )
            {
                request.rgdwAttrOffsets[ iAttrib ] = dwTotalSize;
                dwTotalSize += rgAttributes[ iAttrib ].GetSize();
            }

            // Store the total size
            request.dwMessageLength = dwTotalSize;

            // Call the front door to handle the request
            uint hr = PostXrlRequest(
                    ref slot,
                    VirtualInterface.xmatchfd,
                    "/xmatch/xmatchsplit.ashx",
                    request, 
                    null, 
                    response);
            if( xsc.HResult.Failed( hr ) )
            {
                return hr;
            }

            session = response.Session;

            RegisterSessionForCleanup(session.qwSessionId, dwTitleId);

            return hr;
        }

        public static uint DeadXbox(SGADDR sgaddr, uint dwTitleId)
        {
            CSgMsgNotifyCliDelete request = new CSgMsgNotifyCliDelete();

            request._sgaddr = sgaddr;
            request._dwTitleId = dwTitleId;

            CSGInfo sginfo = MatchReq.CreateSGInfo(
                    Util.CreateRandomXNADDR(),
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0);

            uint hr = PostXrlRequest(
                    ref sginfo,
                    VirtualInterface.xmatchfd_int, 
                    "/xmatch/deadxbox.ashx", 
                    request, 
                    null, 
                    null);

            return hr;
        }

        public static uint DeadSg(SGADDR sgaddr)
        {
            CSgMsgNotifyCliDelete request = new CSgMsgNotifyCliDelete();
            request._sgaddr = new SGADDR();

            CSGInfo sginfo = MatchReq.CreateSGInfo(
                    Util.CreateRandomXNADDR(),
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0);

            // Zero out field required to make this a deadsg message
            request._sgaddr.inaSg       = sgaddr.inaSg;
            request._sgaddr.dwSpiSg     = 0;
            request._sgaddr.qwXboxId    = 0;
            request._sgaddr.abReserved  = 0;
            request._dwTitleId          = 0;

            uint hr = PostXrlRequest(
                    ref sginfo,
                    VirtualInterface.xmatchfd_int,
                    "/xmatch/deadxbox.ashx",
                    request,
                    null,
                    null);

            return hr;
        }

        public static CSGInfo CreateSGInfo(
                XNADDR xnaddr,
                ulong userId,
                ulong machineId,
                byte tier,
                byte countryId,
                uint titleId,
                ushort languageId,
                uint authDataFlags)
        {
            CSGInfo sginfo = GlobalFakeSG.FakeSG.GetSlot();

            sginfo.Initialize();
            sginfo.ipaI                     = xnaddr.inaOnline;
            sginfo.ipportI                  = xnaddr.wPortOnline;
            sginfo.userPuid0                = userId;
            sginfo.userFlag0                = ((((uint)tier << 4) << 8) | ((uint)countryId << 8));
            sginfo.userTrust0               = 0.0f;
            sginfo.machinePuid              = machineId;
            sginfo.titleId                  = titleId;
            sginfo.languageID               = languageId;
            sginfo.wMajorVersion            = 2;
            sginfo.wMinorVersion            = 0;
            sginfo.wBuildNumber             = 2732;
            sginfo.wQFENumber               = 0;
            sginfo.authDataFlags            = authDataFlags;
            sginfo.SetPrivilege(xsc.XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER);

            return sginfo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\matchsqlgen\matchsqlgen.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Xml;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.match;

[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.server.match.test.matchsqlgen
{
    class MatchSqlGen
    {
        private static void Usage()
        {
            //                0.........1.........2.........3.........4.........5.........6.........7.........8
            Console.WriteLine("");
            Console.WriteLine("Generates a SQL script that can be used to create match tables and databases.");
            Console.WriteLine("Note: this is not intended to be a production tool. It is primarily a way to");
            Console.WriteLine("execute the match SQL code generator in a standalone fashion in order to");
            Console.WriteLine("inspect the resulting SQL code. To configure matchmaking in a real");
            Console.WriteLine("environment, use LiveMatch.exe");
            Console.WriteLine("");
            Console.WriteLine("Usage:");
            Console.WriteLine("    MatchSqlGen <filename> [droptable]");
            Console.WriteLine("");
            Console.WriteLine("    <filename> is the xlast or xms file to process.");
            Console.WriteLine("    output will be sent to <filename>.sql. Any existing <filename>.sql");
            Console.WriteLine("    will be overwritten. Note that this utility only generates sql for");
            Console.WriteLine("    the matchmaking database. LiveMatch.exe also updates tables in npdb");
            Console.WriteLine("    when configuring a title, and this utility does not generate code");
            Console.WriteLine("    to update those tables. If [droptable] is specified as a second command");
            Console.WriteLine("    line parameter, then the table creation code will include statements");
            Console.WriteLine("    to drop any existing matchmaking table for the title.");
            Console.WriteLine("");
        }

        public static int Main(string[] args)
        {
            try
            {
                if (args.Length < 1 || args.Length > 2)
                {
                    Usage();
                    Console.WriteLine("Error: Incorrect number of command line arguments");
                    return -1;
                }

                string filename = args[0];
                bool droptable = false;
                if (args.Length > 1)
                {
                    if (args[1] == "droptable")
                    {
                        droptable = true;
                    }
                }

                if(filename.ToLower().EndsWith(".xlast"))
                {
                    ProcessXlast(filename, droptable);
                }
                else if(filename.ToLower().EndsWith(".xms"))
                {
                    ProcessXms(filename, droptable);
                }
                else if(filename.ToLower().EndsWith("_ltc.xml"))
                {
                    ProcessLtc(filename);
                }
                else
                {
                    Console.WriteLine("Invalid filename, is not of type .xlast or .xms");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("");
                Console.WriteLine("Error: " + e.Message);
                Console.WriteLine("At: " + e.StackTrace);
                return -1;
            }

            return 0;
        }

        static void ProcessXlast(string filename, bool droptable)
        {
            Console.WriteLine("Parsing XLAST: " + filename);
            MatchGameConfig matchConfig = ParseXlastFile(filename);

            string outputFilename = matchConfig.TitleId.ToString("X8") + ".sql";
            Console.WriteLine("Writing SQL script to " + outputFilename);

            using (StreamWriter writer = new StreamWriter(outputFilename))
            {
                WriteSqlStatements(writer, MatchSqlCodeGen.All(matchConfig, droptable));
            }
                
            Console.WriteLine("SQL Script generation complete");
        }

        private static void ProcessXms(string filename, bool droptable)
        {
            Console.WriteLine("Parsing XMS: " + filename);

            MatchGameConfig matchConfig = ParseXmsFile(filename);

            string outputFilename = matchConfig.TitleId.ToString("X8") + ".sql";
            Console.WriteLine("Writing SQL script to " + outputFilename);

            // Populate settings to generate SQL code
            MatchSqlCodeGenXbox1.Settings settings = new MatchSqlCodeGenXbox1.Settings();
            settings.InputFilename = filename;
            settings.ServerList = "";
            settings.DropTable = droptable;
            settings.NoNat = false;

            MatchSqlCodeGenXbox1 codeGen = new MatchSqlCodeGenXbox1(Console.Out);
            codeGen.EmitTitleSQL(matchConfig, settings);
        }

        private static void ProcessLtc(string filename)
        {
            Console.WriteLine("Parsing LTC: " + filename);

            XmlDocument doc = new XmlDocument();
            doc.Load(filename);

            MatchLtcConfig config;
            MatchLtcConfigLoader loader = new MatchLtcConfigLoader();
            loader.Load(doc, Console.Out, out config);


            Console.WriteLine("LTC Settings:");
            Console.WriteLine("TitleId:            {0:X}", config.TitleId);
            Console.WriteLine("MatchServerList:    {0}", config.MatchServerList);
            Console.WriteLine("MatchExpiration:    {0}", config.MatchExpiration);
            Console.WriteLine("DeleteDelaySeconds: {0}", config.DeleteDelaySeconds);

            Console.WriteLine("Updating LTC config in NPDB");
            string []serverList = config.MatchServerList.Split(';');
            MatchAdmin.ApplyTitleConfigToNPDB(config, serverList);
        }

        private static MatchGameConfig ParseXlastFile(string filename)
        {
            string xlastXml = null;
            using (StreamReader reader = new StreamReader(filename))
            {
                xlastXml = reader.ReadToEnd();
            }

            // Load xlast game config
            MatchGameConfig config;
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xlastXml);
            MatchXlastConfigLoader loader = new MatchXlastConfigLoader();
            loader.Load(doc, Console.Out, out config);

            return config;
        }

        private static MatchGameConfig ParseXmsFile(string filename)
        {
            string xmsXml = null;
            using (StreamReader reader = new StreamReader(filename))
            {
                xmsXml = reader.ReadToEnd();
            }

            MatchGameConfig config;

            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmsXml);

            MatchXmsConfigLoader loader = new MatchXmsConfigLoader();
            loader.Load(doc, Console.Out, out config);

            return config;
        }

        private static void WriteSqlStatements(StreamWriter writer, string[] statements)
        {
            foreach (string statement in statements)
            {
                writer.Write(statement);
                writer.WriteLine("");
                writer.WriteLine("GO");
                writer.WriteLine("");
            }
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\test\dvt\Stress.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;

using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;

namespace xonline.server.match.test.dvt
{
    public class StressException : Exception
    {
        public StressException(string msg) : base(msg)
        {
        }
    }

    public enum SessionState
    {
        Clean,
        InLobby,
        InGame,
        Finished
    }


    public class StressSession : Session, IDisposable
    {
        public SessionState State;

        // Overridden from Session to provide state management
        public void StressAdvertise()
        {
            if(State != SessionState.Clean)
            {
                throw new StressException("Invalid state for Advertise(): " + State.ToString());
            }

            Advertise();
            State = SessionState.InLobby;
        }

        public void StressUpdate()
        {
            if(State != SessionState.InLobby)
            {
                throw new StressException("Invalid state for Update(): " + State.ToString());
            }

            base.Update();

            if(0 == (new Random().Next(10)))
            {
                State = SessionState.InGame;
            }
        }

        public void StressDelete()
        {
            if(!(State != SessionState.InGame || State != SessionState.InLobby))
            {
                throw new StressException("Invalid state for Delete(): " + State.ToString());
            }

            base.Delete();
            State = SessionState.Finished;
        }

        public void StressSplit()
        {
            if(!(State != SessionState.InGame || State != SessionState.InLobby))
            {
                throw new StressException("Invalid state for Split(): " + State.ToString());
            }

            // Create the new session via split and release the new session to the
            // session manager.
            StressSession splitSession = new StressSession();
            base.Split(splitSession);
            splitSession.State = State;
            SessionManager.Release(splitSession);
        }

        // From IDisposable
        public void Dispose()
        {
            SessionManager.Release(this);
        }
    }

    public static class SessionManager
    {
        public class UserTypeInfo
        {
            public int Count;
            public byte Zone;
            public byte Country;
            public byte Language;

            public void FromString(string str)
            {
                string []elements = str.Split(',');
                if(4 != elements.Length)
                {
                    throw new Exception(
                            String.Format("String value: '{0}' does not contain enough elemnts to parse UserTypeInfo", str)
                            );
                }

                Count       = Int32.Parse(elements[0]);
                Zone        = Byte.Parse(elements[1]);
                Country     = Byte.Parse(elements[2]);
                Language    = Byte.Parse(elements[3]);
            }
        }

        public class RatingInfo
        {
            public int Count;
            public float RatingBucket;

            public void FromString(string str)
            {
                string []elements = str.Split(',');
                if(2 != elements.Length)
                {
                    throw new Exception(
                            String.Format("String value: '{0}' does not contain enough elemnts to parse RatingInfo", str)
                            );
                }

                Count           = Int32.Parse(elements[0]);
                RatingBucket    = Single.Parse(elements[1]);
            }
        }

        private static Queue<StressSession> Clean = new Queue<StressSession>(1024);
        private static Queue<StressSession> InLobby = new Queue<StressSession>(1024);
        private static Queue<StressSession> InGame = new Queue<StressSession>(1024);
        private static DateTime LogTime = DateTime.Now.AddSeconds(5);
        private static int TotalSessions;
        private const int MaxTotalSessions = 100000;
        private const int MaxInGameSessions = 20000;

        private static List<UserTypeInfo> UserTypes = new List<UserTypeInfo>();
        private static int UserTypesSum;
        private static List<RatingInfo>  Ratings = new List<RatingInfo>();
        private static int RatingsSum;

        private static PresenceEmulator Emulator;


        public static string EmulatorEndpoint;
        public static uint StressTitleId = 0xFFFF2003;

        static SessionManager()
        {
            LoadConfigs("graw_user_types.csv", "graw_rating_dist.csv");

            Emulator = new PresenceEmulator(7878, 0, 100);
            Emulator.Go();

            IPAddress localAddress;
            LocalInterface.GetBestMatch(Global.XEnv.GetVirtualInterface(VirtualInterface.xmatchfd), out localAddress);
            EmulatorEndpoint = "http://" + localAddress.ToString() + ":7878/";
        }

        public static void LoadConfigs(string userTypeInfo, string ratingInfo)
        {
            StreamReader reader;
            string line;

            UserTypes.Clear();
            UserTypesSum = 0;
            Ratings.Clear();
            RatingsSum = 0;

            reader = File.OpenText(userTypeInfo);
            while(null != (line = reader.ReadLine()))
            {
                UserTypeInfo info = new UserTypeInfo();
                info.FromString(line);
                UserTypes.Add(info);
                UserTypesSum += info.Count;
            }
            
            reader = File.OpenText(ratingInfo);
            while(null != (line = reader.ReadLine()))
            {
                RatingInfo info = new RatingInfo();
                info.FromString(line);
                Ratings.Add(info);
                RatingsSum += info.Count;
            }

            if(0 == UserTypes.Count || 0 == Ratings.Count)
            {
                throw new Exception(
                            String.Format("Failed to load enough user types ({0}) or ratings ({1})",
                            UserTypes.Count,
                            Ratings.Count)
                        );
            }
        }

        public static UserTypeInfo GetRandomUserType(Random rand)
        {
            UserTypeInfo userType = null;
            int select = rand.Next(UserTypesSum);

            foreach(UserTypeInfo i in UserTypes)
            {
                select -= i.Count;
                if(select <= 0)
                {
                    userType = i;
                    break;
                }
            }

            if(null == userType)
            {
                userType = UserTypes[UserTypes.Count-1];
            }

            return userType;
        }

        public static RatingInfo GetRandomRating(Random rand)
        {
            RatingInfo rating = null;
            int select = rand.Next(RatingsSum);

            foreach(RatingInfo i in Ratings)
            {
                select -= i.Count;
                if(select <= 0)
                {
                    rating = i;
                    break;
                }
            }
            
            if(null == rating)
            {
                rating = Ratings[Ratings.Count-1];
            }

            return rating;
        }

        public static void GenerateStressAttributeCollection(AttributeCollection attrCol)
        {
            UserTypeInfo userType;
            RatingInfo rating;

            Random rand = new Random();

            // Select a random user type based on occurance in our table
            userType = GetRandomUserType(rand);
            
            // Select a random rating based on occurance in our table
            rating = GetRandomRating(rand);
           
            byte gameMode = (byte)rand.Next(3);
            ulong puid = (ulong)(uint)rand.Next() << 32 | (ulong)(uint)rand.Next();

            attrCol.GenerateAttributes(
                    (byte)MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD,
                    gameMode,
                    userType.Zone,
                    userType.Country, 
                    userType.Language, 
                    rating.RatingBucket + (float)rand.NextDouble(), 
                    Util.RandomMu(), 
                    Util.RandomSigma(),
                    puid); 
        }

        public static void Release(StressSession session)
        {
            switch(session.State)
            {
                case SessionState.Finished:
                    session.AttributeCollection.Clear();
                    session.State = SessionState.Clean;
                    lock(Clean)
                    {
                        Clean.Enqueue(session);
                    }
                    break;
                case SessionState.Clean:
                    lock(Clean)
                    {
                        Clean.Enqueue(session);
                    }
                    break;
                case SessionState.InLobby:
                    lock(InLobby)
                    {
                        InLobby.Enqueue(session);
                    }
                    break;
                case SessionState.InGame:
                    lock(InGame)
                    {
                        InGame.Enqueue(session);
                    }
                    break;
            }
        }

        public static StressSession GetCleanSession()
        {
            StressSession session = null;
            lock(Clean)
            {
                try
                {
                    session = Clean.Dequeue();
                    SetupCleanSession(session);
                }
                catch(InvalidOperationException)
                {
                    if(TotalSessions < MaxTotalSessions)
                    {
                        session = new StressSession();
                        SetupCleanSession(session);
                        Interlocked.Increment(ref TotalSessions);
                    }
                }

                LogState();
            }

            return session;
        }

        private static void SetupCleanSession(StressSession session)
        {
            session.dwTitleId = StressTitleId;

            SessionManager.GenerateStressAttributeCollection(session.AttributeCollection);
            session.SetupSGInfo();
        }

        public static StressSession GetInLobbySession()
        {
            lock(InLobby)
            {
                try
                {
                    return InLobby.Dequeue();
                }
                catch(InvalidOperationException)
                {
                    return null;
                }
            }
        }

        public static StressSession GetInGameSession()
        {
            lock(InGame)
            {
                // Only return sessions off the top of the in game sessions
                if(InGame.Count < MaxInGameSessions)
                {
                    return null;
                }

                try
                {
                    return InGame.Dequeue();
                }
                catch(InvalidOperationException)
                {
                    return null;
                }
            }
        }

        public static StressSession GetSplitableSession()
        {
            StressSession session = null;

            session = GetInLobbySession();
            if(null == session)
            {
               session = GetInGameSession(); 
            }

            return session;
        }

        public static void LogState()
        {
            if(LogTime < DateTime.Now)
            {
                Global.RO.Debug("Total: {0}, Clean: {1}, InLobby: {2}, InGame: {3}",
                        TotalSessions,
                        Clean.Count,
                        InLobby.Count,
                        InGame.Count);
                LogTime = DateTime.Now.AddSeconds(10);
            }
        }
    }

    public class StressCreateSession : TestNode
    {
        public override void Run()
        {
            using(StressSession session = SessionManager.GetCleanSession())
            {
                session.StressAdvertise();
            }
            return TEST_RESULTS.PASSED;
        }
    }

    public class StressUpdateSession : TestNode
    {
        public override void Run()
        {
            using(StressSession session = SessionManager.GetInLobbySession())
            {
                if(null == session)
                {
                    return TEST_RESULTS.NOT_EXECUTED;
                }

                session.StressUpdate();
            }
            return TEST_RESULTS.PASSED;
        }
    }

    public class StressDeleteSession : TestNode
    {
        public override void Run()
        {
            using(StressSession session = SessionManager.GetInGameSession())
            {
                if(null == session)
                {
                    return TEST_RESULTS.NOT_EXECUTED;
                }
                session.StressDelete();
            }
            return TEST_RESULTS.PASSED;
        }
    }

    public class StressSplitSession : TestNode
    {
        public override void Run()
        {
            using(StressSession session = SessionManager.GetSplitableSession())
            {
                if(null == session)
                {
                    return TEST_RESULTS.NOT_EXECUTED;
                }
                session.StressSplit();
            }
            return TEST_RESULTS.PASSED;
        }
    }

    public class StressSearch : TestNode
    {
        public override void Run()
        {
            SessionCollection scol = new SessionCollection();
            SessionManager.GenerateStressAttributeCollection(scol.SearchTemplate.AttributeCollection);
            scol.dwProcedureIndex = (uint)(new Random().Next(2));
            scol.PresenceDestination = SessionManager.EmulatorEndpoint;
            scol.Search();

            return TEST_RESULTS.PASSED;
        }
    }

    // This stress test is used to do performance tuning on the standard search
    // procedure
    public class StressSearchDirect : TestNode
    {
        // Static test data
        private static uint MaxResults = 50;
        private static XNADDR xnaddr = Util.CreateRandomXNADDR();
        private static uint ProcedureIndex = 0;
        private static uint NegativeSessions = 2;

        public override void Run()
        {
            Random rand = new Random();
            uint resultCount;
            uint hr = HResult.E_FAIL;
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlDataReader reader = null;
            SqlParameter param; 

            try
            {
                SessionManager.UserTypeInfo userType = SessionManager.GetRandomUserType(rand);
                SessionManager.RatingInfo rating = SessionManager.GetRandomRating(rand);

                // Get the connection
                cxn = new SqlConnection("Data Source=JACOBR3;Initial Catalog=xmatch;Integrated Security=SSPI");
                cxn.Open();

                // Create the procedure command
                cmd = new SqlCommand(
                        String.Format("p_match_session_0x{0:X8}_0x{1:X8}_search_standard", 
                            SessionManager.StressTitleId, 
                            ProcedureIndex),
                        cxn);
                cmd.CommandType = CommandType.StoredProcedure;

                // Add the retval return param
                param = new SqlParameter();
                param.ParameterName = "@retval";
                param.Direction = ParameterDirection.ReturnValue;
                param.DbType = DbType.Int32;
                param.Value = 0;
                cmd.Parameters.Add(param);

                // Add the max results out param
                param = new SqlParameter();
                param.ParameterName = "@i_max_results";
                param.Direction = ParameterDirection.Output; 
                param.DbType = DbType.Int32;
                param.Value = (int)MaxResults;
                cmd.Parameters.Add(param);

                // Add the base parameters
                cmd.Parameters.AddWithValue("@i_negative_sessions", (int)NegativeSessions);
                cmd.Parameters.AddWithValue("@si_required_slots", (int)1);
                cmd.Parameters.AddWithValue("@i_client_ip", (int)xnaddr.inaOnline);
                cmd.Parameters.AddWithValue("@ti_nat_type", (byte)rand.Next(4));
                cmd.Parameters.AddWithValue("ti_server_count", (byte)1);

                // Add the attribute params
                cmd.Parameters.AddWithValue("@param_0x0000800A", (int)1); // game type
                cmd.Parameters.AddWithValue("@param_0x0000800B", (int)rand.Next(3)); // game mode
                cmd.Parameters.AddWithValue("@param_0x10008101", (int)userType.Zone); // gamer zone
                cmd.Parameters.AddWithValue("@param_0x10008102", (int)userType.Country); // gamer country
                cmd.Parameters.AddWithValue("@param_0x10008103", (int)userType.Language); // gamer lang
                cmd.Parameters.AddWithValue("@param_0x50008104", (float)(rating.RatingBucket + rand.NextDouble())); // gamer rating
                cmd.Parameters.AddWithValue("@param_0x30008105", Util.RandomMu()); // gamer mu 
                cmd.Parameters.AddWithValue("@param_0x30008106", Util.RandomSigma()); // gamer sigma
                cmd.Parameters.AddWithValue("@param_0x20008107", (long)Util.RandomPuid()); // gamer puid
                cmd.Parameters.AddWithValue("@param_0x40008109", "gamertag"); // gamer hostname
                cmd.Parameters.AddWithValue("@param_0x10008201", (int)1); // platform type
                cmd.Parameters.AddWithValue("@param_0x10008202", (int)0); // platform lock

                // Execute
                reader = cmd.ExecuteReader();


                // Read each of 3 disjoint groups
                resultCount = 0;
                for(int i = 0; i < 3; ++i)
                {
                    // Read details
                    if(!reader.Read())
                    {
                        break;
                    }

                    // Move to results
                    if(!reader.NextResult())
                    {
                        break;
                    }

                    // Read results
                    while(reader.Read())
                    {
                        resultCount++;
                    }

                    // Move to next details section
                    if(!reader.NextResult())
                    {
                        break;
                    }
                }

                
                hr = (uint)(int)cmd.Parameters["@retval"].Value;
                uint maxResults = (uint)(int)cmd.Parameters["@i_max_results"].Value;
            }
            finally
            {
                if(null != cmd)
                {
                    cmd.Cancel();
                }
                if(null != reader)
                {
                    reader.Close();
                }
                if(null != cxn)
                {
                    cxn.Close();
                }
            }

            return HResult.Failed(hr) ? TEST_RESULTS.FAILED : TEST_RESULTS.PASSED;
        }
    }

    public class PresenceEmulator : XHttpListenerIOCP
    {
        private uint []_affiliateFlags;

        public PresenceEmulator(int listenPort, int delay, int maxConn)
            : base(listenPort, delay, maxConn)
        {
            _affiliateFlags = new uint[100];
            for(uint i = 0; i < 100; ++i)
            {
                if(i < 10)
                    _affiliateFlags[i] = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX);
                else if (i < 20)
                    _affiliateFlags[i] = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX);
                else if (i < 40)
                    _affiliateFlags[i] = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX);
                else if (i < 90)
                    _affiliateFlags[i] = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX);
                else if (i < 95)
                    _affiliateFlags[i] = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX);
                else
                    _affiliateFlags[i] = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX);
            }
        }

        public override bool ProcessData(byte[] bytes, int bundleIndex, int contentLength, out byte[] resp)
        {
            PresenceQueryAffiliatesMsg msgData;
            MemoryStream reqStream; 
            MemoryStream resStream;
            BinaryReader reqReader; 
            BinaryWriter resWriter;

            reqStream = new MemoryStream(bytes, bundleIndex, contentLength);
            reqReader = new BinaryReader(reqStream);

            resStream = new MemoryStream(256);
            resWriter = new BinaryWriter(resStream);

            msgData = new PresenceQueryAffiliatesMsg();
            msgData.ReadStream(reqStream);

            RandomEx rand = new RandomEx();

            PresenceQueryAffiliatesReplyMsg replyMsgData = new PresenceQueryAffiliatesReplyMsg();
            replyMsgData.hr = 0;
            replyMsgData.cdwResults = (uint)rand.Next(200);
            replyMsgData.rgResults = new QueryAffiliatesReplyData[replyMsgData.cdwResults];
           

            for (int i = 0; i < replyMsgData.cdwResults; i++)
            {
                QueryAffiliatesReplyData affiliate = replyMsgData.rgResults[i] = new QueryAffiliatesReplyData();

                affiliate.qwAffiliateID = rand.NextPuid();
                affiliate.dwListFlags = _affiliateFlags[rand.Next(100)];
                
                uint selector = (uint)rand.Next(10);
                if(0 == selector)
                {
                    using(StressSession s = SessionManager.GetInLobbySession())
                    {
                        if (null == s)
                        {
                            affiliate.dwTitleID = (uint)rand.Next();
                            affiliate.qwSessionID = 0;
                            affiliate.mtDateUpdated = 2;
                        }
                        else
                        {
                            affiliate.dwTitleID = SessionManager.StressTitleId;
                            affiliate.qwSessionID = s.qwSessionId;
                            affiliate.mtDateUpdated = 1;
                        }
                    }
                }
                else
                {
                    affiliate.dwTitleID = (uint)rand.Next();
                    affiliate.qwSessionID = (ulong)(uint)rand.Next() << 32 | (uint)rand.Next();
                    affiliate.mtDateUpdated = 0;
                }
            }

            replyMsgData.header.dwMsgLen = (uint)replyMsgData.Size();
            replyMsgData.WriteStream(resWriter);
            resp = resStream.ToArray();

            return (true);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\match\fd\database.cs ===
//
// Database.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Front Door
// Xbox Online Service
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities2;
using xonline.common.match;
using xonline.common.fastfail;

namespace xonline.server.match.fd
{

// -----------------------------------------------------------------------
// DeadXboxMsg class - encapsulates how the database identifies individual
// xbox consoles, and wants to receive that information for dead xbox,
// dead sg, or title change notifications.
// -----------------------------------------------------------------------
public class DeadXboxMsg
{
    /*
    private uint m_dwTitleId;
    private SGADDR m_sgAddr;

    public DeadXboxMsg(uint dwTitleId, SGADDR sgaddr)
    {
        m_dwTitleId = dwTitleId;
        m_sgAddr = sgaddr;
    }

    public uint TitleId
    {
        get { return m_dwTitleId; }
    }

    public SGADDR SgAddr
    {
        get { return m_sgAddr; }
    }

    // 4 bytes TitleId
    // 16 bytes BoxId
    public const int DBMSG_SIZE = 4 + BOXID_SIZE;

    // 4 bytes SgAddr.dwSpiSg
    // 8 bytes SgAddr.qwXboxId
    // 4 bytes SgAddr.abReserved
    public const int BOXID_SIZE = 16;

    public byte[] DeadXboxMsgBytes
    {
        get
        {
            // The p_match_dead_xbox stored proc expects an array of bytes
            // as a parameter. The array consists of 20 byte chunks. Each
            // chunk is a 4 byte title id, followed by the 16 byte box id.
            // However, the title id must be in network order!
            byte[] rgbDeadBoxBytes = new byte[DBMSG_SIZE];
            BinaryWriter writer
                = new BinaryWriter(new MemoryStream(rgbDeadBoxBytes));
            writer.Write(DBLayer.ByteSwap(TitleId));
            writer.Write(SgAddrToBoxId(SgAddr));
            return rgbDeadBoxBytes;
        }
    }
    */

    // The matchmaking database's concept of a box ID incorporates all
    // of the SG info for a single Xbox console
    //
    // 4 bytes SgAddr.dwSpiSg
    // 8 bytes SgAddr.qwXboxId
    // 4 bytes SgAddr.abReserved
    public const int BOXID_SIZE = 16;
    public static byte[] SgAddrToBoxId(SGADDR sgaddr)
    {
        byte[] rgbBoxId = new byte[BOXID_SIZE];
        BinaryWriter writer
            = new BinaryWriter(new MemoryStream(rgbBoxId));
        writer.Write(sgaddr.dwSpiSg);
        writer.Write(sgaddr.qwXboxId);
        writer.Write(sgaddr.abReserved);
        return rgbBoxId;
    }

    // Tests the provided SGADDR structure to see if it is part of a
    // "dead sg" message, or is a genuine "dead xbox" message.
    public static bool IsDeadSgMsg(SGADDR sgaddr)
    {
        return (sgaddr.dwSpiSg == 0) && (sgaddr.qwXboxId == 0);
    }
}

// ------------------------------------------------------------------------
// SQLDefs class - provide symbolic names for SQL Error codes so we don't
// have literal values in switch statements in DBLayer
// ------------------------------------------------------------------------
public class SQLDefs
{
    // These errors are not from SQL Server, they must be from the data access layer, SqlClient.
    public const int ERROR_SQLCLIENT_TIMEOUT = -2;              // "Timeout expired.  The timeout period elapsed prior to completion of the operation or the server is not responding."
    public const int ERROR_SQLCLIENT_CONNECTION_FAILED = 2;     // "An error has occurred while establishing a connection to the server.  When connecting to SQL Server 2005, this failure may be caused by the fact that under the default settings SQL Server does not allow remote connections. (provider: Named Pipes Provider, error: 40 - Could not open a connection to SQL Server)"

    // These errors are from SQL Server (sysmessages)
    public const int ERROR_PARAM_MISSING = 201;
    public const int ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK = 601;
    public const int ERROR_DEADLOCKED_PROCESS_KILLED = 1205;
    public const int ERROR_PRIMARY_KEY_VIOLATION = 2627;
    public const int ERROR_COULD_NOT_FIND_STORED_PROC = 2812;
    public const int ERROR_TOO_MANY_PARAM = 8144;
    public const int ERROR_INVALID_PARAM_NAME = 8145;
    public const int ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES = 8143;
    public const int ERROR_DATA_TRUNCATED = 8152;
    public const int ERROR_LOGIN_TIMEOUT = 17197;
    public const int ERROR_LOGIN_NETWORK_ERROR = 17829;
    public const int ERROR_NETWORK_TIMEOUT = 17830;
}

// ------------------------------------------------------------------------
// AffiliateSession class - encapsulates a session id and its affiliate value
// ------------------------------------------------------------------------
public class AffiliateSession : IComparable
{
    private ulong _sessionId;
    private int _affiliateValue;

    public AffiliateSession(ulong sessionId, int affiliateValue)
    {
        _sessionId = sessionId;
        _affiliateValue = affiliateValue;
    }

    public ulong SessionId
    {
        get { return _sessionId; }
    }

    public int AffiliateValue
    {
        get { return _affiliateValue; }
        set { _affiliateValue = value; }
    }

    public int CompareTo(object o)
    {
        if (o is AffiliateSession)
        {
            AffiliateSession affiliateSession = (AffiliateSession)o;

            // We want large values to sort at the beginning of the array,
            // when used by Array.Sort(). Therefore we reverse the usual semantics
            // of greater than and less than.
            return affiliateSession.AffiliateValue - AffiliateValue;
        }
        throw new ArgumentException("object passed is not of type AffiliateSession");
    }

    public override string ToString()
    {
        return "{" + _sessionId.ToString("X16") + "," + _affiliateValue.ToString() + "}";
    }
}

// ------------------------------------------------------------------------
// RankedSearchDetails class - simple class to hold details regarding how a ranked
// database search was performed.
// ------------------------------------------------------------------------
public class RankedSearchDetails
{
    public uint titleId;
    public uint queryId;
    public int gameType;
    public int gameMode;
    public double gamerMu;
    public int iterations;
    public int rowCount;
    public double muRange;
    public double muUpperBound;
    public double muLowerBound;
    public int lowerHashBound1;
    public int upperHashBound1;
    public int lowerHashBound2;
    public int upperHashBound2;
}

// ------------------------------------------------------------------------
// AffiliateDetails class - simple class to hold details regarding
// the affiliate data returned by the presence front door.
// ------------------------------------------------------------------------
public class AffiliateDetails
{
    public AffiliateDetails()
    {
        friendCount = 0;
        posCount = 0;
        completedCount = 0;
        negCount = 0;
        avoidingMeCount = 0;
        posSessionsCount = 0;
        negSessionsCount = 0;
    }

    public int friendCount;
    public int posCount;
    public int completedCount;
    public int negCount;
    public int avoidingMeCount;
    public int posSessionsCount;
    public int negSessionsCount;
}

// ------------------------------------------------------------------------
// StandardSearchDetails class - simple class to hold details regarding how a standard
// database search was performed.
// ------------------------------------------------------------------------
public class StandardSearchDetails
{
    public uint titleId;
    public uint queryId;
    public int gameType;
    public int gameMode;
    public double gamerRating;
    public int gamerZone;
    public int iterations;
    public int rowCount;
    public double ratingRange;
    public double ratingUpperBound;
    public double ratingLowerBound;
    public int lowerHashBound1;
    public int upperHashBound1;
    public int lowerHashBound2;
    public int upperHashBound2;
}

// ------------------------------------------------------------------------
// WeightedSearchDetails class - simple class to hold details regarding how a weighted
// database search was performed.
// ------------------------------------------------------------------------
public class WeightedSearchDetails
{
    public uint titleId;
    public uint queryId;
    public int gameType;
    public int gameMode;
    public double gamerMu;
    public int iterations;
    public int rowCount;
    public double range;
    public int lowerHashBound1;
    public int upperHashBound1;
    public int lowerHashBound2;
    public int upperHashBound2;
}


// ------------------------------------------------------------------------
// DBLayer class - provides all database communication for Matchmaking
// front door
// ------------------------------------------------------------------------
public class DBLayer
{
    // Used to generate keys and session ids
    private static RNGCryptoServiceProvider m_rng
        = new RNGCryptoServiceProvider();

    // An array of all known match databases, suitable for use as a
    // "Data Source" string in a sql connection string
    private static string[] m_rgstrDatabases = new string[0];

    // A lookup table of title info. We don't use the Hashtable.Synchronized
    // wrapper because this table is used only for reading after it has been
    // created by InitCheck
    private static Hashtable m_hashTitleInfo = new Hashtable();

    // False when we we first start up or need to reload any
    // title configurations, or other configuration from npdb.
    private static bool m_fInitialized = false;

    // Reader writer lock used to protect access to the above flag
    private static ReaderWriterLock m_rwlInitialized = new ReaderWriterLock();
    private const int LockTimeout = 30000;

    // ------------------------------------------------------------------------
    // BreadCrumbTransitions
    // Used by the UpdateSession code to report on what work it had to do
    // to update the row.
    // ------------------------------------------------------------------------
    public enum BreadcrumbTransition
    {
        UpdateOriginal = 0,
        CreateInitialSW,
        UpdateExistingSW,
        MoveRemoteRow,
        UnBreadcrumb,
        PreemptedByDelete
    };

    // ------------------------------------------------------------------------
    // BreadcrumbState
    // Enumeration for the possible states that a row in any of the session
    // tables can be in.
    // ------------------------------------------------------------------------
    public enum BreadcrumbState
    {
        Unknown = 0, // we don't know.  This is a special case, used to tell the DB to go with what it's got.
        Breadcrumb,   // This is the original row.  It may point to another row, using the i_sw_bucket column.
        Sandwich,           // there are 2 rows for the session, in 2 different buckets.  This is the newest, or sandwich.
        Both                    // there's 1 row, but it "contains" both the breadcrumb and sandwich
    };

    static DBLayer()
    {
        m_fastFailHelper = new FastFailHelper(
            Setting.xmatchfd_fastFailTimeoutThresholdCount,
            Setting.xmatchfd_fastFailTimeoutTimespanSeconds,
            Setting.xmatchfd_fastFailBlockIntervalSeconds,
            XEvent.Id.MATCH_COMM_FASTFAIL,
            XEvent.Id.FAIL_FAST_EXIT);  // TODO: make this unique

        m_resMonitor = new ResourceUsageMonitor(
            "MatchSQL",
            Setting.xmatchfd_fastFailReservedThreadsPerDB,
            Setting.xmatchfd_fastFailTotalSharedThreads,
            Setting.xmatchfd_fastFailBucketIntervalSeconds,
            Setting.xmatchfd_fastFailNumBuckets,
            Setting.xmatchfd_fastFailTimeTolerance,
            XEvent.Id.MATCH_COMM_FASTFAIL,
            XEvent.Id.FAIL_FAST_EXIT);  // TODO: make this unique
    }

    // We cache our settings in static properties in this class to
    // avoid the hashtable lookup in GetSetting. This means we have
    // to handle the SettingChange event.
    private static int m_defaultSessionExpiration;
    public static int DefaultSessionExpiration
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_defaultSessionExpiration;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_defaultSessionExpiration = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static bool m_relaxXenonValidation;
    public static bool RelaxXenonValidation
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_relaxXenonValidation;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_relaxXenonValidation = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static uint m_sessionCacheExpiration;
    public static uint SessionCacheExpiration
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_sessionCacheExpiration;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_sessionCacheExpiration = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static bool m_disableAffiliateQuery;
    public static bool DisableAffiliateQuery
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_disableAffiliateQuery;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_disableAffiliateQuery = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_valueOfFriend;
    public static int ValueOfFriend
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_valueOfFriend;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_valueOfFriend = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_valueOfPositiveFeedback;
    public static int ValueOfPositiveFeedback
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_valueOfPositiveFeedback;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_valueOfPositiveFeedback = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_valueOfCompletedGame;
    public static int ValueOfCompletedGame
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_valueOfCompletedGame;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_valueOfCompletedGame = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_valueOfNegativeFeedback;
    public static int ValueOfNegativeFeedback
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_valueOfNegativeFeedback;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_valueOfNegativeFeedback = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_valueOfAvoidingMe;
    public static int ValueOfAvoidingMe
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_valueOfAvoidingMe;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_valueOfAvoidingMe = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static bool m_enableTitlePerfCounters;
    public static bool EnableTitlePerfCounters
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_enableTitlePerfCounters;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_enableTitlePerfCounters = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_nolockRetries;
    public static int NolockRetries
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_nolockRetries;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_nolockRetries = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static int m_insertRetries;
    public static int InsertRetries
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_insertRetries;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_insertRetries = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }

    private static bool m_enableAuthCheck;
    public static bool EnableAuthCheck
    {
        get
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                return m_enableAuthCheck;
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
        set
        {
            m_rwlInitialized.AcquireReaderLock(LockTimeout);
            try
            {
                LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
                try
                {
                    m_enableAuthCheck = value;
                }
                finally
                {
                    m_rwlInitialized.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                m_rwlInitialized.ReleaseReaderLock();
            }
        }
    }


    // returns whether the DBLayer is currently initialized.
    public static bool fInitialized
    {
        get
        {
            // no locking, because:
            // -a read of a boolean (< 32 bits!) should be atomic
            // -using m_rwlInitialized to lock here could block the caller, and this property is used to avoid such blocking.
            return m_fInitialized;
        }
    }


    // Used by MatchXomCallback to force reload of title info after initial
    // startup
    public static void ReInitialize()
    {
        m_rwlInitialized.AcquireReaderLock(LockTimeout);
        try
        {
            LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
            try
            {
                m_fInitialized = false;
            }
            finally
            {
                m_rwlInitialized.DowngradeFromWriterLock(ref lc);
            }
        }
        finally
        {
            m_rwlInitialized.ReleaseReaderLock();
        }
    }

    // shorthand for byte swapping unsigned values
    public static ulong ByteSwap(ulong qword)
    {
        return unchecked((ulong)IPAddress.HostToNetworkOrder((long)qword));
    }

    public static uint ByteSwap(uint dword)
    {
        return unchecked((uint)IPAddress.HostToNetworkOrder((int)dword));
    }

    public static ushort ByteSwap(ushort word)
    {
        return unchecked((ushort)IPAddress.HostToNetworkOrder((short)word));
    }

    // -----------------------------------------------------------------------
    // FBucketInMigration - determine whether the given bucket is currently
    // being migrated.
    // -----------------------------------------------------------------------
    public static bool FBucketInMigration(IBucketServer ibsBucket)
    {
        if (ibsBucket.NextServerName != "" &&
            String.Compare(ibsBucket.NextServerName, ibsBucket.CurrentServerName) != 0 &&
            ibsBucket.NextServerStart < DateTime.UtcNow)
        {
            return true;
        }
        return false;
    }

    // -----------------------------------------------------------------------
    // Gets the server the the front door should hit first for the given
    // bucket.  (depends on whether the server's in migration)
    // -----------------------------------------------------------------------
    private static string GetActiveServer(IBucketServer ibs)
    {
        if (FBucketInMigration(ibs))
        {
            return ibs.NextServerName;
        }
        else
        {
            return ibs.CurrentServerName;
        }
    }

    // -----------------------------------------------------------------------
    // InsertSession - adds a new session
    // -----------------------------------------------------------------------
    public static HResult InsertSession(
        byte bServerType,
        byte bNatType,
        uint dwTitleId,
        XNADDR HostAddress,
        uint dwPublicOpen,
        uint dwPrivateOpen,
        uint dwPublicFilled,
        uint dwPrivateFilled,
        MatchAttribute[] rgAttributes,
        MatchXrl matchXrl,
        out ulong qwSessionId,
        out byte[] rgbKeyExchangeKey,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        HResult hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
        qwSessionId = 0;
        rgbKeyExchangeKey = null;

        ulong gameType = GetGameType(rgAttributes);
        InsertSessionPerfCountersStart(matchXrl, dwTitleId, gameType);

        try
        {
            hr = InsertSessionInternal(bServerType, bNatType, dwTitleId, HostAddress,
                dwPublicOpen, dwPrivateOpen, dwPublicFilled, dwPrivateFilled,
                rgAttributes, matchXrl, ref qwSessionId, ref rgbKeyExchangeKey,
                seqNum);
        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value 

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId))
            {
                throw;
            }
            else
            {

                // Something unexpected has happened. Rethrow an XRLException
                // so we get proper eventing, and set the hr so it is logged
                // properly below
                throw new XRLException(
                    hr,
                    XEvent.Id.MATCH_CODE_0,
                    "XMatchFD.DBLayer.InsertSession(" + seqNum.ToString("X8") + "): "
                    + "Unexpected exception was thrown. Details should follow.", e);
            }
        }
        finally
        {
            InsertSessionLog(bServerType, bNatType, dwTitleId, HostAddress, dwPublicOpen,
                dwPrivateOpen, dwPublicFilled, dwPrivateFilled, rgAttributes, matchXrl,
                qwSessionId, rgbKeyExchangeKey, xrteRequestTime, seqNum, hr);

            InsertSessionPerfCountersEnd(matchXrl, dwTitleId, gameType, xrteRequestTime, hr);
        }
        return hr;
    }

    // -----------------------------------------------------------------------
    // InsertSession - internal insert that generates a semi-random session
    // ID using some attributes of the session.
    //
    // This version of insert will iterate InsertRetries times which is now
    // a config setting xmatchfd_insertRetries.
    // -----------------------------------------------------------------------
    private static HResult InsertSessionInternal(
        byte bServerType,
        byte bNatType,
        uint dwTitleId,
        XNADDR HostAddress,
        uint dwPublicOpen,
        uint dwPrivateOpen,
        uint dwPublicFilled,
        uint dwPrivateFilled,
        MatchAttribute[] rgAttributes,
        MatchXrl matchXrl,
        ref ulong qwSessionId,
        ref byte[] rgbKeyExchangeKey,
        uint seqNum)
    {
        HResult hr = 0;
        qwSessionId = 0;
        rgbKeyExchangeKey = null;
        SqlConnection cxn = null;
        SqlCommand cmd = null;
        DateTime dtExpire;
        string strActiveServer = null;

        // Get information on this title
        TitleInfo ti = GetTitleInfo(dwTitleId, seqNum);

        // figure out if this is a legacy xbox title by the xrl that
        // was used
        bool fIsLegacyXboxTitle = false;
        if (matchXrl == MatchXrl.xmatchhost_srf && !ti.ForceXenonBehavior)
        {
            fIsLegacyXboxTitle = true;
        }

        // Reuseable data
        rgbKeyExchangeKey = GenerateKeyExchangeKey();
        byte[] rgbBoxId = DeadXboxMsg.SgAddrToBoxId(HostAddress.sgaddr);

        // we spread the insert requests evenly over the servers for this
        // title/type/mode by cycling through the list of RR servers.
        byte bDBUsed = 0;
        IBucketServer ibsServer = ti.GetNextRRBucketForPartition(
                                    GetGameType(rgAttributes),
                                    GetGameMode(rgAttributes),
                                    false,      // Don't choose draining buckets, should not be inserting into them.
                                    ref bDBUsed,
                                    seqNum);
        strActiveServer = GetActiveServer(ibsServer);

        // TODO2THEOM: call GetGameType and GetGameMode as little as possible per request, since they iterate through the attributes array.

        try
        {
            cxn = OpenSqlConnectionToMatchDB(strActiveServer);

            // Build the command once, substitute the actual generated
            // session id in each loop iteration
            cmd = CreateInsertSqlCommand(dwTitleId, fIsLegacyXboxTitle);
            cmd.Connection = cxn;

            MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                    "@retval", (uint)0);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@bi_session_id", (ulong)0);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_ip_addr", ByteSwap(HostAddress.inaOnline));
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_sg_ip", ByteSwap(HostAddress.sgaddr.inaSg));
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@b_box_id", rgbBoxId);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@b_host_address", (byte[])HostAddress);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@b_key_exchange_key", rgbKeyExchangeKey);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_public_available", dwPublicOpen);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_private_available", dwPrivateOpen);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_public_current", dwPublicFilled);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_private_current", dwPrivateFilled);

            if (fIsLegacyXboxTitle)
            {
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_expiration", ti.SessionExpiration);
            }
            else
            {
                // determine when this session will expire
                dtExpire = DateTime.UtcNow.AddSeconds(ti.SessionExpiration);
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@dt_session_expire", dtExpire);

                // hack a null value into the sw_bucket column.  This is required for initial insertion,
                // since all sessions are initially "breadcrumbs", and should have i_sw_bucket == null
                SqlParameter param = new SqlParameter();
                param.ParameterName = "@i_sw_bucket";
                param.Direction = ParameterDirection.Input;
                param.DbType = DbType.Int32;
                param.Value = DBNull.Value;
                cmd.Parameters.Add(param);
            }

            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@ti_nat_type", bNatType);

            AddSessionAttributesToSqlCommand(dwTitleId, rgAttributes,
                    cmd, fIsLegacyXboxTitle, seqNum);
        }
        catch (SqlException e)
        {
            if (ConsiderExceptionAsConnectionFailure(e))
            {
                hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                DBLayer.ReportFailure(strActiveServer, e.ToString());
            }

            throw new XRLException(
                HResult.XONLINE_E_MATCH_SERVER_ERROR,
                XEvent.Id.MATCH_COMM_OPEN_CONNECTION_FOR_INSERT,
                "XMatchFD.DBLayer.InsertSession(" + seqNum.ToString("X8")
                + "): Failed to open a connection to " + strActiveServer +
                ".  titleID = " + (TitleId) dwTitleId, e);
        }

        // outer try to handle default exception case
        try
        {
            // Loop for retries
            int retries = 0;
            bool fRetry = true;
            while(fRetry && retries++ < InsertRetries)
            {
                // Try to generate a new session ID each iteration, set the parameter
                // in the query
                qwSessionId = GenerateSessionId(bServerType, bDBUsed, rgAttributes);
                cmd.Parameters["@bi_session_id"].Value = (long)qwSessionId;
                cmd.Parameters["@bi_session_id"].DbType = DbType.Int64;

                Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                    "XMatchFD.DBLayer.InsertSession(" + seqNum.ToString("X8")
                    + "): Using db=" + cxn.DataSource
                    + " to insert session id=" + qwSessionId.ToString("X16")
                    + ". titleId = " + (TitleId) dwTitleId);

                fRetry = InsertSessionCore(cmd,
                                                    BreadcrumbState.Breadcrumb,
                                                    false /*fOverWriteDupes*/,
                                                    fIsLegacyXboxTitle,
                                                    dwTitleId,
                                                    strActiveServer,
                                                    seqNum);

                // we need to retry.  There is only one reason for this -- PK violation,
                // and we assume this is because we got unlucky and produced a dupe
                // SessionID.
                if(fRetry == true)
                {
                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.InsertSession(" + seqNum.ToString("X8")
                        + "): PK violation detected, retry = " + retries.ToString()
                        + ". titleId = " + (TitleId) dwTitleId);

                    InsertSessionRetryPerfCounters(fIsLegacyXboxTitle, dwTitleId);

                    //cmd.Cancel();
                }
            } // end insert retry loop

            if(retries >= InsertRetries)
            {
                Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                    "XMatchFD.DBLayer.InsertSession(" + seqNum.ToString("X8")
                    + "): too many insert tries detected, "
                    + "retry = " + retries.ToString()
                    + ". titleId = " + (TitleId) dwTitleId);

                InsertSessionRetryFailurePerfCounters(fIsLegacyXboxTitle, dwTitleId);

                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_SESSION_ID,
                    XEvent.Id.MATCH_CODE_2,
                    "XMatchFD.DBLayer.InsertSession(" + seqNum.ToString("X8")
                    + "): Failed to select unique session id after " + retries + " attempts."
                    + " titleID = " + (TitleId) dwTitleId);
            }
        }
        finally
        {
            //if(cmd != null)
            //{
            //    cmd.Cancel();
            //}
            if(cxn != null)
            {
                cxn.Close();
            }
        }

        return hr;
    }



    // ------------------------------------------------------------------------
    // InsertSWSessionForBucket
    // Shared code to deal with inserts into a bucket.
    // pretty much just calls InsertSessionCore
    // ------------------------------------------------------------------------
    private static bool InsertSWSessionForBucket(
                            IBucketServer ibsInsert,
                            uint dwSWBucket,
                            string strDontInsertOnThisServer,  // if we happen to know there's a row, and don' want to overwrite/fail
                            SqlCommand cmdInsert,
                            // the rest are for logging
                            ulong dwTitleId,
                            uint seqNum)
    {
        SqlConnection cxnNext = null;
        string strActiveServer = GetActiveServer(ibsInsert);

        // don't insert if we know it's already there.
        if (String.Compare(strActiveServer, strDontInsertOnThisServer, true) == 0)
        {
            return false;
        }

        // we always insert to the "next" server for the bucket, regardless
        // of whether the bucket is in migration, because "next" and "current"
        // should be equal if it's not in migration.
        try
            {
            // when inserting a SW session, the row needs to know both that it is a sandwich
            // (this is passed into InsertSessionCore) and what the sandwich bucket is.  This
            // second part is simply set in the insert command...
            cmdInsert.Parameters["@i_sw_bucket"].Value = (int)dwSWBucket;

            cxnNext = OpenSqlConnectionToMatchDB(strActiveServer);
            cmdInsert.Connection = cxnNext;
            InsertSessionCore(cmdInsert,
                                BreadcrumbState.Sandwich,
                                false,  // fNoFailOnPkViolation
                                false, // fIsLegacyXboxTitle... this method is 360-only
                                dwTitleId,
                                strActiveServer,
                                seqNum);
            cxnNext.Close();
            return true;
            }
        finally
        {
            if(cxnNext != null)
            {
                cxnNext.Close();
            }
        }
    }


    // ------------------------------------------------------------------------
    // InsertSessionCore
    // Shared code to call the Insert stored proc, and handle errors
    // appropriately.  (shared by standard insert and breadcrumb code paths)
    // returns true if the DB call failed with PK_VIOLATION.  Throws on other
    // failures, and returns false if all is well.
    // ------------------------------------------------------------------------
    private static bool InsertSessionCore(
                            SqlCommand cmd,
                            BreadcrumbState bcsInsert, // the type of row we're inserting.  Either breadcrumb or sandwich
                            bool fNoFailOnPKViolation,
                            bool fIsLegacyXboxTitle,
                            ulong dwTitleId,
                            string strServerName, // TODOTHEOM: this is for logging only... crummy
                            uint seqNum)
    {
        HResult hr = HResult.S_OK;
        try
        {
            if(!fIsLegacyXboxTitle)
            {
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@ti_breadcrumb_state", (byte)bcsInsert);
            }

            cmd.ExecuteNonQuery();

            hr = (uint)(int)cmd.Parameters["@retval"].Value;
            if (HResult.Failed(hr))
            {
                // we expect that SQL errors will generate a SQLException that
                // will be caught below. Therefore we treat this as a
                // development error.
                throw new XRLException(hr, XEvent.Id.MATCH_CODE_1,
                    "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                    + "): Unexpected return code from stored proc = "
                    + hr
                    + ". titleId = " + (TitleId) dwTitleId);
            }
        }
        catch (SqlException e)
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                + "): titleId = " + (TitleId) dwTitleId
                + ", SqlException(" + SqlExceptionToString(e) + ")");

            if (ConsiderExceptionAsConnectionFailure(e))
            {
                hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                DBLayer.ReportFailure(strServerName, e.ToString());

                throw new XRLException(
                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                    XEvent.Id.MATCH_COMM_EXECUTE_INSERT,
                    "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                    + "): Failed to communicate with " + strServerName
                    + ".  titleId = " + (TitleId) dwTitleId, e);
            }

            switch (e.Errors[0].Number)
            {
                case SQLDefs.ERROR_PRIMARY_KEY_VIOLATION:
                    // Primary key violation.  Different behaviors for different callers.
                    if (fNoFailOnPKViolation)
                    {
                        //This can happen in normal operation
                        // since we may select the SessionID randomly, with
                        // no assurance that it is not already in use. Therefore,
                        // we may try again in this case.
                        return true; // tell the call that we failed due to PK violation, and need to retry.
                    }
                    else
                    {
                        // If we got back this error when we were supposed to be overwriting
                        // dupes, something's very wrong.
                        throw new XRLException(
                            HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                            XEvent.Id.MATCH_CODE_3,
                            "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                            + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                            + " titleId = " + (TitleId) dwTitleId, e);
                    }
                case SQLDefs.ERROR_INVALID_PARAM_NAME:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID,
                        XEvent.Id.MATCH_TITLEBUG_0,
                        "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                        + "): Invalid attribute id."
                        + " titleId = " + (TitleId) dwTitleId, e);

                case SQLDefs.ERROR_DATA_TRUNCATED:
                    // String or binary data would be truncated.
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_OVERFLOW,
                        XEvent.Id.MATCH_TITLEBUG_1,
                        "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                        + "): String or binary attribute too large."
                        + " titleId = " + (TitleId) dwTitleId, e);

                case SQLDefs.ERROR_PARAM_MISSING:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                        XEvent.Id.MATCH_TITLEBUG_2,
                        "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                        + "): Missing required session attribute."
                        + " titleId = " + (TitleId) dwTitleId, e);

                default:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                        XEvent.Id.MATCH_CODE_3,
                        "XMatchFD.DBLayer.InsertSessionCore(" + seqNum.ToString("X8")
                        + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                        + " titleId = " + (TitleId) dwTitleId, e);
            }
        }
        return false;
    }



    // ----------------------------------------------------------------------
    // InsertSessionLog - Logs the results of an insert session call to the
    // application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void InsertSessionLog(
        byte bServerType,
        byte bNatType,
        uint dwTitleId,
        XNADDR HostAddress,
        uint dwPublicOpen,
        uint dwPrivateOpen,
        uint dwPublicFilled,
        uint dwPrivateFilled,
        MatchAttribute[] rgAttributes,
        MatchXrl matchXrl,
        ulong qwSessionId,
        byte[] rgbKeyExchangeKey,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        if (matchXrl == MatchXrl.xmatchhost_srf)
        {
            sb.Append("MatchInsertXbox|");
        }
        else
        {
            sb.Append("MatchInsertXbox360|");
        }
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(qwSessionId.ToString("X16")); sb.Append("|");
        sb.Append(dwPublicOpen.ToString()); sb.Append("|");
        sb.Append(dwPrivateOpen.ToString()); sb.Append("|");
        sb.Append(dwPublicFilled.ToString()); sb.Append("|");
        sb.Append(dwPrivateFilled.ToString()); sb.Append("|");
        if (matchXrl == MatchXrl.xmatchhost2_ashx)
        {
            sb.Append(GetCallerPuid(rgAttributes).ToString("X16")); sb.Append("|");
            sb.Append(GetGamerHostname(rgAttributes)); sb.Append("|");
            sb.Append(GetGameType(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGameMode(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerZone(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerCountry(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerLanguage(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerRating(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetGamerMu(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetGamerSigma(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetPlatformLock(rgAttributes).ToString()); sb.Append("|");
        }
        sb.Append(bServerType.ToString("X2")); sb.Append("|");
        sb.Append(bNatType.ToString()); sb.Append("|");
        sb.Append(ByteSwap(HostAddress.ina).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(HostAddress.inaOnline).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(HostAddress.wPortOnline).ToString()); sb.Append("|");
        sb.Append(ByteSwap(HostAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(HostAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(HostAddress.sgaddr.qwXboxId).ToString("X16"));

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }

    // ----------------------------------------------------------------------
    // InsertSessionPerfCountersStart - updates perf counters at the start
    // of an insert session operation
    // ----------------------------------------------------------------------
    private static void InsertSessionPerfCountersStart(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType)
    {
        MatchInsertCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchInsertCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchhost_srf)
        {
            MatchInsertCounters.Counters.RequestsInProgressXboxInsert.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxInsert.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchhost2_ashx)
        {
            MatchInsertCounters.Counters.RequestsInProgressXbox360Insert.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Insert.Increment();
            }
            if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
            {
                MatchInsertCounters.Counters.RequestsInProgressXbox360InsertRanked.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360InsertRanked.Increment();
                }
            }
            else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
            {
                MatchInsertCounters.Counters.RequestsInProgressXbox360InsertStandard.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360InsertStandard.Increment();
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // InsertSessionPerfCountersEnd - updates perf counters at the end
    // of an insert session operation
    // ----------------------------------------------------------------------
    private static void InsertSessionPerfCountersEnd(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType,
        XomRequestTimeElapsed xrteRequestTime,
        HResult hr)
    {
        MatchInsertCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchInsertCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchhost_srf)
        {
            MatchInsertCounters.Counters.RequestsInProgressXboxInsert.Decrement();
            MatchInsertCounters.Counters.TotalRequestsXboxInsert.Increment();
            MatchInsertCounters.Counters.RequestsPerSecXboxInsert.Increment();
            MatchInsertCounters.Counters.AverageExecutionTimeXboxInsert.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchInsertCounters.Counters.AverageExecutionTimeBaseXboxInsert.Increment();
            if(HResult.Failed(hr))
            {
                MatchInsertCounters.Counters.TotalRequestsXboxInsertFailed.Increment();
                MatchInsertCounters.Counters.RequestsPerSecXboxInsertFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxInsert.Decrement();
                titleIdCounters.TotalRequestsXboxInsert.Increment();
                titleIdCounters.RequestsPerSecXboxInsert.Increment();
                titleIdCounters.AverageExecutionTimeXboxInsert.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXboxInsert.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXboxInsertFailed.Increment();
                    titleIdCounters.RequestsPerSecXboxInsertFailed.Increment();
                }
            }
        }
        else if (matchXrl == MatchXrl.xmatchhost2_ashx)
        {
            MatchInsertCounters.Counters.RequestsInProgressXbox360Insert.Decrement();
            MatchInsertCounters.Counters.TotalRequestsXbox360Insert.Increment();
            MatchInsertCounters.Counters.RequestsPerSecXbox360Insert.Increment();
            MatchInsertCounters.Counters.AverageExecutionTimeXbox360Insert.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchInsertCounters.Counters.AverageExecutionTimeBaseXbox360Insert.Increment();
            if(HResult.Failed(hr))
            {
                MatchInsertCounters.Counters.TotalRequestsXbox360InsertFailed.Increment();
                MatchInsertCounters.Counters.RequestsPerSecXbox360InsertFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Insert.Decrement();
                titleIdCounters.TotalRequestsXbox360Insert.Increment();
                titleIdCounters.RequestsPerSecXbox360Insert.Increment();
                titleIdCounters.AverageExecutionTimeXbox360Insert.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXbox360Insert.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXbox360InsertFailed.Increment();
                    titleIdCounters.RequestsPerSecXbox360InsertFailed.Increment();
                }
            }
            if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
            {
                MatchInsertCounters.Counters.RequestsInProgressXbox360InsertRanked.Decrement();
                MatchInsertCounters.Counters.TotalRequestsXbox360InsertRanked.Increment();
                MatchInsertCounters.Counters.RequestsPerSecXbox360InsertRanked.Increment();
                MatchInsertCounters.Counters.AverageExecutionTimeXbox360InsertRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchInsertCounters.Counters.AverageExecutionTimeBaseXbox360InsertRanked.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360InsertRanked.Decrement();
                    titleIdCounters.TotalRequestsXbox360InsertRanked.Increment();
                    titleIdCounters.RequestsPerSecXbox360InsertRanked.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360InsertRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360InsertRanked.Increment();
                }
            }
            else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
            {
                MatchInsertCounters.Counters.RequestsInProgressXbox360InsertStandard.Decrement();
                MatchInsertCounters.Counters.TotalRequestsXbox360InsertStandard.Increment();
                MatchInsertCounters.Counters.RequestsPerSecXbox360InsertStandard.Increment();
                MatchInsertCounters.Counters.AverageExecutionTimeXbox360InsertStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchInsertCounters.Counters.AverageExecutionTimeBaseXbox360InsertStandard.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360InsertStandard.Decrement();
                    titleIdCounters.TotalRequestsXbox360InsertStandard.Increment();
                    titleIdCounters.RequestsPerSecXbox360InsertStandard.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360InsertStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360InsertStandard.Increment();
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // InsertSessionRetryPerfCounters - updates the insert retry perf counters
    // ----------------------------------------------------------------------
    private static void InsertSessionRetryPerfCounters(
        bool fIsLegacyXboxTitle,
        uint dwTitleId)
    {
        MatchInsertRetryCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchInsertRetryCounters.Counters[dwTitleId];
        }

        if (fIsLegacyXboxTitle)
        {
            MatchInsertRetryCounters.Counters.TotalXboxInsertRetries.Increment();
            MatchInsertRetryCounters.Counters.PerSecXboxInsertRetries.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXboxInsertRetries.Increment();
                titleIdCounters.PerSecXboxInsertRetries.Increment();
            }
        }
        else
        {
            MatchInsertRetryCounters.Counters.TotalXbox360InsertRetries.Increment();
            MatchInsertRetryCounters.Counters.PerSecXbox360InsertRetries.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXbox360InsertRetries.Increment();
                titleIdCounters.PerSecXbox360InsertRetries.Increment();
            }
        }
    }

    // ----------------------------------------------------------------------
    // InsertSessionRetryFailurePerfCounters - updates the insert retry
    // failure perf counters
    // ----------------------------------------------------------------------
    private static void InsertSessionRetryFailurePerfCounters(
        bool fIsLegacyXboxTitle,
        uint dwTitleId)
    {
        MatchInsertRetryCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchInsertRetryCounters.Counters[dwTitleId];
        }

        if (fIsLegacyXboxTitle)
        {
            MatchInsertRetryCounters.Counters.TotalXboxInsertRetryFailures.Increment();
            MatchInsertRetryCounters.Counters.PerSecXboxInsertRetryFailures.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXboxInsertRetryFailures.Increment();
                titleIdCounters.PerSecXboxInsertRetryFailures.Increment();
            }
        }
        else
        {
            MatchInsertRetryCounters.Counters.TotalXbox360InsertRetryFailures.Increment();
            MatchInsertRetryCounters.Counters.PerSecXbox360InsertRetryFailures.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXbox360InsertRetryFailures.Increment();
                titleIdCounters.PerSecXbox360InsertRetryFailures.Increment();
            }
        }
    }


    // ----------------------------------------------------------------------
    // UpdateSession - update an existing session
    // ----------------------------------------------------------------------
    public static HResult UpdateSession(
        ulong qwSessionId,
        uint dwTitleId,
        uint dwPublicOpen,
        uint dwPrivateOpen,
        uint dwPublicFilled,
        uint dwPrivateFilled,
        MatchAttribute[] rgAttributes,
        MatchXrl matchXrl,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        HResult hr = HResult.S_OK;
        SqlCommand cmdUpdate = null;
        SqlConnection cxnUpdateBC = null;
        SqlConnection cxnUpdateSW = null;
        DateTime dtExpire;
        // used for logging, to track BC related row moves.  The default case is no breadcrumb...
        BreadcrumbTransition bct = BreadcrumbTransition.UpdateOriginal;

        byte bBCGameType = MatchDefs.GetGameTypeFromSessionId(qwSessionId);
        byte bBCGameMode = MatchDefs.GetGameModeFromSessionId(qwSessionId);
        byte bBCRRID = MatchDefs.XNetXnKidGetDatabaseIndex(qwSessionId);
        uint dwBCBucket = dwBucketIDFromAttribs(bBCGameType, bBCGameMode, bBCRRID);
        UpdateSessionPerfCountersStart(matchXrl, dwTitleId, bBCGameType);

        SqlDataReader reader = null;
        try
        {
            TitleInfo ti = GetTitleInfo(dwTitleId, seqNum);

            // figure out if this is a legacy xbox title by the xrl that
            // was used
            bool fIsLegacyXboxTitle = false;
            if (matchXrl == MatchXrl.xmatchhost_srf && !ti.ForceXenonBehavior)
            {
                fIsLegacyXboxTitle = true;
            }

            // TODO2THEOM: Should there be special error handling for cases where the
            // server name could not be found, possibly due to bad type/mode?  Right now things throw.

            // Retrieve the name of the server that the row to be updated was first
            // created on, according to the sessionid.  This server will either have
            // a breadcrumb for the row, or the actual data.
            IBucketServer ibsBCBucket = ti.GetBucketForPartitionAndRRID(
                    bBCGameType,
                    bBCGameMode,
                    bBCRRID,
                    seqNum);

            cmdUpdate = CreateUpdateSqlCommand(dwTitleId, fIsLegacyXboxTitle);

            // Build up the standard parameters
            MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);
            MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                "@i_public_available", dwPublicOpen);
            MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                "@i_private_available", dwPrivateOpen);
            MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                "@i_public_current", dwPublicFilled);
            MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                "@i_private_current", dwPrivateFilled);

            if (fIsLegacyXboxTitle)
            {
                MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                    "@i_expiration", ti.SessionExpiration);
            }
            else
            {
                // 360 titles now calculate the session expire time at
                // the FD, to simplify the SQL code for session moves
                dtExpire = DateTime.UtcNow.AddSeconds(ti.SessionExpiration);
                MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                    "@dt_session_expire", dtExpire);
            }



            // Add title-specific parameters
            AddSessionAttributesToSqlCommand(dwTitleId, rgAttributes,
                cmdUpdate, fIsLegacyXboxTitle, seqNum);

            if (fIsLegacyXboxTitle)
            {
                    UpdateSessionForBucket(cmdUpdate,
                    BreadcrumbState.Breadcrumb, // updating a breadcrumb, although there are no SWs for legacyxbox titles.
                    ibsBCBucket,
                    qwSessionId,
                    ti,
                    fIsLegacyXboxTitle,
                    dwTitleId,
                    seqNum,
                    out cxnUpdateBC);
                //cmdUpdate.ExecuteNonQuery();  // get the first column of the first row, which is the return code
                //hr = (uint)(int)cmdUpdate.Parameters["@retval"].Value;
                //UpdateSessionThrowOnHrFail(hr, seqNum, dwTitleId);
            }
            else
            {
                // using a reader and getting back a row, because it was easier/cleaner
                // than creating ~70 output params and shuttling them around.
                // however, this means we can't get at the return code until after
                // reading the row and closing the reader.  In order to get around this,
                // we now put the return code in the result set, AND in a param.


                // first, update the base location of the session.  This is whatever bucket the session was put in
                // when it was first created.
                // If the session has been "breadcrumbed", this will be the location of the breadcrumb (a row with bc state 1).
                // If not, it'll be a row with bc state 3.
                reader = UpdateSessionForBucket(cmdUpdate,
                BreadcrumbState.Breadcrumb, // updating a breadcrumb, please.
                ibsBCBucket,
                qwSessionId,
                ti,
                fIsLegacyXboxTitle,
                dwTitleId,
                seqNum,
                out cxnUpdateBC);

                // if UpdateSessionForBucket doesn't throw, we should have a good reader.
                // this reader tells us the current type/mode/rrid (bucket) of the Sandwich (data) row.

                // There several cases, which are covered by the big if/else statement below.

                // some miscelleous notes about who has the info necessary to update a session:
                // FD knows the server the row was originally on.
                // FD knows what game type the row originally had.
                // FD knows what server it's calling to do the initial update.
                // FD can suggest a server that this update's type/mode should be on.
                // DB knows the server the row's data is currently on.
                // DB knows whether this update changes type/mode

                // TODO2THEOM: add code to handle a session that's in a state where the previous
                // breadcrumb operation failed.  These should have expired locks.

                // a few words on Breadcrumbs (BC) and Sandwiches (SW), since the analogy doesn't totally match
                // the implementation...

                // When a session starts out, it has only one database row, which is located on the server pointed
                // to by the bucket that the session was created in.  (at this point, bc state is 1, and i_sw_bucket is null)
                // At this point the session is considered a breadcrumb with no sandwich.
                // If the session's mode is changed, its bucket changes, and it gets a sandwich in that new bucket.  As
                // a result, i_sw_bucket becomes non-null.
                // The new bucket may actually be on the same server as the old one, in which case the breadcrumb
                // and sandwich coexist in the same row.  (with bc state 3)
                // The mode can be changed again, either to some third state, or back to the original.  In all these cases,
                // the breadcrumb stays in the same place and points to the sandwich, while the sandwich is moved around.

                // The reason for all this is that there are two ways of finding a session -- through its sessionid, and
                // through its type and mode.
                // - The sessionid search uses the bucket information encoded into the sessionid
                // to figure out what server the session is on, and therefore ends up at the breadcrumb server.
                // - The type/mode search just searches within the server (or servers) that are hosting that type/mode.  So
                // the session needs a placeholder in that bucket.  That's the purpose of the sandwich.


                BreadcrumbState bcs = BreadcrumbState.Breadcrumb;  // this will be set to the final state for the BC row
                // initialize sandwich info to breadcrumb info, as the default.  TODOTHEOM: be more explicit about this?
                byte bSWGameType = bBCGameType;
                byte bSWGameMode = bBCGameMode;
                byte bSWRRID = bBCRRID;
                IBucketServer ibsSWBucket = ibsBCBucket;
                uint dwSWBucket = dwBCBucket;

                bcs = (BreadcrumbState)(byte)reader["ti_breadcrumb_state"];
                if(IsNullColumn(reader, "i_sw_bucket"))
                {
                    dwSWBucket = dwBCBucket;
                }
                else
                {
                    dwSWBucket = (uint)(int)reader["i_sw_bucket"];
                }

                ibsSWBucket = Config.GetTitleBucketServer(Interface.xmatch, dwTitleId, dwSWBucket);
                bSWGameType = (byte)(dwSWBucket >> 16);
                bSWGameMode = (byte)((dwSWBucket >> 8) & 0xFF);
                bSWRRID = (byte)(dwSWBucket & 0xFF);

                // TODOTHEOM: Assert that bcs is not sandwich.

                // get the new type and mode that were passed in to the Update() call.
                // if the new type and mode were out of range (which is the case if they're not specified)
                // then set the new to the current.
                byte bNewGameType = GetGameType(rgAttributes);
                bNewGameType = bNewGameType > MatchDefs.XMATCH_MAX_GAMETYPE ? bSWGameType : bNewGameType;
                byte bNewGameMode = GetGameMode(rgAttributes);
                bNewGameMode = bNewGameMode > MatchDefs.XMATCH_MAX_GAMEMODE ? bSWGameMode : bNewGameMode;
                byte bNewRRID = 0;

                // set up purely for comparison with dwSW and dwBC because I don't want to
                // compare IBucketServer instances, and they don't have a dwBucketId member.
                uint dwNewBucket = dwBucketIDFromAttribs(bNewGameType, bNewGameMode, bNewRRID);
                IBucketServer ibsNewBucket = null;

                if (bSWGameMode == bNewGameMode)
                {
                    ibsNewBucket = ibsSWBucket;
                    dwNewBucket = dwSWBucket;
                    bNewRRID = bSWRRID;
                }
                else
                {
                    // This will only get called in the case where an insert will take place
                    ibsNewBucket = ti.GetNextRRBucketForPartition(
                                        bNewGameType,
                                        bNewGameMode,
                                        false,      // Don't choose draining buckets, should not be inserting into them.
                                        ref bNewRRID,
                                        seqNum);
                    dwNewBucket = dwBucketIDFromAttribs(bNewGameType, bNewGameMode, bNewRRID);
                }



                bool fInsertNew = false;  // the update resulted in a new session row being inserted somewhere

                if (dwNewBucket != dwBCBucket ||
                    dwSWBucket != dwBCBucket )  // The SW is in a different bucket from the BC, either before or after this operation..
                {
                    if (dwSWBucket == dwBCBucket) // row was not breadcrumbed before
                    {
                        if (dwNewBucket != dwSWBucket) // data moved to a new bucket.
                        {
                            // (1) insert into dwNewBucket, and clear the lock/set the new in BC

                            bct = BreadcrumbTransition.CreateInitialSW;
                            SqlCommand cmdInsert = MatchSql.InsertCmdFromReaderRow(reader, dwTitleId, false /*fCarryLock*/);
                            // insert to iBucketSWNew.NextServer, unless that overlaps with BC
                            // used to determine whether we have anything to delete on rollback
                            fInsertNew = InsertSWSessionForBucket(ibsNewBucket,       // the bucket to insert to
                                                    dwNewBucket,                      // tell the new SW where it is
                                                    GetActiveServer(ibsBCBucket),                // where the breadcrumb actually is
                                                    cmdInsert,
                                                    dwTitleId,
                                                    seqNum);
                            // if we inserted a new SW, the original row is now a "1"  (bcs.Breadcrumb)
                            // if we didn't insert, the original row is now a "3" (bcs.Both)
                            bcs = fInsertNew ? BreadcrumbState.Breadcrumb :
                                                BreadcrumbState.Both;
                        }
                        // else... we should never get here
                    }
                    else // it was breadcrumbed before
                    {
                        // currentbucket is not the original bucket.  But what's new bucket?
                        if (dwNewBucket == dwSWBucket)  // TODOTHEOM: consider not doing this update if it hits thesame BC server.  Check formigrate first, though.
                        {
                            bct = BreadcrumbTransition.UpdateExistingSW;
                            //// (5/5.5) just update the row on current, and clear the lock
                            // update "next" server.  If it fails, update current, insert to next, delete from current.
                            // TODOTHEOM: unless either of those updates would hit the BC or operations are interrupted by a delete.

                            // tell the update call that it's updating a sandwich
                            UpdateSessionForBucket(cmdUpdate,
                                                    BreadcrumbState.Sandwich, // update a sandwich, please
                                                    ibsSWBucket,
                                                    qwSessionId,
                                                    ti,
                                                    fIsLegacyXboxTitle,
                                                    dwTitleId,
                                                    seqNum,
                                                    out cxnUpdateSW);
                            // XONLINE:104017 -- set the desired breadcrumbstate to unknown.  This tell the DB to keep
                            // whatever state it had.  Btw, it could be that the original row has changed states in the call above,
                            // b.c. the SW bucket migrated to the BC bucket's server.
                            // in that case, we need Breadcrumbstate.Both, but the insert stored proc within
                            // updatesessionforbucket should have taken care of that.
                            bcs = BreadcrumbState.Unknown;
                        }
                        else if (dwNewBucket == dwBCBucket)
                        {
                            bct = BreadcrumbTransition.UnBreadcrumb;
                            // (3) delete from current bucket, clear the lock/set new bucket in BC
                            // delete from "next" server for the bucket. If it fails, delete
                            // from the "current" server for the bucket.  (unless either is the BC)
                            uint dwSWBucketTemp = UInt32.MaxValue; // TODOTHEOM: get rid of this, probably with an override.
                            string strDeletedFromServer = ""; // TODOTHEOM: make this optional too?
                            DeleteSessionForBucket(ibsSWBucket,
                                            BreadcrumbState.Sandwich,     // just to be safe, tell deletesession that it's deleting a sandwich.
                                            dwTitleId,
                                            qwSessionId,
                                            GetActiveServer(ibsBCBucket),
                                            ti,
                                            true /*fForceImmediateDelete*/,
                                            fIsLegacyXboxTitle,
                                            ref dwSWBucketTemp,
                                            ref strDeletedFromServer,
                                            seqNum);
                            // if the SW was on the BC server, deletesessionforbucket does nothing, but returns success.
                            // Either way, we need to set the state of that row from 3 (both) to 1 (breadcrumb)
                            bcs = BreadcrumbState.Breadcrumb;
                        }
                        else
                        {
                            bct = BreadcrumbTransition.MoveRemoteRow;

                            // (4) delete from current, insert to new, clear the lock/set new in BC
                            // we get back the contents of the breadcrumb, which are authoritative.
                            // note that this row has already been updated, so it's state is good for the next insert.

                            // delete from "next" server for the bucket. If it fails, delete
                            // from the "current" server for the bucket.  (unless either is the BC)
                            uint dwSWBucketTemp = UInt32.MaxValue; // TODOTHEOM: get rid of this, probably with an override.
                            string strDeletedFromServer = "";// TODOTHEOM: makethis optional
                            DeleteSessionForBucket(ibsSWBucket,
                                            BreadcrumbState.Sandwich,     // just to be safe, tell deletesession that it's deleting a sandwich.
                                            dwTitleId,
                                            qwSessionId,
                                            GetActiveServer(ibsBCBucket),
                                            ti,
                                            true /*fForceImmediateDelete*/,
                                            fIsLegacyXboxTitle,
                                            ref dwSWBucketTemp,
                                            ref strDeletedFromServer,
                                            seqNum);

                            // if the row that we're deleting is already deleted, it's because a delete
                            // beat the update to the punch.  Pretend the update succeeded, but don't
                            // insert the new row.
                            if (hr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
                            {
                                SqlCommand cmdInsert = MatchSql.InsertCmdFromReaderRow(reader, dwTitleId, false /*fCarryLock*/);
                                // insert to iBucketSWNew.NextServer, unless that overlaps with BC
                                fInsertNew = InsertSWSessionForBucket(ibsNewBucket,       // the bucket to insert to
                                                        dwNewBucket,                      // tell the new SW where it is
                                                        GetActiveServer(ibsBCBucket),                // where the breadcrumb actually is
                                                        cmdInsert,
                                                        dwTitleId,
                                                        seqNum);
                                bcs = fInsertNew ? BreadcrumbState.Breadcrumb :
                                                   BreadcrumbState.Both;
                            }
                        }
                    }

                    // NOTE: at this point, it's possible that the above Delete or Update failed because
                    // the target row was deleted by a delete request from the client.  (although very unlikely)
                    // We could avoid calling UpdateSessionCompleteForBucket in that case, but it's really not
                    // worth the extra complexity.

                    // another NOTE: the above calls may throw exceptions, which would mean that this
                    // UpdateComplete call would not get made, and the lock would not get cleared.  This is ok
                    // (for now at least) because the lock times out after a very short period, and no threads
                    // ever wait on the lock.  (they just fail.)
                    // TODOTHEOM: revamp the error handling so that it's consistent and avoids the above lock issue.

                    // clear the lock, and set the "new" SW bucket into the breadcrumb, to replace the current server.
                    hr = UpdateSessionCompleteForBucket(ibsBCBucket,
                                                    dwBCBucket,
                                                    dwNewBucket,
                                                    dwTitleId,
                                                    qwSessionId,
                                                    (byte)bcs,
                                                    seqNum);

                    // (bug 103713) if the breadcrumb has been deleted (or marked) since we last
                    // checked, the "new" data row needs to be deleted as cleanup.  (the delete will have
                    // taken care of the "current" row.)
                    if (fInsertNew == true &&
                        hr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
                    {
                        bct = BreadcrumbTransition.PreemptedByDelete;
                        uint dwSWBucketTemp = UInt32.MaxValue; // TODOTHEOM: get rid of this, probably with an override.
                        string strDeletedFromServer = "";// TODOTHEOM: makethis optio
                        // TODOTHEOM: this delete could be optimized to reuse the SQL connection that we just
                        // used to insert the row, and only delete from that one server.  But this case should be so rare
                        // that it's not worth doing right now..
                        DeleteSessionForBucket(ibsNewBucket,
                                        BreadcrumbState.Sandwich,     // tell deletesession that it's deleting a sandwich.
                                        dwTitleId,
                                        qwSessionId,
                                        "", // strNoDeleteFromThisServer
                                        ti,
                                        true /*fForceImmediateDelete*/,
                                        fIsLegacyXboxTitle,
                                        ref dwSWBucketTemp, // todotheom: not used
                                        ref strDeletedFromServer, // todotheom: not used
                                        seqNum);
                    }
                }
            }
        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below

            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_6,
                "XMatchFD.DBLayer.UpdateSession(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            if(cxnUpdateBC != null)
            {
                cxnUpdateBC.Close();
            }
            if(cxnUpdateSW != null)
            {
                cxnUpdateSW.Close();
            }

            UpdateSessionLog(qwSessionId, dwTitleId, dwPublicOpen, dwPrivateOpen, dwPublicFilled,
                dwPrivateFilled, bct, rgAttributes, matchXrl, xrteRequestTime, seqNum, hr);

            UpdateSessionPerfCountersEnd(matchXrl, dwTitleId, bBCGameType, bct, xrteRequestTime, hr);
        }
        return hr;
    }



    // ----------------------------------------------------------------------
    // UpdateSessionForBucket - does the work necessary to update a session
    // row in a bucket, migrating it to the "next" server for the bucket
    // at the saeme time.
    // ----------------------------------------------------------------------
    private static SqlDataReader UpdateSessionForBucket(
                                            SqlCommand cmdUpdate,
                                            BreadcrumbState bcsTargetRowType,
                                            IBucketServer ibsBucket,
                                            ulong qwSessionId,
                                            TitleInfo ti,
                                            bool fIsLegacyXboxTitle,
                                            uint dwTitleId,
                                            uint seqNum,
                                            out SqlConnection cxnUpdate)
    {
        // update the "next" server first.
        // If it fails, update "current" server, insert to "next", delete from "current".
        // unless either of those updates would hit the BC or operations are interrupted by a delete.
        // TODOTHEOM: don't update if the update is going over the breadcrumb.  (non-essential for now)

        // TODOTHEOM: more XomTrace logging about what session movement is happening.
        HResult hr = HResult.S_OK;
        SqlConnection cxnCurrDelete = null;
        SqlDataReader reader = null;
        string strActiveServer = null;

        strActiveServer = GetActiveServer(ibsBucket);

        try
        {
            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                + "): Using db=" + strActiveServer
                + " to update session id=" + qwSessionId.ToString("X16")
                + ". titleId = " + (TitleId) dwTitleId);

            SqlConnection cxnNext = OpenSqlConnectionToMatchDB(strActiveServer);
            // keep a reference to the connection that's associated with the reader we will return.
            // This connection will also be returned and closed by the caller, because needs the connection to stay open.
            cxnUpdate = cxnNext;
            cmdUpdate.Connection = cxnNext;

            if (fIsLegacyXboxTitle)
            {
                MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.ReturnValue,
                    "@retval", (uint)0);
                cmdUpdate.ExecuteNonQuery();  // get the first column of the first row, which is the return code
                hr = (uint)(int)cmdUpdate.Parameters["@retval"].Value;
            }
            else
            {
                // update needs to know what type of row we're updating, so that it doesn't accidentally
                // update a row of the wrong type that happens to be in the right place.
                if(cmdUpdate.Parameters.IndexOf("@ti_target_rowtype") == -1)
                {
                    MatchSql.SqlAddParam(cmdUpdate, ParameterDirection.Input,
                                    "@ti_target_rowtype", (byte)bcsTargetRowType);
                }
                else
                {
                    cmdUpdate.Parameters["@ti_target_rowtype"].Value = (byte)bcsTargetRowType;
                }
                reader = UpdateSessionCore(cmdUpdate, seqNum, dwTitleId);
                reader.Read();   // advance to first (and only) row
                hr = (uint)(int)reader["i_return_code"];
            }

            if (FBucketInMigration(ibsBucket) &&
                (hr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID ||        // the session wasn't there
                 hr == HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH))  // the SW or BC was there, but we were looking for the other.
            {
                try
                {
                    reader.Close();

                    // we need to move the row to its new location
                    // first, update the old location
                    SqlConnection cxnCurrent = OpenSqlConnectionToMatchDB(ibsBucket.CurrentServerName);
                    // keep a reference to the connection that's associated with the reader we will return.
                    // This connection will also be returned and closed by the caller, because needs the connection to stay open.
                    cxnUpdate = cxnCurrent;
                    cmdUpdate.Connection = cxnCurrent;
                    reader = UpdateSessionCore(cmdUpdate, seqNum, dwTitleId);
                    reader.Read(); // advance to first (and only) row
                    hr = (uint)(int)reader["i_return_code"];

                    // if that didn't work, fail
                    UpdateSessionThrowOnHrFail(hr, seqNum, dwTitleId);

                    // if the update worked, reader contains the updated info.  Insert it onto next.
                    SqlCommand cmdInsert = MatchSql.InsertCmdFromReaderRow(reader, dwTitleId, true /*fCarryLock*/);
                    cmdInsert.Connection = cxnNext;
                    InsertSessionCore(cmdInsert,
                                        bcsTargetRowType, // tell insert what type of row it's inserting
                                        false /*fNoFailOnPKViolation*/,
                                        fIsLegacyXboxTitle,
                                        dwTitleId,
                                        strActiveServer, // purely for logging purposes
                                        seqNum);

                    // open a new connection to the "current" DB, because the open reader
                    // occuripies the connection we already have.
                    // TODOTHEOM: consider switching to dataadapter or a custom data structure
                    // to allow the returned data row to be truly disconnected.
                    cxnCurrDelete = OpenSqlConnectionToMatchDB(ibsBucket.CurrentServerName);

                    // if it did work, we're responsible for cleaning up the row on
                    // the current server for the bucket
                    DeleteSessionCore(cxnCurrDelete,
                                        bcsTargetRowType, // tell the delete what type of row it's deleting.
                                        dwTitleId,
                                        qwSessionId,
                                        ti,
                                        true, // fForceImmediateDelete
                                        false, // fIsLegacyXboxTitle,
                                        ibsBucket.CurrentServerName, // for logging only?
                                        seqNum);
                    }
                    finally
                    {
                        if(cxnNext != null)
                        {
                            cxnNext.Close();
                        }
                        if(cxnCurrDelete != null)
                        {
                            cxnCurrDelete.Close();
                        }
                    }
            }
            else
            {
                // the row is in the right place, or there's an error
                UpdateSessionThrowOnHrFail(hr, seqNum, dwTitleId);
            }
        }
            // TODOTHEOM: deal with the error IDs here.
        catch (SqlException e) // translate SQL exceptions to XRLExceptions, which will be caught later.
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                + "): titleId = " + (TitleId) dwTitleId
                + ", SqlException(" + SqlExceptionToString(e) + ")");

            if (ConsiderExceptionAsConnectionFailure(e))
            {
                DBLayer.ReportFailure(e.Server, e.ToString());

                throw new XRLException(
                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                    XEvent.Id.MATCH_COMM_UPDATE,
                    "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                    + "): Failed to communicate with " + e.Server
                    + ".  titleId = " + (TitleId) dwTitleId, e);
            }

            switch (e.Errors[0].Number)
            {
                case SQLDefs.ERROR_INVALID_PARAM_NAME:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID,
                        XEvent.Id.MATCH_TITLEBUG_5,
                        "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                        + "): Invalid attribute id."
                        + " titleId = " + (TitleId) dwTitleId, e);

                case SQLDefs.ERROR_DATA_TRUNCATED:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_OVERFLOW,
                        XEvent.Id.MATCH_TITLEBUG_6,
                        "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                        + "): String or binary attribute too large."
                        + " titleId = " + (TitleId) dwTitleId, e);

                case SQLDefs.ERROR_PARAM_MISSING:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                        XEvent.Id.MATCH_TITLEBUG_7,
                        "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                        + "): Missing required session attribute."
                        + " titleId = " + (TitleId) dwTitleId, e);

                default:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                        XEvent.Id.MATCH_CODE_5,
                        "XMatchFD.DBLayer.UpdateSessionForBucket(" + seqNum.ToString("X8")
                        + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                        + " titleId = " + (TitleId) dwTitleId, e);
            }
        }
        return reader;
    }

    // ----------------------------------------------------------------------
    // UpdateSessionComplete - private helper to finish the update of a row
    // that needed a cross-machine update.  (was breadcrumbed)
    // ----------------------------------------------------------------------
    private static HResult UpdateSessionCompleteForBucket(
                                            IBucketServer ibsBCBucket,
                                            uint dwBCBucket,
                                            uint dwSWBucket,
                                            uint dwTitleId,
                                            ulong qwSessionId,
                                            byte bBreadcrumbState,
                                            uint seqNum)
    {
        HResult hr = 0;
        SqlConnection cxn = null;
        SqlCommand cmd = null;
        string strActiveServer = null;

        strActiveServer = GetActiveServer(ibsBCBucket);

        try
        {
            cxn = OpenSqlConnectionToMatchDB(strActiveServer);
            cmd = CreateUpdateCompleteSqlCommand(dwTitleId, cxn);

            // Build up the  parameters
            MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);
            if(dwSWBucket != dwBCBucket)
            {
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_sw_bucket", (int)dwSWBucket);
            }
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@ti_breadcrumb_state", bBreadcrumbState);

            // Retry logic, we should not retry more than once.
            // Note that retry is only used for deadlocks.
            int allowedTries = 2;
            for (int currentTry = 0;
                    currentTry < allowedTries;
                    currentTry++)
            {
                try
                {
                        cmd.ExecuteNonQuery();
                        hr = (uint)(int)cmd.Parameters["@retval"].Value;
                        break; // getting here means success, so break
                }
                catch(SqlException e)
                {
                    // if the process was deadlocked, retry since it'll probably get through the second time.
                    if (SQLDefs.ERROR_DEADLOCKED_PROCESS_KILLED == e.Errors[0].Number)
                    {
                        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                            "XMatchFD.DBLayer.UpdateSessionComplete(" + seqNum.ToString("X8")
                            + "): titleId = " + (TitleId) dwTitleId
                            + ", Deadlock encountered - SqlException:(" + SqlExceptionToString(e) + ")");
                    }
                    else
                    {
                        // rethrow, since other sql exceptions will be caught below.
                        throw;
                    }
                }
            }

            // bug 103713: updatesessioncomplete needs to return INVALID_SESSION_ID
            // if that's what SQL returned. (the caller uses this to decide what to do next)
            if (HResult.Failed(hr) && hr != HResult.XONLINE_E_MATCH_INVALID_SESSION_ID)
            {
                // we expect that SQL errors will generate a
                // SQLException that will be caught below. Therefore
                // we treat this as a development error.
                throw new XRLException(hr, XEvent.Id.MATCH_CODE_4,
                    "XMatchFD.DBLayer.UpdateSessionComplete(" + seqNum.ToString("X8")
                    + "): Unexpected return code from stored proc = "
                    + hr
                    + ". titleId = " + (TitleId) dwTitleId);
            }
        }
        catch (Exception e)
        {
            // get the hr from the exception, or use a default vaule

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifially without an event or
            // alreday has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId))
            {
                throw;
            }
            else
            {

                // Something unexpected has happened. Rethrow an XRLException
                // so we get proper eventing.  Logging will be done in UpdateSession.
                throw new XRLException(
                    hr,
                    XEvent.Id.MATCH_CODE_6, // TODOTHEOM: change this code?
                    "XMatchFD.DBLayer.UpdateSessionComplete(" + seqNum.ToString("X8") + "): "
                    + "Unexpected exception was thrown. Details should follow.", e);
            }
        }
        finally
        {
            if (cxn != null)
            {
                cxn.Close();
            }
        }
        return hr;
    }

    // ----------------------------------------------------------------------
    // UpdateSessionCore - executes the passed in reader against the passed in
    // connection, and does some error handling / retry logic
    // TODO: move more logic here, to simplify the higher levels
    // ----------------------------------------------------------------------
    private static SqlDataReader UpdateSessionCore(SqlCommand cmd, uint seqNum, uint dwTitleId)
    {
        // Retry logic, we should not retry more than once.
        // Note that retry is only used for deadlocks.
        SqlDataReader reader = null;
        int allowedTries = 2;
        for (int currentTry = 0;
                currentTry < allowedTries;
                currentTry++)
        {
            try
            {
                reader = cmd.ExecuteReader();
                break;
            }
            catch(SqlException e)
            {
                // if the process was deadlocked, retry since it'll probably get through the second time.
                if (SQLDefs.ERROR_DEADLOCKED_PROCESS_KILLED == e.Errors[0].Number)
                {
                    Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                        "XMatchFD.DBLayer.UpdateSessionCore(" + seqNum.ToString("X8")
                        + "): titleId = " + (TitleId) dwTitleId
                        + ", Deadlock encountered - SqlException:(" + SqlExceptionToString(e) + ")");
                }
                else
                {
                    // rethrow, as other sql exceptions will be handled higher in the stack.
                    throw;
                }
            }
        }
        return reader;
    }


    // ----------------------------------------------------------------------
    // UpdateSessionThrowOnHrFail - throws on Hresult failures returned from
    // the update stored proc.  Separated into a function for code brevity.
    // ----------------------------------------------------------------------
    private static void UpdateSessionThrowOnHrFail(HResult hr, uint seqNum, uint dwTitleId)
    {
        if (HResult.Failed(hr))
        {
            switch (hr)
            {
                case HResult.XONLINE_E_MATCH_INVALID_SESSION_ID:
                    // If the session is gone, its because the game
                    // deleted it. If the game deleted it, then it
                    // shouldn't be trying to update it later. Thus,
                    // we consider this a game error
                    throw new XRLExceptionWithoutEvent(hr,
                        "XMatchFD.DBLayer.UpdateSession(" + seqNum.ToString("X8")
                        + "): Attempt to update invalid session id."
                        + " titleId = " + (TitleId) dwTitleId);

                default:
                    // we expect that SQL errors will generate a
                    // SQLException that will be caught below. Therefore
                    // we treat this as a development error.
                    throw new XRLException(hr, XEvent.Id.MATCH_CODE_4,
                        "XMatchFD.DBLayer.UpdateSession(" + seqNum.ToString("X8")
                        + "): Unexpected return code from stored proc = "
                        + hr
                        + ". titleId = " + (TitleId) dwTitleId);
            }
        }
    }


    // ----------------------------------------------------------------------
    // UpdateSessionLog - Logs the results of an update session call to the
    // application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void UpdateSessionLog(
        ulong qwSessionId,
        uint dwTitleId,
        uint dwPublicOpen,
        uint dwPrivateOpen,
        uint dwPublicFilled,
        uint dwPrivateFilled,
        BreadcrumbTransition bct,
        MatchAttribute[] rgAttributes,
        MatchXrl matchXrl,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        if (matchXrl == MatchXrl.xmatchhost_srf)
        {
            sb.Append("MatchUpdateXbox|");
        }
        else
        {
            sb.Append("MatchUpdateXbox360|");
        }
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(qwSessionId.ToString("X16")); sb.Append("|");
        sb.Append(dwPublicOpen.ToString()); sb.Append("|");
        sb.Append(dwPrivateOpen.ToString()); sb.Append("|");
        sb.Append(dwPublicFilled.ToString()); sb.Append("|");
        sb.Append(dwPrivateFilled.ToString());
        if (matchXrl == MatchXrl.xmatchhost2_ashx) // it's a 360 request
        {
            sb.Append("|");
            sb.Append(((int)bct).ToString()); sb.Append("|");
            sb.Append(GetCallerPuid(rgAttributes).ToString("X16")); sb.Append("|");
            sb.Append(GetGamerHostname(rgAttributes)); sb.Append("|");
            sb.Append(GetGameType(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGameMode(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerZone(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerCountry(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerLanguage(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerRating(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetGamerMu(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetGamerSigma(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetPlatformLock(rgAttributes).ToString());
        }

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }


    // ----------------------------------------------------------------------
    // UpdateSessionPerfCountersStart - updates perf counters at the start
    // of an update session operation
    // ----------------------------------------------------------------------
    private static void UpdateSessionPerfCountersStart(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType)
    {
        MatchUpdateCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchUpdateCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchhost_srf)
        {
            MatchUpdateCounters.Counters.RequestsInProgressXboxUpdate.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxUpdate.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchhost2_ashx)
        {
            MatchUpdateCounters.Counters.RequestsInProgressXbox360Update.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Update.Increment();
            }
            if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
            {
                MatchUpdateCounters.Counters.RequestsInProgressXbox360UpdateRanked.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360UpdateRanked.Increment();
                }
            }
            else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
            {
                MatchUpdateCounters.Counters.RequestsInProgressXbox360UpdateStandard.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360UpdateStandard.Increment();
                }
            }
        }
    }


    // ----------------------------------------------------------------------
    // UpdateSessionPerfCountersEnd - updates perf counters at the end
    // of an insert session operation
    // ----------------------------------------------------------------------
    private static void UpdateSessionPerfCountersEnd(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType,
        BreadcrumbTransition bct,
        XomRequestTimeElapsed xrteRequestTime,
        HResult hr)
    {
        MatchUpdateCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchUpdateCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchhost_srf)
        {
            MatchUpdateCounters.Counters.RequestsInProgressXboxUpdate.Decrement();
            MatchUpdateCounters.Counters.TotalRequestsXboxUpdate.Increment();
            MatchUpdateCounters.Counters.RequestsPerSecXboxUpdate.Increment();
            MatchUpdateCounters.Counters.AverageExecutionTimeXboxUpdate.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchUpdateCounters.Counters.AverageExecutionTimeBaseXboxUpdate.Increment();
            if(HResult.Failed(hr))
            {
                MatchUpdateCounters.Counters.TotalRequestsXboxUpdateFailed.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXboxUpdateFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxUpdate.Decrement();
                titleIdCounters.TotalRequestsXboxUpdate.Increment();
                titleIdCounters.RequestsPerSecXboxUpdate.Increment();
                titleIdCounters.AverageExecutionTimeXboxUpdate.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXboxUpdate.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXboxUpdateFailed.Increment();
                    titleIdCounters.RequestsPerSecXboxUpdateFailed.Increment();
                }
            }
        }
        else if (matchXrl == MatchXrl.xmatchhost2_ashx)
        {
            MatchUpdateCounters.Counters.RequestsInProgressXbox360Update.Decrement();
            MatchUpdateCounters.Counters.TotalRequestsXbox360Update.Increment();
            MatchUpdateCounters.Counters.RequestsPerSecXbox360Update.Increment();

            if(HResult.Failed(hr))
            {
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateFailed.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateFailed.Increment();
            }

            // conditionally increment counters dedicated to tracking breadcrumb movement
            switch(bct)
            {
            case BreadcrumbTransition.UpdateOriginal:
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateBCUpdateOriginal.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateBCUpdateOriginal.Increment();
                break;
            case BreadcrumbTransition.CreateInitialSW:
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateBCCreateInitialSW.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateBCCreateInitialSW.Increment();
                break;
            case BreadcrumbTransition.UpdateExistingSW:
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateBCUpdateExistingSW.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateBCUpdateExistingSW.Increment();
                break;
            case BreadcrumbTransition.MoveRemoteRow:
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateBCMoveRemoteRow.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateBCMoveRemoteRow.Increment();
                break;
            case BreadcrumbTransition.UnBreadcrumb:
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateBCUnBreadcrumb.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateBCUnBreadcrumb.Increment();
                break;
            case BreadcrumbTransition.PreemptedByDelete:
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateBCPreemptedByDelete.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateBCPreemptedByDelete.Increment();
                break;
            }

            MatchUpdateCounters.Counters.AverageExecutionTimeXbox360Update.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchUpdateCounters.Counters.AverageExecutionTimeBaseXbox360Update.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Update.Decrement();
                titleIdCounters.TotalRequestsXbox360Update.Increment();
                titleIdCounters.RequestsPerSecXbox360Update.Increment();
                titleIdCounters.AverageExecutionTimeXbox360Update.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXbox360Update.Increment();

                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXbox360UpdateFailed.Increment();
                    titleIdCounters.RequestsPerSecXbox360UpdateFailed.Increment();
                }

                // conditionally increment counters dedicated to tracking breadcrumb movement
                switch (bct)
                {
                    case BreadcrumbTransition.UpdateOriginal:
                        titleIdCounters.TotalRequestsXbox360UpdateBCUpdateOriginal.Increment();
                        titleIdCounters.RequestsPerSecXbox360UpdateBCUpdateOriginal.Increment();
                        break;
                    case BreadcrumbTransition.CreateInitialSW:
                        titleIdCounters.TotalRequestsXbox360UpdateBCCreateInitialSW.Increment();
                        titleIdCounters.RequestsPerSecXbox360UpdateBCCreateInitialSW.Increment();
                        break;
                    case BreadcrumbTransition.UpdateExistingSW:
                        titleIdCounters.TotalRequestsXbox360UpdateBCUpdateExistingSW.Increment();
                        titleIdCounters.RequestsPerSecXbox360UpdateBCUpdateExistingSW.Increment();
                        break;
                    case BreadcrumbTransition.MoveRemoteRow:
                        titleIdCounters.TotalRequestsXbox360UpdateBCMoveRemoteRow.Increment();
                        titleIdCounters.RequestsPerSecXbox360UpdateBCMoveRemoteRow.Increment();
                        break;
                    case BreadcrumbTransition.UnBreadcrumb:
                        titleIdCounters.TotalRequestsXbox360UpdateBCUnBreadcrumb.Increment();
                        titleIdCounters.RequestsPerSecXbox360UpdateBCUnBreadcrumb.Increment();
                        break;
                    case BreadcrumbTransition.PreemptedByDelete:
                        titleIdCounters.TotalRequestsXbox360UpdateBCPreemptedByDelete.Increment();
                        titleIdCounters.RequestsPerSecXbox360UpdateBCPreemptedByDelete.Increment();
                        break;
                }
            }
            if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
            {
                MatchUpdateCounters.Counters.RequestsInProgressXbox360UpdateRanked.Decrement();
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateRanked.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateRanked.Increment();
                MatchUpdateCounters.Counters.AverageExecutionTimeXbox360UpdateRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchUpdateCounters.Counters.AverageExecutionTimeBaseXbox360UpdateRanked.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360UpdateRanked.Decrement();
                    titleIdCounters.TotalRequestsXbox360UpdateRanked.Increment();
                    titleIdCounters.RequestsPerSecXbox360UpdateRanked.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360UpdateRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360UpdateRanked.Increment();
                }
            }
            else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
            {
                MatchUpdateCounters.Counters.RequestsInProgressXbox360UpdateStandard.Decrement();
                MatchUpdateCounters.Counters.TotalRequestsXbox360UpdateStandard.Increment();
                MatchUpdateCounters.Counters.RequestsPerSecXbox360UpdateStandard.Increment();
                MatchUpdateCounters.Counters.AverageExecutionTimeXbox360UpdateStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchUpdateCounters.Counters.AverageExecutionTimeBaseXbox360UpdateStandard.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360UpdateStandard.Decrement();
                    titleIdCounters.TotalRequestsXbox360UpdateStandard.Increment();
                    titleIdCounters.RequestsPerSecXbox360UpdateStandard.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360UpdateStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360UpdateStandard.Increment();
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // DeleteSession - delete an existing session
    // ----------------------------------------------------------------------
    public static HResult DeleteSession(
        uint dwTitleId,
        ulong qwSessionId,
        MatchXrl matchXrl,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        HResult hr = HResult.S_OK; // start with ok... DeleteSessionCore throws on error.
        uint dwSWBucket = UInt32.MaxValue;
        string strDeletedFromServer = "";

        byte gameType = MatchDefs.GetGameTypeFromSessionId(qwSessionId);
        DeleteSessionPerfCountersStart(matchXrl, dwTitleId, gameType);

        try
        {
            TitleInfo ti = GetTitleInfo(dwTitleId, seqNum);

            // figure out if this is a legacy xbox title by the xrl that
            // was used
            bool fIsLegacyXboxTitle = false;
            if (matchXrl == MatchXrl.xmatchhostdelete_srf && !ti.ForceXenonBehavior)
            {
                fIsLegacyXboxTitle = true;
            }

            // Get the bucket for this partition,
            // using the type/mode/rrid from the sessionid

            byte bType = MatchDefs.GetGameTypeFromSessionId(qwSessionId);
            byte bMode = MatchDefs.GetGameModeFromSessionId(qwSessionId);
            byte bRRID = MatchDefs.XNetXnKidGetDatabaseIndex(qwSessionId);
            uint dwBCBucket = dwBucketIDFromAttribs(bType, bMode, bRRID);

            IBucketServer ibsBCBucket = ti.GetBucketForPartitionAndRRID(
                    bType,
                    bMode,
                    bRRID,
                    seqNum);

            DeleteSessionForBucket(ibsBCBucket,
                                  BreadcrumbState.Both, // XONLINE:108894 -- delete both BC and Sandwich if they're sharing a row.
                                  dwTitleId,
                                  qwSessionId,
                                  null,
                                  ti,
                                  false /*fForceImmediateDelete*/,
                                  fIsLegacyXboxTitle,
                                  ref dwSWBucket,
                                  ref strDeletedFromServer,
                                  seqNum);


            // if the SW is in a different bucket, we need to delete the SW too
            if (dwSWBucket != UInt32.MaxValue &&
                dwBCBucket != dwSWBucket)
            {
                // TODOTHEOM: assert !fIsLegacyXboxTitle?
                IBucketServer ibsSWBucket = Config.GetTitleBucketServer(Interface.xmatch, dwTitleId, dwSWBucket);
                DeleteSessionForBucket(ibsSWBucket,
                                  BreadcrumbState.Sandwich,
                                  dwTitleId,
                                  qwSessionId,
                                  null,
                                  ti,
                                  true /*fForceImmediateDelete*/,
                                  fIsLegacyXboxTitle,
                                  ref dwSWBucket,
                                  ref strDeletedFromServer,
                                  seqNum);
            }
        }

        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below

            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_9,
                "XMatchFD.DBLayer.DeleteSession(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            DeleteSessionLog(qwSessionId, dwTitleId, matchXrl, xrteRequestTime, seqNum, hr);

            DeleteSessionPerfCountersEnd(matchXrl, dwTitleId, gameType, xrteRequestTime, hr);
        }
        return hr;
    }

    // ----------------------------------------------------------------------
    // DeleteSessionCore - see below
    // this one's an override for callers that don't care about strCurrentSrv
    // ----------------------------------------------------------------------
    private static void DeleteSessionCore(SqlConnection cxn,
                                        BreadcrumbState bcs,
                                        uint dwTitleId,
                                        ulong qwSessionId,
                                        TitleInfo ti,
                                        bool fForceImmediateDelete,
                                        bool fIsLegacyXboxTitle,
                                        string strCxnServer,
                                        uint seqNum)
    {
        uint dwCurrentBucket = UInt32.MaxValue;
        DeleteSessionCore(cxn,
                          bcs,
                          dwTitleId,
                          qwSessionId,
                          ti,
                          fForceImmediateDelete,
                          fIsLegacyXboxTitle,
                          strCxnServer,
                          ref dwCurrentBucket,
                          seqNum);
    }



    // ----------------------------------------------------------------------
    // DeleteSessionCore
    // encapsulates the core logic of creating a delete command, executing
    // it against a server, and retrying where appropriate.
    // (and all kinds of crazy error handling)
    // ----------------------------------------------------------------------
    private static HResult DeleteSessionCore(SqlConnection cxn,
                                        BreadcrumbState bcs,
                                        uint dwTitleId,
                                        ulong qwSessionId,
                                        TitleInfo ti,
                                        bool fForceImmediateDelete,
                                        bool fIsLegacyXboxTitle,
                                        string strCxnServer,
                                        ref uint dwSWBucket,
                                        uint seqNum)
    {
        HResult hr = HResult.S_OK;
        bool fRetry = true;
        dwSWBucket = UInt32.MaxValue; // tell the caller that no i_sw_bucket came back by default.  TODOTHEOM: use a better const here.

        SqlCommand cmd = CreateDeleteSqlCommand(dwTitleId, fIsLegacyXboxTitle, cxn);

        if (!fIsLegacyXboxTitle) // 360 titles get extra params to handle breadcrumbs
        {
            MatchSql.SqlAddParam(cmd, ParameterDirection.Output, "@i_sw_bucket", (uint)0);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input, "@ti_target_rowtype", (byte)bcs);
        }

        MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);
        MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);

        if (!fForceImmediateDelete && ti.DeleteDelaySeconds > 0)
        {
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_delete_delay_seconds", ti.DeleteDelaySeconds);
        }

        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                "XMatchFD.DBLayer.DeleteSession(" + seqNum.ToString("X8")
                + "): Using db=" + cxn.DataSource
                + " to delete session id=" + qwSessionId.ToString("X16")
                + ". titleId = " + (TitleId) dwTitleId);

        try
        {
            // Retry logic, we should not retry more than once.
            // Note that retry is only used for 2 cases, ERROR_INVALID_PARAM_NAME, and deadlocks
            fRetry = true;
            for (int currentTry = 0, allowedTries = 2;
                    fRetry == true &&
                    currentTry < allowedTries;
                    currentTry++)
            {
                try
                {
                    cmd.ExecuteNonQuery();

                    // If we failed to issue this command with the parameter the title
                    // is likely misconfigured
                    hr = (uint)(int)cmd.Parameters["@retval"].Value;
                    if (HResult.Failed(hr))
                    {
                        switch (hr)
                        {
                            case HResult.XONLINE_E_MATCH_INVALID_SESSION_ID:
                            case HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH:
                                // This is either a game issue (A game shouldn't
                                // try to delete a session that is already gone) or we're doing a migration
                                // and just tried the server that the session isn't on.
                                // Alternatively, it could be that the wrong part of the session (bc or sw)
                                // is present there.
                                hr = HResult.S_FALSE;
                                fRetry = false; // if the session wasn't found, no reason to retry.
                                break;
                            default:
                                // we expect that SQL errors will generate a
                                // SQLException that will be caught below. Therefore
                                // we treat this as a development error.
                                throw new XRLException(hr, XEvent.Id.MATCH_CODE_7,
                                        "XMatchFD.DBLayer.DeleteSession(" + seqNum.ToString("X8")
                                        + "): Unexpected return code from stored proc="
                                        + hr
                                        + " titleId = " + (TitleId) dwTitleId);
                        }
                    }
                    else
                    {
                        fRetry = false; // all is well
                        dwSWBucket = UInt32.MaxValue; // tell the caller that no i_sw_bucket came back by default.  TODOTHEOM: use a better const here.
                        if (!fIsLegacyXboxTitle)
                        {
                            // if we got back a value for @vc_current_server, that means we need
                            // to do an additional delete on that server
                            SqlParameter paramSWBucket = cmd.Parameters["@i_sw_bucket"];
                            // TODOTHEOM: I'm not sure whether i_sw_bucket is always null in the non-BC case.
                            // TODOTHEOM: is the DBNull check necessary either way?
                            if (paramSWBucket.Value != DBNull.Value)
                            {
                                dwSWBucket = (uint)(int)paramSWBucket.Value;
                            }
                        }
                    }
                }
                catch (SqlException e)
                {
                    // There are a couple cases where we may retry
                    if (0 == currentTry)
                    {
                        // Handle titles that have t_match_titles.i_delete_delay_seconds
                        // set but have not had the stored procs updated or tables updated
                        // correctly
                        // By not "throw"ing, we trigger a retry
                        if(ti.DeleteDelaySeconds > 0 && SQLDefs.ERROR_INVALID_PARAM_NAME == e.Errors[0].Number)
                        {
                            Xom.NtEvent(XEvent.Id.MATCH_CONFIG_72, e,
                                "XMatchFD.DBLayer.DeleteSession({0}): Check npdb.t_match_titles.i_delete_delay_seconds for non-zero for titleId = {1}",
                                seqNum.ToString("X8"), (TitleId) dwTitleId
                            );

                            // if we want the retry to succeed, we have to remove the offending param
                            cmd.Parameters.RemoveAt("@i_delete_delay_seconds");
                        }
                        // if the process was deadlocked, retry since it'll probably get through the second time.
                        else if(SQLDefs.ERROR_DEADLOCKED_PROCESS_KILLED == e.Errors[0].Number)
                        {
                            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                "XMatchFD.DBLayer.DeleteSessionCore(" + seqNum.ToString("X8")
                                + "): titleId = " + (TitleId) dwTitleId
                                + ", Deadlock encountered - SqlException:(" + SqlExceptionToString(e) + ")");
                        }
                    }
                    else if (ConsiderExceptionAsConnectionFailure(e))
                    {
                        hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                        DBLayer.ReportFailure(strCxnServer, e.ToString());

                        throw new XRLException(
                            HResult.XONLINE_E_MATCH_SERVER_ERROR,
                            XEvent.Id.MATCH_COMM_DELETE,
                            "XMatchFD.DBLayer.DeleteSession(" + seqNum.ToString("X8")
                            + "): Failed to communicate with " + strCxnServer
                            + ".  titleId = " + (TitleId) dwTitleId, e);
                    }
                    else
                    {
                        throw new XRLException(
                                HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                XEvent.Id.MATCH_CODE_8,
                                "XMatchFD.DBLayer.DeleteSession(" + seqNum.ToString("X8")
                                + "): titleId = " + (TitleId) dwTitleId, e);
                    }
                }
            } // end retry loop
        }
        finally
        {
            // TODOTHEOM: is there any cleanup we need to do?
        }
        return hr;
    }


    // ----------------------------------------------------------------------
    // DeleteSessionForBucket
    // Deals with deleting a sessino across the 2 servers of a bucket.
    // Goes to "next" first, then "current".  Stops when the delete succeeds,
    // fails if it doesn't succeed on either.
    // ----------------------------------------------------------------------
    private static void DeleteSessionForBucket(IBucketServer ibsDelete,
                                        BreadcrumbState bcs,
                                        uint dwTitleId,
                                        ulong qwSessionId,
                                        string strNoDeleteFromThisServer,
                                        TitleInfo ti,
                                        bool fForceImmediateDelete,
                                        bool fIsLegacyXboxTitle,
                                        ref uint dwSWBucket,
                                        ref string strDeletedFromServer,
                                        uint seqNum)
    {
        SqlConnection cxnDelete = null;
        try
        {
            HResult hrNext = HResult.S_FALSE;
            HResult hrCurr = HResult.S_FALSE;
            uint dwSWBucketCurrentServer = UInt32.MaxValue; //TODOTHEOM: INVALID_BUCKET
            string strActiveServer = null ;
            strDeletedFromServer = "";
            strActiveServer = GetActiveServer(ibsDelete);
            cxnDelete = OpenSqlConnectionToMatchDB(strActiveServer);
            if (String.Compare(strActiveServer, strNoDeleteFromThisServer, true) == 0)
            {
                hrNext = HResult.S_OK;
            }
            else
            {
                hrNext = DeleteSessionCore(cxnDelete,
                                        bcs,
                                        dwTitleId,
                                        qwSessionId,
                                        ti,
                                        fForceImmediateDelete,
                                        fIsLegacyXboxTitle,
                                        strActiveServer,
                                        ref dwSWBucket,
                                        seqNum);
                strDeletedFromServer = hrNext == HResult.S_OK ? strActiveServer : "";
            }

            if (FBucketInMigration(ibsDelete))
            {
                cxnDelete.Close();
                cxnDelete = OpenSqlConnectionToMatchDB(ibsDelete.CurrentServerName);

                if (String.Compare(ibsDelete.CurrentServerName, strNoDeleteFromThisServer, true) == 0)
                {
                    hrCurr = HResult.S_OK;
                }
                else
                {
                    hrCurr = DeleteSessionCore(cxnDelete,
                                        bcs,
                                        dwTitleId,
                                        qwSessionId,
                                        ti,
                                        fForceImmediateDelete,
                                        fIsLegacyXboxTitle,
                                        ibsDelete.CurrentServerName,
                                        ref dwSWBucketCurrentServer,
                                        seqNum);
                    strDeletedFromServer = hrCurr == HResult.S_OK ? ibsDelete.CurrentServerName :  "";
                 }
            }

            // XONLINE:103831 -- take the SW bucket from the current server's deleted
            // row, but only if we don't already have one from the next server.
            if(dwSWBucketCurrentServer != UInt32.MaxValue
                && dwSWBucket == UInt32.MaxValue)
            {
                dwSWBucket = dwSWBucketCurrentServer;
            }

            if (hrNext == HResult.S_FALSE && hrCurr == HResult.S_FALSE)
            {
                // throw an exception since we didn't find the row to delete
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MATCH_INVALID_SESSION_ID,
                     "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                     + "): Session not found.\n"
                     + " SessionID=0x" + qwSessionId.ToString("X16"));
            }
        }
        catch (SqlException e) // translate SQL exceptions to XRLExceptions, which will be caught later.
        {
            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                + "): titleId = " + (TitleId) dwTitleId
                + ", SqlException(" + SqlExceptionToString(e) + ")");

            if (ConsiderExceptionAsConnectionFailure(e))
            {
                DBLayer.ReportFailure(e.Server, e.ToString());

                throw new XRLException(
                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                    XEvent.Id.MATCH_COMM_UPDATE,
                    "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                    + "): Failed to communicate with " + e.Server
                    + ".  titleId = " + (TitleId) dwTitleId, e);
            }

            switch (e.Errors[0].Number)
            {
                case SQLDefs.ERROR_INVALID_PARAM_NAME:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID,
                        XEvent.Id.MATCH_TITLEBUG_5,
                        "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                        + "): Invalid attribute id."
                        + " titleId = " + (TitleId) dwTitleId, e);

                case SQLDefs.ERROR_DATA_TRUNCATED:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_OVERFLOW,
                        XEvent.Id.MATCH_TITLEBUG_6,
                        "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                        + "): String or binary attribute too large."
                        + " titleId = " + (TitleId) dwTitleId, e);

                case SQLDefs.ERROR_PARAM_MISSING:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                        XEvent.Id.MATCH_TITLEBUG_7,
                        "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                        + "): Missing required session attribute."
                        + " titleId = " + (TitleId) dwTitleId, e);

                default:
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                        XEvent.Id.MATCH_CODE_5,
                        "XMatchFD.DBLayer.DeleteSessionForBucket(" + seqNum.ToString("X8")
                        + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                        + " titleId = " + (TitleId) dwTitleId, e);
            }
        }
        finally
        {
            if(cxnDelete != null)
            {
                cxnDelete.Close();
            }
        }


    }

    // ----------------------------------------------------------------------
    // DeleteSessionLog - Logs the results of an delete session call to the
    // application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void DeleteSessionLog(
        ulong qwSessionId,
        uint dwTitleId,
        MatchXrl matchXrl,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        if (matchXrl == MatchXrl.xmatchhostdelete_srf)
        {
            sb.Append("MatchDeleteXbox|");
        }
        else
        {
            sb.Append("MatchDeleteXbox360|");
        }
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(qwSessionId.ToString("X16"));

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }


    // ----------------------------------------------------------------------
    // DeleteSessionPerfCountersStart - updates perf counters at the start
    // of a delete session operation
    // ----------------------------------------------------------------------
    private static void DeleteSessionPerfCountersStart(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType)
    {
        MatchDeleteCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchDeleteCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchhostdelete_srf)
        {
            MatchDeleteCounters.Counters.RequestsInProgressXboxDelete.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxDelete.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchhostdelete2_ashx)
        {
            MatchDeleteCounters.Counters.RequestsInProgressXbox360Delete.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Delete.Increment();
            }
            if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
            {
                MatchDeleteCounters.Counters.RequestsInProgressXbox360DeleteRanked.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360DeleteRanked.Increment();
                }
            }
            else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
            {
                MatchDeleteCounters.Counters.RequestsInProgressXbox360DeleteStandard.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360DeleteStandard.Increment();
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // DeleteSessionPerfCountersEnd - updates perf counters at the end
    // of an insert session operation
    // ----------------------------------------------------------------------
    private static void DeleteSessionPerfCountersEnd(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType,
        XomRequestTimeElapsed xrteRequestTime,
        HResult hr)
    {
        MatchDeleteCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchDeleteCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchhostdelete_srf)
        {
            MatchDeleteCounters.Counters.RequestsInProgressXboxDelete.Decrement();
            MatchDeleteCounters.Counters.TotalRequestsXboxDelete.Increment();
            MatchDeleteCounters.Counters.RequestsPerSecXboxDelete.Increment();
            MatchDeleteCounters.Counters.AverageExecutionTimeXboxDelete.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchDeleteCounters.Counters.AverageExecutionTimeBaseXboxDelete.Increment();
            if(HResult.Failed(hr))
            {
                MatchDeleteCounters.Counters.TotalRequestsXboxDeleteFailed.Increment();
                MatchDeleteCounters.Counters.RequestsPerSecXboxDeleteFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxDelete.Decrement();
                titleIdCounters.TotalRequestsXboxDelete.Increment();
                titleIdCounters.RequestsPerSecXboxDelete.Increment();
                titleIdCounters.AverageExecutionTimeXboxDelete.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXboxDelete.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXboxDeleteFailed.Increment();
                    titleIdCounters.RequestsPerSecXboxDeleteFailed.Increment();
                }
            }
        }
        else if (matchXrl == MatchXrl.xmatchhostdelete2_ashx)
        {
            MatchDeleteCounters.Counters.RequestsInProgressXbox360Delete.Decrement();
            MatchDeleteCounters.Counters.TotalRequestsXbox360Delete.Increment();
            MatchDeleteCounters.Counters.RequestsPerSecXbox360Delete.Increment();
            MatchDeleteCounters.Counters.AverageExecutionTimeXbox360Delete.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchDeleteCounters.Counters.AverageExecutionTimeBaseXbox360Delete.Increment();
            if(HResult.Failed(hr))
            {
                MatchDeleteCounters.Counters.TotalRequestsXbox360DeleteFailed.Increment();
                MatchDeleteCounters.Counters.RequestsPerSecXbox360DeleteFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Delete.Decrement();
                titleIdCounters.TotalRequestsXbox360Delete.Increment();
                titleIdCounters.RequestsPerSecXbox360Delete.Increment();
                titleIdCounters.AverageExecutionTimeXbox360Delete.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXbox360Delete.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXbox360DeleteFailed.Increment();
                    titleIdCounters.RequestsPerSecXbox360DeleteFailed.Increment();
                }
            }
            if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
            {
                MatchDeleteCounters.Counters.RequestsInProgressXbox360DeleteRanked.Decrement();
                MatchDeleteCounters.Counters.TotalRequestsXbox360DeleteRanked.Increment();
                MatchDeleteCounters.Counters.RequestsPerSecXbox360DeleteRanked.Increment();
                MatchDeleteCounters.Counters.AverageExecutionTimeXbox360DeleteRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchDeleteCounters.Counters.AverageExecutionTimeBaseXbox360DeleteRanked.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360DeleteRanked.Decrement();
                    titleIdCounters.TotalRequestsXbox360DeleteRanked.Increment();
                    titleIdCounters.RequestsPerSecXbox360DeleteRanked.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360DeleteRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360DeleteRanked.Increment();
                }
            }
            else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
            {
                MatchDeleteCounters.Counters.RequestsInProgressXbox360DeleteStandard.Decrement();
                MatchDeleteCounters.Counters.TotalRequestsXbox360DeleteStandard.Increment();
                MatchDeleteCounters.Counters.RequestsPerSecXbox360DeleteStandard.Increment();
                MatchDeleteCounters.Counters.AverageExecutionTimeXbox360DeleteStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchDeleteCounters.Counters.AverageExecutionTimeBaseXbox360DeleteStandard.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360DeleteStandard.Decrement();
                    titleIdCounters.TotalRequestsXbox360DeleteStandard.Increment();
                    titleIdCounters.RequestsPerSecXbox360DeleteStandard.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360DeleteStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360DeleteStandard.Increment();
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // FindSession - search for a session
    // ----------------------------------------------------------------------
    public static HResult FindSession(
        byte bNatType,
        string emulatorUrl,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        MatchAttributeWeighted[] rgWeightedAttributes,
        MatchXrl matchXrl,
        bool fWeighted,
        out SearchResult[] rgResults,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        rgResults = null;
        HResult hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;

        ulong gameType = GetGameType(rgAttributes);
        SearchSessionPerfCountersStart(matchXrl, dwTitleId, dwProcedureIndex, gameType, fWeighted);

        try
        {
            TitleInfo ti = GetTitleInfo(dwTitleId, seqNum);
            if (matchXrl == MatchXrl.xmatchclient_srf && !ti.ForceXenonBehavior)
            {
                hr = FindSessionXbox(bNatType, dwTitleId, dwProcedureIndex, ClientAddress, wNumUsers,
                    rgAttributes, out rgResults, seqNum);
            }
            else
            {
                hr = FindSessionXenon(bNatType, emulatorUrl, dwTitleId, dwProcedureIndex, ClientAddress, wNumUsers,
                    rgAttributes, rgWeightedAttributes, fWeighted, out rgResults, seqNum);
            }
        }
        finally
        {
            SearchSessionPerfCountersEnd(matchXrl, dwTitleId, dwProcedureIndex, gameType, fWeighted, xrteRequestTime, hr);
            SearchResultsPerfCounters(matchXrl, dwTitleId, gameType, fWeighted, rgResults == null ? 0 : rgResults.Length);
        }

        return hr;
    }

    // ----------------------------------------------------------------------
    // SearchSessionPerfCountersStart - updates perf counters at the start
    // of a search operation
    // ----------------------------------------------------------------------
    private static void SearchSessionPerfCountersStart(
        MatchXrl matchXrl,
        uint dwTitleId,
        uint dwProcedureIndex,
        ulong gameType,
        bool fWeighted)
    {
        MatchSearchCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSearchCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchclient_srf)
        {
            MatchSearchCounters.Counters.RequestsInProgressXboxSearch.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxSearch.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchclient2_ashx)
        {
            MatchSearchCounters.Counters.RequestsInProgressXbox360Search.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Search.Increment();
            }

            if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION)
            {
                MatchSearchCounters.Counters.RequestsInProgressXbox360SearchFindById.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360SearchFindById.Increment();
                }
            }
            else if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION_LIST)
            {
                MatchSearchCounters.Counters.RequestsInProgressXbox360SearchFindByIds.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360SearchFindByIds.Increment();
                }
            }
            else if (fWeighted) // it's a weighted search, could be ranked or standard
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360WeightedSearchRanked.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360WeightedSearchRanked.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360WeightedSearchStandard.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360WeightedSearchStandard.Increment();
                    }
                }
            }
            else // not a findbyid, findbyids and not a weighted search, so must be a "regular" search, ranked or standard.
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360SearchRanked.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360SearchRanked.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360SearchStandard.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360SearchStandard.Increment();
                    }
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // SearchSessionPerfCountersEnd - updates perf counters at the end
    // of search operation
    // ----------------------------------------------------------------------
    private static void SearchSessionPerfCountersEnd(
        MatchXrl matchXrl,
        uint dwTitleId,
        uint dwProcedureIndex,
        ulong gameType,
        bool fWeighted,
        XomRequestTimeElapsed xrteRequestTime,
        HResult hr)
    {
        MatchSearchCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSearchCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchclient_srf)
        {
            MatchSearchCounters.Counters.RequestsInProgressXboxSearch.Decrement();
            MatchSearchCounters.Counters.TotalRequestsXboxSearch.Increment();
            MatchSearchCounters.Counters.RequestsPerSecXboxSearch.Increment();
            MatchSearchCounters.Counters.AverageExecutionTimeXboxSearch.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchSearchCounters.Counters.AverageExecutionTimeBaseXboxSearch.Increment();
            if(HResult.Failed(hr))
            {
                MatchSearchCounters.Counters.TotalRequestsXboxSearchFailed.Increment();
                MatchSearchCounters.Counters.RequestsPerSecXboxSearchFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXboxSearch.Decrement();
                titleIdCounters.TotalRequestsXboxSearch.Increment();
                titleIdCounters.RequestsPerSecXboxSearch.Increment();
                titleIdCounters.AverageExecutionTimeXboxSearch.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXboxSearch.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXboxSearchFailed.Increment();
                    titleIdCounters.RequestsPerSecXboxSearchFailed.Increment();
                }
            }
        }
        else if (matchXrl == MatchXrl.xmatchclient2_ashx)
        {
            MatchSearchCounters.Counters.RequestsInProgressXbox360Search.Decrement();
            MatchSearchCounters.Counters.TotalRequestsXbox360Search.Increment();
            MatchSearchCounters.Counters.RequestsPerSecXbox360Search.Increment();
            MatchSearchCounters.Counters.AverageExecutionTimeXbox360Search.IncrementBy(xrteRequestTime.TimeElapsed);
            MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360Search.Increment();
            if(HResult.Failed(hr))
            {
                MatchSearchCounters.Counters.TotalRequestsXbox360SearchFailed.Increment();
                MatchSearchCounters.Counters.RequestsPerSecXbox360SearchFailed.Increment();
            }
            if (titleIdCounters != null)
            {
                titleIdCounters.RequestsInProgressXbox360Search.Decrement();
                titleIdCounters.TotalRequestsXbox360Search.Increment();
                titleIdCounters.RequestsPerSecXbox360Search.Increment();
                titleIdCounters.AverageExecutionTimeXbox360Search.IncrementBy(xrteRequestTime.TimeElapsed);
                titleIdCounters.AverageExecutionTimeBaseXbox360Search.Increment();
                if(HResult.Failed(hr))
                {
                    titleIdCounters.TotalRequestsXbox360SearchFailed.Increment();
                    titleIdCounters.RequestsPerSecXbox360SearchFailed.Increment();
                }
            }

            if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION)
            {
                MatchSearchCounters.Counters.RequestsInProgressXbox360SearchFindById.Decrement();
                MatchSearchCounters.Counters.TotalRequestsXbox360SearchFindById.Increment();
                MatchSearchCounters.Counters.RequestsPerSecXbox360SearchFindById.Increment();
                MatchSearchCounters.Counters.AverageExecutionTimeXbox360SearchFindById.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360SearchFindById.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360SearchFindById.Decrement();
                    titleIdCounters.TotalRequestsXbox360SearchFindById.Increment();
                    titleIdCounters.RequestsPerSecXbox360SearchFindById.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360SearchFindById.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360SearchFindById.Increment();
                }
            }
            else if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION_LIST)
            {
                MatchSearchCounters.Counters.RequestsInProgressXbox360SearchFindByIds.Decrement();
                MatchSearchCounters.Counters.TotalRequestsXbox360SearchFindByIds.Increment();
                MatchSearchCounters.Counters.RequestsPerSecXbox360SearchFindByIds.Increment();
                MatchSearchCounters.Counters.AverageExecutionTimeXbox360SearchFindByIds.IncrementBy(xrteRequestTime.TimeElapsed);
                MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360SearchFindByIds.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.RequestsInProgressXbox360SearchFindByIds.Decrement();
                    titleIdCounters.TotalRequestsXbox360SearchFindByIds.Increment();
                    titleIdCounters.RequestsPerSecXbox360SearchFindByIds.Increment();
                    titleIdCounters.AverageExecutionTimeXbox360SearchFindByIds.IncrementBy(xrteRequestTime.TimeElapsed);
                    titleIdCounters.AverageExecutionTimeBaseXbox360SearchFindByIds.Increment();
                }
            }
            else if (fWeighted) // it was a weighted search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360WeightedSearchRanked.Decrement();
                    MatchSearchCounters.Counters.TotalRequestsXbox360WeightedSearchRanked.Increment();
                    MatchSearchCounters.Counters.RequestsPerSecXbox360WeightedSearchRanked.Increment();
                    MatchSearchCounters.Counters.AverageExecutionTimeXbox360WeightedSearchRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                    MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360WeightedSearchRanked.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360WeightedSearchRanked.Decrement();
                        titleIdCounters.TotalRequestsXbox360WeightedSearchRanked.Increment();
                        titleIdCounters.RequestsPerSecXbox360WeightedSearchRanked.Increment();
                        titleIdCounters.AverageExecutionTimeXbox360WeightedSearchRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                        titleIdCounters.AverageExecutionTimeBaseXbox360WeightedSearchRanked.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360WeightedSearchStandard.Decrement();
                    MatchSearchCounters.Counters.TotalRequestsXbox360WeightedSearchStandard.Increment();
                    MatchSearchCounters.Counters.RequestsPerSecXbox360WeightedSearchStandard.Increment();
                    MatchSearchCounters.Counters.AverageExecutionTimeXbox360WeightedSearchStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                    MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360WeightedSearchStandard.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360WeightedSearchStandard.Decrement();
                        titleIdCounters.TotalRequestsXbox360WeightedSearchStandard.Increment();
                        titleIdCounters.RequestsPerSecXbox360WeightedSearchStandard.Increment();
                        titleIdCounters.AverageExecutionTimeXbox360WeightedSearchStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                        titleIdCounters.AverageExecutionTimeBaseXbox360WeightedSearchStandard.Increment();
                    }
                }
            }
            else // not a findbyid, findbyids and not a weighted search, so must be a "regular" search, ranked or standard.
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360SearchRanked.Decrement();
                    MatchSearchCounters.Counters.TotalRequestsXbox360SearchRanked.Increment();
                    MatchSearchCounters.Counters.RequestsPerSecXbox360SearchRanked.Increment();
                    MatchSearchCounters.Counters.AverageExecutionTimeXbox360SearchRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                    MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360SearchRanked.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360SearchRanked.Decrement();
                        titleIdCounters.TotalRequestsXbox360SearchRanked.Increment();
                        titleIdCounters.RequestsPerSecXbox360SearchRanked.Increment();
                        titleIdCounters.AverageExecutionTimeXbox360SearchRanked.IncrementBy(xrteRequestTime.TimeElapsed);
                        titleIdCounters.AverageExecutionTimeBaseXbox360SearchRanked.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchCounters.Counters.RequestsInProgressXbox360SearchStandard.Decrement();
                    MatchSearchCounters.Counters.TotalRequestsXbox360SearchStandard.Increment();
                    MatchSearchCounters.Counters.RequestsPerSecXbox360SearchStandard.Increment();
                    MatchSearchCounters.Counters.AverageExecutionTimeXbox360SearchStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                    MatchSearchCounters.Counters.AverageExecutionTimeBaseXbox360SearchStandard.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.RequestsInProgressXbox360SearchStandard.Decrement();
                        titleIdCounters.TotalRequestsXbox360SearchStandard.Increment();
                        titleIdCounters.RequestsPerSecXbox360SearchStandard.Increment();
                        titleIdCounters.AverageExecutionTimeXbox360SearchStandard.IncrementBy(xrteRequestTime.TimeElapsed);
                        titleIdCounters.AverageExecutionTimeBaseXbox360SearchStandard.Increment();
                    }
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // SearchByIdsPerfCountersUpdate - updates perf counters related to
    // SessionSearchByIds to track statistics about how many IDs were requested
    // ----------------------------------------------------------------------
    private static void SearchByIdsPerfCountersUpdate(uint dwTitleId, int numIdsRequested)
    {
        MatchSearchCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSearchCounters.Counters[dwTitleId];
        }

        // Track the number of IDs being requested.  This is mainly useful for tracking min/max values
        MatchSearchCounters.Counters.IdsPerRequestXbox360SearchFindByIds.RawValue = numIdsRequested;

        // Track the average number of IDs being requested.
        MatchSearchCounters.Counters.AverageIdsPerRequestXbox360SearchFindByIds.IncrementBy(numIdsRequested);
        MatchSearchCounters.Counters.AverageIdsPerRequestBaseXbox360SearchFindByIds.Increment();

        if (titleIdCounters != null)
        {
            titleIdCounters.IdsPerRequestXbox360SearchFindByIds.RawValue = numIdsRequested;
            titleIdCounters.AverageIdsPerRequestXbox360SearchFindByIds.IncrementBy(numIdsRequested);
            titleIdCounters.AverageIdsPerRequestBaseXbox360SearchFindByIds.Increment();
        }
    }


    // ----------------------------------------------------------------------
    // SearchResultsPerfCounters - updates search result perf counters at the end
    // of an search operation
    // ----------------------------------------------------------------------
    private static void SearchResultsPerfCounters(
        MatchXrl matchXrl,
        uint dwTitleId,
        ulong gameType,
        bool fWeighted,
        int numResults)
    {
        MatchResultCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchResultCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchclient_srf)
        {
            MatchResultCounters.Counters.TotalResultsXboxSearch.IncrementBy(numResults);
            MatchResultCounters.Counters.ResultsPerSecXboxSearch.IncrementBy(numResults);
            MatchResultCounters.Counters.AverageResultsXboxSearch.IncrementBy(numResults);
            MatchResultCounters.Counters.AverageResultsXboxSearchBase.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalResultsXboxSearch.IncrementBy(numResults);
                titleIdCounters.ResultsPerSecXboxSearch.IncrementBy(numResults);
                titleIdCounters.AverageResultsXboxSearch.IncrementBy(numResults);
                titleIdCounters.AverageResultsXboxSearchBase.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchclient2_ashx)
        {
            MatchResultCounters.Counters.TotalResultsXbox360Search.IncrementBy(numResults);
            MatchResultCounters.Counters.ResultsPerSecXbox360Search.IncrementBy(numResults);
            MatchResultCounters.Counters.AverageResultsXbox360Search.IncrementBy(numResults);
            MatchResultCounters.Counters.AverageResultsXbox360SearchBase.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalResultsXbox360Search.IncrementBy(numResults);
                titleIdCounters.ResultsPerSecXbox360Search.IncrementBy(numResults);
                titleIdCounters.AverageResultsXbox360Search.IncrementBy(numResults);
                titleIdCounters.AverageResultsXbox360SearchBase.Increment();
            }
            if (fWeighted) // weighted xenon search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchResultCounters.Counters.TotalResultsXbox360WeightedRankedSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.ResultsPerSecXbox360WeightedRankedSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360WeightedRankedSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360WeightedRankedSearchBase.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalResultsXbox360WeightedRankedSearch.IncrementBy(numResults);
                        titleIdCounters.ResultsPerSecXbox360WeightedRankedSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360WeightedRankedSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360WeightedRankedSearchBase.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchResultCounters.Counters.TotalResultsXbox360WeightedStandardSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.ResultsPerSecXbox360WeightedStandardSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360WeightedStandardSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360WeightedStandardSearchBase.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalResultsXbox360WeightedStandardSearch.IncrementBy(numResults);
                        titleIdCounters.ResultsPerSecXbox360WeightedStandardSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360WeightedStandardSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360WeightedStandardSearchBase.Increment();
                    }
                }
            }
            else // "regular" xenon search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchResultCounters.Counters.TotalResultsXbox360RankedSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.ResultsPerSecXbox360RankedSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360RankedSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360RankedSearchBase.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalResultsXbox360RankedSearch.IncrementBy(numResults);
                        titleIdCounters.ResultsPerSecXbox360RankedSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360RankedSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360RankedSearchBase.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchResultCounters.Counters.TotalResultsXbox360StandardSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.ResultsPerSecXbox360StandardSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360StandardSearch.IncrementBy(numResults);
                    MatchResultCounters.Counters.AverageResultsXbox360StandardSearchBase.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalResultsXbox360StandardSearch.IncrementBy(numResults);
                        titleIdCounters.ResultsPerSecXbox360StandardSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360StandardSearch.IncrementBy(numResults);
                        titleIdCounters.AverageResultsXbox360StandardSearchBase.Increment();
                    }
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // SearchSessionRetryPerfCounters - updates the search retry perf counters
    // ----------------------------------------------------------------------
    private static void SearchSessionRetryPerfCounters(
        MatchXrl matchXrl,
        uint dwTitleId,
        uint dwProcedureIndex,
        ulong gameType,
        bool fWeighted)
    {
        MatchSearchRetryCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSearchRetryCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchclient_srf)
        {
            MatchSearchRetryCounters.Counters.TotalXboxSearchRetries.Increment();
            MatchSearchRetryCounters.Counters.PerSecXboxSearchRetries.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXboxSearchRetries.Increment();
                titleIdCounters.PerSecXboxSearchRetries.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchclient2_ashx)
        {
            MatchSearchRetryCounters.Counters.TotalXbox360SearchRetries.Increment();
            MatchSearchRetryCounters.Counters.PerSecXbox360SearchRetries.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXbox360SearchRetries.Increment();
                titleIdCounters.PerSecXbox360SearchRetries.Increment();
            }

            if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION)
            {
                MatchSearchRetryCounters.Counters.TotalXbox360SearchFindByIdRetries.Increment();
                MatchSearchRetryCounters.Counters.PerSecXbox360SearchFindByIdRetries.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.TotalXbox360SearchFindByIdRetries.Increment();
                    titleIdCounters.PerSecXbox360SearchFindByIdRetries.Increment();
                }
            }
            else if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION_LIST)
            {
                MatchSearchRetryCounters.Counters.TotalXbox360SearchFindByIdsRetries.Increment();
                MatchSearchRetryCounters.Counters.PerSecXbox360SearchFindByIdsRetries.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.TotalXbox360SearchFindByIdsRetries.Increment();
                    titleIdCounters.PerSecXbox360SearchFindByIdsRetries.Increment();
                }
            }
            else if (fWeighted) // xenon weighted search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360WeightedSearchRankedRetries.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360WeightedSearchRankedRetries.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360WeightedSearchRankedRetries.Increment();
                        titleIdCounters.PerSecXbox360WeightedSearchRankedRetries.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360WeightedSearchStandardRetries.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360WeightedSearchStandardRetries.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360WeightedSearchStandardRetries.Increment();
                        titleIdCounters.PerSecXbox360WeightedSearchStandardRetries.Increment();
                    }
                }   
            }
            else // xenon "regular" search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360SearchRankedRetries.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360SearchRankedRetries.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360SearchRankedRetries.Increment();
                        titleIdCounters.PerSecXbox360SearchRankedRetries.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360SearchStandardRetries.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360SearchStandardRetries.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360SearchStandardRetries.Increment();
                        titleIdCounters.PerSecXbox360SearchStandardRetries.Increment();
                    }
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // SearchSessionRetryFailurePerfCounters - updates the search retry failure perf counters
    // ----------------------------------------------------------------------
    private static void SearchSessionRetryFailurePerfCounters(
        MatchXrl matchXrl,
        uint dwTitleId,
        uint dwProcedureIndex,
        ulong gameType,
        bool fWeighted)
    {
        MatchSearchRetryCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSearchRetryCounters.Counters[dwTitleId];
        }

        if (matchXrl == MatchXrl.xmatchclient_srf)
        {
            MatchSearchRetryCounters.Counters.TotalXboxSearchRetryFailures.Increment();
            MatchSearchRetryCounters.Counters.PerSecXboxSearchRetryFailures.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXboxSearchRetryFailures.Increment();
                titleIdCounters.PerSecXboxSearchRetryFailures.Increment();
            }
        }
        else if (matchXrl == MatchXrl.xmatchclient2_ashx)
        {
            MatchSearchRetryCounters.Counters.TotalXbox360SearchRetryFailures.Increment();
            MatchSearchRetryCounters.Counters.PerSecXbox360SearchRetryFailures.Increment();
            if (titleIdCounters != null)
            {
                titleIdCounters.TotalXbox360SearchRetryFailures.Increment();
                titleIdCounters.PerSecXbox360SearchRetryFailures.Increment();
            }

            if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION)
            {
                MatchSearchRetryCounters.Counters.TotalXbox360SearchFindByIdRetryFailures.Increment();
                MatchSearchRetryCounters.Counters.PerSecXbox360SearchFindByIdRetryFailures.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.TotalXbox360SearchFindByIdRetryFailures.Increment();
                    titleIdCounters.PerSecXbox360SearchFindByIdRetryFailures.Increment();
                }
            }
            else if (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION_LIST)
            {
                MatchSearchRetryCounters.Counters.TotalXbox360SearchFindByIdsRetryFailures.Increment();
                MatchSearchRetryCounters.Counters.PerSecXbox360SearchFindByIdsRetryFailures.Increment();
                if (titleIdCounters != null)
                {
                    titleIdCounters.TotalXbox360SearchFindByIdsRetryFailures.Increment();
                    titleIdCounters.PerSecXbox360SearchFindByIdsRetryFailures.Increment();
                }
            }
            else if (fWeighted) // xenon weighted search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360WeightedSearchRankedRetryFailures.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360WeightedSearchRankedRetryFailures.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360WeightedSearchRankedRetryFailures.Increment();
                        titleIdCounters.PerSecXbox360WeightedSearchRankedRetryFailures.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360WeightedSearchStandardRetryFailures.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360WeightedSearchStandardRetryFailures.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360WeightedSearchStandardRetryFailures.Increment();
                        titleIdCounters.PerSecXbox360WeightedSearchStandardRetryFailures.Increment();
                    }
                }
            }
            else // xenon "regular" search
            {
                if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360SearchRankedRetryFailures.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360SearchRankedRetryFailures.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360SearchRankedRetryFailures.Increment();
                        titleIdCounters.PerSecXbox360SearchRankedRetryFailures.Increment();
                    }
                }
                else if (gameType == MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD)
                {
                    MatchSearchRetryCounters.Counters.TotalXbox360SearchStandardRetryFailures.Increment();
                    MatchSearchRetryCounters.Counters.PerSecXbox360SearchStandardRetryFailures.Increment();
                    if (titleIdCounters != null)
                    {
                        titleIdCounters.TotalXbox360SearchStandardRetryFailures.Increment();
                        titleIdCounters.PerSecXbox360SearchStandardRetryFailures.Increment();
                    }
                }
            }
        }
    }

    // ----------------------------------------------------------------------
    // FindSessionXbox - search for a session for an Xbox 1 title
    // ----------------------------------------------------------------------
    public static HResult FindSessionXbox(
        byte bNatType,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        out SearchResult[] rgResults,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        bool fIsLegacyXboxTitle = true;
        rgResults = null;
        HResult hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;

        // this is legacy xbox, so game type/mode are always the same
        byte bGameType = (byte)(MatchDefs.XMATCH_MAX_GAMETYPE + 1);
        byte bGameMode = (byte)(MatchDefs.XMATCH_MAX_GAMEMODE + 1);

        try
        {
            TitleInfo ti = GetTitleInfo(dwTitleId, seqNum);

            byte bRRID = 0;
            byte bRRCount = ti.GetRRCountForPartition(
                bGameType,
                bGameMode,
                seqNum);
            if (MatchDefs.IsSearchSystemFindByIdQuery(dwProcedureIndex))
            {
                // because this is the system FindById query, we know the first
                // and only parameter is the session id, which will tell us
                // what database the session record is on.
                if (rgAttributes.Length != 1)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                        XEvent.Id.MATCH_CODE_10,
                        "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                        + "): Incorrect number of parameters ("
                        + rgAttributes.Length.ToString()
                        + ")for system FindById query. titleId = " + (TitleId) dwTitleId);
                }
                ulong qwSessionId = rgAttributes[0].qwValue;
                bRRID = MatchDefs.XNetXnKidGetDatabaseIndex(qwSessionId);
            }
            else
            {
                // we spread the search requests evenly over the servers for this
                // title by cycling through the list of servers for this title.
                bRRID = ti.GetNextRRIndexForPartition(
                    bGameType,
                    bGameMode,
                    true,
                    seqNum);
            }

            // Xbox 1 matchsim allowed developers to specify custom
            // FindById queries in addition to the system FindById query
            // generated automatically. Unfortunately, for these
            // custom FindById queries, there's no way to tell with
            // the information we have at this point if the query
            // we're running is a normal query or a FindById query.
            // Therefore, we must be prepared to run the query
            // against all the match databases for this title.
            // Thus, we keep track of the database we queried
            // first, so we can tell when we've queried them all.
            byte bRRIDStart = bRRID;
            do
            {
                SqlConnection cxn = null;
                SqlCommand cmd = null;
                SqlDataReader reader = null;

                IBucketServer ibsServer = ti.GetBucketForPartitionAndRRID(
                                bGameType,
                                bGameMode,
                                bRRID,
                                seqNum);

                try
                {
                    cxn = OpenSqlConnectionToMatchDB(ibsServer.NextServerName);
                    cmd = CreateLegacySearchSqlCommand(dwTitleId, dwProcedureIndex, cxn);

                    MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                        "@retval", (uint)0);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@si_required_slots", wNumUsers);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@i_client_ip", ByteSwap(ClientAddress.inaOnline));
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@ti_nat_type", bNatType);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@ti_server_count", bRRCount);

                    AddParamAttributesToSqlCommand(rgAttributes, ti, dwTitleId,
                        dwProcedureIndex, cmd, fIsLegacyXboxTitle, seqNum);

                    // loop so we can retry the query in case of a NOLOCK
                    // scanning failure
                    int retries = 0;
                    while (true)
                    {
                        try
                        {
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                                + "): Using db=" + cxn.DataSource
                                + " to execute query=" + cmd.CommandText
                                + ". titleId = " + (TitleId) dwTitleId);

                            reader = cmd.ExecuteReader();

                            // We don't need to check for failed hr here, because
                            // and error will throw an XRLException. We keep track
                            // of it only in case there are different flavors of
                            // success.
                            uint maxResults; // unused for xbox titles
                            hr = ReadSearchResults(dwTitleId, dwProcedureIndex,
                                cmd, reader, fIsLegacyXboxTitle, out maxResults, out rgResults, seqNum);

                            // if we get here, the query worked, so break out of the loop
                            break;
                        }
                        catch (SqlException e)
                        {
                            if (ConsiderExceptionAsConnectionFailure(e))
                            {
                                hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                                DBLayer.ReportFailure(ibsServer.NextServerName, e.ToString());

                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                                    XEvent.Id.MATCH_COMM_EXECUTE_FIND_XBOX,
                                    "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                                    + "): Failed to communicate with " + ibsServer.NextServerName
                                    + ".  titleId = " + (TitleId) dwTitleId, e);
                            }

                            switch(e.Errors[0].Number)
                            {
                            case SQLDefs.ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK:
                                // every once in a while, we're going to have
                                // to retry a query because we use the NOLOCK
                                // hint to avoid deadlocks.
                                retries++;
                                if (retries < NolockRetries)
                                {
                                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                        "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                                        + "): NOLOCK scan error detected, retry = " + retries.ToString()
                                        + ". titleId = " + (TitleId) dwTitleId);
                                    reader.Close();
                                    SearchSessionRetryPerfCounters(MatchXrl.xmatchclient_srf,
                                        dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                    continue;
                                }

                                // if we've already retried as many times as we're allowed to
                                // then return empty search results, but update the retry
                                // failure perf counters so we'll be able to tell if this
                                // ever happens in practice.
                                Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                    "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                                    + "): too many NOLOCK scan errors detected, "
                                    + "returing empty search results, retry = " + retries.ToString()
                                    + ". titleId = " + (TitleId) dwTitleId);
                                SearchSessionRetryFailurePerfCounters(MatchXrl.xmatchclient_srf,
                                    dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                rgResults = new SearchResult[0];
                                break;

                            // Could not find stored procedure
                            // 'p_match_search_<title>_<proc>'.
                            case SQLDefs.ERROR_PARAM_MISSING:
                            case SQLDefs.ERROR_COULD_NOT_FIND_STORED_PROC:
                            case SQLDefs.ERROR_INVALID_PARAM_NAME:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ,
                                    XEvent.Id.MATCH_TITLEBUG_11,
                                    "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                                    + "): Invalid Search request."
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                            default:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                    XEvent.Id.MATCH_CODE_11,
                                    "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                                    + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);
                            }
                        }

                        // if we get here, we've given up on our retries, so break
                        // out of the loop.
                        break;
                    }
                }
                finally
                {
                    if(reader != null)
                    {
                        reader.Close();
                    }
                    if(cxn != null)
                    {
                        cxn.Close();
                    }
                }

                // If S_FALSE is returned then the query was a FindFromId query and
                // the session was not found on the last database we tried, so try
                // the next one.
                if(HResult.S_FALSE == hr)
                {
                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                        + "): FindFromID session not found on db=" + cxn.DataSource
                        + ", trying next database. titleId = " + (TitleId) dwTitleId
                        + ", queryid=" + dwProcedureIndex.ToString("X8"));

                    bRRID = (byte)((bRRID + 1) % bRRCount);
                    if(bRRID == bRRIDStart)
                    {
                        // We have tried every database, give up and return
                        // zero results
                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_ERROR,
                            "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8")
                            + "): FindFromID session not found on any database. "
                            + "titleId = " + (TitleId) dwTitleId
                            + ", queryid=" + dwProcedureIndex.ToString("X8"));
                        break;
                    }
                }
            } while(HResult.S_FALSE == hr);

            // Don't pass S_FALSE up to the caller, that's just for
            // this method's use while iterating over the databases
            // for a FindById query.
            if(HResult.S_FALSE == hr)
            {
                hr = HResult.S_OK;
            }
        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below

            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_12,
                "XMatchFD.DBLayer.FindSessionXbox(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            FindSessionXboxLog(bNatType, dwTitleId, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes.Length, rgResults == null ? 0 : rgResults.Length, xrteRequestTime,
                seqNum, hr);

        }
        return hr;
    }

    // ----------------------------------------------------------------------
    // FindSessionXboxLog - Logs the results of an delete session call to the
    // application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void FindSessionXboxLog(
        byte bNatType,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        int numAttributes,
        int numResults,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchSearchXbox|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(dwProcedureIndex.ToString()); sb.Append("|");
        sb.Append(bNatType.ToString()); sb.Append("|");
        sb.Append(wNumUsers.ToString()); sb.Append("|");
        sb.Append(numAttributes.ToString()); sb.Append("|");
        sb.Append(numResults.ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.ina).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.inaOnline).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.wPortOnline).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.qwXboxId).ToString("X16"));

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }

    // ----------------------------------------------------------------------
    // FindSessionXenon - search for a session for a Xenon title
    // ----------------------------------------------------------------------
    public static HResult FindSessionXenon(
        byte bNatType,
        string emulatorUrl,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        MatchAttributeWeighted[] rgWeightedAttributes,
        bool fWeighted,
        out SearchResult[] rgResults,
        uint seqNum)
    {
        rgResults = null;
        HResult hr;

        TitleInfo ti = GetTitleInfo(dwTitleId, seqNum);

        if (MatchDefs.IsSearchSystemFindByIdQuery(dwProcedureIndex))
        {
            hr = FindSessionByIdXenon(bNatType, dwTitleId, ti, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes, out rgResults, seqNum);
        }
        else if(fWeighted) // the new weighted search magic.  Trumps ranked vs. standard.  (both have same behavior in this case)
        {
            hr = FindSessionWeightedXenon(bNatType, dwTitleId, ti, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes, rgWeightedAttributes, out rgResults, seqNum);
        }
        else if (IsRankedQuery(rgAttributes))
        {
            hr = FindSessionRankedXenon(bNatType, dwTitleId, ti, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes, out rgResults, seqNum);
        }
        else
        {
            hr = FindSessionStandardXenon(bNatType, emulatorUrl, dwTitleId, ti, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes, out rgResults, seqNum);
        }

        return hr;
    }

    //------------------------------------------------------------------------------
    // Container for a query batch against a single partition
    //------------------------------------------------------------------------------
    class FindSessionQueryBatch
    {
        public uint             dwBucket;
        public MatchAttribute[] rgAttributes;
        public int              cSessionIds;

        public FindSessionQueryBatch()
        {
        }

        public FindSessionQueryBatch(uint dwBucket)
        {
            this.dwBucket = dwBucket;
        }
    }

    // ----------------------------------------------------------------------
    // FindSessionByIdXenon - performs a system FindById query for Xenon titles
    // ----------------------------------------------------------------------
    public static HResult FindSessionByIdXenon(
        byte bNatType,
        uint dwTitleId,
        TitleInfo ti,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        out SearchResult[] results,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        bool fIsLegacyXboxTitle = false;
        HResult hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
        ulong qwSessionId = 0;
        FindSessionQueryBatch []rgBatches = null;
        SearchResult[] previousResults = null;
        uint dwBucket = UInt32.MaxValue;

        results = null;

        try
        {
            switch(dwProcedureIndex)
            {
                case MatchDefs.X_SSINDEX_GET_SESSION:
                case MatchDefs.X_SSINDEX_GET_SESSION_ATTRIBUTES:

                    // Setup a single session ID query against a single partition
                    FindSessionByIdXenon_ValidateParams(
                            seqNum,
                            dwTitleId,
                            dwProcedureIndex,
                            MatchDefs.X_ATTRIBUTE_SESSION_ID,
                            rgAttributes);

                    qwSessionId = rgAttributes[0].qwValue;
                    rgBatches = new FindSessionQueryBatch[1];
                    dwBucket = dwBucketIDFromAttribs(MatchDefs.GetGameTypeFromSessionId(qwSessionId),
                                                    MatchDefs.GetGameModeFromSessionId(qwSessionId),
                                                    MatchDefs.XNetXnKidGetDatabaseIndex(qwSessionId));

                    rgBatches[0] = new FindSessionQueryBatch(dwBucket);
                    rgBatches[0].rgAttributes = rgAttributes;
                    rgBatches[0].cSessionIds = 1;

                    break;
                case MatchDefs.X_SSINDEX_GET_SESSION_LIST:

                    // Setup a multi session ID query against each partition
                    FindSessionByIdXenon_ValidateParams(
                            seqNum,
                            dwTitleId,
                            dwProcedureIndex,
                            MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST,
                            rgAttributes);
                    rgBatches = FindSessionByIdXenon_CreateBatchesFromList(seqNum, dwTitleId, ti, rgAttributes);
                    break;
            }

            foreach(FindSessionQueryBatch queryBatch in rgBatches)
            {
                SqlConnection cxn = null;
                SqlCommand cmd = null;
                SqlDataReader reader = null;
                rgAttributes = queryBatch.rgAttributes;

                try
                {
                    cmd = CreateFindByIdSearchSqlCommand(dwTitleId, dwProcedureIndex);

                    MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                            "@retval", (uint)0);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                            "@si_required_slots", wNumUsers);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                            "@i_client_ip", ByteSwap(ClientAddress.inaOnline));
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                            "@ti_nat_type", bNatType);
                    // TODOTHEOM: I believe that the dbcount param is unused.  Confirm and remove.
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                            "@ti_server_count", 0);

                    // Add a session count when querying the list procedure
                    if(MatchDefs.X_SSINDEX_GET_SESSION_LIST == dwProcedureIndex)
                    {
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                                "@i_session_id_count", queryBatch.cSessionIds);
                    }

                    AddParamAttributesToSqlCommand(rgAttributes, ti, dwTitleId,
                            dwProcedureIndex, cmd, fIsLegacyXboxTitle, seqNum);

                    IBucketServer ibsServer = Config.GetTitleBucketServer(Interface.xmatch, dwTitleId, queryBatch.dwBucket);
                    // loop over the (2) potential migrating servers for this bucket
                    string strServerName = GetActiveServer(ibsServer);
                    bool fBucketMigratingRequery = false;

                    do  // for Next and Current server of the bucket if it's in migration
                    {
                        cxn = OpenSqlConnectionToMatchDB(strServerName);
                        cmd.Connection = cxn;

                        // loop so we can retry the query in case of a NOLOCK
                        // scanning failure
                        int retries = 0;
                        while (true)
                        {
                            try
                            {
                                Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                        "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                        + "): Using db=" + cxn.DataSource
                                        + " to execute query=" + cmd.CommandText
                                        + ". titleId = " + (TitleId) dwTitleId);

                                reader = cmd.ExecuteReader();

                                // We don't need to check for failed hr here, because
                                // an error will throw an XRLException. We keep track
                                // of it only in case there are different flavors of
                                // success.
                                uint maxResults; // unused for FindById queries

                                // If this is not the first result set then save off the existing
                                // results so we can merge the new ones in after they are read.
                                if (null != results)
                                {
                                    previousResults = results;
                                    results = null;
                                }

                                hr = ReadSearchResults(dwTitleId, dwProcedureIndex,
                                        cmd, reader, fIsLegacyXboxTitle, out maxResults, out results, seqNum);

                                if (null != previousResults && null != results)
                                {
                                    results = MergeResults(previousResults, results);
                                    previousResults = null;
                                }

                                // if we get here, the query worked, so break out of the retry loop
                                break;
                            }
                            catch (SqlException e)
                            {
                                if (ConsiderExceptionAsConnectionFailure(e))
                                {
                                    hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                                    DBLayer.ReportFailure(e.Server, e.ToString());

                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_SERVER_ERROR,
                                        XEvent.Id.MATCH_COMM_EXECUTE_FINDBYID_XENON,
                                        "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                        + "): Failed to communicate with " + e.Server
                                        + ".  titleId = " + (TitleId) dwTitleId, e);
                                }

                                switch (e.Errors[0].Number)
                                {
                                    case SQLDefs.ERROR_DEADLOCKED_PROCESS_KILLED:
                                    case SQLDefs.ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK:
                                        // every once in a while, we're going to have
                                        // to retry a query because we use the NOLOCK
                                        // hint to avoid deadlocks.
                                        //
                                        // findbyid_get_attributes eschews (NOLOCK) for consistent reads
                                        // otherwise 0 results may return during an update. this may result
                                        // in deadlocks.
                                        retries++;
                                        if (retries < NolockRetries)
                                        {
                                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                                    "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                    + "): NOLOCK scan error detected, retry = " + retries.ToString()
                                                    + ". titleId = " + (TitleId) dwTitleId);
                                            reader.Close();
                                            SearchSessionRetryPerfCounters(MatchXrl.xmatchclient2_ashx,
                                                    dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                            continue;
                                        }

                                        // if we've already retried as many times as we're allowed to
                                        // then return empty search results, but update the retry
                                        // failure perf counters so we'll be able to tell if this
                                        // ever happens in practice.
                                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): too many NOLOCK scan errors detected, "
                                                + "returing empty search results, retry = " + retries.ToString()
                                                + ". titleId = " + (TitleId) dwTitleId);
                                        SearchSessionRetryFailurePerfCounters(MatchXrl.xmatchclient2_ashx,
                                                dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                        results = new SearchResult[0];
                                        break;
                                    case SQLDefs.ERROR_PARAM_MISSING:
                                        throw new XRLException(
                                                HResult.XONLINE_E_MATCH_PARAM_MISSING,
                                                XEvent.Id.MATCH_TITLEBUG_16,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): Required parameter missing."
                                                + " titleId = " + (TitleId) dwTitleId
                                                + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                    case SQLDefs.ERROR_COULD_NOT_FIND_STORED_PROC:
                                        throw new XRLException(
                                                HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ,
                                                XEvent.Id.MATCH_TITLEBUG_17,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): could not find stored proc."
                                                + " titleId = " + (TitleId) dwTitleId
                                                + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                    case SQLDefs.ERROR_TOO_MANY_PARAM:
                                        throw new XRLException(
                                                HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                                                XEvent.Id.MATCH_TITLEBUG_18,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): Required parameter missing."
                                                + " titleId = " + (TitleId) dwTitleId
                                                + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                    case SQLDefs.ERROR_INVALID_PARAM_NAME:
                                        throw new XRLException(
                                                HResult.XONLINE_E_MATCH_INVALID_PARAM,
                                                XEvent.Id.MATCH_TITLEBUG_19,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): Invalid parameter passed."
                                                + " titleId = " + (TitleId) dwTitleId
                                                + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                    case SQLDefs.ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES:
                                        throw new XRLException(
                                                HResult.XONLINE_E_MATCH_DUPLICATE_PARAM,
                                                XEvent.Id.MATCH_TITLEBUG_20,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): Duplicate parameter passed."
                                                + " titleId = " + (TitleId) dwTitleId
                                                + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                    default:
                                        throw new XRLException(
                                                HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                                XEvent.Id.MATCH_CODE_13,
                                                "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8")
                                                + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                                                + " titleId = " + (TitleId) dwTitleId
                                                + ", queryid=" + dwProcedureIndex.ToString("X8"), e);
                                }
                            }

                            // if we get here, we've given up on our retries, so break
                            // out of the retry loop.
                            break;
                        } // End retry loop

                        // requery if the bucket is in migration, and we haven't already requeried
                        // bug 101296: for the brief moment during a migration when there are two copies of the same
                        // session (on the "current" and "next" servers of the migration) we need to stop querying when
                        // we find the first one.
                        // TODO: the long term fix may be to always merge the result sets from the "current"
                        // and "next" servers of the migrating pair.  But that's unnecessary if GET_SESSION_LIST
                        // is never used.  Maybe remove the GET_SESSION_LIST code altogether?
                        fBucketMigratingRequery = FBucketInMigration(ibsServer) && // bucket's in migration
                                                !fBucketMigratingRequery &&                         // and we haven't already retried
                                                (dwProcedureIndex == MatchDefs.X_SSINDEX_GET_SESSION_LIST || // and (we're getting a list of sessions (rarely if ever used)
                                                results == null || results.Length == 0);                                                 // OR we don't already have a result for a single session query.)
                        strServerName = ibsServer.CurrentServerName;
                        if (reader != null)
                        {
                            reader.Close();
                        }
                        if (cxn != null)
                        {
                            cxn.Close();
                        }
                    }
                    while (fBucketMigratingRequery);  // end loop over server for a bucket that's in migration
                }
                finally
                {
                    if(reader != null)
                    {
                        reader.Close();
                    }
                    if(cxn != null)
                    {
                        cxn.Close();
                    }
                }
            } // End query batch loop
        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value 

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId))
            {
                throw;
            }
            else
            {
                // Something unexpected has happened. Rethrow an XRLException
                // so we get proper eventing, and set the hr so it is logged
                // properly below
                throw new XRLException(
                    hr,
                    XEvent.Id.MATCH_CODE_14,
                    "XMatchFD.DBLayer.FindSessionByIdXenon(" + seqNum.ToString("X8") + "): "
                    + "Unexpected exception was thrown. Details should follow.", e);
            }
        }
        finally
        {
            FindSessionByIdLog(
                    bNatType,
                    dwTitleId,
                    dwProcedureIndex,
                    qwSessionId,
                    ClientAddress,
                    wNumUsers,
                    rgAttributes,
                    results == null ? 0 : results.Length,
                    xrteRequestTime,
                    seqNum,
                    hr);
        }

        return hr;
    }

    private static void FindSessionByIdXenon_ValidateParams(
            uint seqNum,
            uint dwTitleId,
            uint dwProcedureIndex,
            uint dwQueryAttributeId,
            MatchAttribute []rgAttributes)
    {
        // because this is the system FindById query, we know the first
        // and only parameter is the session id, which will tell us
        // what database the session record is on.
        if (rgAttributes.Length < 1)
        {
            string msg = String.Format("XMatchFD.DBLayer.FindSessionByIdXenon_ValidateParams(0x{0:X8}): " +
                    "): Less than one parameter, Count: {1}, ProcedureIndex: 0x{2:X8}, Title: 0x{3:X8}",
                    seqNum,
                    rgAttributes.Length,
                    dwProcedureIndex,
                    dwTitleId);
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_PARAM_MISSING,
                    XEvent.Id.MATCH_TITLEBUG_12,
                    msg);
        }
        else if (1 == rgAttributes.Length)
        {
            if (rgAttributes[0].dwAttributeId != dwQueryAttributeId)
            {
                string msg = String.Format(@"XMatchFD.DBLayer.FindSessionByIdXenon_ValidateParams(0x{0:X8}): " +
                        "): Invalid attribute ID: 0x{1:X8}, ProcedureIndex: 0x{2:X8}, Title: 0x{3:X8}",
                        seqNum,
                        rgAttributes[0].dwAttributeId,
                        dwProcedureIndex,
                        dwTitleId);
                throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID,
                        XEvent.Id.MATCH_TITLEBUG_14,
                        msg);
            }
        }
        else if(3 == rgAttributes.Length)
        {
            if (        (null == MatchFdUtil.LookupAttribute(rgAttributes, dwQueryAttributeId))
                    ||  (null == MatchFdUtil.LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE))
                    ||  (null == MatchFdUtil.LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)))
            {
                string msg = String.Format(@"XMatchFD.DBLayer.FindSessionByIdXenon_ValidateParams(0x{0:X8}): " +
                        "): Invalid attribute ID(s): (0x{1:X8}, 0x{2:X8}, 0x{3:X8}), ProcedureIndex: 0x{4:X8}, Title: 0x{5:X8}",
                        seqNum,
                        rgAttributes[0].dwAttributeId,
                        rgAttributes[1].dwAttributeId,
                        rgAttributes[2].dwAttributeId,
                        dwProcedureIndex,
                        dwTitleId);
                throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID,
                        XEvent.Id.MATCH_TITLEBUG_14,
                        msg);
            }
        }
        else
        {
            string msg = String.Format(@"XMatchFD.DBLayer.FindSessionByIdXenon_ValidateParams(0x{0:X8}): " +
                    "): More than three parameters, Count: {1}, ProcedureIndex: 0x{2:X8}, Title: 0x{3:X8}",
                    seqNum,
                    rgAttributes.Length,
                    dwProcedureIndex,
                    dwTitleId);
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                    XEvent.Id.MATCH_TITLEBUG_13,
                    msg);
        }
    }

    private static FindSessionQueryBatch []FindSessionByIdXenon_CreateBatchesFromList(
            uint seqNum,
            uint dwTitleId,
            TitleInfo ti,
            MatchAttribute[] rgAttributes)
    {
        MatchAttribute sessionListAttr = MatchFdUtil.LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST);

        // Session blob list should be non-zero and a multiple of 8 bytes. The underlying conversion routine
        // will catch it in a generic argument exception but this provides a meaningful HRESULT to
        // the title
        if(null == sessionListAttr.rgbValue || 0 == sessionListAttr.rgbValue.Length || (0 != (sessionListAttr.rgbValue.Length & 0x3)))
        {
            throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_PARAM,
                    XEvent.Id.MATCH_TITLEBUG_FINDBYIDS_INVALID_BLOB_PARAM,
                    "XMatchFD.DBLayer.FindSessionByIdXenon_CreateBatchesFromList(" + seqNum.ToString("X8")
                    + "): The blob attribute passed to find by IDs was not a correct size ("
                    + (null == rgAttributes[0].rgbValue ? "<null>" : rgAttributes[0].rgbValue.Length.ToString())
                    + ") titleId = " + (TitleId) dwTitleId);
        }

        ulong[] rgqwSessionIds = MatchDefs.SessionIdListFromBytes(sessionListAttr.rgbValue);

        // Track the size of the request
        SearchByIdsPerfCountersUpdate(dwTitleId, rgqwSessionIds.Length);

        // hash the sessions into their buckets, to create a list of sessions for each bucket
        Hashtable hashBuckets = new Hashtable();
        foreach (ulong qwSessionId in rgqwSessionIds)
        {
            uint dwBucket = dwBucketIDFromAttribs(MatchDefs.GetGameTypeFromSessionId(qwSessionId),
                                            MatchDefs.GetGameModeFromSessionId(qwSessionId),
                                            MatchDefs.XNetXnKidGetDatabaseIndex(qwSessionId));

            if (hashBuckets.ContainsKey(dwBucket))
            {
                ((List<ulong>)hashBuckets[dwBucket]).Add(qwSessionId);
            }
            else
            {
                List<ulong> listSessions = new List<ulong>();
                listSessions.Add(qwSessionId);
                hashBuckets.Add(dwBucket, listSessions);
            }
        }

        FindSessionQueryBatch [] rgBatches = new FindSessionQueryBatch[hashBuckets.Keys.Count];

        int iServer = 0;
        foreach(DictionaryEntry de in hashBuckets)
        {
            rgBatches[iServer] = new FindSessionQueryBatch((uint)de.Key);

            MatchAttribute[] rgNewAttributes = new MatchAttribute[rgAttributes.Length];
            rgNewAttributes[0] = new MatchAttribute(
                    MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST,
                    MatchDefs.SessionIdListToBytes(((List<ulong>)de.Value).ToArray(), true));

            for (int iAttribute = 1; iAttribute < rgAttributes.Length; ++iAttribute)
            {
                rgNewAttributes[iAttribute] = rgAttributes[iAttribute];
            }

            rgBatches[iServer].rgAttributes = rgNewAttributes;
            rgBatches[iServer].cSessionIds = ((List<ulong>)de.Value).Count;
            iServer++;
        }
        return rgBatches;
    }

    // ----------------------------------------------------------------------
    // FindSessionByIdLog - Logs the results of an delete session call to the
    // application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void FindSessionByIdLog(
        byte bNatType,
        uint dwTitleId,
        uint dwProcedureIndex,
        ulong qwSessionId,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute []rgAttributes,
        int numResults,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchSearchByIdXbox360|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(dwProcedureIndex.ToString("X8")); sb.Append("|");
        sb.Append(bNatType.ToString()); sb.Append("|");
        sb.Append(wNumUsers.ToString()); sb.Append("|");
        sb.Append(rgAttributes.Length.ToString()); sb.Append("|");
        sb.Append(numResults.ToString()); sb.Append("|");
        sb.Append(qwSessionId.ToString("X16")); sb.Append("|");
        sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetPlatformLock(rgAttributes).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.ina).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.inaOnline).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.wPortOnline).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.qwXboxId).ToString("X16"));

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }


    // ----------------------------------------------------------------------
    // FindSessionRankedXenon - performs a ranked query for Xenon titles
    // ----------------------------------------------------------------------
    public static HResult FindSessionRankedXenon(
        byte bNatType,
        uint dwTitleId,
        TitleInfo ti,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        out SearchResult[] results,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        bool fIsLegacyXboxTitle = false;
        HResult hr = HResult.S_OK;
        RankedSearchDetails rankedSearchDetails = null;
        uint maxResults = 0;
        SqlConnection cxn = null;
        SqlCommand cmd = null;
        SqlDataReader reader = null;
        SearchResult[] previousResults = null;
        bool fFirstMerge = true;
        double gamerMu = -1.0;
        double gamerSigma = -1.0;
        byte bNumRRBuckets = 0;
        byte bStartingRRID = 0;
        IBucketServer ibsServer = null;

        results = null;

        try
        {
            // the ranked session could be on any of the Round Robined DBs
            // for this type/mode.  Try each one...

            bNumRRBuckets = ti.GetRRCountForPartition(GetGameType(rgAttributes), GetGameMode(rgAttributes), seqNum);
            bStartingRRID = ti.GetNextRRIndexForPartition(GetGameType(rgAttributes), GetGameMode(rgAttributes), true, seqNum);

            for(int iCurrent = 0; iCurrent < bNumRRBuckets; iCurrent++)
            {

                byte bRRIndex = (byte)(((bStartingRRID + iCurrent) % bNumRRBuckets));
                ibsServer = ti.GetBucketForPartitionAndRRID(
                                        GetGameType(rgAttributes),
                                        GetGameMode(rgAttributes),
                                        bRRIndex,
                                        seqNum);

                cmd = CreateXenonSearchSqlCommand(dwTitleId, dwProcedureIndex, "ranked");

                MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                    "@retval", (uint)0);
                MatchSql.SqlAddParam(cmd, ParameterDirection.Output,
                    "@i_max_results", maxResults);
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@si_required_slots", wNumUsers);
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@i_client_ip", ByteSwap(ClientAddress.inaOnline));
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@ti_nat_type", bNatType);
                // TODOTHEOM: I believe that this param is not used.  Confirm and remove.
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                    "@ti_server_count", 0);

                AddParamAttributesToSqlCommand(rgAttributes, ti, dwTitleId,
                    dwProcedureIndex, cmd, fIsLegacyXboxTitle, seqNum);

                // loop across the servers for the bucket, if the bucket is in migration
                string strServerName = GetActiveServer(ibsServer);
                bool fBucketMigratingRequery = false;

                do  // for Next and Current server of the bucket
                {
                    cxn = OpenSqlConnectionToMatchDB(strServerName);
                    cmd.Connection = cxn;

                    // loop so we can retry the query in case of a NOLOCK
                    // scanning failure
                    int retries = 0;
                    while (true)
                    {
                        try
                        {
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                + "): Using db=" + cxn.DataSource
                                + " to execute query=" + cmd.CommandText
                                + ". titleId = " + (TitleId) dwTitleId);

                            reader = cmd.ExecuteReader();

                            // We get two result sets from a ranked query. The first result set
                            // provides the front door with some insight into how the ranked search
                            // stored proc arrived at the range of mu to use for this query.
                            // TODO: in the round-robin or migration-in-progress cases, we'll only log the
                            // details for the last server.  We should really aggregate.
                            ReadRankedSearchDetails(reader, out rankedSearchDetails, seqNum, dwTitleId);

                            reader.NextResult();

                            // If this is not the first result set then save off the existing
                            // results so we can merge the new ones in after they are read.
                            if (null != results)
                            {
                                previousResults = results;
                                results = null;
                            }

                            ReadSearchResults(dwTitleId, dwProcedureIndex,
                                cmd, reader, fIsLegacyXboxTitle, out maxResults, out results, seqNum);

                            if (null != previousResults && null != results)
                            {
                                // Set the draw probability for the original results
                                if (fFirstMerge)
                                {
                                    gamerMu = GetGamerMu(rgAttributes);
                                    gamerSigma = GetGamerSigma(rgAttributes);

                                    SetDrawProbabilty(previousResults, gamerMu, gamerSigma);

                                    fFirstMerge = false;
                                }

                                // Set the draw probability for the new results
                                SetDrawProbabilty(results, gamerMu, gamerSigma);

                                results = MergeResultsByDrawProbability(previousResults, results);
                                previousResults = null;
                            }

                            // if we get here, the query worked, so break out of the loop
                            break;
                        }
                        catch (SqlException e)
                        {
                            if (ConsiderExceptionAsConnectionFailure(e))
                            {
                                hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                                DBLayer.ReportFailure(cxn.DataSource, e.ToString());

                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                                    XEvent.Id.MATCH_COMM_EXECUTE_FINDRANKED_XENON,
                                    "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                    + "): Failed to communicate with " + cxn.DataSource
                                    + ".  titleId = " + (TitleId) dwTitleId, e);
                            }

                            switch (e.Errors[0].Number)
                            {
                                case SQLDefs.ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK:
                                    // every once in a while, we're going to have
                                    // to retry a query because we use the NOLOCK
                                    // hint to avoid deadlocks.
                                    retries++;
                                    if (retries < NolockRetries)
                                    {
                                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                            "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                            + "): NOLOCK scan error detected, retry = " + retries.ToString()
                                            + ". titleId = " + (TitleId) dwTitleId);
                                        reader.Close();
                                        SearchSessionRetryPerfCounters(MatchXrl.xmatchclient2_ashx,
                                            dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                        continue;
                                    }

                                    // if we've already retried as many times as we're allowed to
                                    // then return empty search results, but update the retry
                                    // failure perf counters so we'll be able to tell if this
                                    // ever happens in practice.
                                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): too many NOLOCK scan errors detected, "
                                        + "returing empty search results, retry = " + retries.ToString()
                                        + ". titleId = " + (TitleId) dwTitleId);
                                    SearchSessionRetryFailurePerfCounters(MatchXrl.xmatchclient2_ashx,
                                        dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                    results = new SearchResult[0];
                                    maxResults = 0;
                                    break;

                                case SQLDefs.ERROR_PARAM_MISSING:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_PARAM_MISSING,
                                        XEvent.Id.MATCH_TITLEBUG_21,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): Required parameter missing."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_COULD_NOT_FIND_STORED_PROC:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ,
                                        XEvent.Id.MATCH_TITLEBUG_22,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): could not find stored proc."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_TOO_MANY_PARAM:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_23,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): Required parameter missing."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_INVALID_PARAM_NAME:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_24,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): Invalid parameter passed."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_DUPLICATE_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_25,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): Duplicate parameter passed."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                default:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                        XEvent.Id.MATCH_CODE_15,
                                        "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8")
                                        + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);
                            }
                        }

                        // if we get here, we've given up on our retries, so break
                        // out of the loop.
                        break;
                    }   // while true for retries

                    // If we have enough results we can break out of the loop else
                    // we have to continue on to query the next server (if any).
                    if (results.Length >= maxResults)
                        break;
                    // requery if the bucket is in migration, and we haven't already requeried
                    fBucketMigratingRequery = FBucketInMigration(ibsServer) &&
                                            !fBucketMigratingRequery;
                    strServerName = ibsServer.CurrentServerName;

                    if (reader != null)
                    {
                        reader.Close();
                    }
                    if (cxn != null)
                    {
                        cxn.Close();
                    }
                }
                while (fBucketMigratingRequery);  // end loop over servers for a bucket that's in migration

                // If we have enough results we can break out of the loop else
                // we have to continue on to query the next server (if any).
                if (results.Length >= maxResults)
                    break;
            }   // foreach SqlConnection

        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below

            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_16,
                "XMatchFD.DBLayer.FindSessionRankedXenon(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            if(reader != null)
            {
                reader.Close();
            }
            if (cxn != null)
            {
                cxn.Close();
            }

            FindSessionRankedLog(bNatType, dwTitleId, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes, results == null ? 0 : results.Length, maxResults,
                rankedSearchDetails, xrteRequestTime, seqNum, hr);
        }

        return hr;
    }

    // ----------------------------------------------------------------------
    // FindSessionRankedLog - Logs the results of an ranked session search call
    // to the application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void FindSessionRankedLog(
        byte bNatType,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        int numResults,
        uint maxResults,
        RankedSearchDetails rankedSearchDetails,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchSearchRankedXbox360|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(dwProcedureIndex.ToString("X8")); sb.Append("|");
        sb.Append(bNatType.ToString()); sb.Append("|");
        sb.Append(wNumUsers.ToString()); sb.Append("|");
        sb.Append(rgAttributes.Length.ToString()); sb.Append("|");
        sb.Append(numResults.ToString()); sb.Append("|");
        sb.Append(maxResults.ToString()); sb.Append("|");
        sb.Append(GetCallerPuid(rgAttributes).ToString("X16")); sb.Append("|");
        sb.Append(GetGamerHostname(rgAttributes)); sb.Append("|");
        sb.Append(GetGameType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGameMode(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerZone(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerCountry(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerLanguage(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerRating(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetGamerMu(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetGamerSigma(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetPlatformLock(rgAttributes).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.ina).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.inaOnline).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.wPortOnline).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.qwXboxId).ToString("X16")); sb.Append("|");
        if (rankedSearchDetails != null)
        {
            sb.Append(rankedSearchDetails.iterations.ToString()); sb.Append("|");
            sb.Append(rankedSearchDetails.rowCount.ToString()); sb.Append("|");
            sb.Append(rankedSearchDetails.muRange.ToString("r")); sb.Append("|");
            sb.Append(rankedSearchDetails.muUpperBound.ToString("r")); sb.Append("|");
            sb.Append(rankedSearchDetails.muLowerBound.ToString("r")); sb.Append("|");
            sb.Append(rankedSearchDetails.lowerHashBound1.ToString()); sb.Append("|");
            sb.Append(rankedSearchDetails.upperHashBound1.ToString()); sb.Append("|");
            sb.Append(rankedSearchDetails.lowerHashBound2.ToString()); sb.Append("|");
            sb.Append(rankedSearchDetails.upperHashBound2.ToString());
        }
        else
        {
            sb.Append("0|0|0|0|0|0|0|0|0");
        }

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }

    // ----------------------------------------------------------------------
    // FindSessionStandardXenon - performs a standard "social" query for Xenon titles
    // ----------------------------------------------------------------------
    public static HResult FindSessionStandardXenon(
        byte bNatType,
        string emulatorUrl,
        uint dwTitleId,
        TitleInfo ti,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        out SearchResult[] results,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        HResult hr = HResult.S_OK;
        results = null;
        AffiliateDetails affiliateDetails = null;
        int negSessionsFilteredInZoneSameLangSameCountryCount = 0;
        int negSessionsFilteredInZoneCount = 0;
        int negSessionsFilteredOutZoneCount = 0;
        StandardSearchDetails standardSearchDetailsInZoneSameLangSameCountry = null;
        StandardSearchDetails standardSearchDetailsInZone = null;
        StandardSearchDetails standardSearchDetailsOutZone = null;
        AffiliateSession[] positiveAffiliateSessions = new AffiliateSession[0];
        AffiliateSession[] negativeAffiliateSessions = new AffiliateSession[0];
        SearchResult[] affiliateResultsSameZone = new SearchResult[0];
        SearchResult[] affiliateResultsDiffZone = new SearchResult[0];
        SearchResult[] nonAffiliateResultsSameZoneSameLangSameCountry = new SearchResult[0];
        SearchResult[] nonAffiliateResultsSameZone = new SearchResult[0];
        SearchResult[] nonAffiliateResultsDiffZone = new SearchResult[0];
        uint maxResults = MatchDefs.X_MATCH_MAX_QUERY_RESULTS;

        try
        {
            ulong puid = GetCallerPuid(rgAttributes);
            if (!DisableAffiliateQuery && puid != 0)
            {
                // if we have a PUID, then we do an affiliates query
                GetAffiliateSessions(emulatorUrl, dwTitleId, puid, out positiveAffiliateSessions,
                    out negativeAffiliateSessions, out affiliateDetails, seqNum);

                maxResults = GetAffiliateResults(bNatType, dwTitleId, ti, dwProcedureIndex,
                    ClientAddress, wNumUsers, rgAttributes, positiveAffiliateSessions,
                    out affiliateResultsSameZone, out affiliateResultsDiffZone, seqNum);
            }

            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                "XMatchFD.DBLayer.FindSessionStandardXenon(" + seqNum.ToString("X8")
                + "): Found "
                + affiliateResultsSameZone.Length.ToString()
                + " same zone affiliate results and "
                + affiliateResultsDiffZone.Length.ToString()
                + " different zone affiliate results for user puid "
                + puid.ToString("X16") + " for query=" + dwProcedureIndex.ToString("X8")
                + ", titleId = " + (TitleId) dwTitleId);

            // only look for non-affiliate results if we don't have enough, same-zone
            // affiliate results to satisfy maxResults
            if (affiliateResultsSameZone.Length < maxResults)
            {
                maxResults = GetNonAffiliateResults(bNatType, dwTitleId, ti, dwProcedureIndex,
                    ClientAddress, wNumUsers, rgAttributes, affiliateResultsSameZone,
                    affiliateResultsDiffZone, negativeAffiliateSessions,
                    out nonAffiliateResultsSameZoneSameLangSameCountry,
                    out nonAffiliateResultsSameZone,
                    out nonAffiliateResultsDiffZone,
                    out standardSearchDetailsInZoneSameLangSameCountry,
                    out standardSearchDetailsInZone,
                    out standardSearchDetailsOutZone,
                    seqNum);
            }

            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                "XMatchFD.DBLayer.FindSessionStandardXenon(" + seqNum.ToString("X8")
                + "): Found "
                + nonAffiliateResultsSameZone.Length.ToString()
                + " same zone non-affiliate results and "
                + nonAffiliateResultsDiffZone.Length.ToString()
                + " different zone non-affiliate results for query="
                + dwProcedureIndex.ToString("X8")
                + ", titleId = " + (TitleId) dwTitleId);

            // we now have everything we need to assemble the final result set
            results = AssembleResults(
                dwTitleId,
                dwProcedureIndex,
                rgAttributes,
                maxResults,
                positiveAffiliateSessions,
                negativeAffiliateSessions,
                affiliateResultsSameZone,
                nonAffiliateResultsSameZoneSameLangSameCountry,
                nonAffiliateResultsSameZone,
                affiliateResultsDiffZone,
                nonAffiliateResultsDiffZone,
                out negSessionsFilteredInZoneSameLangSameCountryCount,
                out negSessionsFilteredInZoneCount,
                out negSessionsFilteredOutZoneCount,
                seqNum);

            StandardSearchResultsPerfCounters(dwTitleId,
                affiliateResultsSameZone.Length,
                nonAffiliateResultsSameZoneSameLangSameCountry.Length,
                nonAffiliateResultsSameZone.Length,
                affiliateResultsDiffZone.Length,
                nonAffiliateResultsDiffZone.Length,
                negSessionsFilteredInZoneSameLangSameCountryCount,
                negSessionsFilteredInZoneCount,
                negSessionsFilteredOutZoneCount);

        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below
            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_17,
                "XMatchFD.DBLayer.FindSessionStandardXenon(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            FindSessionStandardLog(bNatType, dwTitleId, dwProcedureIndex, ClientAddress, wNumUsers,
                rgAttributes, results == null ? 0 : results.Length, maxResults,
                affiliateResultsSameZone == null ? 0 : affiliateResultsSameZone.Length,
                nonAffiliateResultsSameZoneSameLangSameCountry == null ? 0 : nonAffiliateResultsSameZoneSameLangSameCountry.Length,
                nonAffiliateResultsSameZone == null ? 0 : nonAffiliateResultsSameZone.Length,
                affiliateResultsDiffZone == null ? 0 : affiliateResultsDiffZone.Length,
                nonAffiliateResultsDiffZone == null ? 0 : nonAffiliateResultsDiffZone.Length,
                affiliateDetails, negSessionsFilteredInZoneSameLangSameCountryCount,
                negSessionsFilteredInZoneCount, negSessionsFilteredOutZoneCount,
                standardSearchDetailsInZoneSameLangSameCountry, standardSearchDetailsInZone,
                standardSearchDetailsOutZone, xrteRequestTime, seqNum, hr);
        }
        return HResult.S_OK;
    }

    // ----------------------------------------------------------------------
    // FindSessionStandardLog - Logs the results of an ranked session search call
    // to the application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void FindSessionStandardLog(
        byte bNatType,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        int numResults,
        uint maxResults,
        int numAffiliateResultsInZone,
        int numNonAffiliateResultsInZoneSameLangSameCountry,
        int numNonAffiliateResultsInZone,
        int numAffiliateResultsOutZone,
        int numNonAffiliateResultsOutZone,
        AffiliateDetails affiliateDetails,
        int negSessionsFilteredInZoneSameLangSameCountryCount,
        int negSessionsFilteredInZoneCount,
        int negSessionsFilteredOutZoneCount,
        StandardSearchDetails standardSearchDetailsInZoneSameLangSameCountry,
        StandardSearchDetails standardSearchDetailsInZone,
        StandardSearchDetails standardSearchDetailsOutZone,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchSearchStandardXbox360|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(dwProcedureIndex.ToString("X8")); sb.Append("|");
        sb.Append(bNatType.ToString()); sb.Append("|");
        sb.Append(wNumUsers.ToString()); sb.Append("|");
        sb.Append(rgAttributes.Length.ToString()); sb.Append("|");
        sb.Append(numResults.ToString()); sb.Append("|");
        sb.Append(maxResults.ToString()); sb.Append("|");
        sb.Append(numAffiliateResultsInZone.ToString()); sb.Append("|");
        sb.Append(numNonAffiliateResultsInZone.ToString()); sb.Append("|");
        sb.Append(numAffiliateResultsOutZone.ToString()); sb.Append("|");
        sb.Append(numNonAffiliateResultsOutZone.ToString()); sb.Append("|");
        sb.Append(GetCallerPuid(rgAttributes).ToString("X16")); sb.Append("|");
        sb.Append(GetGamerHostname(rgAttributes)); sb.Append("|");
        sb.Append(GetGameType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGameMode(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerZone(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerCountry(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerLanguage(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerRating(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetGamerMu(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetGamerSigma(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetPlatformLock(rgAttributes).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.ina).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.inaOnline).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.wPortOnline).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.qwXboxId).ToString("X16")); sb.Append("|");

        if (affiliateDetails != null)
        {
            sb.Append(affiliateDetails.friendCount.ToString()); sb.Append("|");
            sb.Append(affiliateDetails.posCount.ToString()); sb.Append("|");
            sb.Append(affiliateDetails.completedCount.ToString()); sb.Append("|");
            sb.Append(affiliateDetails.negCount.ToString()); sb.Append("|");
            sb.Append(affiliateDetails.avoidingMeCount.ToString()); sb.Append("|");
            sb.Append(affiliateDetails.posSessionsCount.ToString()); sb.Append("|");
            sb.Append(affiliateDetails.negSessionsCount.ToString()); sb.Append("|");
        }
        else
        {
            sb.Append("0|0|0|0|0|0|0"); sb.Append("|");
        }

        sb.Append(negSessionsFilteredInZoneSameLangSameCountryCount.ToString()); sb.Append("|");
        sb.Append(negSessionsFilteredInZoneCount.ToString()); sb.Append("|");
        sb.Append(negSessionsFilteredOutZoneCount.ToString()); sb.Append("|");

        if (standardSearchDetailsInZoneSameLangSameCountry != null)
        {
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.iterations.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.rowCount.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.ratingRange.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.ratingUpperBound.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.ratingLowerBound.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.lowerHashBound1.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.upperHashBound1.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.lowerHashBound2.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZoneSameLangSameCountry.upperHashBound2.ToString()); sb.Append("|");
        }
        else
        {
            sb.Append("0|0|0|0|0|0|0|0|0"); sb.Append("|");
        }
        if (standardSearchDetailsInZone != null)
        {
            sb.Append(standardSearchDetailsInZone.iterations.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.rowCount.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.ratingRange.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.ratingUpperBound.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.ratingLowerBound.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.lowerHashBound1.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.upperHashBound1.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.lowerHashBound2.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsInZone.upperHashBound2.ToString()); sb.Append("|");
        }
        else
        {
            sb.Append("0|0|0|0|0|0|0|0|0"); sb.Append("|");
        }
        if (standardSearchDetailsOutZone != null)
        {
            sb.Append(standardSearchDetailsOutZone.iterations.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.rowCount.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.ratingRange.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.ratingUpperBound.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.ratingLowerBound.ToString("r")); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.lowerHashBound1.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.upperHashBound1.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.lowerHashBound2.ToString()); sb.Append("|");
            sb.Append(standardSearchDetailsOutZone.upperHashBound2.ToString());
        }
        else
        {
            sb.Append("0|0|0|0|0|0|0|0|0");
        }

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }


   // ----------------------------------------------------------------------
    // FindSessionWeightedXenon - performs a Weighted query for Xenon titles
    // ----------------------------------------------------------------------
    public static HResult FindSessionWeightedXenon(
        byte bNatType,
        uint dwTitleId,
        TitleInfo ti,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        MatchAttributeWeighted[] rgWeightedAttributes,
        out SearchResult[] results,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        bool fIsLegacyXboxTitle = false;
        HResult hr = HResult.S_OK;
        WeightedSearchDetails weightedSearchDetails = null;
        uint maxResults = 0;
        SqlConnection cxn = null;
        SqlCommand cmd = null;
        SqlDataReader reader = null;
        SearchResult[] previousResults = null;
        byte bNumRRBuckets = 0;
        byte bStartingRRID = 0;
        IBucketServer ibsServer = null;
        byte bGameType = (byte)MatchDefs.XMATCH_MAX_GAMETYPE+1;
        byte bGameMode = (byte)MatchDefs.XMATCH_MAX_GAMEMODE+1;

        results = null;

        try
        {
            // weighted search gets the same semantics as ranked, in term of migration and round-robining.
            // we will search across migrating servers (current and next) and round robin buckets, until we have 
            // enough results.  The those results will be brought together and re-sorted.

            bGameType = GetGameType(rgAttributes);
            bGameMode = GetGameMode(rgAttributes);
            bNumRRBuckets = ti.GetRRCountForPartition(bGameType, bGameMode, seqNum);
            bStartingRRID = ti.GetNextRRIndexForPartition(bGameType, bGameMode, true, seqNum);

            // create the sql command once -- we'll reuse it for each server we query
            string strGameType = MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED == bGameType ? "weighted_ranked" : "weighted_standard";
            cmd = CreateXenonSearchSqlCommand(dwTitleId, dwProcedureIndex, strGameType);

            MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Output,
                "@i_max_results", maxResults);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@si_required_slots", wNumUsers);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@i_client_ip", ByteSwap(ClientAddress.inaOnline));
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@ti_nat_type", bNatType);
            // TODOTHEOM: I believe that this param is not used.  Confirm and remove.
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@ti_server_count", 0);

            // add the non-weighted attributes (params) first
            AddParamAttributesToSqlCommand(rgAttributes, ti, dwTitleId,
                dwProcedureIndex, cmd, fIsLegacyXboxTitle, seqNum);

            // add the weighted attributes (params)
            AddParamAttributesToSqlCommand(rgWeightedAttributes, ti, dwTitleId,
                dwProcedureIndex, cmd, fIsLegacyXboxTitle, true /*fWeighted*/, seqNum);
                
            for(int iCurrent = 0; iCurrent < bNumRRBuckets; iCurrent++)
            {

                byte bRRIndex = (byte)(((bStartingRRID + iCurrent) % bNumRRBuckets));
                ibsServer = ti.GetBucketForPartitionAndRRID(
                                        GetGameType(rgAttributes),
                                        GetGameMode(rgAttributes),
                                        bRRIndex,
                                        seqNum);


                // loop across the servers for the bucket, if the bucket is in migration
                string strServerName = GetActiveServer(ibsServer);
                bool fBucketMigratingRequery = false;

                do  // for Next and Current server of the bucket
                {
                    cxn = OpenSqlConnectionToMatchDB(strServerName);
                    cmd.Connection = cxn;

                    // loop so we can retry the query in case of a NOLOCK
                    // scanning failure
                    int retries = 0;
                    while (true)
                    {
                        try
                        {
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                + "): Using db=" + cxn.DataSource
                                + " to execute query=" + cmd.CommandText
                                + ". titleId = " + (TitleId) dwTitleId);

                            reader = cmd.ExecuteReader();

                            // We get two result sets from a Weighted query. The first result set
                            // provides the front door with some insight into how the weighted search
                            // did its magic.  (expanding on each dimension, and hashing)
                            // NOTE: in the round-robin or migration-in-progress cases, we'll only log the
                            // details for the last server.
                            ReadWeightedSearchDetails(reader, out weightedSearchDetails, seqNum, dwTitleId);

                            reader.NextResult();

                            // If this is not the first result set then save off the existing
                            // results so we can merge the new ones in after they are read.
                            if (null != results)
                            {
                                previousResults = results;
                                results = null;
                            }

                            ReadSearchResults(dwTitleId, dwProcedureIndex,
                                cmd, reader, fIsLegacyXboxTitle, out maxResults, out results, seqNum);

                            // merge together the old results and the new results.  
                            if (null != previousResults && null != results)
                            {
                                 results = MergeResultsByWeightedScore(previousResults, results);
                                previousResults = null;
                            }

                            // if we get here, the query worked, so break out of the loop
                            break;
                        }
                        catch (SqlException e)
                        {
                            // handle specific sql exceptions.  This also updates the retry count. (ref retries)

                            // TODOTHEOM: consider factoring all this exception handling code out since it's duplicated across ranked/weighted/etc.
                            if (ConsiderExceptionAsConnectionFailure(e))
                            {
                                hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                                DBLayer.ReportFailure(cxn.DataSource, e.ToString());

                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                                    XEvent.Id.MATCH_COMM_EXECUTE_FINDRANKED_XENON, // TODOTHEOM: should be FINDWEIGHTED_XENON
                                    "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                    + "): Failed to communicate with " + cxn.DataSource
                                    + ".  titleId = " + (TitleId) dwTitleId, e);
                            }

                            switch (e.Errors[0].Number)
                            {
                                case SQLDefs.ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK:
                                    // every once in a while, we're going to have
                                    // to retry a query because we use the NOLOCK
                                    // hint to avoid deadlocks.
                                    retries++;
                                    if (retries < NolockRetries)
                                    {
                                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                            "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                            + "): NOLOCK scan error detected, retry = " + retries.ToString()
                                            + ". titleId = " + (TitleId) dwTitleId);
                                        reader.Close();
                                        SearchSessionRetryPerfCounters(MatchXrl.xmatchclient2_ashx,
                                            dwTitleId, dwProcedureIndex, 0, true /*fWeighted*/);
                                        continue;
                                    }

                                    // if we've already retried as many times as we're allowed to
                                    // then return empty search results, but update the retry
                                    // failure perf counters so we'll be able to tell if this
                                    // ever happens in practice.
                                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): too many NOLOCK scan errors detected, "
                                        + "returing empty search results, retry = " + retries.ToString()
                                        + ". titleId = " + (TitleId) dwTitleId);
                                    SearchSessionRetryFailurePerfCounters(MatchXrl.xmatchclient2_ashx,
                                        dwTitleId, dwProcedureIndex, 0, true /*fWeighted*/);
                                    results = new SearchResult[0];
                                    maxResults = 0;
                                    break;

                                case SQLDefs.ERROR_PARAM_MISSING:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_PARAM_MISSING,
                                        XEvent.Id.MATCH_TITLEBUG_21,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): Required parameter missing."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_COULD_NOT_FIND_STORED_PROC:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ,
                                        XEvent.Id.MATCH_TITLEBUG_22,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): could not find stored proc."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_TOO_MANY_PARAM:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_23,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): Required parameter missing."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_INVALID_PARAM_NAME:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_24,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): Invalid parameter passed."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_DUPLICATE_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_25,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): Duplicate parameter passed."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                default:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                        XEvent.Id.MATCH_CODE_15,
                                        "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8")
                                        + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);
                            }
                        }
                        // if we get here, we've given up on our retries, so break
                        // out of the loop.
                        break;
                    }   // while true for retries

                    // If we have enough results we can break out of the loop else
                    // we have to continue on to query the next server (if any).
                    if (results.Length >= maxResults)
                        break;
                    // requery if the bucket is in migration, and we haven't already requeried
                    fBucketMigratingRequery = FBucketInMigration(ibsServer) &&
                                            !fBucketMigratingRequery;
                    strServerName = ibsServer.CurrentServerName;

                    if (reader != null)
                    {
                        reader.Close();
                    }
                    if (cxn != null)
                    {
                        cxn.Close();
                    }
                }
                while (fBucketMigratingRequery);  // end loop over servers for a bucket that's in migration

                // If we have enough results we can break out of the loop else
                // we have to continue on to query the next server (if any).
                if (results.Length >= maxResults)
                    break;
            }   // foreach SqlConnection

        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below

            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_16,
                "XMatchFD.DBLayer.FindSessionWeightedXenon(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            if(reader != null)
            {
                reader.Close();
            }
            if (cxn != null)
            {
                cxn.Close();
            }

            FindSessionWeightedLog(bNatType, dwTitleId, dwProcedureIndex, ClientAddress,
                wNumUsers, rgAttributes, results == null ? 0 : results.Length, maxResults,
                weightedSearchDetails, xrteRequestTime, seqNum, hr);
        }

        return hr;
    }

    // ----------------------------------------------------------------------
    // FindSessionWeightedLog - Logs the results of an Weighted session search call
    // to the application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void FindSessionWeightedLog(
        byte bNatType,
        uint dwTitleId,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        int numResults,
        uint maxResults,
        WeightedSearchDetails weightedSearchDetails,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchSearchWeightedXbox360|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(dwProcedureIndex.ToString("X8")); sb.Append("|");
        sb.Append(bNatType.ToString()); sb.Append("|");
        sb.Append(wNumUsers.ToString()); sb.Append("|");
        sb.Append(rgAttributes.Length.ToString()); sb.Append("|");
        sb.Append(numResults.ToString()); sb.Append("|");
        sb.Append(maxResults.ToString()); sb.Append("|");
        sb.Append(GetCallerPuid(rgAttributes).ToString("X16")); sb.Append("|");
        sb.Append(GetGamerHostname(rgAttributes)); sb.Append("|");
        sb.Append(GetGameType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGameMode(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerZone(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerCountry(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerLanguage(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetGamerRating(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetGamerMu(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetGamerSigma(rgAttributes).ToString("r")); sb.Append("|");
        sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
        sb.Append(GetPlatformLock(rgAttributes).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.ina).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.inaOnline).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.wPortOnline).ToString()); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(ClientAddress.sgaddr.qwXboxId).ToString("X16")); sb.Append("|");
        if (weightedSearchDetails != null)
        {
            sb.Append(weightedSearchDetails.iterations.ToString()); sb.Append("|");
            sb.Append(weightedSearchDetails.rowCount.ToString()); sb.Append("|");
            sb.Append(weightedSearchDetails.range.ToString("r")); sb.Append("|");
            sb.Append(weightedSearchDetails.lowerHashBound1.ToString()); sb.Append("|");
            sb.Append(weightedSearchDetails.upperHashBound1.ToString()); sb.Append("|");
            sb.Append(weightedSearchDetails.lowerHashBound2.ToString()); sb.Append("|");
            sb.Append(weightedSearchDetails.upperHashBound2.ToString());
        }
        else
        {
            sb.Append("0|0|0|0|0|0|0");
        }

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }


    // -----------------------------------------------------------------------
    // SplitSession - create a new session from an existing session
    // -----------------------------------------------------------------------
    public static HResult SplitSession(
        ulong qwSplitSessionId,
        byte bServerType,
        byte bNatType,
        uint dwTitleId,
        XNADDR HostAddress,
        MatchAttribute[] rgAttributes,
        MatchXrl matchXrl,
        out SearchResult session,
        uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        TitleInfo ti;
        HResult hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
        session = null;

        SplitSessionPerfCountersStart(matchXrl, dwTitleId);

        try
        {
            ti = GetTitleInfo(dwTitleId, seqNum);

            List<MatchAttribute> SearchAttributes = new List<MatchAttribute>(3);

            // Add the session ID by default
            SearchAttributes.Add(new MatchAttribute(MatchDefs.X_ATTRIBUTE_SESSION_ID, qwSplitSessionId));

            //
            // Find the existing session that should split. We have to copy the platform attributes
            // from the splitting attributes if they exists.
            //
            MatchAttribute platformAttr = MatchFdUtil.LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE);
            if(null != platformAttr)
            {
                SearchAttributes.Add(platformAttr);
            }
            platformAttr = MatchFdUtil.LookupAttribute(rgAttributes, MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
            if(null != platformAttr)
            {
                SearchAttributes.Add(platformAttr);
            }

            SearchResult []rgResults;
            hr = FindSessionByIdXenon(
                    bNatType,
                    dwTitleId,
                    ti,
                    MatchDefs.X_SSINDEX_GET_SESSION_ATTRIBUTES,
                    HostAddress,
                    0, // wNumUsers
                    SearchAttributes.ToArray(),
                    out rgResults,
                    seqNum);

            if(HResult.Failed(hr) || rgResults == null || rgResults.Length != 1)
            {
                // Didn't throw and we don't have a good HR here so we're going
                // to give the best HR we can.
                if(HResult.S_OK == hr)
                {
                    hr = HResult.XONLINE_E_MATCH_INVALID_SESSION_ID;
                }

                // If the session is gone, it's because the game
                // deleted it. If the game deleted it, then it
                // shouldn't be trying to split it later. Thus,
                // we consider this a game error
                throw new XRLException(hr, XEvent.Id.MATCH_TITLEBUG_52,
                        "XMatchFD.DBLayer.SplitSession(" + seqNum.ToString("X8")
                        + "): Attempt to split an invalid session id (not found)."
                        + " titleId = " + (TitleId) dwTitleId
                        + " SplitSessionID=0x" + qwSplitSessionId.ToString("X16"));
            }

            ulong qwSessionId = 0;
            byte []rgbKeyExchangeKey = null;
            SearchResult sr = rgResults[0];

            // Do per attribute fixup
            foreach(MatchAttribute attr in sr.rgAttributes)
            {
                switch(attr.dwAttributeId)
                {
                    default:
                        break;
                    case MatchDefs.X_ATTRIBUTE_GAMER_PUID:
                        // Type 0 subtype 2
                        attr.qwValue = GetCallerPuid(rgAttributes);
                        break;
                    case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING|MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME:
                        // Type 1 subtype 4

                        // Because this is a variable length type we need to make sure and fix up
                        // the result lengths and padding before returning the new payload.
                        sr.dwResultLength -= attr.GetSize();
                        attr.strValue = GetGamerHostname(rgAttributes);
                        sr.dwResultLength += attr.GetSize();

                        // Re-pad to a 4-byte boundary
                        if(0 != sr.rgbPaddingLen)
                        {
                            sr.dwResultLength -= sr.rgbPaddingLen;

                            sr.rgbPaddingLen = 4 - (sr.dwResultLength % 4);
                            sr.rgbPadding = new byte[sr.rgbPaddingLen];
                        }
                        else
                        {
                            sr.rgbPaddingLen = 0;
                        }

                        break;
                }
            }

            //
            // Use the parameters  of the split request
            // with the attributes of the current session
            // to generate a new session
            //
            hr = InsertSessionInternal(
                    bServerType,
                    bNatType,
                    dwTitleId,
                    HostAddress,
                    sr.dwPublicOpen,
                    sr.dwPrivateOpen,
                    sr.dwPublicFilled,
                    sr.dwPrivateFilled,
                    sr.rgAttributes,
                    matchXrl,
                    ref qwSessionId,
                    ref rgbKeyExchangeKey,
                    seqNum);
            if(HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.MATCH_CODE_36,
                        "XMatchFD.DBLayer.SplitSession(" + seqNum.ToString("X8")
                        + "): Attempt to insert the new session failed."
                        + " titleId = " + (TitleId) dwTitleId);
            }

            // Copy the session to the out param, do replacement on
            // attributes that have changed for the new session
            session = sr;
            session.qwSessionId         = qwSessionId;
            session.HostAddress         = HostAddress;
            session.rgbKeyExchangeKey   = rgbKeyExchangeKey;
        }
        catch (Exception e)
        {
            // get the hr from the exception,  or use a default value

            hr = XRLException.ToHResult(e, HResult.XONLINE_E_MATCH_SERVER_ERROR);

            // if the exception is specifically without an  event  or
            // already has an event id, then we don't need to wrap it

            if ((e is ExceptionWithoutEvent) || (e is ExceptionWithEventId)) throw;

            // Something unexpected has happened. Rethrow an XRLException
            // so we get proper eventing, and set the hr so it is logged
            // properly below

            throw new XRLException(
                hr, XEvent.Id.MATCH_CODE_0,
                "XMatchFD.DBLayer.SplitSession(" + seqNum.ToString("X8") + "): "
                + "Unexpected exception was thrown. Details should follow.", e);
        }
        finally
        {
            SplitSessionLog(
                    qwSplitSessionId,
                    bServerType,
                    bNatType,
                    dwTitleId,
                    HostAddress,
                    session,
                    xrteRequestTime,
                    seqNum,
                    hr);

            SplitSessionPerfCountersEnd(matchXrl, dwTitleId, xrteRequestTime, hr);
        }
        return hr;
    }

    // ----------------------------------------------------------------------
    // SplitSessionPerfCountersStart - updates perf counters at the start
    // of a split operation
    // ----------------------------------------------------------------------
    private static void SplitSessionPerfCountersStart(
        MatchXrl matchXrl,
        uint dwTitleId)
    {
        MatchSplitSessionCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSplitSessionCounters.Counters[dwTitleId];
        }

        MatchSplitSessionCounters.Counters.RequestsInProgressSplitSession.Increment();
        if (titleIdCounters != null)
        {
            titleIdCounters.RequestsInProgressSplitSession.Increment();
        }
    }

    // ----------------------------------------------------------------------
    // SplitSessionPerfCountersEnd - updates perf counters at the end
    // of split operation
    // ----------------------------------------------------------------------
    private static void SplitSessionPerfCountersEnd(
        MatchXrl matchXrl,
        uint dwTitleId,
        XomRequestTimeElapsed xrteRequestTime,
        HResult hr)
    {
        MatchSplitSessionCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchSplitSessionCounters.Counters[dwTitleId];
        }

        MatchSplitSessionCounters.Counters.RequestsInProgressSplitSession.Decrement();
        MatchSplitSessionCounters.Counters.TotalRequestsSplitSession.Increment();
        MatchSplitSessionCounters.Counters.RequestsPerSecSplitSession.Increment();
        MatchSplitSessionCounters.Counters.AverageExecutionTimeSplitSession.IncrementBy(xrteRequestTime.TimeElapsed);
        MatchSplitSessionCounters.Counters.AverageExecutionTimeBaseSplitSession.Increment();
        if(HResult.Failed(hr))
        {
            MatchSplitSessionCounters.Counters.TotalRequestsSplitSessionFailed.Increment();
            MatchSplitSessionCounters.Counters.RequestsPerSecSplitSessionFailed.Increment();
        }
        if (titleIdCounters != null)
        {
            titleIdCounters.RequestsInProgressSplitSession.Decrement();
            titleIdCounters.TotalRequestsSplitSession.Increment();
            titleIdCounters.RequestsPerSecSplitSession.Increment();
            titleIdCounters.AverageExecutionTimeSplitSession.IncrementBy(xrteRequestTime.TimeElapsed);
            titleIdCounters.AverageExecutionTimeBaseSplitSession.Increment();
            if(HResult.Failed(hr))
            {
                titleIdCounters.TotalRequestsSplitSessionFailed.Increment();
                titleIdCounters.RequestsPerSecSplitSessionFailed.Increment();
            }
        }
    }

    // ----------------------------------------------------------------------
    // SplitSessionLog - Logs the results of an session split call
    // to the application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void SplitSessionLog(
        ulong qwSplitSessionId,
        byte bServerType,
        byte bNatType,
        uint dwTitleId,
        XNADDR HostAddress,
        SearchResult session,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder(256);

        if(null == session || null == session.rgAttributes)
        {
            sb.Append("MatchSplitSession|");
            sb.Append(seqNum.ToString("X8")); sb.Append("|");
            sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
            sb.Append(hr.ToString()); sb.Append("|");
            sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
            sb.Append(qwSplitSessionId.ToString("X16")); sb.Append("|");
            sb.Append(bServerType.ToString()); sb.Append("|");
            sb.Append(bNatType.ToString()); sb.Append("|");
            sb.Append(0); sb.Append("|"); // session.qwSessionId
            sb.Append(0); sb.Append("|"); // session.dwPublicOpen
            sb.Append(0); sb.Append("|"); // session.dwPrivateOpen
            sb.Append(0); sb.Append("|"); // session.dwPublicFilled
            sb.Append(0); sb.Append("|"); // session.dwPrivateFilled
            sb.Append(0); sb.Append("|"); // rgAttributes.Length
            sb.Append(0); sb.Append("|"); // caller puid
            sb.Append(0); sb.Append("|"); // hostname
            sb.Append(0); sb.Append("|"); // game type
            sb.Append(0); sb.Append("|"); // game mode
            sb.Append(0); sb.Append("|"); // gamer zone
            sb.Append(0); sb.Append("|"); // gamer country
            sb.Append(0); sb.Append("|"); // gamer language
            sb.Append(0); sb.Append("|"); // gamer rating
            sb.Append(0); sb.Append("|"); // gamer mu
            sb.Append(0); sb.Append("|"); // gamer sigma
            sb.Append(0); sb.Append("|"); // platform type
            sb.Append(0); sb.Append("|"); // platform lock
            sb.Append(ByteSwap(HostAddress.ina).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.inaOnline).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.wPortOnline).ToString()); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.sgaddr.qwXboxId).ToString("X16"));

        }
        else
        {
            MatchAttribute []rgAttributes = session.rgAttributes;

            sb.Append("MatchSplitSession|");
            sb.Append(seqNum.ToString("X8")); sb.Append("|");
            sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
            sb.Append(hr.ToString()); sb.Append("|");
            sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
            sb.Append(qwSplitSessionId.ToString("X16")); sb.Append("|");
            sb.Append(bServerType.ToString()); sb.Append("|");
            sb.Append(bNatType.ToString()); sb.Append("|");
            sb.Append(session.qwSessionId.ToString("X16")); sb.Append("|");
            sb.Append(session.dwPublicOpen.ToString()); sb.Append("|");
            sb.Append(session.dwPrivateOpen.ToString()); sb.Append("|");
            sb.Append(session.dwPublicFilled.ToString()); sb.Append("|");
            sb.Append(session.dwPrivateFilled.ToString()); sb.Append("|");
            sb.Append(rgAttributes.Length.ToString()); sb.Append("|");
            sb.Append(GetCallerPuid(rgAttributes).ToString("X16")); sb.Append("|");
            sb.Append(GetGamerHostname(rgAttributes)); sb.Append("|");
            sb.Append(GetGameType(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGameMode(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerZone(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerCountry(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerLanguage(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetGamerRating(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetGamerMu(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetGamerSigma(rgAttributes).ToString("r")); sb.Append("|");
            sb.Append(GetPlatformType(rgAttributes).ToString()); sb.Append("|");
            sb.Append(GetPlatformLock(rgAttributes).ToString()); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.ina).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.inaOnline).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.wPortOnline).ToString()); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.sgaddr.inaSg).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
            sb.Append(ByteSwap(HostAddress.sgaddr.qwXboxId).ToString("X16"));
        }


        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }

    // ----------------------------------------------------------------------
    // IsRankedQuery - finds the game type attribute and returns true if it
    // equals ranked. If the attribute is missing, or is not equal to
    // ranked, then false is returned.
    // ----------------------------------------------------------------------
    public static bool IsRankedQuery(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            {
                return matchAttribute.qwValue == MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED;
            }
        }
        return false;
    }

    // ----------------------------------------------------------------------
    // GetGameType - retrieves the game type attribute from the array of attributes
    // if present. If game type is not present, 0x03 (max_game_type+1) is returned.
    // ----------------------------------------------------------------------
    public static byte GetGameType(MatchAttribute[] rgAttributes)
    {
        // TODO2THEOM: can we not do a linear search every time?
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            {
                // TODOTHEOM: do I need to do anything special to catch overflow errors here?
                return (byte)matchAttribute.qwValue;
            }
        }
        return (byte)(MatchDefs.XMATCH_MAX_GAMETYPE + 1);
    }

    // ----------------------------------------------------------------------
    // GetGameMode - retrieves the gamer mode attribute from the array of attributes
    // if present. If game mode is not present, 0x3F (max_game_mode+1) is returned.
    // ----------------------------------------------------------------------
    public static byte GetGameMode(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAME_MODE)
            {
                return (byte)matchAttribute.qwValue;
            }
        }
        return (byte)(MatchDefs.XMATCH_MAX_GAMEMODE + 1);
    }

    // ----------------------------------------------------------------------
    // GetGamerZone - retrieves the gamer zone attribute from the array of attributes
    // if present. If gamer zone is not present, 1 is returned.
    // ----------------------------------------------------------------------
    public static uint GetGamerZone(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            {
                return (uint)matchAttribute.qwValue;
            }
        }
        return MatchDefs.X_ATTRIBUTE_GAMER_ZONE_DEFAULT;
    }

    // ----------------------------------------------------------------------
    // GetGamerCountry - retrieves the gamer country attribute from the array of attributes
    // if present. If gamer country is not present, 103 is returned.
    // ----------------------------------------------------------------------
    public static uint GetGamerCountry(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            {
                return (uint)matchAttribute.qwValue;
            }
        }
        return MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT;
    }

    // ----------------------------------------------------------------------
    // GetGamerLanguage - retrieves the gamer language attribute from the array of attributes
    // if present. If gamer language is not present, 1 is returned.
    // ----------------------------------------------------------------------
    public static uint GetGamerLanguage(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            {
                return (uint)matchAttribute.qwValue;
            }
        }
        return MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT;
    }

    // ----------------------------------------------------------------------
    // GetGamerRating - retrieves the gamer rating attribute from the array of attributes
    // if present. If gamer rating is not present, 58.72 is returned.
    // ----------------------------------------------------------------------
    public static float GetGamerRating(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            {
                return matchAttribute.ToSingle();
            }
        }
        return MatchDefs.X_ATTRIBUTE_GAMER_RATING_DEFAULT;
    }

    // ----------------------------------------------------------------------
    // GetGamerMu - retrieves the gamer mu attribute from the array of attributes
    // if present. If gamer mu is not present, 3.0 is returned.
    // ----------------------------------------------------------------------
    public static double GetGamerMu(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_MU)
            {
                return BitConverter.Int64BitsToDouble((long)matchAttribute.qwValue);
            }
        }
        return MatchDefs.X_ATTRIBUTE_GAMER_MU_DEFAULT;
    }

    // ----------------------------------------------------------------------
    // GetGamerSigma - retrieves the gamer sigma attribute from the array of attributes
    // if present. If gamer sigma is not present, 1.0 is returned.
    // ----------------------------------------------------------------------
    public static double GetGamerSigma(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            {
                return BitConverter.Int64BitsToDouble((long)matchAttribute.qwValue);
            }
        }
        return MatchDefs.X_ATTRIBUTE_GAMER_SIGMA_DEFAULT;
    }

    // ----------------------------------------------------------------------
    // GetCallerPuid - retrieves the puid attribute from the array of attributes
    // if present. If puid is not present, 0 is returned.
    // ----------------------------------------------------------------------
    public static ulong GetCallerPuid(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            {
                return matchAttribute.qwValue;
            }
        }
        return 0;
    }

    // ----------------------------------------------------------------------
    // GetAffiliateValue - retrieves the affiliate value attribute from the array of attributes
    // if present. If affiliate value is not present, 0 is returned.
    // ----------------------------------------------------------------------
    public static ulong GetAffiliateValue(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE)
            {
                return matchAttribute.qwValue;
            }
        }
        return 0;
    }

    // ----------------------------------------------------------------------
    // GetGamerHostname - retrieves the gamer host name attribute from the array of attributes
    // if present. If gamer host name is not present, the empty string is returned.
    // ----------------------------------------------------------------------
    public static string GetGamerHostname(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME
                    || (matchAttribute.dwAttributeId == (MatchDefs.X_ATTRIBUTE_DATATYPE_STRING|MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)))
            {
                return matchAttribute.strValue;
            }
        }
        return "";
    }

    // ----------------------------------------------------------------------
    // GetPlatformType - returns the type of platform if it exists or 0
    // ----------------------------------------------------------------------
    public static uint GetPlatformType(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            {
                return (uint)matchAttribute.qwValue;
            }
        }
        return 0;
    }

    // ----------------------------------------------------------------------
    // GetPlatformLock - returns the platform lock if it exists or 0
    // ----------------------------------------------------------------------
    public static uint GetPlatformLock(MatchAttribute[] rgAttributes)
    {
        foreach (MatchAttribute matchAttribute in rgAttributes)
        {
            if (matchAttribute.dwAttributeId == MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            {
                return (uint)matchAttribute.qwValue;
            }
        }
        return 0;
    }

    // ----------------------------------------------------------------------
    // dwBucketIDFromAttribs - Given a type+mode+rrid, create a bucket ID.
    // ----------------------------------------------------------------------
    public static uint dwBucketIDFromAttribs(byte bGameType, byte bGameMode, byte bRRID)
    {
        return (uint)((bGameType << 16) | (bGameMode << 8) | bRRID);
    }

    // ----------------------------------------------------------------------
    // GetAffiliateSessions - retrieves the list of positive and negative
    // affiliate sessions for the specified user in the specified title
    // ----------------------------------------------------------------------
    public static void GetAffiliateSessions(
        string emulatorUrl,
        uint titleId,
        ulong puid,
        out AffiliateSession[] positiveAffiliateSessions,
        out AffiliateSession[] negativeAffiliateSessions,
        out AffiliateDetails affiliateDetails,
        uint seqNum)
    {
        // default to empty affiliate arrays
        positiveAffiliateSessions = new AffiliateSession[0];
        negativeAffiliateSessions = new AffiliateSession[0];

        affiliateDetails = new AffiliateDetails();

        // get the list of affiliates from the presence front door
        PresenceQueryAffiliatesMsg request = new PresenceQueryAffiliatesMsg();
        request.header.dwSeqNum = seqNum;
        request.header.sgaddr = new SGADDR();
        request.header.sgaddr.inaSg = 0;
        request.header.sgaddr.dwSpiSg = 0;
        request.header.sgaddr.qwXboxId = 0;
        request.header.sgaddr.abReserved = 0;
        request.qwSenderID = puid;
        request.dwListFlags
            = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX)
            | PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)
            | PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)
            | PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX)
            | PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX);
        request.cdwLimit = 0; // no limit to the number of results
        request.dwOnlineTitleID = titleId;

        PresenceQueryAffiliatesReplyMsg reply = new PresenceQueryAffiliatesReplyMsg();
        long elapsed = 0;
        try
        {
            XomRequestTimeElapsed xomRequestTimeElapsed = new XomRequestTimeElapsed();
            HResult hr = PostXrlRequestToPresence(emulatorUrl, request, reply, seqNum);
            elapsed = xomRequestTimeElapsed.TimeElapsed;
            if (HResult.Failed(hr))
            {
                // This means the other server responded, but with an error code
                // of some kind. Log it, but continue as if there were simply no
                // affiliates to return.
                Xom.NtEvent(XEvent.Id.MATCH_COMM_0,
                    "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                    + "): Error getting affiliates list from presence front door, hr = "
                    + hr);
                return;
            }
        }
        catch (Exception e)
        {
            // This could mean just about anything, but again, we should simply log it
            // and continue as if there were no affiliates available.
            Xom.NtEvent(XEvent.Id.MATCH_COMM_1, e,
                "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                + "): Exception thrown getting affiliates list from presence front door.");
            return;
        }

        Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_NORMAL,
            "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
            + "): presence front door returned " + reply.rgResults.Length.ToString()
            + " affiliate records.");

        // if we get here, we should have a valid PresenceQueryAffiliatesReplyMsg in reply
        // now the fun can begin
        Hashtable sessionsHashtable = new Hashtable();
        for (int i = 0; i < reply.rgResults.Length; ++i)
        {
            QueryAffiliatesReplyData replyData = reply.rgResults[i];

            Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + ")\n"
                + replyData.ToString(0));

            // ignore anything with session id zero, which means the user is online,
            // but not in a session at this time.
            if (replyData.qwSessionID != 0)
            {
                // find or add this session to the hashtable
                AffiliateSession affiliateSession = null;
                if (!sessionsHashtable.ContainsKey(replyData.qwSessionID))
                {
                    affiliateSession = new AffiliateSession(replyData.qwSessionID, 0);
                    sessionsHashtable.Add(affiliateSession.SessionId, affiliateSession);
                    Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                        "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                        + "): new session id " + affiliateSession.SessionId.ToString("X16")
                        + " found, initial affiliate value is "
                        + affiliateSession.AffiliateValue.ToString());
                }
                else
                {
                    affiliateSession = (AffiliateSession)sessionsHashtable[replyData.qwSessionID];
                    Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                        "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                        + "): existing session id " + affiliateSession.SessionId.ToString("X16")
                        + " found, present affiliate value is "
                        + affiliateSession.AffiliateValue.ToString());
                }

                // update the value of this sessionid according to the affiliation in this result
                if ((replyData.dwListFlags
                    & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX)) != 0)
                {
                    affiliateSession.AffiliateValue += ValueOfFriend;
                    affiliateDetails.friendCount++;
                }
                if ((replyData.dwListFlags
                    & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)) != 0)
                {
                    affiliateSession.AffiliateValue += ValueOfPositiveFeedback;
                    affiliateDetails.posCount++;
                }
                if ((replyData.dwListFlags
                    & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX)) != 0)
                {
                    affiliateSession.AffiliateValue += ValueOfCompletedGame;
                    affiliateDetails.completedCount++;
                }
                if ((replyData.dwListFlags
                    & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)) != 0)
                {
                    affiliateSession.AffiliateValue += ValueOfNegativeFeedback;
                    affiliateDetails.negCount++;
                }
                if ((replyData.dwListFlags
                    & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX)) != 0)
                {
                    affiliateSession.AffiliateValue += ValueOfAvoidingMe;
                    affiliateDetails.avoidingMeCount++;
                }

                Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                    "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                    + "): session id " + affiliateSession.SessionId.ToString("X16")
                    + " now has affiliate value " + affiliateSession.AffiliateValue.ToString());

            }
        }

        // The hashtable now contains all the session ids referenced in the affiliates reply
        // and had calculated the value of each of those sessions. Convert the hashtable to
        // an array, and sort it.
        AffiliateSession[] affiliateSessions = new AffiliateSession[sessionsHashtable.Count];
        int index = 0;
        foreach (DictionaryEntry de in sessionsHashtable)
        {
            affiliateSessions[index] = (AffiliateSession)de.Value;
            ++index;
        }

        // Array.Sort implements quicksort, which takes O(n^2) worst case, O(n lg n) average case
        // the sort is based on the IComparable interface implemented by AffiliateSession
        // which will sort the largest values to the start of the array
        Array.Sort(affiliateSessions);

        Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
            "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + "): "
            + affiliateSessions.Length.ToString()
            + " affiliate sessions found for puid " + puid.ToString("X16"));
        Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
            "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + ")\n"
            + CollectionUtil.ToString(affiliateSessions));

        // figure out at what index in the now sorted array the affiliate values become negative
        int firstNegative = affiliateSessions.Length;
        for (int i = 0; i < affiliateSessions.Length; ++i)
        {
            if (affiliateSessions[i].AffiliateValue < 0)
            {
                firstNegative = i;
                Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                    "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                    + "): first negative affiliate session found at index "
                    + firstNegative.ToString());
                break;
            }
        }

        // copy the positive values to the positive array
        // however, we must be able to pass these session ids to the sql server
        // in a varbinary(8000) parameter, which means we cannot support
        // more than 1000 elements in this array, so only the first 1000
        // sessions, which should be more than enough.
        const int c_maxAffiliateSessions = 1000;

        positiveAffiliateSessions = new AffiliateSession[Math.Min(firstNegative, c_maxAffiliateSessions)];

        Array.Copy(affiliateSessions, 0, positiveAffiliateSessions, 0,
            positiveAffiliateSessions.Length);

        Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_NORMAL,
            "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + "): "
            + positiveAffiliateSessions.Length.ToString()
            + " positive affiliate sessions found for puid " + puid.ToString("X16"));

        // copy the negative values to the negative array
        // The 1000 session limit doesn't apply because these are not sent to SQL
        negativeAffiliateSessions = new AffiliateSession[affiliateSessions.Length - firstNegative];

        Array.Copy(affiliateSessions, firstNegative, negativeAffiliateSessions, 0,
            negativeAffiliateSessions.Length);

        Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_NORMAL,
            "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + "): "
            + negativeAffiliateSessions.Length.ToString()
            + " negative affiliate sessions sessions found for puid " + puid.ToString("X16"));

        affiliateDetails.posSessionsCount = positiveAffiliateSessions.Length;
        affiliateDetails.negSessionsCount = negativeAffiliateSessions.Length;

        AffiliateSessionPerfCounters(titleId, reply.rgResults.Length, positiveAffiliateSessions.Length,
            negativeAffiliateSessions.Length, elapsed);
    }

    // ----------------------------------------------------------------------
    // AffiliateSessionPerfCounters - updates search result perf counters at the end
    // of an search operation
    // ----------------------------------------------------------------------
    private static void AffiliateSessionPerfCounters(
        uint dwTitleId,
        int numAffiliates,
        int numPositiveSessions,
        int numNegativeSessions,
        long affiliateQueryTimeElapsed)
    {
        MatchAffiliateCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchAffiliateCounters.Counters[dwTitleId];
        }

        MatchAffiliateCounters.Counters.TotalAffiliateRecords.IncrementBy(numAffiliates);
        MatchAffiliateCounters.Counters.AffiliateRecordsPerSec.IncrementBy(numAffiliates);
        MatchAffiliateCounters.Counters.AverageAffiliateRecordsPerRequest.IncrementBy(numAffiliates);
        MatchAffiliateCounters.Counters.AverageAffiliateRecordsPerRequestBase.Increment();
        MatchAffiliateCounters.Counters.AverageExecutionTimeAffiliateQuery.IncrementBy(affiliateQueryTimeElapsed);
        MatchAffiliateCounters.Counters.AverageExecutionTimeBaseAffiliateQuery.Increment();
        if (titleIdCounters != null)
        {
            titleIdCounters.TotalAffiliateRecords.IncrementBy(numAffiliates);
            titleIdCounters.AffiliateRecordsPerSec.IncrementBy(numAffiliates);
            titleIdCounters.AverageAffiliateRecordsPerRequest.IncrementBy(numAffiliates);
            titleIdCounters.AverageAffiliateRecordsPerRequestBase.Increment();
            titleIdCounters.AverageExecutionTimeAffiliateQuery.IncrementBy(affiliateQueryTimeElapsed);
            titleIdCounters.AverageExecutionTimeBaseAffiliateQuery.Increment();
        }

        MatchAffiliateCounters.Counters.TotalAffiliateSessionsPositive.IncrementBy(numPositiveSessions);
        MatchAffiliateCounters.Counters.AffiliateSessionsPositivePerSec.IncrementBy(numPositiveSessions);
        MatchAffiliateCounters.Counters.AverageAffiliateSessionsPositivePerRequest.IncrementBy(numPositiveSessions);
        MatchAffiliateCounters.Counters.AverageAffiliateSessionsPositivePerRequestBase.Increment();
        if (titleIdCounters != null)
        {
            titleIdCounters.TotalAffiliateSessionsPositive.IncrementBy(numPositiveSessions);
            titleIdCounters.AffiliateSessionsPositivePerSec.IncrementBy(numPositiveSessions);
            titleIdCounters.AverageAffiliateSessionsPositivePerRequest.IncrementBy(numPositiveSessions);
            titleIdCounters.AverageAffiliateSessionsPositivePerRequestBase.Increment();
        }

        MatchAffiliateCounters.Counters.TotalAffiliateSessionsNegative.IncrementBy(numNegativeSessions);
        MatchAffiliateCounters.Counters.AffiliateSessionsNegativePerSec.IncrementBy(numNegativeSessions);
        MatchAffiliateCounters.Counters.AverageAffiliateSessionsNegativePerRequest.IncrementBy(numNegativeSessions);
        MatchAffiliateCounters.Counters.AverageAffiliateSessionsNegativePerRequestBase.Increment();
        if (titleIdCounters != null)
        {
            titleIdCounters.TotalAffiliateSessionsNegative.IncrementBy(numNegativeSessions);
            titleIdCounters.AffiliateSessionsNegativePerSec.IncrementBy(numNegativeSessions);
            titleIdCounters.AverageAffiliateSessionsNegativePerRequest.IncrementBy(numNegativeSessions);
            titleIdCounters.AverageAffiliateSessionsNegativePerRequestBase.Increment();
        }
    }

    // ----------------------------------------------------------------------
    // PostXrlRequestToPresence - sends a query affiliates message to the
    // presence front door. If fUseEmu is true, then the presence emulator
    // is used instead.
    // ----------------------------------------------------------------------
    private static HResult PostXrlRequestToPresence(
        string emulatorUrl,
        PresenceQueryAffiliatesMsg request,
        PresenceQueryAffiliatesReplyMsg reply,
        uint seqNum)
    {
        HResult hr = HResult.S_OK;
        if (emulatorUrl == null)
        {
            Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_NORMAL,
                "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                + "): querying presence front door for affiliate list for puid "
                + request.qwSenderID.ToString("X16"));
            Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + ")\n"
                + request.ToString(0));
            XRLObject2 xrlo = reply;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int,
                request.GetXRL(), null, request, ref xrlo);
        }
        else
        {
            Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_NORMAL,
                "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8")
                + "): querying presence emulator at " + emulatorUrl
                + " for affiliate list for puid " + request.qwSenderID.ToString("X16"));
            Xom.Trace(XomAreaName.matchprestrace, LogLevel.L_LOW,
                "XMatchFD.DBLayer.GetAffiliateSessions(" + seqNum.ToString("X8") + ")\n"
                + request.ToString(0));
            hr = XRLUtil.PostXrlRequestToAlternate(XOService.PresNotification, emulatorUrl,
                null, request, null, reply);
        }
        return hr;
    }

    // ----------------------------------------------------------------------
    // GetAffiliateResults - Retrieves the session details for all sessions
    // listed in positiveAffiliateSessions that match the other title defined
    // search criteria and are joinable. The results are returned as two sets,
    // the first set contains the sessions that are in the same gamer zone,
    // the second set contains the sessions that are in other gamer zones.
    // ----------------------------------------------------------------------
    public static uint GetAffiliateResults(
        byte bNatType,
        uint dwTitleId,
        TitleInfo ti,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        AffiliateSession[] positiveAffiliateSessions,
        out SearchResult[] affiliateResultsSameZone,
        out SearchResult[] affiliateResultsDiffZone,
        uint seqNum)
    {
        bool fIsLegacyXboxTitle = false;

        SqlConnection cxn = null;
        SqlCommand cmd = null;
        SqlDataReader reader = null;
        uint maxResults = 0;
        byte bNumRRBuckets = 0;
        byte bStartingRRID = 0;
        byte bGameType = 0xFF;
        byte bGameMode = 0xFF;
        IBucketServer ibsServer;

        // create a byte array of session ids
        byte[] sessionIds = new byte[positiveAffiliateSessions.Length * 8];
        BinaryWriter writer = new BinaryWriter(new MemoryStream(sessionIds));
        for (int i = 0; i < positiveAffiliateSessions.Length; ++i)
        {
            // The sql cast that converts an array of 8 bytes back to a long
            // integer value expects the bytes in big-endian (network) order.
            long l = IPAddress.HostToNetworkOrder(unchecked((long)positiveAffiliateSessions[i].SessionId));
            writer.Write(l);
        }

        // the list of results needs to span queries to all dbs
        ArrayList listSameZone = new ArrayList();
        ArrayList listDiffZone = new ArrayList();

        uint gamerZone = GetGamerZone(rgAttributes);

        // get these once here, since we may use them multiple times.
        bGameType = GetGameType(rgAttributes);
        bGameMode = GetGameMode(rgAttributes);

        // affiliate sessions could be in any of the Round Robined Buckets
        // for this type/mode.  Try each one...
        bNumRRBuckets = ti.GetRRCountForPartition(GetGameType(rgAttributes), GetGameMode(rgAttributes), seqNum);
        bStartingRRID = ti.GetNextRRIndexForPartition(GetGameType(rgAttributes), GetGameMode(rgAttributes), true, seqNum);

        try
        {
            byte bRRIndex = 0;
            for(int iCurrent = 0; iCurrent < bNumRRBuckets; iCurrent++)
            {

                bRRIndex = (byte)(((bStartingRRID + iCurrent) % bNumRRBuckets));
                ibsServer = ti.GetBucketForPartitionAndRRID(
                                        bGameType,
                                        bGameMode,
                                        bRRIndex,
                                        seqNum);


                string strServerName = GetActiveServer(ibsServer);
                bool fBucketMigratingRequery = false;

                do  // for Next and Current server of the bucket
                {

                    cxn = OpenSqlConnectionToMatchDB(strServerName);
                    cmd = CreateAffiliatesSearchSqlCommand(dwTitleId, dwProcedureIndex, cxn);

                    MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                        "@retval", (uint)0);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Output,
                        "@i_max_results", maxResults);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@si_required_slots", wNumUsers);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@i_client_ip", ByteSwap(ClientAddress.inaOnline));
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@ti_nat_type", bNatType);
                    // TODOTHEOM: I don't think this is used.  Confirm and remove.
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@ti_server_count", 0);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@i_session_id_count", positiveAffiliateSessions.Length);
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                        "@vb_session_ids", sessionIds);

                    AddParamAttributesToSqlCommand(rgAttributes, ti, dwTitleId,
                        dwProcedureIndex, cmd, fIsLegacyXboxTitle, seqNum);

                    // loop so we can retry the query in case of a NOLOCK
                    // scanning failure
                    int retries = 0;
                    while (true)
                    {
                        try
                        {
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                + "): Using db=" + cxn.DataSource
                                + " to execute query=" + cmd.CommandText
                                + ". titleId = " + (TitleId) dwTitleId);

                            reader = cmd.ExecuteReader();

                            // The search results for this query are different...
                            // a select statement is run for each session id passed, so the
                            // reader has as many result sets as there were session ids
                            // passed in. each result set should have 0 or 1 rows.
                            // We also need to check the gamer zone in the search results
                            // to figure out what list to add the result to. However,
                            // the stored proc does ensure that each session is only
                            // returned once. We will not get the same session id returned
                            // twice.
                            uint[] attributeIds = null;
                            do
                            {
                                while (reader.Read())
                                {
                                    if (attributeIds == null)
                                    {
                                        attributeIds = GetAttributeIds(reader);
                                    }
                                    SearchResult sr = ReadSearchResult(dwTitleId, dwProcedureIndex,
                                        reader, attributeIds, fIsLegacyXboxTitle, seqNum);
                                    if (gamerZone == GetGamerZone(sr.rgAttributes))
                                    {
                                        listSameZone.Add(sr);
                                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                                            "XMatchFD.DBLayer.GetAffiliateResults("
                                            + seqNum.ToString("X8")
                                            + "): found same zone affiliate result for queryid="
                                            + dwProcedureIndex.ToString("X8")
                                            + ". titleId = " + (TitleId) dwTitleId);
                                    }
                                    else
                                    {
                                        listDiffZone.Add(sr);
                                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                                            "XMatchFD.DBLayer.GetAffiliateResults("
                                            + seqNum.ToString("X8")
                                            + "): found different zone affiliate result for queryid="
                                            + dwProcedureIndex.ToString("X8")
                                            + ". titleId = " + (TitleId) dwTitleId);
                                    }
                                }
                            } while (reader.NextResult());

                            // Our return value will not be populated until we close the
                            // SqlDataReader
                            reader.Close();
                            reader = null;

                            HResult hr = (uint)(int)cmd.Parameters["@retval"].Value;
                            if (HResult.Failed(hr))
                            {
                                throw new XRLException(hr, XEvent.Id.MATCH_CODE_18,
                                    "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                    + "): Unexpected return code hr="
                                    + hr
                                    + " queryid=" + dwProcedureIndex.ToString("X8")
                                    + " titleId = " + (TitleId) dwTitleId);
                            }

                            maxResults = (uint)(int)cmd.Parameters["@i_max_results"].Value;
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW, "XMatchFD.DBLayer.GetAffiliateResults("
                                + seqNum.ToString("X8")
                                + "): maxresults=" + maxResults.ToString()
                                + " hr = " + hr
                                + " from queryid=" + dwProcedureIndex.ToString("X8")
                                + " for titleid=" + dwTitleId.ToString("X8")
                                + " on db=" + cxn.DataSource);

                            // if we get here, the query worked, so break out of the loop
                            break;
                        }
                        catch (SqlException e)
                        {
                            if (ConsiderExceptionAsConnectionFailure(e))
                            {
                                DBLayer.ReportFailure(cxn.DataSource, e.ToString());

                                Xom.Trace(XomAreaName.matchtrace, LogLevel.L_WARNING,
                                    "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                    + "): "
                                    + e.Message);

                                // No affiliates is not a big deal.  Don't throw, run the
                                // sproc on all the round robined databases for this partition.
                                break;
                            }

                            switch (e.Errors[0].Number)
                            {
                                case SQLDefs.ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK:
                                    // every once in a while, we're going to have
                                    // to retry a query because we use the NOLOCK
                                    // hint to avoid deadlocks.
                                    retries++;
                                    if (retries < NolockRetries)
                                    {
                                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                            "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                            + "): NOLOCK scan error detected, retry = " + retries.ToString()
                                            + ". titleId = " + (TitleId) dwTitleId);
                                        reader.Close();
                                        SearchSessionRetryPerfCounters(MatchXrl.xmatchclient2_ashx,
                                            dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                        continue;
                                    }

                                    // if we've already retried as many times as we're allowed to
                                    // then return empty search results, but update the retry
                                    // failure perf counters so we'll be able to tell if this
                                    // ever happens in practice.
                                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): too many NOLOCK scan errors detected, "
                                        + "returing empty search results, retry = " + retries.ToString()
                                        + ". titleId = " + (TitleId) dwTitleId);
                                    SearchSessionRetryFailurePerfCounters(MatchXrl.xmatchclient2_ashx,
                                        dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                    affiliateResultsSameZone = new SearchResult[0];
                                    affiliateResultsDiffZone = new SearchResult[0];
                                    maxResults = 0;
                                    break;

                                case SQLDefs.ERROR_PARAM_MISSING:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_PARAM_MISSING,
                                        XEvent.Id.MATCH_TITLEBUG_26,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): Required parameter missing."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_COULD_NOT_FIND_STORED_PROC:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ,
                                        XEvent.Id.MATCH_TITLEBUG_27,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): could not find stored proc."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_TOO_MANY_PARAM:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_28,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): Required parameter missing."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_INVALID_PARAM_NAME:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_INVALID_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_29,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): Invalid parameter passed."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                case SQLDefs.ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_DUPLICATE_PARAM,
                                        XEvent.Id.MATCH_TITLEBUG_30,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): Duplicate parameter passed."
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                                default:
                                    throw new XRLException(
                                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                        XEvent.Id.MATCH_CODE_19,
                                        "XMatchFD.DBLayer.GetAffiliateResults(" + seqNum.ToString("X8")
                                        + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                                        + " titleId = " + (TitleId) dwTitleId
                                        + ", queryid=" + dwProcedureIndex.ToString("X8"), e);
                            }
                        }

                        // if we get here, we've given up on our retries, so break
                        // out of the loop.
                        break;
                    } // end while(1) for retries

                    // close the connection to this server, so we can open the next
                    if (reader != null)
                    {
                        reader.Close();
                    }
                    if (cxn != null)
                    {
                        cxn.Close();
                    }

                    // requery if the bucket is in migration, and we haven't already requeried
                    fBucketMigratingRequery = FBucketInMigration(ibsServer) &&
                                            !fBucketMigratingRequery;
                    strServerName = ibsServer.CurrentServerName;
                }
                while (fBucketMigratingRequery);  // end loop over server for a bucket that's in migration
            } // end for loop over RR buckets
        }
        finally
        {
            if (reader != null)
            {
                reader.Close();
            }
            if (cxn != null)
            {
                cxn.Close();
            }
        }

        affiliateResultsSameZone = (SearchResult[])listSameZone.ToArray(typeof(SearchResult));
        affiliateResultsDiffZone = (SearchResult[])listDiffZone.ToArray(typeof(SearchResult));

        // Insert the proper affiliate values into these sessions. The layer below
        // created the X_ATTRIBUTE_AFFILIATE_VALUE attributes, but set them to zero,
        // because it did not know what they were. This is also where we sort the
        // lists by affiliate value.
        WriteAffiliateValues(positiveAffiliateSessions,
            ref affiliateResultsSameZone, ref affiliateResultsDiffZone, seqNum);

        AffiliateRecordPerfCounters(dwTitleId, affiliateResultsSameZone.Length,
            affiliateResultsDiffZone.Length);

        return maxResults;
    }

    private static void WriteAffiliateValues(
        AffiliateSession[] positiveAffiliateSessions,
        ref SearchResult[] affiliateResultsSameZone,
        ref SearchResult[] affiliateResultsDiffZone,
        uint seqNum)
    {
        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.DBLayer.WriteAffiliateValues(" + seqNum.ToString("X8")
            + "): creating final same zone affiliate results");
        WriteAffiliateValues(positiveAffiliateSessions, ref affiliateResultsSameZone, seqNum);
        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL, "XMatchFD.DBLayer.WriteAffiliateValues(" + seqNum.ToString("X8")
            + "): creating final different zone affiliate results");
        WriteAffiliateValues(positiveAffiliateSessions, ref affiliateResultsDiffZone, seqNum);
        return;
    }

    private static void WriteAffiliateValues(
        AffiliateSession[] affiliateSessions,
        ref SearchResult[] searchResults,
        uint seqNum)
    {
        ArrayList orderedResults = new ArrayList();
        foreach (SearchResult searchResult in searchResults)
        {
            foreach (AffiliateSession affiliateSession in affiliateSessions)
            {
                if (searchResult.qwSessionId == affiliateSession.SessionId)
                {
                    InsertSearchResult(orderedResults, searchResult, affiliateSession, seqNum);
                    break;
                }
            }
        }

        searchResults = (SearchResult[])orderedResults.ToArray(typeof(SearchResult));
        return;
    }

    private static void InsertSearchResult(
        ArrayList orderedResults,
        SearchResult searchResult,
        AffiliateSession affiliateSession,
        uint seqNum)
    {
        // attributeIndexOfAffiliateValue was cached when the SearchResult
        // attributes were read in ReadAttributesAndPad.
        System.Diagnostics.Debug.Assert(searchResult.rgAttributes[searchResult.attributeIndexOfAffiliateValue].dwAttributeId == MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE);

        // set the affiliate value correctly
        searchResult.rgAttributes[searchResult.attributeIndexOfAffiliateValue].qwValue = (ulong)affiliateSession.AffiliateValue;

        // figure out where we want to insert this result into the ordered list of results
        int i = 0;
        for (i = 0; i < orderedResults.Count; ++i)
        {
            SearchResult srInResults = (SearchResult)orderedResults[i];

            if (srInResults.rgAttributes[srInResults.attributeIndexOfAffiliateValue].qwValue < (ulong)affiliateSession.AffiliateValue)
            {
                break;
            }
        }

        orderedResults.Insert(i, searchResult);

        Xom.Trace(XomAreaName.matchtrace, LogLevel.L_LOW,
            "XMatchFD.DBLayer.InsertSearchResult("
            + seqNum.ToString("X8")
            + "): inserting session id " + searchResult.qwSessionId.ToString("X16")
            + " with affiliate value " + affiliateSession.AffiliateValue.ToString()
            + " at index " + i.ToString() + " in ordered results, list size is now "
            + orderedResults.Count.ToString());
    }

    // ----------------------------------------------------------------------
    // AffiliateSessionPerfCounters - updates search result perf counters at the end
    // of an search operation
    // ----------------------------------------------------------------------
    private static void AffiliateRecordPerfCounters(
        uint dwTitleId,
        int numInZoneResults,
        int numDiffZoneResults)
    {
        MatchAffiliateCounters titleIdCounters = null;
        if (EnableTitlePerfCounters)
        {
            titleIdCounters = MatchAffiliateCounters.Counters[dwTitleId];
        }

        MatchAffiliateCounters.Counters.TotalAffiliateResultsInZone.IncrementBy(numInZoneResults);
        MatchAffiliateCounters.Counters.AffiliateResultsInZonePerSec.IncrementBy(numInZoneResults);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsInZonePerRequest.IncrementBy(numInZoneResults);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsInZonePerRequestBase.Increment();
        if (titleIdCounters != null)
        {
            titleIdCounters.TotalAffiliateResultsInZone.IncrementBy(numInZoneResults);
            titleIdCounters.AffiliateResultsInZonePerSec.IncrementBy(numInZoneResults);
            titleIdCounters.AverageAffiliateResultsInZonePerRequest.IncrementBy(numInZoneResults);
            titleIdCounters.AverageAffiliateResultsInZonePerRequestBase.Increment();
        }

        MatchAffiliateCounters.Counters.TotalAffiliateResultsOutZone.IncrementBy(numDiffZoneResults);
        MatchAffiliateCounters.Counters.AffiliateResultsOutZonePerSec.IncrementBy(numDiffZoneResults);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsOutZonePerRequest.IncrementBy(numDiffZoneResults);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsOutZonePerRequestBase.Increment();
        if (titleIdCounters != null)
        {
            titleIdCounters.TotalAffiliateResultsOutZone.IncrementBy(numDiffZoneResults);
            titleIdCounters.AffiliateResultsOutZonePerSec.IncrementBy(numDiffZoneResults);
            titleIdCounters.AverageAffiliateResultsOutZonePerRequest.IncrementBy(numDiffZoneResults);
            titleIdCounters.AverageAffiliateResultsOutZonePerRequestBase.Increment();
        }
    }

    // ----------------------------------------------------------------------
    // GetNonAffiliateResults - Retrieves the session details for all sessions
    // not listed in negativeAffiliateSessions that match the other title
    // defined search criteria and are joinable. The results are returned as
    // three sets:
    // 1) same zone, same lang, same country
    // 2) same zone
    // 3) different zone
    // also returns result sets with info about how each of the above result
    // sets was found.
    // ----------------------------------------------------------------------
    public static uint GetNonAffiliateResults(
        byte bNatType,
        uint dwTitleId,
        TitleInfo ti,
        uint dwProcedureIndex,
        XNADDR ClientAddress,
        ushort wNumUsers,
        MatchAttribute[] rgAttributes,
        SearchResult[] affiliateResultsSameZone,
        SearchResult[] affiliateResultsDiffZone,
        AffiliateSession[] negativeAffiliateSessions,
        out SearchResult[] nonAffiliateResultsSameZoneSameLangSameCountry,
        out SearchResult[] nonAffiliateResultsSameZone,
        out SearchResult[] nonAffiliateResultsDiffZone,
        out StandardSearchDetails standardSearchDetailsInZoneSameLangSameCountry,
        out StandardSearchDetails standardSearchDetailsInZone,
        out StandardSearchDetails standardSearchDetailsOutZone,
        uint seqNum)
    {
        bool fIsLegacyXboxTitle = false;
        nonAffiliateResultsSameZoneSameLangSameCountry = new SearchResult[0];
        nonAffiliateResultsSameZone = new SearchResult[0];
        nonAffiliateResultsDiffZone = new SearchResult[0];
     double gamerMu = -1;
     double gamerSigma = -1;

        standardSearchDetailsInZoneSameLangSameCountry = null;
        standardSearchDetailsInZone = null;
        standardSearchDetailsOutZone = null;

        SqlConnection cxn = null;
        SqlCommand cmd = null;
        SqlDataReader reader = null;
        uint maxResults = 0;

        // GetNonAffiliateResults only searches on 1 RR bucket, for perf reasons
        IBucketServer ibsServer = ti.GetNextRRBucketForPartition(
                                    GetGameType(rgAttributes),
                                    GetGameMode(rgAttributes),
                                    true,
                                    seqNum);
        bool bDraining = string.Compare(ibsServer.Info1, TitleInfo.DRAIN_FLAG, true) == 0;

        try
        {
            cmd = CreateXenonSearchSqlCommand(dwTitleId, dwProcedureIndex, "standard");

            MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Output,
                "@i_max_results", maxResults);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@i_negative_sessions", negativeAffiliateSessions.Length);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@si_required_slots", wNumUsers);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@i_client_ip", ByteSwap(ClientAddress.inaOnline));
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@ti_nat_type", bNatType);
            // TODOTHEOM: I believe this isn't used.  Confirm and remove.
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@ti_server_count", 0);

            AddParamAttributesToSqlCommand(rgAttributes, ti, dwTitleId,
                dwProcedureIndex, cmd, fIsLegacyXboxTitle, seqNum);

            string strServerName = GetActiveServer(ibsServer);
            bool fBucketMigratingRequery = false;
            bool fBucketDrainingRequery = false;

            // loop over the servers in the bucket, if the bucket is in migration
            do
            {
                // switch the command to the appropriate server
                cxn = OpenSqlConnectionToMatchDB(strServerName);
                cmd.Connection = cxn;

                // loop so we can retry the query in case of a NOLOCK
                // scanning failure
                int retries = 0;
                while (true)
                {
                    try
                    {
                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                            "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                            + "): Using db=" + cxn.DataSource
                            + " to execute query=" + cmd.CommandText
                            + ". titleId = " + (TitleId) dwTitleId);

                        reader = cmd.ExecuteReader();

                        // there are up to six result sets in this query
                        // 1 - the first result set provides the front door with some information about
                        //     how the query arrived at its results for sessions in the same gamer zone
                        //     with the same language and country
                        // 2 - the second result set contains the same zone, same language,
                        //     same country results
                        // 3 - the third result set provides the front door with some information about
                        //     how the query arrived at its results for sessions in the same gamer zone
                        //     with either language or country different (or both)
                        // 4 - the fourth result set contains the same zone results where either
                        //     language or country (or both) are different.
                        // 5 - the fifth result set provides the front door with some information about
                        //     the query arrived at its results for sessions in different gamer zones
                        // 6 - the sixth result set contains the different zone results
                        //
                        // Note that there will be either 2, 4 or 6 result sets, depending on if
                        // the result set in 2 or 2+4 contains enough rows to satisfy the query.


                        // TODO: merge details through aggregation, as well as merging actual results.

                        // 1 - the query intrumentation stuff
                        ReadStandardSearchDetails(reader,
                            out standardSearchDetailsInZoneSameLangSameCountry, seqNum, dwTitleId);
                        reader.NextResult();

                        // 2 - the same zone, same lang, same country result set

                        ReadAndMergeResults(ref nonAffiliateResultsSameZoneSameLangSameCountry,
                                dwTitleId,
                                dwProcedureIndex,
                                cmd,
                                reader,
                                fIsLegacyXboxTitle,
                                rgAttributes,
                                seqNum,
                                ref gamerMu,
                                ref gamerSigma);

                        if (reader.NextResult())
                        {
                            // 3 - the query intrumentation stuff
                            ReadStandardSearchDetails(reader,
                                out standardSearchDetailsInZone, seqNum, dwTitleId);
                            reader.NextResult();

                            // 4 - the same zone, same lang, same country result set
                            ReadAndMergeResults(ref nonAffiliateResultsSameZone,
                                    dwTitleId,
                                    dwProcedureIndex,
                                    cmd,
                                    reader,
                                    fIsLegacyXboxTitle,
                                    rgAttributes,
                                    seqNum,
                                    ref gamerMu,
                                    ref gamerSigma);

                            if (reader.NextResult())
                            {
                                // 5 - the query instrumentation stuff
                                ReadStandardSearchDetails(reader, out standardSearchDetailsOutZone,
                                    seqNum, dwTitleId);
                                reader.NextResult();

                                // 6 - the different zone result set
                                ReadAndMergeResults(ref nonAffiliateResultsDiffZone,
                                        dwTitleId,
                                        dwProcedureIndex,
                                        cmd,
                                        reader,
                                        fIsLegacyXboxTitle,
                                        rgAttributes,
                                        seqNum,
                                        ref gamerMu,
                                        ref gamerSigma);
                             }
                        }

                        // get max results (closes reader as well)
                        GetMaxResults(dwTitleId, dwProcedureIndex, cmd, reader, false,
                            out maxResults, seqNum);

                        // if we get here, the query worked, so break out of the retry loop
                        break;
                    }
                    catch (SqlException e)
                    {
                        if (ConsiderExceptionAsConnectionFailure(e))
                        {
                            // we couldn't connect to the DB.
                            // Fail the request, and they'll try again later.
                            DBLayer.ReportFailure(cxn.DataSource, e.ToString());

                            throw new XRLException(
                                HResult.XONLINE_E_MATCH_SERVER_ERROR,
                                XEvent.Id.MATCH_COMM_EXECUTE_GET_NON_AFFILIATE_RESULTS,
                                "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                + "): Failed to communicate with " + cxn.DataSource
                                + ".  titleId = " + (TitleId) dwTitleId, e);
                        }

                        switch (e.Errors[0].Number)
                        {
                            case SQLDefs.ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK:
                                // every once in a while, we're going to have
                                // to retry a query because we use the NOLOCK
                                // hint to avoid deadlocks.
                                retries++;
                                if (retries < NolockRetries)
                                {
                                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                        "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                        + "): NOLOCK scan error detected, retry = " + retries.ToString()
                                        + ". titleId = " + (TitleId) dwTitleId);
                                    reader.Close();
                                    SearchSessionRetryPerfCounters(MatchXrl.xmatchclient2_ashx,
                                        dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                    continue;
                                }

                                // if we've already retried as many times as we're allowed to
                                // then return empty search results, but update the retry
                                // failure perf counters so we'll be able to tell if this
                                // ever happens in practice.
                                Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): too many NOLOCK scan errors detected, "
                                    + "returing empty search results, retry = " + retries.ToString()
                                    + ". titleId = " + (TitleId) dwTitleId);
                                SearchSessionRetryFailurePerfCounters(MatchXrl.xmatchclient2_ashx,
                                    dwTitleId, dwProcedureIndex, 0, false /*fWeighted*/);
                                nonAffiliateResultsSameZone = new SearchResult[0];
                                nonAffiliateResultsDiffZone = new SearchResult[0];
                                maxResults = 0;
                                break;

                            case SQLDefs.ERROR_PARAM_MISSING:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_PARAM_MISSING,
                                    XEvent.Id.MATCH_TITLEBUG_31,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): Required parameter missing."
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                            case SQLDefs.ERROR_COULD_NOT_FIND_STORED_PROC:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_INVALID_SEARCH_REQ,
                                    XEvent.Id.MATCH_TITLEBUG_32,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): could not find stored proc."
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                            case SQLDefs.ERROR_TOO_MANY_PARAM:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_TOO_MANY_PARAM,
                                    XEvent.Id.MATCH_TITLEBUG_33,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): Required parameter missing."
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                            case SQLDefs.ERROR_INVALID_PARAM_NAME:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_INVALID_PARAM,
                                    XEvent.Id.MATCH_TITLEBUG_34,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): Invalid parameter passed."
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                            case SQLDefs.ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_DUPLICATE_PARAM,
                                    XEvent.Id.MATCH_TITLEBUG_35,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): Duplicate parameter passed."
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);

                            default:
                                throw new XRLException(
                                    HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                                    XEvent.Id.MATCH_CODE_20,
                                    "XMatchFD.DBLayer.GetNonAffiliateResults(" + seqNum.ToString("X8")
                                    + "): Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                                    + " titleId = " + (TitleId) dwTitleId
                                    + ", queryid=" + dwProcedureIndex.ToString("X8"), e);
                        }
                    }

                    // if we get here, we've given up on our retries, so break
                    // out of the loop.
                    break;
                }

                if (reader != null)
                {
                    reader.Close();
                }
                if (cxn != null)
                {
                    cxn.Close();
                }

                // requery if the bucket is in migration, and we haven't already requeried
                fBucketMigratingRequery = FBucketInMigration(ibsServer) &&
                                        !fBucketMigratingRequery;
                strServerName = ibsServer.CurrentServerName;

                // If the bucket was draining, find a non-draining bucket and query on it too.
                if (bDraining)
                {
                    bDraining = false;
                    fBucketDrainingRequery = true;

                    // Get a non-draining bucket
                    ibsServer = ti.GetNextRRBucketForPartition(GetGameType(rgAttributes), GetGameMode(rgAttributes), false, seqNum);
                }
                else
                {
                    // Not draining, no need to query a second bucket.
                    fBucketDrainingRequery = false;
                }
            }
            while (fBucketMigratingRequery || fBucketDrainingRequery);
            // in here I'll have the end of the in-bucket loop
        }
        finally
        {
            if(reader != null)
            {
                reader.Close();
            }
            if(cxn != null)
            {
                cxn.Close();
            }
        }

        return maxResults;
    }

    // ----------------------------------------------------------------------
    // AssembleResults - Given the four individual arrays of results, this
    // method assembles and returns a single result array of no more than
    // maxResults elements. Affiliate results in the same zone are added
    // first, followed by non-affiliate results in the same zone, followed
    // by affiliate results in different zones, followed by non-affiliate
    // results in different zones.
    // ----------------------------------------------------------------------
    public static SearchResult[] AssembleResults(
        uint dwTitleId,
        uint dwProcedureIndex,
        MatchAttribute[] rgAttributes,
        uint maxResults,
        AffiliateSession[] positiveAffiliateSessions,
        AffiliateSession[] negativeAffiliateSessions,
        SearchResult[] affiliateResultsSameZone,
        SearchResult[] nonAffiliateResultsSameZoneSameLangSameCountry,
        SearchResult[] nonAffiliateResultsSameZone,
        SearchResult[] affiliateResultsDiffZone,
        SearchResult[] nonAffiliateResultsDiffZone,
        out int negSessionsFilteredInZoneSameLangSameCountry,
        out int negSessionsFilteredInZone,
        out int negSessionsFilteredOutZone,
        uint seqNum)
    {
        // The three sets of non-affiliate results are disjoint. However, the non-affiliate
        // results are not disjoint from the affiliate results. Therefore we must filter
        // from the non-affiliate results any sessions that appear in the affiliate results.
        // We must also filter out any negative session ids from the non-affiliate results.
        negSessionsFilteredInZoneSameLangSameCountry = 0;
        negSessionsFilteredInZone = 0;
        negSessionsFilteredOutZone = 0;
        SearchResult[] nonAffiliateResultsSameZoneSameLangSameCountryFiltered = FilterNonAffiliateResults(
            nonAffiliateResultsSameZoneSameLangSameCountry, affiliateResultsSameZone, negativeAffiliateSessions,
            dwTitleId, ref negSessionsFilteredInZoneSameLangSameCountry, true);
        SearchResult[] nonAffiliateResultsSameZoneFiltered = FilterNonAffiliateResults(
            nonAffiliateResultsSameZone, affiliateResultsSameZone, negativeAffiliateSessions,
            dwTitleId, ref negSessionsFilteredInZone, true);
        SearchResult[] nonAffiliateResultsDiffZoneFiltered = FilterNonAffiliateResults(
            nonAffiliateResultsDiffZone, affiliateResultsDiffZone, negativeAffiliateSessions,
            dwTitleId, ref negSessionsFilteredOutZone, false);

        uint resultsLength = maxResults;
        if (affiliateResultsSameZone.Length
            + nonAffiliateResultsSameZoneSameLangSameCountryFiltered.Length
            + nonAffiliateResultsSameZoneFiltered.Length
            + affiliateResultsDiffZone.Length
            + nonAffiliateResultsDiffZoneFiltered.Length < maxResults)
        {
            resultsLength = (uint)(
                + affiliateResultsSameZone.Length
                + nonAffiliateResultsSameZoneSameLangSameCountryFiltered.Length
                + nonAffiliateResultsSameZoneFiltered.Length
                + affiliateResultsDiffZone.Length
                + nonAffiliateResultsDiffZoneFiltered.Length);
        }

        SearchResult[] results = new SearchResult[resultsLength];
        uint resultsRemaining = resultsLength;
        uint resultsFilled = 0;

        if (resultsFilled < resultsLength)
        {
            Array.Copy(affiliateResultsSameZone, 0, results, resultsFilled,
                Math.Min((uint)affiliateResultsSameZone.Length, resultsLength - resultsFilled));
            resultsFilled
                += Math.Min((uint)affiliateResultsSameZone.Length, resultsLength - resultsFilled);
        }

        if (resultsFilled < resultsLength)
        {
            Array.Copy(nonAffiliateResultsSameZoneSameLangSameCountryFiltered, 0, results, resultsFilled,
                Math.Min((uint)nonAffiliateResultsSameZoneSameLangSameCountryFiltered.Length, resultsLength - resultsFilled));
            resultsFilled
                += Math.Min((uint)nonAffiliateResultsSameZoneSameLangSameCountryFiltered.Length, resultsLength - resultsFilled);
        }

        if (resultsFilled < resultsLength)
        {
            Array.Copy(nonAffiliateResultsSameZoneFiltered, 0, results, resultsFilled,
                Math.Min((uint)nonAffiliateResultsSameZoneFiltered.Length, resultsLength - resultsFilled));
            resultsFilled
                += Math.Min((uint)nonAffiliateResultsSameZoneFiltered.Length, resultsLength - resultsFilled);
        }

        if (resultsFilled < resultsLength)
        {
            Array.Copy(affiliateResultsDiffZone, 0, results, resultsFilled,
                Math.Min((uint)affiliateResultsDiffZone.Length, resultsLength - resultsFilled));
            resultsFilled
                += Math.Min((uint)affiliateResultsDiffZone.Length, resultsLength - resultsFilled);
        }

        if (resultsFilled < resultsLength)
        {
            Array.Copy(nonAffiliateResultsDiffZoneFiltered, 0, results, resultsFilled,
                Math.Min((uint)nonAffiliateResultsDiffZoneFiltered.Length, resultsLength - resultsFilled));
            resultsFilled
                += Math.Min((uint)nonAffiliateResultsDiffZoneFiltered.Length, resultsLength - resultsFilled);
        }

        return results;
    }

    // ----------------------------------------------------------------------
    // FilterNonAffiliateResults - creates a filtered set of non affiliate results
    // by removing sessions from 'nonAffilliateResults' that also appear in either
    // 'affiliateResults' or 'negativeAffiliateSessions'. The order of
    // nonAffiliateResults is preserved - sessions are simply removed.
    // ----------------------------------------------------------------------
    private static SearchResult[] FilterNonAffiliateResults(
            SearchResult[] nonAffiliateResults,
            SearchResult[] affiliateResults,
            AffiliateSession[] negativeAffiliateSessions,
            uint dwTitleId,
            ref int negSessionsFilteredOut,
            bool sameZone)
    {
        ArrayList filteredList = new ArrayList();
        foreach (SearchResult sr in nonAffiliateResults)
        {
            if (!ContainsSession(sr.qwSessionId, affiliateResults))
            {
                if (!ContainsSession(sr.qwSessionId, negativeAffiliateSessions))
                {
                    filteredList.Add(sr);
                }
                else
                {
                    negSessionsFilteredOut++;
                }
            }
        }
        return (SearchResult[])filteredList.ToArray(typeof(SearchResult));
    }

    // ----------------------------------------------------------------------
    // ContainsSession - returns true if the SearchResult array contains
    // the session id
    // ----------------------------------------------------------------------
    private static bool ContainsSession(ulong sessionId, SearchResult[] list)
    {
        foreach (SearchResult sr in list)
        {
            if (sr.qwSessionId == sessionId)
            {
                return true;
            }
        }
        return false;
    }

    // ----------------------------------------------------------------------
    // ContainsSession - returns true if the AffiliateSession array contains
    // the session id
    // ----------------------------------------------------------------------
    private static bool ContainsSession(ulong sessionId, AffiliateSession[] list)
    {
        foreach (AffiliateSession affiliateSession in list)
        {
            if (affiliateSession.SessionId == sessionId)
            {
                return true;
            }
        }
        return false;
    }

    // ----------------------------------------------------------------------
    // StandardSearchResultsPerfCounters -
    // ----------------------------------------------------------------------
    private static void StandardSearchResultsPerfCounters(
        uint dwTitleId,
        int numAffiliateResultsSameZone,
        int numNonAffiliateResultsSameZoneSameLangSameCountry,
        int numNonAffiliateResultsSameZone,
        int numAffiliateResultsDiffZone,
        int numNonAffiliateResultsDiffZone,
        int negSessionsFilteredInZoneSameLangSameCountry,
        int negSessionsFilteredInZone,
        int negSessionsFilteredOutZone)
    {
        MatchResultCounters.Counters.TotalResultsXbox360StandardAffiliateInZoneSearch.IncrementBy(numAffiliateResultsSameZone);
        MatchResultCounters.Counters.ResultsPerSecXbox360StandardAffiliateInZoneSearch.IncrementBy(numAffiliateResultsSameZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardAffiliateInZoneSearch.IncrementBy(numAffiliateResultsSameZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardAffiliateInZoneSearchBase.Increment();

        MatchResultCounters.Counters.TotalResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch.IncrementBy(numNonAffiliateResultsSameZoneSameLangSameCountry);
        MatchResultCounters.Counters.ResultsPerSecXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch.IncrementBy(numNonAffiliateResultsSameZoneSameLangSameCountry);
        MatchResultCounters.Counters.AverageResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch.IncrementBy(numNonAffiliateResultsSameZoneSameLangSameCountry);
        MatchResultCounters.Counters.AverageResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearchBase.Increment();

        MatchResultCounters.Counters.TotalResultsXbox360StandardNonAffiliateInZoneSearch.IncrementBy(numNonAffiliateResultsSameZone);
        MatchResultCounters.Counters.ResultsPerSecXbox360StandardNonAffiliateInZoneSearch.IncrementBy(numNonAffiliateResultsSameZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardNonAffiliateInZoneSearch.IncrementBy(numNonAffiliateResultsSameZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardNonAffiliateInZoneSearchBase.Increment();

        MatchResultCounters.Counters.TotalResultsXbox360StandardAffiliateOutZoneSearch.IncrementBy(numAffiliateResultsDiffZone);
        MatchResultCounters.Counters.ResultsPerSecXbox360StandardAffiliateOutZoneSearch.IncrementBy(numAffiliateResultsDiffZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardAffiliateOutZoneSearch.IncrementBy(numAffiliateResultsDiffZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardAffiliateOutZoneSearchBase.Increment();

        MatchResultCounters.Counters.TotalResultsXbox360StandardNonAffiliateOutZoneSearch.IncrementBy(numNonAffiliateResultsDiffZone);
        MatchResultCounters.Counters.ResultsPerSecXbox360StandardNonAffiliateOutZoneSearch.IncrementBy(numNonAffiliateResultsDiffZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardNonAffiliateOutZoneSearch.IncrementBy(numNonAffiliateResultsDiffZone);
        MatchResultCounters.Counters.AverageResultsXbox360StandardNonAffiliateOutZoneSearchBase.Increment();

        MatchAffiliateCounters.Counters.TotalAffiliateResultsFilteredInZoneSameLangSameCountry.IncrementBy(negSessionsFilteredInZoneSameLangSameCountry);
        MatchAffiliateCounters.Counters.AffiliateResultsFilteredInZoneSameLangSameCountryPerSec.IncrementBy(negSessionsFilteredInZoneSameLangSameCountry);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsFilteredInZoneSameLangSameCountryPerRequest.IncrementBy(negSessionsFilteredInZoneSameLangSameCountry);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsFilteredInZoneSameLangSameCountryPerRequestBase.Increment();

        MatchAffiliateCounters.Counters.TotalAffiliateResultsFilteredInZone.IncrementBy(negSessionsFilteredInZone);
        MatchAffiliateCounters.Counters.AffiliateResultsFilteredInZonePerSec.IncrementBy(negSessionsFilteredInZone);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsFilteredInZonePerRequest.IncrementBy(negSessionsFilteredInZone);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsFilteredInZonePerRequestBase.Increment();

        MatchAffiliateCounters.Counters.TotalAffiliateResultsFilteredOutZone.IncrementBy(negSessionsFilteredOutZone);
        MatchAffiliateCounters.Counters.AffiliateResultsFilteredOutZonePerSec.IncrementBy(negSessionsFilteredOutZone);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsFilteredOutZonePerRequest.IncrementBy(negSessionsFilteredOutZone);
        MatchAffiliateCounters.Counters.AverageAffiliateResultsFilteredOutZonePerRequestBase.Increment();

        if (EnableTitlePerfCounters)
        {
            MatchResultCounters titleIdCounters = MatchResultCounters.Counters[dwTitleId];
            MatchAffiliateCounters titleIdAffiliateCounters = MatchAffiliateCounters.Counters[dwTitleId];

            titleIdCounters.TotalResultsXbox360StandardAffiliateInZoneSearch.IncrementBy(numAffiliateResultsSameZone);
            titleIdCounters.ResultsPerSecXbox360StandardAffiliateInZoneSearch.IncrementBy(numAffiliateResultsSameZone);
            titleIdCounters.AverageResultsXbox360StandardAffiliateInZoneSearch.IncrementBy(numAffiliateResultsSameZone);
            titleIdCounters.AverageResultsXbox360StandardAffiliateInZoneSearchBase.Increment();

            titleIdCounters.TotalResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch.IncrementBy(numNonAffiliateResultsSameZoneSameLangSameCountry);
            titleIdCounters.ResultsPerSecXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch.IncrementBy(numNonAffiliateResultsSameZoneSameLangSameCountry);
            titleIdCounters.AverageResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearch.IncrementBy(numNonAffiliateResultsSameZoneSameLangSameCountry);
            titleIdCounters.AverageResultsXbox360StandardNonAffiliateInZoneSameLangSameCountrySearchBase.Increment();

            titleIdCounters.TotalResultsXbox360StandardNonAffiliateInZoneSearch.IncrementBy(numNonAffiliateResultsSameZone);
            titleIdCounters.ResultsPerSecXbox360StandardNonAffiliateInZoneSearch.IncrementBy(numNonAffiliateResultsSameZone);
            titleIdCounters.AverageResultsXbox360StandardNonAffiliateInZoneSearch.IncrementBy(numNonAffiliateResultsSameZone);
            titleIdCounters.AverageResultsXbox360StandardNonAffiliateInZoneSearchBase.Increment();

            titleIdCounters.TotalResultsXbox360StandardAffiliateOutZoneSearch.IncrementBy(numAffiliateResultsDiffZone);
            titleIdCounters.ResultsPerSecXbox360StandardAffiliateOutZoneSearch.IncrementBy(numAffiliateResultsDiffZone);
            titleIdCounters.AverageResultsXbox360StandardAffiliateOutZoneSearch.IncrementBy(numAffiliateResultsDiffZone);
            titleIdCounters.AverageResultsXbox360StandardAffiliateOutZoneSearchBase.Increment();

            titleIdCounters.TotalResultsXbox360StandardNonAffiliateOutZoneSearch.IncrementBy(numNonAffiliateResultsDiffZone);
            titleIdCounters.ResultsPerSecXbox360StandardNonAffiliateOutZoneSearch.IncrementBy(numNonAffiliateResultsDiffZone);
            titleIdCounters.AverageResultsXbox360StandardNonAffiliateOutZoneSearch.IncrementBy(numNonAffiliateResultsDiffZone);
            titleIdCounters.AverageResultsXbox360StandardNonAffiliateOutZoneSearchBase.Increment();

            titleIdAffiliateCounters.TotalAffiliateResultsFilteredInZoneSameLangSameCountry.IncrementBy(negSessionsFilteredInZoneSameLangSameCountry);
            titleIdAffiliateCounters.AffiliateResultsFilteredInZoneSameLangSameCountryPerSec.IncrementBy(negSessionsFilteredInZoneSameLangSameCountry);
            titleIdAffiliateCounters.AverageAffiliateResultsFilteredInZoneSameLangSameCountryPerRequest.IncrementBy(negSessionsFilteredInZoneSameLangSameCountry);
            titleIdAffiliateCounters.AverageAffiliateResultsFilteredInZoneSameLangSameCountryPerRequestBase.Increment();

            titleIdAffiliateCounters.TotalAffiliateResultsFilteredInZone.IncrementBy(negSessionsFilteredInZone);
            titleIdAffiliateCounters.AffiliateResultsFilteredInZonePerSec.IncrementBy(negSessionsFilteredInZone);
            titleIdAffiliateCounters.AverageAffiliateResultsFilteredInZonePerRequest.IncrementBy(negSessionsFilteredInZone);
            titleIdAffiliateCounters.AverageAffiliateResultsFilteredInZonePerRequestBase.Increment();

            titleIdAffiliateCounters.TotalAffiliateResultsFilteredOutZone.IncrementBy(negSessionsFilteredOutZone);
            titleIdAffiliateCounters.AffiliateResultsFilteredOutZonePerSec.IncrementBy(negSessionsFilteredOutZone);
            titleIdAffiliateCounters.AverageAffiliateResultsFilteredOutZonePerRequest.IncrementBy(negSessionsFilteredOutZone);
            titleIdAffiliateCounters.AverageAffiliateResultsFilteredOutZonePerRequestBase.Increment();
        }
    }

    // ----------------------------------------------------------------------
    // DeadXbox - remove sessions from consoles that have gone offline
    // by looping through all SQL servers for the title that the user was
    // in, and calling the deadxbox stored proc.  (which is basically delete)
    // ----------------------------------------------------------------------
    public static HResult DeadXbox(TitleInfo ti, SGADDR sgaddr, string logtype, uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        HResult hr = HResult.S_OK;

        try
        {
            // Make sure we are initialized
            InitCheck(seqNum);

            string[] rgServers = null;
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            Exception lastException = null;
            Exception lastLoggableException = null;

            try
            {
                rgServers = GetServerNamesForAllTitleMatchDBs(ti);
                for(int i = 0; i < rgServers.Length; i++)
                {
                    cxn = OpenSqlConnectionToMatchDB(rgServers[i]);
                    
                    // Allow two tries so that we don't leak a session when a title
                    // is misconfigured in t_match_titles
                    for(    int currentTry = 0, allowedTries = 2;
                            currentTry < allowedTries;
                            currentTry++)
                    {
                        try
                        {
                            cmd = CreateDeadXboxSqlCommand(ti.TitleId, cxn);
                            MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                                    "@retval", (uint)0);
                            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                                    "@b_box_id", DeadXboxMsg.SgAddrToBoxId(sgaddr));

                            // If we failed to issue this command with the parameter the title
                            // is likely misconfigured
                            if(0 == currentTry && ti.DeleteDelaySeconds > 0)
                            {
                                MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                                        "@i_delete_delay_seconds", ti.DeleteDelaySeconds);
                            }

                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                                    "XMatchFD.DBLayer.DeadXbox(" + seqNum.ToString("X8")
                                    + "): Using db=" + cxn.DataSource
                                    + " to execute query=" + cmd.CommandText);

                            cmd.ExecuteNonQuery();

                            hr = (uint)(int)cmd.Parameters["@retval"].Value;
                            if(HResult.Failed(hr))
                            {
                                Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                        "XMatchFD.DBLayer.DeadXbox(" + seqNum.ToString("X8")
                                        + "): Database returned hr = "
                                        + hr);

                                // this will be caught immediately, and we will skip to the next db.
                                throw new Exception("XMatchFD.DBLayer.DeadXbox(" + seqNum.ToString("X8")
                                        + "): DeadXbox sproc returned hr = " + hr);
                            }
                        }
                        catch(Exception e)
                        {
                            if (e is SqlException)
                            {
                                Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                        "XMatchFD.DBLayer.DeadXbox(" + seqNum.ToString("X8")
                                        + "): Unexpected SQL Exception(" + SqlExceptionToString((SqlException)e) + ")");


                                if (ConsiderExceptionAsConnectionFailure((SqlException)e))
                                {
                                    hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                                    DBLayer.ReportFailure(cxn.DataSource, e.ToString());
                                }

                                //
                                // Handle titles that are have t_match_titles.i_delete_delay_seconds
                                // set but have not had the stored procs updated or tables updated
                                // correctly
                                //
                                if (0 == currentTry && ti.DeleteDelaySeconds > 0 && SQLDefs.ERROR_INVALID_PARAM_NAME == ((SqlException)e).Errors[0].Number)
                                {
                                    Xom.NtEvent(XEvent.Id.MATCH_CONFIG_73, e,
                                        "XMatchFD.DBLayer.DeadXbox({0}): Check npdb.t_match_titles.i_delete_delay_seconds for non-zero for titleId = {1}",
                                        seqNum.ToString("X8"), (TitleId) ti.TitleId
                                    );
                                    if (null != cmd)
                                    {
                                        cmd.Cancel();
                                        cmd = null;
                                    }

                                    // Retry without noting the failure
                                    continue;
                                }
                            }
                            else
                            {
                                Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                        "XMatchFD.DBLayer.DeadXbox(" + seqNum.ToString("X8")
                                        + "): Unexpected Exception: " + e.Message);
                            }

                            string strDSN = (cxn == null) ? String.Empty : cxn.DataSource;
                            lastException = new Exception("Failure when calling DeadXbox on sql server "
                                + strDSN + " for titleid " + ti.TitleId.ToString("X8"), e);

                            // grab a copy of the exception if it's loggable
                            if (!(e is ExceptionWithoutEvent))
                            {
                                lastLoggableException = lastException;
                            }
                            // don't rethrow, run the sproc on all the databases
                        }

                        // Normal case, no retry required
                        break;
                    } // End try logic loop
                    cmd = null;
                    if (cxn != null)
                    {
                        cxn.Close();
                        cxn = null;
                    }

                    CompleteDBUsage(rgServers[i]);
                } // End each db connection loop

                if (lastException != null)
                {
                    // We've finished hitting all the databases, and something
                    // went wrong somewhere.  

                    if (lastLoggableException == null)
                    {
                        // all the exceptions were "ExceptionWithoutEvent".  Throw lastException. 
                        throw lastException;
                    }
                    else
                    {
                        throw lastLoggableException;
                    }
                }
            }
            finally
            {
                if(cmd != null)
                {
                    cmd.Cancel();
                }
                if(cxn != null)
                {
                    cxn.Close();
                }
            }
        }
        // no catch and rethrow... the 2 callers (titlechange.cs and deadxbox.cs) are perfectly good at handling exceptions,
        // and adding some text to the exception stack here doesn't really help either.
        finally
        {
            DeadXboxLog(ti.TitleId, sgaddr, logtype, xrteRequestTime, seqNum, hr);
        }

        return hr;
    }

    // ----------------------------------------------------------------------
    // DeadXboxLog - Logs the results of a dead xbox call
    // to the application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void DeadXboxLog(
        uint dwTitleId,
        SGADDR sgaddr,
        string logtype,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchDeadXbox|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(logtype); sb.Append("|");
        sb.Append(dwTitleId.ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(sgaddr.qwXboxId).ToString("X16"));

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }

    // ----------------------------------------------------------------------
    // DeadSg - remove sessions from consoles connected to a specified
    // Security Gateway
    // ----------------------------------------------------------------------
    public static HResult DeadSg(SGADDR sgaddr, uint seqNum)
    {
        XomRequestTimeElapsed xrteRequestTime = new XomRequestTimeElapsed();
        HResult hr = HResult.S_OK;

        try
        {
            // Make sure we are initialized
            InitCheck(seqNum);

            string[] rgServers = null;
            SqlConnection cxn = null;
            SqlCommand cmd = null;
            Exception lastException = null;
            Exception lastLoggableException = null;

            try
            {
                rgServers = GetServerNamesForAllMatchDBs();
                for(int i = 0; i < rgServers.Length; i++)
                {
                    cxn = OpenSqlConnectionToMatchDB(rgServers[i]);
                    
                    try
                    {
                        cmd = CreateDeadSgSqlCommand(cxn);
                        MatchSql.SqlAddParam(cmd, ParameterDirection.ReturnValue,
                            "@retval", (uint) 0 );
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                            "@i_sg_ip", ByteSwap(sgaddr.inaSg));

                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                            "XMatchFD.DBLayer.DeadSg(" + seqNum.ToString("X8")
                            + "): Using db=" + cxn.DataSource
                            + " to execute query=" + cmd.CommandText);

                        cmd.ExecuteNonQuery();

                        hr = (uint)(int)cmd.Parameters["@retval"].Value;
                        if(HResult.Failed(hr))
                        {
                            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                "XMatchFD.DBLayer.DeadSg(" + seqNum.ToString("X8")
                                + "): Database returned hr = "
                                + hr);

                            // this will be caught immediately, and we will skip to the next db.
                            throw new Exception("XMatchFD.DBLayer.DeadSg(" + seqNum.ToString("X8")
                                    + "): DeadSg sproc returned hr = " + hr);
                        }
                    }
                    catch(Exception e)
                    {
                        if (e is SqlException)
                        {
                            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                "XMatchFD.DBLayer.DeadSg(" + seqNum.ToString("X8")
                                + "): Unexpected SQL Exception (" + SqlExceptionToString((SqlException)e) + ")");

                            if (ConsiderExceptionAsConnectionFailure((SqlException)e))
                            {
                                hr = HResult.XONLINE_E_MATCH_SERVER_ERROR;
                                DBLayer.ReportFailure(cxn.DataSource, e.ToString());
                            }
                        }
                        else
                        {
                            Xom.Trace(XomAreaName.matchtrace, LogLevel.L_ERROR,
                                "XMatchFD.DBLayer.DeadSg(" + seqNum.ToString("X8")
                                + "): Unexpected Exception: " + e.Message);
                        }

                        string strDSN = (cxn == null) ? String.Empty : cxn.DataSource;
                        lastException = new Exception("Failure when calling DeadSg on sql server " + strDSN, e);

                        // grab a copy of the exception if it's loggable
                        if (!(e is ExceptionWithoutEvent))
                        {
                            lastLoggableException = lastException;
                        }
                        // don't rethrow, run the sproc on all the databases
                    }
                    cmd = null;
                    if (cxn != null)
                    {
                        cxn.Close();
                        cxn = null;
                    }

                    CompleteDBUsage(rgServers[i]);
                }

                if (lastException != null)
                {
                    // We've finished hitting all the databases, and something
                    // went wrong somewhere.  

                    if (lastLoggableException == null)
                    {
                        // all the exceptions were "ExceptionWithoutEvent".  Throw lastException. 
                        throw lastException;
                    }
                    else
                    {
                        throw lastLoggableException;
                    }
                }
            }
            finally
            {
                if(cmd != null)
                {
                    cmd.Cancel();
                }
                if(cxn != null)
                {
                    cxn.Close();
                }
            }
        }
        // no catch and rethrow... the 2 callers (titlechange.cs and deadxbox.cs) are perfectly good at handling exceptions,
        // and adding some text to the exception stack here doesn't really help either.
        finally
        {
            DeadSgLog(sgaddr, xrteRequestTime, seqNum, hr);
        }

        return hr;
    }

    // ----------------------------------------------------------------------
    // DeadSgLog - Logs the results of a dead xbox call
    // to the application log file and reporting server.
    // ----------------------------------------------------------------------
    public static void DeadSgLog(
        SGADDR sgaddr,
        XomRequestTimeElapsed xrteRequestTime,
        uint seqNum,
        HResult hr)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("MatchDeadSg|");
        sb.Append(seqNum.ToString("X8")); sb.Append("|");
        sb.Append(xrteRequestTime.MillisecondsElapsed.ToString()); sb.Append("|");
        sb.Append(hr.ToString()); sb.Append("|");
        sb.Append(ByteSwap(sgaddr.inaSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(sgaddr.dwSpiSg).ToString("X8")); sb.Append("|");
        sb.Append(ByteSwap(sgaddr.qwXboxId).ToString("X16"));

        string line = sb.ToString();

        Xom.Log(XomAreaName.log, line);
        Xom.Log(XomAreaName.Reporting_v2, line);
    }

    private static bool m_fSettingChangeHandlerAttached = false;
    public static void SettingChangeHandler(
        object sender,
        SettingChangeEventArgs e)
    {
        switch (e.Setting)
        {
        case Setting.xmatchfd_defaultSessionExpiration:
            DefaultSessionExpiration = Int32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_relaxXenonValidation:
            if (e.ValueNew == "1" || e.ValueNew == "yes"
                || e.ValueNew == "true" || e.ValueNew == "on")
            {
                RelaxXenonValidation = true;
            }
            else
            {
                RelaxXenonValidation = false;
            }
            break;

        case Setting.xmatchfd_sessioncacheexpiration:
            SessionCacheExpiration = UInt32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_disableAffiliateQuery:
            if (e.ValueNew == "1" || e.ValueNew == "yes"
                || e.ValueNew == "true" || e.ValueNew == "on")
            {
                DisableAffiliateQuery = true;
            }
            else
            {
                DisableAffiliateQuery = false;
            }
            break;

        case Setting.xmatchfd_valueOfFriend:
            ValueOfFriend = Int32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_valueOfPositiveFeedback:
            ValueOfPositiveFeedback = Int32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_valueOfCompletedGame:
            ValueOfCompletedGame = Int32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_valueOfNegativeFeedback:
            ValueOfNegativeFeedback = Int32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_valueOfAvoidingMe:
            ValueOfAvoidingMe = Int32.Parse(e.ValueNew);
            break;

        case Setting.xmatchfd_enableTitlePerfCounters:
            if (e.ValueNew == "1" || e.ValueNew == "yes"
                || e.ValueNew == "true" || e.ValueNew == "on")
            {
                EnableTitlePerfCounters = true;
            }
            else
            {
                EnableTitlePerfCounters = false;
            }
            break;

        case Setting.xmatchfd_nolockRetries:
            NolockRetries  = Int32.Parse(e.ValueNew);
            break;
        case Setting.xmatchfd_insertRetries:
            InsertRetries  = Int32.Parse(e.ValueNew);
            break;
        case Setting.xmatchfd_enableAuthCheck:
            if (e.ValueNew == "1" || e.ValueNew == "yes"
                || e.ValueNew == "true" || e.ValueNew == "on")
            {
                EnableAuthCheck = true;
            }
            else
            {
                EnableAuthCheck = false;
            }
            break;
        }
    }

    // --------------------------------------------------------------------
    // InitCheck - when first called, this method reads title information
    // from npdb and caches it in memory. Subsequent calls simply check
    // to ensure initialization has been performed, then returns.
    // --------------------------------------------------------------------
    public static void InitCheck(uint seqNum)
    {
        // TODOTHEOM: we should be able to reload title info per title, rather than
        // having to reload all titles when m_fInitialized becomes false.

        // TODOTHEOM: it's kinda funky to go through my own stored proc for
        // all of this retrieval from t_int_buckets.  Maybe I can add GetBucketsForInterface()
        // and GetBucketsForTitleInterface()?

        m_rwlInitialized.AcquireReaderLock(LockTimeout);
        try
        {
            if (m_fInitialized)
            {
                // already initialized, so return
                return;
            }

            LockCookie lc = m_rwlInitialized.UpgradeToWriterLock(LockTimeout);
            try
            {
                // Check that another thread blocked on this writer
                // lock didn't already do the initialization
                if (m_fInitialized)
                {
                    // already initialized, so return
                    return;
                }

                // first, flush the config cache so anything we do from
                // here forward uses fresh information.
                Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                    "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                    + "): calling Config.DiscardCachedValues()");
                Config.DiscardCachedValues();

                // refresh our setting properties
                // we already have the writer lock, so bypass the set property
                m_defaultSessionExpiration =
                    Config.GetIntSetting(Setting.xmatchfd_defaultSessionExpiration);
                m_relaxXenonValidation =
                    Config.GetBoolSetting(Setting.xmatchfd_relaxXenonValidation);
                m_sessionCacheExpiration =
                    Config.GetUIntSetting(Setting.xmatchfd_sessioncacheexpiration);
                m_disableAffiliateQuery =
                    Config.GetBoolSetting(Setting.xmatchfd_disableAffiliateQuery);
                m_valueOfFriend =
                    Config.GetIntSetting(Setting.xmatchfd_valueOfFriend);
                m_valueOfPositiveFeedback
                    = Config.GetIntSetting(Setting.xmatchfd_valueOfPositiveFeedback);
                m_valueOfCompletedGame
                    = Config.GetIntSetting(Setting.xmatchfd_valueOfCompletedGame);
                m_valueOfNegativeFeedback
                    = Config.GetIntSetting(Setting.xmatchfd_valueOfNegativeFeedback);
                m_valueOfAvoidingMe
                    = Config.GetIntSetting(Setting.xmatchfd_valueOfAvoidingMe);
                m_enableTitlePerfCounters
                    = Config.GetBoolSetting(Setting.xmatchfd_enableTitlePerfCounters);
                m_nolockRetries
                    = Config.GetIntSetting(Setting.xmatchfd_nolockRetries);
                m_insertRetries
                    = Config.GetIntSetting(Setting.xmatchfd_insertRetries);
                m_enableAuthCheck
                    = Config.GetBoolSetting(Setting.xmatchfd_enableAuthCheck);

                // attach our change handler, if we haven't already
                if (!m_fSettingChangeHandlerAttached)
                {
                    Config.SettingChange
                        += new SettingChangeEventHandler(SettingChangeHandler);
                }


                // we get a list of all buckets for the match interface from
                // t_interface_buckets, skipping config because we want t a bunch
                // of match-specific logic.  As a result, we don't get
                // auto-notifications of new buckets or bucket migrations.

                // TODO2THEOM: is there any way to get away from having 2 SQL connections?
                // at least rename cxn to something specific.
                SqlConnection cxnConfig = null;
                SqlConnection cxnTitleBuckets = null;
                SqlCommand cmdGetTitleConfig = null;
                SqlCommand cmdGetTitleBuckets = null;
                SqlDataReader rdrGenericInfo = null;
                SqlDataReader rdrPartitionInfo = null;
                try
                {
                    // first, get the generic config info for all titles from the npdb

                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): looking up npdb interface");
                    cxnConfig = new SqlConnection(ConfigUtil.NpdbConnectionString);
                    cxnConfig.Open();
                    cmdGetTitleConfig = new SqlCommand("p_match_title_get_all", cxnConfig);
                    cmdGetTitleConfig.CommandType = CommandType.StoredProcedure;

                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): calling p_match_title_get_all");

                    rdrGenericInfo = cmdGetTitleConfig.ExecuteReader();


                    // next, get the list of buckets for all titles from the NPDB.
                    // the stored proc orders the results by titleId

                    cxnTitleBuckets = new SqlConnection(ConfigUtil.NpdbConnectionString);
                    cxnTitleBuckets.Open();

                    // TODOTHEOM: can I use p_config_get_interface_all_buckets???
                    cmdGetTitleBuckets = new SqlCommand("p_match_get_all_match_buckets", cxnTitleBuckets);
                    cmdGetTitleBuckets.CommandType = CommandType.StoredProcedure;
                    MatchSql.SqlAddParam(cmdGetTitleBuckets, ParameterDirection.Input, "@vc_environment", Config.Environment);
                    MatchSql.SqlAddParam(cmdGetTitleBuckets, ParameterDirection.Input, "@vc_interface", Interface.xmatch);

                    Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): calling p_match_get_all_buckets");

                    rdrPartitionInfo = cmdGetTitleBuckets.ExecuteReader();
                    rdrPartitionInfo.Read();  // advance to the first item
                    bool fEOF = false; // used to remember whether we've used up the titlebuckets rowset.

                    // Fill in a local hash table with the title info, then we
                    // will swap it into the instance member if we succeed
                    Hashtable hashTitleInfo = new Hashtable();

                    // also fill in a hash that'll keep a list of all servers
                    // across all titles.
                    Hashtable hashMatchServers = new Hashtable();

                    while(rdrGenericInfo.Read())
                    {
                        // Add results to the local hash table
                        uint dwTitleId
                            = (uint)(int)rdrGenericInfo["i_title_id"];
                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                            "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                            + "): Found titleId = " + (TitleId) dwTitleId);

                        uint dwSessionExpiration
                            = (uint)(int)rdrGenericInfo["i_session_expiration"];
                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                            "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                            + "): i_session_expiration=" + dwSessionExpiration.ToString()
                            + " for titleId = " + (TitleId) dwTitleId);

                        // TODO2THEOM: remove the strDBList and it's SQL param.  This is now built from t_int_buckets.
                        string strDBList
                            = (string)rdrGenericInfo["vc_db_list"];
                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                            "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                            + "): vc_db_list=" + strDBList
                            + " for titleId = " + (TitleId) dwTitleId);

                        bool fForceXenonBehavior = false;
                        if (!IsNullColumn(rdrGenericInfo, "i_force_xenon_behavior"))
                        {
                            // The column is not null, let's see what it says.
                            // A non-zero value means to force xenon behavior
                            // even if the call came in from an xbox 1 xrl.
                            uint dwForceXenonBehavior
                                = (uint)(int)rdrGenericInfo["i_force_xenon_behavior"];
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                                "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                                + "): i_force_xenon_behavior=" + dwForceXenonBehavior.ToString()
                                + " for titleId = " + (TitleId) dwTitleId);
                            if (dwForceXenonBehavior != 0)
                            {
                                fForceXenonBehavior = true;
                            }
                        }

                        uint dwDeleteDelaySeconds
                            = (uint)(int)rdrGenericInfo["i_delete_delay_seconds"];
                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                                "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                                + "): i_delete_delay_seconds=" + dwDeleteDelaySeconds.ToString()
                                + " for titleId = " + (TitleId) dwTitleId);

                        byte bRevokeCrossPlatform = TitleInfo.INVALID_CROSS_PLATFORM_REVOKE;
                        if(!IsNullColumn(rdrGenericInfo, "ti_revoke_cross_platform"))
                        {
                            bRevokeCrossPlatform = (byte)rdrGenericInfo["ti_revoke_cross_platform"];
                        }

                        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                                "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                                + " ): ti_revoke_cross_platform=" + bRevokeCrossPlatform.ToString("X")
                                + " for titleId = " + (TitleId) dwTitleId);



                        // iterate through the list of buckets for this title (they're together because
                        // the stored proc results are sorted by title) and make a hash of game type
                        // + game mode => a count of RR buckets.

                        // we need to enforce that RRIDs must be zero based, consecutive,
                        // and have a max < 16.
                        // we know they will be unique because bucketid is a sql key, therefore
                        // if max >=16 OR max != count-1, we have a problem.

                        Hashtable hashTitlePartitions = new Hashtable();
                        Hashtable hashTitleServers = new Hashtable();
                        uint dwBucketCount = 0;

                        // XONLINE:106599 -- spin the rdrPartitionInfo reader forward until it matches
                        // up with the rdrGenericInfo (titleid) reader.  This handles the case where there
                        // are titleids in rdrPartitionInfo that are not present in rdrGenericInfo.
                        // The inverse (titleid in rdrGenericInfo but not in rdrPartitionInfo) is handled
                        // by the main loop.

                        while (!fEOF && (uint)(int)rdrPartitionInfo["i_title_id"] < dwTitleId)
                        {
                            fEOF = !rdrPartitionInfo.Read();
                        }

                        while(!fEOF && (uint)(int)rdrPartitionInfo["i_title_id"] == dwTitleId)
                        {
                            dwBucketCount++;
                            uint dwBucketId = (uint)(int)rdrPartitionInfo["i_bucket"];
                            uint dwPartition = dwBucketId & 0xFFFFFF00;  // TODOTHEOM: put these bit masks in a const.
                            byte bRRID = (byte)(dwBucketId & 0x000000FF);
                            bool bDraining = string.Compare((string)rdrPartitionInfo["vc_info1"], TitleInfo.DRAIN_FLAG, true) == 0;
                            if(hashTitlePartitions.ContainsKey(dwPartition))
                            {
                                RRIDInfo rrInfo = (RRIDInfo)hashTitlePartitions[dwPartition];
                                // if this partition's RRID is greater than max, it becomes max
                                if(bRRID > rrInfo.bMaxAll)
                                {
                                    rrInfo.bMaxAll = bRRID;
                                }
                                if (!bDraining)
                                {
                                    if (bRRID > rrInfo.bMaxNotDraining)
                                    {
                                        rrInfo.bMaxNotDraining = bRRID;
                                    }
                                }
                            }
                            else
                            {
                                RRIDInfo rriTemp = new RRIDInfo();
                                rriTemp.bMaxAll = bRRID;
                                rriTemp.bCounterAll = 1;
                                rriTemp.bMaxNotDraining = bRRID;
                                rriTemp.bCounterNotDraining = 1;
                                hashTitlePartitions.Add(dwPartition, rriTemp);
                            }

                            // we need a list of servers that are associated with this title.
                            // each server may show up multiple times in the bucket list, so
                            // hash to remove dupes.
                            string strServerName = ((string)rdrPartitionInfo["vc_server"]).ToLower();
                            string strNextServerName = ((string)rdrPartitionInfo["vc_next_server"]).ToLower();
                            if (!hashTitleServers.ContainsKey(strServerName))
                            {
                                hashTitleServers.Add(strServerName, null); // no value...
                            }
                            // if the bucket's going to be migrated, we'll need to server list(s) to contain
                            // both servers of the migrating pair.
                            if (!hashTitleServers.ContainsKey(strNextServerName))
                            {
                                hashTitleServers.Add(strNextServerName, null); // no value...
                            }

                            // ditto for the global server list
                            if (!hashMatchServers.ContainsKey(strServerName))
                            {
                                hashMatchServers.Add(strServerName, null);
                            }
                            // if the bucket's going to be migrated, we'll need to server list(s) to contain
                            // both servers of the migrating pair.
                            if (!hashMatchServers.ContainsKey(strNextServerName))
                            {
                                hashMatchServers.Add(strNextServerName, null);
                            }

                            fEOF = !rdrPartitionInfo.Read();
                        }

                        // make the server hash for this title into an array.
                        string[] rgstrTitleDatabases = new string[hashTitleServers.Keys.Count];
                        hashTitleServers.Keys.CopyTo(rgstrTitleDatabases, 0); // 0 = copy to the beginning of the array.

                        if (dwBucketCount > 0)
                        {
                            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
                                "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                                + "): Configured titleId = " + (TitleId) dwTitleId);
                            hashTitleInfo.Add(dwTitleId,
                                new TitleInfo(
                                    dwTitleId,
                                    dwSessionExpiration,
                                    fForceXenonBehavior,
                                    rgstrTitleDatabases,
                                    hashTitlePartitions,
                                    dwDeleteDelaySeconds,
                                    bRevokeCrossPlatform)
                            );
                        }
                        else
                        {
                            // log an event so we can figure out why a title we think should
                            // work isn't working...
                            Xom.NtEvent(XEvent.Id.MATCH_CONFIG_68,
                                "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                                + "): No valid buckets found for title = " + (TitleId) dwTitleId
                                + ", skipping this title.");
                        }
                    }

                    // make the global hash of servers into an array.
                    string[] rgstrDatabases = new string[hashMatchServers.Keys.Count];
                    hashMatchServers.Keys.CopyTo(rgstrDatabases, 0); // 0 = copy to the beginning of the array.

                    // Make our local copy the title info that gets used
                    m_hashTitleInfo = hashTitleInfo;
                    m_rgstrDatabases = rgstrDatabases;

                }
                catch(SqlException e)
                {
                    Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): Unexpected SQL exception!"
                        + "e.Message: " + e.Message
                        + "e.StackTrace: " + e.StackTrace);
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                        XEvent.Id.MATCH_CODE_25,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): Unexpected SQL Exception.", e);
                }
                catch(Exception e)
                {
                    Xom.Trace(XomAreaName.matchtrace, LogLevel.L_NORMAL,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): Unexpected exception!"
                        + "e.Message: " + e.Message
                        + "e.StackTrace: " + e.StackTrace);
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_SERVER_ERROR,
                        XEvent.Id.MATCH_CODE_26,
                        "XMatchFD.DBLayer.InitCheck(" + seqNum.ToString("X8")
                        + "): Unexpected Exception.", e);
                }
                finally
                {
                    //if(cmdGetTitleConfig != null)
                    //{
                    //    cmdGetTitleConfig.Cancel();
                    //}
                    if(rdrGenericInfo != null)
                    {
                        rdrGenericInfo.Close();
                    }
                    if(rdrPartitionInfo != null)
                    {
                        rdrPartitionInfo.Close();
                    }
                    if(cxnConfig != null)
                    {
                        cxnConfig.Close();
                    }
                    if (cxnTitleBuckets != null)
                    {
                        cxnTitleBuckets.Close();
                    }
                }

                // If we get here, initialization is complete so we can
                // safely set this member variable to false and release the lock
                m_fInitialized = true;
            }
            finally
            {
                m_rwlInitialized.DowngradeFromWriterLock(ref lc);
            }
        }
        finally
        {
            m_rwlInitialized.ReleaseReaderLock();
        }

        return;
    }

    // -----------------------------------------------------------------------
    // GetTitleInfo - returns title information for a specified title
    // -----------------------------------------------------------------------
    public static TitleInfo GetTitleInfo(uint dwTitleId, uint seqNum, bool noThrow)
    {
        // make sure the hash table has been initialized
        InitCheck(seqNum);

        if(!m_hashTitleInfo.Contains(dwTitleId))
        {
            if (noThrow)
            {
                // some callers expect that a title may not be there
                // and we don't want to incur the overhead of a throw
                // catch for an expected case.
                return null;
            }

            // this caller didn't expect the title to be missing, so throw
            throw new XRLException(
                HResult.XONLINE_E_MATCH_INVALID_TITLE_ID,
                XEvent.Id.MATCH_CONFIG_69,
                "XMatchFD.DBLayer.GetTitleInfo(" + seqNum.ToString("X8")
                + "): title id not found. "
                + "May need to run 'reloadtitleinfo' xmgmt command. "
                + "titleId = " + (TitleId) dwTitleId);
        }

        return (TitleInfo)m_hashTitleInfo[dwTitleId];
    }

    // -----------------------------------------------------------------------
    // GetTitleInfo - returns title information for a specified title
    // -----------------------------------------------------------------------
    public static TitleInfo GetTitleInfo(uint dwTitleId, uint seqNum)
    {
         return GetTitleInfo(dwTitleId, seqNum, false);
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the generation of a key exchange key
    // -----------------------------------------------------------------------
    private static byte[] GenerateKeyExchangeKey()
    {
        // The key exchange key is just a series of random bytes
        byte[] rgbKeyExchangeKey
            = new byte[MatchDefs.X_MATCH_KEY_EXCHANGE_KEY_LEN];
        m_rng.GetBytes(rgbKeyExchangeKey);
        return rgbKeyExchangeKey;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the generation of a session id, which is
    // trickier that it may first appear
    // -----------------------------------------------------------------------
    private static ulong GenerateSessionId(
        byte bServerType,
        byte bDBUsed,
        MatchAttribute[] attributes)
    {
        // A session id is a 64 bit value. The top 48 bits are
        // generated randomly. The last 16 bits are used to
        // encode the server type of the session host,
        // the database number this session is assigned to,
        // and the table within that database the session
        // is present in.

        // The lowest nibble contains the database index

        // The next lowest nibble contains the server type
        // (System link sessions, which are not advertized in match
        // will have a different server type, and therefore an id
        // generated by a client for a system link game should never
        // match an id picked by the server.)

        // The next lowest nibble contains the table number.
        // Starting with xbox 360, each game type is getting its
        // own match table. This is so we can use a different clustered
        // index for standard matches vs ranked matches.

        // Note that session ids are unique across all match
        // database servers and tables because all sessions on
        // a particular database server in a particular table
        // will have the same database ids and table ids embedded
        // in them, and the primary key on each server
        // guarantees no duplicates within a server. The session
        // ids on two different servers or two different tables
        // will always be different because the database id and table id
        // embedded in the session id will always be different.

        // The front door decides to create a new session
        // instead of updating an existing session by looking at the
        // session id passed in the client request. If the
        // top 48 bits of the session id are zero, then
        // the front door may decide create a new session. Therefore
        // we must not choose a session id with all zeros
        // in the top 48 bits!
        ulong qwSessionId = 0;
        while((qwSessionId & 0xFFFFFFFFFFFF0000) == 0)
        {
            byte[] rgbSessionId = new byte[8];
            m_rng.GetBytes(rgbSessionId);
            BinaryReader reader
                = new BinaryReader(new MemoryStream(rgbSessionId));
            qwSessionId = reader.ReadUInt64();
        }

        // defaults to zero if no game type attribute, which will be the
        // case for xbox 1 titles.
        byte gameType = GetGameType(attributes);
        byte gameMode = GetGameMode(attributes);

        // now mask in the session server type, database id, and table id
        // in the low byte. The database id is in the lowest nibble
        // and the server type is in the next lowest nibble.
        // (see MatchDefs.XNET_XNKID_MASK and MatchDefs.XNET_XNKID_DBINDEX_MASK)
        ushort wSessionLowBits = 0; // the last 16 bits of the sessionid
        // TODO2THEOM: consts for type and mode shift?
        wSessionLowBits |= (ushort)((gameMode << 10) | (gameType << 8) |
                            bServerType | bDBUsed);

        qwSessionId = (qwSessionId & 0xFFFFFFFFFFFF0000) | wSessionLowBits;

        return qwSessionId;
    }

    // -----------------------------------------------------------------------
    // this method encapsulates the details of the connection string
    // we use to access the match dbs
    // -----------------------------------------------------------------------
    private static SqlConnection OpenSqlConnectionToMatchDB(
        string datasource)
    {
        SqlConnection cxn = null;

        DBLayer.CheckForFastFail(datasource);

        try
        {
            cxn = new SqlConnection("Initial Catalog=xmatch;Integrated Security=SSPI;Data Source=" + datasource);

            cxn.Open();

        }
        catch(SqlException e)
        {
            if (ConsiderExceptionAsConnectionFailure(e))
            {
                DBLayer.ReportFailure(datasource, e.ToString());

                throw new XRLException(
                    HResult.XONLINE_E_MATCH_SERVER_ERROR,
                    XEvent.Id.MATCH_COMM_OPEN_CONNECTION,
                    "XMatchFD.DBLayer.OpenSqlConnectionToMatchDB: Failed to communicate with " + datasource, e);
            }

            throw;
        }
        finally
        {
            DBLayer.ReportSuccess(datasource);  // ok to report Success after Failure
        }

        return cxn;
    }

    // -----------------------------------------------------------------------
    // The DeadSg operation needs to hit all the known matchdbs,
    // but we want to be careful that we don't reset the list of matchdbs
    // halfway through the operation while we iterating through them.
    // This method grabs the list of known matchdbs at a particular moment in
    // time in a threadsafe fashion, and opens connections to each of those
    // databases. The caller can safely iterate through the array of
    // connections without worrying the list will change part way through
    // the iteration.
    // -----------------------------------------------------------------------
    private static string[] GetServerNamesForAllMatchDBs()
    {
        return m_rgstrDatabases;
    }

    // -----------------------------------------------------------------------
    // When searching for deadxbox sessions, we need to search on all the databases
    // that have been configured to support this title. This method opens connections
    // to those databases, given the TitleInfo for the title.  Connections are
    // opened starting at a semi-random offset so as to distribute load for
    // operations that might not need them all (such as searches that are fulfilled
    // by the first couple servers without requiring hitting them all.
    // -----------------------------------------------------------------------
    private static string[] GetServerNamesForAllTitleMatchDBs(TitleInfo ti)
    {
        string[] rgServers = new string[ti.DBCount];

        int startingIndex = ti.NextDBIndex;

        for (byte i = 0; i < ti.DBCount; ++i)
        {
            byte bDBIndex = (byte)(((startingIndex + i) % ti.DBCount));
            rgServers[i] = ti.GetDB(bDBIndex);
        }

        return rgServers;
    }

    // -----------------------------------------------------------------------
    // The insert, update, and delete stored procs generated for each title
    // have a root name that is fixed, with a suffix based on the titleid.
    // This method encapsulates attaching the suffix and creating a
    // SqlCommand object, given a particular root stored proc name and titleid
    // -----------------------------------------------------------------------
    private static SqlCommand CreateTitleSqlCommand(
        string storedProcRoot,
        uint dwTitleId,
        bool isLegacyXboxTitle,
        SqlConnection cxn)
    {
        SqlCommand cmd = new SqlCommand(storedProcRoot
            + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle),
            cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the generation of stored proc and attribute name,
    // suffixes
    // -----------------------------------------------------------------------
    private static string IdToSqlSuffix(
        uint id,
        bool isLegacyXboxTitle)
    {
        if (isLegacyXboxTitle)
        {
            // legacy titles use decimal suffixes
            return id.ToString();
        }
        // xenon titles use hex suffixes, plus "v2" designation
        // for the latest release to allow upgrade
        return "0x" + id.ToString("X8");
    }


    // -----------------------------------------------------------------------
    // This method encapsulates the name of the insert session stored proc
    // -----------------------------------------------------------------------
    private static SqlCommand CreateInsertSqlCommand(
        uint dwTitleId,
        bool isLegacyXboxTitle)
    {
        string procName;
        if (isLegacyXboxTitle)
        {
            procName = "p_match_session_insert_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle);
        }
        else
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle)
                + "_insert";
        }
        SqlCommand cmd = new SqlCommand(procName);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the root name of the update session stored proc
    // -----------------------------------------------------------------------
    private static SqlCommand CreateUpdateSqlCommand(
        uint dwTitleId,
        bool isLegacyXboxTitle)
    {
        string procName;
        if (isLegacyXboxTitle)
        {
            procName = "p_match_session_update_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle);
        }
        else
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle)
                + "_update";
        }
        SqlCommand cmd = new SqlCommand(procName);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }


    // -----------------------------------------------------------------------
    // This method encapsulates the root name of the update session stored proc
    // should only be called for 360 titles
    // -----------------------------------------------------------------------
    private static SqlCommand CreateUpdateCompleteSqlCommand(
        uint dwTitleId,
        SqlConnection cxn)
    {
        string procName;
        procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false) // islegacyxboxtitle
                + "_updatecomplete";
        SqlCommand cmd = new SqlCommand(procName, cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the root name of the delete session stored proc
    // -----------------------------------------------------------------------
    private static SqlCommand CreateDeleteSqlCommand(
        uint dwTitleId,
        bool isLegacyXboxTitle,
        SqlConnection cxn)
    {
        string procName;
        if (isLegacyXboxTitle)
        {
            procName = "p_match_session_delete_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle);
        }
        else
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle)
                + "_delete";
        }
        SqlCommand cmd = new SqlCommand(procName, cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // The session search stored procs generated for each title have a fixed
    // root name plus with a suffix based on the titleid and a query number,
    // a.k.a. procedure index. This method encapsulates attaching this suffix
    // and creating a SqlCommand object, given titleid and procedure index.
    // This method is only for use with legacy Xbox titles.
    // -----------------------------------------------------------------------
    private static SqlCommand CreateLegacySearchSqlCommand(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlConnection cxn)
    {
        string procName;
        procName = "p_match_search_" + IdToSqlSuffix(dwTitleId, true)
            + "_" + IdToSqlSuffix(dwProcedureIndex, true);
        SqlCommand cmd = new SqlCommand(procName, cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // The system findbyid search stored procs generated for each title have a fixed
    // root name plus with a suffix based on the titleid. This method encapsulates
    // attaching this suffix and creating a SqlCommand object, given titleid.
    // This method is only for use with Xbox 360 titles.
    // -----------------------------------------------------------------------
    private static SqlCommand CreateFindByIdSearchSqlCommand(
        uint dwTitleId,
        uint dwProcedureIndex)
    {
        string procName = "";

        if(MatchDefs.X_SSINDEX_GET_SESSION_ATTRIBUTES == dwProcedureIndex)
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false)
                + "_search_findbyid_get_attributes";
        }
        else if(MatchDefs.X_SSINDEX_GET_SESSION_LIST == dwProcedureIndex)
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false)
                + "_search_findbyid_list";
        }
        else
        {
            // This used to be the default should map to X_SSINDEX_GET_SESSION
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false)
                + "_search_findbyid";
        }

        SqlCommand cmd = new SqlCommand(procName);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // The standard search stored procs generated for each title have a fixed
    // root name plus with a suffix based on the titleid and a query number,
    // a.k.a. procedure index. This method encapsulates attaching this suffix
    // and creating a SqlCommand object, given titleid and procedure index.
    // This method is only for use with Xbox 360 titles.
    // -----------------------------------------------------------------------
    private static SqlCommand CreateXenonSearchSqlCommand(
        uint dwTitleId,
        uint dwProcedureIndex,
        string strDecoration) // decoration will be ranked, standard, weighted
    {
        string procName;
        procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false)
            + "_" + IdToSqlSuffix(dwProcedureIndex, false)
            + "_search_" + strDecoration ;
        SqlCommand cmd = new SqlCommand(procName);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // The standard search stored procs generated for each title have a fixed
    // root name plus with a suffix based on the titleid and a query number,
    // a.k.a. procedure index. This method encapsulates attaching this suffix
    // and creating a SqlCommand object, given titleid and procedure index.
    // This method is only for use with Xbox 360 titles.
    // -----------------------------------------------------------------------
    private static SqlCommand CreateAffiliatesSearchSqlCommand(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlConnection cxn)
    {
        string procName;
        procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false)
            + "_" + IdToSqlSuffix(dwProcedureIndex, false)
            + "_search_affiliates";
        SqlCommand cmd = new SqlCommand(procName, cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the name of the dead xbox stored proc, and the
    // creation of a SqlCommand to call it. This stored proc is not title
    // specific.
    // -----------------------------------------------------------------------
    private static SqlCommand CreateDeadXboxSqlCommand(
        uint dwTitleId,
        SqlConnection cxn)
    {
        SqlCommand cmd = new SqlCommand("p_match_session_0x"
            + dwTitleId.ToString("X8") + "_deadxbox", cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the name of the dead sg stored proc, and the
    // creation of a SqlCommand to call it. This stored proc is not title
    // specific.
    // -----------------------------------------------------------------------
    private static SqlCommand CreateDeadSgSqlCommand(SqlConnection cxn)
    {
        SqlCommand cmd = new SqlCommand("p_match_dead_sg", cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method removes the xbox style datatype from a property or context
    // id
    // -----------------------------------------------------------------------
    private static uint RemoveXboxDatatype(uint id)
    {
        return id & (~MatchDefs.X_ATTRIBUTE_DATATYPE_MASK);
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the generation of attribute names given
    // an attribute id
    // -----------------------------------------------------------------------
    private static string IdToAttrName(uint id, bool fIsLegacyXboxTitle)
    {
        // Attribute names are just the id suffix tacked onto "@att_", but
        // for xenon titles, we need to mask out the xbox 1 datatype bits,
        // since they are not actually part of the property or context id,
        // but are only there so the wiredata classes process the data
        // correctly.
        if (!fIsLegacyXboxTitle)
        {
            id = RemoveXboxDatatype(id);
        }
        return "@att_" + IdToSqlSuffix(id, fIsLegacyXboxTitle);
    }

    // -----------------------------------------------------------------------
    // Insert and update sql commands have a variable number of parameters
    // for each title. The client passes a set of session attributes to the
    // front door which are used to populate these parameters. This method
    // translates a list of session attributes into sql parameters that are
    // attached to the specified sql command.
    // -----------------------------------------------------------------------
    private static void AddSessionAttributesToSqlCommand(
        uint dwTitleId,
        MatchAttribute[] rgAttributes,
        SqlCommand cmd,
        bool fIsLegacyXboxTitle,
        uint seqNum)
    {
        for(uint iAttrib = 0; iAttrib < rgAttributes.Length; iAttrib++)
        {
            if(!MatchDefs.IsAttributeIdValid(
                rgAttributes[iAttrib].dwAttributeId))
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID,
                    XEvent.Id.MATCH_TITLEBUG_36,
                    "XMatchFD.DBLayer.AddSessionAttributesToSqlCommand("
                    + seqNum.ToString("X8")
                    + "): Reserved bits set in attribute, id=0x"
                    + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId);
            }

            if(!MatchDefs.IsAttributeTypeSession(
                rgAttributes[iAttrib].dwAttributeId))
            {
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_ATTR_TYPE,
                    XEvent.Id.MATCH_TITLEBUG_37,
                    "XMatchFD.DBLayer.AddSessionAttributesToSqlCommand("
                    + seqNum.ToString("X8")
                    + "): Attribute is not a session attribute, id=0x"
                    + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId);
            }

            // figure out the attribute name
            string attrName = IdToAttrName(rgAttributes[iAttrib].dwAttributeId, fIsLegacyXboxTitle);

            switch(MatchDefs.AttributeDatatype(
                rgAttributes[iAttrib].dwAttributeId))
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                // Xenon clients may specify a subtype using the bits in
                // MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_MASK. Xbox clients will
                // never have any of these bits set, which correponds to
                // MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT, which will be
                // interpreted as a 64 bit unsigned integer, the same as it
                // was in the past. Other subtypes have the appropriate type
                // conversions applied to them.
                try
                {
                    switch (MatchDefs.AttributeXenonDatatype(
                        rgAttributes[iAttrib].dwAttributeId))
                    {
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT:
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT64:
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME:
                        // No type conversion required for these types.
                        // For datetimes, qwValue contains a FILETIME in UTC
                        // we store it directly in the database as a bigint
                        // not a datetime, so there is no loss of precision
                        // and so they subtract easily for "fuzzy match".
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, attrName,
                            rgAttributes[iAttrib].qwValue);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT32:
                        // convert to 32 bit unsigned integer
                        uint ui = (uint)rgAttributes[iAttrib].qwValue;
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, attrName, ui);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT32:
                        float f = rgAttributes[iAttrib].ToSingle();
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, attrName, f);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT64:
                        double d = rgAttributes[iAttrib].ToDouble();
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, attrName, d);
                        break;

                    default:
                        throw new XRLException(
                            HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                            XEvent.Id.MATCH_TITLEBUG_38,
                            "XMatchFD.DBLayer.AddSessionAttributesToSqlCommand("
                            + seqNum.ToString("X8")
                            + "): Unknown attribute xenon subtype id=0x"
                            + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                            + ". titleId = " + (TitleId) dwTitleId);
                    }
                }
                catch (OverflowException e)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_OVERFLOW,
                        XEvent.Id.MATCH_TITLEBUG_39,
                        "XMatchFD.DBLayer.AddSessionAttributesToSqlCommand("
                        + seqNum.ToString("X8")
                        + "): Attribute out of range id=0x"
                        + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                        + ". titleId = " + (TitleId) dwTitleId, e);
                }
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input, attrName,
                    rgAttributes[iAttrib].strValue);
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                if (fIsLegacyXboxTitle || RelaxXenonValidation)
                {
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input, attrName,
                        rgAttributes[iAttrib].rgbValue);
                }
                else
                {
                    // we don't allow blob schema attributes in Xenon
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                        XEvent.Id.MATCH_TITLEBUG_40,
                        "XMatchFD.DBLayer.AddSessionAttributesToSqlCommand("
                        + seqNum.ToString("X8")
                        + "): Blob attributes are not allowed in Xenon, id=0x"
                        + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                        + ". titleId = " + (TitleId) dwTitleId);
                }
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                // If the client chooses to send us a null attribute, we
                // simply ignore it, silently.
                break;
            default:
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                    XEvent.Id.MATCH_TITLEBUG_41,
                    "XMatchFD.DBLayer.AddSessionAttributesToSqlCommand("
                    + seqNum.ToString("X8")
                    + "): Unknown attribute type id=0x"
                    + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId);
            }
        }
        return;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the generation of parameter names given
    // an parameter id
    // -----------------------------------------------------------------------
    private static string IdToParamName(
        uint id,
        uint ordinal,
        uint dwTitleId,
        bool fIsLegacyXboxTitle,
        uint seqNum)
    {
        if (fIsLegacyXboxTitle)
        {
            // Xbox 1 titles don't pass the complete context or property id up
            // in a search call, they only pass the datatype. Therefore Xbox 1
            // stype parameters are named with a decimal suffix based on ordinal,
            // and the id is only used to determine the type. XmlToSql (which
            // is still being used for legacy titles until bug 21114 is fixed)
            // also prepends a type prefix on each parameter name.
            switch(MatchDefs.AttributeDatatype(id))
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                return "@bi_param_" + ordinal.ToString();

            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                return "@nvc_param_" + ordinal.ToString();

            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                return "@vb_param_" + ordinal.ToString();

            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                // if a null parameter comes us, we're supposed to silently
                // ignore it.
                return null;

            default:
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                    XEvent.Id.MATCH_TITLEBUG_42,
                    "XMatchFD.DBLayer.IdToParamName(" + seqNum.ToString("X8")
                    + "): Unknown attribute type, id=0x" + id.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId);
            }
        }

        // Xenon titles name parameters more simply. The param id, in hex
        // is tacked on to the end of a standard prefix. However, for xenon
        // titles, we need to mask out the xbox 1 datatype bits,
        // since they are not actually part of the property or context id,
        // but are only there so the wiredata classes process the data
        // correctly.
        id = RemoveXboxDatatype(id);
        return "@param_0x" + id.ToString("X8");
    }

    // -----------------------------------------------------------------------
    // By default, this method operates on non-weighted params. 
    // -----------------------------------------------------------------------
    private static void AddParamAttributesToSqlCommand(
        MatchAttribute[] rgAttributes,
        TitleInfo ti,
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlCommand cmd,
        bool fIsLegacyXboxTitle,
        uint seqNum)
    {
        AddParamAttributesToSqlCommand(
                rgAttributes,
                ti,
                dwTitleId,
                dwProcedureIndex,
                cmd,
                fIsLegacyXboxTitle,
                false /*fWeighted*/,
                seqNum);
    }

    // -----------------------------------------------------------------------
    // Session search sql commands have a variable number of parameters
    // depending on the search. The client passes a set of param attributes
    // to the front door which are used to populate these parameters. This
    // method translates a list of param attributes into sql parameters that are
    // attached to the specified sql command.
    // -----------------------------------------------------------------------
    private static void AddParamAttributesToSqlCommand(
        MatchAttribute[] rgAttributes,
        TitleInfo ti,
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlCommand cmd,
        bool fIsLegacyXboxTitle,
        bool fWeighted,
        uint seqNum)
    {
        // now that this method is used by weighted attributes, it's possible
        // that rgAttributes could be null, because 0 weighted attributes is allowed.
        if(rgAttributes == null)
        {
            return;
        }

        for(uint iAttrib = 0; iAttrib < rgAttributes.Length; iAttrib++)
        {
            string paramName = IdToParamName(rgAttributes[iAttrib].dwAttributeId,
                iAttrib + 1, dwTitleId, fIsLegacyXboxTitle, seqNum);

            switch(MatchDefs.AttributeDatatype(
                rgAttributes[iAttrib].dwAttributeId))
            {
            case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                try
                {
                    switch (MatchDefs.AttributeXenonDatatype(
                        rgAttributes[iAttrib].dwAttributeId))
                    {
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT:
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT64:
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME:
                        // No type conversion required for these types.
                        // For datetimes, qwValue contains a FILETIME in UTC
                        // we store it directly in the database as a bigint
                        // not a datetime, so there is no loss of precision
                        // and so they subtract easily for "fuzzy match".
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, paramName,
                            rgAttributes[iAttrib].qwValue);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT32:
                        // convert to 32 bit unsigned integer
                        uint ui = (uint)rgAttributes[iAttrib].qwValue;
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, paramName, ui);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT32:
                        // convert to 32 bit floating point value,
                        // using literal bit pattern
                        float f = rgAttributes[iAttrib].ToSingle();
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, paramName, f);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT64:
                        // convert to 64 bit floating point value,
                        // using literal bit pattern
                        double d = rgAttributes[iAttrib].ToDouble();
                        MatchSql.SqlAddParam(cmd, ParameterDirection.Input, paramName, d);
                        break;

                    default:
                        throw new XRLException(
                            HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                            XEvent.Id.MATCH_TITLEBUG_43,
                            "XMatchFD.DBLayer.AddParamAttributesToSqlCommand("
                            + seqNum.ToString("X8")
                            + "): Unknown attribute xenon subtype id=0x"
                            + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                            + ". titleId = " + (TitleId) dwTitleId);
                    }
                }
                catch (OverflowException)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_OVERFLOW,
                        XEvent.Id.MATCH_TITLEBUG_44,
                        "XMatchFD.DBLayer.AddParamAttributesToSqlCommand("
                        + seqNum.ToString("X8")
                        + "): Attribute out of range id=0x"
                        + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                        + ". titleId = " + (TitleId) dwTitleId);
                }
                break;

            case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input, paramName,
                    rgAttributes[iAttrib].strValue);
                break;

            case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                // Some early titles used blob parameters.
                // Xenon titles are not allowed to use blob parameters.
                if (fIsLegacyXboxTitle || RelaxXenonValidation || MatchDefs.X_SSINDEX_GET_SESSION_LIST == dwProcedureIndex)
                {
                    // this is an Xbox 1 title, so we'll let it use the
                    // blob parameter
                    MatchSql.SqlAddParam(cmd, ParameterDirection.Input, paramName,
                        rgAttributes[iAttrib].rgbValue);
                }
                else
                {
                    // we don't allow Xenon titles to use blob parameters
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                        XEvent.Id.MATCH_TITLEBUG_45,
                        "XMatchFD.DBLayer.AddParamAttributesToSqlCommand("
                        + seqNum.ToString("X8")
                        + "): Parameter cannot be type blob id=0x"
                        + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                        + ". titleId = " + (TitleId) dwTitleId);
                }
                break;
            case MatchDefs.X_ATTRIBUTE_DATATYPE_NULL:
                // Since all parameters are named, we don't need to do anything
                // for those that are null
                break;
            default:
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_DATA_TYPE,
                    XEvent.Id.MATCH_TITLEBUG_46,
                    "XMatchFD.DBLayer.AddParamAttributesToSqlCommand(" + seqNum.ToString("X8")
                    + "): Unknown attribute type, id=0x"
                    + rgAttributes[iAttrib].dwAttributeId.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId);
            }

            // weighted attributes (which should only ever be used as params to the WeightedSearch sproc)
            // get an additional SqlParam to carry the weight associated with the attribute.
            // TODOTHEOM: what happens if the attribute can't be casted to a weighted attribute?  Should never happen, but...
            if(fWeighted)
            {
                string weightParamName = IdToParamName(rgAttributes[iAttrib].dwAttributeId,
                    iAttrib + 1, dwTitleId, fIsLegacyXboxTitle, seqNum);
                weightParamName = weightParamName + "_weight";
                MatchAttributeWeighted maw = (MatchAttributeWeighted)rgAttributes[iAttrib];
                float f = maw.GetWeight();
                MatchSql.SqlAddParam(cmd, ParameterDirection.Input, weightParamName, f);
            }
        }
        return;
    }


    // -----------------------------------------------------------------------
    // Reads the results of a session search query from a SqlDataReader
    // and places them into an array of SearchResult objects, then closes
    // the reader and gets the return value and maxresults output parameter values
    // -----------------------------------------------------------------------
    private static HResult ReadSearchResults(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlCommand cmd,
        SqlDataReader reader,
        bool bIsLegacyXboxTitle,
        out uint maxResults,
        out SearchResult[] rgResults,
        uint seqNum)
    {
        ReadSearchResults(dwTitleId, dwProcedureIndex, reader,
            bIsLegacyXboxTitle, out rgResults, seqNum);

        HResult hr = GetMaxResults(dwTitleId, dwProcedureIndex, cmd, reader,
            bIsLegacyXboxTitle, out maxResults, seqNum);

        return hr;
    }

    // -----------------------------------------------------------------------
    // Reads the results of a session search query from a SqlDataReader
    // and places them into an array of SearchResult objects.
    // -----------------------------------------------------------------------
    private static void ReadSearchResults(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlDataReader reader,
        bool bIsLegacyXboxTitle,
        out SearchResult[] rgResults,
        uint seqNum)
    {
        // Add results to a temporary list until we know how many there are
        // and can create an array
        ArrayList list = new ArrayList();

        uint[] attributeIds = null;
        while(reader.Read())
        {
            // use the column headers to get the attribute ids of any properties
            // and contexts
            if (attributeIds == null)
            {
                if (!bIsLegacyXboxTitle)
                {
                    attributeIds = GetAttributeIds(reader);
                }
            }
            list.Add(ReadSearchResult(dwTitleId, dwProcedureIndex,
                reader, attributeIds, bIsLegacyXboxTitle, seqNum));
        }

        rgResults = (SearchResult[])list.ToArray(typeof(SearchResult));
        return;
    }

    private static void SetDrawProbabilty(SearchResult[] results, double gamerMu, double gamerSigma)
    {
        if (-0.5 < gamerMu && -0.5 < gamerSigma)
        {
            foreach (SearchResult sr in results)
            {
                sr.SetDrawProbability(gamerMu, gamerSigma);

                // Give up if the session results don't have mu and sigma
                if (sr.drawProbability < -0.5)
                    break;
            }
        }
    }

    // -----------------------------------------------------------------------
    // Helper to read a set of results, and merge them with a previous set of results
    // of the same type.  This code assumes that it will only ever be called twice in a single
    // request -- once to populate the initial results and once to merge in a new set.
    // This is most apparent because we re-calculate the draw probability for both result
    // sets on the merge.
    // -----------------------------------------------------------------------
    private static void ReadAndMergeResults(ref SearchResult[] results,
                                                                        uint dwTitleId,
                                                                        uint dwProcedureIndex,
                                                                        SqlCommand cmd,
                                                                        SqlDataReader reader,
                                                                        bool fIsLegacyXboxTitle,
                                                                        MatchAttribute[] rgAttributes,
                                                                        uint seqNum,
                                                                        ref double gamerMu,
                                                                        ref double gamerSigma
                                                                        )
    {
        SearchResult[] rgsrNewResults = null;

        ReadSearchResults(dwTitleId, dwProcedureIndex, reader,
             fIsLegacyXboxTitle, out rgsrNewResults, seqNum);

        if (null != results && results.Length > 0 &&
            null != rgsrNewResults && rgsrNewResults.Length > 0)
        {
            // we have 2 sets of results.  Merge!
            // only grab mu and sigma if they're not already grabbed, b/c it's expensive.
            if(gamerMu == -1 || gamerSigma == -1)
            {
                gamerMu = GetGamerMu(rgAttributes);
                gamerSigma = GetGamerSigma(rgAttributes);
            }
            // Set the draw probability for both result sets
            SetDrawProbabilty(results, gamerMu, gamerSigma);
            SetDrawProbabilty(results, gamerMu, gamerSigma);
            results = MergeResultsByDrawProbability(results, rgsrNewResults);
        }
        else if(rgsrNewResults != null && rgsrNewResults.Length > 0)
        {
            // we have only new... overwrite the old
            results = rgsrNewResults;
        }
        // otherwise, we just have old, so do nothing.

}



    private static SearchResult[] MergeResults(SearchResult[] previousResults, SearchResult[] newResults)
    {
        SearchResult[] mergedResults = new SearchResult[previousResults.Length + newResults.Length];

        Array.Copy(
            previousResults,            // sourceArray
            0,                          // sourceIndex,
            mergedResults,              // destinationArray
            0,                          // destinationIndex
            previousResults.Length);    // length

        Array.Copy(
            newResults,                 // sourceArray
            0,                          // sourceIndex,
            mergedResults,              // destinationArray
            previousResults.Length,     // destinationIndex
            newResults.Length);         // length

        return (mergedResults);
    }

    private static SearchResult[] MergeResultsByDrawProbability(SearchResult[] previousResults, SearchResult[] newResults)
    {
        SearchResult[] mergedResults = MergeResults(previousResults, newResults);

        // CONSIDER: Could do merge sort since the results sets are already
        // ordered by draw probability.  In that case we could avoid the
        // 2 Copy calls in MergeResults plus the sort below and just do a
        // double loop walk.

        // The SearchResults might not have draw probability set.  This can
        // happen if the title doesn't request mu and sigma as search return
        // values.  In that case we don't have the mu and sigma of the
        // session that we need to calculate draw probability.  There's not
        // much we can do so we leave the array ordered only within server.
        if (mergedResults.Length > 0 &&
            null != mergedResults[0] &&
            -0.5 < mergedResults[0].drawProbability)
        {
            Array.Sort(mergedResults, new SearchResultDrawProbabilityComparer());
        }

        return (mergedResults);
    }


    private static SearchResult[] MergeResultsByWeightedScore(SearchResult[] previousResults, SearchResult[] newResults)
    {
        SearchResult[] mergedResults = MergeResults(previousResults, newResults);

        // CONSIDER: Could do merge sort since the results sets are already
        // ordered by draw probability.  In that case we could avoid the
        // 2 Copy calls in MergeResults plus the sort below and just do a
        // double loop walk.

        if (mergedResults.Length > 0 &&
            null != mergedResults[0] )
        {
            Array.Sort(mergedResults, new SearchResultScoreComparer());
        }

        return (mergedResults);
    }


    // -----------------------------------------------------------------------
    // Uses the column names to generate an array attribute ids
    // This is only valid for use with Xenon titles
    // -----------------------------------------------------------------------
    private static uint[] GetAttributeIds(SqlDataReader reader)
    {
        // title defined columns begin at ordinal 7
        int fieldCount = reader.FieldCount;
        uint[] attributeIds = new uint[fieldCount - 7];
        for (int i = 0; i < fieldCount - 7; ++i)
        {
            // xbox1 attributes are of the form att_0x50008106
            attributeIds[i] = UInt32.Parse(reader.GetName(i+7).Substring(6),
                NumberStyles.HexNumber);

            // the column name in the database does not include the
            // xbox 1 style match datatype required for the wiredata class
            // to correctly process it. Set the match data type as needed.
            switch (MatchDefs.AttributeXenonDatatype(attributeIds[i]))
            {
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT:
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT32:
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT64:
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT64:
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT32:
                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME:
                    attributeIds[i] |= MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER;
                    break;

                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UNICODE:
                    attributeIds[i] |= MatchDefs.X_ATTRIBUTE_DATATYPE_STRING;
                    break;

                case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_BINARY:
                    attributeIds[i] |= MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB;
                    break;
            }
        }

        return attributeIds;
    }

    // -----------------------------------------------------------------------
    // Reads the results of a session search query from a SqlDataReader
    // and places them into an array of SearchResult objects, then closes
    // the reader and gets the return value and maxresults output parameter values
    // -----------------------------------------------------------------------
    private static HResult GetMaxResults(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlCommand cmd,
        SqlDataReader reader,
        bool bIsLegacyXboxTitle,
        out uint maxResults,
        uint seqNum)
    {
        // Our return value will not be populated until we close the
        // SqlDataReader
        reader.Close();
        reader = null;

        HResult hr = (uint)(int)cmd.Parameters["@retval"].Value;
        if(HResult.Failed(hr))
        {
            throw new XRLException(hr, XEvent.Id.MATCH_CODE_27,
                "XMatchFD.DBLayer.GetMaxResults(" + seqNum.ToString("X8")
                + "): Unexpected return code from stored proc="
                + hr
                + " titleId = " + (TitleId) dwTitleId);
        }

        maxResults = 0;
        if (!bIsLegacyXboxTitle && !MatchDefs.IsSearchSystemFindByIdQuery(dwProcedureIndex))
        {
            maxResults = (uint)(int)cmd.Parameters["@i_max_results"].Value;
        }

        return hr;
    }

    // -----------------------------------------------------------------------
    // Reads a single row of a session search query from a SqlDataReader
    // as SearchResult object.
    // -----------------------------------------------------------------------
    private static SearchResult ReadSearchResult(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlDataReader reader,
        uint[] attributeIds,
        bool fIsLegacyXboxTitle,
        uint seqNum)
    {
        SearchResult sr = new SearchResult();
        sr.HostAddress = new XNADDR();

        sr.qwSessionId = (ulong)reader.GetInt64(0); // bi_session_id
        sr.HostAddress.ReadBytes((byte[])reader.GetValue(1)); // b_host_address
        sr.rgbKeyExchangeKey = (byte[])reader.GetValue(2); // b_key_exchange_key
        sr.dwPublicOpen = (uint)reader.GetInt32(3); // i_public_available
        sr.dwPrivateOpen = (uint)reader.GetInt32(4); // i_private_available
        sr.dwPublicFilled = (uint)reader.GetInt32(5); // i_public_current
        sr.dwPrivateFilled = (uint)reader.GetInt32(6); // i_private_current

        // We've read the first seven columns above, ordinals 0 through 6.
        // Legacy xbox titles return i_hash for no reason, so the real
        // attributes start at ordinal 8. Xbox 360 titles don't return
        // the hash, so the real attributes start at ordinal 7.
        int nextOrdinal = 7;
        if (fIsLegacyXboxTitle)
        {
            nextOrdinal = 8;
        }
        ReadAttributesAndPad(dwTitleId, dwProcedureIndex,
            reader, nextOrdinal, attributeIds, fIsLegacyXboxTitle, sr, seqNum);

        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_LOW,
            "XMatchFD.DBLayer.ReadSearchResult(" + seqNum.ToString("X8") + ")\n"
            + sr.ToString(0));

        return sr;
    }

    // -----------------------------------------------------------------------
    // Reads a variable number of columns from the end of a single result row
    // from a session search query into SearchResult.rgAttributes, and then
    // zero pads the SearchResult object to a 4 byte boundary.
    // -----------------------------------------------------------------------
    private static void ReadAttributesAndPad(
        uint dwTitleId,
        uint dwProcedureIndex,
        SqlDataReader reader,
        int iStartColumn,
        uint[] attributeIds,
        bool fIsLegacyXboxTitle,
        SearchResult sr,
        uint seqNum)
    {
        sr.dwNumAttributes = (uint)(reader.FieldCount - iStartColumn);
        if (!fIsLegacyXboxTitle && !MatchDefs.IsSearchSystemFindByIdQuery(dwProcedureIndex))
        {
            // for Xenon titles, we return an extra attribute for the "affiliate
            // value" of the session, except for FindById queries.
            ++sr.dwNumAttributes;
        }
        uint dwTotalSize = sr.GetBaseSize() + (4 * sr.dwNumAttributes);
        sr.rgAttributes = new MatchAttribute[sr.dwNumAttributes];
        sr.rgdwAttrOffsets = new uint[sr.dwNumAttributes];

        // This loop iterates based on position, because xbox 1 clients
        // expect attributes to be returned in the order they appear
        // in the table. Xenon clients don't care about the order,
        // because they use the attribute id itself, but the array of
        // attribute ids passed in also depends on processing the fields
        // in order.
        int j = 0;
        for(int iColumn = iStartColumn; iColumn < reader.FieldCount; iColumn++)
        {
            uint attributeId = 0;
            if (!fIsLegacyXboxTitle)
            {
                attributeId = attributeIds[j];
                ++j;
            }

            int attributeIndex = iColumn - iStartColumn;

            // Save some often-used attribute indexes to save ourselves from
            // having to search for them later.
            switch (attributeId)
            {
                case MatchDefs.X_ATTRIBUTE_GAMER_MU:
                    sr.attributeIndexOfMu = attributeIndex;
                    break;
                case MatchDefs.X_ATTRIBUTE_GAMER_SIGMA:
                    sr.attributeIndexOfSigma = attributeIndex;
                    break;
                case MatchDefs.X_ATTRIBUTE_SESSION_SCORE:
                    sr.attributeIndexOfScore = attributeIndex;
                    break;
            }

            sr.rgAttributes[attributeIndex]
                = ReadAttribute(dwTitleId, iColumn, reader, attributeId, fIsLegacyXboxTitle, seqNum);

            sr.rgdwAttrOffsets[attributeIndex] = dwTotalSize;

            dwTotalSize += sr.rgAttributes[attributeIndex].GetSize();
        }

        // If this is a Xenon title, add the affiliate value, as 0
        // The layer above will replace the 0 value with the correct
        // value, if appropriate. Don't do this for FindById queries.
        if (!fIsLegacyXboxTitle && !MatchDefs.IsSearchSystemFindByIdQuery(dwProcedureIndex))
        {
            // Remember the affiliate attribute index cause we'll use it a lot
            // later when we're ordering the results by affiliate value.
            sr.attributeIndexOfAffiliateValue = (int)sr.dwNumAttributes - 1;

            sr.rgAttributes[sr.attributeIndexOfAffiliateValue] = new MatchAttribute();
            sr.rgAttributes[sr.attributeIndexOfAffiliateValue].dwAttributeId = MatchDefs.X_ATTRIBUTE_AFFILIATE_VALUE;
            sr.rgAttributes[sr.attributeIndexOfAffiliateValue].qwValue = (ulong)BitConverter.DoubleToInt64Bits(0.0);

            sr.rgdwAttrOffsets[sr.attributeIndexOfAffiliateValue] = dwTotalSize;
            dwTotalSize += sr.rgAttributes[sr.attributeIndexOfAffiliateValue].GetSize();
        }

        // Zero pad to a 4-byte boundary
        if(0 != (dwTotalSize % 4))
        {
            sr.rgbPaddingLen = 4 - (dwTotalSize % 4);
            sr.rgbPadding = new byte[sr.rgbPaddingLen];
            for(int iByte = 0; iByte < sr.rgbPaddingLen; iByte++)
            {
                sr.rgbPadding[iByte] = 0;
                dwTotalSize++;
            }
        }
        else
        {
            sr.rgbPaddingLen = 0;
        }
        sr.dwResultLength = dwTotalSize;
        return;
    }

    // -----------------------------------------------------------------------
    // Reads the data from a single column in a single row of the results
    // of a search query into a MatchAttribute object.
    // -----------------------------------------------------------------------
    private static MatchAttribute ReadAttribute(
        uint dwTitleId,
        int iColumn,
        SqlDataReader reader,
        uint attributeId,
        bool fIsLegacyXboxTitle,
        uint seqNum)
    {
        MatchAttribute attribute  = new MatchAttribute();

        if(reader.IsDBNull(iColumn))
        {
            // For xbox titles, null columns were returned with attribute id
            // equal to MatchDefs.X_ATTRIBUTE_DATATYPE_NULL.
            // The Xenon client is perfectly happy to deal with this
            // convention as well. No data is associated with a null attribute.
            attribute.dwAttributeId = MatchDefs.X_ATTRIBUTE_DATATYPE_NULL;
        }
        else
        {
            if (fIsLegacyXboxTitle)
            {
                // Xbox 1 summary queries do not have an attribute id encoded
                // in the column name, so if this is an Xbox 1 query, we have
                // to figure out the datatype by looking at the datatype of the
                // column itself. Additionally Xbox 1 titles only get the
                // datatype returned in the attribute id, not the whole id.
                attribute.dwAttributeId
                    = ColumnDataType(dwTitleId, reader, iColumn, seqNum);
            }
            else
            {
                // For Xenon titles, we've already figured out the attribute id
                // by parsing the column name and adding in the appropriate
                // match datatype bits.
                attribute.dwAttributeId = attributeId;
            }

            try
            {
                switch (MatchDefs.AttributeDatatype(attribute.dwAttributeId))
                {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    switch (MatchDefs.AttributeXenonDatatype(attribute.dwAttributeId))
                    {
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT:
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT64:
                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME:
                        // Column sql type: BIGINT (64 bit signed integer)
                        // For datetimes, the bigint contains a FILETIME in UTC
                        // We store datetimes directly in the database as bigints
                        // not as datetimes, so there is no loss of precision
                        // and so they subtract easily for "fuzzy match".
                        attribute.qwValue = (ulong)reader.GetInt64(iColumn);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT32:
                        // Column sql type: INT (32 bit signed integer)
                        attribute.qwValue = (ulong)reader.GetInt32(iColumn);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT32:
                        // Column sql type: REAL (32 bit floating point value)
                        float f = reader.GetFloat(iColumn);
                        attribute.FromSingle(f);
                        break;

                    case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT64:
                        // Column sql type: FLOAT (64 bit floating point value)
                        double d = reader.GetDouble(iColumn);
                        attribute.FromDouble(d);
                        break;

                    default:
                        // I'm calling this a code error because our tools
                        // never should've let this column be created in
                        // the database!
                        throw new XRLException(
                            HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
                            XEvent.Id.MATCH_CODE_28,
                            "XMatchFD.DBLayer.ReadAttribute(" + seqNum.ToString("X8")
                            + "): Unknown attribute xenon subtype in result id=0x"
                            + attribute.dwAttributeId.ToString("X8")
                            + ". titleId = " + (TitleId) dwTitleId);
                    }
                    break;

                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                    // Column sql type: NVARCHAR
                    attribute.strValue = reader.GetString(iColumn);
                    break;

                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                    // Column sql type: VARBINARY
                    attribute.rgbValue = reader.GetSqlBinary(iColumn).Value;
                    break;

                default:
                    // I'm calling this a code error because our tools
                    // never should've let this column be created in
                    // the database!
                    throw new XRLException(
                        HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
                        XEvent.Id.MATCH_CODE_29,
                        "XMatchFD.DBLayer.ReadAttribute(" + seqNum.ToString("X8")
                        + "): Unknown attribute type in result id=0x"
                        + attribute.dwAttributeId.ToString("X8")
                        + ". titleId = " + (TitleId) dwTitleId);
                }
            }
            catch (OverflowException e)
            {
                // I'm calling this a code error, because this
                // value shouldn't have gotten into the database
                // via InsertSession or UpdateSession
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_OVERFLOW,
                    XEvent.Id.MATCH_CODE_30,
                    "XMatchFD.DBLayer.ReadAttribute(" + seqNum.ToString("X8")
                    + "): Attribute out of range in result id=0x"
                    + attribute.dwAttributeId.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId, e);
            }
            catch (InvalidCastException e)
            {
                // I'm calling this a code error because our tools
                // shouldn't have created a column with a datatype that's
                // not compatible with the type in the attribute id
                throw new XRLException(
                    HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
                    XEvent.Id.MATCH_CODE_31,
                    "XMatchFD.DBLayer.ReadAttribute(" + seqNum.ToString("X8")
                    + "): Attribute in result could not be converted to expected type id=0x"
                    + attribute.dwAttributeId.ToString("X8")
                    + ". titleId = " + (TitleId) dwTitleId, e);
            }
        }
        return attribute;
    }

    // -----------------------------------------------------------------------
    // Checks to see if the specified column in the SqlDataReader is NULL
    // USE SPARINGLY, as it's relatively inefficient.  If you know the index of the column,
    // use reader.IsDBNull directly.
    // -----------------------------------------------------------------------
    private static bool IsNullColumn(SqlDataReader reader, string sColumn)
    {
        int iColumn;
        bool isNull = true;
        try
        {
            iColumn = reader.GetOrdinal(sColumn);
            isNull = reader.IsDBNull(iColumn);
        }
        catch (IndexOutOfRangeException)
        {
            // this means the column doens't exist in the results, so
            // consider it null.
            isNull = true;
        }
        return isNull;
    }

    // -----------------------------------------------------------------------
    // Translates the database column type into an attribute data type.
    // This should only be used by legacy xbox titles. Xenon titles figure
    // out the datatype of the column from the attribute id in the column
    // name. We can't always do that for Legacy Xbox titles, because summary
    // queries don't have the attribute id in the column name. Note that
    // this method presumes that the column is not null. Check for DBNull before
    // calling this method.
    // -----------------------------------------------------------------------
    private static uint ColumnDataType(
        uint dwTitleId,
        SqlDataReader reader,
        int iColumn,
        uint seqNum)
    {
        Type t = reader.GetFieldType(iColumn);
        if(t == typeof(long))
        {
            return MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER;
        }
        if(t == typeof(string))
        {
            return MatchDefs.X_ATTRIBUTE_DATATYPE_STRING;
        }
        if(t == typeof(byte[]))
        {
            return MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB;
        }

        // I'm calling this a code error, because our tools shouldn't
        // allow this situation to happen.
        throw new XRLException(
            HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
            XEvent.Id.MATCH_CODE_32,
            "XMatchFD.DBLayer.ColumnDataType(" + seqNum.ToString("X8")
            + "): Invalid column type in results. TitleID="
            + dwTitleId.ToString("X8"));
    }

    // -----------------------------------------------------------------------
    // Reads the search details returned by a ranked query stored proc
    // -----------------------------------------------------------------------
    private static void ReadRankedSearchDetails(
        SqlDataReader reader,
        out RankedSearchDetails rankedSearchDetails,
        uint seqNum,
        uint dwTitleId)
    {
        if (!reader.Read())
        {
            throw new XRLException(
                HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
                XEvent.Id.MATCH_CODE_33,
                "XMatchFD.DBLayer.ReadRankedSearchDetails(" + seqNum.ToString("X8")
                + "): Unable to read ranked search details. TitleID="
                + dwTitleId.ToString("X8"));
        }

        rankedSearchDetails = new RankedSearchDetails();

        // use numeric ordinals for performance
        // makes code maintenance a bit harder, but we'll be doing this a lot
        rankedSearchDetails.titleId = (uint)reader.GetInt32(0);
        rankedSearchDetails.queryId = (uint)reader.GetInt32(1);
        rankedSearchDetails.gameType = (int)reader.GetInt64(2);
        rankedSearchDetails.gameMode = (int)reader.GetInt64(3);
        rankedSearchDetails.gamerMu = reader.GetDouble(4);
        rankedSearchDetails.iterations = reader.GetInt32(5);
        rankedSearchDetails.rowCount = reader.GetInt32(6);
        rankedSearchDetails.muRange = reader.GetDouble(7);
        rankedSearchDetails.muUpperBound = reader.GetDouble(8);
        rankedSearchDetails.muLowerBound = reader.GetDouble(9);
        rankedSearchDetails.lowerHashBound1 = reader.GetInt32(10);
        rankedSearchDetails.upperHashBound1 = reader.GetInt32(11);
        rankedSearchDetails.lowerHashBound2 = reader.GetInt32(12);
        rankedSearchDetails.upperHashBound2 = reader.GetInt32(13);
     }

    // -----------------------------------------------------------------------
    // Reads the search details returned by a standard query stored proc
    // -----------------------------------------------------------------------
    private static void ReadStandardSearchDetails(
        SqlDataReader reader,
        out StandardSearchDetails standardSearchDetails,
        uint seqNum,
        uint dwTitleId)
    {
        if (!reader.Read())
        {
            throw new XRLException(
                HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
                XEvent.Id.MATCH_CODE_34,
                "XMatchFD.DBLayer.ReadStandardSearchDetails(" + seqNum.ToString("X8")
                + "): Unable to read standard search details. TitleID="
                + dwTitleId.ToString("X8"));
        }

        standardSearchDetails = new StandardSearchDetails();

        // use numeric ordinals for performance
        // makes code maintenance a bit harder, but we'll be doing this a lot
        standardSearchDetails.titleId = (uint)reader.GetInt32(0);
        standardSearchDetails.queryId = (uint)reader.GetInt32(1);
        standardSearchDetails.gameType = (int)reader.GetInt64(2);
        standardSearchDetails.gameMode = (int)reader.GetInt64(3);
        standardSearchDetails.gamerRating = reader.GetFloat(4);
        standardSearchDetails.gamerZone = reader.GetInt32(5);
        standardSearchDetails.iterations = reader.GetInt32(6);
        standardSearchDetails.rowCount = reader.GetInt32(7);
        standardSearchDetails.ratingRange = reader.GetDouble(8);
        standardSearchDetails.ratingUpperBound = reader.GetDouble(9);
        standardSearchDetails.ratingLowerBound = reader.GetDouble(10);
        standardSearchDetails.lowerHashBound1 = reader.GetInt32(11);
        standardSearchDetails.upperHashBound1 = reader.GetInt32(12);
        standardSearchDetails.lowerHashBound2 = reader.GetInt32(13);
        standardSearchDetails.upperHashBound2 = reader.GetInt32(14);
    }


    // -----------------------------------------------------------------------
    // Reads the search details returned by a ranked query stored proc
    // -----------------------------------------------------------------------
    private static void ReadWeightedSearchDetails(
        SqlDataReader reader,
        out WeightedSearchDetails weightedSearchDetails,
        uint seqNum,
        uint dwTitleId)
    {
        if (!reader.Read())
        {
            throw new XRLException(
                HResult.XONLINE_E_MATCH_INVALID_RESULT_COL,
                XEvent.Id.MATCH_CODE_33, // TODOTHEOM: new event ID and maybe HRESULT.
                "XMatchFD.DBLayer.ReadWeightedSearchDetails(" + seqNum.ToString("X8")
                + "): Unable to read weighted search details. TitleID="
                + dwTitleId.ToString("X8"));
        }

        weightedSearchDetails = new WeightedSearchDetails();

        // use numeric ordinals for performance
        // makes code maintenance a bit harder, but we'll be doing this a lot
        weightedSearchDetails.titleId = (uint)reader.GetInt32(0);
        weightedSearchDetails.queryId = (uint)reader.GetInt32(1);
        weightedSearchDetails.gameType = (int)reader.GetInt64(2);
        weightedSearchDetails.gameMode = (int)reader.GetInt64(3);
        weightedSearchDetails.gamerMu = reader.GetDouble(4);
        weightedSearchDetails.iterations = reader.GetInt32(5);
        weightedSearchDetails.rowCount = reader.GetInt32(6);
        weightedSearchDetails.range = reader.GetDouble(7);
        weightedSearchDetails.lowerHashBound1 = reader.GetInt32(8);
        weightedSearchDetails.upperHashBound1 = reader.GetInt32(9);
        weightedSearchDetails.lowerHashBound2 = reader.GetInt32(10);
        weightedSearchDetails.upperHashBound2 = reader.GetInt32(11);
     }


    private static string SqlExceptionToString(SqlException e)
    {
        return String.Format("State: {0}, Error: {1}, Message: {2}",
                e.State.ToString(),
                e.Errors[0].Number.ToString(),
                e.Message);
    }

    //
    // Fast Fail - Quickly bail on talking to naughty servers
    //

    protected static FastFailHelper m_fastFailHelper;
    protected static ResourceUsageMonitor m_resMonitor;

    private static void CheckForFastFail(string resourceName)
    {
        resourceName = resourceName.ToLower();  //Make sure casing doesn't create multiple resources
                                                //for one server

        bool fThreadDenied = false;
        
        // only monitor resource usage on http request threads.
        if (HttpContext.Current != null)
        {
            // check the proportion based monitor.
            if (m_resMonitor.AttemptResourceUse(resourceName))
            {
                RecordDBUsage(resourceName);
            }
            else
            {
                fThreadDenied = true;
            }
        }
        
        // now check the failure tolerance.
        if (fThreadDenied || m_fastFailHelper.InFastFailState(resourceName))
        {
            MatchFastFailCounters perServerCounters = MatchFastFailCounters.Counters[resourceName];
            MatchFastFailCounters.Counters.TotalConnectsFailed.Increment();
            MatchFastFailCounters.Counters.ConnectsPerSecFailed.Increment();
            if(perServerCounters != null)
            {
                perServerCounters.TotalConnectsFailed.Increment();
                perServerCounters.ConnectsPerSecFailed.Increment();
            }

            throw new XRLExceptionWithoutEvent(
                HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                String.Format("'{0}' is in a fast-fail state, operation aborted.", resourceName));
        }
    }

    private static void RecordDBUsage(string resourceName)
    {
        // get the cached list of used db servers.
        List<string> listDBs = (List<string>)HttpContext.Current.Items["MatchSQL_DB_List"];

        if (listDBs == null)
        {
            // no list exists?  make one.
            listDBs = new List<string>();
            HttpContext.Current.Items["MatchSQL_DB_List"] = listDBs;
        }

        // add this resource use.
        listDBs.Add(resourceName);
    }

    public static void CompleteDBUsage(string resourceName)
    {
        // get the cached list of used db servers.
        List<string> listDBs = (List<string>)HttpContext.Current.Items["MatchSQL_DB_List"];

        if ((listDBs == null) || !listDBs.Remove(resourceName))
        {
            throw new XRLExceptionWithoutEvent(HResult.E_UNEXPECTED, "CompleteDBUsage(): could not find resource named {0}.", resourceName);
        }

        m_resMonitor.CompleteResourceUse(resourceName);
    }

    public static void CompleteAllDBUsage()
    {
        // get the cached list of used db servers.
        List<string> listDBs = (List<string>)HttpContext.Current.Items["MatchSQL_DB_List"];
        
        if (listDBs != null)
        {
            foreach (string resourceName in listDBs)
            {
                // complete each resource use.
                m_resMonitor.CompleteResourceUse(resourceName);
            }
        }

        // null out the cached list just in case this gets called twice.
        HttpContext.Current.Items["MatchSQL_DB_List"] = null;
    }

    private static void ReportFailure(string resourceName, string errorMessage)
    {
        m_fastFailHelper.ReportFailure(resourceName, errorMessage);
    }

    private static void ReportSuccess(string resourceName)
    {
        m_fastFailHelper.ReportSuccess(resourceName);
    }

    private static bool ConsiderExceptionAsConnectionFailure(SqlException e)
    {
        bool considerExceptionAsConnectionFailure = false;

        foreach (SqlError error in e.Errors)
        {
            if (SQLDefs.ERROR_LOGIN_TIMEOUT == error.Number ||
                SQLDefs.ERROR_LOGIN_NETWORK_ERROR == error.Number ||
                SQLDefs.ERROR_NETWORK_TIMEOUT == error.Number ||
                SQLDefs.ERROR_SQLCLIENT_TIMEOUT == error.Number ||
                SQLDefs.ERROR_SQLCLIENT_CONNECTION_FAILED == error.Number)
            {
                considerExceptionAsConnectionFailure = true;
                break;
            }
        }

        return (considerExceptionAsConnectionFailure);
    }

    private static bool ConsiderExceptionAsConnectionFailure(XRLException e)
    {
        bool considerExceptionAsConnectionFailure = false;
        SqlException se = e.InnerException as SqlException;

        if (null != se)
        {
            considerExceptionAsConnectionFailure = ConsiderExceptionAsConnectionFailure(se);
        }

        return (considerExceptionAsConnectionFailure);
    }
}   // class DBLayer

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\DeleteMessage.cs ===
//
// DeleteMessage.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Web;
using System.Net;

using xonline.common.community;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process DeleteMessage requests
    //-----------------------------------------------------------------------------------
    public class DeleteMessage : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly DeleteMessageMsg   m_request;
        private readonly DeleteMessageReply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public DeleteMessage(BaseHeader header) : base(header)
        {
            m_request  = new DeleteMessageMsg();
            m_response = new DeleteMessageReply();

            m_response.hr = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            // UserID of 0 not allowed
            if(m_request.qwUserID == 0) {
                string err = string.Format("DeleteMessage: Invalid user ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_DELETEMESSAGE_INVALID_USERID, err);
            }

            // Don't allow any flags to be set except the block sender flag
            if(0 != (m_request.dwFlags & ~MsgDefs.XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER)) {
                string err = string.Format("DeleteMessage: Call from client @ {0}:{1} User {2} message 0x{3:X8} Invalid flags 0x{4:X8}",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort,
                                           (Puid)m_request.qwUserID, m_request.dwMessageID, m_request.dwFlags);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_DELETEMESSAGE_INVALID_FLAGS, err); 
            }

            // Message ID from failed send not allowed
            if(0 != (m_request.dwMessageID & MsgDefs.XONLINE_MSG_ID_SEND_FAILED)) {
                string err = string.Format("DeleteMessage: Call from client @ {0}:{1} Bad message ID 0x{2:X8}",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.dwMessageID);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_DELETEMESSAGE_MESSAGEID_FROM_FAILED_SEND, err); 
            }

            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.MESSAGING_DELETEMESSAGE_INVALID_USERID, ""); 
            }

            if (MsgDefs.IsMsgTransient(m_request.dwMessageID))
            {
                TransientMessage xmsg = MessagingUtil.DeleteTransientMessage(m_request.qwUserID, m_request.dwMessageID);
                if (xmsg == null)
                {
                    string err = string.Format("DeleteMessage: MessagingUtil.DeleteTransientMessage returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                    throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_DELETEMESSAGE_INVALID_MESSAGEID, err);
                }
                else
                {
                    m_response.hr = HResult.S_OK;
                    if ((m_request.dwFlags & MsgDefs.XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER) != 0)
                    {
                        PresenceUtil.AddUsersToNeverList(m_request.qwUserID, new ulong[] { xmsg.Summary.qwSenderID });
                    }
                }
            }
            else
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // Call the sproc
                    ws.StoredProc = "dbo.p_xmsg_user_message_delete";
                    ws.Partition = ws.CalcPartition(m_request.qwUserID);
                    ws.AddParameter("@bi_user_puid", m_request.qwUserID);
                    ws.AddParameter("@i_message_id", m_request.dwMessageID);
                    ws.AddParameter("@f_block_sender", (m_request.dwFlags & MsgDefs.XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER) != 0 ? 1 : 0);
                    ws.AddParameter(ParamType.OUTPUT, "@bi_sender_puid", (ulong)0);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.ExecuteNonQuery();

                    HResult ret = (uint)ws.GetIntParameter("@RETVAL");
                    // Check the results
                    if (HResult.Failed(ret))
                    {
                        m_response.hr = ret;

                        // No results
                    }
                    else if (ret == HResult.S_FALSE)
                    {
                        string err = string.Format("DeleteMessage: p_xmsg_user_message_delete returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                        throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_DELETEMESSAGE_INVALID_MESSAGEID, err);

                    }
                    else
                    {
                        // Delete succeeded
                        m_response.hr = HResult.S_OK;

                        if ((m_request.dwFlags & MsgDefs.XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER) != 0)
                        {
                            // The code above will block the sender in the Database, we should purge the cache.
                            PresenceUtil.PurgeNeverListFromCache(m_request.qwUserID);
                        }
                    }
                }
            }
            // If block sender flag was set, add sender to neverlist!
            if ((m_response.hr == HResult.S_OK))
            {
                // send the notification
                MessagingUtil.SendDeleteMessageNotification(m_request.qwUserID, m_request.dwMessageID);
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "DEL|{0:X}:{1:X}|{2:X}|{3:X}|{4:X}|{5:X}",
                    (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(SGInfo.Current.ClientIP.GetAddressBytes(), 0)), 
                    (ushort)IPAddress.NetworkToHostOrder((short)SGInfo.Current.ClientPort), m_request.qwUserID,
                    m_request.dwMessageID, m_request.dwFlags, (uint)m_response.hr);
            Xom.Log(XomAreaName.Reporting_v2, "DEL|{0:X}:{1:X}|{2:X}|{3:X}|{4:X}|{5:X}",
                    (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(SGInfo.Current.ClientIP.GetAddressBytes(), 0)), 
                    (ushort)IPAddress.NetworkToHostOrder((short)SGInfo.Current.ClientPort), m_request.qwUserID,
                    m_request.dwMessageID, m_request.dwFlags, (uint)m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\DeleteSystemMessage.cs ===
//
// DeleteSystemMessage.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process DeleteSystemMessage requests
    //-----------------------------------------------------------------------------------
    public class DeleteSystemMessage : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly DeleteSystemMessageMsg   m_request;
        private readonly DeleteSystemMessageReply m_response;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public DeleteSystemMessage(BaseHeader header) : base(header)
        {
            m_request  = new DeleteSystemMessageMsg();
            m_response = new DeleteSystemMessageReply();

            m_response.hr = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            // MessageID of 0 not allowed
            if(m_request.dwMessageID == 0) {
                string err = string.Format("DeleteSystemMessage: Invalid message ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_DELETESYSTEMMESSAGE_INVALID_MESSAGEID, err);
            }

            // Don't allow any flags to be set except the revoke all flag
            if(0 != (m_request.dwFlags & ~MsgDefs.XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL)) {
                string err = string.Format("DeleteSystemMessage: Call @ {0}:{1} TitleID {2} message 0x{3:X8} Invalid flags 0x{4:X8}",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort,
                                           (TitleId)m_request.dwTitleID, m_request.dwMessageID, m_request.dwFlags);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_DELETEMESSAGE_INVALID_FLAGS, err);
            }

            // Because the managed webstore interface doesn't support the ALL_PARTITIONS flag, we must iterate over all
            // deployed partitions and call the sproc on each one.
            foreach (int physicalParititon in WSClient.GetPhysicalPartitions(ConfigUtil.UodbWebstoreApp))
            {
                using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PhysicalPartition = physicalParititon;

                    // Call the sproc
                    ws.StoredProc = "dbo.p_xmsg_system_message_delete";
                    ws.AddParameter("@i_title_id",   m_request.dwTitleID);
                    ws.AddParameter("@i_message_id", m_request.dwMessageID);
                    ws.AddParameter("@i_flags",      m_request.dwFlags);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", (uint)0);
                    ws.ExecuteNonQuery();

                    // Check the results
                    HResult ret = (uint)ws.GetIntParameter("@RETVAL");
                    if(HResult.Failed(ret)) {
                        m_response.hr = ret;

                    // No results
                    } else if(ret == HResult.S_FALSE) {
                        m_response.hr = HResult.E_FAIL;
                        string err = string.Format("DeleteSystemMessage: p_xmsg_system_message_delete returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                        throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_DELETESYSTEMMESSAGE_MESSAGE_NOT_FOUND, err);

                    // Delete succeeded
                    } else {
                        m_response.hr = HResult.S_OK;
                    }
                }
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "DES|{0:X}:{1:X}|{2}|{3:X}|{4:X}|{5}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (TitleId)m_request.dwTitleID,
                    m_request.dwMessageID, m_request.dwFlags, m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\EnumerateSystemMessages.cs ===
//
// EnumerateSystemMessages.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Web;
using System.Collections.Generic;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process EnumerateSystemMessages requests
    //-----------------------------------------------------------------------------------
    public class EnumerateSystemMessages : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly EnumerateSystemMessagesMsg   m_request;
        private readonly EnumerateSystemMessagesReply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public EnumerateSystemMessages(BaseHeader header) : base(header)
        {
            m_request  = new EnumerateSystemMessagesMsg();
            m_response = new EnumerateSystemMessagesReply();

            m_response.cMessages = 0;
            m_response.hr        = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE)) { 
                // Call the sproc
                ws.StoredProc = "dbo.p_xmsg_system_message_enumerate";
                ws.Partition = WSClient.ANY_PARTITION;
                ws.AddParameter("@i_title_id", m_request.dwTitleID);

                // Read each message and populate summary objects (up to the maximum number allowed)
                using(WstDataReader wsReader = ws.Execute()) {
                    List<SystemMessageSummary> summaries = new List<SystemMessageSummary>((int)MsgDefs.XONLINE_MAX_SYSTEM_MSGS);
                    for(int i = 0; i < MsgDefs.XONLINE_MAX_SYSTEM_MSGS; i++) {
                        // No more rows
                        if(wsReader.Read() == false) {
                            break;
                        }

                        SystemMessageSummary summary = new SystemMessageSummary();
                        summary.dwRegion        = (uint)(int)wsReader["i_region"];
                        summary.dwMessageID     = (uint)(int)wsReader["i_message_id"];
                        summary.bMessageType    = (byte)(short)wsReader["si_message_type"];
                        summary.dwMessageFlags  = (uint)(int)wsReader["i_message_flags"];
                        summary.dwTitleID       = (uint)(int)wsReader["i_sender_title_id"];
                        summary.qwSenderContext = (ulong)(long)wsReader["bi_sender_context"];
                        summary.szSenderName    = (string)wsReader["vc_sender_name"];
                        summary.dtSentTime      = (DateTime)wsReader["dt_sent_time"];
                        summary.wExpireMinutes  = (ushort)(short)wsReader["si_expire_minutes"];
                        summary.cbDetails       = (ushort)(short)wsReader["si_properties_size"];
                        summary.szDescription   = (string)wsReader["vc_description"];
                        summaries.Add(summary);
                    }
                    wsReader.Close();

                    m_response.cMessages = (ushort)summaries.Count;
                    m_response.rgMessages = summaries.ToArray();

                    m_response.hr = HResult.S_OK;
                }
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "ENS|{0:X}:{1:X}|{2}|{3:X}|{4}",
                    SGInfo.Current.ClientIP,  SGInfo.Current.ClientPort, 
                    (TitleId)m_request.dwTitleID, 
                    m_response.cMessages,
                    m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\EnumerateMessages.cs ===
//
// EnumerateMessages.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Web;
using System.Collections.Generic;
using xonline.common.community;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process EnumerateMessages requests
    //-----------------------------------------------------------------------------------
    public class EnumerateMessages : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly EnumerateMessages2Msg   m_request;
        private readonly EnumerateMessages2Reply m_response;

        private ushort m_cPersistentMessages;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public EnumerateMessages(BaseHeader header) : base(header)
        {
            m_request  = new EnumerateMessages2Msg();
            m_response = new EnumerateMessages2Reply();

            m_response.cMessages = 0;
            m_response.hr        = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            if (m_header.dwMsgType == (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES)
            {
                var v1Reply = new EnumerateMessagesReply();
                v1Reply.hr = m_response.hr;
                v1Reply.cMessages = m_response.cMessages;
                v1Reply.header.dwSeqNum = m_header.dwSeqNum;
                v1Reply.header.sgaddr = m_header.sgaddr;

                if (m_response.rgMessages == null)
                {
                    v1Reply.rgMessages = null;
                }
                else
                {
                    v1Reply.rgMessages = new MessageSummary[m_response.rgMessages.Length];
                    for (int i = 0; i < m_response.rgMessages.Length; ++i)
                    {
                        v1Reply.rgMessages[i] = new MessageSummary();
                        v1Reply.rgMessages[i].dwMessageID     = m_response.rgMessages[i].dwMessageID;
                        v1Reply.rgMessages[i].bMessageType    = m_response.rgMessages[i].bMessageType;
                        v1Reply.rgMessages[i].dwMessageFlags  = m_response.rgMessages[i].dwMessageFlags;
                        v1Reply.rgMessages[i].qwSenderID      = m_response.rgMessages[i].qwSenderID;
                        v1Reply.rgMessages[i].dwSenderTitleID = m_response.rgMessages[i].dwSenderTitleID;
                        v1Reply.rgMessages[i].qwSenderContext = m_response.rgMessages[i].qwSenderContext;
                        v1Reply.rgMessages[i].szSenderName    = m_response.rgMessages[i].szSenderName;
                        v1Reply.rgMessages[i].mtSentTime      = m_response.rgMessages[i].mtSentTime;
                        v1Reply.rgMessages[i].wExpireMinutes  = m_response.rgMessages[i].wExpireMinutes;
                        v1Reply.rgMessages[i].cbDetails       = m_response.rgMessages[i].cbDetails;
                        
                    }
                }
                return v1Reply;
            }
            else
            {
                m_response.header.dwSeqNum = m_header.dwSeqNum;
                m_response.header.sgaddr = m_header.sgaddr;

                return (m_response);
            }
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            if (m_header.dwMsgType == (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES)
            {
                var v1Msg = new EnumerateMessagesMsg();
                v1Msg.ReadFromRequest(HttpContext.Current.Request);
                m_request.qwUserID = v1Msg.qwUserID;
            }
            else
            {
                // Deserialize the incoming stream
                m_request.ReadFromRequest(HttpContext.Current.Request);
            }

            // UserID of 0 not allowed
            if(m_request.qwUserID == 0) {
                string err = string.Format("EnumerateMessages: Invalid user ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_ENUMERATEMESSAGES_INVALID_USERID, err);
            }

            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.MESSAGING_ENUMERATEMESSAGES_INVALID_USERID,
                     "EnumerateMessages{0} (user {1}) failed hr=ERROR_NO_SUCH_USER",
                     (m_header.dwMsgType == (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2 ? 2 : 1), (Puid)m_request.qwUserID);
            }

            List<MessageSummary2> summaries = new List<MessageSummary2>((int)MsgDefs.XONLINE_MAX_PERSISTENT_MESSAGES + (int)MsgDefs.XONLINE_MAX_TRANSIENT_MESSAGES);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            { 
                // Call the sproc
                ws.StoredProc = "dbo.p_xmsg_user_message_enumerate";
                ws.Partition = ws.CalcPartition(m_request.qwUserID);
                ws.AddParameter("@bi_user_puid", m_request.qwUserID);

                // Read each message and populate summary objects (up to the maximum number allowed)
                using (WstDataReader wsReader = ws.Execute())
                {
                    for(int i = 0; i < MsgDefs.XONLINE_MAX_PERSISTENT_MESSAGES; i++) {
                        // No more rows
                        if(wsReader.Read() == false) {
                            break;
                        }

                        MessageSummary2 summary = new MessageSummary2();
                        summary.dwMessageID     = (uint)(int)wsReader["i_message_id"];
                        summary.bMessageType    = (byte)(short)wsReader["si_message_type"];
                        summary.dwMessageFlags  = (uint)(int)wsReader["i_message_flags"];
                        summary.qwSenderID      = (ulong)(long)wsReader["bi_sender_puid"];
                        summary.dwSenderTitleID = (uint)(int)wsReader["i_sender_title_id"];
                        summary.qwSenderContext = (ulong)(long)wsReader["bi_sender_context"];
                        summary.szSenderName    = (string)wsReader["vc_sender_name"];
                        summary.mtSentTime      = MsgDefs.DateTimeToMsgTime((DateTime)wsReader["dt_sent_time"]);
                        summary.wExpireMinutes  = (ushort)(short)wsReader["si_expire_minutes"];
                        summary.cbDetails       = (ushort)(short)wsReader["si_properties_size"];
                        summary.szSubject       = (string)wsReader["vc_subject"];
                        summaries.Add(summary);
                    }
                    wsReader.Close();
                }
            }

            m_cPersistentMessages = (ushort)summaries.Count;

            // Retrieve transient messages as well
            TransientMessage[] xmsgs = MessagingUtil.GetTransientMessages(m_request.qwUserID);
            if (xmsgs != null)
            {
                foreach (var xmsg in xmsgs)
                {
                    summaries.Add(xmsg.Summary2);
                }
            }

            // Sort messages by sent time
            summaries.Sort(new SentTimeComparer());

            m_response.cMessages = (ushort)summaries.Count;
            m_response.rgMessages = summaries.ToArray();

            m_response.hr = HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Comparer for sorting messages by sent time
        //-----------------------------------------------------------------------------------
        private class SentTimeComparer : IComparer<MessageSummary2>
        {
            public int Compare(MessageSummary2 left, MessageSummary2 right)
            {
                if(left.mtSentTime > right.mtSentTime) {
                    return(-1);
                } 
                if(left.mtSentTime < right.mtSentTime) {
                    return(1);
                } 

                return(0);
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "ENM|{0:X}:{1:X}|{2}|{3:X}|{4:X}|{5}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID, 
                    m_cPersistentMessages,
                    m_response.cMessages - m_cPersistentMessages,
                    m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\GetMessageDetails.cs ===
//
// GetMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Web;
using xonline.common.community;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process GetMessageDetails requests
    //-----------------------------------------------------------------------------------
    public class GetMessageDetails : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly MessageDetailsMsg   m_request;
        private readonly MessageDetailsReply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public GetMessageDetails(BaseHeader header) : base(header)
        {
            m_request  = new MessageDetailsMsg();
            m_response = new MessageDetailsReply();

            m_response.summary = new MessageSummary();
            m_response.hr      = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            // UserID of 0 not allowed
            if(m_request.qwUserID == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_GETMESSAGEDETAILS_INVALID_USERID, "GetMessageDetails: Invalid user ID 0, seq num {0:X8}", 
                    m_request.header.dwSeqNum);
            }

            // They can't be setting and unsetting the same bits
            if(0 != (m_request.dwSetFlags & m_request.dwUnsetFlags))
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_GETMESSAGEDETAILS_SETUNSET_SAME_FLAGS, 
                    "GetMessageDetails: Call from client @ {0}:{1} user {2} msg {3:X} Attempting to set/unset the same flags (0x{4:X8}, 0x{5:X8})",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID, m_request.dwMessageID, m_request.dwSetFlags, m_request.dwUnsetFlags);
            }

            // They can only set certain flags
            if(0 != (m_request.dwSetFlags & ~MsgDefs.XONLINE_MSG_FLAGS_TITLE_SETABLE))
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_GETMESSAGEDETAILS_SET_INVALID_FLAGS, 
                    "GetMessageDetails: Call from client @ {0}:{1} user {2} msg {3:X} Attempting to set invalid flags (0x{4:X8} not in {5:X8})",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID, m_request.dwMessageID, m_request.dwSetFlags, MsgDefs.XONLINE_MSG_FLAGS_TITLE_SETABLE);
            }

            // They can only unset certain flags
            if(0 != (m_request.dwUnsetFlags & ~MsgDefs.XONLINE_MSG_FLAGS_TITLE_CLEARABLE))
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_GETMESSAGEDETAILS_UNSET_INVALID_FLAGS, 
                    "GetMessageDetails: Call from client @ {0}:{1} user {2} msg {3:X} Attempting to unset invalid flags (0x{4:X8} not in {5:X8})",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID, m_request.dwMessageID, m_request.dwSetFlags, MsgDefs.XONLINE_MSG_FLAGS_TITLE_CLEARABLE);
            }

            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.MESSAGING_GETMESSAGEDETAILS_INVALID_USERID,
                     "GetMessageDetails (user {0}, msg {1:X8}) failed hr=ERROR_NO_SUCH_USER", (Puid)m_request.qwUserID, m_request.dwMessageID);
            }

            if (MsgDefs.IsMsgTransient(m_request.dwMessageID))
            {
                m_response.hr = MessagingUtil.ModifyTransientMessageFlags(
                    m_request.qwUserID,
                    m_request.dwMessageID,
                    m_request.dwSetFlags,
                    m_request.dwUnsetFlags);
                    
                if (m_response.hr != HResult.S_OK)
                {
                    throw new XRLException(m_response.hr, XEvent.Id.MESSAGING_DO_NOT_LOG_EVENT, 
                        "GetMessageDetails: MessagingUtil.ModifyTransientMessageFlags returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                }
                
                TransientMessage xmsg = MessagingUtil.GetTransientMessage(m_request.qwUserID, m_request.dwMessageID);
                if (xmsg == null)
                {
                    throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_DO_NOT_LOG_EVENT, 
                        "GetMessageDetails: MessagingUtil.GetTransientMessage returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                }

                m_response.summary = xmsg.Summary;
                m_response.details = xmsg.Details;
                m_response.hr = HResult.S_OK;
            }
            else
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    // Call the sproc
                    ws.StoredProc = "dbo.p_xmsg_user_message_details";
                    ws.Partition = ws.CalcPartition(m_request.qwUserID);
                    ws.AddParameter("@bi_user_puid", m_request.qwUserID);
                    ws.AddParameter("@i_message_id", m_request.dwMessageID);
                    ws.AddParameter("@i_set_flags", m_request.dwSetFlags);
                    ws.AddParameter("@i_unset_flags", m_request.dwUnsetFlags);

                    using (WstDataReader wsReader = ws.Execute())
                    {
                        // No results
                        if (wsReader.HasRows == false)
                        {
                            throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_DO_NOT_LOG_EVENT, 
                                "GetMessageDetails: p_xmsg_user_message_details returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                        }

                        // Read a single row and populate summary object
                        wsReader.Read();
                        m_response.summary.dwMessageID = (uint)(int)wsReader["i_message_id"];
                        m_response.summary.bMessageType = (byte)(short)wsReader["si_message_type"];
                        m_response.summary.dwMessageFlags = (uint)(int)wsReader["i_message_flags"];
                        m_response.summary.qwSenderID = (ulong)(long)wsReader["bi_sender_puid"];
                        m_response.summary.dwSenderTitleID = (uint)(int)wsReader["i_sender_title_id"];
                        m_response.summary.qwSenderContext = (ulong)(long)wsReader["bi_sender_context"];
                        m_response.summary.szSenderName = (string)wsReader["vc_sender_name"];
                        m_response.summary.mtSentTime = MsgDefs.DateTimeToMsgTime((DateTime)wsReader["dt_sent_time"]);
                        m_response.summary.wExpireMinutes = (ushort)(short)wsReader["si_expire_minutes"];
                        m_response.summary.cbDetails = (ushort)(short)wsReader["si_properties_size"];

                        // If there are details present, get the blob and deserialize it into the details object
                        if (m_response.summary.cbDetails > 0)
                        {
                            byte[] propBinary = (byte[])wsReader["vb_properties"];
                            m_response.details = new MessageDetails();
                            m_response.details.ReadBytes(propBinary);
                        }

                        wsReader.Close();

                        m_response.hr = HResult.S_OK;
                    }
                }
            }

        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "DET|{0:X}:{1:X}|{2}|{3:X}|{4:X}|{5:X}|{6:X}|{7}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID, m_request.dwMessageID,
                    m_request.dwSetFlags, m_request.dwUnsetFlags, m_request.header.dwMsgType, m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\GetMessageSummary.cs ===
//
// GetMessageSummary.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Web;
using xonline.common.community;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process GetMessageSummary requests
    //-----------------------------------------------------------------------------------
    public class GetMessageSummary : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly MessageSummary2Msg   m_request;
        private readonly MessageSummary2Reply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public GetMessageSummary(BaseHeader header) : base(header)
        {
            m_request  = new MessageSummary2Msg();
            m_response = new MessageSummary2Reply();

            m_response.summary = new MessageSummary2();
            m_response.hr      = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            // UserID of 0 not allowed
            if(m_request.qwUserID == 0) {
                string err = string.Format("GetMessageSummary: Invalid user ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_GETMESSAGESUMMARY_INVALID_USERID, err);
            }

            // Message ID from failed send not allowed
            if(0 != (m_request.dwMessageID & MsgDefs.XONLINE_MSG_ID_SEND_FAILED)) {
                string err = string.Format("GetMessageSummary: Call from client @ {0}:{1} Bad message ID 0x{2:X8}",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.dwMessageID);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_GETMESSAGESUMMARY_MESSAGEID_FROM_FAILED_SEND, err); 
            }

            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.MESSAGING_GETMESSAGESUMMARY_INVALID_USERID,
                     "GetMessageSummary (user {0}, msg {1:X8}) failed hr=ERROR_NO_SUCH_USER", (Puid)m_request.qwUserID, m_request.dwMessageID);
            }

            if (MsgDefs.IsMsgTransient(m_request.dwMessageID))
            {
                TransientMessage xmsg = MessagingUtil.GetTransientMessage(m_request.qwUserID, m_request.dwMessageID);
                if (xmsg == null)
                {
                    string err = string.Format("GetMessageDetails: MessagingUtil.GetTransientMessage returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                    throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_GETMESSAGEDETAILS_INVALID_MESSAGEID, err);
                }

                m_response.summary = xmsg.Summary2;
                m_response.hr = HResult.S_OK;
            }
            else
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    // Call the sproc
                    ws.StoredProc = "dbo.p_xmsg_user_message_summary";
                    ws.Partition = ws.CalcPartition(m_request.qwUserID);
                    ws.AddParameter("@bi_user_puid", m_request.qwUserID);
                    ws.AddParameter("@i_message_id", m_request.dwMessageID);

                    using (WstDataReader wsReader = ws.Execute())
                    {
                        // No results
                        if (wsReader.HasRows == false)
                        {
                            string err = string.Format("GetMessageSummary: p_xmsg_user_message_summary returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                            throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_GETMESSAGESUMMARY_INVALID_MESSAGEID, err);
                        }

                        // Read a single row and populate summary object
                        wsReader.Read();
                        m_response.summary.dwMessageID = (uint)(int)wsReader["i_message_id"];
                        m_response.summary.bMessageType = (byte)(short)wsReader["si_message_type"];
                        m_response.summary.dwMessageFlags = (uint)(int)wsReader["i_message_flags"];
                        m_response.summary.qwSenderID = (ulong)(long)wsReader["bi_sender_puid"];
                        m_response.summary.dwSenderTitleID = (uint)(int)wsReader["i_sender_title_id"];
                        m_response.summary.qwSenderContext = (ulong)(long)wsReader["bi_sender_context"];
                        m_response.summary.szSenderName = (string)wsReader["vc_sender_name"];
                        m_response.summary.szSubject = (string)wsReader["vc_subject"];
                        m_response.summary.mtSentTime = MsgDefs.DateTimeToMsgTime((DateTime)wsReader["dt_sent_time"]);
                        m_response.summary.wExpireMinutes = (ushort)(short)wsReader["si_expire_minutes"];
                        m_response.summary.cbDetails = (ushort)(short)wsReader["si_properties_size"];
                        wsReader.Close();

                        m_response.hr = HResult.S_OK;
                    }
                }
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "SUM|{0:X}:{1:X}|{2}|{3:X}|{4:X}|{5}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID,
                    m_request.dwMessageID, m_request.header.dwMsgType, m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\Messaging.cs ===
//
// Forwarder.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Text;
using System.IO;
using System.Web;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Forward messages to messaging
    //-----------------------------------------------------------------------------------
    public class Messaging : IHttpHandler
    {
        public void ProcessRequest(HttpContext httpCtx)
        {
            // just for kicks, make sure this is cached.
            HttpContext ctx = HttpContext.Current;
            MemoryStream response = new MemoryStream();
            HResult hr = HResult.S_OK;
            
            // This is the first step, so log the request to the debug stream
            LogFDRequest();

            MessagingHandlerBase handler = null;
            XomRequestTimeElapsed elapsed = new XomRequestTimeElapsed();

            try 
            {
                // Get the handler 
                MessagingHandlerBase.GetHandler(out handler);
                handler.ProcessRequest();

                MessagingPerAPICounters.Total.SuccessRate.Increment();
                MessagingPerAPICounters.Total[MessagingHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].SuccessRate.Increment();
            }
            catch(Exception e)
            {
                XEvent.Id eventId = XEvent.Id.MC_APPLICATION_ERROR;
                hr = HResult.XONLINE_E_SERVER_ERROR;
                XRLException xrle = e as XRLException;
                if (xrle != null)
                {
                    hr = xrle.HResult;
                    eventId = xrle.EventId;
                }

                if (eventId != XEvent.Id.MESSAGING_DO_NOT_LOG_EVENT)
                {
                    Xom.NtEvent(eventId, "Error processing request.\r\nException: {0}\r\nMessage type: {1}: {2}\r\nUser ID: {3}",
                        e.ToString(),
                        (handler == null) ? 0 : handler.m_header.dwMsgType,
                        (handler == null) ? "unknown" : MessagingHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType),
                        (Puid)((handler == null) ? 0 : handler.m_qwUserID));
                }
                
                if (handler != null)
                {
                    hr = handler.ProcessError(hr);
                    MessagingPerAPICounters.Total[MessagingHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].FailureRate.Increment();
                }

                MessagingPerAPICounters.Total.FailureRate.Increment();
            }
            finally
            {
                if (handler != null)
                {
                    handler.WriteResponse(response);
                    handler.LogResults();
                    MessagingPerAPICounters.Total[MessagingHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].RequestsPerSecond.Increment();
                    MessagingPerAPICounters.Total[MessagingHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
                    MessagingPerAPICounters.Total[MessagingHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].ResponseTimeAvgBase.Increment();
                }

                MessagingPerAPICounters.Total.RequestsPerSecond.Increment();
                MessagingPerAPICounters.Total.ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
                MessagingPerAPICounters.Total.ResponseTimeAvgBase.Increment();
            }

            byte[] rgbResponse = response.ToArray();
            XRLUtil.SetXRLResponse(HttpContext.Current.Response, XOService.MessagingService, 0, hr, (rgbResponse.Length > 0) ? rgbResponse : null);
        }


        public bool IsReusable {
            get { return(true); }
        }

        //-------------------------------------------------------------------------------
        // LogFDRequest - Log the incoming request
        //-------------------------------------------------------------------------------
        public static void LogFDRequest()
        {
            Xom.Trace(XomAreaName.messagingfd, LogLevel.L_NORMAL, "Request: Url={0} User-Agent={1}\r\n{2}",
                      HttpContext.Current.Request.RawUrl, HttpContext.Current.Request.UserAgent,
                      StreamToString(HttpContext.Current.Request.InputStream, true));
        }

        //-------------------------------------------------------------------------------
        // StreamToString - returns a string representation of a stream
        //-------------------------------------------------------------------------------
        private static string StreamToString(Stream stream, bool fShowOffset)
        {
            if(stream == null) {
                return("");
            }

            // Store the original position of the stream
            long lOriginalPos = stream.Position;

            // Seek to the beginning of the stream
            stream.Seek(0, SeekOrigin.Begin);

            StringBuilder sb = new StringBuilder();

            // We will build lines of the format:
            // "00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................"
            uint dwOffset = 0;
            while(dwOffset < stream.Length) {
                // Add the offset if requested
                if(fShowOffset) {
                    sb.Append(dwOffset.ToString("X8"));
                    sb.Append(" ");
                }

                long lLineStartPos = stream.Position;

                // Display the raw bytes
                for(uint iByte = 0; iByte < 16; iByte++) {
                    if(dwOffset + iByte < stream.Length) {
                        byte b = (byte)stream.ReadByte();
                        sb.Append(b.ToString("X2"));
                        sb.Append(" ");
                    } else {
                        sb.Append("   ");
                    }
                }

                // We want 4 spaces between the byte and character display (one space already follows the last byte)
                sb.Append("   ");

                // Go back to the start of the line
                stream.Seek(lLineStartPos, SeekOrigin.Begin);

                // Display the bytes as characters
                for(uint iByte = 0; iByte < 16; iByte++) {
                    if(dwOffset + iByte < stream.Length) {
                        byte b = (byte)stream.ReadByte();

                        if(0x20 <= b && 0x7E >= b) {// C's isprint function
                            sb.Append((char)b);
                        } else {
                            sb.Append(".");
                        }
                    } else {
                        sb.Append(" ");
                    }
                }

                // End the line
                sb.Append("\r\n");

                dwOffset += 16;
            }

            // Put the stream back where we found it
            stream.Seek(lOriginalPos, SeekOrigin.Begin);

            return(sb.ToString());
        } 
    }


    [XomPerformanceCounterCategoryAttr( "Messaging FD - API", "XBox Live Messaging Service Frontdoor: Per API Info" )]
    public class MessagingPerAPICounters : XomPerformanceCounterCategory
    {
        public MessagingPerAPICounters() : base(true)
        {
        }
        
        public virtual MessagingPerAPICounters this[string APIName]
        {
            get
            {
                return (MessagingPerAPICounters) GetInstance(APIName);
            }
        }

        static public MessagingPerAPICounters Total = new MessagingPerAPICounters();

        [XomPerformanceCounterAttr(
            "Requests per Second", 
            "Number of requests per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Average Response Time", 
            "Average time a request takes to be processed.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ResponseTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Respone Time Base", 
            "Base for Average time a request takes to be processed.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ResponseTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Success Rate", 
            "Number of requests succeeded per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SuccessRate;

        [XomPerformanceCounterAttr(
            "Failure Rate", 
            "Number of requests failed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailureRate;

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\messagingApp.cs ===
// 
// MessagingApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Messaging Front Door
// Xbox Online Service
// 
// Author: dberke
//
using System;
using System.Web;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomSrfInstallerAttribute(Interface.xpnfd_messaging)]
[assembly: XomSrfInstallerAttribute(Interface.xpnfd_messaging_int)]
[assembly: Config(Component.messagingfd)]

[assembly: XomAreaDefinition(XomAreaName.messagingfd)]
[assembly: XomAreaDefinition(XomAreaName.messagingfdLog)]

namespace xonline.server.messaging.fd
{
    // -----------------------------------------------------------------------------------
    // MessagingApp class - the main application class
    // -----------------------------------------------------------------------------------
    public class MessagingApp : FrontEndApp
    {
        // -------------------------------------------------------------------------------
        // Application_Start - called once when the front door starts up
        // -------------------------------------------------------------------------------
        protected override void OnApplicationStart()
        {
        }

        // -------------------------------------------------------------------------------
        // Application_BeginRequest - called at the beginning of every request
        // -------------------------------------------------------------------------------
        public override void Application_BeginRequest( object sender, EventArgs e )
        {
            // Call the base class
            base.Application_BeginRequest(sender, e);
        }

        // -------------------------------------------------------------------------------
        // Application_EndRequest - called at the end of every request
        // -------------------------------------------------------------------------------
        public override void Application_EndRequest( object sender, EventArgs e )
        {
            // Call the base class
            base.Application_EndRequest(sender, e);
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\MessagingHandlerBase.cs ===
//
// MessagingHandlerBase.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Base class for messaging service handlers
    //-----------------------------------------------------------------------------------
    public abstract class MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Functions to be implemented is the specific subclasses
        //-----------------------------------------------------------------------------------
        public abstract void ProcessRequest();
        public abstract HResult ProcessError(HResult hr);
        public abstract void LogResults();
        protected abstract XRLObject2 GetResponse();

        //-----------------------------------------------------------------------------------
        // Protected data
        //-----------------------------------------------------------------------------------
        public BaseHeader m_header;
        public ulong m_qwUserID;
        public bool        m_bIsDatacenter;
        

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        protected MessagingHandlerBase(BaseHeader header)
        {
            m_header = header;
        }

        //-----------------------------------------------------------------------------------
        // Get the handler based on message type
        //-----------------------------------------------------------------------------------

        public static void GetHandler(out MessagingHandlerBase handler)
        {
            // Save the starting position of the stream
            HttpContext httpCtx = HttpContext.Current;
            long streamStartPos = HttpContext.Current.Request.InputStream.Position;
            handler = null;

            try
            {
                BaseHeader header = ReadHeader(HttpContext.Current);

                switch(header.dwMsgType) {
                    case (uint)Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2:
                        handler = new GetMessageSummary(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_MESSAGE_DETAILS:
                        handler = new GetMessageDetails(header);
                        break;
                    case (uint)Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS:
                        handler = new GetSystemMessageDetails(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES:
                    case (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2:
                        handler = new EnumerateMessages(header);
                        break;
                    case (uint)Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES:
                        handler = new EnumerateSystemMessages(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_DELETE_MESSAGE:
                        handler = new DeleteMessage(header);
                        break;
                    case (uint)Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE:
                        handler = new DeleteSystemMessage(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_MESSAGE_FLAGS:   
                        handler = new MessageFlags(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_SEND_MESSAGE:
                        handler = new SendMessageHandler(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE:
                    case (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_EX:
                        handler = new RevokeMessage(header);
                        break;

                    case (uint)Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE:
                        handler = new SendSystemMessageHandler(header);
                        break;
                }

                if (handler == null)
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_UNKNOWN_MESSAGE_TYPE,
                        "messagingfd: Unknown message type " + header.dwMsgType);
                }

                handler.m_header = header;

                // Perform required validations
                handler.CheckSource();
                handler.ValidateHeader();
            }
            finally
            {
                // Reset the stream to the start so it can be deserialized into the request wiredata object
                HttpContext.Current.Request.InputStream.Position = streamStartPos;
            }
        }

        //-----------------------------------------------------------------------------------
        // Read the header
        //-----------------------------------------------------------------------------------
        private static BaseHeader ReadHeader(HttpContext httpCtx)
        {
            BaseHeader   header = new BaseHeader();
            BinaryReader reader = new BinaryReader(httpCtx.Request.InputStream);
            
            long dwBytesLeft = httpCtx.Request.InputStream.Length - httpCtx.Request.InputStream.Position;
            if(dwBytesLeft < header.Size()) {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.MESSAGING_HEADER_TRUNCATED,
                                       "messagingfd: Message is too short for header.");
            }

            // Read in the header
            header.ReadStream(reader);

            return header;
        }

        //-----------------------------------------------------------------------------------
        // Properties
        //-----------------------------------------------------------------------------------
        public uint MessageType 
        {
            get { return(m_header.dwMsgType); }
        }

        public ulong UserID 
        {
            get { return(m_qwUserID); }
        }

        //-----------------------------------------------------------------------------------
        // Send the response to the caller
        //-----------------------------------------------------------------------------------
        public void WriteResponse(MemoryStream stream)
        {
            XRLObject2 resp = GetResponse();
            if (resp != null)
            {
                byte[] rgbResp = (byte[])resp; 
                stream.Write(rgbResp, 0, rgbResp.Length);
            }
        }

        //-----------------------------------------------------------------------------------
        // Validate the call source
        //-----------------------------------------------------------------------------------
        private void CheckSource()
        {
            Xom.Trace(XomAreaName.messagingfdLog, LogLevel.L_LOW, "messagingfd.CheckSource thread={0}", Thread.CurrentThread.GetHashCode());

            // Check the port the request came from
            // For some reason, HttpContext.Request.Url is rather slow.
            // To help us out, xrlscan has dropped the request port into an
            // HTTP header, which seems to be quicker than getting the port
            // out of the URL. If the header is there, use it.
            ushort wPortUsed;
            string serverPort = HttpContext.Current.Request.Headers["ServerPort"];
            if(serverPort != null) {
                // Strangely, while the REMOTE_PORT server variable returns the port in network
                // order, so we have to byte swap it, the SERVER_PORT server variable returns
                // the port in host order, so no byte swap is required. Very confusing.
                wPortUsed = Convert.ToUInt16(serverPort);
            } else {
                wPortUsed = (ushort)HttpContext.Current.Request.Url.Port;
            }

            string viface = VirtualInterface.None;
            if(CallSource.IsVirtualInterfacePort(VirtualInterface.xpnfd_messaging, wPortUsed)) {
                viface = VirtualInterface.xpnfd_messaging;
                m_bIsDatacenter = false;
            } else if(CallSource.IsVirtualInterfacePort(VirtualInterface.xpnfd_messaging_int, wPortUsed)) {
                viface = VirtualInterface.xpnfd_messaging_int;
                m_bIsDatacenter = true;
            }

            if(viface == VirtualInterface.None) {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_ERROR, XEvent.Id.MESSAGING_NO_VINTERFACE,
                    "messagingfd.CheckSource: Could not determine virtual interface for port " + wPortUsed);
            }

            CallSource.Set(HttpContext.Current, viface);

            Xom.Trace(XomAreaName.messagingfdLog, LogLevel.L_LOW, "messagingfd.CheckSource: vinterface={0}", viface);
        }

        //-----------------------------------------------------------------------------------
        // Validate data in the header - message length, type, etc.
        //-----------------------------------------------------------------------------------
        private void ValidateHeader()
        {
            Xom.Trace(XomAreaName.messagingfdLog, LogLevel.L_LOW, "messagingfd.ValidateHeader thread={0}", Thread.CurrentThread.GetHashCode());

            // Validate service request on XRL post
            if(!XRLUtil.IsValidXOnlineRequest(HttpContext.Current.Request, XOService.MessagingService)) {
                throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE, XEvent.Id.MESSAGING_BAD_CONTENT_TYPE,
                    "messagingfd.ValidateHeader: Content-Type in request is incorrect " +
                    "User-Agent: " + HttpContext.Current.Request.UserAgent +
                    ", Content-Type: " + HttpContext.Current.Request.ContentType +
                    ", Expected: " + (uint)XOService.MessagingService);
            }

            // We already read the header.  Inputstream should be pointing at the point right after it.
            BinaryReader reader = new BinaryReader(HttpContext.Current.Request.InputStream);
            long dwBytesLeft = HttpContext.Current.Request.InputStream.Length - HttpContext.Current.Request.InputStream.Position;

            // Make sure there is enough room for the request
            if(dwBytesLeft < m_header.dwMsgLen) {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.MESSAGING_HEADER_TRUNCATED,
                                       "messagingfd: Message is too short for request.");
            }

            if(IsUserMessageType(m_header.dwMsgType)) {
                // Make sure there is enough room to read the user ID
                if(m_header.dwMsgLen < 8) {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.MESSAGING_NOTIFICATION_MESSAGE_TRUNCATED,
                                           "messagingfd.ValidateHeader: Message is too short for userId.");
                }

                // Read user ID
                m_qwUserID = reader.ReadUInt64();

                // Can't get a connection without a PUID
                if(m_qwUserID == 0 && m_bIsDatacenter == false) {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_INVALID_USERID,
                                           string.Format("messagingfd.ValidateHeader: User PUID is zero. type {0}, sg {1:X}, spi {2:X}, xb {3}", 
                                                         m_header.dwMsgType, m_header.sgaddr.inaSg, m_header.sgaddr.dwSpiSg,
                                                         (Puid)m_header.sgaddr.qwXboxId));
                }

                if((0xffffffffffffffff == m_qwUserID)) {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_INVALID_USERID,  
                                           string.Format("messagingfd.ValidateHeader: User PUID is 0xffffffffffffffff. type {0}, sg {1:X}, spi {2:X}, xb {3}", 
                                                         m_header.dwMsgType, m_header.sgaddr.inaSg, m_header.sgaddr.dwSpiSg,
                                                         (Puid)m_header.sgaddr.qwXboxId));
                }
            }

            // We relax several restrictions for calls on the datacenter port
            if(m_bIsDatacenter) 
            {
                //  Make sure that this message was sent to the right place
                if(IsDatacenterMessageType(m_header.dwMsgType) == false) {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE, XEvent.Id.MESSAGING_INVALID_DC_MESSAGE_TYPE,
                                           "messagingfd.ValidateHeader: Invalid datacenter message type " + m_header.dwMsgType);                    
                }
            } 
            else 
            {
                //  Make sure that this message was sent to the right place
                if(IsClientMessageType(m_header.dwMsgType) == false) {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE, XEvent.Id.MESSAGING_INVALID_CLIENT_MESSAGE_TYPE,
                                           "messagingfd.ValidateHeader: Invalid client message type " + m_header.dwMsgType);                    
                }

                // Do we authenticate this type of message?
                if(IsAuthMessageType(m_header.dwMsgType)) 
                {
                    CheckSgInfo();
                }
            }
        }

        private void CheckSgInfo()
        {
            // Get the sgaddr
            SGInfo sginfo = SGInfo.Current;

            // Verify the machine id in the request matches what the SG told us
            sginfo.VerifyMachineId2(m_header.sgaddr.qwXboxId);

            // TODO: SGInfo doesn't allow access to inaSg and dwSpiSg right now

            // DEAD_USER is the only message allowed when the user is not present, and DEAD_USER is
            // only valid in this case. If the user is present, the msgtype must not be DEAD_USER,
            // and if the user is not present, the msgtype must be DEAD_USER.
            if(sginfo.IsUserPresent(m_qwUserID) == ((uint)P_MSG_TYPES.PMSG_DEAD_USER == m_header.dwMsgType)) {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, XEvent.Id.MESSAGING_SGINFO_INVALID_PUID,
                                       "messagingfd.CheckSgInfo: Mismatch (DEAD_USER) == (PUID found) in request, user="
                                        + (Puid)m_qwUserID + " msgtype=" + m_header.dwMsgType);
            }
        }

        //-------------------------------------------------------------------------------
        // IsUserMessageType - true if user ID directly follows the header in the request
        //-------------------------------------------------------------------------------
        private static bool IsUserMessageType(uint dwMsgType)
        {
            switch(dwMsgType) {
                case (uint)Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES:
                case (uint)Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS:
                case (uint)Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE:
                    return(false);
                default:
                    return(true);
            }
        }

        //-------------------------------------------------------------------------------
        // IsDatacenterMessageType - true if this message is valid on the datacenter port
        //-------------------------------------------------------------------------------
        private static bool IsDatacenterMessageType(uint dwMsgType)
        {
            switch(dwMsgType) {
                case (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_DETAILS:
                case (uint)Q_MSG_TYPES.QMSG_DELETE_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_SEND_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_DELETE_TITLE:
                case (uint)Q_MSG_TYPES.QMSG_ENUM_TITLES:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_FLAGS:
                case (uint)Q_MSG_TYPES.QMSG_ENUM_SYSTEM_MESSAGES:
                case (uint)Q_MSG_TYPES.QMSG_SYSTEM_MESSAGE_DETAILS:
                case (uint)Q_MSG_TYPES.QMSG_DELETE_SYSTEM_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_SEND_SYSTEM_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_EX:
                case (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2:
                    return(true);
                default:
                    return(false);
            }
        }

        //-------------------------------------------------------------------------------
        // IsClientMessageType - True if this message is valid on the client port
        //-------------------------------------------------------------------------------
        private static bool IsClientMessageType(uint dwMsgType)
        {
            switch(dwMsgType) {
                case (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_DETAILS:
                case (uint)Q_MSG_TYPES.QMSG_DELETE_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_SEND_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE:
                case (uint)Q_MSG_TYPES.QMSG_DELETE_TITLE:
                case (uint)Q_MSG_TYPES.QMSG_ENUM_TITLES:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_FLAGS:
                case (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE_EX:
                case (uint)Q_MSG_TYPES.QMSG_ENUM_MESSAGES_2:
                case (uint)Q_MSG_TYPES.QMSG_MESSAGE_SUMMARY_2:
                    return(true);
                default:
                    return(false);
            }
        }

        //-------------------------------------------------------------------------------
        // IsAuthMessageType - true if auth data should be requested from the Security Gateway
        //-------------------------------------------------------------------------------
        private static bool IsAuthMessageType(uint dwMsgType)
        {
            switch(dwMsgType) {
                case (uint)Q_MSG_TYPES.QMSG_SEND_MESSAGE:
                    return(true);

                default:
                    return(false);
            }
        }

        //-------------------------------------------------------------------------------
        // GetRequestTypeName - Get the name of the message type
        //-------------------------------------------------------------------------------
        public static string GetRequestTypeName(uint dwMsgType)
        {
            if(((dwMsgType >= (uint)P_MSG_TYPES.PMSG_MIN_REQ_TYPE) && (dwMsgType <= (uint)P_MSG_TYPES.PMSG_MAX_REQ_TYPE)) ||
               ((dwMsgType >= (uint)P_MSG_TYPES.PMSG_MIN_REPLY_TYPE) && (dwMsgType <= (uint)P_MSG_TYPES.PMSG_MAX_REPLY_TYPE))) {
                return((P_MSG_TYPES)dwMsgType).ToString();
            }
            
            if(((dwMsgType >= (uint)Q_MSG_TYPES.QMSG_MIN_REQ_TYPE) && (dwMsgType <= (uint)Q_MSG_TYPES.QMSG_MAX_REQ_TYPE)) ||
               ((dwMsgType >= (uint)Q_MSG_TYPES.QMSG_MIN_REPLY_TYPE) && (dwMsgType <= (uint)Q_MSG_TYPES.QMSG_MAX_REPLY_TYPE))) {
                return((Q_MSG_TYPES)dwMsgType).ToString();
            }

            return("Unknown Message Type!");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\GetSystemMessageDetails.cs ===
//
// GetSystemMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process GetSystemMessageDetails requests
    //-----------------------------------------------------------------------------------
    public class GetSystemMessageDetails : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly SystemMessageDetailsMsg   m_request;
        private readonly SystemMessageDetailsReply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public GetSystemMessageDetails(BaseHeader header) : base(header)
        {
            m_request  = new SystemMessageDetailsMsg();
            m_response = new SystemMessageDetailsReply();

            m_response.summary = new SystemMessageSummary();
            m_response.summary.dtSentTime = DateTime.UtcNow;        // Must set this because default is not a valid FileTime
            m_response.hr      = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            if(m_request.dwMessageID == 0) {
                string err = string.Format("GetSystemMessageDetails: Invalid message ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
                throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_GETSYSTEMMESSAGEDETAILS_INVALID_MESSAGEID, err);
            }

            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE)) {
                // Call the sproc
                ws.StoredProc = "dbo.p_xmsg_system_message_details";
                ws.Partition = WSClient.ANY_PARTITION;
                ws.AddParameter("@i_title_id",   m_request.dwTitleID);
                ws.AddParameter("@i_message_id", m_request.dwMessageID);

                using(WstDataReader wsReader = ws.Execute()) {
                    // No results
                    if(wsReader.HasRows == false) {
                        string err = string.Format("GetSystemMessageDetails: p_xmsg_system_message_details returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                        throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_GETSYSTEMMESSAGEDETAILS_MESSAGE_NOT_FOUND, err);
                    }

                    // Read a single row and populate summary object
                    wsReader.Read();
                    m_response.summary.dwRegion        = (uint)(int)wsReader["i_region"];
                    m_response.summary.dwMessageID     = (uint)(int)wsReader["i_message_id"];
                    m_response.summary.bMessageType    = (byte)(short)wsReader["si_message_type"];
                    m_response.summary.dwMessageFlags  = (uint)(int)wsReader["i_message_flags"];
                    m_response.summary.dwTitleID       = (uint)(int)wsReader["i_sender_title_id"];
                    m_response.summary.qwSenderContext = (ulong)(long)wsReader["bi_sender_context"];
                    m_response.summary.szSenderName    = (string)wsReader["vc_sender_name"];
                    m_response.summary.dtSentTime      = (DateTime)wsReader["dt_sent_time"];
                    m_response.summary.wExpireMinutes  = (ushort)(short)wsReader["si_expire_minutes"];
                    m_response.summary.cbDetails       = (ushort)(short)wsReader["si_properties_size"];
                    m_response.summary.szDescription   = (string)wsReader["vc_description"];

                    // If there are details present, get the blob and deserialize it into the details object
                    if(m_response.summary.cbDetails > 0) {
                        byte[] propBinary = (byte[])wsReader["vb_properties"];
                        m_response.details = new MessageDetails();
                        m_response.details.ReadBytes(propBinary);
                    }

                    wsReader.Close();
                }

                m_response.hr = HResult.S_OK;
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "DTS|{0:X}:{1:X}|{2}|{3:X}|{4:X}|{5}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, 
                    (TitleId)m_request.dwTitleID, m_request.dwMessageID,
                    m_request.header.dwMsgType, m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\MessageFlags.cs ===
//
// MessageFlags.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.community;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process MessageFlags requests
    //-----------------------------------------------------------------------------------
    public class MessageFlags : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly MessageFlagsMsg   m_request;
        private readonly MessageFlagsReply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public MessageFlags(BaseHeader header) : base(header)
        {
            m_request  = new MessageFlagsMsg();
            m_response = new MessageFlagsReply();

            m_response.hr = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadFromRequest(HttpContext.Current.Request);

            // UserID of 0 not allowed
            if(m_request.qwUserID == 0) {
                string err = string.Format("MessageFlags: Invalid user ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_MESSAGEFLAGS_INVALID_USERID, err);
            }

            // They can't set and unset the same flags
            if(0 != (m_request.dwSetFlags & m_request.dwUnsetFlags)) {
                string err = string.Format("MessageFlags: Call from client @ {0}:{1} - Attempting to set/unset the same flags (0x{2:X8}, 0x{3:X8}), seq num {4:X8}", 
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, 
                                           m_request.dwSetFlags, m_request.dwUnsetFlags, m_request.header.dwSeqNum);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_MESSAGEFLAGS_SET_AND_UNSET, err);
            }

            // They can only set certain flags
            if(0 != (m_request.dwSetFlags & ~MsgDefs.XONLINE_MSG_FLAGS_TITLE_SETABLE)) {
                string err = string.Format("MessageFlags: Call from client @ {0}:{1} User {2} message 0x{3:X8} Attempting to set invalid flags (0x{4:X8} not in 0x{5:X8})",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort,
                                           (Puid)m_request.qwUserID, m_request.dwMessageID, 
                                           m_request.dwSetFlags, MsgDefs.XONLINE_MSG_FLAGS_TITLE_SETABLE);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_MESSAGEFLAGS_FLAG_NOT_SETABLE, err); 
            }

            // They can only unset certain flags
            if(0 != (m_request.dwUnsetFlags & ~MsgDefs.XONLINE_MSG_FLAGS_TITLE_CLEARABLE)) {
                string err = string.Format("MessageFlags: Call from client @ {0}:{1} User {2} message 0x{3:X8} Attempting to unset invalid flags (0x{4:X8} not in 0x{5:X8})",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort,
                                           (Puid)m_request.qwUserID, m_request.dwMessageID, 
                                           m_request.dwUnsetFlags, MsgDefs.XONLINE_MSG_FLAGS_TITLE_CLEARABLE);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_MESSAGEFLAGS_FLAG_NOT_UNSETABLE, err); 
            }
            
            // Message ID from failed send not allowed
            if(0 != (m_request.dwMessageID & MsgDefs.XONLINE_MSG_ID_SEND_FAILED)) {
                string err = string.Format("MessageFlags: Call from client @ {0}:{1} Bad message ID 0x{2:X8}",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.dwMessageID);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_MESSAGEFLAGS_MESSAGEID_FROM_FAILED_SEND, err); 
            }

            if (MsgDefs.IsMsgTransient(m_request.dwMessageID))
            {
                m_response.hr = MessagingUtil.ModifyTransientMessageFlags(
                    m_request.qwUserID,
                    m_request.dwMessageID, 
                    m_request.dwSetFlags, 
                    m_request.dwUnsetFlags);
            }
            else
            {
                using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE)) 
                {
                    // Call the sproc
                    ws.StoredProc = "dbo.p_xmsg_user_message_modify_flags";
                    ws.Partition = ws.CalcPartition(m_request.qwUserID);
                    ws.AddParameter("@bi_user_puid",   m_request.qwUserID);
                    ws.AddParameter("@i_message_id",   m_request.dwMessageID);
                    ws.AddParameter("@i_set_flags",    m_request.dwSetFlags);
                    ws.AddParameter("@i_unset_flags",  m_request.dwUnsetFlags);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);  
                    ws.ExecuteNonQuery();

                    // Check the results
                    HResult ret = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(ret)) 
                    {
                        m_response.hr = ret;
                    } 
                    else if (ret == HResult.S_FALSE) 
                    {
                        // No results
                        string err = string.Format("MessageFlags: p_xmsg_user_message_modify_flags returned message not found, seq num {0:X8}", m_request.header.dwSeqNum);
                        throw new XRLException(HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, XEvent.Id.MESSAGING_MESSAGEFLAGS_INVALID_MESSAGEID, err);
                    } 
                    else 
                    {
                        // Update flags succeeded
                        m_response.hr = HResult.S_OK;
                    }
                }
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "FLG|{0:X}:{1:X}|{2}|{3:X}|{4:X}|{5:X}|{6}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwUserID,
                    m_request.dwMessageID, m_request.dwSetFlags, m_request.dwUnsetFlags, m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\MessagingHealthBlock.cs ===
// 
// MessagingHealthBlock.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Health check for messaging Front Door
// Xbox Online Service
// 
// Author: dberke
//
using xonline.common.health;
using System.Collections.Specialized;

namespace xonline.server.messaging.fd
{
    public class MessagingHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return(ResourceTypeEnum.Local); }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\RevokeMessage.cs ===
//
// RevokeMessage.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.community;

namespace xonline.server.messaging.fd
{
    //-----------------------------------------------------------------------------------
    // Process RevokeMessage requests
    //-----------------------------------------------------------------------------------
    public class RevokeMessage : MessagingHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private readonly RevokeMessageExMsg m_request;
        private readonly RevokeMessageReply m_response;
        
        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public RevokeMessage(BaseHeader header) : base(header)
        {
            m_request  = new RevokeMessageExMsg();
            m_response = new RevokeMessageReply();

            m_response.hr = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;

            return(m_response);
        }

        private bool MessageMatch(TransientMessage tmsg)
        {
            if (0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER))
            {
                return (m_request.qwSenderID == tmsg.Summary.qwSenderID);
            }
            if (0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT))
            {
                return (m_request.qwSenderContext == tmsg.Summary.qwSenderContext);
            }
            if (0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP))
            {
                byte proptype = MsgDefs.XOnlineMessageGetPropType(m_request.wPropTag);
                foreach (MessageProperty prop in tmsg.Details.rgProperties)
                {
                    if (prop.wPropTag != m_request.wPropTag)
                        continue;
                    if ((proptype == MsgDefs.XONLINE_MSG_PROP_TYPE_NULL) ||
                        (proptype == MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL) ||
                        (proptype == MsgDefs.XONLINE_MSG_PROP_TYPE_I1) || ((proptype == MsgDefs.XONLINE_MSG_PROP_TYPE_I2))
                        )
                    {
                        return MessagingUtil.MemCmpImpl(prop.wPropOffset, m_request.rgbProp);
                    }
                    else
                    {
                        return MessagingUtil.MemCmpImpl(tmsg.Details.rgbData, m_request.rgbProp, m_request.cbProp, prop.wPropOffset);
                    }
                }
                return false;
            }

            return true;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // If a revoke message was sent, deserialze the incoming stream and convert it to RevokeEx
            if(m_header.dwMsgType == (uint)Q_MSG_TYPES.QMSG_REVOKE_MESSAGE) {
                ReadRevokeAsRevokeEx(HttpContext.Current);
            } else {
                // Deserialize the incoming stream
                m_request.ReadFromRequest(HttpContext.Current.Request);
            }

            // Validate recipient count
            if(m_request.cRecipients > MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Too many recipients ({2} > {3})",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, 
                                           m_request.cRecipients, MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_TOO_MANY_RECIPIENTS, err); 
            }

            // Validate prop size
            if(MsgDefs.XONLINE_MAX_MESSAGE_DETAILS < m_request.cbProp) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Prop size is too large ({2} > {3})",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, 
                                           m_request.cbProp, MsgDefs.XONLINE_MAX_MESSAGE_DETAILS);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_PROP_SIZE_TOO_LARGE, err); 
            }

            // Validate each allowed flag

            // Block sender has some special restrictions
            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER)) {
                // Can't block sender if we don't have one
                if(0 == (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER)) {
                    string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Can't block sender if not specified (0x{2:X8})",
                                               SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.dwFlags);
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_BLOCK_SENDER_NOT_SPECIFIED, err); 
                }

                // This should only be used when there is exactly one recipient
                if(1 != m_request.cRecipients) {
                    string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Can't block sender for more than one recipient (0x{2:X4})",
                                               SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.cRecipients);
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_CANT_BLOCK_MORE_THAN_ONE, err); 
                }
            }

            // If revoking by ID, the IDs must be non-zero
            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID)) {
                // Validate recipient count
                if(0 == m_request.cRecipients) {
                    string err = string.Format("RevokeMessage: Call from client @ {0}:{1} No recipients (0)",
                                               SGInfo.Current.ClientIP, SGInfo.Current.ClientPort);
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_NO_RECIPIENTS, err); 
                }

                for(int iRecip = 0; iRecip < m_request.cRecipients; iRecip++) {
                    if(0 == m_request.rgRecipients[iRecip].dwMessageID) {
                        string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Can't revoke by ID when ID is zero {2}",
                                                   SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, iRecip);
                        throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_RECIPIENT_ID_ZERO, err); 
                    }
                }
            }

            // SenderID of 0 not allowed if revoking by sender
            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER) && 0 == m_request.qwSenderID) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Bad sender id (0)",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_SENDER_ID_ZERO, err); 
            }

            // Can't have a zero context if revoking by context
            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT) && 0 == m_request.qwSenderContext) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Bad sender context (0)",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_BAD_SENDER_CONTEXT, err); 
            }

            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP)) {
                // USE_PROP implies USE_TYPE
                if(0 == (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE)) {
                    string err = string.Format("RevokeMessage: Call from client @ {0}:{1} USE_PROP implies USE_TYPE",
                                               SGInfo.Current.ClientIP, SGInfo.Current.ClientPort );
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_MISSING_USE_TYPE, err); 
                }

                // We don't support revoking persistent messages by prop at this time
                if(MsgDefs.XONLINE_MSG_TYPE_GAME_INVITE != m_request.bMessageType) {
                    string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Can't revoke persistent message by prop, type (0x{2:X2})",
                                               SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.bMessageType);
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_CANT_REVOKE_PERSISTENT_BY_PROP, err); 
                }

                // Can't have no prop if revoking by prop
                // NOTE: It is okay if cbProp is zero because we may have a NULL prop type which has no data
                if(0 == m_request.wPropTag) {
                    string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Bad prop tag (0)",
                                               SGInfo.Current.ClientIP, SGInfo.Current.ClientPort);
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_BAD_PROP_TAG, err); 
                }
            }

            // Can't have a zero type if revoking by type
            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE) && 0 == m_request.bMessageType) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Bad message type (0)",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_BAD_MESSAGE_TYPE, err); 
            }

            // One of USE_TYPE or USE_ID must be specified, otherwise we can't know whether the message
            // is persistent or transient.
            if(0 == (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID) &&
               0 == (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE)) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} One of USE_TYPE or USE_ID must be set (0x{2:X8})",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.dwFlags);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_USE_TYPE_OR_USE_ID_MUST_BE_SET, err); 
            }

            if(0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED)) {
                string err = string.Format("RevokeMessage: Call from client @ {0}:{1} Using reserved flags (0x{2:X8})",
                                           SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, m_request.dwFlags);
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_REVOKEMESSAGE_USING_RESERVED_FLAGS, err); 
            }

            //Calculate the size of the recipient array, note that we trust the minimum of what the user
            //gives us and what was deserialized, not necessary and they SHOULD be equal.
            //We will use the length calculated here for all the following code
            ulong[] recipients = new ulong[m_request.rgRecipients.Length];
            for(int i = 0; i< recipients.Length; i++ )
            {
                recipients[i] = m_request.rgRecipients[i].qwUserID;
            }
            
            string[] recipientGamertags = XCache.LookupGamerTags(recipients);
            HResult[] userResult = new HResult[recipients.Length];
            if ((0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE) && MsgDefs.IsNotifyMsgType(m_request.bMessageType)) ||
                (0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID) && MsgDefs.IsMsgTransient(m_request.rgRecipients[0].dwMessageID)))
            {
                //We use this instance for Matching below in RevokeMessage
                MessagingUtil.MatchRule rl = new MessagingUtil.MatchRule(this.MessageMatch);
                for (int i = 0; i < recipients.Length; i++ )
                {
                    if (recipientGamertags[i] == XCache.InvalidGamertag)
                    {
                        userResult[i] = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                        continue;
                    }
                    //Then Let's first delete by Id if asked for...
                    try
                    {
                        if (0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID))
                        {
                            if (0 != (m_request.rgRecipients[i].dwMessageID & MsgDefs.XONLINE_MSG_ID_SEND_FAILED))
                            {
                                userResult[i] = HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
                                continue;
                            }
                            MessagingUtil.DeleteTransientMessage(m_request.rgRecipients[i].qwUserID, m_request.rgRecipients[i].dwMessageID);
                        }
                        else 
                        {
                            TransientMessage[] msg = MessagingUtil.RevokeTransientMessage(m_request.rgRecipients[i].qwUserID, rl);
                            if (msg == null || msg.Length == 0)
                            {
                                //We have not found at least one match in the recipient array
                                //Raise a user specific error code here :XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE
                                userResult[i] = HResult.XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE;
                            }
                            else if (null != msg[0])
                            {
                                m_request.rgRecipients[i].dwMessageID = msg[0].Summary.dwMessageID;
                            }
                            else
                            {
                                userResult[i] = HResult.XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE;
                            }
                        }
                    }
                    catch (Exception e)
                    { 
                        ExceptionWithHResult hre = e as ExceptionWithHResult;
                        userResult[i] = (hre != null) ? hre.HResult : (HResult)(HResult.E_FAIL);
                    }
                }
            }
            else
            {
                //These are all persistent messages, we send if off onto SQL
                for (int i = 0; i < recipients.Length; i++)
                {
                    try
                    {
                        userResult[i] = SProcRevokeMessage(m_request.rgRecipients[i]);
                        if (userResult[i].IsSuccess())
                        {
                            m_request.rgRecipients[i].dwMessageID = userResult[i];
                        }
                    }
                    catch (Exception e)
                    {
                        ExceptionWithHResult hre = e as ExceptionWithHResult;
                        userResult[i] = (hre != null) ? hre.HResult : (HResult)(HResult.E_FAIL);
                    }
                }
            }
            //Block anyone who needs blocking...
            if (0 != (m_request.dwFlags & MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER) && 0 != m_request.qwSenderID)
            {
                //Only block for the first, since only one user can be blocked at a time in revoke.
                //Blocking is best effort, so we wrap with a try catch.
                try
                {
                    PresenceUtil.AddUsersToNeverList(m_request.rgRecipients[0].qwUserID, new ulong[] { m_request.qwSenderID });
                }
                catch (Exception)
                {
                    // best effort.
                }
            }
            //Send notifications for all successful revokes.
            for (int i=0; i < recipients.Length; i++)
            {
                //dwMessageId is appropriately set above with the message id used.
                if (userResult[i].IsSuccess() && 0 != m_request.rgRecipients[i].dwMessageID)
                {
                    try
                    {
                        MessagingUtil.SendDeleteMessageNotification(recipients[i], m_request.rgRecipients[i].dwMessageID);
                    }
                    catch (Exception)
                    {
                        // best effort.
                    }
                }
            }

            m_response.hr = HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "RVK|{0:X}:{1:X}|{2}|{3}|{4:X}|{5:X}|{6:X}|{7:X}|{8:X}|{9}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)m_request.qwSenderID,
                    (Puid)m_request.qwSenderContext, m_request.cRecipients, m_request.dwFlags,
                    m_request.wPropTag, m_request.cbProp, m_request.bMessageType, m_response.hr);
        }


        // -------------------------------------------------------------------------------
        // ConvertRevokeToRevokeEx - converts a Revoke message to a RevokeEx type
        // -------------------------------------------------------------------------------
        private void ReadRevokeAsRevokeEx(HttpContext httpCtx)
        {
            // Read message as a Revoke message
            RevokeMessageMsg origmsg = new RevokeMessageMsg();
            origmsg.ReadFromRequest(httpCtx.Request);

            // Set the BASE_MSG_HEADER fields
            m_request.header.dwSeqNum = origmsg.header.dwSeqNum;
            m_request.header.sgaddr   = origmsg.header.sgaddr;

            // Fill in common properties
            m_request.qwSenderID   = origmsg.qwSenderID;
            m_request.cRecipients  = origmsg.cRecipients;
            m_request.rgRecipients = new RecipientResult[origmsg.cRecipients];
            for(int iUser = 0; iUser < origmsg.cRecipients; iUser++) {
                m_request.rgRecipients[iUser]             = new RecipientResult();
                m_request.rgRecipients[iUser].qwUserID    = origmsg.rgRecipients[iUser].qwUserID;
                m_request.rgRecipients[iUser].dwMessageID = origmsg.rgRecipients[iUser].dwMessageID;
            }

            // Fill in properties that only exist on the new type
            m_request.qwSenderContext = 0; // Even though this is on the old type, it is always zero
            m_request.bMessageType    = 0; // Even though this is on the old type, it is always zero
            m_request.dwFlags         = MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID;
            m_request.wPropTag        = 0;
            m_request.cbProp          = 0;
        }

        private HResult SProcRevokeMessage(RecipientResult result)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Call the sproc
                ws.StoredProc = "dbo.p_xmsg_user_message_revoke";
                ws.Partition = ws.CalcPartition(result.qwUserID);
                ws.AddParameter("@bi_sender_puid", m_request.qwSenderID);
                ws.AddParameter("@bi_recipient_puid", result.qwUserID);
                ws.AddParameter("@bi_sender_context", m_request.qwSenderContext);
                ws.AddParameter("@i_message_id", result.dwMessageID);
                ws.AddParameter("@i_message_flags", m_request.dwFlags);
                ws.AddParameter("@si_message_type", m_request.bMessageType);
                ws.AddParameter(ParamType.OUTPUT, "@i_ret_message_id", (uint)0);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.ExecuteNonQuery();

                // Check the results
                HResult ret = (uint)ws.GetIntParameter("@RETVAL");
                if (ret.IsFailure())
                {
                    Xom.NtEvent(XEvent.Id.MESSAGING_REVOKEMESSAGE_INVALID_MESSAGE_ID, "StoreRevokeMessage failed hr={0}, user={1}", ret, (Puid)result.qwUserID);
                }
                else if (ret == HResult.S_FALSE)
                {
                    string err = string.Format("RevokeMessage: p_xmsg_user_message_revoke found no message to revoke, returning XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, user={0}", (Puid)result.qwUserID);
                    Xom.Trace(XomAreaName.messagingfdLog, LogLevel.L_WARNING, err);

                    ret = HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
                    // Revoke succeeded
                }
                else
                {
                    //Return the message id;
                    ret = (uint)ws.GetIntParameter("@i_ret_message_id");
                }
                return ret;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\SendMessage.cs ===
// Author: mayankd
//
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Net;

using xonline.common.config;
using xonline.common.community;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using System.Collections.Generic;
using Microsoft.Webstore.WstClient;
using Microsoft.Xbox.Privacy.Interfaces;
using Microsoft.Xbox.Privacy.Client;

namespace xonline.server.messaging.fd
{

	internal class SendMessageHandler : MessagingHandlerBase
	{
        private readonly SendMessageMsg _request;
        private readonly SendMessageReply _response;
        private readonly List<RecipientResult> _results;
        //This second level cache is null for userid 0
        //private PrivilegeCache _cache;

        //These can be NULL and if so we check...
        private string _senderGamertag;
        private string[] _userGamertags;

        //These will NOT be null except for a live message
        private NeverList _sendingNeverList;
        private NeverList[] _receiverNeverList;
        private UserPrivileges _sendingPrivileges;
        private FriendsList _friends;

        #region BoilerPlateCode(Similar to Other Handlers)
        
        public SendMessageHandler(BaseHeader header)
            : base(header)
        {
            _request = new SendMessageMsg();
            _response = new SendMessageReply();
            _results = new List<RecipientResult>();

            //Set the default to success...
            _response.hr = HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            _response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < _response.cRecipients; i++)
            {
                builder.AppendFormat("{0:X};", _response.recipients[i].qwUserID);
            }
            //Remove last semi colon
            if (builder.Length > 0)
                builder.Remove(builder.Length - 1,1);

            Xom.Log(XomAreaName.messagingfdLog, "SND|{0:X}:{1:X}|{2:X}|{3:X}|{4:X}|{5:X}|{6:X}|{7:X}|{8:X}|{9}|{10:X}",
                    (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(SGInfo.Current.ClientIP.GetAddressBytes(), 0)), 
                    (ushort)IPAddress.NetworkToHostOrder((short)SGInfo.Current.ClientPort), _request.qwSenderID,
                    _request.qwSenderContext, _request.dwSenderTitleID, _request.dwMessageFlags,
                    _request.wExpireMinutes, _request.cbDetails, _request.bMessageType, builder.ToString(), (uint)_response.hr);
            Xom.Log(XomAreaName.Reporting, "SND|{0:X}:{1:X}|{2:X}|{3:X}|{4:X}|{5:X}|{6:X}|{7:X}|{8:X}|{9}|{10:X}",
                    (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(SGInfo.Current.ClientIP.GetAddressBytes(), 0)), 
                    (ushort)IPAddress.NetworkToHostOrder((short)SGInfo.Current.ClientPort), _request.qwSenderID,
                    _request.qwSenderContext, _request.dwSenderTitleID, _request.dwMessageFlags,
                    _request.wExpireMinutes, _request.cbDetails, _request.bMessageType, builder.ToString(), (uint)_response.hr);
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            _response.cRecipients = (ushort)_results.Count;
            _response.recipients = _results.ToArray();

            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;

            return (_response);
        }

        #endregion

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            //Check the extended size of the message, we need to make sure
            //that the message is deserialized properly. This is taken care of by the 
            //protocol deserialization in ...
            _request.ReadFromRequest(HttpContext.Current.Request);

            //Run through the validation grid
            SendMessageValidation.ValidateWithException(_request);

            //Actually send the message
            SendMessage();
                    
        }

        /// <summary>
        /// </summary>
        /// <param name="message"></param>
        private void SendMessage()
        {
            ulong[] recipients = (ulong[])_request.qwRecipientIDs.Clone();

            //LIVE messages come in with 0 PUID
            //_cache is NULL for those since user is 0
            #region Extra checks for user to user messages

            if (0 != _request.qwSenderID)
            {
                _senderGamertag = XCache.LookupGamerTag(_request.qwSenderID);
                if (_senderGamertag == XCache.InvalidGamertag)
                {
                    HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                    throw new XRLException(hr, 
                        XEvent.Id.MESSAGING_SENDMESSAGE_INVALID_USERID, 
                        "SendMessage (sender: {0}, type {1:X}) failed hr={2}",
                        (Puid)_request.qwSenderID, _request.bMessageType, hr);
                }

                //Overwrite the sender name
                _request.szSenderName = _senderGamertag;

                if (!MsgDefs.IsNotifyMsgType(_request.bMessageType) && !PresenceUtil.IsXOnWatchIP(SGInfo.Current.ClientIP))
                {
                    if (MessagingUtil.ApplyThrottling(_request.qwSenderID, _request.cRecipients))
                    {
                        throw new XRLException(HResult.XONLINE_E_MESSAGE_THROTTLED, XEvent.Id.MESSAGING_DO_NOT_LOG_EVENT,"");
                    }
                }

                //Prep our cached items for the first round
                _sendingNeverList = PresenceUtil.GetNeverList(_request.qwSenderID);
                _sendingPrivileges = PresenceUtil.GetUserPrivileges(_request.qwSenderID);
                _userGamertags = XCache.LookupGamerTags(recipients);
                _receiverNeverList = PresenceUtil.GetNeverList(recipients);
                _friends = FriendsListUtil.GetFriendsListForXuid(_request.qwSenderID);

                //This call will change the recipients array, to list of privileged users
                recipients = GetPrivilegedUsersList(recipients);
            }

            #endregion


            foreach (ulong recipient in recipients)
            {
                HResult hr = new HResult();

                try
                {
                    if (!MsgDefs.IsNotifyMsgType(_request.bMessageType))
                    {
                        hr = SProcUserMessageSend(recipient);
                    }
                    else
                    {
                        //Remember that the cache does not exist for userid 0
                        hr = TransientUserMessageSend(recipient);
                    }
                }
                catch (Exception /*ex*/)
                {
                    //Message is undeliverable.
                    hr = HResult.XONLINE_E_MESSAGE_UNDELIVERABLE;
                }

                //CHECK: If the DB returns an error then we don't call the notification?
                if (!(hr.IsFailure()))
                {
                    //On success hr is NOT an hresult but contains a message id
                    try
                    {
                        MessagingUtil.SendAddMessageNotification(recipient, _request, (uint)hr);
                    }
                    catch (Exception)
                    {
                        // best effort.
                    }
                }

                //We have succeeded or potentially failed so need to set the response
                _results.Add(GetResult(recipient, hr));
            }
            //We add the results array over in the GetResponse
        }

        /// <summary>
        /// The method that applies privacy settings and also unblocks users
        /// if needed.
        /// This is ONLY called if the sender is NOT Live
        /// This method is called if all the objects are properly created
        /// </summary>
        /// <param name="record"></param>
        /// <param name="recipients"></param>
        /// <param name="results"></param>
        /// <returns></returns>
        private ulong[] GetPrivilegedUsersList(ulong[] recipients)
        {
            List<ulong> authorizedRecipients = new List<ulong>();
            List<ulong> unlistRecipients = new List<ulong>();

            bool fSenderCommEveryone = _sendingPrivileges.HasPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS);
            bool fSenderCommFriends = _sendingPrivileges.HasPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);

            uint cAuthorizedRecipients = 0;
            for (int i = 0; i < recipients.Length; i++)
            {
                if (_userGamertags[i] == XCache.InvalidGamertag)
                {
                    _results.Add(GetResult(recipients[i], Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER)));
                    recipients[i] = 0;
                    continue;
                }

                // Check to see if the sender is permitted to send messages (Always permitted to send friend requests)
                if ((_request.bMessageType != MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST) &&
                    !PresenceUtil.IsSharingAllowed(_friends, recipients[i], fSenderCommEveryone, fSenderCommFriends))
                {
                    _results.Add(GetResult(recipients[i], HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES));
                    recipients[i] = 0;
                    continue;
                }
                //Check never list, this should never be null actually...
                if (null != _sendingNeverList)
                {
                    if (_sendingNeverList.ContainsUser(recipients[i]))
                    {
                        unlistRecipients.Add(recipients[i]);
                    }
                }

                cAuthorizedRecipients++;
            }

            if (cAuthorizedRecipients == 0)
            {
                throw new XRLException(HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES, XEvent.Id.MESSAGING_DO_NOT_LOG_EVENT,"");
            }

            // Now check to see if the recipient wants to recieve the message.

            // First, make privacy checks for all valid users
            PrivacyCheckRequest[] checksToMake = new PrivacyCheckRequest[recipients.Length];

            for (int i = 0; i < recipients.Length; i++)
            {
                if (recipients[i] != 0)
                {
                    checksToMake[i] = new PrivacyCheckRequest { TargetSetting = (ushort) PrivacySetting.MessagingandVoice, TargetXuid = recipients[i], ViewerXuid=_request.qwSenderID };
                }
            }

            var vInfo = Config.GetVirtualInterface("privacy_int");

            bool[] privacyResults = new PrivacyClientInternal(new IPEndPoint(vInfo.IPAddress, vInfo.Port)).CheckPrivacy(checksToMake);

            // Now analyze the privacy check results
            for (int i = 0; i < recipients.Length; i++)
            {
                if (recipients[i] == 0)
                {
                    continue;
                }

                if (!privacyResults[i])
                {
                    _results.Add(GetResult(recipients[i], HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES));
                    continue;
                }

                if (null != _receiverNeverList[i])
                {
                    //We will not authenticate this user to be sent to
                    //but we may still need to unblock if the above is true
                    if (_receiverNeverList[i].ContainsUser(_request.qwSenderID))
                    {
                        _results.Add(GetResult(recipients[i], HResult.XONLINE_E_MESSAGE_SENDER_BLOCKED));
                        continue;
                    }
                }

                //These are the ones that we will actually send to...
                authorizedRecipients.Add(recipients[i]);
            }

            //Unblock the users...
            PresenceUtil.RemoveUsersFromNeverList(_request.qwSenderID, unlistRecipients.ToArray());

            return authorizedRecipients.ToArray();
        }

        /// <summary>
        /// Gets a recipient result, also sets the uber hresult as appropriate
        /// </summary>
        /// <param name="recipient"></param>
        /// <param name="errorOrMessage"></param>
        /// <returns></returns>
        private RecipientResult GetResult(ulong recipient, HResult errorOrMessage)
        {
            RecipientResult result = new RecipientResult();
            //Mark the message as undeliverable
            result.dwMessageID = errorOrMessage;
            result.qwUserID = recipient;
            if (errorOrMessage.IsFailure())
                _response.hr = HResult.S_FALSE;
            return result;
        }

        private HResult TransientUserMessageSend(ulong user)
        {
            HResult hr = HResult.E_FAIL;
            bool fIsFriend = _friends.IsAcceptedBuddy(user);
            TransientMessage xmsg = new TransientMessage();
            xmsg.Summary.qwSenderID = _request.qwSenderID;
            xmsg.Summary.qwSenderContext = _request.qwSenderContext;
            xmsg.Summary.dwSenderTitleID = _request.dwSenderTitleID;
            xmsg.Summary.dwMessageFlags = _request.dwMessageFlags;
            xmsg.Summary.dwMessageFlags |= (fIsFriend) ? MsgDefs.XONLINE_MSG_FLAG_SENDER_IS_FRIEND : 0;
            xmsg.Summary.wExpireMinutes = _request.wExpireMinutes;
            xmsg.Summary.bMessageType = _request.bMessageType;
            xmsg.Summary.szSenderName = _request.szSenderName;
            xmsg.Summary.cbDetails = _request.cbDetails;
            xmsg.Summary.mtSentTime = MsgDefs.DateTimeToMsgTime(DateTime.UtcNow);
            xmsg.Details = _request.details;
            uint dwNewMsgID = MessagingUtil.AddTransientMessage(user, xmsg);
            // After the transient message has been sent, Add an item to PQUEUE_INVITE only for friend recipients
            if (fIsFriend)
            {
                // Back-compat on CXLiveFriendsLegacy: XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE is set on each 
                // friend record when PQUEUE_INVITE items are received.
                PresenceRecord recipient = PresenceUtil.GetPresenceRecord(user);
                if (recipient != null && recipient.IsOnline())
                {
                    recipient.QueueInviteQVals(_request.qwSenderID, xmsg.MatchSessionID, _request.dwSenderTitleID);
                }
            }
            return (HResult)dwNewMsgID;
        }

        /// <summary>
        /// Stored proc call
        /// </summary>
        /// <param name="user"></param>
        /// <returns></returns>
        private uint SProcUserMessageSend(ulong user)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Call the sproc
                ws.StoredProc = "dbo.p_xmsg_user_message_send";
                ws.Partition = ws.CalcPartition(user);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_puid_from", _request.qwSenderID);
                ws.AddParameter("@bi_puid_to", user);
                ws.AddParameter("@i_title_id_from", _request.dwSenderTitleID);
                ws.AddParameter("@bi_sender_context", _request.qwSenderContext);
                ws.AddParameter("@si_message_type", _request.bMessageType);
                ws.AddParameter("@i_message_flags", _request.dwMessageFlags);
                ws.AddParameter("@vc_sender_name", _request.szSenderName);
                ws.AddParameter("@si_expire_minutes", _request.wExpireMinutes);
                ws.AddParameter("@si_properties_size", _request.cbDetails);
                ws.AddParameter("@vc_subject", "");
                ws.AddParameter("@vb_properties", (byte[])null);
                ws.AddParameter(ParamType.OUTPUT, "@i_message_id", 0);

                if (null != _request.details && 0 != _request.cbDetails)
                {
                    ws.Parameters["@vb_properties"].Value = _request.details.ToArray();
                    ws.Parameters["@vb_properties"].Size = ((byte[])ws.Parameters["@vb_properties"].Value).Length;

                    if (_request.details.wPropCount > 0)
                    {
                        byte[] buffer = MessagingUtil.GetMessageProperty(MsgDefs.XONLINE_MSG_PROP_TEXT, _request.details);
                        if (null != buffer)
                        {
                            MemoryStream propStream = new MemoryStream(buffer);
                            MessageStringProperty strProperty = new MessageStringProperty();
                            propStream.Seek(0, SeekOrigin.Begin);
                            strProperty.ReadStream(propStream);
                            ws.Parameters["@vc_subject"].Value = strProperty.szString;
                            ws.Parameters["@vc_subject"].Size = strProperty.szString.Length;
                        }
                    }
                }

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (hr.IsSuccess())
                {
                    return (uint)ws.GetIntParameter("@i_message_id");
                }
                return (uint)hr;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\test\stf\FuncDeleteSystemMsg.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace MessagingTest
{
    ////////////////////////////////////////////////////////////////////////////////////
    /// <summary>
    /// Functional Tests for DeleteSystemMessage
    /// </summary>
    /// Positive cases check for success hr. Because this message is used to validate the
    ///   exhaustive set of Send cases this list is short.  Summary contents will be checked
    ///   against expected.
    /// Negative Cases check for failure hr that makes sense and is consistent.
    [TestGroup]
    public class FuncDeleteSystemMsg : TestNode
    {
        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description( "Delete a system message" )]
        public void Normal()
        {
            SystemMsgFolder folder = new SystemMsgFolder( MsgTestUtils.DefaultSystemTitleID );
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test( "Count", startingCount+1, folder.Count );

            msgSent.Delete( SystemMessage.RevokeAlso.No );

            folder.Load();
            ValueCheck.Test( "Count", startingCount, folder.Count );
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete a system message for each region")]
        public void AllRegions()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            for (uint region = 1; region < 13; ++region)
            {
                SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                    Message.Priority.Normal,
                    "MessagingTest",
                    MsgTestUtils.DefaultSystemTitleID,
                    region,
                    Name,
                    1,
                    0,
                    5
                    );
                msgSent.Send();

                folder.Load();
                ValueCheck.Test("Count", startingCount + 1, folder.Count);

                msgSent.Delete(SystemMessage.RevokeAlso.No);

                folder.Load();
                ValueCheck.Test("Count", startingCount, folder.Count);
            }
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete a recommended system message")]
        public void RecommendedMessage()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Recomended,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete a required system message")]
        public void RequiredMessage()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Required,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete a system message that will send in the future")]
        public void SendInFuture()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                60,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description( "Delete a system message and also revoke it" )]
        public void RevokeAlso()
        {

            // Create a new unique user, not logged in yet
            PNUser user = MsgTestUtils.CreateCleanUser();
            MsgTestUtils.Fc.LogoffUser(user);
            //Todo:shailesh fix this.
            //PNServers.SetCacheState(user, CacheState.NotInMemory);

            // Set up system message folder with initial contents for this title
            SystemMsgFolder sysFolder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            sysFolder.Load();
            ushort startingCount = sysFolder.Count;

            // When run on the server, the user's last read time above can be a fraction of a
            // second ahead of the sent message time below
            Thread.Sleep(2000);

            // Create and send a new system message
            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            // Reload system message folder to make sure new message is there
            sysFolder.Load();
            ValueCheck.Test( "SystemMsgFolder.Count", startingCount+1, sysFolder.Count );

            // Logon the user to cause system messgaes to be delivered
            MsgTestUtils.Fc.LogonUser(user, MsgTestUtils.DefaultSystemTitleID);

            // Check user message folder it should contain all the system message to it's title
            UserMsgFolder userFolder = new UserMsgFolder(user);
            userFolder.Load2();
            ValueCheck.Test( "UserMsgFolder.Count", sysFolder.Count, userFolder.Count );

            // Delete the system message from user and system queues
            msgSent.Delete( SystemMessage.RevokeAlso.Yes );

            // Make sure message was deleted from system
            sysFolder.Load();
            ValueCheck.Test( "SystemMsgFolder.Count", startingCount, sysFolder.Count );

            // Make sure message was deleted from user
            userFolder.Load2();
            ValueCheck.Test( "UserMsgFolder.Count", startingCount, userFolder.Count );
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete and revoke a system message that will send in the future")]
        public void RevokeInFuture()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                60,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.Yes);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Sends two messages, deletes the first one")]
        public void DeleteOlder()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgFirst = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name + "1",
                1,
                0,
                5
                );
            msgFirst.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            SystemMessage msgSecond = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name + "2",
                1,
                0,
                5
                );
            uint msgId = msgSecond.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 2, folder.Count);

            msgFirst.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            // Ensure the second message still exists
            ValueCheck.TestNotNull("Second System Message", folder[msgId]);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description( "Title ID zero" )]
        public void TitleId_Zero()
        {

            SystemMsgFolder folder = new SystemMsgFolder(0);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                0,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description( "Title ID Dash " )]
        public void TitleId_XenonDash()
        {

            SystemMsgFolder folder = new SystemMsgFolder(XOn.XENON_DASH_TITLE_ID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                XOn.XENON_DASH_TITLE_ID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description( "DataCenter Port (no SPI Data)" )]
        public void NoSpiData_DCPort()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            uint msgId = msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            SystemMessage.Delete(MsgTestUtils.DefaultSystemTitleID, msgId, SystemMessage.RevokeAlso.No, true);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete message ID 0")]
        public void MessageIdZero()
        {

            try
            {
                SystemMessage.Delete(MsgTestUtils.DefaultSystemTitleID, 0, SystemMessage.RevokeAlso.No);
            }
            catch (HResultException ex)
            {
                ValueCheck.TestHR("Delete HR", HResult.E_INVALIDARG, ex.HR);
            }
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Delete a system message twice")]
        public void DeleteTwice()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);

            msgSent.Delete(SystemMessage.RevokeAlso.No);

            folder.Load();
            ValueCheck.Test("Count", startingCount, folder.Count);

            try
            {
                msgSent.Delete(SystemMessage.RevokeAlso.No);
            }
            catch (HResultException ex)
            {
                ValueCheck.TestHR("Second Delete HR", HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, ex.HR);
            }
        }

        // The following test cases were based on the following PICT model:
        //
        //        TitleID: Zero, Default, Dash
        //          MsgId: Zero, Invalid, Valid
        //       Priority: Normal, Recommended, Required
        //         Revoke: Yes, No
        //      SendDelay: 0, 60
        //
        [TestCase, Description("PICT Parameter Test")]
        [CompoundCase("TitleZeroMsgInvalidNormalRevokeNoFutureNo", (uint)0, "Invalid", Message.Priority.Normal, SystemMessage.RevokeAlso.No, 0)]
        [CompoundCase("TitleZeroMsgZeroRequiredRevokeYesFutureYes", (uint)0, "Zero", Message.Priority.Required, SystemMessage.RevokeAlso.Yes, 60)]
        [CompoundCase("TitleDashMsgZeroRecommendedRevokeNoFutureNo", XOn.XENON_DASH_TITLE_ID, "Zero", Message.Priority.Recomended, SystemMessage.RevokeAlso.No, 0)]
        [CompoundCase("TitleDefaultMsgZeroNormalRevokeYesFutureYes", MsgTestUtils.DefaultSystemTitleID, "Zero", Message.Priority.Normal, SystemMessage.RevokeAlso.Yes, 60)]
        [CompoundCase("TitleDashMsgInvalidRecommendedRevokeYesFutureYes", XOn.XENON_DASH_TITLE_ID, "Invalid", Message.Priority.Recomended, SystemMessage.RevokeAlso.Yes, 60)]
        [CompoundCase("TitleZeroMsgValidRecommendedRevokeYesFutureNo", (uint)0, "Valid", Message.Priority.Recomended, SystemMessage.RevokeAlso.Yes, 0)]
        [CompoundCase("TitleDefaultMsgValidRecommendedRevokeNoFutureNo", MsgTestUtils.DefaultSystemTitleID, "Valid", Message.Priority.Recomended, SystemMessage.RevokeAlso.No, 0)]
        [CompoundCase("TitleDefaultMsgInvalidRequiredRevokeNoFutureNo", MsgTestUtils.DefaultSystemTitleID, "Invalid", Message.Priority.Required, SystemMessage.RevokeAlso.No, 0)]
        [CompoundCase("TitleDashMsgValidNormalRevokeNoFutureYes", XOn.XENON_DASH_TITLE_ID, "Valid", Message.Priority.Normal, SystemMessage.RevokeAlso.No, 60)]
        [CompoundCase("TitleDashMsgValidRequiredRevokeNoFutureNo", XOn.XENON_DASH_TITLE_ID, "Valid", Message.Priority.Required, SystemMessage.RevokeAlso.No, 0)]
        public void PictParameterTest(TestNode self)
        {
            // Data values
            uint titleId = (uint)self.MyValues[0];
            string msgIdType = (string)self.MyValues[1];
            Message.Priority priority = (Message.Priority)self.MyValues[2];
            SystemMessage.RevokeAlso revoke = (SystemMessage.RevokeAlso)self.MyValues[3];
            int delayTime = (int)self.MyValues[4];

            // Test variables
            SystemMessage sysMsg = null;
            uint msgId = 0;
            SystemMsgFolder sysFolder = new SystemMsgFolder(titleId);
            sysFolder.Load();
            ushort startingCount = sysFolder.Count;

            // Determine the actual message ID to use
            switch (msgIdType)
            {
                case "Valid":
                    sysMsg = SystemMessage.CreateLiveMsg(priority, "MessagingTest", titleId, 1, Name, 1, (ushort)delayTime, 5);
                    msgId = sysMsg.Send();
                    sysFolder.Load();
                    ValueCheck.Test("Count After Send", startingCount + 1, sysFolder.Count);
                    break;
                case "Invalid":
                    msgId = 500;
                    break;
                case "Zero":
                    msgId = 0;
                    break;
                default:
                    throw new UnexpectedTestResultException(
                        String.Format("Unknown msg ID type \"{0}\"", msgIdType));
            }

            // Perform the delete
            try
            {
                SystemMessage.Delete(titleId, msgId, revoke);
                sysFolder.Load();
                ValueCheck.Test("Count After Delete", startingCount, sysFolder.Count);
            }
            catch (HResultException hrEx)
            {
                uint expectedHr = HResult.S_OK;  // should never be true

                if (msgIdType == "Invalid")
                    expectedHr = HResult.XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
                else if (msgIdType == "Zero")
                    expectedHr = HResult.E_INVALIDARG;

                ValueCheck.TestHR("Delete HR", expectedHr, hrEx.HR);
            }
        }

        ////////////////////////////////////////////////////////////////////////////////////
        [TestCase, Description("Set invalid flags")]
        public void SetInvalidFlags()
        {

            SystemMsgFolder folder = new SystemMsgFolder(MsgTestUtils.DefaultSystemTitleID);
            folder.Load();
            ushort startingCount = folder.Count;

            SystemMessage msgSent = SystemMessage.CreateLiveMsg(
                Message.Priority.Normal,
                "MessagingTest",
                MsgTestUtils.DefaultSystemTitleID,
                PNXbox.DefTitleRegion,
                Name,
                1,
                0,
                5
                );
            uint msgId = msgSent.Send();

            folder.Load();
            ValueCheck.Test("Count", startingCount + 1, folder.Count);
            ValueCheck.TestNotNull("Message Exists", folder[msgId]);

            // Delete the message with invalid flags
            for (int i = 0; i < 32; ++i)
            {
                uint flag = (uint)(1 << i);

                if (flag == XonPresNoti.DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL)
                    continue;

                Global.RO.Info("Setting invalid flag {0:X08}", flag);

                QMsgDeleteSystemMsg delMsg = new QMsgDeleteSystemMsg(MsgTestUtils.DefaultSystemTitleID, msgId, false);
                ((QDeleteSystemMsgMsgData)(delMsg.Msg.Data)).Flags = flag;
                PNMsg reply;

                delMsg.TransactFD(out reply);

                QDeleteSystemMsgReplyMsgData replyData = (QDeleteSystemMsgReplyMsgData)(reply.Data);
                ValueCheck.TestHR("Reply HRESULT", HResult.E_INVALIDARG, replyData.HR);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\test\stf\FuncCheckTitleMessages.cs ===
using System;
using System.Threading;
using System.Collections;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace MessagingTest
{
    [TestGroup]
    [TestTag("Unreviewed")]
    class FuncCheckTitleMessages : MessagingTestGroup
    {
        uint _TitleId = 0x11223300;

        [TestGroupTearDown]
        public void TearDown()
        {
            SystemMsgFolder.DeleteAll(_TitleId, SystemMessage.RevokeAlso.Yes );
        }

        uint ClearAndSendNewTitleMessage(PNUser user, Message.Priority priority, string subject)
        {
            // Clear old messages
            SystemMsgFolder.DeleteAll(_TitleId, SystemMessage.RevokeAlso.Yes );

            // Build and send message
            SystemMessage msg =
                SystemMessage.CreateLiveMsg(
                priority,
                "FCTMTest",
                _TitleId,
                0,
                subject,
                1, // string Id
                0, // delay minutes
                10 // expire minutes
                );

            uint msgId = msg.Send();

            return msgId;
        }

        PNUser CreateUser()
        {
            PNUser u = MsgTestUtils.CreateCleanUser();
            MsgTestUtils.Fc.LogoffUser(u);
            u.Xbox.ChangeTitle(_TitleId, 0, 0);
            MsgTestUtils.Fc.LogonUser(u);

            return u;
        }

        [TestCase]
        public void P_Check_None()
        {
            PNUser u = CreateUser();
            uint hr = u.CheckTitleMessages();
            ValueCheck.TestHR("HResult none", HResult.S_OK, hr);
        }

        [TestCase]
        public void P_Check_Normal_System_Messages()
        {
            PNUser user = CreateUser();
            uint msgId = ClearAndSendNewTitleMessage(user, Message.Priority.Normal, "normal pri");
            uint hr = user.CheckTitleMessages();
            ValueCheck.TestHR("Hresult", HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED, hr);
        }
        [TestCase]
        public void P_Check_Recommended_System_Messages()
        {
            PNUser user = CreateUser();
            uint msgId = ClearAndSendNewTitleMessage(user, Message.Priority.Recomended, "recommended pri");
            uint hr = user.CheckTitleMessages();
            ValueCheck.TestHR("Hresult", HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE, hr);
        }
        [TestCase]
        public void P_Check_Required_System_Messages()
        {
            PNUser user = CreateUser();
            uint msgId = ClearAndSendNewTitleMessage(user, Message.Priority.Required, "required pri");
            uint hr = user.CheckTitleMessages();
            ValueCheck.TestHR("Hresult", HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT, hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\SendSystemMessage.cs ===
// Author: mayankd
//
using System;
using System.IO;
using System.Web;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.community;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.server.messaging.fd
{
    internal class SendSystemMessageHandler : MessagingHandlerBase
    {
        private readonly SendSystemMessageMsg _request;
        private readonly SendSystemMessageReply _response;
        private static uint _nextid = 0;
        private static uint _endid = 0;
        private static object _glob = new object();

        public SendSystemMessageHandler(BaseHeader header)
            : base(header)
        {
            _request = new SendSystemMessageMsg();
            _response = new SendSystemMessageReply();

            //Set the default to success...
            _response.hr = HResult.E_FAIL;
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            _response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.messagingfdLog, "SNS|{0:X}:{1:X}|{2}|{3}|{4:X}|{5:X16}|{6:X}|{7:X}|{8:X}|{9:X}|{10:X}|{11}",
                    SGInfo.Current.ClientIP, SGInfo.Current.ClientPort, (Puid)_request.qwSenderContext,
                    (TitleId)_request.dwTitleID, _request.dwRegion, _request.dtSentTime, _request.dwMessageFlags,
                    _request.wExpireMinutes, _request.cbDetails, _request.bMessageType, _response.dwMessageID, _response.hr);
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;

            return (_response);
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            //Check the extended size of the message, we need to make sure
            //that the message is deserialized properly. This is taken care of by the
            //protocol deserialization in ...
            _request.ReadFromRequest(HttpContext.Current.Request);

            //Run through the validation grid
            SendSystemMessageValidation.ValidateWithException(_request);

            //Actually send the message
            try
            {
                _response.dwMessageID = SProcSystemMessageSend();
            }
            catch (Exception e)
            {
                throw new XRLException(HResult.E_FAIL, XEvent.Id.MESSAGING_SENDSYSTEMMESSAGE_DATABASE_FAILURE, "Database exception occurred", e);
            }
            _response.hr = HResult.S_OK;
        }

        private uint SProcSystemMessageSend()
        {
            uint nextid = GetNextSystemMessageId();
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Call the sproc
                ws.StoredProc = "dbo.p_xmsg_system_message_send";
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@i_title_id_from", _request.dwTitleID);
                ws.AddParameter("@i_region", _request.dwRegion);
                ws.AddParameter("@bi_sender_context", _request.qwSenderContext);
                ws.AddParameter("@si_message_type", _request.bMessageType);
                ws.AddParameter("@i_message_flags", _request.dwMessageFlags);
                ws.AddParameter("@vc_sender_name", _request.szSenderName);
                ws.AddParameter("@dt_sent_time", _request.dtSentTime);
                ws.AddParameter("@si_expire_minutes", _request.wExpireMinutes);
                ws.AddParameter("@si_properties_size", _request.cbDetails);
                ws.AddParameter("@vb_properties", _request.details.ToArray());
                ws.AddParameter("@vc_description", _request.szDescription);
                ws.AddParameter("@i_message_id", nextid);

                foreach (int physicalParititon in WSClient.GetPhysicalPartitions(ConfigUtil.UodbWebstoreApp))
                {
                    ws.PhysicalPartition = physicalParititon;

                    //This method will retrieve the list of physical database connections available for the above physical partition
                    //and fire it on them, using cached connections if available.
                    ws.ExecuteNonQuery();

                    HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (hr.IsFailure())
                    {
                        throw new XRLException(HResult.E_FAIL, XEvent.Id.MESSAGING_SENDSYSTEMMESSAGE_SPROC_ERROR,
                            "p_xmsg_system_message_send returned failure hr={0}", hr);
                    }
                }
            }
            return nextid;
        }

        //TODO: This uses the same methodology as the INH and we should possibly think of a better way to do this for the FDs, they will recycle more often
        //than the INH.
        private uint GetNextSystemMessageId()
        {
            uint nextid = 0;
            lock (_glob)
            {
                if (_nextid == _endid)
                {
                    using(SqlConnection cxn = new SqlConnection(ConfigUtil.NpdbConnectionString))
                    {
                        cxn.Open();
                        using (SqlCommand cmd = new SqlCommand("p_xmsg_system_messages_get_ids", cxn))
                        {
                            using (SqlDataReader reader = cmd.ExecuteReader())
                            {
                                if (reader.HasRows && reader.Read())
                                {
                                    _nextid = (uint)reader.GetInt32(0);
                                    _endid = (uint)reader.GetInt32(1);
                                }
                                else
                                {
                                    throw new XRLException(HResult.E_FAIL, XEvent.Id.MESSAGING_SENDSYSTEMMESSAGE_SYSID_ERROR, "p_xmsg_system_messages_get_ids returned no rows");
                                }
                            }
                        }
                    }
                }
                nextid = _nextid | MsgDefs.XONLINE_MSG_ID_SYSTEM_MESSAGE;
                _nextid = (_nextid + 1) & MsgDefs.XONLINE_MSG_ID_BASE_MASK;
            }
            return nextid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\test\stf\FuncDeleteTitle.cs ===
using System;
using System.IO;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;

namespace MessagingTest
{
    /// <summary>
    /// Functional Tests for DeleteTitle
    /// </summary>
    /// Positive cases check for success hr.  QMSG_ENUM_TITLES used to verify changes.
    /// Negative Casescheck for failure hr that makes sense and is consistent.
    [TestGroup]
    public class FuncDeleteTitle : MessagingTestGroup
    {
        [TestCase]
        public void P_Mainline()
        {
            UserTitle[] titles;
            PNUser u = Globals.Fc.CreateXboxUser(true);

            titles = u.EnumerateTitles();
            ValidateContains(titles, u.Xbox.TitleId);

            u.DeleteTitle(u.Xbox.TitleId);
            titles = u.EnumerateTitles();

            ValueCheck.Test("EnumTitles.Length", 0, titles.Length);
        }

        [TestCase, Description( "Other Title" ), Ignore]
        public void P_OtherTitle()
        {
        }

        [TestCase, Description( "User Not Logged On" ), Ignore]
        public void P_User_NotAlive()
        {
        }

        [TestCase, Description( "User Doesn't Exist" ), Ignore]
        public void N_User_DoesNotExist()
        {
        }

        [TestCase, Description( "User PUID zero" ), Ignore]
        public void N_User_Zero()
        {
        }

        [TestCase, Description( "Title ID zero" ), Ignore]
        public void N_TitleId_Zero()
        {
        }

        [TestCase, Description( "Title ID invalid, not in user's list" ), Ignore]
        public void N_TitleId_Invalid()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\fd\SendMessageValidation.cs ===
// Author: mayankd
//
using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using System.Text;
using System.Text.RegularExpressions;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.community;

namespace xonline.server.messaging.fd
{
    /// <summary>
    /// IMPORTANT!: When adding values here, remember to add the trace message to the string array below
    /// </summary>
    public enum SendMessageValidationCodes
    {
        SENDMESSAGE_SUCCESS,

        SENDMESSAGE_ERROR_INVALID_MSG_TYPE,
        SENDMESSAGE_ERROR_INVALID_MSG,
        SENDMESSAGE_ERROR_NON_EXPORTABLE,
        SENDMESSAGE_ERROR_REQUIRED_RECOMMENDED,
        SENDMESSAGE_ERROR_TITLEID,
        SENDMESSAGE_ERROR_RECIPIENTS,
        SENDSYSTEMMESSAGE_ERROR_INVALID_DESC,
        SENDMESSAGE_ERROR_DETAILS, //placeholder for details errors below since we raise one exception for them

        SENDMESSAGE_ERROR_DETAILS_SIZE,
        SENDMESSAGE_ERROR_DETAILS_PROPERTIES_SIZE,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_ID,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_ID_REPEATED,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_TYPE,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_TYPE_UNKNOWN,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_VAL_BOOL,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_VAL_OFFSET,
        SENDMESSAGE_ERROR_DETAILS_PROPERTY_OFFSET_OVERFLOW
    }
    
    internal class MessageWrapper
    {
        public MessageWrapper(SendMessageMsg msg) { m1 = msg; m2 = null; }
        public MessageWrapper(SendSystemMessageMsg msg) { m1 = null;  m2 = msg; }

        public byte bMessageType
        {
            get
            {
                return (m1 == null ? m2.bMessageType : m1.bMessageType);
            }
        }
        public ushort cbDetails
        {
            get
            {
                return (m1 == null ? m2.cbDetails : m1.cbDetails);
            }
        }
        public MessageDetails details
        {
            get
            {
                return (m1 == null ? m2.details : m1.details);
            }
        }
        public ushort wExpireMinutes
        {
            get
            {
                return (m1 == null ? m2.wExpireMinutes : m1.wExpireMinutes);
            }
            set
            {
                if (m1 == null)
                {
                    m2.wExpireMinutes = value;
                }else
                {
                    m1.wExpireMinutes = value;
                }
            }
        }

        public uint dwMessageFlags
        {
            get
            {
                return (m1 == null ? m2.dwMessageFlags : m1.dwMessageFlags);
            }
        }

        public SendMessageMsg m1;
        public SendSystemMessageMsg m2;
    }

    internal class BaseValidation
    {
        private const ushort MESSAGE_MAX_PROPCOUNT = 255;
        private const ushort MESSAGE_ERRORSTRING_DEFAULT_SIZE = 128;

        /// <summary>
        /// The below strings have to match the array above, DO NOT MESS THIS UP!
        /// </summary>
        public static string[] validationCodeFormatStringMap = 
        {
            "", //The first one is a success
            //The next set are strings returned in exceptions
            "Send{4}Message from {0}:{1} Bad message type ({2}){3}",
            "Send{5}Message from {0}:{1} Bad message flags ({2:8X} not in {3:8X}){4}",
            "Send{4}Message from {0}:{1} Non-exportable flag only allowed on TITLE_CUSTOM messages, type={2}{3}",
            "Send{4}Message from {0}:{1} Required and recommended flags only allowed on LIVE_MESSAGE messages, type={2}{3}",
            "Send{3}Message from {0}:{1} invalid title ID (0){2}",
            "Send{5}Message from {0}:{1} Number of recipients is too small or too large (0 < {2} <= {3}){4}",
            "SendSystemMessage from {0}:{1} Message description is not NULL-terminated",
            "Send{3}Message from {0}:{1} Message details are invalid{2}",
            //Remember that the following are only trace messages, you would normally NOT throw an exception for these
            "Details validation failed - cbDetails is too small or too large ({0} <= {1} <= {2})",
            "Details validation failed - Message contains too many properties ({0} > 256)",
            "Details validation failed - Message contains invalid prop ID (0)",
            "Details validation failed - Message contains prop ID {0} more than once",
            "Details validation failed - Message contains invalid prop type (0)",
            "Property validation failed - PropTag[{0:4X}] unknown property type",
            "Property validation failed - PropTag[{0:4X}] contains non-boolean byte data ({1:4X})",
            "Property validation failed - PropTag[{0:4X}] offset begins before previous property ends ({1} <= {2})",
            "Property validation failed - PropTag[{0:4X}] offset overflows message ({1} > {2})"
        };

        /// <summary>
        /// Validates the message expiration and type
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        private static bool ValidateMessageType(MessageWrapper message)
        {
            if (MessagingUtil.IsValidMessageType(message.bMessageType))
            {
                if ((0 == message.wExpireMinutes) || (message.wExpireMinutes > MessagingUtil.GetMessageExpiration(message.bMessageType)))
                {
                    message.wExpireMinutes = MessagingUtil.GetMessageExpiration(message.bMessageType);
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// Base Validate for both System and Normal messages
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="message"></param>
        /// <returns></returns>
        public static SendMessageValidationCodes BaseValidate(MessageWrapper message)
        {
            if (!ValidateMessageType(message))
            {
                return SendMessageValidationCodes.SENDMESSAGE_ERROR_INVALID_MSG_TYPE;
            }
            if (0 != (message.dwMessageFlags & ~(MsgDefs.XONLINE_MSG_FLAGS_VALID_SEND_MASK)))
            {
                return SendMessageValidationCodes.SENDMESSAGE_ERROR_INVALID_MSG;
            }

            if (0 != (message.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_NON_EXPORTABLE)
                && (MsgDefs.XONLINE_MSG_TYPE_TITLE_CUSTOM != message.bMessageType))
            {
                return SendMessageValidationCodes.SENDMESSAGE_ERROR_NON_EXPORTABLE;
            }
            return SendMessageValidationCodes.SENDMESSAGE_SUCCESS;
        }

        public static SendMessageValidationCodes TraceErrorAndReturn(SendMessageValidationCodes eCode, params object[] args)
        {
            Xom.Trace(XomAreaName.messagingfdLog,
                LogLevel.L_ERROR,
                validationCodeFormatStringMap[(int)eCode],
                args);
            return eCode;
        }

        /// <summary>
        /// Validate the details part of the message, both for System and Normal messages
        /// </summary>
        /// <param name="details"></param>
        /// <param name="cbDetails"></param>
        /// <returns></returns>
        public static SendMessageValidationCodes ValidateDetails(MessageDetails details, uint cbDetails)
        {
            if (cbDetails > MsgDefs.XONLINE_MAX_MESSAGE_DETAILS)
            {
                return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_SIZE, 
                    0, cbDetails, MsgDefs.XONLINE_MAX_MESSAGE_DETAILS);
            }

            if (details.wPropCount > MESSAGE_MAX_PROPCOUNT)
            {
                return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTIES_SIZE, 
                    details.wPropCount);
            }

            ushort nextOffset = 0;

            BitArray propMask = new BitArray(256);

            foreach (MessageProperty prop in details.rgProperties)
            {
                ushort offsetbase = (ushort)(details.Size() - details.cbData);
                if (0 == MsgDefs.XOnlineMessageGetPropId(prop.wPropTag))
                {
                    return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_ID);
                }

                if (0 == MsgDefs.XOnlineMessageGetPropType(prop.wPropTag))
                {
                    return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_TYPE);
                }

                if (propMask[(int)MsgDefs.XOnlineMessageGetPropId(prop.wPropTag)] == false)
                {
                    propMask[(int)MsgDefs.XOnlineMessageGetPropId(prop.wPropTag)] = true;
                }
                else
                {
                    return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_ID_REPEATED, 
                        MsgDefs.XOnlineMessageGetPropId(prop.wPropTag));
                }

                //Check values that are not embedded in offset
                byte propType = MsgDefs.XOnlineMessageGetPropType(prop.wPropTag);
                //Only Bool needs special handling null,I1 and I2 are not needed
                if (propType != MsgDefs.XONLINE_MSG_PROP_TYPE_NULL &&
                    propType != MsgDefs.XONLINE_MSG_PROP_TYPE_I1 &&
                    propType != MsgDefs.XONLINE_MSG_PROP_TYPE_I2 &&
                    propType != MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL)
                {
                    //Check if offsets are reasonable, these are updated once additional validation
                    //succeeds below
                    if (prop.wPropOffset != nextOffset)
                    {
                        return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_VAL_OFFSET, 
                            propType, prop.wPropOffset, nextOffset);
                    }
                }

                try
                {
                    //In the following code I don't need to check for boundary condition overflow as the deserialization
                    //will take care of that
                    MemoryStream propStream = new MemoryStream(details.rgbData);
                    switch (propType)
                    {
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_NULL:
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_I1:
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_I2:
                            break;
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_BOOL:
                            if ((prop.wPropOffset >> 8) != 1 && (prop.wPropOffset >> 8) != 0)
                            {
                                return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_VAL_BOOL, 
                                    propType, prop.wPropOffset);
                            }
                            break;
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_I4:
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_STRING_ID:
                            //The following may not be required if deserialization happens correctly.
                            if (offsetbase + prop.wPropOffset + sizeof(uint) > cbDetails)
                            {
                                return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_OFFSET_OVERFLOW, 
                                    propType, offsetbase + prop.wPropOffset + sizeof(uint), cbDetails);
                            }
                            nextOffset = (ushort)(prop.wPropOffset + sizeof(uint));
                            break;
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_I8:
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_FILETIME:
                            //The following may not be required if deserialization happens correctly.
                            if (offsetbase + prop.wPropOffset + sizeof(ulong) > cbDetails)
                            {
                                return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_OFFSET_OVERFLOW, 
                                    propType, offsetbase + prop.wPropOffset + sizeof(ulong), cbDetails);
                            }
                            nextOffset = (ushort)(prop.wPropOffset + sizeof(ulong));
                            break;
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_STRING:
                            //Use MessageStringProperty
                            MessageStringProperty strProperty = new MessageStringProperty();
                            propStream.Seek(prop.wPropOffset, SeekOrigin.Begin);
                            strProperty.ReadStream(propStream);

                            //Update next offset
                            nextOffset = (ushort)(prop.wPropOffset + strProperty.Size());
                            break;
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_BINARY:
                            //Use MessageBinaryProperty
                            MessageBinaryProperty binProperty = new MessageBinaryProperty();
                            propStream.Seek(prop.wPropOffset, SeekOrigin.Begin);
                            binProperty.ReadStream(propStream);

                            //Update next offset
                            nextOffset = (ushort)(prop.wPropOffset + binProperty.Size());
                            break;
                        case MsgDefs.XONLINE_MSG_PROP_TYPE_ATTACHMENT:
                            //Use MessageAttachmentProperty
                            MessageAttachmentProperty attProperty = new MessageAttachmentProperty();
                            propStream.Seek(prop.wPropOffset, SeekOrigin.Begin);
                            attProperty.ReadStream(propStream);

                            //Update next offset
                            nextOffset = (ushort)(prop.wPropOffset + attProperty.Size());
                            break;
                        default:
                            return TraceErrorAndReturn(SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_TYPE_UNKNOWN, 
                                propType);
                    }
                }
                catch (XRLException /*ex*/)
                {
                    //Code above this function will rewrap the exception
                    //We lose the XRL exception but make it more meaningful above...
                    return SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS;
                }
            }
            System.Diagnostics.Debug.Assert((nextOffset == details.cbData));
            return SendMessageValidationCodes.SENDMESSAGE_SUCCESS;
        }

        public static StringBuilder GetExceptionString(SendMessageValidationCodes code, MessageWrapper message, string tag, string suffix)
        {
            //Pre allocate a 128 character buffer
            StringBuilder builder = new StringBuilder(MESSAGE_ERRORSTRING_DEFAULT_SIZE);
            switch (code)
            {
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_INVALID_MSG_TYPE:
                    builder.AppendFormat(validationCodeFormatStringMap[(int)code],
                        SGInfo.Current.ClientIP,
                        SGInfo.Current.ClientPort,
                        message.bMessageType,
                        suffix,
                        tag
                        );
                    break;
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_INVALID_MSG:
                    builder.AppendFormat(validationCodeFormatStringMap[(int)code],
                        SGInfo.Current.ClientIP,
                        SGInfo.Current.ClientPort,
                        message.dwMessageFlags,
                        MsgDefs.XONLINE_MSG_FLAGS_VALID_SEND_MASK,
                        suffix,
                        tag
                        );
                    break;
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_NON_EXPORTABLE:
                    builder.AppendFormat(validationCodeFormatStringMap[(int)code],
                        SGInfo.Current.ClientIP,
                        SGInfo.Current.ClientPort,
                        message.bMessageType,
                        suffix,
                        tag
                        );
                    break;
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_REQUIRED_RECOMMENDED:
                    builder.AppendFormat(validationCodeFormatStringMap[(int)code],
                        SGInfo.Current.ClientIP,
                        SGInfo.Current.ClientPort,
                        message.bMessageType,
                        suffix,
                        tag
                        );
                    break;
                case SendMessageValidationCodes.SENDSYSTEMMESSAGE_ERROR_INVALID_DESC:
                    builder.AppendFormat(validationCodeFormatStringMap[(int)code],
                        SGInfo.Current.ClientIP,
                        SGInfo.Current.ClientPort
                        );
                    break;
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_SIZE:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTIES_SIZE:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_ID:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_TYPE:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_TYPE_UNKNOWN:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_VAL_BOOL:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_VAL_OFFSET:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_OFFSET_OVERFLOW:
                case SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS_PROPERTY_ID_REPEATED:
                    //Notice us eating other return codes with the details placeholder error string.
                    builder.AppendFormat(validationCodeFormatStringMap[(int)SendMessageValidationCodes.SENDMESSAGE_ERROR_DETAILS],
                        SGInfo.Current.ClientIP,
                        SGInfo.Current.ClientPort,
                        suffix,
                        tag);
                    break;
                default:
                    //Default codepath returns success
                    return null;
            }
            return builder;
        }
    }

    internal static class SendMessageValidation
    {
        /// <summary>
        /// The non exception based validation method
        /// </summary>
        /// <param name="message">The message object to validate</param>
        /// <returns>Sendmessage validation return code enum</returns>
        public static SendMessageValidationCodes Validate(SendMessageMsg message)
        {
            SendMessageValidationCodes ret = BaseValidation.BaseValidate(new MessageWrapper(message));
            if (ret == SendMessageValidationCodes.SENDMESSAGE_SUCCESS)
            {
                if (0 != (message.dwMessageFlags & (MsgDefs.XONLINE_MSG_FLAG_REQUIRED | MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED))
                    && (MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE != message.bMessageType))
                {
                    return SendMessageValidationCodes.SENDMESSAGE_ERROR_REQUIRED_RECOMMENDED;
                }

                if (0 == message.dwSenderTitleID)
                {
                    return SendMessageValidationCodes.SENDMESSAGE_ERROR_TITLEID;
                }

                if (0 == message.cRecipients || message.cRecipients > MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)
                {
                    return SendMessageValidationCodes.SENDMESSAGE_ERROR_RECIPIENTS;
                }

                if (0 != message.cbDetails)
                {
                    ret = BaseValidation.ValidateDetails(message.details, message.cbDetails);
                }
            }
            return ret;
        }

        /// <summary>
        /// An exception based validation method, throws only 1 exception type 
        /// with appropriate string message
        /// </summary>
        /// <param name="message">The message object to validate</param>
        public static void ValidateWithException(SendMessageMsg message)
        {
            SendMessageValidationCodes code = SendMessageValidation.Validate(message);
            //Pre allocate a 128 character buffer
            string suffix = string.Format(", title={0}", (TitleId)message.dwSenderTitleID);
            StringBuilder builder = BaseValidation.GetExceptionString(code, new MessageWrapper(message), "", suffix);
            if (null != builder)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_SENDMESSAGE_INVALID_MESSAGE, builder.ToString());
            }
            else
            {
                builder = new StringBuilder();
                switch (code)
                {
                    case SendMessageValidationCodes.SENDMESSAGE_ERROR_TITLEID:
                        builder.AppendFormat(BaseValidation.validationCodeFormatStringMap[(int)code],
                            SGInfo.Current.ClientIP,
                            SGInfo.Current.ClientPort,
                            suffix,
                            ""
                            );
                        break;
                    case SendMessageValidationCodes.SENDMESSAGE_ERROR_RECIPIENTS:
                        builder.AppendFormat(BaseValidation.validationCodeFormatStringMap[(int)code],
                            SGInfo.Current.ClientIP,
                            SGInfo.Current.ClientPort,
                            message.cRecipients,
                            MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS,
                            suffix,
                            ""
                            );
                        break;
                    default:
                        return;
                }
            }
            throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_SENDMESSAGE_INVALID_MESSAGE, builder.ToString());
        }
    }

    internal static class SendSystemMessageValidation
    {
        private const ushort XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN = 64;
        /// <summary>
        /// The non exception based validation method
        /// </summary>
        /// <param name="message">The message object to validate</param>
        /// <returns>Sendmessage validation return code enum</returns>
        public static SendMessageValidationCodes Validate(SendSystemMessageMsg message)
        {
            SendMessageValidationCodes ret = BaseValidation.BaseValidate(new MessageWrapper(message));

            if (0 != message.cbDetails)
            {
                ret = BaseValidation.ValidateDetails(message.details, message.cbDetails);
            }

            if (message.szDescription.Length > (XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN - 1))
            {
                ret = SendMessageValidationCodes.SENDSYSTEMMESSAGE_ERROR_INVALID_DESC;
            }

            return ret;
        }

        /// <summary>
        /// An exception based validation method, throws only 1 exception type 
        /// with appropriate string message
        /// </summary>
        /// <param name="message">The message object to validate</param>
        public static void ValidateWithException(SendSystemMessageMsg message)
        {
            SendMessageValidationCodes code = Validate(message);
            //Pre allocate a 128 character buffer
            string suffix = "";
            StringBuilder builder = BaseValidation.GetExceptionString(code, new MessageWrapper(message), "System", suffix);
            if (null != builder)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.MESSAGING_SENDSYSTEMMESSAGE_INVALID_MESSAGE, builder.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\messaging\test\stf\FuncDeleteMsg.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;

namespace MessagingTest
{
    /// <summary>
    /// Functional Tests for DeleteMessage
    /// </summary>
    /// Positive cases check for success hr, and that QVal is received.
    /// Negative Cases check for failure hr that makes sense and is consistent.
    [TestGroup]
    public class FuncDeleteMsg_PositiveCases : MessagingTestGroup
    {
        private void General_Delete_Type_Case(byte msgType)
        {
            PNUser sender = MsgTestUtils.Fc.CreateUser(true);
            PNUser recipient = MsgTestUtils.CreateCleanUser();

            UserMessage msg = MsgTestUtils.CreateMessage(sender, msgType);
            msg.Send(recipient);

            UserMsgFolder msgFolder = new UserMsgFolder(recipient);
            msgFolder.WaitForMsgByContext(msgType, msg.Context, 60);
            ValueCheck.Test("Message Count", (ushort)1, msgFolder.Count);

            DeleteMessage(recipient, msgFolder.FirstMessage);
            msgFolder.Load2();
            ValueCheck.Test("Message Count After Delete", (ushort)0, msgFolder.Count);
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description("Delete a personal message")]
        public void P_Delete_Type_Personal()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_PERSONAL_MESSAGE);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Delete a party invitation")]
        public void P_Delete_Type_PartyChatInvite()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_PARTY_CHAT_INVITE);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Delete a quick chat invitation")]
        public void P_Delete_Type_QuickChatInvite()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_QUICK_CHAT_INVITE);
        }

        [TestCase, Description("Delete a title custom message")]
        public void P_Delete_Type_TitleCustom()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_TITLE_CUSTOM);
        }

        [TestCase, Description("Delete a video chat invitation")]
        public void P_Delete_Type_VideoChatInvite()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_VIDEO_CHAT_INVITE);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Delete a friend request")]
        public void P_Delete_Type_FriendRequest()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Delete a system message")]
        public void P_Delete_Type_SystemMessage()
        {
            General_Delete_Type_Case(XonPresNoti.MSG_TYPE_LIVE_MESSAGE);
        }

        [TestCase(42308), TestFrequency("Daily"), TestCasePriority(2), Description("Delete a game invitation")]
        public void P_Delete_Type_GameInvite()
        {
            PNUser sender = MsgTestUtils.Fc.CreateUser(true);
            PNUser recipient = MsgTestUtils.CreateCleanUser();

            MsgTestUtils.SendGameInvite(sender, recipient);
            UserMsgFolder msgFolder = new UserMsgFolder(recipient);
            msgFolder.Load2();
            ValueCheck.Test("Message Folder Counter", (ushort)1, msgFolder.Count);
            ValueCheck.Test("First Message Type", XonPresNoti.MSG_TYPE_GAME_INVITE, msgFolder.FirstMessage.Type);

            DeleteMessage(recipient, msgFolder.FirstMessage);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(1), Description("Delete a message that has been read")]
        public void P_Delete_Read()
        {
            PNUser sender = MsgTestUtils.CreateCleanUser();
            PNUser recipient = MsgTestUtils.CreateCleanUser();

            UserMessage msg = MsgTestUtils.CreateAndSendMessage(sender, recipient, XonPresNoti.MSG_TYPE_TITLE_CUSTOM);

            // Mark the message as read
            msg.GetDetails(recipient, msg.ID, XonPresNoti.MSG_FLAG_READ, 0);
            ValueCheck.Test(
                "Message Flags",
                XonPresNoti.MSG_FLAG_HAS_PHOTO | XonPresNoti.MSG_FLAG_HAS_TEXT | XonPresNoti.MSG_FLAG_HAS_VOICE | XonPresNoti.MSG_FLAG_READ,
                msg.Flags
                );

            DeleteMessage(recipient, msg);
        }

        [TestCase, Description("Delete a message that has custom title flags set")]
        public void P_Delete_TitleCustomFlags()
        {
            PNUser sender = MsgTestUtils.Fc.CreateUser(true);
            PNUser recipient = MsgTestUtils.CreateCleanUser();

            UserMessage msg = MsgTestUtils.CreateAndSendMessage(sender, recipient, XonPresNoti.MSG_TYPE_TITLE_CUSTOM);

            // Mark the message as read
            msg.GetDetails(recipient, msg.ID, XonPresNoti.MSG_FLAGS_TITLE_RESERVED, 0);
            ValueCheck.Test(
                "Message Flags",
                XonPresNoti.MSG_FLAG_HAS_PHOTO | XonPresNoti.MSG_FLAG_HAS_TEXT | XonPresNoti.MSG_FLAG_HAS_VOICE | XonPresNoti.MSG_FLAGS_TITLE_RESERVED,
                msg.Flags
                );

            DeleteMessage(recipient, msg);
        }

        [TestCase, Description("Delete a message flagged as non-exportable")]
        public void P_Delete_NonExportable()
        {
            PNUser sender = MsgTestUtils.Fc.CreateUser(true);
            PNUser recipient = MsgTestUtils.Fc.CreateUser(true);

            UserMessage msg = MsgTestUtils.CreateAndSendMessage(
                sender,
                new PNUser[] { recipient },
                XonPresNoti.MSG_TYPE_TITLE_CUSTOM,
                XonPresNoti.MSG_FLAG_NON_EXPORTABLE | XonPresNoti.MSG_FLAG_HAS_PHOTO | XonPresNoti.MSG_FLAG_HAS_TEXT | XonPresNoti.MSG_FLAG_HAS_VOICE,
                0,
                null
                );

            ValueCheck.Test(
                "Message Flags",
                XonPresNoti.MSG_FLAG_NON_EXPORTABLE | XonPresNoti.MSG_FLAG_HAS_PHOTO | XonPresNoti.MSG_FLAG_HAS_TEXT | XonPresNoti.MSG_FLAG_HAS_VOICE,
                msg.Flags
                );

            DeleteMessage(recipient, msg);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description("Delete a message and block the sender")]
        public void P_Delete_Block()
        {
            // Create the users
            PNUser user1 = MsgTestUtils.Fc.CreateUser(true);
            PNUser user2 = MsgTestUtils.CreateCleanUser();

            // Send Message
            UserMessage msg = MsgTestUtils.CreateAndSendMessage(user1, user2, XonPresNoti.MSG_TYPE_TITLE_CUSTOM);

            // Delete and block
            DeleteMessage(user2, msg, true);
            EnsureBlocked(user1, user2);
        }

        [TestCase, Description("Delete a game invitation and block the sender")]
        public void P_Delete_Block_Transient()
        {
            PNUser sender = MsgTestUtils.Fc.CreateUser(true);
            PNUser recipient = MsgTestUtils.CreateCleanUser();

            MsgTestUtils.SendGameInvite(sender, recipient);
            UserMsgFolder msgFolder = new UserMsgFolder(recipient);
            msgFolder.Load2();
            ValueCheck.Test("Message Folder Counter", (ushort)1, msgFolder.Count);
            ValueCheck.Test("First Message Type", XonPresNoti.MSG_TYPE_GAME_INVITE, msgFolder.FirstMessage.Type);

            DeleteMessage(recipient, msgFolder.FirstMessage, true);
            EnsureBlocked(sender, recipient);
        }

        [TestCase, Description("Block Sender, Unblock them, Block again")]
        public void P_Delete_BlockUnblockBlock()
        {
            // Create the users
            PNUser user1 = MsgTestUtils.Fc.CreateUser(true);
            PNUser user2 = MsgTestUtils.CreateCleanUser();

            // Send Message
     