;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CFTPInstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CInstanceProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      //
      // Service Page
      //
      HANDLE_META_RECORD(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      HANDLE_META_RECORD(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      HANDLE_META_RECORD(MD_LOG_TYPE,            m_dwLogType)
      //
      // Accounts Page
      //
      HANDLE_META_RECORD(MD_ANONYMOUS_USER_NAME,   m_strUserName)
      HANDLE_META_RECORD(MD_ANONYMOUS_PWD,         m_strPassword)
      HANDLE_META_RECORD(MD_ANONYMOUS_ONLY,        m_fOnlyAnonymous)
      HANDLE_META_RECORD(MD_ALLOW_ANONYMOUS,       m_fAllowAnonymous)
      HANDLE_META_RECORD(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      HANDLE_META_RECORD(MD_ADMIN_ACL,             m_acl)
      //
      // Message Page
      //
      HANDLE_META_RECORD(MD_EXIT_MESSAGE,        m_strExitMessage)
      HANDLE_META_RECORD(MD_MAX_CLIENTS_MESSAGE, m_strMaxConMsg)
      HANDLE_META_RECORD(MD_GREETING_MESSAGE,    m_strlWelcome)
      //
      // Directory Properties Page
      //
      HANDLE_META_RECORD(MD_MSDOS_DIR_OUTPUT,    m_fDosDirOutput);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CFTPInstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CInstanceProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    BEGIN_META_WRITE()
      //
      // Service Page
      //
      META_WRITE(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      META_WRITE(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      META_WRITE(MD_LOG_TYPE,            m_dwLogType)
      //
      // Accounts Page
      //
      META_WRITE(MD_ANONYMOUS_USER_NAME,   m_strUserName)
      META_WRITE(MD_ANONYMOUS_PWD,         m_strPassword)
      META_WRITE(MD_ANONYMOUS_ONLY,        m_fOnlyAnonymous)
      META_WRITE(MD_ALLOW_ANONYMOUS,       m_fAllowAnonymous)
      META_WRITE(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      META_WRITE(MD_ADMIN_ACL,             m_acl)
      //
      // Message Page
      //
      META_WRITE(MD_EXIT_MESSAGE,        m_strExitMessage)
      META_WRITE(MD_MAX_CLIENTS_MESSAGE, m_strMaxConMsg)
      META_WRITE(MD_GREETING_MESSAGE,    m_strlWelcome)
      //
      // Directory Properties Page
      //
      META_WRITE(MD_MSDOS_DIR_OUTPUT,    m_fDosDirOutput);
    END_META_WRITE(err);

    return err;
}



CFTPDirProps::CFTPDirProps(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwInstance,      OPTIONAL
    IN LPCTSTR lpszParent,      OPTIONAL
    IN LPCTSTR lpszAlias        OPTIONAL
    )
/*++

Routine Description:

    FTP Directory properties object

Arguments:

    LPCTSTR lpszServerName     : Server name
    DWORD dwInstance            : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParent         : Parent path (could be NULL)
    LPCTSTR lpszAlias          : Alias name (could be NULL)

Return Value:

    N/A.

--*/
    : CChildNodeProps(
        lpszServerName, 
        g_cszSvc, 
        dwInstance,
        lpszParent, 
        lpszAlias,
        WITH_INHERITANCE,
        FALSE               // Complete information
        ),
      /**/
      m_fDontLog(FALSE),
      m_ipl()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CFTPDirProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CChildNodeProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,  m_pbMDData)
      HANDLE_META_RECORD(MD_VR_USERNAME,      m_strUserName)
      HANDLE_META_RECORD(MD_VR_PASSWORD,      m_strPassword)
      HANDLE_META_RECORD(MD_DONT_LOG,         m_fDontLog);
      HANDLE_META_RECORD(MD_IP_SEC,           m_ipl);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CFTPDirProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CChildNodeProps::WriteDirtyProps());
    if (err.Failed())
    {
        return err;
    }

    //
    // CODEWORK: Consider DDX/DDV like methods which do both
    // ParseFields and WriteDirtyProps in a single method.  Must
    // take care not to write data which should only be read, not
    // written
    //
    BEGIN_META_WRITE()
      META_WRITE(MD_VR_USERNAME,      m_strUserName)
      META_WRITE(MD_VR_PASSWORD,      m_strPassword)
      META_WRITE(MD_DONT_LOG,         m_fDontLog);
      META_WRITE(MD_IP_SEC,           m_ipl);
    END_META_WRITE(err);

    return err;
}



CFtpSheet::CFtpSheet(
    LPCTSTR pszCaption,
    LPCTSTR lpszServer,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias,
    CWnd *  pParentWnd,
    LPARAM  lParam,
    LONG_PTR handle,
    UINT    iSelectPage
    )
/*++

Routine Description:

    FTP Property sheet constructor

Arguments:

    LPCTSTR pszCaption      : Sheet caption
    LPCTSTR lpszServer      : Server name
    DWORD   dwInstance      : Instance number
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Alias name
    CWnd *  pParentWnd      : Parent window
    LPARAM  lParam          : Parameter for MMC console
    LONG_PTR handle         : MMC console handle
    UINT    iSelectPage     : Initial page selected or -1

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pszCaption,
        lpszServer,
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias,
        pParentWnd,
        lParam,
        handle,
        iSelectPage
        ),
      m_ppropInst(NULL),
      m_ppropDir(NULL)
{
}



CFtpSheet::~CFtpSheet()
/*++

Routine Description:

    FTP Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();

    //
    // Must be deleted by now
    //
    ASSERT(m_ppropInst == NULL);
    ASSERT(m_ppropDir  == NULL);
}



void
CFtpSheet::WinHelp(
    IN DWORD dwData,
    IN UINT  nCmd
    )
/*++

Routine Description:

    FTP Property sheet help handler

Arguments:

    DWORD dwData            : WinHelp data (dialog ID)
    UINT nCmd               : WinHelp command

Return Value:

    None

Notes:

    Replace the dialog ID if this is the directory tab.  We have
    different help depending on virtual directory, home, file, directory.

--*/
{
    ASSERT(m_ppropDir != NULL);

    if (::lstrcmpi(m_ppropDir->QueryAlias(), g_cszRoot) == 0
        && dwData == HIDD_DIRECTORY_PROPERTIES)
    {
        //
        // It's a home virtual directory -- change the ID
        //
        dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
    }

    CInetPropertySheet::WinHelp(dwData, nCmd);
}



/* virtual */ 
HRESULT 
CFtpSheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    if (m_ppropInst == NULL)
    {
        ASSERT(m_ppropDir == NULL);

        m_ppropInst = new CFTPInstanceProps(m_strServer, m_dwInstance);
        m_ppropDir  = new CFTPDirProps(
            m_strServer, 
            m_dwInstance, 
            m_strParent, 
            m_strAlias
            );

        if (!m_ppropInst || !m_ppropDir)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_ppropInst->LoadData();
        if (err.Succeeded())
        {
            err = m_ppropDir->LoadData();
        }
    }

    return err;
}



/* virtual */ 
void 
CFtpSheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must be deleted by now
    //
    ASSERT(m_ppropInst != NULL);
    ASSERT(m_ppropDir  != NULL);

    SAFE_DELETE(m_ppropInst);
    SAFE_DELETE(m_ppropDir);
}




//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Global DLL instance
//
HINSTANCE hInstance;



//
// ISM API Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



extern "C" DWORD APIENTRY
ISMQueryServiceInfo(
    OUT ISMSERVICEINFO * psi
    )
/*++

Routine Description:

    Return service-specific information back to the application.  This
    function is called by the service manager immediately after LoadLibary();
    The size element must be set prior to calling this API.

Arguments:

    ISMSERVICEINFO * psi : Service information returned.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(psi != NULL);
    ASSERT(psi->dwSize == ISMSERVICEINFO_SIZE);

    psi->dwSize = ISMSERVICEINFO_SIZE;
    psi->dwVersion = ISM_VERSION;
    psi->flServiceInfoFlags = SERVICE_INFO_FLAGS;
    psi->ullDiscoveryMask = INETSLOC_MASK;
    psi->rgbButtonBkMask  = BUTTON_BMP_BACKGROUND;
    psi->nButtonBitmapID  = BUTTON_BMP_ID;
    psi->rgbServiceBkMask = SERVICE_BMP_BACKGROUND;
    psi->nServiceBitmapID = SERVICE_BMP_ID;
    psi->rgbServiceBkMask = SERVICE_BMP_BACKGROUND;
    psi->nLargeServiceBitmapID = SERVICE_BMP32_ID;

    ASSERT(::lstrlen(SERVICE_LONG_NAME)  <= MAX_LNLEN);
    ASSERT(::lstrlen(SERVICE_SHORT_NAME) <= MAX_SNLEN);
    ::lstrcpy(psi->atchShortName, SERVICE_SHORT_NAME);
    ::lstrcpy(psi->atchLongName,  SERVICE_LONG_NAME);

    //
    // /* K2 */
    //
    psi->rgbChildBkMask = CHILD_BMP_BACKGROUND;
    psi->nChildBitmapID = CHILD_BMP_ID ;
    psi->rgbLargeChildBkMask = CHILD_BMP_BACKGROUND;
    psi->nLargeChildBitmapID = CHILD_BMP32_ID;

    //
    // IIS 5
    //
    ASSERT(::lstrlen(SERVICE_PROTOCOL) <= MAX_SNLEN);
    ASSERT(::lstrlen(g_cszSvc) <= MAX_SNLEN);
    ::lstrcpy(psi->atchProtocol, SERVICE_PROTOCOL);
    ::lstrcpy(psi->atchMetaBaseName, g_cszSvc);

    return ERROR_SUCCESS;
}



DWORD APIENTRY
ISMDiscoverServers(
    OUT ISMSERVERINFO * psi,
    IN  DWORD * pdwBufferSize,
    IN  int * cServers
    )
/*++

Routine Description:

    Discover machines running this service.  This is only necessary
    for services not discovered with inetsloc (which don't give a mask)

Arguments:

    ISMSERVERINFO * psi   : Server info buffer.
    DWORD * pdwBufferSize : Size required/available.
    int * cServers        : Number of servers in buffer.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    *cServers = 0;
    *pdwBufferSize = 0L;

    //
    // We're an inetsloc service
    //
    TRACEEOLID("Warning: service manager called bogus ISMDiscoverServers");
    ASSERT(FALSE);

    return ERROR_SUCCESS;
}



extern "C" DWORD APIENTRY
ISMQueryServerInfo(
    IN  LPCTSTR lpszServerName,
    OUT ISMSERVERINFO * psi
    )
/*++

Routine Description:

    Get information about a specific server with regards to this service.

Arguments:

    LPCTSTR lpszServerName : Name of server.
    ISMSERVERINFO * psi     : Server information returned.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(psi != NULL);
    ASSERT(psi->dwSize == ISMSERVERINFO_SIZE);
    ASSERT(::lstrlen(lpszServerName) <= MAX_SERVERNAME_LEN);

    psi->dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi->atchServerName, lpszServerName);

    //
    // Start with NULL comment
    //
    *psi->atchComment = _T('\0');

    //
    // First look at the SC
    //
    CError err(::QueryInetServiceStatus(
        psi->atchServerName,
        SERVICE_SC_NAME,
        &(psi->nState)
        ));

    if (err.Failed())
    {
        psi->nState = INetServiceUnknown;

        return err;
    }

    //
    // Check the metabase to see if the service is installed
    //
    CMetaKey mk(lpszServerName, METADATA_PERMISSION_READ, g_cszSvc);
    err = mk.QueryResult();
    if (err.Failed())
    {
        if (err == REGDB_E_CLASSNOTREG)
        {
            //
            // Ok, the service is there, but the metabase is not.
            // This must be the old IIS 1-3 version of this service,
            // which doesn't count as having the service installed.
            //
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }

        return err;
    }

    //
    // If not exist, return bogus acceptable error
    //
    return (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        ? ERROR_SERVICE_DOES_NOT_EXIST
        : err.Win32Error();
}



extern "C" DWORD APIENTRY
ISMChangeServiceState(
    IN  int nNewState,
    OUT int * pnCurrentState,
    IN  DWORD dwInstance,
    IN  LPCTSTR lpszServers
    )
/*++

Routine Description:

    Change the service state of the servers (to paused/continue, started,
    stopped, etc)

Arguments:

    int nNewState        : INetService definition.
    int * pnCurrentState : Ptr to current state (will be changed
    DWORD dwInstance     : Instance or 0 for the service itself
    LPCTSTR lpszServers  : Double NULL terminated list of servers.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    ASSERT(nNewState >= INetServiceStopped
        && nNewState <= INetServicePaused);

    if (IS_MASTER_INSTANCE(dwInstance))
    {
        //
        // Service itself is referred to here
        //
        return ChangeInetServiceState(
            lpszServers,
            SERVICE_SC_NAME,
            nNewState, 
            pnCurrentState
            );
    }

    //
    // Change the state of the instance
    //
    CInstanceProps inst(lpszServers, g_cszSvc, dwInstance);
    inst.LoadData();

    CError err(inst.ChangeState(nNewState));
    *pnCurrentState = inst.QueryISMState();

    return err;
}



extern "C" DWORD APIENTRY
ISMConfigureServers(
    IN HWND hWnd,
    IN DWORD dwInstance,
    IN LPCTSTR lpszServers
    )
/*++

Routine Description:

    Display configuration property sheet.

Arguments:

    HWND hWnd            : Main app window handle
    DWORD dwInstance     : Instance number
    LPCTSTR lpszServers : Double NULL terminated list of servers

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    DWORD err = ERROR_SUCCESS;

    //
    // Convert the list of servers to a
    // more manageable CStringList.
    //
    CStringList strlServers;
    err = ConvertDoubleNullListToStringList(lpszServers, strlServers);
    if (err != ERROR_SUCCESS)
    {
        TRACEEOLID("Error building server string list");
        return err;
    }

    CString strCaption;

    if (strlServers.GetCount() == 1)
    {
        CString str;
        LPCTSTR lpComputer = PURE_COMPUTER_NAME(lpszServers);

        if(IS_MASTER_INSTANCE(dwInstance))
        {
            VERIFY(str.LoadString(IDS_CAPTION_DEFAULT));
            strCaption.Format(str, lpComputer);
        }
        else
        {
            VERIFY(str.LoadString(IDS_CAPTION));
            strCaption.Format(str, dwInstance, lpComputer);
        }
    }
    else // Multiple server caption
    {
       VERIFY(strCaption.LoadString(IDS_CAPTION_MULTIPLE));
    }

    ASSERT(strlServers.GetCount() == 1);

    //
    // Get the server name
    //
    LPCTSTR lpszServer = strlServers.GetHead();

    CFtpSheet * pSheet = NULL;

    try
    {
        pSheet = new CFtpSheet(
            strCaption,
            lpszServer,
            dwInstance,
            NULL,
            g_cszRoot,
            CWnd::FromHandlePermanent(hWnd)
            );

        pSheet->AddRef();

        if (SUCCEEDED(pSheet->QueryInstanceResult()))
        {
            //
            // Add instance pages
            //
            pSheet->AddPage(new CFtpServicePage(pSheet));
            pSheet->AddPage(new CFtpAccountsPage(pSheet));
            pSheet->AddPage(new CFtpMessagePage(pSheet));
        }

        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            //
            // Add home directory pages for the home directory
            //
            pSheet->AddPage(new CFtpDirectoryPage(pSheet, TRUE));
            pSheet->AddPage(new CFtpSecurityPage(pSheet));
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting because of exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    if (err == ERROR_SUCCESS)
    {
        ASSERT(pSheet != NULL);
        pSheet->DoModal();
        pSheet->Release();
    }

    //
    // Sheet and pages clean themselves up
    //
    return err;
}


//
// K2 Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
AddMMCPage(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CPropertyPage * pg
    )
/*++

Routine Description:

    Helper function to add MFC property page using callback provider
    to MMC.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Property sheet provider
    CPropertyPage * pg                  : MFC property page object

Return Value:

    HRESULT

--*/
{
    ASSERT(pg != NULL);

    //
    // Patch MFC property page class.
    //
    MMCPropPageCallback(&pg->m_psp);

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(
        (LPCPROPSHEETPAGE)&pg->m_psp
        );

    if (hPage == NULL)
    {
        return E_UNEXPECTED;
    }

    lpProvider->AddPage(hPage);

    return S_OK;
}



extern "C" HRESULT APIENTRY
ISMBind(
    IN  LPCTSTR lpszServer,
    OUT HANDLE * phServer
    )
/*++

Routine Description:

    Generate a handle for the server name.

Arguments:

    LPCTSTR lpszServer      : Server name
    HANDLE * phServer       : Returns a handle

Return Value:
    
    HRESULT

--*/
{
    return COMDLL_ISMBind(lpszServer, phServer);
}



extern "C" HRESULT APIENTRY
ISMUnbind(
    IN HANDLE hServer
    )
/*++

Routine Description:

    Free up the server handle

Arguments:

    HANDLE hServer      : Server handle

Return Value:

    HRESULT

--*/
{
    return COMDLL_ISMUnbind(hServer);
}



extern "C" HRESULT APIENTRY
ISMMMCConfigureServers(
    IN HANDLE   hServer,
    IN PVOID    lpfnMMCCallbackProvider,
    IN LPARAM   param,
    IN LONG_PTR handle,
    IN DWORD    dwInstance
    )
/*++

Routine Description:

    Display configuration property sheet.

Arguments:

    HANDLE   hServer                 : Server handle
    PVOID    lpfnMMCCallbackProvider : MMC Callback provider
    LPARAM   param                   : MMC LPARAM
    LONG_PTR handle                  : MMC Console handle
    DWORD    dwInstance              : Instance number

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    LPPROPERTYSHEETCALLBACK lpProvider =
        (LPPROPERTYSHEETCALLBACK)lpfnMMCCallbackProvider;

    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    CString str, strCaption;
    LPCTSTR lpszComputer = PURE_COMPUTER_NAME(lpszServer);

    if(IS_MASTER_INSTANCE(dwInstance))
    {
        VERIFY(str.LoadString(IDS_CAPTION_DEFAULT));
        strCaption.Format(str, lpszComputer);
    }
    else
    {
        VERIFY(str.LoadString(IDS_CAPTION));
        strCaption.Format(str, dwInstance, lpszComputer);
    }

    CFtpSheet * pSheet = NULL;

    try
    {
        pSheet = new CFtpSheet(
            strCaption,
            lpszServer,
            dwInstance,
            NULL,
            g_cszRoot,
            NULL,
            param,
            handle
            );

        pSheet->SetModeless();

        CFtpServicePage *   pServPage = NULL;
        CFtpAccountsPage *  pAccPage  = NULL;
        CFtpMessagePage  *  pMessPage = NULL;
        CFtpDirectoryPage * pDirPage  = NULL;
        CFtpSecurityPage *  pSecPage  = NULL;

        if (SUCCEEDED(pSheet->QueryInstanceResult()))
        {
            //
            // Add instance pages
            //
            AddMMCPage(lpProvider, new CFtpServicePage(pSheet));
            AddMMCPage(lpProvider, new CFtpAccountsPage(pSheet));
            AddMMCPage(lpProvider, new CFtpMessagePage(pSheet));
        }

        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            //
            // Add home directory pages for the home directory
            //
            AddMMCPage(lpProvider, new CFtpDirectoryPage(pSheet, TRUE));
            AddMMCPage(lpProvider, new CFtpSecurityPage(pSheet));
        }

    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting because of exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    //
    // Sheet and pages clean themselves up
    //
    return err;
}



extern "C" HRESULT APIENTRY
ISMMMCConfigureChild(
    IN HANDLE  hServer,
    IN PVOID   lpfnMMCCallbackProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Display configuration property sheet for child object.

Arguments:

    HANDLE  hServer               : Server handle
    PVOID lpfnMMCCallbackProvider : MMC Callback provider
    LPARAM param                  : MMC parameter passed to sheet
    LONG_PTR handle               : MMC console handle
    DWORD dwAttributes            : Must be FILE_ATTRIBUTE_VIRTUAL_DIRECTORY
    DWORD dwInstance              : Parent instance number
    LPCTSTR lpszParent            : Parent path
    LPCTSTR lpszAlias             : Child to configure

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);

    CError err;

    LPPROPERTYSHEETCALLBACK lpProvider =
        (LPPROPERTYSHEETCALLBACK)lpfnMMCCallbackProvider;

    CString strCaption;
    {
        CString str;
        VERIFY(str.LoadString(IDS_DIR_TITLE));

        strCaption.Format(str, lpszAlias);
    }

    ASSERT(dwAttributes == FILE_ATTRIBUTE_VIRTUAL_DIRECTORY);

    //
    // Call the APIs and build the property pages
    //
    CFtpSheet * pSheet = NULL;

    try
    {
        pSheet = new CFtpSheet(
            strCaption,
            lpszServer,
            dwInstance,
            lpszParent,
            lpszAlias,
            NULL,
            param,
            handle
            );

        pSheet->SetModeless();

        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            CFtpDirectoryPage * pDirPage = NULL;
            CFtpSecurityPage * pSecPage  = NULL;

            //
            // Add private pages
            //
            AddMMCPage(lpProvider, new CFtpDirectoryPage(pSheet));
            AddMMCPage(lpProvider, new CFtpSecurityPage(pSheet));
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting due to exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    //
    // Sheet and pages clean themselves up
    //
    return err;
}



extern "C" HRESULT APIENTRY
ISMEnumerateInstances(
    IN HANDLE  hServer,
    OUT ISMINSTANCEINFO * pii,
    OUT IN HANDLE * phEnum
    )
/*++

Routine Description:

    Enumerate Instances.  First call with *phEnum == NULL.

Arguments:

    HANDLE  hServer         : Server handle
    ISMINSTANCEINFO * pii   : Instance info buffer
    HANDLE * phEnum         : Enumeration handle.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);
    ASSERT(pInterface != NULL);

    BEGIN_ASSURE_BINDING_SECTION
        err = COMDLL_ISMEnumerateInstances(
            pInterface, 
            pii, 
            phEnum, 
            g_cszSvc
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_NO_MORE_ITEMS);

    return err;
}



extern "C" HRESULT APIENTRY
ISMAddInstance(
    IN  HANDLE  hServer,         
    IN  DWORD   dwSourceInstance,
    OUT ISMINSTANCEINFO * pii,      OPTIONAL
    IN  DWORD   dwBufferSize
    )
/*++

Routine Description:

    Add an instance.

Arguments:

    HANDLE  hServer             : Server handle
    DWORD   dwSourceInstance    : Source instance ID to clone
    ISMINSTANCEINFO * pii       : Instance info buffer.  May be NULL
    DWORD   dwBufferSize        : Size of buffer

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CIISWizardSheet sheet(IDB_WIZ_LEFT, IDB_WIZ_HEAD);

    CIISFtpWizSettings ws(hServer, g_cszSvc);

    CIISWizardBookEnd pgWelcome(
        IDS_SITE_WELCOME, 
        IDS_NEW_SITE_WIZARD, 
        IDS_SITE_BODY
        );

    CVDWPDescription  pgDescr(&ws);
    CVDWPBindings     pgBindings(&ws);
    CVDWPPath         pgHome(&ws, FALSE);
    CVDWPUserName     pgUserName(&ws, FALSE);
    CVDWPPermissions  pgPerms(&ws, FALSE);

    CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_SITE_SUCCESS,
        IDS_SITE_FAILURE,
        IDS_NEW_SITE_WIZARD
        );

    sheet.AddPage(&pgWelcome);
    sheet.AddPage(&pgDescr);
    sheet.AddPage(&pgBindings);
    sheet.AddPage(&pgHome);
    sheet.AddPage(&pgUserName);
    sheet.AddPage(&pgPerms);
    sheet.AddPage(&pgCompletion);

    if (sheet.DoModal() == IDCANCEL)
    {
        return ERROR_CANCELLED;
    }

    CError err(ws.m_hrResult);

    if (err.Succeeded())
    {
        //
        // Get info on it to be returned.
        //
        ISMQueryInstanceInfo(
            ws.m_pKey, 
            WITHOUT_INHERITANCE,
            pii, 
            ws.m_dwInstance
            );
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMDeleteInstance(
    IN HANDLE  hServer,         
    IN DWORD   dwInstance
    )
/*++

Routine Description:

   Delete an instance

Arguments:

    HANDLE  hServer         : Server handle
    DWORD   dwInstance      : Instance to be deleted

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);

    BEGIN_ASSURE_BINDING_SECTION
        err = CInstanceProps::Delete(
            pInterface, 
            g_cszSvc, 
            dwInstance
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_CANCELLED);

    return err;
}



extern "C" HRESULT APIENTRY
ISMEnumerateChildren(
    IN  HANDLE  hServer,        
    OUT ISMCHILDINFO * pii,
    OUT IN HANDLE * phEnum,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent
    )
/*++

Routine Description:

    Enumerate children.  First call with *phEnum == NULL;

Arguments:

    HANDLE hServer              : Server handle
    ISMCHILDINFO * pii          : Child info buffer
    HANDLE * phEnum             : Enumeration handle.
    DWORD   dwInstance          : Parent instance
    LPCTSTR lpszParent          : Parent path

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);

    BEGIN_ASSURE_BINDING_SECTION
        err = COMDLL_ISMEnumerateChildren(
            pInterface,
            pii,
            phEnum,
            g_cszSvc,
            dwInstance,
            lpszParent
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_NO_MORE_ITEMS);

    return err;
}



extern "C" HRESULT APIENTRY
ISMAddChild(
    IN  HANDLE  hServer,
    OUT ISMCHILDINFO * pii,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent
    )
/*++

Routine Description:

    Add a child.

Arguments:

    HANDLE  hServer             : Server handle
    ISMCHILDINFO * pii          : Child info buffer. May be NULL
    DWORD   dwBufferSize        : Size of info buffer
    DWORD   dwInstance          : Parent instance
    LPCTSTR lpszParent          : Parent path

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CIISFtpWizSettings ws(hServer, g_cszSvc, dwInstance, lpszParent);

    CIISWizardSheet sheet(IDB_WIZ_LEFT_DIR, IDB_WIZ_HEAD_DIR);

    CIISWizardBookEnd pgWelcome(
        IDS_VDIR_WELCOME, 
        IDS_NEW_VDIR_WIZARD, 
        IDS_VDIR_BODY
        );

    CVDWPAlias        pgAlias(&ws);
    CVDWPPath         pgPath(&ws, TRUE);
    CVDWPUserName     pgUserName(&ws, TRUE);
    CVDWPPermissions  pgPerms(&ws, TRUE);

    CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_VDIR_SUCCESS,
        IDS_VDIR_FAILURE,
        IDS_NEW_VDIR_WIZARD
        );

    sheet.AddPage(&pgWelcome);
    sheet.AddPage(&pgAlias);
    sheet.AddPage(&pgPath);
    sheet.AddPage(&pgUserName);
    sheet.AddPage(&pgPerms);
    sheet.AddPage(&pgCompletion);

    if (sheet.DoModal() == IDCANCEL)
    {
        return ERROR_CANCELLED;
    }

    CError err(ws.m_hrResult);

    if (err.Succeeded())
    {
        //
        // Refresh child info
        //
        err = ISMQueryChildInfo(
            ws.m_pKey,
            WITH_INHERITANCE,
            pii, 
            ws.m_dwInstance, 
            ws.m_strParent, 
            ws.m_strAlias
            );
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMDeleteChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Delete a child.

Arguments:

    HANDLE  hServer            : Server handle
    DWORD   dwInstance         : Parent instance
    LPCTSTR lpszParent         : Parent path
    LPCTSTR lpszAlias          : Alias of child to be deleted

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);

    BEGIN_ASSURE_BINDING_SECTION
        err = CChildNodeProps::Delete(
            pInterface, 
            g_cszSvc, 
            dwInstance, 
            lpszParent, 
            lpszAlias
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_CANCELLED);

    return err;
}



extern "C" HRESULT APIENTRY
ISMRenameChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias,
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename a child.

Arguments:

    HANDLE  hServer            : Server handle
    DWORD   dwInstance         : Parent instance
    LPCTSTR lpszParent         : Parent path
    LPCTSTR lpszAlias          : Alias of child to be renamed
    LPCTSTR lpszNewName        : New alias name

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);

    BEGIN_ASSURE_BINDING_SECTION
        err = CChildNodeProps::Rename(
            pInterface,
            g_cszSvc, 
            dwInstance, 
            lpszParent, 
            lpszAlias, 
            lpszNewName
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_CANCELLED)

    return err;
}



extern "C" HRESULT APIENTRY
ISMQueryInstanceInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,
    OUT ISMINSTANCEINFO * pii,
    IN  DWORD   dwInstance
    )
/*++

Routine Description:

    Get instance specific information.

Arguments:

    HANDLE  hServer         : Server handle
    BOOL    fInherit        : TRUE to inherit, FALSE otherwise
    ISMINSTANCEINFO * pii   : Instance info buffer
    LPCTSTR lpszServer      : A single server
    DWORD   dwInstance      : Instance number

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(pii != NULL);

	CError err;
    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    BEGIN_ASSURE_BINDING_SECTION
    CInstanceProps inst(pKey, g_cszSvc, dwInstance);
    err = inst.LoadData();
	if (err.Succeeded())
	{
		pii->dwSize = ISMINSTANCEINFO_SIZE;
		inst.FillInstanceInfo(pii);
		//
		// Get properties on the home directory
		//
		CChildNodeProps home(
			&inst,
			g_cszSvc,
			dwInstance,
			NULL,
			g_cszRoot,
			fInherit,
			TRUE                    // Path only
			);

		err = home.LoadData();
		home.FillInstanceInfo(pii);
	}
    END_ASSURE_BINDING_SECTION(err, pKey, err);

    return err.Failed() ? err : S_OK;
}



extern "C" HRESULT APIENTRY
ISMQueryChildInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,
    OUT ISMCHILDINFO * pii,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent,
    IN  LPCTSTR lpszAlias
    )
/*++

Routine Description:

   Get child-specific info.

Arguments:

    HANDLE  hServer         : Server handle
    BOOL    fInherit        : TRUE to inherit, FALSE otherwise
    ISMCHILDINFO * pii      : Child info buffer
    DWORD   dwInstance      : Parent instance
    LPCTSTR lpszParent      : Parent Path ("" for root)
    LPCTSTR lpszAlias       : Alias of child to be deleted

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // Get all the inherited properties
    //
    CChildNodeProps node(
        GetMetaKeyFromHandle(hServer),
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias,
        fInherit,
        FALSE               // Complete information
        );
    CError err(node.LoadData());

    //
    // Set the output structure
    //
    pii->dwSize = ISMCHILDINFO_SIZE;
    node.FillChildInfo(pii);

    //
    // Not supported for FTP
    //
    ASSERT(!node.IsRedirected());
    ASSERT(!*pii->szRedirPath);
    ASSERT(!pii->fEnabledApplication);

    return err;
}



extern "C" HRESULT APIENTRY
ISMConfigureChild(
    IN HANDLE  hServer,
    IN HWND    hWnd,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Configure child.

Arguments:

    HANDLE  hServer         : Server handle
    HWND    hWnd            : Main app window handle
    DWORD   dwAttributes    : File attributes
    DWORD   dwInstance      : Parent instance
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Child to configure or NULL

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);

    CError err;

    CString strCaption;
    {
        CString str;
        VERIFY(str.LoadString(IDS_DIR_TITLE));

        strCaption.Format(str, lpszAlias);
    }

    ASSERT(dwAttributes == FILE_ATTRIBUTE_VIRTUAL_DIRECTORY);

    //
    // Call the APIs and build the property pages
    //
    CFtpSheet * pSheet = NULL;

    try
    {
        pSheet = new CFtpSheet(
            strCaption,
            lpszServer,
            dwInstance,
            lpszParent,
            lpszAlias,
            CWnd::FromHandlePermanent(hWnd)
            );

        pSheet->AddRef();

        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            CFtpDirectoryPage * pDirPage = NULL;
            CFtpSecurityPage * pSecPage = NULL;

            //
            // Add private pages
            //
            pSheet->AddPage(new CFtpDirectoryPage(pSheet));
            pSheet->AddPage(new CFtpSecurityPage(pSheet));
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting due to exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    if (err.Succeeded())
    {
        ASSERT(pSheet != NULL);
        pSheet->DoModal();
        pSheet->Release();
    }

    //
    // Sheet and pages clean themselves up
    //
    return err;
}



class CFTPSecurityTemplate : public CIISSecurityTemplate
/*++

Class Description:

    FTP Security template class

Public Interface:

    CFTPSecurityTemplate        : Constructor

    ApplySettings               : Apply template to destination path
    GenerateSummary             : Generate text summary

--*/
{
//
// Constructor
//
public:
    CFTPSecurityTemplate(
        IN const CMetaKey * pKey,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit     
        );

public:
    //
    // Apply settings to destination path
    //
    virtual HRESULT ApplySettings(
        IN BOOL    fUseTemplates,
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance         = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );

    //
    // Load and parse source data
    //
    virtual HRESULT LoadData();

    virtual void GenerateSummary(
        IN BOOL    fUseTemplates,
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance         = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );
    
protected:
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    MP_BOOL  m_fAllowAnonymous;
    MP_BOOL  m_fAnonymousOnly;
};



CFTPSecurityTemplate::CFTPSecurityTemplate(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path
    BOOL    fInherit        : TRUE to inherit values, FALSE if not

Return Value:

    N/A

--*/
    : CIISSecurityTemplate(pKey, lpszMDPath, fInherit),
      m_fAllowAnonymous(FALSE),
      m_fAnonymousOnly(FALSE)
{
    //
    // Managed Properties
    //
    m_dlProperties.AddTail(MD_ALLOW_ANONYMOUS);
    m_dlProperties.AddTail(MD_ANONYMOUS_ONLY);
}



/* virtual */
HRESULT 
CFTPSecurityTemplate::LoadData()
/*++

Routine Description:

    LoadData() base class override

Arguments:

    None

Return Value:

    HRESULT

Notes:

    The FTP wizard has an annoying idiosynchrasy:  access authentication 
    settings are per site, not per vdir.   Therefore, they need to be set
    and fetched in a separate path, and not be set at all if not
    setting props on a site.  What a pain...

--*/
{
    TRACEEOLID(m_strMetaPath);

    CError err(CIISSecurityTemplate::LoadData());

    if (lstrcmpi(m_strMetaRoot, g_cszRoot) == 0)
    {
        //
        // Fetch the anonymous access settings from
        // the instance node.  Note: This explicit step
        // should only be necessary for templates, because 
        // this would otherwise be picked up on inheritance.
        //
        ASSERT(!m_fInherit);
        m_strMetaRoot.Empty();

        err = CIISSecurityTemplate::LoadData();
    }

    return err;
}



/* virtual */
void
CFTPSecurityTemplate::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base class values
    //
    CIISSecurityTemplate::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,    m_pbMDData)
      HANDLE_META_RECORD(MD_ALLOW_ANONYMOUS,    m_fAllowAnonymous)
      HANDLE_META_RECORD(MD_ANONYMOUS_ONLY,     m_fAnonymousOnly)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT 
CFTPSecurityTemplate::ApplySettings(
    IN BOOL    fUseTemplate,
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Apply the settings to the specified destination path

Arguments:
    
    BOOL fUseTemplates         : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    HRESULT

--*/
{
    //
    // Write base class properties
    //
    CError err(CIISSecurityTemplate::ApplySettings(
        fUseTemplate,
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        ));

    if (err.Failed())
    {
        return err;
    }

    BOOL fWriteProperties = TRUE;

    CMetaKey mk(
        lpszServerName, 
        METADATA_PERMISSION_WRITE,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        );

    err = mk.QueryResult();

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        if (!fUseTemplate)
        {
            //
            // No need to delete properties; everything's already
            // inherited.  Note that this is the only legit failure
            // case.  If using a template, the base class must have
            // created the path by now.
            //
            fWriteProperties = FALSE;
            err.Reset();
        }
    }

    if (fWriteProperties)
    {
        do
        {
            if (mk.IsHomeDirectoryPath())
            {
                BREAK_ON_ERR_FAILURE(err);

                //
                // Path describes an instance path, which is the only
                // time we need to do anything here
                //
                err = mk.ConvertToParentPath(TRUE);

                BREAK_ON_ERR_FAILURE(err);

                if (fUseTemplate)
                {
                    //
                    // Write values from template
                    //
                    err = mk.SetValue(
                        MD_ALLOW_ANONYMOUS, 
                        m_fAllowAnonymous
                        );

                    BREAK_ON_ERR_FAILURE(err);

                    err = mk.SetValue(
                        MD_ANONYMOUS_ONLY, 
                        m_fAnonymousOnly
                        );
                }
                else
                {
                    //
                    // Inheritance case: delete authentication
                    // values
                    //
                    mk.DeleteValue(MD_ALLOW_ANONYMOUS);
                    mk.DeleteValue(MD_ANONYMOUS_ONLY);
                }
            }
        }
        while(FALSE);
    }

    return err;
}



/* virtual */
void 
CFTPSecurityTemplate::GenerateSummary(
    IN BOOL    fUseTemplate,
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Generate text summary of what's in the security template, and is about to
    be applied to the given path.

Arguments:
    
    BOOL fUseTemplates         : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    None

--*/
{
    CString strPath;

    CMetaKey::BuildMetaPath(
        strPath, 
        lpszService, 
        dwInstance, 
        lpszParent, 
        lpszAlias
        );

    //
    // Authentication methods apply to instances only
    //
    if (CMetaKey::IsHomeDirectoryPath(strPath))
    {
        //
        // Add private summary items
        //
        AddSummaryString(IDS_AUTHENTICATION_METHODS);

        //
        // Summarize Authentication Methods:
        //
        AddSummaryString(
            m_fAllowAnonymous 
                ? IDS_AUTHENTICATION_ANONYMOUS 
                : IDS_AUTHENTICATION_NO_ANONYMOUS, 
            1
            );

        if (m_fAllowAnonymous && m_fAnonymousOnly)
        {
            AddSummaryString(IDS_AUTHENTICATION_ANONYMOUS_ONLY, 1);
        }
    }

    //
    // Add base class summary
    //
    CIISSecurityTemplate::GenerateSummary(
        fUseTemplate,
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}



CIISSecurityTemplate * 
AllocateSecurityTemplate(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Security template allocator function

Arguments:

    IN const CMetaKey * pKey    : Open key
    IN LPCTSTR lpszMDPath       : Path
    IN BOOL fInherit            : TRUE to inherit properties

Return Value:

    Pointer to newly allocated security object    

--*/
{
    return new CFTPSecurityTemplate(pKey, lpszMDPath, fInherit);
}




extern "C" HRESULT APIENTRY 
ISMSecurityWizard(
    IN HANDLE  hServer,           
    IN DWORD   dwInstance,        
    IN LPCTSTR lpszParent,        
    IN LPCTSTR lpszAlias          
    )
/*++

Routine Description:

    Launch the security wizard

Arguments:

    HANDLE  hServer         : Server handle
    DWORD   dwInstance      : Parent instance
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Child to configure or NULL

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    return COMDLL_ISMSecurityWizard(
        &AllocateSecurityTemplate,
        GetMetaKeyFromHandle(hServer),
        IDB_WIZ_LEFT_SEC, 
        IDB_WIZ_HEAD_SEC,
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}



//
// End of ISM API Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
InitializeDLL()
/*++

Routine Description:

    Perform additional DLL initialisation as necessary

Arguments:

    None

Return Value:

    None

--*/
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#ifdef UNICODE

    TRACEEOLID("Loading UNICODE fscfg.dll");

#else

    TRACEEOLID("Loading ANSI fscfg.dll");

#endif UNICODE

    ::AfxEnableControlContainer();

#ifndef _COMSTATIC

    //
    // Initialize IISUI extension DLL
    //
    InitIISUIDll();

#endif // _COMSTATIC

}

//
// Declare the one and only dll object
//
CConfigDll NEAR theApp;

CConfigDll::CConfigDll(
    IN LPCTSTR pszAppName OPTIONAL
    )
/*++

Routine Description:

    Constructor for USRDLL

Arguments:

    LPCTSTR pszAppName : Name of the app or NULL to load from resources

Return Value:

    N/A

--*/
    : CWinApp(pszAppName),
      m_lpOldHelpPath(NULL)
{
}



BOOL
CConfigDll::InitInstance()
/*++

Routine Description:

    Initialise current instance of the DLL

Arguments:

    None

Return Value:

    TRUE for successful initialisation, FALSE otherwise

--*/
{
    BOOL bInit = CWinApp::InitInstance();

    hInstance = ::AfxGetInstanceHandle();
    ASSERT(hInstance);
    InitializeDLL();

    try
    {
        //
        // Get the help path
        //
        m_lpOldHelpPath = m_pszHelpFilePath;
        ASSERT(m_pszHelpFilePath != NULL);
        CString strFile(_tcsrchr(m_pszHelpFilePath, _T('\\')));
        CRMCRegKey rk(REG_KEY, SZ_PARAMETERS, KEY_READ);
        rk.QueryValue(SZ_HELPPATH, m_strHelpPath, EXPANSION_ON);
        m_strHelpPath += strFile;
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }

    if (!m_strHelpPath.IsEmpty())
    {
        m_pszHelpFilePath = m_strHelpPath;
    }

    return bInit;
}



int
CConfigDll::ExitInstance()
/*++

Routine Description:

    Clean up current instance

Arguments:

    None

Return Value:

    The application's exit code; 0 indicates no errors, and values greater
    than 0 indicate an error.

--*/
{
    m_pszHelpFilePath = m_lpOldHelpPath;
    return CWinApp::ExitInstance();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CConfigDll, CWinApp)
    //{{AFX_MSG_MAP(CConfigDll)
    //}}AFX_MSG_MAP
    //
    // Global Help Commands
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\fmessage.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fmessage.h

   Abstract:

        FTP Message property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class CFtpMessagePage : public CInetPropertyPage
/*++

Class Description:

    FTP Messages property page

Public Interface:

    CFtpMessagePage  : Constructor
    ~CFtpMessagePage : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpMessagePage)

//
// Construction
//
public:
    CFtpMessagePage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpMessagePage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpMessagePage)
    enum { IDD = IDD_MESSAGES };
    CString m_strExitMessage;
    CString m_strMaxConMsg;
    CString m_strWelcome;
    CEdit   m_edit_Exit;
    CEdit   m_edit_MaxCon;
    //}}AFX_DATA
    HMODULE m_hInstRichEdit;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFtpMessagePage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CFtpMessagePage)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fscfg.rc
//
#define IDHELP                          9
#define IDS_RECONNECT_WARNING           90
#define IDB_FTP                         1000
#define IDS_FTP                         1000
#define IDS_CAPTION                     1001
#define IDS_PORT_CHANGE                 1002
#define IDS_CONFIRM_DISCONNECT_USER     1003
#define IDS_CONFIRM_DISCONNECT_ALL      1004
#define IDS_CAPTION_MULTIPLE            1005
#define IDS_USERS_TOTAL                 1006
#define IDS_CONNECTED_USERS             1007
#define IDS_FROM                        1008
#define IDS_TIME                        1009
#define IDS_DISCONNECT_ERR              1010
#define IDS_SERVICE_NOT_STARTED         1011
#define IDC_EDIT_DIRECTORY              1015
#define IDC_EDIT_PATH                   1015
#define IDC_BUTTON_ADD                  1016
#define IDC_EDIT_USER_NAME              1017
#define IDS_UNC_MASK                    1023
#define IDC_LIST_DIRECTORIES            1024
#define IDS_DIRECTORY_MASK              1025
#define IDS_DIR_TITLE                   1026
#define IDS_NEW_VROOT                   1046
#define IDS_BUTTON_PROPERTIES           1047
#define IDS_TAB_HOME_DIRECTORY          1049
#define IDS_TAB_VIRTUAL_DIRECTORY       1050
#define IDS_CAPTION_DEFAULT             1051
#define IDS_PATH                        1052
#define IDC_PASSWORD                    1053
#define IDS_SHARE                       1053
#define IDS_NEW_VDIR_WIZARD             1054
#define IDS_NEW_SITE_WIZARD             1055
#define IDC_STATIC_USER_NAME            1056
#define IDS_SITE_PERMS_TITLE            1056
#define IDC_STATIC_PASSWORD             1057
#define IDS_SITE_PERMS_SUBTITLE         1057
#define IDS_SITE_SECURITY_TITLE         1058
#define IDS_SITE_SECURITY_SUBTITLE      1059
#define IDS_SITE_WELCOME                1060
#define IDS_SITE_BODY                   1061
#define IDS_SITE_SUCCESS                1062
#define IDS_SITE_FAILURE                1063
#define IDS_VDIR_WELCOME                1064
#define IDS_VDIR_BODY                   1065
#define IDS_VDIR_SUCCESS                1066
#define IDS_VDIR_FAILURE                1067
#define IDC_BUTTON_EDIT                 1067
#define IDC_BUTTON_REMOVE               1068
#define IDC_LIST_IP_ADDRESSES           1069
#define IDC_BUTTON_BROWSE               1077
#define IDC_EDIT_ALIAS                  1079
#define IDC_RADIO_GRANTED               1094
#define IDC_RADIO_DENIED                1095
#define IDC_IPA_IPADDRESS               1107
#define IDC_CHECK_READ                  1118
#define IDC_CHECK_WRITE                 1119
#define IDC_STATIC_IP_GROUP             1120
#define IDC_CHECK_USE_IP                1121
#define IDC_STATIC_IP_PROMPT            1122
#define IDC_STATIC_ALIAS                1125
#define IDC_RADIO_HOME                  1136
#define IDC_RADIO_ALIAS                 1137
#define IDC_CHECK_EXECUTE               1138
#define IDC_GROUP_ACCOUNT               1139
#define IDC_GROUP_ACCESS                1140
#define IDC_CHECK_SSL                   1141
#define IDC_STATIC_EXCEPT               1145
#define IDC_ICON_GRANTED                1146
#define IDC_ICON_DENIED                 1147
#define IDS_BAD_UNC_PATH                1162
#define IDS_ILLEGAL_ALIAS_CHARS         1163
#define IDC_RADIO_UNLIMITED             1182
#define IDC_RADIO_LIMITED               1183
#define IDD_SERVICE                     2000
#define IDD_SESSIONS                    2001
#define IDD_USER_SESSIONS               2002
#define IDB_USERS                       2005
#define IDD_DIRECTORY_SECURITY          2005
#define IDB_FTPVIEW                     2006
#define IDD_MESSAGES                    2007
#define IDB_FTPDIR                      2009
#define IDD_DIRECTORY_PROPERTIES        2011
#define IDB_FTPVIEW32                   2012
#define IDB_FTPDIR32                    2013
#define IDB_NEW_VROOT                   2015
#define IDB_NEW_INSTANCE                2017
#define IDD_NEW_DIR_COMPLETION_PAGE     2019
#define IDB_WIZ_LEFT                    2019
#define IDB_WIZ_HEAD                    2020
#define IDB_WIZ_LEFT_DIR                2021
#define IDB_WIZ_HEAD_DIR                2022
#define IDB_WIZ_LEFT_SEC                2024
#define IDB_WIZ_HEAD_SEC                2025
#define IDD_USER_ACCOUNT                2029
#define IDD_NEW_INST_DESCRIPTION        2041
#define IDD_NEW_INST_BINDINGS           2042
#define IDD_NEW_INST_HOME               2043
#define IDD_NEW_DIR_ALIAS               2044
#define IDD_NEW_DIR_PATH                2045
#define IDD_NEW_DIR_PERMS               2046
#define IDD_NEW_PERMS                   2046
#define IDD_NEW_DIR_USER_PASSWORD       2047
#define IDD_NEW_USER_PASSWORD           2047
#define IDD_FTP_DIRECTORIES             3002
#define IDD_FTP_DIRECTORY_PROPERTIES    3012
#define IDD_ACCOUNTS                    3013
#define IDD_NEW_INST_PERMS              3014
#define IDD_NEW_INST_USER_PASSWORD      3015
#define IDD_NEW_INST_COMPLETION_PAGE    3016
#define IDC_EDIT_EMAIL                  3017
#define IDC_EDIT_NAME                   3027
#define IDC_EDIT_TCP_PORT               3033
#define IDC_EDIT_CONNECTION_TIMEOUT     3034
#define IDC_EDIT_MAX_CONNECTIONS        3036
#define IDC_EDIT_WELCOME                3045
#define IDC_EDIT_EXIT                   3046
#define IDC_EDIT_COMMENT                3048
#define IDC_CHECK_ALLOW_ANONYMOUS       3049
#define IDC_EDIT_USERNAME               3050
#define IDC_EDIT_PASSWORD               3051
#define IDC_CHECK_ONLY_ANYMOUS          3052
#define IDC_STATIC_USERNAME             3053
#define IDC_STATIC_PW                   3054
#define IDC_RADIO_UNIX                  3055
#define IDC_RADIO_MSDOS                 3056
#define IDC_BUTTON_CURRENT_SESSIONS     3059
#define IDC_BUTTON_REFRESH              3060
#define IDC_LIST_USERS                  3061
#define IDC_BUTTON_DISCONNECT           3062
#define IDC_BUTTON_DISCONNECT_ALL       3063
#define IDC_STATIC_USERS                3064
#define IDC_STATIC_FROM                 3065
#define IDC_STATIC_TIME                 3066
#define IDC_STATIC_NUM_CONNECTED        3067
#define IDC_BUTTON_BROWSE_USER          3069
#define IDC_BUTTON_CHECK_PASSWORD       3070
#define IDC_CHECK_ENABLE_LOGGING        3071
#define IDC_COMBO_LOG_FORMATS           3072
#define IDC_BUTTON_PROPERTIES           3073
#define IDC_CHECK_ENABLE_PW_SYNCHRONIZATION 3074
#define IDC_STATIC_PATH                 3075
#define IDC_RADIO_DIR                   3076
#define IDC_RADIO_UNC                   3077
#define IDC_STATIC_DESCRIPTION          3079
#define IDC_BUTTON_DELETE               3080
#define IDC_STATIC_IPADDRESS            3080
#define IDC_STATIC_TCP_PORT             3081
#define IDC_STATIC_ID                   3082
#define IDC_BUTTON_BROWSE_USERS         3082
#define IDC_STATIC_DIRLISTING           3084
#define IDC_STATIC_PATH_TYPE            3085
#define IDC_STATIC_OPERATOR_PROMPT1     3086
#define IDC_STATIC_OPERATOR_PROMPT2     3087
#define IDC_STATIC_ACCOUNT_PROMPT       3088
#define IDC_LIST_ADMINISTRATORS         3106
#define IDC_COMBO_IP_ADDRESS            3108
#define IDC_STATIC_CONNECTIONS          3111
#define IDC_COMBO_PATH_TYPE             3117
#define IDC_BUTTON_EDIT_PATH_TYPE       3171
#define IDC_CHECK_LOG_ACCESS            3173
#define IDC_LOGUICTRL                   3201
#define IDC_STATIC_LOG_PROMPT           3202
#define IDC_COMBO_IP_ADDRESSES          3213
#define IDC_EDIT_DESCRIPTION            3216
#define IDC_EDIT_HOME_PATH              3219
#define IDC_COMBO_WEBSITES              3817
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2026
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3091
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\logui.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "logui.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CLogUI

IMPLEMENT_DYNCREATE(CLogUI, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CLogUI properties

CString CLogUI::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CLogUI::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

COleFont CLogUI::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CLogUI::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CLogUI::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CLogUI::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CLogUI::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CLogUI::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CLogUI operations

void CLogUI::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CLogUI::ApplyLogSelection()
{
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::SetComboBox(HWND hComboBox)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         hComboBox);
}

void CLogUI::Terminate()
{
    InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\fscfg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fscfg.h

   Abstract:

        FTP Configuration Module definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//

#include <lmcons.h>
#include <lmapibuf.h>
#include <svcloc.h>

//
// Required by VC5
//
#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(x) struct
#endif // MIDL_INTERFACE
#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__ 440
#endif // __RPCNDR_H_VERSION__

#include <ftpd.h>


#include "resource.h"
#include "mmc.h"
#include "svrinfo.h"
#include "comprop.h"


extern const LPCTSTR g_cszSvc;
extern HINSTANCE hInstance;



class CConfigDll : public CWinApp
/*++

Class Description:

    USRDLL CWinApp module

Public Interface:

    CConfigDll : Constructor

    InitInstance : Perform initialization of this module
    ExitInstance : Perform termination and cleanup

--*/
{
public:
    CConfigDll(
        IN LPCTSTR pszAppName = NULL
        );

    virtual BOOL InitInstance();
    virtual int ExitInstance();

protected:
    //{{AFX_MSG(CConfigDll)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    CString m_strHelpPath;
    LPCTSTR m_lpOldHelpPath;
};


inline BOOL LoggingEnabled(
    IN DWORD dwLogType
    )
{
    return (dwLogType == MD_LOG_TYPE_ENABLED);
}

inline void EnableLogging(
    OUT DWORD & dwLogType, 
    IN  BOOL fEnabled = TRUE
    )
{
    dwLogType = fEnabled ? MD_LOG_TYPE_ENABLED : MD_LOG_TYPE_DISABLED;
}



class CFTPInstanceProps : public CInstanceProps
/*++

Class Description:

    FTP Properties

Public Interface:

    CFTPInstanceProps   : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CFTPInstanceProps(
        IN LPCTSTR lpszServerName,
        IN DWORD   dwInstance       = MASTER_INSTANCE
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Service Page
    //
    MP_CILong        m_nMaxConnections;
    MP_CILong        m_nConnectionTimeOut;
    MP_DWORD         m_dwLogType;

    //
    // Accounts Page
    //
    MP_CString       m_strUserName;
    MP_CString       m_strPassword;
    MP_BOOL          m_fAllowAnonymous;
    MP_BOOL          m_fOnlyAnonymous;
    MP_BOOL          m_fPasswordSync;
    MP_CBlob         m_acl;

    //
    // Message Page
    //
    MP_CString       m_strExitMessage;
    MP_CString       m_strMaxConMsg;
    MP_CStringListEx m_strlWelcome;

    //
    // Directory Properties Page
    //
    MP_BOOL          m_fDosDirOutput;

    //
    // Default Site page
    //
    MP_DWORD         m_dwDownlevelInstance;
};



class CFTPDirProps : public CChildNodeProps
/*++

Class Description:

    FTP Directory properties

Public Interface:

    CFTPDirProps        : Constructor

--*/
{
public:
    CFTPDirProps(
        IN LPCTSTR lpszServerName,
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent  = NULL,
        IN LPCTSTR lpszAlias   = NULL
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Directory properties page
    //
    MP_CString     m_strUserName;
    MP_CString     m_strPassword;
    MP_BOOL        m_fDontLog;
    MP_CBlob       m_ipl;
};



class CFtpSheet : public CInetPropertySheet
{
/*++

Class Description:

    Ftp Property sheet

Public Interface:

    CFtpSheet     : Constructor

    Initialize    : Initialize config data

--*/
public:
    //
    // Constructor
    //
    CFtpSheet(
        IN LPCTSTR pszCaption,
        IN LPCTSTR lpszServer,
        IN DWORD   dwInstance,
        IN LPCTSTR lpszParent,
        IN LPCTSTR lpszAlias,
        IN CWnd *  pParentWnd  = NULL,
        IN LPARAM  lParam      = 0L,
        IN LONG_PTR handle      = 0L,
        IN UINT    iSelectPage = 0
        );

    ~CFtpSheet();

public:
    HRESULT QueryInstanceResult() const;
    HRESULT QueryDirectoryResult() const;
    CFTPInstanceProps & GetInstanceProperties() { return *m_ppropInst; }
    CFTPDirProps & GetDirectoryProperties() { return *m_ppropDir; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

protected:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    // Generated message map functions
    //{{AFX_MSG(CFtpSheet)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CFTPInstanceProps * m_ppropInst;
    CFTPDirProps      * m_ppropDir;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CFtpSheet::QueryInstanceResult() const
{
    return m_ppropInst ? m_ppropInst->QueryResult() : S_OK;
}

inline HRESULT CFtpSheet::QueryDirectoryResult() const
{
    return m_ppropDir ? m_ppropDir->QueryResult() : S_OK;
}


#define FTPSCFG_DLL_NAME _T("FSCFG.DLL")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\logui.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CLogUI wrapper class

class CLogUI : public CWnd
{
protected:
    DECLARE_DYNCREATE(CLogUI)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634603, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    CString GetCaption();
    void SetCaption(LPCTSTR);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
    void ApplyLogSelection();
    void SetComboBox(HWND hComboBox);
    void Terminate();
    void DoClick();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\fservic.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fservic.h

   Abstract:

        FTP Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FSERVIC_H__
#define __FSERVIC_H__



//{{AFX_INCLUDES()
#include "logui.h"
//}}AFX_INCLUDES



class CFtpServicePage : public CInetPropertyPage
/*++

Class Description:

    FTP Service property page

Public Interface:

    CFtpServicePage  : Constructor
    ~CFtpServicePage : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpServicePage)

//
// Constructors/Destructors
//
public:
    CFtpServicePage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpServicePage();

//
// Dialog Data
//
protected:
    //
    //  Radio button IDs for unlimited radio control
    //
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CFtpServicePage)
    enum { IDD = IDD_SERVICE };
    int         m_nUnlimited;
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    BOOL        m_fEnableLogging;
    CString     m_strComment;
    CEdit       m_edit_MaxConnections;
    CStatic     m_static_LogPrompt;
    CStatic     m_static_Connections;
    CButton     m_button_LogProperties;
    CComboBox   m_combo_IpAddresses;
    CComboBox   m_combo_LogFormats;
    //}}AFX_DATA

    UINT        m_nOldTCPPort;
    BOOL        m_fUnlimitedConnections;
    DWORD       m_dwLogType;
    CILong      m_nConnectionTimeOut;
    CILong      m_nMaxConnections;
    CILong      m_nVisibleMaxConnections;
    CString     m_strDomainName;
    CIPAddress  m_iaIpAddress;
    CLogUI      m_ocx_LogProperties;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFtpServicePage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    void SetControlStates();
    void SetLogState();
    void PopulateKnownIpAddresses();
    LPCTSTR QueryMetaPath();

    // Generated message map functions
    //{{AFX_MSG(CFtpServicePage)
    afx_msg void OnCheckEnableLogging();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnButtonCurrentSessions();
    afx_msg void OnButtonProperties();
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

protected:
    CObListPlus m_oblIpAddresses;
    BOOL m_f10ConnectionLimit;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CFtpServicePage::QueryMetaPath()
{
    return ((CFtpSheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}


#endif // __FSERVIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\fservic.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fservic.cpp

   Abstract:

        FTP Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "fservic.h"
#include "usersess.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// Some sanity values on max connections
//
#define MAX_MAX_CONNECTIONS      (1999999999L)
#define INITIAL_MAX_CONNECTIONS  (      1000L)
#define UNLIMITED_CONNECTIONS    (2000000000L)

#define MAX_TIMEOUT              (0x7FFFFFFF)

#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)



IMPLEMENT_DYNCREATE(CFtpServicePage, CInetPropertyPage)



CFtpServicePage::CFtpServicePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP service property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpServicePage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CFtpServicePage)
    m_strComment = _T("");
    m_nTCPPort = 20;
    m_nUnlimited = RADIO_LIMITED;
    m_nIpAddressSel = -1;
    m_fEnableLogging = FALSE;
    //}}AFX_DATA_INIT

    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
    m_nConnectionTimeOut = 600;
    m_iaIpAddress = (LONG)0L;
    m_strDomainName = _T("");

#endif // 0
}



CFtpServicePage::~CFtpServicePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpServicePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        m_fEnableLogging = LoggingEnabled(m_dwLogType);
    }

    //{{AFX_DATA_MAP(CFtpServicePage)
    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Check(pDX, IDC_CHECK_ENABLE_LOGGING, m_fEnableLogging);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
    DDV_MinMaxChars(pDX, m_strComment, 0, MAX_PATH);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Control(pDX, IDC_STATIC_LOG_PROMPT, m_static_LogPrompt);
    DDX_Control(pDX, IDC_STATIC_CONNECTIONS, m_static_Connections);
    DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_button_LogProperties);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESS, m_combo_IpAddresses);
    DDX_Control(pDX, IDC_COMBO_LOG_FORMATS, m_combo_LogFormats);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    if (!IsMasterInstance())
    {
        DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    }

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        pDX->Fail();
    }

    //
    // Private DDX/DDV Routines
    //
    int nMin = IsMasterInstance() ? 0 : 1;

    if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
    {
        DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
    }

    if (m_f10ConnectionLimit)
    {
        //
        // Special validation for unlimited connections.  We use a bogus
        // numeric check for data validation.  Number adjustment happes 
        // later.
        //
        if (pDX->m_bSaveAndValidate && 
            (m_nVisibleMaxConnections < 0 || 
             m_nVisibleMaxConnections > UNLIMITED_CONNECTIONS))
        {
            TCHAR szMin[32];
            TCHAR szMax[32];
            wsprintf(szMin, _T("%ld"), 0);
            wsprintf(szMax, _T("%ld"), 40);
            CString prompt;
            AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
            AfxMessageBox(prompt, MB_ICONEXCLAMATION);
            prompt.Empty(); // exception prep
            pDX->Fail();
        }
    }
    else
    {
        DDV_MinMaxLong(pDX, m_nVisibleMaxConnections, 0, UNLIMITED_CONNECTIONS);
    }

    DDX_Text(pDX, IDC_EDIT_CONNECTION_TIMEOUT, m_nConnectionTimeOut);
    DDV_MinMaxLong(pDX, m_nConnectionTimeOut, nMin, MAX_TIMEOUT);

    if (pDX->m_bSaveAndValidate)
    {
        EnableLogging(m_dwLogType, m_fEnableLogging);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpServicePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpServicePage)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_LOGGING, OnCheckEnableLogging)
    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_BUTTON_CURRENT_SESSIONS, OnButtonCurrentSessions)
    ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnItemChanged)
    ON_CBN_EDITCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_LOG_FORMATS, OnItemChanged)

END_MESSAGE_MAP()



void
CFtpServicePage::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_edit_MaxConnections.m_hWnd)
    {
        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
        m_static_Connections.EnableWindow(!m_fUnlimitedConnections);
    }
}



void
CFtpServicePage::PopulateKnownIpAddresses()
/*++

Routine Description:

    Fill the combo box with known ip addresses

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        QueryServerName(),
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel 
        );
    EndWaitCursor();
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CFtpServicePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Take our direction from a phony button
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_LogProperties.Create(
        _T("LogUI"),
        WS_BORDER,
        rc,
        this,
        IDC_LOGUICTRL
        );

    //
    // Initialize the logging ocx; pass it the metabase path of the 
    // virtual server.
    //
    m_ocx_LogProperties.SetAdminTarget(GetServerName(), QueryMetaPath());
    m_ocx_LogProperties.SetComboBox(m_combo_LogFormats.m_hWnd);

    GetDlgItem(IDC_RADIO_UNLIMITED)->EnableWindow(!m_f10ConnectionLimit);

    if (IS_MASTER_INSTANCE(QueryInstance()) || !HasAdminAccess())
    {
        GetDlgItem(IDC_STATIC_IPADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_TCP_PORT)->EnableWindow(FALSE);
        m_combo_IpAddresses.EnableWindow(FALSE);
    }

    PopulateKnownIpAddresses();
    SetControlStates();
    SetLogState();

    GetDlgItem(IDC_BUTTON_CURRENT_SESSIONS)->EnableWindow(!IsMasterInstance());

    return TRUE;
}



/* virtual */
HRESULT
CFtpServicePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    m_f10ConnectionLimit = Has10ConnectionLimit();

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_nConnectionTimeOut);
        FETCH_INST_DATA_FROM_SHEET(m_iaIpAddress);
        FETCH_INST_DATA_FROM_SHEET(m_nTCPPort);
        FETCH_INST_DATA_FROM_SHEET(m_strDomainName);
        FETCH_INST_DATA_FROM_SHEET(m_strComment);
        FETCH_INST_DATA_FROM_SHEET(m_dwLogType);
        
        m_fUnlimitedConnections = m_nMaxConnections >= MAX_MAX_CONNECTIONS;
        if (m_f10ConnectionLimit)
        {
            m_fUnlimitedConnections = FALSE;
            if ((LONG)m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
            {
                m_nMaxConnections = LIMITED_CONNECTIONS_MAX;
            }
        }

        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS
            : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;

        m_nOldTCPPort = m_nTCPPort;
    END_META_INST_READ(err)

    return err;
}




HRESULT
CFtpServicePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP service page now...");

    CError err;

    m_nMaxConnections = m_fUnlimitedConnections 
        ? UNLIMITED_CONNECTIONS
        : m_nVisibleMaxConnections;

    //
    // Check to make sure we're not violating the license
    // agreement
    //
    if (m_f10ConnectionLimit)
    {
        if (m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_CONNECTION_LIMIT);
            m_nMaxConnections = LIMITED_CONNECTIONS_MIN;
        }
        else if (m_nMaxConnections >  LIMITED_CONNECTIONS_MIN
              && m_nMaxConnections <= LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_WRN_CONNECTION_LIMIT);
        }
    }

    CString strBinding;
    CStringListEx m_strlBindings;

    CInstanceProps::BuildBinding(
        strBinding, 
        m_iaIpAddress, 
        m_nTCPPort, 
        m_strDomainName
        );
    m_strlBindings.AddTail(strBinding);
    m_ocx_LogProperties.ApplyLogSelection();

    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nConnectionTimeOut);
        STORE_INST_DATA_ON_SHEET(m_dwLogType);
        STORE_INST_DATA_ON_SHEET(m_strComment);
        STORE_INST_DATA_ON_SHEET(m_strlBindings);
    END_META_INST_WRITE(err)
    EndWaitCursor();

    return err;
}



void
CFtpServicePage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0, -1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}



void
CFtpServicePage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}



void
CFtpServicePage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}



void
CFtpServicePage::SetLogState()
/*++

Routine Description:

    Set the enabled state of the logging controls depending on
    whether logging is currently enabled

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_LogPrompt.EnableWindow(m_fEnableLogging);
    m_combo_LogFormats.EnableWindow(m_fEnableLogging);
    m_button_LogProperties.EnableWindow(m_fEnableLogging);
}



void
CFtpServicePage::OnCheckEnableLogging()
/*++

Routine Description:

    'Enable logging' checkbox has been toggled.  Reset the state
    of the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableLogging = !m_fEnableLogging;
    SetLogState();
    OnItemChanged();
}



void 
CFtpServicePage::OnButtonProperties() 
/*++

Routine Description:

    Pass on "log properties" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    m_ocx_LogProperties.DoClick();
}



void
CFtpServicePage::OnButtonCurrentSessions()
/*++

Routine Description:

    'Current Sessions' button has been pressed.  Bring up the current
    sessions dialog

Arguments:

    None

Return Value:

    None

-*/
{
    CUserSessionsDlg dlg(GetServerName(), QueryInstance(), this);
    dlg.DoModal();
}



void 
CFtpServicePage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    if (m_ocx_LogProperties.m_hWnd)
    {
        m_ocx_LogProperties.Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\security.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.cpp

   Abstract:

        FTP Security Property Page 

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "accessdl.h"
#include "security.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Needed for granted/denied icons
//
#include "..\comprop\resource.h"



IMPLEMENT_DYNCREATE(CFtpSecurityPage, CInetPropertyPage)



CFtpSecurityPage::CFtpSecurityPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A

--*/
    : CInetPropertyPage(
        CFtpSecurityPage::IDD, 
        pSheet, 
        USE_DEFAULT_CAPTION, 
        TRUE                    // Enable enhanced fonts
        ),
      m_ListBoxRes(
        IDB_ACCESS,
        m_list_IpAddresses.nBitmaps
        ),
      m_oblAccessList(),
      m_list_IpAddresses(TRUE),
      m_fIpDirty(FALSE),
      m_fOldDefaultGranted(TRUE),
      m_fDefaultGranted(TRUE)   // By default, we grant access
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CFtpSecurityPage)
    m_nGrantedDenied = 0;
    //}}AFX_DATA_INIT

#endif // 0

    m_list_IpAddresses.AttachResources(&m_ListBoxRes);
}



CFtpSecurityPage::~CFtpSecurityPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // The access list will clean itself up
    //
}



void
CFtpSecurityPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFtpSecurityPage)
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_ICON_GRANTED, m_icon_Granted);
    DDX_Control(pDX, IDC_ICON_DENIED, m_icon_Denied);
    DDX_Control(pDX, IDC_RADIO_GRANTED, m_radio_Granted);
    DDX_Radio(pDX, IDC_RADIO_GRANTED, m_nGrantedDenied);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_RADIO_DENIED, m_radio_Denied);
    DDX_Control(pDX, IDC_LIST_IP_ADDRESSES, m_list_IpAddresses);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpSecurityPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpSecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_RADIO_GRANTED, OnRadioGranted)
    ON_BN_CLICKED(IDC_RADIO_DENIED, OnRadioDenied)
    ON_LBN_DBLCLK(IDC_LIST_IP_ADDRESSES, OnDblclkListIpAddresses)
    ON_LBN_ERRSPACE(IDC_LIST_IP_ADDRESSES, OnErrspaceListIpAddresses)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRESSES, OnSelchangeListIpAddresses)
    ON_WM_VKEYTOITEM()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
HRESULT
CFtpSecurityPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    m_nGrantedDenied = 0;

    //
    // Build the IPL list
    //
    CError err(BuildIplOblistFromBlob(
        ((CFtpSheet *)GetSheet())->GetDirectoryProperties().m_ipl,
        m_oblAccessList,
        m_fDefaultGranted
        ));

    err.MessageBoxOnFailure();
    m_nGrantedDenied = m_fDefaultGranted ? DEFAULT_GRANTED : DEFAULT_DENIED;
    m_fOldDefaultGranted = m_fDefaultGranted;

    return S_OK;
}



/* virtual */
HRESULT
CFtpSecurityPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP security page now...");
    
    BOOL fIplDirty = m_fIpDirty || (m_fOldDefaultGranted != m_fDefaultGranted);

    //
    // Use m_ notation because the message crackers require it.
    //
    CBlob m_ipl;

    if (fIplDirty)
    {
        BuildIplBlob(m_oblAccessList, m_fDefaultGranted, m_ipl);
    }

    CError err;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CFtpSheet)
        if (fIplDirty)
        {
            STORE_DIR_DATA_ON_SHEET(m_ipl);
        }
    END_META_DIR_WRITE(err)

    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fIpDirty = FALSE;
        m_fOldDefaultGranted = m_fDefaultGranted;
    }

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CFtpSecurityPage::OnButtonAdd() 
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        SetControlStates();
        m_fIpDirty = TRUE;
        OnItemChanged();
    }
}



void
CFtpSecurityPage::OnButtonEdit() 
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        SetControlStates();
        m_fIpDirty = TRUE;
        OnItemChanged();
    }
}



void
CFtpSecurityPage::OnButtonRemove() 
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = 0;
    int nCurSel = m_list_IpAddresses.GetCurSel();

    while (m_list_IpAddresses.GetNextSelectedItem(&nSel))
    {
        m_oblAccessList.RemoveIndex(nSel);
        m_list_IpAddresses.DeleteString(nSel);
    }

    m_fIpDirty = TRUE;
    OnItemChanged();

    if (nCurSel > 0)
    {
        --nCurSel;
    }

    m_list_IpAddresses.SetCurSel(nCurSel);

    if (!SetControlStates())
    {
        m_button_Add.SetFocus();
    }
}



BOOL
CFtpSecurityPage::SetControlStates()
/*++

Routine Description:
    
    Set the enabled status of the controls depending on the current
    state of the dialog

Arguments:

    None

Return Value:

    TRUE if at least one item is currently selected in the listbox

--*/
{
    BOOL fSomeSelection = m_list_IpAddresses.GetSelCount() > 0;

    m_button_Edit.EnableWindow(m_list_IpAddresses.GetSelCount() == 1);
    m_button_Remove.EnableWindow(m_list_IpAddresses.GetSelCount() > 0);

    return fSomeSelection;
}



void
CFtpSecurityPage::FillListBox(
    IN CIPAccessDescriptor * pSelection OPTIONAL
    )
/*++

Routine Description:

    Populate the listbox with the access list
    entries

Arguments:

    CIPAccessDescriptor * pSelection : Item to be selected or NULL.

Return Value:

    None

--*/
{
    CObListIter obli(m_oblAccessList);
    const CIPAccessDescriptor * pAccess;

    m_list_IpAddresses.SetRedraw(FALSE);
    m_list_IpAddresses.ResetContent();

    int cItems = 0 ;
    int nSel = LB_ERR, nItem;

    for ( /**/ ; pAccess = (CIPAccessDescriptor *)obli.Next(); ++cItems)
    {
        //
        // We only list those not adhering to the default
        //
        if (pAccess->HasAccess() != m_fDefaultGranted)
        {
            nItem = m_list_IpAddresses.AddItem(pAccess);

            if (pAccess == pSelection)
            {
                //
                // Found item to be selected
                //
                nSel = nItem;
            }
        }
    }

    m_list_IpAddresses.SetCurSel(nSel);
    m_list_IpAddresses.SetRedraw(TRUE);
}



DWORD
CFtpSecurityPage::SortAccessList()
/*++

Routine Description:

    Sorting the access list by grant denied and ip address
    FillListBox() should be called after this because
    the listbox will no longer reflect the true status
    of the list of directories.

Arguments:

    None

Return Value:
    
    Error return code

--*/
{
    BeginWaitCursor();
    DWORD dw =  m_oblAccessList.Sort(
        (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CIPAccessDescriptor::OrderByAddress);
    EndWaitCursor();

    return dw;
}



INT_PTR
CFtpSecurityPage::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit. Return the value returned 
    by the dialog

Arguments:

    BOOL fAdd : If TRUE, create new item.  Otherwise, edit existing item

Return Value:

    Dialog return code (IDOK/IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CIPAccessDescriptor * pAccess = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        //
        // Edit existing entry -- there better be only one...
        //
        pAccess = m_list_IpAddresses.GetSelectedItem();
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            //
            // Double click?
            //
            return IDCANCEL;
        }
    }

    CIPAccessDlg dlgAccess(
        m_fDefaultGranted, 
        pAccess, 
        &m_oblAccessList, 
        this
        );

    INT_PTR nReturn = dlgAccess.DoModal();

    if (nReturn == IDOK)
    {
        CError err;
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            try
            {
                if (fAdd)
                {
                    m_oblAccessList.AddTail(pAccess);
                }

                SortAccessList();
                FillListBox(pAccess);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;    
                e->Delete();
            }
        }

        err.MessageBoxOnFailure();
    }

    return nReturn;
}



void
CFtpSecurityPage::OnDblclkListIpAddresses()
/*++

Routine Description:

    Map listbox double click to the edit button

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CFtpSecurityPage::OnErrspaceListIpAddresses()
/*++

Routine Description:

    Handle error condition in the ip address listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFtpSecurityPage::OnSelchangeListIpAddresses()
/*++

Routine Description:

    Handle change in the selection of the listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFtpSecurityPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function
    
Arguments:

    None
    
Return Value:

    None

--*/
{
    SetModified(TRUE);
}



BOOL
CFtpSecurityPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_icon_Granted.SetIcon(::AfxGetApp()->LoadIcon(IDI_GRANTED));
    m_icon_Denied.SetIcon(::AfxGetApp()->LoadIcon(IDI_DENIED));

    m_list_IpAddresses.Initialize();

    m_list_IpAddresses.EnableWindow(HasIPAccessCheck());
    m_button_Add.EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_RADIO_GRANTED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_RADIO_DENIED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_GRANTED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_DENIED)->EnableWindow(HasIPAccessCheck());

    FillListBox();
    SetControlStates();

    return TRUE;  
}



void
CFtpSecurityPage::OnRadioGranted()
/*++

Routine Description:

    Granted by default has been selected.
    Refill the listbox with items that have
    been explicitly denied.  Although we can
    only have a deny list or a grant list,
    we keep both of them around until it comes
    time to saving the information.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fDefaultGranted)
    {
        m_fDefaultGranted = TRUE;
        FillListBox();
        OnItemChanged();
        SetControlStates();
    }
}



void
CFtpSecurityPage::OnRadioDenied()
/*++

Routine Description:

    As above, but reverse granted and denied 

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fDefaultGranted)
    {
        m_fDefaultGranted = FALSE;
        FillListBox();
        OnItemChanged();
        SetControlStates();
    }
}



int
CFtpSecurityPage::OnVKeyToItem(
    IN UINT nKey, 
    IN CListBox * pListBox, 
    IN UINT nIndex
    ) 
/*++

Routine Description:

    Map insert and delete keys for the listbox

Arguments:

    UINT nKey               : Key pressed
    CListBox * pListBox     : Listbox
    UINT nIndex             : Index selected

Return Value:

    -2 if fully handled, -1 if partially handled, 0+ if not
    handled at all    

--*/
{
    switch(nKey)
    {
    case VK_DELETE:
        OnButtonRemove();
        break;

    case VK_INSERT:
        OnButtonAdd();
        break;

    default:
        //
        // Not completely handled by this function, let
        // windows handle the remaining default action.
        //
        return -1;
    }

    //
    // No further action is neccesary.
    //
    return -2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\sources.inc ===
!include ..\..\..\..\place.inc

MAJORCOMP=internet
MINORCOMP=fscfg

TARGETNAME=fscfg
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows
SUBSYSTEM_VERSION=4.00
DLLDEF=..\fscfg.def
USE_MFCUNICODE=1
USE_MSVCRT=1
MFC_USRDLL=1

PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1

C_DEFINES=$(C_DEFINES) -D_COMIMPORT

INCLUDES=\
       ..\..\inc;\
       ..\..\..\inc;\
       $(IISBASEDIR)\inc;\
       $(IISBASEDIR)\inc\$(O);\
       ..\..\comprop;\
       ..

SOURCES=\
       ..\fscfg.cpp    \
       ..\fservic.cpp  \
       ..\facc.cpp     \
       ..\fmessage.cpp \
       ..\font.cpp     \
       ..\logui.cpp    \
       ..\wizard.cpp   \
       ..\vdir.cpp     \
       ..\security.cpp \
       ..\usersess.cpp \
       ..\fscfg.rc

TARGETLIBS=\
       $(IISBASEDIR)\svcs\infocomm\info\client\$(O)\infoadmn.lib \
       $(IISBASEDIR)\svcs\ftp\client\$(O)\ftpsapi2.lib   \
       $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib   \
       $(SDK_LIB_PATH)\netapi32.lib   \
       $(SDK_LIB_PATH)\ws2_32.lib     \
       $(SDK_LIB_PATH)\kernel32.lib   \
       $(SDK_LIB_PATH)\advapi32.lib   \
       $(SDK_LIB_PATH)\comdlg32.lib   \
       $(SDK_LIB_PATH)\comctl32.lib   \
       $(SDK_LIB_PATH)\mmc.lib        \
       $(SDK_LIB_PATH)\winspool.lib   \
       $(SDK_LIB_PATH)\shell32.lib    \
       $(SDK_LIB_PATH)\user32.lib     \
       $(SDK_LIB_PATH)\gdi32.lib      \
       $(SDK_LIB_PATH)\ole32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\vdir.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        vdir.cpp

   Abstract:

        FTP Virtual Directory Properties dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "vdir.h"
#include "dirbrows.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Directory Properties Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CFtpDirectoryPage, CInetPropertyPage)



CFtpDirectoryPage::CFtpDirectoryPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL fHome
    ) 
/*++

Routine Description:

    Constructor for directory property page

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer
    BOOL fHome                  : TRUE if this is a home directory


--*/
    : CInetPropertyPage(CFtpDirectoryPage::IDD, pSheet,
          fHome ? IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY),
      m_fHome(fHome),
      m_fOriginallyUNC(FALSE)
{
    VERIFY(m_strPathPrompt.LoadString(IDS_PATH));
    VERIFY(m_strSharePrompt.LoadString(IDS_SHARE));

#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CFtpDirectoryPage)
    m_nPathType = RADIO_DIRECTORY;
    m_nUnixDos = 0;
    m_fRead = FALSE;
    m_fWrite = FALSE;
    m_fLogAccess = FALSE;
    m_strPath = _T("");
    m_strDefaultDocument = _T("");
    m_strFooter = _T("");
    m_fBrowsingAllowed = FALSE;
    m_fEnableDefaultDocument = FALSE;
    m_fEnableFooter = FALSE;
    m_dwAccessPerms = 0;
    //}}AFX_DATA_INIT

#endif // 0

}



CFtpDirectoryPage::~CFtpDirectoryPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpDirectoryPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control Data

Arguments:

    CDataExchange * pDX : DDX/DDV struct

Return Value:

    None.

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFtpDirectoryPage)
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Control(pDX, IDC_CHECK_LOG_ACCESS, m_check_LogAccess);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);
    DDX_Control(pDX, IDC_BUTTON_EDIT_PATH_TYPE, m_button_AddPathType);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_STATIC_PATH, m_static_PathPrompt);
    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Radio(pDX, IDC_RADIO_UNIX, m_nUnixDos);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_UNC, m_radio_Unc);
    DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
    m_strPath.TrimLeft();
    DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

    if (pDX->m_bSaveAndValidate)
    {
        // Make sure a field names are correct
        //
        if (m_nPathType == RADIO_NETDIRECTORY)
        {
            DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
            m_strPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

            if (!IsUNCName(m_strPath))
            {
                ::AfxMessageBox(IDS_BAD_UNC_PATH);
                pDX->Fail();
            }

            /*

                ISSUE: Supposedly this is not necessary...


            if (m_strUserName.IsEmpty())
            {
                ::AfxMessageBox(IDS_ERR_NO_USERNAME);
                OnButtonEditPathType();
                pDX->Fail();
            }

            */
        }
        else // Local Directory
        {
            ASSERT(m_nPathType == RADIO_DIRECTORY);

            if (!IsMasterInstance())
            {
                DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
            }
            else
            {
                if (m_strPath.IsEmpty())
                {
                    //
                    // No additional validation necc. on master
                    // instance.
                    //
                    return;
                }
            }

            if (!IsFullyQualifiedPath(m_strPath) && !IsDevicePath(m_strPath))
            {
                ::AfxMessageBox(IDS_ERR_INVALID_PATH);
                pDX->Fail();
            }

            if (IsLocal())
            {
                DWORD dwAttr = GetFileAttributes(m_strPath);
                if (dwAttr == 0xffffffff || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);
                    pDX->Fail();
                }
            }
        }
    }
    else
    {
        if (!IsMasterInstance())
        {
            DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
        }
    }
}



void
CFtpDirectoryPage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        DeActivateControl(m_button_AddPathType);
		if (IsLocal() && !IsMasterInstance() && HasAdminAccess())
			ActivateControl(m_button_Browse);
		else
			DeActivateControl(m_button_Browse);
        m_static_PathPrompt.SetWindowText(m_strPathPrompt);
        break;

    case RADIO_NETDIRECTORY:
        ActivateControl(m_button_AddPathType);
        DeActivateControl(m_button_Browse);
        m_static_PathPrompt.SetWindowText(m_strSharePrompt);
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
    }
}



void
CFtpDirectoryPage::SetPathType(
    IN LPCTSTR lpstrPath
    )
/*++

Routine Description:

    Set path type from given path

Arguments:

    LPCTSTR lpstrPath       : Path string

Return Value:

    None

--*/
{
    if (::IsUNCName(lpstrPath))
    {
        m_nPathType = RADIO_NETDIRECTORY;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(1);
    }
    else
    {
        m_nPathType =  RADIO_DIRECTORY;
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }

    SetStateByType();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpDirectoryPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpDirectoryPage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_PATH_TYPE, OnButtonEditPathType)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_UNC, OnRadioUnc)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_READ, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
    ON_BN_CLICKED(IDC_RADIO_MSDOS, OnItemChanged)
    ON_BN_CLICKED(IDC_RADIO_UNIX, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CFtpDirectoryPage::OnItemChanged()
/*++

Routine Description:

    Handle change in data on the item

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}



void
CFtpDirectoryPage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(IsLocal());
    CString str;
    m_edit_Path.GetWindowText(str);

    CDirBrowseDlg dlgBrowse(this, str);
    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_Path.SetWindowText(dlgBrowse.GetFullPath(m_strPath));
        SetPathType(m_strPath);
        OnItemChanged();
    }
}



BOOL
CFtpDirectoryPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_button_Browse.EnableWindow(
        IsLocal()
     && !IsMasterInstance()
     && HasAdminAccess());

    SetPathType(m_strPath);

    //
    // Directory listing style dependent on whether or not
    // this is a home directory
    //
    ActivateControl(*GetDlgItem(IDC_STATIC_DIRLISTING), m_fHome);
    ActivateControl(*GetDlgItem(IDC_RADIO_UNIX),        m_fHome);
    ActivateControl(*GetDlgItem(IDC_RADIO_MSDOS),       m_fHome);

    //
    // Some items not available on master instance
    //
    GetDlgItem(IDC_STATIC_PATH_TYPE)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_RADIO_DIR)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_RADIO_UNC)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_STATIC_PATH)->EnableWindow(
        !IsMasterInstance());
    GetDlgItem(IDC_EDIT_PATH)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_BUTTON_EDIT_PATH_TYPE)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());

    m_check_Write.EnableWindow(HasAdminAccess());
    m_check_Read.EnableWindow(HasAdminAccess());

    //
    // Store the original value of fUNC of reference later when 
    // saving out --BoydM
    //
    m_fOriginallyUNC = (m_nPathType == RADIO_NETDIRECTORY);

    return TRUE;  
}



void
CFtpDirectoryPage::ChangeTypeTo(
    IN int nNewType
    )
/*++

Routine Description

    Change the directory type

Arguments:

    int nNewType    : New radio value

Return Value:

    None

--*/
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        //
        // No change
        //
        return;
    }

    OnItemChanged();
    SetStateByType();

    LPCTSTR lpKeepPath = NULL;

    int nID = -1;
    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        if (IsFullyQualifiedPath(m_strPath) || IsDevicePath(m_strPath))
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath = m_strPath;
        }

        nID = IDS_DIRECTORY_MASK;
        break;

    case RADIO_NETDIRECTORY:
        if (IsUNCName(m_strPath))
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath = m_strPath;
        }

        nID = IDS_UNC_MASK;
        break;
    }

    if (lpKeepPath != NULL)
    {
        //
        // Restore the old path
        //
        m_edit_Path.SetWindowText(lpKeepPath);
    }
    else
    {
        //
        // Load mask resource, and display
        // this in the directory
        //
        CString str;
        VERIFY(str.LoadString(nID));
        m_edit_Path.SetWindowText(str);
    }

    m_edit_Path.SetSel(0,-1);
    m_edit_Path.SetFocus();
}



void
CFtpDirectoryPage::OnRadioDir() 
/*++

Routine Description:

    'directory' radio button handler

Arguments:

    None

Return Value:

    None.

--*/
{
    ChangeTypeTo(RADIO_DIRECTORY);
}



void
CFtpDirectoryPage::OnRadioUnc() 
/*++

Routine Description:

    'network directory' radio button handler

Arguments:

    None

Return Value:

    None.

--*/
{
    ChangeTypeTo(RADIO_NETDIRECTORY);
}



/* virtual */
HRESULT
CFtpDirectoryPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CFtpSheet)
        //
        // Use 'm_' notation because the message crackers require it.
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strAlias);
        FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
        FETCH_DIR_DATA_FROM_SHEET(m_strPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_strPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);

        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fLogAccess = !m_fDontLog;
    END_META_DIR_READ(err)

    BEGIN_META_INST_READ(CFtpSheet)
        BOOL  m_fDosDirOutput;

        FETCH_INST_DATA_FROM_SHEET(m_fDosDirOutput);
        m_nUnixDos = m_fDosDirOutput ? RADIO_DOS : RADIO_UNIX;
    END_META_INST_READ(err)

    m_nPathType = ::IsUNCName(m_strPath) 
        ? RADIO_NETDIRECTORY
        : RADIO_DIRECTORY;

    //
    // Make sure we were passed the right home directory
    // flag
    //
    ASSERT((m_fHome && !::lstrcmp(m_strAlias, g_cszRoot))
        || (!m_fHome && ::lstrcmp(m_strAlias, g_cszRoot)));

    return err;
}



/* virtual */
HRESULT
CFtpDirectoryPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 virtual directory page now...");

    CError err;

    SET_FLAG_IF(m_fRead, m_dwAccessPerms, MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms, MD_ACCESS_WRITE);

    //
    // Use m_ notation because the message crackers require them
    //
    BOOL m_fDontLog = !m_fLogAccess;
    BOOL m_fDosDirOutput = (m_nUnixDos == RADIO_DOS);
    BOOL fUNC = (m_nPathType == RADIO_NETDIRECTORY);
//    BOOL fUserNameWritten = FALSE;

    BeginWaitCursor();
    BEGIN_META_DIR_WRITE(CFtpSheet)
        if (fUNC)      
        {
              // Fix for 380353 -- sergeia
              // When user want to change password only the above construction doesn't work
              // because flag will be false -- user name is the same and not written!
//            STORE_DIR_DATA_ON_SHEET_REMEMBER(m_strUserName, fUserNameWritten)
//            if (fUserNameWritten)
//            {
                STORE_DIR_DATA_ON_SHEET(m_strUserName);
                STORE_DIR_DATA_ON_SHEET(m_strPassword);
//            }
			  // endoffix
        }
        else
        {
            if (m_fOriginallyUNC)
            {
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_USERNAME);
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_PASSWORD);
            }
        }
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_strPath)
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        BEGIN_META_INST_WRITE(CFtpSheet)
            STORE_INST_DATA_ON_SHEET(m_fDosDirOutput);  
        END_META_INST_WRITE(err)
    }

    if (err.Succeeded())
    {
        //
        // This page can set the path, which can in theory
        // set the error state
        //
        NotifyMMC();  
    }

    EndWaitCursor();

    return err;
}



void
CFtpDirectoryPage::OnButtonEditPathType() 
/*++

Routine Description:

    'Connect As..." button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CUserAccountDlg dlg(
        QueryServerName(), 
        m_strUserName,
        m_strPassword, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.m_strUserName;
        m_strPassword = dlg.m_strPassword;
        OnItemChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\vdir.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        vdir.h

   Abstract:

        FTP Virtual Directory Properties dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __VDIR_H__
#define __VDIR_H__



class CFtpDirectoryPage : public CInetPropertyPage
/*++

Class Description:

    FTP Virtual Directory Page.

Public Interface:

    CFtpDirectoryPage    : Constructor
    ~CFtpDirectoryPage   : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpDirectoryPage)

//
// Construction
//
public:
    CFtpDirectoryPage(
        IN CInetPropertySheet * pSheet = NULL, 
        IN BOOL fHome                  = FALSE
        );

    ~CFtpDirectoryPage();

//
// Dialog Data
//
protected:
    //
    // Directory Type
    //
    enum
    {
        RADIO_DIRECTORY,
        RADIO_NETDIRECTORY,
    };

    //
    // Unix/DOS radio button values
    //
    enum
    {
        RADIO_UNIX,
        RADIO_DOS,
    };

    //{{AFX_DATA(CFtpDirectoryPage)
    enum { IDD = IDD_DIRECTORY_PROPERTIES };
    int     m_nUnixDos;
    int     m_nPathType;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fLogAccess;
    CString m_strPath;
    CStatic m_static_PathPrompt;
    CButton m_check_LogAccess;
    CButton m_check_Write;
    CButton m_check_Read;
    CButton m_button_AddPathType;
    CButton m_button_Browse;
    CButton m_radio_Dir;
    CEdit   m_edit_Path;
    //}}AFX_DATA

    BOOL    m_fOriginallyUNC;
    DWORD   m_dwAccessPerms;
    CString m_strAlias;
    CButton m_radio_Unc;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFtpDirectoryPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CFtpDirectoryPage)
    afx_msg void OnButtonBrowse();
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckWrite();
    afx_msg void OnButtonEditPathType();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioUnc();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    void SetStateByType();
    void SetPathType(LPCTSTR lpstrPath);
    void ChangeTypeTo(int nNewType);

    BOOL IsHome() const { return m_fHome; }

private:
    BOOL    m_fHome;
    CString m_strOldPath;
    CString m_strUserName;
    CString m_strPassword;
    CString m_strPathPrompt;
    CString m_strSharePrompt;
};

#endif // __VDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\security.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.h

   Abstract:

        FTP Security Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SECURITY_H__
#define __SECURITY_H__



class CFtpSecurityPage : public CInetPropertyPage
/*++

Class Description:

    FTP Security property page

Public Interface:

    CFtpSecurityPage     : Constructor
    ~CFtpSecurityPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpSecurityPage)

//
// Construction
//
public:
    CFtpSecurityPage(CInetPropertySheet * pSheet = NULL);
    ~CFtpSecurityPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpSecurityPage)
    enum { IDD = IDD_DIRECTORY_SECURITY };
    int     m_nGrantedDenied;
    CStatic m_icon_Granted;
    CStatic m_icon_Denied;
    CButton m_radio_Granted;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    //}}AFX_DATA

    CIPAccessDescriptorListBox m_list_IpAddresses;
    CButton m_radio_Denied;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFtpSecurityPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CFtpSecurityPage)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListIpAddresses();
    afx_msg void OnErrspaceListIpAddresses();
    afx_msg void OnRadioGranted();
    afx_msg void OnRadioDenied();
    afx_msg void OnSelchangeListIpAddresses();
    afx_msg int  OnVKeyToItem(UINT nKey, CListBox * pListBox, UINT nIndex);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    void    FillListBox(CIPAccessDescriptor * pSelection = NULL);
    BOOL    SetControlStates();
    DWORD   SortAccessList();

private:
    BOOL m_fDefaultGranted;
    BOOL m_fOldDefaultGranted;
    BOOL m_fIpDirty;
    CObListPlus m_oblAccessList;
    CRMCListBoxResources m_ListBoxRes;
};


#endif //__SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\usersess.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        usersess.h

   Abstract:

        FTP User Sessions Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class CFtpUserInfo : public CObjectPlus
/*++

Class Description:

    Connected FTP User object

Public Interface:

    CFtpUserInfo     : Constructor

    QueryUserID      : Get the user's ID code
    QueryAnonymous   : Return TRUE if the user logged on anonymously
    QueryHostAddress : Get the user's IP Address
    QueryConnectTime : Get the user's connect time
    QueryUserName    : Get the user's name
    OrderByName      : Sort helper
    OrderByTime      : Sort helper
    OrderByMachine   : Sort helper

--*/
{
//
// Construction
//
public:
    CFtpUserInfo(
        IN LPIIS_USER_INFO_1 lpUserInfo
        );

//
// Access Functions
//
public:
    DWORD QueryUserID() const { return m_idUser; }
    BOOL QueryAnonymous() const { return m_fAnonymous; }
    CIPAddress QueryHostAddress() const { return m_iaHost; }
    DWORD QueryConnectTime() const { return m_tConnect; }
    LPCTSTR QueryUserName() const { return m_strUser; }

//
// Sorting Helper Functions
//
public:
    int OrderByName(
        IN const CObjectPlus * pobFtpUser
        ) const;

    int OrderByTime(
        IN const CObjectPlus * pobFtpUser
        ) const;

    int OrderByHostAddress(
        IN const CObjectPlus * pobFtpUser
        ) const;

//
// Private Data
//
private:
    BOOL    m_fAnonymous;
    DWORD   m_idUser;
    DWORD   m_tConnect;
    CString m_strUser;
    CIPAddress m_iaHost;
};



class CFtpUsersListBox : public CHeaderListBox
{
/*++

Class Description:

    Listbox of CFtpUserInfo objects

Public Interface:

    CFtpUsersListBox : Constructor

    GetItem          : Get FtpUserInfo object
    AddItem          : Add FtpUserInfo object
    Initialize       : Initialize the listbox

--*/
    DECLARE_DYNAMIC(CFtpUsersListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;  

//
// Constructor/Destructor
//
public:
    CFtpUsersListBox();

//
// Access
//
public:
    CFtpUserInfo * GetItem(
        IN UINT nIndex
        );

    int AddItem(
        IN const CFtpUserInfo * pItem
        );

    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & ds
        );

protected:
    CString m_strTimeSep;
};



class CUserSessionsDlg : public CDialog
{
/*++

Class Description:

    FTP User sessions dialog

Public Interface:

    CUserSessionsDlg : Constructor

--*/
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CUserSessionsDlg(
        IN LPCTSTR lpServerName,
        IN DWORD dwInstance,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CUserSessionsDlg)
    enum { IDD = IDD_USER_SESSIONS };
    CStatic m_static_Total;
    CButton m_button_DisconnectAll;
    CButton m_button_Disconnect;
    //}}AFX_DATA

    CFtpUsersListBox m_list_Users;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CUserSessionsDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CUserSessionsDlg)
    afx_msg void OnButtonDisconnect();
    afx_msg void OnButtonDisconnectAll();
    afx_msg void OnButtonRefresh();
    afx_msg void OnSelchangeListUsers();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnHeaderItemClick(UINT nID, NMHDR *pNMHDR, LRESULT *lResult);

    DECLARE_MESSAGE_MAP()

    int QuerySortColumn() const { return m_nSortColumn; }

    DWORD SortUsersList();
    HRESULT RefreshUsersList();

    HRESULT DisconnectUser(
        IN CFtpUserInfo * pUserInfo
        );

    HRESULT BuildUserList();

    CFtpUserInfo * GetSelectedListItem(
        OUT int * pnSel = NULL
        );

    CFtpUserInfo * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    void FillListBox(
        IN CFtpUserInfo * pSelection = NULL
        );

    void SetControlStates();
    void UpdateTotalCount();

private:
    int m_nSortColumn;
    DWORD m_dwInstance;
    CString m_strServerName;
    CString m_strTotalConnected;
    CObListPlus m_oblFtpUsers;
    CRMCListBoxResources m_ListBoxRes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CFtpUserInfo * CFtpUsersListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CFtpUserInfo *)GetItemDataPtr(nIndex);
}

inline int CFtpUsersListBox::AddItem(
    IN const CFtpUserInfo * pItem
    )
{
    return AddString((LPCTSTR)pItem);
}

inline CFtpUserInfo * CUserSessionsDlg::GetSelectedListItem(
    OUT int * pnSel
    )
{
    return (CFtpUserInfo *)m_list_Users.GetSelectedListItem(pnSel);
}

inline CFtpUserInfo * CUserSessionsDlg::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CFtpUserInfo *)m_list_Users.GetNextSelectedItem(pnStartingIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\wizard.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.cpp

   Abstract:

        FTP Wizards pages 

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "dirbrows.h"
#include "wizard.h"



#define DEF_PORT        (21)
#define MAX_ALIAS_NAME (240)        // Ref Bug 241148



CIISFtpWizSettings::CIISFtpWizSettings(
    IN HANDLE  hServer,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,      OPTIONAL
    IN LPCTSTR lpszParent       OPTIONAL
    )
/*++

Routine Description:

    FTP Wizard Constructor

Arguments:

    HANDLE  hServer      : Server handle
    LPCTSTR lpszService  : Service name
    DWORD   dwInstance   : Instance number
    LPCTSTR lpszParent   : Parent path

Return Value:

    N/A

--*/
    : m_hrResult(S_OK),
      m_pKey(NULL),
      m_fLocal(FALSE),
      m_fUNC(FALSE),
      m_fRead(FALSE),
      m_fWrite(FALSE),
      m_strServerName(),
      m_strService(),
      m_strParent(),
      m_dwInstance(dwInstance)
{
    m_pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    m_strServerName = lpszServer;
    m_fLocal = IsServerLocal(m_strServerName);

    if (lpszService)
    {
        m_strService = lpszService;
    }

    if (lpszParent)
    {
        m_strParent = lpszParent;
    }
}


//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPDescription, CIISWizardPage)



CVDWPDescription::CVDWPDescription(
    IN OUT CIISFtpWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPDescription::IDD,          // Template
        IDS_NEW_SITE_WIZARD,            // Caption
        HEADER_PAGE
        ),
      m_pwsSettings(pwsSettings)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CVDWPDescription)
    m_strDescription = _T("");
    //}}AFX_DATA_INIT

#endif // 0
}




CVDWPDescription::~CVDWPDescription()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CVDWPDescription::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPDescription)
    DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
    //}}AFX_DATA_MAP
}



void
CVDWPDescription::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Description.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



LRESULT
CVDWPDescription::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_Description, 
        m_pwsSettings->m_strDescription, 
        1, 
        MAX_PATH
        ))
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPDescription, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPDescription)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPDescription::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void
CVDWPDescription::OnChangeEditDescription() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPBindings, CIISWizardPage)



CVDWPBindings::CVDWPBindings(
    IN OUT CIISFtpWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPBindings::IDD,  // Template
        IDS_NEW_SITE_WIZARD, // Page Caption
        HEADER_PAGE          // Header page
        ),
      m_pwsSettings(pwsSettings),
      m_iaIpAddress(),
      m_oblIpAddresses()
{
    //{{AFX_DATA_INIT(CVDWPBindings)
    m_nTCPPort = DEF_PORT;
    m_nIpAddressSel = -1;
    //}}AFX_DATA_INIT
}



CVDWPBindings::~CVDWPBindings()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CVDWPBindings::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CVDWPBindings)
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    //}}AFX_DATA_MAP

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate)
    {
        if (!FetchIpAddressFromCombo(
            m_combo_IpAddresses,
            m_oblIpAddresses,
            m_iaIpAddress
            ))
        {
            pDX->Fail();
        }

        CString strDomain;
        CInstanceProps::BuildBinding(
            m_pwsSettings->m_strBinding, 
            m_iaIpAddress, 
            m_nTCPPort, 
            strDomain
            );
    }
}



void
CVDWPBindings::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPBindings, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPBindings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPBindings::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_pwsSettings->m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();
    
    return TRUE;
}



BOOL
CVDWPBindings::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPAlias, CIISWizardPage)



CVDWPAlias::CVDWPAlias(
    IN OUT CIISFtpWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPAlias::IDD,        // Template
        IDS_NEW_VDIR_WIZARD,    // Caption
        HEADER_PAGE
        ),
      m_pwsSettings(pwsSettings)
      //m_strAlias()
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CVDWPAlias)
    m_strAlias = _T("");
    //}}AFX_DATA_INIT

#endif // 0
}



CVDWPAlias::~CVDWPAlias()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CVDWPAlias::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPAlias)
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_Alias);
    //}}AFX_DATA_MAP
}



LRESULT
CVDWPAlias::OnWizardNext() 
/*++

Routine Description:

    prevent the / and \ characters from being in the alias name

Arguments:

    None

Return Value:

    None

--*/
{
    if (!ValidateString(
        m_edit_Alias, 
        m_pwsSettings->m_strAlias, 
        1, 
        MAX_ALIAS_NAME
        ))
    {
        return -1;
    }

    //
    // Find the illegal characters. If they exist tell 
    // the user and don't go on.
    //
    if (m_pwsSettings->m_strAlias.FindOneOf(_T("/\\?*")) >= 0)
    {
        AfxMessageBox(IDS_ILLEGAL_ALIAS_CHARS);
        m_edit_Alias.SetFocus();
        m_edit_Alias.SetSel(0, -1);

        //
        // prevent the wizard page from changing
        //
        return -1;
    }

    //
    // Allow the wizard to continue
    //
    return CIISWizardPage::OnWizardNext();
}



void
CVDWPAlias::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Alias.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPAlias, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPAlias)
    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnChangeEditAlias)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPAlias::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void
CVDWPAlias::OnChangeEditAlias() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPPath, CIISWizardPage)



CVDWPPath::CVDWPPath(
    IN OUT CIISFtpWizSettings * pwsSettings,
    IN BOOL bVDir 
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is for a vdir,
                                  FALSE if this is an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        (bVDir ? IDD_NEW_DIR_PATH : IDD_NEW_INST_HOME),         // Template
        (bVDir ? IDS_NEW_VDIR_WIZARD : IDS_NEW_SITE_WIZARD),    // Caption
        HEADER_PAGE                                             // Header page
        ),
      m_pwsSettings(pwsSettings)
{

#if 0 // Keep ClassWizard happy

    //{{AFX_DATA_INIT(CVDWPPath)
    m_strPath = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



CVDWPPath::~CVDWPPath()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CVDWPPath::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPPath)
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_PATH, m_pwsSettings->m_strPath);
    DDV_MaxChars(pDX, m_pwsSettings->m_strPath, MAX_PATH);
}



void 
CVDWPPath::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Path.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPPath, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPPath)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnChangeEditPath)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CVDWPPath::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



LRESULT
CVDWPPath::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(m_edit_Path, m_pwsSettings->m_strPath, 1, MAX_PATH))
    {
        return -1;
    }

    m_pwsSettings->m_fUNC = IsUNCName(m_pwsSettings->m_strPath);

    if (!m_pwsSettings->m_fUNC)
    {
        if (!IsFullyQualifiedPath(m_pwsSettings->m_strPath)
         && !IsDevicePath(m_pwsSettings->m_strPath)
           )
        {
            m_edit_Path.SetSel(0,-1);
            m_edit_Path.SetFocus();
            ::AfxMessageBox(IDS_ERR_BAD_PATH);

            return -1;
        }

        if (m_pwsSettings->m_fLocal)
        {
            DWORD dwAttr = GetFileAttributes(m_pwsSettings->m_strPath);
            if (dwAttr == 0xffffffff || 
               (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                m_edit_Path.SetSel(0,-1);
                m_edit_Path.SetFocus();
                ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);

                return -1;
            }
        }
    }

    return CIISWizardPage::OnWizardNext();
}



void
CVDWPPath::OnChangeEditPath() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CVDWPPath::OnButtonBrowse() 
/*++

Routine Description:

    Handle 'browsing' for directory path -- local system only

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_pwsSettings->m_fLocal);

    CString str;
    m_edit_Path.GetWindowText(str);

    CDirBrowseDlg dlgBrowse(this, str);
    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_Path.SetWindowText(
            dlgBrowse.GetFullPath(m_pwsSettings->m_strPath)
            );
        SetControlStates();
    }
}



BOOL
CVDWPPath::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    m_button_Browse.EnableWindow(m_pwsSettings->m_fLocal);
    
    return TRUE;  
}



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPUserName, CIISWizardPage)



CVDWPUserName::CVDWPUserName(
    IN OUT CIISFtpWizSettings * pwsSettings,    
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is for a vdir,
                                  FALSE if this is an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPUserName::IDD,                                         // Templ.
        (bVDir ? IDS_NEW_VDIR_WIZARD : IDS_NEW_SITE_WIZARD),        // Caption
        HEADER_PAGE,                                                // Header
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_SECURITY_TITLE),    // Title
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_SECURITY_SUBTITLE)  // Subtitle
        ),
      m_pwsSettings(pwsSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CVDWPUserName)
    //}}AFX_DATA_INIT

#endif // 0
}



CVDWPUserName::~CVDWPUserName()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CVDWPUserName::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPUserName)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_pwsSettings->m_strUserName);
    DDV_MaxChars(pDX, m_pwsSettings->m_strUserName, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pwsSettings->m_strUserName.TrimLeft();
    while (*m_pwsSettings->m_strUserName == '\\')
    {
        m_pwsSettings->m_strUserName = m_pwsSettings->m_strUserName.Mid(2);
    }

    DDX_Password(pDX, IDC_EDIT_PASSWORD, m_pwsSettings->m_strPassword, g_lpszDummyPassword);
    DDV_MaxChars(pDX, m_pwsSettings->m_strPassword, PWLEN);
}



void 
CVDWPUserName::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_UserName.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPUserName, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPUserName)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPUserName::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    if (!m_pwsSettings->m_fUNC)
    {
        return 0;
    }

    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



BOOL
CVDWPUserName::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    return TRUE;  
}



LRESULT
CVDWPUserName::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_UserName, 
        m_pwsSettings->m_strUserName, 
        1, 
        UNLEN
        ))
    {
        return -1;
    }
    
    return CIISWizardPage::OnWizardNext();
}



void
CVDWPUserName::OnButtonBrowseUsers() 
/*++

Routine Description:

    'browse' for users handler

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_pwsSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}



void
CVDWPUserName::OnChangeEditUsername() 
/*++

Routine Description:

    'edit change' in user name notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_edit_Password.SetWindowText(_T(""));
    SetControlStates();
}



void 
CVDWPUserName::OnButtonCheckPassword() 
/*++

Routine Description:

    'Check Password' has been pressed.  Try to validate
    the password that has been entered

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(VerifyUserPassword(
        m_pwsSettings->m_strUserName, 
        m_pwsSettings->m_strPassword
        ));

    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}


//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPPermissions, CIISWizardPage)



CVDWPPermissions::CVDWPPermissions(
    IN OUT CIISFtpWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is a vdir page, 
                                  FALSE if this is an instance page

Return Value:

    None

--*/
    : CIISWizardPage(
        IDD_NEW_PERMS,                                              // Templ.
        (bVDir ? IDS_NEW_VDIR_WIZARD : IDS_NEW_SITE_WIZARD),        // Caption
        HEADER_PAGE,                                                // Header
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_PERMS_TITLE),       // Title
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_PERMS_SUBTITLE)     // Subtitle
        ),
      m_bVDir(bVDir),
      m_pwsSettings(pwsSettings)
{
    //{{AFX_DATA_INIT(CVDWPPermissions)
    //}}AFX_DATA_INIT

    m_pwsSettings->m_fRead  = TRUE;
    m_pwsSettings->m_fWrite = FALSE;
}



CVDWPPermissions::~CVDWPPermissions()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



void
CVDWPPermissions::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPPermissions)
    //}}AFX_DATA_MAP

    DDX_Check(pDX, IDC_CHECK_READ,  m_pwsSettings->m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_pwsSettings->m_fWrite);
}



void
CVDWPPermissions::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPPermissions, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPPermissions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CVDWPPermissions::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT
CVDWPPermissions::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Complete the wizard

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    ASSERT(m_pwsSettings != NULL);

    CWaitCursor wait;

    //
    // Build permissions DWORD
    //
    DWORD dwPermissions = 0L;

    SET_FLAG_IF(m_pwsSettings->m_fRead, dwPermissions, MD_ACCESS_READ);
    SET_FLAG_IF(m_pwsSettings->m_fWrite, dwPermissions, MD_ACCESS_WRITE);

    if (m_bVDir)
    {
        //
        // First see if by any chance this name already exists
        //
        ISMCHILDINFO ii;
        ii.dwSize = sizeof(ii);

        CError err;

        //
        // Reconnect if necessary.
        //
        BEGIN_ASSURE_BINDING_SECTION
            err = ::ISMQueryChildInfo(
                m_pwsSettings->m_pKey,
                WITHOUT_INHERITANCE,
                &ii,
                m_pwsSettings->m_dwInstance,    
                m_pwsSettings->m_strParent,     
                m_pwsSettings->m_strAlias
                );
        END_ASSURE_BINDING_SECTION(err, m_pwsSettings->m_pKey, ERROR_CANCELLED);

        if (err.Succeeded())
        {
            BOOL fNotUnique = TRUE;

            //
            // If the item existed without a VrPath, we'll just blow it
            // away, as a vdir takes presedence over a directory/file.
            //
            if (!*ii.szPath)
            {
                ASSERT(FALSE && "Not possible in FTP!");

                err = ::ISMDeleteChild(
                    m_pwsSettings->m_pKey,
                    m_pwsSettings->m_dwInstance,    
                    m_pwsSettings->m_strParent,     
                    m_pwsSettings->m_strAlias
                    );

                if (err.Succeeded())
                {
                    //
                    // Successfully deleted -- continue as normal.
                    //
                    fNotUnique = FALSE;
                }
            }

            //
            // This one already exists and exists as a virtual
            // directory, so away with it.
            //
            if (fNotUnique)
            {
                ::AfxMessageBox(IDS_ERR_ALIAS_NOT_UNIQUE);
                return IDD_NEW_DIR_ALIAS;
            }
        }

        //
        // Create new vdir
        //
        BEGIN_ASSURE_BINDING_SECTION
            err = CChildNodeProps::Add(
                m_pwsSettings->m_pKey,
                m_pwsSettings->m_strService,    // Service name
                m_pwsSettings->m_dwInstance,    // Instance
                m_pwsSettings->m_strParent,     // Parent path
                m_pwsSettings->m_strAlias,      // Desired alias name
                m_pwsSettings->m_strAlias,      // Name returned here (may differ)
                &dwPermissions,                 // Permissions
                NULL,                           // dir browsing N/A
                m_pwsSettings->m_strPath,       // Physical path of this directory
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strUserName : NULL),
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strPassword : NULL),
                TRUE                            // Name must be unique
                );
        END_ASSURE_BINDING_SECTION(err, m_pwsSettings->m_pKey, ERROR_CANCELLED);

        m_pwsSettings->m_hrResult = err;
    }
    else
    {
        //
        // Create new instance
        //
        CError err;

        BEGIN_ASSURE_BINDING_SECTION
            err = CInstanceProps::Add(
                m_pwsSettings->m_pKey,
                m_pwsSettings->m_strService,    // Service name
                m_pwsSettings->m_strPath,       // Physical path of this directory
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strUserName : NULL),
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strPassword : NULL),
                m_pwsSettings->m_strDescription,
                m_pwsSettings->m_strBinding,
                NULL,                           // No secure bindings on FTP
                &dwPermissions,
                NULL,                           // dir browsing N/A
                NULL,                           // Auth flags
                &m_pwsSettings->m_dwInstance
                );
        END_ASSURE_BINDING_SECTION(err, m_pwsSettings->m_pKey, ERROR_CANCELLED);

        m_pwsSettings->m_hrResult = err;
    }
    
    return CIISWizardPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\wizard.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.h

   Abstract:

        WWW Wizards pages definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FTP_WIZ_H__
#define __FTP_WIZ_H__



class CIISFtpWizSettings : public CObjectPlus
/*++

Class Description:

    FTP Wizard settings intended to pass along from page
    to page

--*/
{
//
// Constructor/Destructor
//
public:
    CIISFtpWizSettings(
        IN HANDLE  hServer,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent   = NULL
        );

//
// Public Properties
//
public:
    BOOL    m_fLocal;
    BOOL    m_fUNC;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    DWORD   m_dwInstance;
    CString m_strService;
    CString m_strParent;
    CString m_strServerName;
    CString m_strDescription;
    CString m_strBinding;
    CString m_strAlias;
    CString m_strPath;
    CString m_strUserName;
    CString m_strPassword;
    HRESULT m_hrResult;
    CMetaKey * m_pKey;
};


//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CVDWPDescription : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPDescription)

//
// Construction
//
public:
    CVDWPDescription(CIISFtpWizSettings * pwsSettings = NULL);
    ~CVDWPDescription();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPDescription)
    enum { IDD = IDD_NEW_INST_DESCRIPTION };
    CEdit   m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPDescription)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPDescription)
    afx_msg void OnChangeEditDescription();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISFtpWizSettings * m_pwsSettings;
};



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPBindings : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPBindings)

//
// Construction
//
public:
    CVDWPBindings(CIISFtpWizSettings * pwsSettings = NULL);
    ~CVDWPBindings();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPBindings)
    enum { IDD = IDD_NEW_INST_BINDINGS };
    int        m_nIpAddressSel;
    UINT       m_nTCPPort;
    CComboBox  m_combo_IpAddresses;
    //}}AFX_DATA

    CIPAddress  m_iaIpAddress;
    CObListPlus m_oblIpAddresses;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPBindings)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPBindings)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISFtpWizSettings * m_pwsSettings;
};



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPAlias : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPAlias)

//
// Construction
//
public:
    CVDWPAlias(CIISFtpWizSettings * pwsSettings = NULL);
    ~CVDWPAlias();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPAlias)
    enum { IDD = IDD_NEW_DIR_ALIAS };
    CEdit   m_edit_Alias;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPAlias)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPAlias)
    afx_msg void OnChangeEditAlias();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();


private:
    CIISFtpWizSettings * m_pwsSettings;
};



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPPath : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPPath)

//
// Construction
//
public:
    CVDWPPath(
        IN CIISFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );
    ~CVDWPPath();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPPath)
    enum { IDD = -1 };
    CEdit   m_edit_Path;
    CButton m_button_Browse;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPPath)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPPath)
    afx_msg void OnChangeEditPath();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISFtpWizSettings * m_pwsSettings;
};



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPUserName : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPUserName)

//
// Construction
//
public:
    CVDWPUserName(
        IN CIISFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CVDWPUserName();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPUserName)
    enum { IDD = IDD_NEW_USER_PASSWORD };
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPUserName)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPUserName)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnButtonCheckPassword();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISFtpWizSettings * m_pwsSettings;
};



//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPPermissions : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPPermissions)

//
// Construction
//
public:
    CVDWPPermissions(
        IN CIISFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CVDWPPermissions();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPPermissions)
    enum { IDD = IDD_NEW_PERMS };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPPermissions)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPPermissions)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISFtpWizSettings * m_pwsSettings;
    BOOL m_bVDir;
};

#endif // __FTP_WIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\usersess.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        usersess.cpp

   Abstract:

        FTP User Sessions Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "usersess.h"

#include <lmerr.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("User Sessions");

//
// User Sessions Listbox Column Definitions
//
static const ODL_COLUMN_DEF_EX BASED_CODE g_aColumns[] =
{
// ==================================================================================================
// Weight      Label          Sort Helper Function
// ==================================================================================================
    { 2, IDS_CONNECTED_USERS, (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByName        },
    { 1, IDS_FROM,            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByHostAddress },
    { 1, IDS_TIME,            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByTime        },
};


#define NUM_COLUMNS (sizeof(g_aColumns) / sizeof(g_aColumns[0]))



CFtpUserInfo::CFtpUserInfo(
    IN LPIIS_USER_INFO_1 lpUserInfo
    )
/*++

Routine Description:

    Constructor

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    N/A

--*/
    : m_idUser(lpUserInfo->idUser),
      m_strUser(lpUserInfo->pszUser),
      m_fAnonymous(lpUserInfo->fAnonymous),
      //                    Network Byte Order
      //                              ||
      //                              \/
      m_iaHost(lpUserInfo->inetHost, TRUE),
      m_tConnect(lpUserInfo->tConnect)
{
}



int
CFtpUserInfo::OrderByName(
    IN const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by user name.  The CObjectPlus pointer 
    really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return ::lstrcmpi(QueryUserName(), pob->QueryUserName());
}



int
CFtpUserInfo::OrderByTime(
    IN const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by user connect time.  The CObjectPlus 
    pointer really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return QueryConnectTime() > pob->QueryConnectTime()
        ? +1
        : QueryConnectTime() == pob->QueryConnectTime()
            ? 0
            : -1;
}



int
CFtpUserInfo::OrderByHostAddress(
    IN const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by host address.  The CObjectPlus 
    pointer really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return QueryHostAddress().CompareItem(pob->QueryHostAddress());
}



IMPLEMENT_DYNAMIC(CFtpUsersListBox, CHeaderListBox);



//
// User listbox bitmaps
//
enum
{
    BMP_USER = 0,
    BMP_ANONYMOUS,

    //
    // Don't move this one
    //
    BMP_TOTAL
};

const int CFtpUsersListBox::nBitmaps = BMP_TOTAL;



CFtpUsersListBox::CFtpUsersListBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_strTimeSep(_T(":")),
      CHeaderListBox(HLS_DEFAULT, g_szRegKey)
{
    //
    // Get intl time seperator
    //
    VERIFY(::GetLocaleInfo(
        ::GetUserDefaultLCID(), 
        LOCALE_STIME, 
        m_strTimeSep.GetBuffer(10), 
        10
        ));
}



void
CFtpUsersListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item.  This is called from the CRMCListBox base class

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure

Return Value:

    None

--*/
{
    CFtpUserInfo * pFTPUser = (CFtpUserInfo *)ds.m_ItemData;
    ASSERT(pFTPUser != NULL);

    //
    // Display a user bitmap
    //
    DrawBitmap(ds, 0, pFTPUser->QueryAnonymous() ? BMP_ANONYMOUS : BMP_USER);
    ColumnText(ds, 0, TRUE, pFTPUser->QueryUserName());
    ColumnText(ds, 1, FALSE, pFTPUser->QueryHostAddress());

    DWORD dwTime = pFTPUser->QueryConnectTime();
    DWORD dwHours = dwTime / (60L * 60L);
    DWORD dwMinutes = (dwTime / 60L) % 60L;
    DWORD dwSeconds = dwTime % 60L;

    CString strTime;

    strTime.Format(
        _T("%d%s%02d%s%02d"),
        dwHours, (LPCTSTR)m_strTimeSep,
        dwMinutes, (LPCTSTR)m_strTimeSep,
        dwSeconds);

    ColumnText(ds, 2, FALSE, strTime);
}



/* virtual */
BOOL 
CFtpUsersListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay 
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    for (int nCol = 0; nCol < NUM_COLUMNS; ++nCol)
    {
        InsertColumn(
            nCol, 
            g_aColumns[nCol].cd.nWeight, 
            g_aColumns[nCol].cd.nLabelID
            );
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
    if (!SetWidthsFromReg())
    {
        DistributeColumns();
    }

    return TRUE;
}



CUserSessionsDlg::CUserSessionsDlg(
    IN LPCTSTR lpstrServerName,
    IN DWORD dwInstance,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for FTP user sessions dialog

Arguments:

    LPCTSTR lpstrServerName : Server name to connect to
    CWnd * pParent          : Pointer to parent window

Return Value:

    N/A

--*/
    : m_list_Users(),
      m_ListBoxRes(
        IDB_USERS,
        m_list_Users.nBitmaps
        ),
      m_oblFtpUsers(),
      m_strServerName(lpstrServerName),
      m_nSortColumn(0),
      m_dwInstance(dwInstance),
      CDialog(CUserSessionsDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CUserSessionsDlg)
    //}}AFX_DATA_INIT

    m_list_Users.AttachResources(&m_ListBoxRes);
    VERIFY(m_strTotalConnected.LoadString(IDS_USERS_TOTAL));
}



void 
CUserSessionsDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserSessionsDlg)
    DDX_Control(pDX, IDC_STATIC_NUM_CONNECTED, m_static_Total);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT_ALL, m_button_DisconnectAll);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT, m_button_Disconnect);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_USERS, m_list_Users);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CUserSessionsDlg, CDialog)
    //{{AFX_MSG_MAP(CUserSessionsDlg)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT, OnButtonDisconnect)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT_ALL, OnButtonDisconnectAll)
    ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
    ON_LBN_SELCHANGE(IDC_LIST_USERS, OnSelchangeListUsers)
    //}}AFX_MSG_MAP

    ON_NOTIFY_RANGE(HDN_ITEMCLICK, 0, 0xFFFF, OnHeaderItemClick)

END_MESSAGE_MAP()



DWORD
CUserSessionsDlg::SortUsersList()
/*++

Routine Description:

    Sort the list of ftp users on the current sorting key

Arguments:

    None

Return Value:

    ERROR return code

--*/
{
    ASSERT(m_nSortColumn >= 0 && m_nSortColumn < NUM_COLUMNS);

    BeginWaitCursor();              
    DWORD err = m_oblFtpUsers.Sort(
        (CObjectPlus::PCOBJPLUS_ORDER_FUNC)g_aColumns[m_nSortColumn].pSortFn);
    EndWaitCursor();

    return err;
}



HRESULT
CUserSessionsDlg::BuildUserList()
/*++

Routine Description:

    Call the FtpEnum api and build the list of currently connected users.

Arguments:

    None

Return Value:

    ERROR return code

--*/
{
    CError err;
    LPIIS_USER_INFO_1 lpUserInfo = NULL;
    DWORD dwCount = 0L;

    m_oblFtpUsers.RemoveAll();

    BeginWaitCursor();
    err = ::IISEnumerateUsers(TWSTRREF((LPCTSTR)m_strServerName),
        1,
        INET_FTP_SVC_ID,
        m_dwInstance,
        &dwCount,
        (LPBYTE *)&lpUserInfo
        );
    EndWaitCursor();

    TRACEEOLID("IISEnumerateUsers returned " << err);

    if (err.Failed())
    {
        return err;
    }

    try
    {
        for (DWORD i = 0; i < dwCount; ++i)
        {
            m_oblFtpUsers.AddTail(new CFtpUserInfo(lpUserInfo++));
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    SortUsersList();

    //
    // Free up the data allocated by IISEnumerateUsers
    //
     
    if( lpUserInfo )
    {
        for( DWORD i = 0; i < dwCount; ++i )
        {
            if( lpUserInfo[i].pszUser )
            {
                MIDL_user_free( lpUserInfo[i].pszUser );
            }
        }

        MIDL_user_free( lpUserInfo );
    }

    return err;
}



HRESULT
CUserSessionsDlg::DisconnectUser(
    IN CFtpUserInfo * pUserInfo
    )
/*++

Routine Description:

    Disconnect a single user

Arguments:

    CFtpUserInfo * pUserInfo : User to disconnect

Return Value:

    ERROR return code

--*/
{
    CError err(::IISDisconnectUser(TWSTRREF((LPCTSTR)m_strServerName),
        INET_FTP_SVC_ID, 
        m_dwInstance, 
        pUserInfo->QueryUserID()
        ));

    if (err.Win32Error() == NERR_UserNotFound)
    {
        //
        // As long as he's gone now, that's alright
        //
        err.Reset();
    }

    return err;
}



void 
CUserSessionsDlg::UpdateTotalCount()
/*++

Routine Description:

    Update the count of total users

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;
    str.Format(m_strTotalConnected, m_oblFtpUsers.GetCount() );

    m_static_Total.SetWindowText(str);     
}



void
CUserSessionsDlg::FillListBox(
    IN CFtpUserInfo * pSelection OPTIONAL
    )
/*++

Routine Description:

    Show the users in the listbox

Arguments:

    CFtpUserInfo * pSelection : Item to be selected or NULL

Return Value:

    None

--*/
{
    CObListIter obli(m_oblFtpUsers);
    const CFtpUserInfo * pUserEntry = NULL;

    m_list_Users.SetRedraw(FALSE);
    m_list_Users.ResetContent();
    int cItems = 0;

    for ( /**/ ; pUserEntry = (CFtpUserInfo *)obli.Next(); ++cItems)
    {
        m_list_Users.AddItem(pUserEntry);
    }

    if (pSelection)
    {
        //
        // Select the desired entry
        //
        m_list_Users.SelectItem(pSelection);
    }

    m_list_Users.SetRedraw(TRUE);

    //
    // Update the count text on the dialog
    //
    UpdateTotalCount();
}



HRESULT
CUserSessionsDlg::RefreshUsersList()
/*++

Routine Description:

    Rebuild the user list

Arguments:

    None

Return Value:

    Error return code

--*/
{
    TEMP_ERROR_OVERRIDE(EPT_S_NOT_REGISTERED, IDS_ERR_RPC_NA);
    TEMP_ERROR_OVERRIDE(RPC_S_SERVER_UNAVAILABLE, IDS_SERVICE_NOT_STARTED);
    TEMP_ERROR_OVERRIDE(RPC_S_UNKNOWN_IF, IDS_SERVICE_NOT_STARTED);
    TEMP_ERROR_OVERRIDE(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);

    CError err;
	err = BuildUserList();
    if (!err.MessageBoxOnFailure())
    {
        FillListBox();
        SetControlStates();
    }

    return err;
}



void
CUserSessionsDlg::SetControlStates()
/*++

Routine Description:

    Set the connect/disconnect buttons depending on the selection state
    in the listbox.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Disconnect.EnableWindow(m_list_Users.GetSelCount() > 0);
    m_button_DisconnectAll.EnableWindow(m_list_Users.GetCount() > 0);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CUserSessionsDlg::OnButtonDisconnect() 
/*++

Routine Description:

    'Disconnect User' button has been pressed.  Disconnect the currently
    selected user.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for confirmation
    //
    if (!NoYesMessageBox(IDS_CONFIRM_DISCONNECT_USER))
    {
        //
        // Changed his mind
        //
        return;
    }

    CError err;
    m_list_Users.SetRedraw(FALSE);
    CWaitCursor wait;
    
    CFtpUserInfo * pUserEntry;
    int nSel = 0;
    BOOL fProblems = FALSE;
    while((pUserEntry = GetNextSelectedItem(&nSel)) != NULL)
    {
        err = DisconnectUser(pUserEntry);
        if (err.Failed())
        {
            ++fProblems;

            if (err.MessageBoxFormat(
                IDS_DISCONNECT_ERR,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2,
                NO_HELP_CONTEXT,
                (LPCTSTR)pUserEntry->QueryUserName()
                ) == IDYES)
            {
                //
                // Continue trying to delete
                //
                ++nSel;
                continue;
            }    
            else
            {
                break;
            }
        }
    
        m_oblFtpUsers.RemoveIndex(nSel);
        m_list_Users.DeleteString(nSel);

        //
        // Don't advance counter to account for offset
        //
    }

    m_list_Users.SetRedraw(TRUE);
    UpdateTotalCount();
    SetControlStates();

    if (!fProblems)
    {
        //
        // Ensure button not disabled
        //
        GetDlgItem(IDC_BUTTON_REFRESH)->SetFocus();
    }
}



void
CUserSessionsDlg::OnButtonDisconnectAll() 
/*++

Routine Description:

    'Disconnect All Users' button has been pressed.  Disconnect all users

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for confirmation
    //
    if (!NoYesMessageBox(IDS_CONFIRM_DISCONNECT_ALL))
    {
        //
        // Changed his mind
        //
        return;
    }
    
    CObListIter obli(m_oblFtpUsers);
    CFtpUserInfo * pUserEntry;

    m_list_Users.SetRedraw(FALSE);
    CWaitCursor wait;
    int cItems = 0;

    CError err;
    int nSel = 0;
    BOOL fProblems = FALSE;
    for ( /**/; pUserEntry = (CFtpUserInfo *)obli.Next(); ++cItems)
    {
        err = DisconnectUser(pUserEntry);
        if (err.Failed())
        {
            ++fProblems;

            if (err.MessageBoxFormat(
                IDS_DISCONNECT_ERR,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2,
                NO_HELP_CONTEXT,
                (LPCTSTR)pUserEntry->QueryUserName()
                ) == IDYES)
            {
                //
                // Continue trying to delete
                //
                ++nSel;
                continue;
            }    
            else
            {
                break;
            }
        }

        m_oblFtpUsers.RemoveIndex(nSel);
        m_list_Users.DeleteString(nSel);
    }

    m_list_Users.SetRedraw(TRUE);
    UpdateTotalCount();
    SetControlStates();

    if (!fProblems)
    {
        //
        // Ensure button not disabled
        //
        GetDlgItem(IDC_BUTTON_REFRESH)->SetFocus();
    }
}



void
CUserSessionsDlg::OnButtonRefresh() 
/*++

Routine Description:

    'Refresh' Button has been pressed.  Refresh the user list

Arguments:

    None

Return Value:

    None

--*/
{
    RefreshUsersList();
}



void 
CUserSessionsDlg::OnSelchangeListUsers() 
/*++

Routine Description:

    Respond to a change in selection in the user listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CUserSessionsDlg::OnHeaderItemClick(
    IN  UINT nID,
    IN  NMHDR * pNMHDR,
    OUT LRESULT * plResult
    )
/*++

Routine Description:

    Header item has been clicked in the listbox.  Change the sort key
    as appropriate.

Arguments:

    None

Return Value:

    None

--*/
{
    HD_NOTIFY * pNotify = (HD_NOTIFY *)pNMHDR;
    TRACEEOLID("Header Button clicked.");

    //
    // Can't press a button out of range, surely...
    //
    ASSERT(pNotify->iItem < m_list_Users.QueryNumColumns());
    int nOldSortColumn = m_nSortColumn;
    m_nSortColumn = pNotify->iItem;

    if(m_nSortColumn != nOldSortColumn)
    {
        //
        // Rebuild the list
        //
        SortUsersList();
        CFtpUserInfo * pSelector = GetSelectedListItem();
        FillListBox(pSelector);
        SetControlStates();
    }

    //
    // Message Fully Handled
    //
    *plResult = 0;
}



BOOL 
CUserSessionsDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_list_Users.Initialize();

    if (RefreshUsersList() != ERROR_SUCCESS)
    {
        EndDialog(IDCANCEL);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\nt\stdafx.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        stdafx.h

   Abstract:

        Precompiled header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxdisp.h>        // CG: added by OLE Control Containment component
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <tchar.h>

#include <aclapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\w95\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions
#include <afxcoll.h>            // collection class
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>             // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\lbcfg\natobjs.h ===
// nat access objects

class CNATNode;
class CNATSiteComputer;
class CNATSite;
class CNATGroup;
class CNATServerComputer;


// a list of group types. To be used to show an appropriate icon
enum {
    GROUP_TYPE_WWW  = 0,
    GROUP_TYPE_FTP,
    GROUP_TYPE_MAIL,
    GROUP_TYPE_UNKNOWN = 0XFFFFFFFF
    };

#define HASH_BYTE_SIZE       16


//---------------------------------------------------------------------------------
// virtual abstract class just used to get that OnProperties on the virutal table
class CNATNode : public CObject
    {
    public:
    // Edit the properties of this Site - true if OK
    virtual BOOL OnProperties() = 0;
    };


//---------------------------------------------------------------------------------
class CNATSiteComputer : public CObject
    {
    public:
    CNATSiteComputer( LPCTSTR pszName, BOOL fVisible = TRUE ):
            m_fVisibleOnNet(fVisible),
            m_iComp(0),
            m_refcount(0)
        {
        m_csName = pszName;
        }
    ~CNATSiteComputer() {;}

    // ref counting
    void AddRef()           {m_refcount++;}
    void RemoveRef()        {m_refcount--;}

    // When added by a refresh, the visibility of the computer is checked on the
    // net. This flag indicates whether or not that check suceeded.
    BOOL        m_fVisibleOnNet;

    // the network name of the machine
    CString     m_csName;

    // internal DWORD used only during the machine committing process
    DWORD       m_iComp;

    // internal ref count to see how many sites point to it
    DWORD       m_refcount;
    };

//---------------------------------------------------------------------------------
// coded in natobjs.cpp
class CNATSite : public CNATNode
    {
    public:
    CNATSite(CNATGroup* pGroup, CNATSiteComputer* pSiteComputer,
                    LPCTSTR pszPrivateIP = _T(""),
                    LPCTSTR pszName = _T(""));
    ~CNATSite(); // don't forget to decrement the refcount

    // Edit the properties of this Site - true if OK
    BOOL OnProperties();

    // get the data associated with the group
    void GetIP( OUT CString &csIP ) { csIP = m_csPrivateIP; }
    LPCTSTR GetIP() { return (LPCTSTR)m_csPrivateIP; }

    void GetName( OUT CString &csName ) { csName = m_csName; }
    LPCTSTR GetName() { return (LPCTSTR)m_csName; }

    // reference to the computer object this site relates to
    CNATSiteComputer*   m_pSiteComputer;

    // the private IP this site relates to
    CString             m_csPrivateIP;

    // the name (friendly) this site relates to
    CString             m_csName;

    // the owning CNATGroup
    CNATGroup*          m_pGroup;
    };

//---------------------------------------------------------------------------------
// coded in natgroup.cpp
class CNATGroup : public CNATNode
    {
    public:
    CNATGroup( CNATServerComputer* pNatComputer, LPCTSTR pszIP = _T(""),
               LPCTSTR pszName = _T(""), DWORD dwSticky = 0, DWORD type = GROUP_TYPE_UNKNOWN );
    ~CNATGroup();

    // Edit the properties of this Site - true if OK
    BOOL OnProperties();

    // This is just a handy way to get the nat machine object to commit
    void Commit();

    // get the data associated with the group
    void GetIP( OUT CString &csIP ) { csIP = m_csIP; }
    LPCTSTR GetIP() { return (LPCTSTR)m_csIP; }

    void GetName( OUT CString &csName ) { csName = m_csName; }
    LPCTSTR GetName() { return (LPCTSTR)m_csName; }

    void GetSticky( OUT DWORD* pdwSticky ) { *pdwSticky = m_dwSticky; }
    DWORD GetSticky() { return m_dwSticky; }

    void GetType( OUT DWORD* pdwType ) { *pdwType = m_type; }
    DWORD GetType() { return m_type; }


    // get the number of groups associated with this machine
    DWORD GetNumSites() {return m_rgbSites.GetSize();}

    // Get a Site referece
    CNATSite* GetSite( IN DWORD iSite ) {return m_rgbSites[iSite];}


    // adds a new site to the list.
    CNATSite* NewSite();

    // adds an existing site to the list - to be called during a refresh.
    // this checks the visiblity of the machine on the net as it adds it
    void AddSite( IN CNATSiteComputer* pSiteComputer, IN LPCTSTR pszPrivateIP, IN LPCTSTR pszName );


    protected:

    // empties and frees all the groups/sites in the groups list
    void EmptySites();

    // this is the owning NATMachine object. All the real action takes place there.
    CNATServerComputer*    m_pNatComputer;


    // a dynamic array of the sites assocated with the group
    CTypedPtrArray<CObArray, CNATSite*> m_rgbSites;


    // the string that represents the public IP/Port pair presented by the group
    CString         m_csIP;

    // the string that represents the friendly name of the group
    CString         m_csName;

    // the DWORD that represents the sticky IP timeout of the group
    DWORD           m_dwSticky;

    // DWORD indicating what type of group this is.
    DWORD           m_type;
    };

//---------------------------------------------------------------------------------
// coded in NATServerComputer.cpp
class CNATServerComputer : public CNATNode
    {
    public:
    CNATServerComputer( LPCTSTR pszComputerName );
    ~CNATServerComputer();

    // rebuild all the data based on a new blob from the NAT machine
    void Refresh();

    // commit the current state of the data back to the NAT machine
    void Commit();

    
    // Edit the properties of this Site - true if OK
    BOOL OnProperties();


    // add a new group to the server computer (called by the UI). This
    // may or may not prompt the user with UI and returns the pointer
    // to the new group after adding it to the group list
    CNATGroup* NewGroup();

    // add a new computer to the sites list. - Note: if the computer
    // already exists in the sites list, it will just return a reference
    // to the existing computer. This routine prompts the user to choose
    // a computer to add. Returns FALSE if it fails.
    CNATSiteComputer* NewComputer();


    // get the number of groups associated with this machine
    DWORD GetNumGroups();

    // Get a group reference
    CNATGroup* GetGroup( IN DWORD iGroup );

    // Technically, the GetGroupName function is unecessary because
    // you get get the group class pointer, then call GetName on it, but it is really
    // handy to just do it here. Cleans up the snapin part of the code.
    BOOL GetGroupName( IN DWORD iGroup, OUT CString &csName );

    // call this to automatically verify that the target NAT computers config info
    // hasn't changed. If it has, it prompts the user and lets them continue or refresh.
    BOOL VerifyHashIsOK();

    protected:

    // utility to check if the computer is visible on the net
    BOOL CanSeeComputer( IN LPCTSTR pszname );

    // empties and frees all the site computer objects in the list
    void EmptySiteComputers();

    // empties and frees all the groups/sites in the groups list
    void EmptyGroups();


    // adds an existing computer to the list - to be called during a refresh.
    // this checks the visiblity of the machine on the net as it adds it
    void AddSiteComputer( IN LPWSTR pszwName );

    // adds an existing group to the list - to be called during a refresh.
    void AddGroup( IN LPWSTR pszwIPPublic, IN LPWSTR pszwName, IN DWORD dwSticky, IN DWORD type );


    // gets the crypto hash of the NAT data blob. If a null pointer to the blob
    // is passed in, then it dynamically gets the blob from the server
    // or you can pass in a specific blob. This is to be used to check if
    // the state of the server has changed since the data was last loaded.
    // The hash is obtained from the crypto code so it is really good. The
    // buffer for the hash should be 128 bits in length. Using an MD5 hash.
    BOOL GetNATStateHash( IN LPBYTE pData, IN DWORD cbData, IN OUT LPBYTE pHash, OUT DWORD* pcbHash );

    // access the server and retrieve the state blob. Use GetLastError to see
    // what went wrong if the returned result is NULL. Pass in the dword pointed
    // to by pcbData to get the required size.
    LPBYTE PGetNATStateBlob( OUT DWORD* pcbData );

    // access the server and set the state blob. Use GetLastError to see what went
    // wrong if the returned result is FALSE
    BOOL SetStateBlob( IN LPBYTE pData, IN DWORD cbData );

    // open the DCOM interface to the target NAT machine.
    HRESULT GetNATInterface( OUT IMSIisLb** ppIisLb );


    // the name of the target NAT machine to edit
    CString     m_csNatComputer;


    // an dynamic array of the groups associated with the NAT machine
    CTypedPtrArray<CObArray, CNATGroup*> m_rgbGroups;

    // a dynamic array of the site computers assocated with the NAT machine
    CTypedPtrArray<CObArray, CNATSiteComputer*> m_rgbSiteComputers;


    // the last refresh hash of the config blob
    BYTE        m_hash[HASH_BYTE_SIZE];
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\dcomperm.h ===
DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\inc\svrinfo.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        svrinfo.h

   Abstract:

        ISM API Header File

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

   Notes:

        Anything tagged as K2 or greater (v4+) can be changed as required as it is
        not a public interface.  Anything designated as IIS 1, 2, or 3 is frozen
        and must not be altered as it will break existing configuration Dlls.

--*/

#ifndef _SVRINFO_H_
#define _SVRINFO_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Version number (x1000) of the ISM API set
//
#define ISM_VERSION     104     // Version 0.104

//
// API Structures
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#ifndef _SVCLOC_

#pragma message("Assuming service does not use inetsloc for discovery.")

//
// Datatype definitions.
//
typedef unsigned __int64 ULONGLONG;

//
// Provided for non-inetsloc compliant services. Those
// services which DO use inetsloc should include
// svcloc.h before including this file.
//
enum 
{
    //
    // the service has invoked de-registration or
    // the service has never called registration.
    //
    INetServiceStopped,
    //
    // the service is running.
    //
    INetServiceRunning,
    //
    //  the service is paused.
    //
    INetServicePaused,
};

#endif // _SVCLOC_

#define INetServiceUnknown      INetServicePaused + 1

//
// Memory Allocation Macros
//
#define ISMAllocMem(cbSize)\
    LocalAlloc(LPTR, cbSize)

#define ISMFreeMem(lp)\
    if (lp) LocalFree(lp)

#define ISMAllocMemByType(citems, type)\
    (type *)AllocMem(citems * sizeof(type))

//
// Maximum length of some members in characters
//
#define MAX_SERVERNAME_LEN      (256)              // We allow hostnames
#define MAX_COMMENT_LEN         MAXCOMMENTSZ

//
// Dimensions of the toolbar bitmaps
//
#define TOOLBAR_BMP_CX          (16)
#define TOOLBAR_BMP_CY          (16)

//
// Standard Server information structure.
//
typedef struct tagISMSERVERINFO
{
    DWORD dwSize;                                  // Structure size
    TCHAR atchServerName[MAX_SERVERNAME_LEN + 1];  // Server name
    TCHAR atchComment[MAX_COMMENT_LEN + 1 ];       // Server Comment
    int   nState;                                  // State (Running, paused, etc)
} ISMSERVERINFO, *PISMSERVERINFO;

//
// Expected size of structure
//
#define ISMSERVERINFO_SIZE      sizeof(ISMSERVERINFO)

//
// Service information flags
//
#define ISMI_INETSLOCDISCOVER   0x00000001  // Use INETSLOC for discovery
#define ISMI_CANCONTROLSERVICE  0x00000002  // Service state can be changed
#define ISMI_CANPAUSESERVICE    0x00000004  // Service is pausable.
#define ISMI_NORMALTBMAPPING    0x00000100  // Use normal toolbar colour mapping
//
// New for K2:
//
#define ISMI_INSTANCES          0x00000200  // Service supports instance
#define ISMI_CHILDREN           0x00000400  // Service supports children
#define ISMI_UNDERSTANDINSTANCE 0x00000800  // Understand instance codes
#define ISMI_FILESYSTEM         0x00001000  // Support file system properties
//
// New for IIS5
//
#define ISMI_TASKPADS           0x00002000  // Supports MMC taskpads
#define ISMI_SECURITYWIZARD     0x00004000  // Supports security wizard
#define ISMI_HASWEBPROTOCOL     0x00008000  // Supports browsing by protocol
#define ISMI_SUPPORTSMETABASE   0x00010000  // Supports metabase
#define ISMI_SUPPORTSMASTER     0x00020000  // Supports master instance (instance 0) 

#define MAX_SNLEN               (20)        // Maximum short name length
#define MAX_LNLEN               (48)        // Maximum long name length

//
// Standard service configuration information structure
//
// Note: This structure was used for IIS Version 1, 2 and 3
//
typedef struct tagISMSERVICEINFO1
{
    DWORD dwSize;                     // Structure size
    DWORD dwVersion;                  // Version information
    DWORD flServiceInfoFlags;         // ISMI_ flags
    ULONGLONG ullDiscoveryMask;       // InetSloc mask (if necessary)
    COLORREF rgbButtonBkMask;         // Toolbar button bitmap background mask
    UINT nButtonBitmapID;             // Toolbar button bitmap resource ID
    COLORREF rgbServiceBkMask;        // Service bitmap background mask
    UINT nServiceBitmapID;            // Service bitmap resource ID
    TCHAR atchShortName[MAX_SNLEN+1]; // The name as it appears in the menu
    TCHAR atchLongName[MAX_LNLEN+1];  // The name as it appears in tool tips
} ISMSERVICEINFO1, *PISMSERVICEINFO1;

//
// Expected size of structure
//
#define ISMSERVICEINFO1_SIZE     sizeof(ISMSERVICEINFO1)

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                            /* K2 */                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Standard service configuration information structure.
//
typedef struct tagISMSERVICEINFO
{
    //////////////////////////////////////
                                        //
    DWORD dwSize;                       // Structure size
    DWORD dwVersion;                    // Version information
    DWORD flServiceInfoFlags;           // ISMI_ flags
    ULONGLONG ullDiscoveryMask;         // InetSloc mask (if necessary)
    COLORREF rgbButtonBkMask;           // Toolbar button bitmap background mask
    UINT nButtonBitmapID;               // Toolbar button bitmap resource ID
    COLORREF rgbServiceBkMask;          // Service bitmap background mask
    UINT nServiceBitmapID;              // Service bitmap resource ID
    TCHAR atchShortName[MAX_SNLEN+1];   // The name as it appears in the menu
    TCHAR atchLongName[MAX_LNLEN+1];    // The name as it appears in tool tips
                                        //
    //////////////////////////////////////
    //
    // New for K2
    //
    //////////////////////////////////////
                                        //
    COLORREF rgbLargeServiceBkMask;     // Large Service bitmap background mask
    COLORREF rgbChildBkMask;            // Child node background mask
    COLORREF rgbLargeChildBkMask;       // Child node background mask
    UINT nLargeServiceBitmapID;         // Large Service bitmap resource ID or 0.
    UINT nChildBitmapID;                // Child node resource ID
    UINT nLargeChildBitmapID;           // Child node resource ID or 0
                                        //
    //////////////////////////////////////
    //
    // New for IIS5
    //
    //////////////////////////////////////
                                        //
    TCHAR atchMetaBaseName[MAX_SNLEN+1];// Service name
    TCHAR atchProtocol[MAX_SNLEN+1];    // Protocol or NULL
                                        //
    //////////////////////////////////////

} ISMSERVICEINFO, *PISMSERVICEINFO;

//
// Expected size of structure
//
#define ISMSERVICEINFO_SIZE     sizeof(ISMSERVICEINFO)

#define MAX_COMMENT     (255)

//
// Instance info (IIS4)
//
typedef struct tagISMINSTANCEINFO
{
    DWORD  dwSize;                    // Structure size
    DWORD  dwID;                      // Instance ID
    TCHAR  szServerName[MAX_PATH + 1];// Domain name
    TCHAR  szComment[MAX_COMMENT + 1];// Comment
    int    nState;                    // State (Running, paused, etc)
    DWORD  dwIPAddress;               // IP Address
    SHORT  sPort;                     // Port
    TCHAR  szPath[MAX_PATH + 1];      // Home directory path
    TCHAR  szRedirPath[MAX_PATH + 1]; // Redirected Path
    BOOL   fDeletable;                // TRUE if not deletable
    BOOL   fClusterEnabled;           // TRUE if cluster enabled
    BOOL   fChildOnlyRedir;           // TRUE if redir is "child only"
    DWORD  dwError;                   // WIN32 error
} ISMINSTANCEINFO, *PISMINSTANCEINFO;

//
// Expected size of structure
//
#define ISMINSTANCEINFO_SIZE    sizeof(ISMINSTANCEINFO)


//
// Child info (IIS4)
//
typedef struct tagISMCHILDINFO
{
    DWORD dwSize;                     // Structure size
    BOOL  fEnabledApplication;        // TRUE if enabled app
    BOOL  fInheritedPath;             // Inherited path
    TCHAR szAlias[MAX_PATH + 1];      // Alias
    TCHAR szPath[MAX_PATH + 1];       // Physical Path
    TCHAR szRedirPath[MAX_PATH + 1];  // Redirected Path
    BOOL  fChildOnlyRedir;            // TRUE if redir is "child only"
    DWORD dwError;                    // WIN32 error
} ISMCHILDINFO, *PCHILDINFO;

//
// Expected size of structure
//
#define ISMCHILDINFO_SIZE       sizeof(ISMCHILDINFO)

//
// Function prototypes
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Return service-specific information back to
// to the application.  This function is called
// by the service manager immediately after
// LoadLibary();
//
// IIS1-3
//
DWORD APIENTRY
ISMQueryServiceInfo(
    ISMSERVICEINFO * psi        // Service information returned.
    );

//
// Perform a discovery (if not using inetsloc discovery)
// The application will call this API the first time with
// a BufferSize of 0, which should return the required buffer
// size. Next it will attempt to allocate a buffer of that
// size, and then pass a pointer to that buffer to the api.
//
// IIS1-3
//
DWORD APIENTRY
ISMDiscoverServers(
    ISMSERVERINFO * psi,        // Server info buffer.
    DWORD * pdwBufferSize,      // Size required/available.  
    int * cServers              // Number of servers in buffer.
    );

//
// Get information on a single server with regards to
// this service.
//
// IIS1-3
//
DWORD APIENTRY
ISMQueryServerInfo( 
    LPCTSTR lpszServerName,     // Name of server.
    ISMSERVERINFO * psi         // Server information returned.
    );

//
// Change the state of the service (started, stopped, paused) for the 
// listed servers.
//
// IIS1-3
//
DWORD APIENTRY
ISMChangeServiceState(
    int     nNewState,          // INetService* definition.
    int *   pnCurrentState,     // Pointer to the current state of the service.
    DWORD   dwInstance,         // /* K2 */ Instance or 0
    LPCTSTR lpszServers         // Double NULL terminated list of servers.
    );

//
// The big-one:  Show the configuration dialog or
// property sheets, whatever, and allow the user
// to make changes as needed.
//
// IIS1-3
//
DWORD APIENTRY
ISMConfigureServers(
    HWND    hWnd,               // Main app window handle
    DWORD   dwInstance,         // /* K2 */ Instance or 0
    LPCTSTR lpszServers         // Double NULL terminated list of servers
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                            /* K2 */                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// K2 Extended APIs use handles instead of server names.  First obtain a
// handle with Bind(), use the handle with all APIs below, and then Unbind
// the handle
//
// IIS5
//
HRESULT APIENTRY
ISMBind(
    LPCTSTR lpszServer,         // A single server name.
    HANDLE * phServer           // Returns server name.
    );

HRESULT APIENTRY
ISMUnbind(
    HANDLE hServer              // Server handle
    );

//
// Enumerate instances.  This API should first be called with a buffer
// size of 0, which will return the required number of bytes
//
// IIS5
//
HRESULT APIENTRY
ISMEnumerateInstances(
    HANDLE hServer,             // Server handle
    ISMINSTANCEINFO * pii,      // Instance info buffer
    HANDLE * phEnum             // Enumeration handle: init with NULL
    );

//
// Get instance specific information.
//
// IIS5
//
HRESULT APIENTRY
ISMQueryInstanceInfo(
    HANDLE hServer,             // Server handle
    BOOL   fInherit,            // TRUE to inherit, FALSE otherwise
    ISMINSTANCEINFO * pii,      // Instance info buffer
    DWORD  dwInstance           // Instance number
    );

//
// Add an instance
//
// IIS5
//
HRESULT APIENTRY
ISMAddInstance(
    HANDLE hServer,             // Server handle
    DWORD  dwSourceInstance,    // Source instance
    ISMINSTANCEINFO * pii,      // Instance info buffer.  May be NULL
    DWORD  dwBufferSize         // Size of buffer
    );

//
// Delete an instance
//
// IIS5
//
HRESULT APIENTRY
ISMDeleteInstance(
    HANDLE hServer,             // Server handle
    DWORD  dwInstance           // Instance to be deleted
    );

//
// Enumerate children  This API should first be called with a buffer
// size of 0, which will return the required number of bytes.
//
// IIS5
//
HRESULT APIENTRY
ISMEnumerateChildren(
    HANDLE hServer,             // Server handle
    ISMCHILDINFO * pii,         // Child info buffer
    HANDLE * phEnum,            // Enumeration handle: init with NULL
    DWORD   dwInstance,         // Parent instance
    LPCTSTR lpszParent          // Parent Path ("" for root)
    );

//
// Get child-specific info
//
// IIS5
//
HRESULT APIENTRY
ISMQueryChildInfo(
    HANDLE hServer,             // Server handle
    BOOL   fInherit,            // TRUE to inherit, FALSE otherwise
    ISMCHILDINFO * pii,         // Child info buffer
    DWORD   dwInstance,         // Parent instance
    LPCTSTR lpszParent,         // Parent Path ("" for root)
    LPCTSTR lpszAlias           // Alias of child to be deleted
    );

//
// Add a child
//
// IIS5
//
HRESULT APIENTRY
ISMAddChild(
    HANDLE hServer,             // Server handle
    ISMCHILDINFO * pii,         // Child info buffer. May be NULL
    DWORD   dwBufferSize,       // Size of info buffer
    DWORD   dwInstance,         // Parent instance
    LPCTSTR lpszParent          // Parent Path ("" for root)
    );

//
// Delete a child
//
// IIS5
//
HRESULT APIENTRY
ISMDeleteChild(
    HANDLE  hServer,            // Server handle
    DWORD   dwInstance,         // Parent instance
    LPCTSTR lpszParent,         // Parent Path ("" for root)
    LPCTSTR lpszAlias           // Alias of child to be deleted
    );

//
// Rename a child
//
// IIS5
//
HRESULT APIENTRY
ISMRenameChild(
    HANDLE  hServer,            // Server handle
    DWORD   dwInstance,         // Parent instance
    LPCTSTR lpszParent,         // Parent Path ("" for root)
    LPCTSTR lpszAlias,          // Alias of child to be renamed
    LPCTSTR lpszNewAlias        // New alias name of the child
    );

//
// Private FILE_ATTRIBUTE used to designate a virtual directory
//
#define FILE_ATTRIBUTE_VIRTUAL_DIRECTORY    (0x10000000)

//
// Configure Child
//
// IIS5
//
HRESULT APIENTRY
ISMConfigureChild(
    HANDLE  hServer,            // Server handle
    HWND    hWnd,               // Main app window handle
    DWORD   dwAttributes,       // File system attributes
    DWORD   dwInstance,         // Parent instance
    LPCTSTR lpszParent,         // Parent path
    LPCTSTR lpszAlias           // Child alias name
    );

//
// Configure servers with MMC property sheet
//
// IIS5
//
HRESULT APIENTRY
ISMMMCConfigureServers(
    HANDLE   hServer,           // Server handle
    PVOID    lpfnProvider,      // MMC parameter
    LPARAM   lParam,            // MMC parameter
    LONG_PTR handle,            // MMC parameter
    DWORD    dwInstance         // Instance number
    );

//
// Configure Child with MMC property sheet
//
// IIS5
//
HRESULT APIENTRY
ISMMMCConfigureChild(
    HANDLE   hServer,           // Server handle
    PVOID    lpfnProvider,      // MMC parameter
    LPARAM   lParam,            // MMC parameter
    LONG_PTR handle,            // MMC parameter
    DWORD    dwAttributes,      // Child attributes
    DWORD    dwInstance,        // Instance number
    LPCTSTR  lpszParent,        // Parent path
    LPCTSTR  lpszAlias          // Child alias name
    );

//
// Launch security wizard
//
// IIS5
//
HRESULT APIENTRY
ISMSecurityWizard(
    HANDLE  hServer,            // Server handle
    DWORD   dwInstance,         // Instance number
    LPCTSTR lpszParent,         // Parent path
    LPCTSTR lpszAlias           // Child alias name
    );

//
// GetProcAddress() Prototypes 
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IIS1-3                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef DWORD (APIENTRY * pfnQueryServiceInfo)(ISMSERVICEINFO * psi);

typedef DWORD (APIENTRY * pfnDiscoverServers)(
    ISMSERVERINFO * psi,
    DWORD * pdwBufferSize,
    int *   cServers
    );

typedef DWORD (APIENTRY * pfnQueryServerInfo)(
    LPCTSTR lpszServerName,
    ISMSERVERINFO * psi
    );

typedef DWORD (APIENTRY * pfnChangeServiceState)(
    int     nNewState,
    int *   pnCurrentState,
    DWORD   dwInstance,
    LPCTSTR lpszServers
    );

typedef DWORD (APIENTRY * pfnConfigure)(
    HWND    hWnd,
    DWORD   dwInstance,
    LPCTSTR lpszServers
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                            /* K2 */                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef HRESULT (APIENTRY * pfnBind)(
    LPCTSTR lpszServer,
    HANDLE * phServer
    );

typedef HRESULT (APIENTRY * pfnUnbind)(
    HANDLE hServer
    );

typedef HRESULT (APIENTRY * pfnEnumerateInstances)(
    HANDLE hServer,
    ISMINSTANCEINFO * pii,
    HANDLE * phEnum
    );

typedef HRESULT (APIENTRY * pfnQueryInstanceInfo)(
    HANDLE hServer,
    BOOL   fInherit,
    ISMINSTANCEINFO * pii,
    DWORD  dwInstance
    );

typedef HRESULT (APIENTRY * pfnEnumerateChildren)(
    HANDLE hServer,
    ISMCHILDINFO * pii,
    HANDLE * phEnum,
    DWORD   dwInstance,
    LPCTSTR lpszParent
    );

typedef HRESULT (APIENTRY * pfnAddInstance)(
    HANDLE  hServer,
    DWORD   dwSourceInstance,
    ISMINSTANCEINFO * pii,
    DWORD   dwBufferSize
    );

typedef HRESULT (APIENTRY * pfnDeleteInstance)(
    HANDLE  hServer,
    DWORD   dwInstance
    );

typedef HRESULT (APIENTRY * pfnAddChild)(
    HANDLE  hServer,
    ISMCHILDINFO * pii,
    DWORD   dwBufferSize,
    DWORD   dwInstance,
    LPCTSTR lpszParent
    );

typedef HRESULT (APIENTRY * pfnDeleteChild)(
    HANDLE  hServer,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias
    );

typedef HRESULT (APIENTRY * pfnRenameChild)(
    HANDLE  hServer,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias,
    LPCTSTR lpszNewAlias
    );

typedef HRESULT (APIENTRY * pfnQueryChildInfo)(
    HANDLE  hServer,
    BOOL   fInherit,
    ISMCHILDINFO * pii,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias
    );

typedef HRESULT (APIENTRY * pfnConfigureChild)(
    HANDLE  hServer,
    HWND    hWnd,
    DWORD   dwAttributes,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias
    );

typedef HRESULT (APIENTRY * pfnISMMMCConfigureServers)(
    HANDLE  hServer,
    PVOID   lpfnProvider,
    LPARAM  lParam,
    LONG_PTR handle,
    DWORD   dwInstance
    );

typedef HRESULT (APIENTRY * pfnISMMMCConfigureChild)(
    HANDLE  hServer,
    PVOID   lpfnProvider,
    LPARAM  lParam,
    LONG_PTR handle,
    DWORD   dwAttributes,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias
    );

typedef HRESULT (APIENTRY * pfnISMSecurityWizard)(
    HANDLE  hServer,           
    DWORD   dwInstance,        
    LPCTSTR lpszParent,        
    LPCTSTR lpszAlias          
    );

//
// GetProcAddress() Function Names
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// IIS1-3
//

#define SZ_SERVICEINFO_PROC         ("ISMQueryServiceInfo")
#define SZ_DISCOVERY_PROC           ("ISMDiscoverServers")
#define SZ_SERVERINFO_PROC          ("ISMQueryServerInfo")
#define SZ_CHANGESTATE_PROC         ("ISMChangeServiceState")
#define SZ_CONFIGURE_PROC           ("ISMConfigureServers")

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                            /* K2 */                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SZ_BIND_PROC                ("ISMBind")
#define SZ_UNBIND_PROC              ("ISMUnbind")
#define SZ_CONFIGURE_CHILD_PROC     ("ISMConfigureChild")
#define SZ_ENUMERATE_INSTANCES_PROC ("ISMEnumerateInstances")
#define SZ_QUERY_INSTANCE_INFO_PROC ("ISMQueryInstanceInfo")
#define SZ_ENUMERATE_CHILDREN_PROC  ("ISMEnumerateChildren")
#define SZ_ADD_INSTANCE_PROC        ("ISMAddInstance")
#define SZ_DELETE_INSTANCE_PROC     ("ISMDeleteInstance")
#define SZ_ADD_CHILD_PROC           ("ISMAddChild")
#define SZ_DELETE_CHILD_PROC        ("ISMDeleteChild")
#define SZ_RENAME_CHILD_PROC        ("ISMRenameChild")
#define SZ_QUERY_CHILD_INFO_PROC    ("ISMQueryChildInfo")
#define SZ_MMC_CONFIGURE_PROC       ("ISMMMCConfigureServers")
#define SZ_MMC_CONFIGURE_CHILD_PROC ("ISMMMCConfigureChild")
#define SZ_SECURITY_WIZARD_PROC     ("ISMSecurityWizard")

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Taskpad resource names                                                    //
//                                                                           //
// * IIS5 *                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define RES_TASKPAD_NEWVROOT        _T("/img\\newvroot.gif")
#define RES_TASKPAD_NEWSITE         _T("/img\\newsite.gif")
#define RES_TASKPAD_SECWIZ          _T("/img\\secwiz.gif")

#ifdef __cplusplus
}
#endif

#endif // _SVRINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\lbcfg\natobjs.cpp ===
// objects used to access the NAT resources

#include "stdafx.h"
#include "natobjs.h"
#include "resource.h"


//---------------------------------------------------------------------------------
CNATSite::CNATSite(CNATGroup* pGroup, CNATSiteComputer* pSiteComputer,
                                    LPCTSTR pszPrivateIP, LPCTSTR pszName ):
        m_pSiteComputer(pSiteComputer),
        m_pGroup(pGroup)
    {
    m_csPrivateIP = pszPrivateIP;
    m_csName = pszName;

    ASSERT( pGroup );
    ASSERT( m_pSiteComputer );
    if ( m_pSiteComputer )
        m_pSiteComputer->AddRef();
    }

//---------------------------------------------------------------------------------
CNATSite::~CNATSite() // don't forget to decrement the refcount
    {
    ASSERT( m_pSiteComputer );
    if ( m_pSiteComputer )
        m_pSiteComputer->RemoveRef();
    }

//---------------------------------------------------------------------------------
// Edit the properties of this Site - true if OK
BOOL CNATSite::OnProperties()
    {
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\lbcfg\natservercomputer.cpp ===
#include "stdafx.h"
#include "natobjs.h"
#include "resource.h"
#include "ConnectDlg.h"

#include <wincrypt.h>


HRESULT CreateMD5Hash( IN PBYTE pbData,
                       IN DWORD cbData,
                       OUT PBYTE pbHashBuffer,
                       IN OUT DWORD *pdwHashBufferSize );


//-------------------------------------------------------------------------
CNATServerComputer::CNATServerComputer( LPCTSTR pszComputerName )
    {
    m_csNatComputer = pszComputerName;
    ZeroMemory( m_hash, sizeof(m_hash) );
    }

//-------------------------------------------------------------------------
CNATServerComputer::~CNATServerComputer()
    {
    // clean up the lists
    EmptySiteComputers();
    EmptyGroups();
    }

//-------------------------------------------------------------------------
// Edit the properties of this server computer
BOOL CNATServerComputer::OnProperties()
    { 
    AfxMessageBox(IDS_NODENAME);
    return FALSE;
    }

//-------------------------------------------------------------------------
// get the number of groups associated with this machine
DWORD CNATServerComputer::GetNumGroups()
    {
    return m_rgbGroups.GetSize();
    }

//-------------------------------------------------------------------------
// Get a group reference
CNATGroup* CNATServerComputer::GetGroup( IN DWORD iGroup )
    {
    return m_rgbGroups[iGroup];
    }

//-------------------------------------------------------------------------
// Technically, the GetGroupName function is unecessary because
// you get get the group class pointer, then call GetName on it, but it is really
// handy to just do it here. Cleans up the snapin part of the code.
BOOL CNATServerComputer::GetGroupName( IN DWORD iGroup, OUT CString &csName )
    {
    // just get the group and turn around the name
    CNATGroup*  pGroup = GetGroup( iGroup );
    if ( !pGroup ) return FALSE;
    
    // get the name
    csName = pGroup->GetName();
    return TRUE;
    }

//-------------------------------------------------------------------------
// call this to automatically verify that the target NAT computers config info
// hasn't changed. If it has, it prompts the user and lets them continue or refresh.
BOOL CNATServerComputer::VerifyHashIsOK()
    {
    BYTE    hash[HASH_BYTE_SIZE];
    DWORD   cbHash = sizeof(hash);

    // get the has of the current state of the server. Passing in a null pointer
    // causes the routine to go out and get a new copy of the blob
    if ( !GetNATStateHash( NULL, 0, hash, &cbHash ) )
        return FALSE;

    // if the two hashes are the same, then the blob has not changed on us
    return ( memcmp(hash, m_hash, HASH_BYTE_SIZE) == 0 );
    }


//-------------------------------------------------------------------------
// rebuild all the data based on a new blob from the NAT machine
void CNATServerComputer::Refresh()
    {
    DWORD   num, i;
    CString szName, szIP;
    LPWSTR  pszwName, pszwIP;
    BOOL    f;

    // empty any current entries in the lists
    EmptySiteComputers();
    EmptyGroups();

    // Get the blob data from the DCOM object and put it in the wrapper thing
    CIPMap      IpMap;

    // get the data
    LPBYTE      pData = NULL;
    DWORD       cbData = 0;
    // throws up its own errors
    pData = PGetNATStateBlob( &cbData );
    if ( !pData )
        return;

    // unserialize the data into the wrapper class
    if ( !IpMap.Unserialize(&pData, &cbData) )
        {
        goto error;
        }

    // start by reading in all the site computers from the wrapper
    num = IpMap.ComputerCount();
    for ( i = 0; i < num; i++ )
        {
        // the computer name from the wrapper
        if ( !IpMap.EnumComputer(i, &pszwName) )
            {
            ASSERT( FALSE );
            continue;
            }
        szName = pszwName;

        // check if the computer name is visible
        BOOL    bVisible = CanSeeComputer( (LPCTSTR)szName );

        // create the computer object
        CNATSiteComputer*   pSC = new CNATSiteComputer( (LPCTSTR)szName, bVisible );
        ASSERT( pSC );
        if ( !pSC )
            goto error;

        // add the computer to the site computer array
        m_rgbSiteComputers.Add( pSC );
        }

    // now read the groups. In each group, build its site array
    num = IpMap.IpPublicCount();
    for ( i = 0; i < num; i++ )
        {
        DWORD   dwSticky;

        // the computer name from the wrapper
        if ( !IpMap.EnumIpPublic(i, &pszwIP, &pszwName, &dwSticky) )
            {
            ASSERT( FALSE );
            continue;
            }
        szIP = pszwIP;
        szName = pszwName;

        // create the group object
        CNATGroup*   pG = new CNATGroup( this, (LPCTSTR)szIP, (LPCTSTR)szName, dwSticky );
        ASSERT( pG );
        if ( !pG )
            goto error;

        // add the computer to the site computer array
        m_rgbGroups.Add( pG );

        // now, for this group, add the sites that are associated with it. This means
        // looping through all the computer objects and looking for ones that match this one
        DWORD   numComputers = m_rgbSiteComputers.GetSize();
        DWORD   iComp;
        for ( iComp = 0; iComp < numComputers; iComp++ )
            {
            szIP.Empty();
            // if there is a match, add it as a site
            if ( IpMap.GetIpPrivate(iComp, i, &pszwIP, &pszwName) )
                {
                szIP = pszwIP;
                szName = pszwName;
                }

            // if there is a match, then there will be data in szIP
            if ( !szIP.IsEmpty() )
                {
                // we got a match. We can now create a new site object and add it to the group
                pG->AddSite( m_rgbSiteComputers[iComp], (LPCTSTR)szIP, (LPCTSTR)szName );
                }
            }
        }

    // success!
    goto cleanup;

    // failure :-(
error:
    // tell the user about it
    AfxMessageBox( IDS_BADBLOB );

    // empty any current entries in the lists
    EmptySiteComputers();
    EmptyGroups();

    // cleanup
cleanup:
    if ( pData )
        GlobalFree( pData );
    }

//-------------------------------------------------------------------------
// commit the current state of the data back to the NAT machine
void CNATServerComputer::Commit()
    {
#define ICOMP_ERR       0xFFFFFFFF

    CStoreXBF   xbfStorage;

    // start the commit process by verifying that no other admin has changed the
    // state of the server since we last refreshed. If then have, we have to tell
    // the user and let them choose to continue commiting (losing the current state
    // of the server) or to cancel the current operation and automatically refresh
    // to the new state of the server.
    if ( !VerifyHashIsOK() )
        {
        if ( AfxMessageBox( IDS_VERIFYFAILED ) == IDNO )
            {
            Refresh();
            return;
            }
        }

    // we are committing. The process involves creating a new interface wrapper.
    // building up all the values, then writing out the blob to the DCOM layer.
    CIPMap      IpMap;

    // first, add all the SiteComputer objects to the map object. While doing this, only
    // actually add ones that have a refcount associated with them. (cleans up items that)
    // are no longer used. Also, set the actual index on the object for use later on
    DWORD       num = m_rgbSiteComputers.GetSize();
    DWORD       i, j;
    DWORD       iComp = 0;

    // loop through the computers and add each one.
    for ( i = 0; i < num; i++ )
        {
        CNATSiteComputer* pSC = m_rgbSiteComputers[i];
        ASSERT( pSC );

        // if the SC has a refcount, add it to the interface builder
        if ( pSC->m_refcount )
            {
            // set its internal iComp member variable
            pSC->m_iComp = iComp;

            // Add the SC to the interface builder
            if ( !IpMap.AddComputer((LPTSTR)(LPCTSTR)pSC->m_csName) )
                goto error;
            }
        else
            // the refcount is null
            {
            // set its internal iComp member variable to invalid
            pSC->m_iComp = ICOMP_ERR;
            }
        }

    // loop through the groups and add those to the interface builder
    num = m_rgbGroups.GetSize();

    // loop through the computers and add each one.
    for ( i = 0; i < num; i++ )
        {
        CNATGroup* pG = m_rgbGroups[i];
        ASSERT( pG );

        // add it to the interface builder
        if ( !IpMap.AddIpPublic((LPTSTR)pG->GetIP(), (LPTSTR)pG->GetName(), pG->GetSticky()) )
            goto error;

        // we also need to add the sites to the group
        DWORD   numSites = pG->GetNumSites();
        for ( j = 0; j < numSites; j++ )
            {
            CNATSite* pS = pG->GetSite( j );
            ASSERT( pS );
            ASSERT( pS->m_pSiteComputer );
            ASSERT( pS->m_pSiteComputer->m_refcount > 0 );
            ASSERT( pS->m_pSiteComputer->m_iComp != ICOMP_ERR );

            // map the site to the group in the interface builder
            if ( !IpMap.SetIpPrivate( pS->m_pSiteComputer->m_iComp, i,
                             (LPTSTR)pS->GetIP(), (LPTSTR)pS->GetName() ) )
                goto error;
            }
        }

    // serialize it all into a buffer for the COM call
    if ( !IpMap.Serialize(&xbfStorage) )
        goto error;

    // Set the blob into the DCOM layer. - It puts up its own error
    // message if there is a failure talking to the DCOM object
    if ( SetStateBlob( xbfStorage.GetBuff(), xbfStorage.GetUsed() ) )
        {
        DWORD   cbHash = HASH_BYTE_SIZE;
        // update the hash
        GetNATStateHash( xbfStorage.GetBuff(), xbfStorage.GetUsed(), m_hash, &cbHash );
        }

    // return normally (success)
    return;

error:
    // shouldn't ever get here
    ASSERT( FALSE );
    AfxMessageBox( IDS_BUILDBLOBERROR );
    }

//-------------------------------------------------------------------------
// empties and frees all the site computer objects in the list
void CNATServerComputer::EmptySiteComputers()
    {
    DWORD   numSiteComputers = m_rgbSiteComputers.GetSize();

    // loop the array and free all the group objects
    for ( DWORD i = 0; i < numSiteComputers; i++ )
        {
        delete m_rgbSiteComputers[i];
        }

    // empty the array itself
    m_rgbSiteComputers.RemoveAll();
    }

//-------------------------------------------------------------------------
// empties and frees all the groups/sites in the groups list
void CNATServerComputer::EmptyGroups()
    {
    DWORD   numGroups = m_rgbGroups.GetSize();

    // loop the array and free all the group objects
    for ( DWORD i = 0; i < numGroups; i++ )
        {
        delete m_rgbGroups[i];
        }

    // empty the array itself
    m_rgbGroups.RemoveAll();
    }

//-------------------------------------------------------------------------
// add a new group to the server computer (called by the UI). This
// may or may not prompt the user with UI and returns the pointer
// to the new group after adding it to the group list
CNATGroup* CNATServerComputer::NewGroup()
    {
    // for now, make a group with just all the defaults
    CNATGroup* pG = new CNATGroup( this );
    if ( pG == NULL )
        {
        AfxMessageBox( IDS_LOWMEM );
        return NULL;
        }

    // Ask the user to edit the group's properties. Do not add it if they cancel
    if ( !pG->OnProperties() )
        {
        delete pG;
        return NULL;
        }

    // add the object to the end of the array
    m_rgbGroups.Add( pG );
    return pG;
    }

//-------------------------------------------------------------------------
// add a new computer to the sites list. - Note: if the computer
// already exists in the sites list, it will just return a reference
// to the existing computer. This routine prompts the user to choose
// a computer to add. Returns FALSE if it fails.
CNATSiteComputer* CNATServerComputer::NewComputer()
    {
    // Ask the user for the machine to connect to.
    CConnectDlg dlgConnect;
    if ( dlgConnect.DoModal() == IDCANCEL )
        return NULL;

    // check if it is visible
    BOOL bVisible = CanSeeComputer( (LPCTSTR)dlgConnect.m_cstring_name );

    // for now, make a group with just all the defaults
    CNATSiteComputer* pSC = new CNATSiteComputer( (LPCTSTR)dlgConnect.m_cstring_name, bVisible );
    if ( pSC == NULL )
        {
        AfxMessageBox( IDS_LOWMEM );
        return NULL;
        }

    // add the object to the end of the array
    m_rgbSiteComputers.Add( pSC );
    return pSC;
    }

//-------------------------------------------------------------------------
// adds an existing computer to the list - to be called during a refresh.
// this checks the visiblity of the machine on the net as it adds it
void CNATServerComputer::AddSiteComputer( LPWSTR pszwName )
    {
    // check if the named computer is visible on the network
    BOOL bVisible = CanSeeComputer( pszwName );

    // create the new Site Computer object
    CNATSiteComputer* pSC = new CNATSiteComputer( pszwName, bVisible );
    if ( pSC == NULL )
        {
        AfxMessageBox( IDS_LOWMEM );
        return;
        }

    // add the object to the end of the array
    m_rgbSiteComputers.Add( pSC );
    }

//-------------------------------------------------------------------------
// adds an existing group to the list - to be called during a refresh.
void CNATServerComputer::AddGroup( LPWSTR pszwIPPublic, LPWSTR pszwName, DWORD dwSticky, DWORD type )
    {
    // create the new Site Computer object
    CNATGroup* pG = new CNATGroup( this, pszwIPPublic, pszwName, dwSticky, type );
    if ( pG == NULL )
        {
        AfxMessageBox( IDS_LOWMEM );
        return;
        }

    // add the object to the end of the array
    m_rgbGroups.Add( pG );
    }

//-------------------------------------------------------------------------
// gets the hash of the NAT data blob. If a null pointer to the blob
// is passed in, then it dynamically gets the blob from the server
// or you can pass in a specific blob. This is to be used to check if
// the state of the server has changed since the data was last loaded.
// The hash is obtained from the crypto code so it is really good. The
// buffer for the hash should be 128 bits in length. Using an MD5 hash.
BOOL CNATServerComputer::GetNATStateHash( IN LPBYTE pData, IN DWORD cbData,
                                         OUT LPBYTE pHash, IN OUT DWORD* pcbHash )
    {
    HRESULT hRes;
    LPBYTE  pInternalData = NULL;

    // if no data buffer was specified, then we should get a new state blob from the server
    if ( !pData )
        {
        pInternalData = PGetNATStateBlob( &cbData );
        if ( !pInternalData )
            return FALSE;
        pData = pInternalData;
        }

    // get the hash
    hRes = CreateMD5Hash( pData, cbData, pHash, pcbHash );

    // if we allocated an internal buffer, free it now
    if ( pInternalData )
        GlobalFree( pInternalData );

    return SUCCEEDED( hRes );
    }

//-------------------------------------------------------------------------
// access the server and retrieve the state blob. Use GetLastError to see
// what went wrong if the returned result is NULL. Pass in the dword pointed
// to by pcbData to get the required size.
LPBYTE CNATServerComputer::PGetNATStateBlob( OUT DWORD* pcbData )
    {
    HRESULT     hRes;
    IMSIisLb*   pIisLb;
    LPBYTE      pData = NULL;

    // get the interface to the NAT server
    hRes = GetNATInterface( &pIisLb );
    if ( FAILED(hRes) )
        return pData;


    // the first call gets the amout of required space for the blob
    DWORD   dwcb;
    hRes = pIisLb->GetIpList( 0, NULL, &dwcb );

    // if it fails, with anything except too small a buffer, then fail
    if ( FAILED(hRes) && (hRes != ERROR_INSUFFICIENT_BUFFER) )
        goto cleanup;

    // allocate space to receive the blob
    pData = (LPBYTE)GlobalAlloc( GPTR, dwcb );
    if ( !pData )
        {
        AfxMessageBox( IDS_LOWMEM );
        goto cleanup;
        }

    // get the blob
    hRes = pIisLb->GetIpList( dwcb, pData, &dwcb );

    // if it fails, with anything except too small a buffer, then fail
    if ( FAILED(hRes) )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // cleanup
cleanup:
    pIisLb->Release();

    return NULL;
    }

//-------------------------------------------------------------------------
// access the server and set the state blob. Use GetLastError to see what went
// wrong if the returned result is FALSE
BOOL CNATServerComputer::SetStateBlob( IN LPBYTE pData, IN DWORD cbData )
    {
    HRESULT     hRes;
    IMSIisLb*   pIisLb;

    // get the interface to the NAT server
    hRes = GetNATInterface( &pIisLb );
    if ( FAILED(hRes) )
        return FALSE;

    // set the data blob to the server.
    hRes = pIisLb->SetIpList( cbData, (PUCHAR)pData );

    // cleanup
    pIisLb->Release();

    return FALSE;
    }

//-------------------------------------------------------------------------
// open the DCOM interface to the target NAT machine.
HRESULT CNATServerComputer::GetNATInterface( IMSIisLb** ppIisLb )
    {
    COSERVERINFO            csiMachineName;
    LPSTR                   pszMachineName = NULL;
    IClassFactory*          pcsfFactory = NULL;
    HRESULT                 hRes = 0;

    //fill the structure for CoCreateInstanceEx
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    csiMachineName.pwszName = NULL;

    // get the class factory
    hRes = CoGetClassObject(CLSID_MSIisLb, CLSCTX_SERVER, &csiMachineName,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if ( SUCCEEDED( hRes ) )
        {
        // the instance of the load balancing interface
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSIisLb, (void **)ppIisLb);
        // clean up the class factory
        pcsfFactory->Release();
        }

    // if there was an error, tell the user
    if ( FAILED( hRes ) )
        {
        AfxMessageBox( IDS_NOLBCONNECT );
        }

    return hRes;
    }

//-------------------------------------------------------------------------
// utility to check if the computer is visible on the net
BOOL CNATServerComputer::CanSeeComputer( LPCTSTR pszname )
    {
    // if no name is passed in, then it is the local machine. return true
    if ( (pszname == NULL) || (*pszname == 0 ) )
        return TRUE;

    // until I can figure out a way to ping the address via TCP/IP, 
    // attempt to connect to registry.
    HKEY    hkResult;
    LONG    err;
    err = RegConnectRegistry(
                pszname,                // address of name of remote computer  
                HKEY_LOCAL_MACHINE,     // predefined registry handle  
                &hkResult               // address of buffer for remote registry handle  
                ); 
    
    // clean up
    if ( err == ERROR_SUCCESS )
        CloseHandle( hkResult );
    
    // return whether or not it worked
    return ( err == ERROR_SUCCESS );
    }

//-------------------------------------------------------------------------
// function is courtesy Alex Mallet (amallet)
HRESULT CreateMD5Hash( IN PBYTE pbData,
                       IN DWORD cbData,
                       OUT PBYTE pbHashBuffer,
                       IN OUT DWORD *pdwHashBufferSize )
/*++

Routine Description:

     Creates MD5 hash of data 

Arguments:

     pbData - buffer of data to be hashed
     cbData - size of data to be hashed
     pbHashBuffer - buffer to receive hash
     pdwHashBufferSize - size of pbHashBuffer

Returns:

     HRESULT indicating success/failure

--*/

{
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    HRESULT hRes = S_OK;

    //
    // Get a handle to the CSP that will create the
    // hash
    if ( !CryptAcquireContext( &hProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

    //
    // Get a handle to an MD5 hash object
    //
    if ( !CryptCreateHash( hProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
      hRes = RETURNCODETOHRESULT( GetLastError() );  
      goto EndCreateHash;
    }

    //
    // Hash the data
    //
    if ( !CryptHashData( hHash,
                         pbData,
                         cbData,
                         0 ) )
    {
        hRes =  RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

    //
    // Retrieve the hash
    //
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             pbHashBuffer,
                             pdwHashBufferSize,
                             0 ) )
    {
        hRes = RETURNCODETOHRESULT( GetLastError() );
        goto EndCreateHash;
    }

EndCreateHash:
    //
    //Cleanup
    //
    if ( hHash )
    {
        CryptDestroyHash( hHash );
    }

    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\extndppg.cpp ===
// ExtndPpg.cpp : Implementation of the CExtndPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "ExtndPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CExtndPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CExtndPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CExtndPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CExtndPropPage, "LOGUI.ExtndPropPage.1",
	0x68871e4a, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::CExtndPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CExtndPropPage

BOOL CExtndPropPage::CExtndPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_EXTND_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::CExtndPropPage - Constructor

CExtndPropPage::CExtndPropPage() :
	COlePropertyPage(IDD, IDS_EXTND_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CExtndPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::DoDataExchange - Moves data between page and properties

void CExtndPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CExtndPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\lbcfg\natgroup.cpp ===
#include "stdafx.h"
#include "natobjs.h"
#include "resource.h"


//-------------------------------------------------------------------------
CNATGroup::CNATGroup( CNATServerComputer* pNatComputer, LPCTSTR pszIP,
                     LPCTSTR pszName, DWORD dwSticky, DWORD type ):
        m_pNatComputer(pNatComputer),
        m_dwSticky(dwSticky),
        m_type(type)
    {
    m_csIP = pszIP;
    m_csName = pszName;
    }

//-------------------------------------------------------------------------
CNATGroup::~CNATGroup()
    {
    // clean up the site array
    EmptySites();
    }

//-------------------------------------------------------------------------
// Edit the properties of this Site - true if OK
BOOL CNATGroup::OnProperties()
    {
    return TRUE;
    }

//-------------------------------------------------------------------------
// This is just a handy way to get the nat machine object to commit
void CNATGroup::Commit()
    {
    if ( m_pNatComputer )
        m_pNatComputer->Commit();
    }

//-------------------------------------------------------------------------
// adds a new site to the list.
// think about making this a wizard
CNATSite* CNATGroup::NewSite()
    {
    CNATSiteComputer* pSC = NULL;
    // ask the nat server object for a site computer
    pSC = m_pNatComputer->NewComputer();
    if ( !pSC )
        return NULL;

    // for now, make a site with the defaults
    CNATSite* pS = new CNATSite( this, pSC );
    if ( pS == NULL )
        {
        AfxMessageBox( IDS_LOWMEM );
        return NULL;
        }

    // Ask the user to edit the group's properties.
    // Do not add it if they cancel
    if ( !pS->OnProperties() )
        {
        delete pS;
        return NULL;
        }

    // add the object to the end of the array
    m_rgbSites.Add( pS );
    return pS;
    }

//-------------------------------------------------------------------------
// adds an existing site to the list - to be called during a refresh.
// this checks the visiblity of the machine on the net as it adds it
void CNATGroup::AddSite( CNATSiteComputer* pSiteComputer, LPCTSTR pszPrivateIP, IN LPCTSTR pszName )
    {
    // create the new Site Computer object
    CNATSite* pS = new CNATSite( this, pSiteComputer, pszPrivateIP, pszName );
    if ( pS == NULL )
        {
        AfxMessageBox( IDS_LOWMEM );
        return;
        }

    // add the object to the end of the array
    m_rgbSites.Add( pS );
    }

//-------------------------------------------------------------------------
// empties and frees all the groups/sites in the groups list
void CNATGroup::EmptySites()
    {
    DWORD   numSites = m_rgbSites.GetSize();

    // loop the array and free all the group objects
    for ( DWORD i = 0; i < numSites; i++ )
        {
        delete m_rgbSites[i];
        }

    // empty the array itself
    m_rgbSites.RemoveAll();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\helpmap.h ===
// helpmaps for the logui project - handmade

#define HIDD_LOGUI_GENERIC                      0x50200
#define HIDD_LOGUI_EXTENDED						0x50201
#define HIDD_LOGUI_ODBC							0x50202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\cnfrmpsd.cpp ===
// CnfrmPsD.cpp : implementation file
//

#include "stdafx.h"
#include "logui.h"
#include "CnfrmPsD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfirmPassDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CConfirmPassDlg)
	m_sz_password_new = _T("");
	//}}AFX_DATA_INIT
    }

void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmPassDlg)
	DDX_Text(pDX, IDC_ODBC_CONFIRM_PASSWORD, m_sz_password_new);
	//}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmPassDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers

void CConfirmPassDlg::OnOK() 
    {
    UpdateData( TRUE );

    // confirm it
    if ( m_sz_password_new != m_szOrigPass )
        {
        AfxMessageBox( IDS_PASS_CONFIRM_FAIL );
        return;
        }

    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\cnfrmpsd.h ===
// CnfrmPsD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
	CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

    // the original password that we are confirming
    CString m_szOrigPass;

// Dialog Data
	//{{AFX_DATA(CConfirmPassDlg)
	enum { IDD = IDD_CONFIRM_ODBC_PASSWORD };
	CString	m_sz_password_new;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfirmPassDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfirmPassDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\dcomperm.cpp ===
#include "stdafx.h"

#include <conio.h>
#include "dcomperm.h"

#define _WIN32_DCOM
#include <objbase.h>

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        delete [] newACL;
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        delete [] newACL;
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        delete [] newACL;
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        delete [] newACL;
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);

        if (tokenUser == NULL) {
            dwReturn = E_OUTOFMEMORY;
        }
        else if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
        
            if (*Sid == NULL) {
                dwReturn = E_OUTOFMEMORY;
            }
            else {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
                CloseHandle (tokenHandle);
            }
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    CString csPrincipal = Principal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    csPrincipal.MakeLower();
    if ( csPrincipal.Find(_T("administrators")) != -1 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if (csPrincipal.Find(_T("system")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if (csPrincipal.Find(_T("interactive")) != -1) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if (csPrincipal.Find(_T("everyone")) != -1) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid = NULL;
    PSID    groupSID = NULL;
    PSID    ownerSID = NULL;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);

        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal); 
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);

     return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);

    return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
    
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\extndppg.h ===
// ExtndPpg.h : Declaration of the CExtndPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CExtndPropPage : See ExtndPpg.cpp.cpp for implementation.

class CExtndPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CExtndPropPage)
	DECLARE_OLECREATE_EX(CExtndPropPage)

// Constructor
public:
	CExtndPropPage();

// Dialog Data
	//{{AFX_DATA(CExtndPropPage)
	enum { IDD = IDD_PROPPAGE_EXTND };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CExtndPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logadvpg.cpp ===
// LogAdvPg.cpp : implementation file
//

#include "stdafx.h"
#include "logui.h"
#include "wrapmb.h"
#include <iiscnfg.h>
#include <metatool.h>

#include "LogAdvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Possible Item States
//

#define TVIS_GCEMPTY        0 
#define TVIS_GCNOCHECK      1 
#define TVIS_GCCHECK        2
#define TVIS_GCTRINOCHECK   3
#define TVIS_GCTRICHECK     4

#define STATEIMAGEMASKTOINDEX(i) ((i) >> 12)

static int CALLBACK LogUICompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	// lParamSort contains a pointer to the tree control

	CLogAdvanced::PCONFIG_INFORMATION pCnfgInfo1 = (CLogAdvanced::PCONFIG_INFORMATION) lParam1;
	CLogAdvanced::PCONFIG_INFORMATION pCnfgInfo2 = (CLogAdvanced::PCONFIG_INFORMATION) lParam2;

	CTreeCtrl* pTreeCtrl = (CTreeCtrl*) lParamSort;

	if (pCnfgInfo1->iOrder < pCnfgInfo2->iOrder)
		return(-1);
	else if (pCnfgInfo1->iOrder > pCnfgInfo2->iOrder)
		return(1);
	else	
		return(0);
}

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced property page

IMPLEMENT_DYNCREATE(CLogAdvanced, CPropertyPage)

CLogAdvanced::CLogAdvanced() : CPropertyPage(CLogAdvanced::IDD)
{
	//{{AFX_DATA_INIT(CLogAdvanced)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_mapLogUI["Date  ( date )"] = IDS_DATE;
    m_mapLogUI["Time  ( time )"] = IDS_TIME;
    m_mapLogUI["Extended Properties"] = IDS_EXTENDED;
    m_mapLogUI["Client IP Address  ( c-ip )"] = IDS_CLIENT;
    m_mapLogUI["User Name  ( cs-username )"] = IDS_USER;
    m_mapLogUI["Service Name  ( s-sitename )"] = IDS_SERVICE_NAME_T;
    m_mapLogUI["Server Name  ( s-computername )"] = IDS_SERVER_NAME_T;
    m_mapLogUI["Server IP Address  ( s-ip )"] = IDS_SERVER_IP;
    m_mapLogUI["Server Port  ( s-port )"] = IDS_SERVER_PORT;
    m_mapLogUI["Method  ( cs-method )"] = IDS_METHOD;
    m_mapLogUI["URI Stem  ( cs-uri-stem )"] = IDS_URI_STEM;
    m_mapLogUI["URI Query  ( cs-uri-query )"] = IDS_URI_QUERY;
    m_mapLogUI["Protocol Status  ( sc-status )"] = IDS_PROTOCOL;
    m_mapLogUI["Win32 Status  ( sc-win32-status )"] = IDS_WIN32;               
    m_mapLogUI["Bytes Sent  ( sc-bytes )"] = IDS_BYTES_SENT_T;
    m_mapLogUI["Bytes Received  ( cs-bytes )"] = IDS_BYTES_RECEIVED;
    m_mapLogUI["Time Taken  ( time-taken )"] = IDS_TIME_TAKEN;
    m_mapLogUI["Protocol Version  ( cs-version )"] = IDS_PROTOCOL_VER;
    m_mapLogUI["Host  ( cs-host )"] = IDS_HOST;
    m_mapLogUI["User Agent  ( cs(User-Agent) )"] = IDS_USER_AGENT;
    m_mapLogUI["Cookie  ( cs(Cookie) )"] = IDS_COOKIE_T;
    m_mapLogUI["Referer  ( cs(Referer) )"] = IDS_REFERER;
    m_mapLogUI["Process Accounting"] = IDS_PROCESS_ACCT;
    m_mapLogUI["Process Event  ( s-event )"] = IDS_PROCESS_EVENT;
    m_mapLogUI["Process Type  ( s-process-type )"] = IDS_PROCESS_TYPE;
    m_mapLogUI["Total User Time  ( s-user-time )"] = IDS_TOTAL_USER_TIME;
    m_mapLogUI["Total Kernel Time  ( s-kernel-time )"] = IDS_TOTAL_KERNEL_TIME;
    m_mapLogUI["Total Page Faults  ( s-page-faults )"] = IDS_TOTAL_PAGE_FAULTS;
    m_mapLogUI["Total Processes  ( s-total-procs )"] = IDS_TOTAL_PROCESSES;
    m_mapLogUI["Active Processes  ( s-active-procs )"] = IDS_ACTIVE_PROCESSES;
    m_mapLogUI["Total Terminated Processes  ( s-stopped-procs )"] = IDS_TOTAL_TERM_PROCS;

	m_mapLogUIOrder[IDS_DATE] = 1;
    m_mapLogUIOrder[IDS_TIME] = 2;
    m_mapLogUIOrder[IDS_EXTENDED] = 3;
    m_mapLogUIOrder[IDS_PROCESS_ACCT] = 4;

    m_mapLogUIOrder[IDS_CLIENT] = 1;
    m_mapLogUIOrder[IDS_USER] = 2;
    m_mapLogUIOrder[IDS_SERVICE_NAME_T] = 3;
    m_mapLogUIOrder[IDS_SERVER_NAME_T] = 4;
    m_mapLogUIOrder[IDS_SERVER_IP] = 5;
    m_mapLogUIOrder[IDS_SERVER_PORT] = 6;
    m_mapLogUIOrder[IDS_METHOD] = 7;
    m_mapLogUIOrder[IDS_URI_STEM] = 8;
    m_mapLogUIOrder[IDS_URI_QUERY] = 9;
    m_mapLogUIOrder[IDS_PROTOCOL] = 10;
    m_mapLogUIOrder[IDS_WIN32] = 11;               
    m_mapLogUIOrder[IDS_BYTES_SENT_T] = 12;
    m_mapLogUIOrder[IDS_BYTES_RECEIVED] = 13;
    m_mapLogUIOrder[IDS_TIME_TAKEN] = 14;
    m_mapLogUIOrder[IDS_PROTOCOL_VER] = 15;
    m_mapLogUIOrder[IDS_HOST] = 16;
    m_mapLogUIOrder[IDS_USER_AGENT] = 17;
    m_mapLogUIOrder[IDS_COOKIE_T] = 18;
    m_mapLogUIOrder[IDS_REFERER] = 19;

    m_mapLogUIOrder[IDS_PROCESS_EVENT] = 1;
    m_mapLogUIOrder[IDS_PROCESS_TYPE] = 2;
    m_mapLogUIOrder[IDS_TOTAL_USER_TIME] = 3;
    m_mapLogUIOrder[IDS_TOTAL_KERNEL_TIME] = 4;
    m_mapLogUIOrder[IDS_TOTAL_PAGE_FAULTS] = 5;
    m_mapLogUIOrder[IDS_TOTAL_PROCESSES] = 6;
    m_mapLogUIOrder[IDS_ACTIVE_PROCESSES] = 7;
    m_mapLogUIOrder[IDS_TOTAL_TERM_PROCS] = 8;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogAdvanced)
	DDX_Control(pDX, IDC_PROP_TREE, m_wndTreeCtrl);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CLogAdvanced, CPropertyPage)
	//{{AFX_MSG_MAP(CLogAdvanced)
	ON_NOTIFY(NM_CLICK, IDC_PROP_TREE, OnClickTree)
	ON_NOTIFY(TVN_KEYDOWN, IDC_PROP_TREE, OnKeydownTree)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced message handlers

BOOL CLogAdvanced::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    m_cImageList.Create(IDB_CHECKBOX, ::GetSystemMetrics (SM_CXICON)/2, 3, RGB (255,0,0));
    m_wndTreeCtrl.SetImageList(&m_cImageList, TVSIL_STATE);

    CreateTreeFromMB();
    ProcessProperties(false);
	
    //
    // set up the modified property list array
    //
    
    m_fTreeModified = false;
    m_cModifiedProperties = 0;
    
    int cProperties = m_wndTreeCtrl.GetCount();

    m_pModifiedPropIDs[0] = new DWORD[cProperties];
    m_pModifiedPropIDs[1] = new DWORD[cProperties];

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnClickTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwpos;
    TV_HITTESTINFO tvhti;
    HTREEITEM  htiItemClicked;
    POINT point;

    //
    // Find out where the cursor was
    //

    dwpos = GetMessagePos();
    point.x = LOWORD(dwpos);
    point.y = HIWORD(dwpos);

    ::MapWindowPoints(HWND_DESKTOP, m_wndTreeCtrl.m_hWnd, &point, 1);

    tvhti.pt = point;
    htiItemClicked = m_wndTreeCtrl.HitTest(&tvhti);

    //
    // If the state image was clicked, lets get the state from the item and toggle it.
    //

    if (tvhti.flags & TVHT_ONITEMSTATEICON)
    {
        ProcessClick(htiItemClicked);
    }

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnKeydownTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;
    
    if ( 0x20 != pTVKeyDown->wVKey)
    {
        // User didn't press the space key. Continue default action

        *pResult = 0;
        return;
    }
    
    ProcessClick(m_wndTreeCtrl.GetSelectedItem());

    //
    // Stop any more processing
    //
    
    *pResult = 1;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::ProcessClick( HTREEITEM htiItemClicked)
{
    TV_ITEM                 tvi;
    UINT                    state;
    HTREEITEM               htiChild;
    PCONFIG_INFORMATION     pCnfg;
    
    if(htiItemClicked)
    {

        //
        // Flip the state of the clicked item if the item is enabled
        //

        tvi.hItem       = htiItemClicked;
        tvi.mask        = TVIF_STATE;
        tvi.stateMask   = TVIS_STATEIMAGEMASK;

        m_wndTreeCtrl.GetItem(&tvi); 

        state = STATEIMAGEMASKTOINDEX(tvi.state);
        pCnfg = (PCONFIG_INFORMATION)(tvi.lParam);

        htiChild = m_wndTreeCtrl.GetNextItem(htiItemClicked, TVGN_CHILD);


        if ( TVIS_GCNOCHECK == state )
        {
            tvi.state = INDEXTOSTATEIMAGEMASK (TVIS_GCCHECK) ;
            pCnfg->fItemModified = true;
            
            m_wndTreeCtrl.SetItem(&tvi);
    
            m_fTreeModified = true;
            SetModified();

            // Reset properties for child nodes

            if (htiChild)
            {
                SetSubTreeProperties(NULL, htiChild, TRUE, FALSE);
            }
        }
        else if ( TVIS_GCCHECK == state )
        {
            tvi.state = INDEXTOSTATEIMAGEMASK (TVIS_GCNOCHECK) ;
            pCnfg->fItemModified = true;
            
            m_wndTreeCtrl.SetItem(&tvi);

            m_fTreeModified = true;
            SetModified();

            // Reset properties for child nodes

            if (htiChild)
            {
                SetSubTreeProperties(NULL, htiChild, FALSE, FALSE);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::ProcessProperties(bool fSave)
{
    CWrapMetaBase   mbWrap;
    HTREEITEM       hRoot;


    if ( NULL == (hRoot = m_wndTreeCtrl.GetRootItem()))
    {
        return;
    }

    // Initialize MB wrapper

    if ( !mbWrap.FInit(m_pMB) ) 
    {
        return;
    }
    
    if (fSave && m_fTreeModified && (mbWrap.Open(m_szMeta, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE)))
    {
        m_cModifiedProperties = 0;
        
        SaveSubTreeProperties(mbWrap, hRoot);

        mbWrap.Close();

        //
        // Now we need to throw an inheritance dialog for each of these modified properties
        //

        for(int i=0; i < m_cModifiedProperties; i++)
        {
            //
            // Set the value and check inheritance.
            //

            SetMetaDword(m_pMB, m_szServer, m_szMeta, _T(""), m_pModifiedPropIDs[0][i],
                                IIS_MD_UT_SERVER, m_pModifiedPropIDs[1][i], TRUE);
        }

        m_fTreeModified = false;
    }
    else if ( mbWrap.Open(m_szMeta, METADATA_PERMISSION_READ) )
    {
        SetSubTreeProperties(&mbWrap, hRoot, TRUE, TRUE);
        mbWrap.Close();
    }
}

/////////////////////////////////////////////////////////////////////////////


void CLogAdvanced::SetSubTreeProperties(CWrapMetaBase * pMBWrap, HTREEITEM hTreeRoot, 
                                        BOOL fParentState, BOOL fInitialize)
{
    HTREEITEM           hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    UINT                iState;
    DWORD               dwProperty = 0;
    
    if (NULL == hTreeRoot)
    {
        return;
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
    
    if ( NULL != pCnfg)
    {
        if (fInitialize)
        {
            //
            // Read property state from Metabase.
            //
            if (pMBWrap->GetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, &dwProperty))
            {
                dwProperty &= pCnfg->dwPropertyMask;
            }
        }
        else
        {
            //
            // we are not initializing, so use the value from the tree
            //

            iState = STATEIMAGEMASKTOINDEX(m_wndTreeCtrl.GetItemState(hTreeRoot, TVIS_STATEIMAGEMASK));

            if ( (TVIS_GCCHECK == iState) || (TVIS_GCTRICHECK == iState))
            {
                dwProperty = TRUE;
            }
            else
            {
                dwProperty = FALSE;
            }
        }

        //
        // Choose the new state depending on parent state
        //

        if (fParentState)
        {
            iState = ( 0 == dwProperty) ?   INDEXTOSTATEIMAGEMASK(TVIS_GCNOCHECK) :
                                            INDEXTOSTATEIMAGEMASK(TVIS_GCCHECK);
        }
        else
        {
            iState = ( 0 == dwProperty) ?   INDEXTOSTATEIMAGEMASK(TVIS_GCTRINOCHECK) :
                                            INDEXTOSTATEIMAGEMASK(TVIS_GCTRICHECK);
        }

        m_wndTreeCtrl.SetItemState(hTreeRoot, iState, TVIS_STATEIMAGEMASK);
    }
    else
    {
        //
        // Tree node with no checkbox (hence no config info)
        //

        dwProperty = TRUE;
        m_wndTreeCtrl.SetItemState(hTreeRoot, INDEXTOSTATEIMAGEMASK(TVIS_GCEMPTY), TVIS_STATEIMAGEMASK);
    }
    
    //
    // Recurse through children and siblings
    //

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        if ( dwProperty && fParentState)
        {
            SetSubTreeProperties(pMBWrap, hTreeChild, TRUE, fInitialize);
        }
        else
        {
            SetSubTreeProperties(pMBWrap, hTreeChild, FALSE, fInitialize);
        }
    }


    if ( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        SetSubTreeProperties(pMBWrap, hTreeSibling, fParentState, fInitialize);
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::SaveSubTreeProperties(CWrapMetaBase& mbWrap, HTREEITEM hTreeRoot)
{
    HTREEITEM           hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    
    if (NULL == hTreeRoot)
    {
        return;
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));

    if ((NULL != pCnfg) && ( pCnfg->fItemModified))
    {
        //
        // There is configuration Information. Write to Metabase.
        //

        UINT NewState = STATEIMAGEMASKTOINDEX(m_wndTreeCtrl.GetItemState(hTreeRoot, TVIS_STATEIMAGEMASK));

        if ( (TVIS_GCNOCHECK <= NewState) && (TVIS_GCTRICHECK >= NewState) )
        {
            //
            // Get the property, reset the bit mask & write it back
            //

            DWORD   dwProperty = 0;

            //
            // Get modified value from array if it exists
            //

            if ( !GetModifiedFieldFromArray(pCnfg->dwPropertyID, &dwProperty))
            {
                mbWrap.GetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, &dwProperty);
            }
            
            //
            // 0 the appropriate bit & then set it depending on the item state
            //
            
            dwProperty &= ~(pCnfg->dwPropertyMask);

            if ((TVIS_GCCHECK == NewState) || (TVIS_GCTRICHECK == NewState))
            {
                dwProperty |= pCnfg->dwPropertyMask;
            }

            // mbWrap.SetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, dwProperty);

            InsertModifiedFieldInArray(pCnfg->dwPropertyID, dwProperty);
        }
    }
    
    //
    // Recurse through children and siblings
    //

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        SaveSubTreeProperties(mbWrap, hTreeChild);
    }

    if( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        SaveSubTreeProperties(mbWrap, hTreeSibling);
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DeleteSubTreeConfig(HTREEITEM hTreeRoot)
{
    HTREEITEM           hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;


    if (NULL == hTreeRoot)
    {
        return;
    }

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        DeleteSubTreeConfig(hTreeChild);
    }

    if ( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        DeleteSubTreeConfig(hTreeSibling);
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
    
    if (pCnfg)
    {
        delete pCnfg;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::CreateTreeFromMB()
{
    TCHAR           szLoggingUIPath[] = _T("/LM/Logging/Custom Logging");
    CWrapMetaBase   mbWrap;

    // Initialize MB wrapper

    if ( !mbWrap.FInit(m_pMB) ) 
    {
        return;
    }

    //
    // open the logging UI path & create the UI tree
    //

    if ( mbWrap.Open(szLoggingUIPath, METADATA_PERMISSION_READ ) )
    {
        CreateSubTree(mbWrap, _T(""), NULL);
    }

    mbWrap.Close();
    m_wndTreeCtrl.EnsureVisible(m_wndTreeCtrl.GetRootItem());
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::CreateSubTree(CWrapMetaBase& mbWrap, LPTSTR szPath, HTREEITEM hTreeRoot)
{
    int     index = 0;
    TCHAR   szChildName[256];
	TCHAR	szLocalizedChildName[256];
    TCHAR   szW3CHeader[256]    = _T("");
    TCHAR   szNewPath[256]      = _T("");

    TV_ITEM             tvi;
    TV_INSERTSTRUCT     tvins;
    HTREEITEM           hChild = NULL;

    PCONFIG_INFORMATION pCnfgInfo;

    // Prepare the item for insertion

    tvi.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
    tvi.state          = INDEXTOSTATEIMAGEMASK(TVIS_GCEMPTY) ;
    tvi.stateMask      = TVIS_STATEIMAGEMASK;

    tvins.hParent      = hTreeRoot;
    tvins.hInsertAfter = TVI_LAST;

    while( mbWrap.EnumObjects(szPath, szChildName, index) )
    {
        DWORD   size;
        DWORD   dwPropertyID, dwPropertyMask;

        //
        // Create the new path.
        //

        lstrcpy(szNewPath, szPath);
        lstrcat(szNewPath,_T("\\"));
        lstrcat(szNewPath, szChildName);

        //
        // Check if these properties are available to the requesting service
        //

        TCHAR   szSupportedServices[256] = _T("");

        size = 256;
            
        if ( (! mbWrap.GetMultiSZString(szNewPath, MD_LOGCUSTOM_SERVICES_STRING, 
                                        IIS_MD_UT_SERVER, szSupportedServices, &size)) ||
             (! IsPresentServiceSupported(szSupportedServices))
           )
        {
            //
            // This property is not supported by this service. Skip the node
            //

            index++;
            continue;
        }

        //
        // Copy configuration information into internal structures & 
        // insert it into tree control for future use.
        //

        //
        // Don't zero out the child name. In case we are unable to retrieve the localized
        // name from the MetaBase, just use the name used in the path.
        //

        size = 256;
        mbWrap.GetString(szNewPath, MD_LOGCUSTOM_PROPERTY_NAME, IIS_MD_UT_SERVER, 
                         szChildName, &size, 0);   // name not inheritable

        szW3CHeader[0] = 0;
        size = 256;
        
        mbWrap.GetString(szNewPath, MD_LOGCUSTOM_PROPERTY_HEADER, IIS_MD_UT_SERVER, 
                        szW3CHeader, &size, 0);   // header not inheritable

        pCnfgInfo = new CONFIG_INFORMATION;

        // if we fail memory alloc, then simply break the loop

        if (pCnfgInfo == NULL) {
            break;
        }

        if ( mbWrap.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_ID, IIS_MD_UT_SERVER, 
                                &dwPropertyID) &&
             mbWrap.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_MASK, IIS_MD_UT_SERVER, 
                                &dwPropertyMask)
            )
        {
            pCnfgInfo->dwPropertyID     = dwPropertyID;
            pCnfgInfo->dwPropertyMask   = dwPropertyMask;
        }
	   	else
	   	{
	   		pCnfgInfo->dwPropertyID 	= NULL;
			pCnfgInfo->dwPropertyMask 	= NULL;
	   	}

        pCnfgInfo->fItemModified    = false;

        //
        // Append the W3C Header to the name and add this node to the Tree Control.
        //

        if ( 0 != szW3CHeader[0])
        {
            lstrcat(szChildName,_T("  ( ") );
            lstrcat(szChildName,szW3CHeader);
            lstrcat(szChildName,_T(" )") );
        }

        int iOrder = LocalizeUIString(szChildName, szLocalizedChildName);
		tvi.pszText = szLocalizedChildName;

        pCnfgInfo->iOrder	= iOrder;
        tvi.lParam  		= (LPARAM)pCnfgInfo;

        tvins.item  = tvi;
        hChild      = m_wndTreeCtrl.InsertItem((LPTV_INSERTSTRUCT) &tvins);

        //
        // Enumerate children
        //

        CreateSubTree(mbWrap, szNewPath, hChild);
        
        index++;
    }

    if (0 != index) 
    {
        m_wndTreeCtrl.Expand(hTreeRoot, TVE_EXPAND);
    }

	// Now sort the tree from subtree root down
	TVSORTCB tvs;
	tvs.hParent = hTreeRoot;
	tvs.lpfnCompare = LogUICompareProc;
	tvs.lParam = (LPARAM) &m_wndTreeCtrl;
	m_wndTreeCtrl.SortChildrenCB(&tvs);
}

/////////////////////////////////////////////////////////////////////////////

int CLogAdvanced::LocalizeUIString(LPCTSTR szOrig, LPTSTR szLocalized)
{
	int iStringID = m_mapLogUI[szOrig];

	if (iStringID < 1) 
	{
		lstrcpy(szLocalized, szOrig);
		// need to return a number greater than the number of properties in the tree
		// 10000 seems reasonable
		return(10000);  
	}

	else
	{
		::LoadString((HINSTANCE)GetWindowLongPtr(m_wndTreeCtrl, GWLP_HINSTANCE), iStringID, szLocalized, 256);
		return(m_mapLogUIOrder[iStringID]);
		
	}
}

/////////////////////////////////////////////////////////////////////////////

bool CLogAdvanced::IsPresentServiceSupported(LPTSTR szSupportedServices)
{
    while ( szSupportedServices[0] != 0) 
    {
        if ( 0 == lstrcmpi(m_szServiceName, szSupportedServices) )
        {
            return true;
        }

        szSupportedServices += lstrlen(szSupportedServices)+1;
    }

    return false;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CLogAdvanced::OnApply() 
{
    //
    // Save the state of the tree into the metabase
    //

    ProcessProperties(true);
	
    return CPropertyPage::OnApply();
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DoHelp()
{
    WinHelp( HIDD_LOGUI_EXTENDED );
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::InsertModifiedFieldInArray(DWORD dwPropID, DWORD dwPropValue)
{
    int     index;
    bool    fFound = false;
    
    if (m_pModifiedPropIDs[0])
    {
        //
        // Search if this property ID pre-exists in the array
        //
        
        for(index = 0; index < m_cModifiedProperties; index++)
        {
            if (dwPropID == m_pModifiedPropIDs[0][index])
            {
                fFound = true;   
                break;
            }   
        }

        if (fFound)
        {
            m_pModifiedPropIDs[1][index] = dwPropValue;
        }
        else
        {
            m_pModifiedPropIDs[0][m_cModifiedProperties] = dwPropID;
            m_pModifiedPropIDs[1][m_cModifiedProperties]= dwPropValue;
            m_cModifiedProperties++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

bool CLogAdvanced::GetModifiedFieldFromArray(DWORD dwPropID, DWORD * pdwPropValue)
{
    int     index;
    bool    fFound = false;
    
    if (m_pModifiedPropIDs[0])
    {
        //
        // Search if this property ID pre-exists in the array
        //
        
        for(index = 0; index < m_cModifiedProperties; index++)
        {
            if (dwPropID == m_pModifiedPropIDs[0][index])
            {
                fFound = true;   
                break;
            }   
        }

        if (fFound)
        {
            *pdwPropValue = m_pModifiedPropIDs[1][index];
        }
    }

    return fFound;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnDestroy() 
{
	CPropertyPage::OnDestroy();

    //
    // Delete all the CONFIG_INFORMATION structures
    //

    DeleteSubTreeConfig(m_wndTreeCtrl.GetRootItem());

    delete [] m_pModifiedPropIDs[0];
    delete [] m_pModifiedPropIDs[1];
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logadvpg.h ===
#if !defined(AFX_LOGADVCPG_H__1821FE96_9846_11D1_8B99_080009DCC2FA__INCLUDED_)
#define AFX_LOGADVCPG_H__1821FE96_9846_11D1_8B99_080009DCC2FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LogAdvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced dialog

class CLogAdvanced : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogAdvanced)

// Construction
public:
	CLogAdvanced();

	typedef struct _CONFIG_INFORMATION_
	{
	    DWORD   dwPropertyID;
	    DWORD   dwPropertyMask;
	    bool    fItemModified;
		int		iOrder;

	}   CONFIG_INFORMATION, *PCONFIG_INFORMATION;

    //
    // metabase target
    //

    CString     m_szServer;
    CString     m_szMeta;
    CString     m_szServiceName;

    IMSAdminBase* m_pMB;

// Dialog Data
	//{{AFX_DATA(CLogAdvanced)
	enum { IDD = IDD_LOG_ADVANCED };
	CTreeCtrl	m_wndTreeCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogAdvanced)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    CImageList  m_cImageList;
    bool        m_fTreeModified;
    
    int         m_cModifiedProperties;
    DWORD       *m_pModifiedPropIDs[2];

    void CreateTreeFromMB();
    void CreateSubTree(CWrapMetaBase& mbWrap, LPTSTR szPath, HTREEITEM hTreeRoot);

    void ProcessClick( HTREEITEM htiItemClicked);

    void ProcessProperties(bool fSave);
    void SetSubTreeProperties(CWrapMetaBase * pMBWrap, HTREEITEM hTreeRoot, BOOL fParentState, BOOL fInitialize);
    void SaveSubTreeProperties(CWrapMetaBase& mbWrap, HTREEITEM hTreeRoot);

    void InsertModifiedFieldInArray(DWORD dwPropID, DWORD dwPropValue);
    bool GetModifiedFieldFromArray(DWORD dwPropID, DWORD * pdwPropValue);
    
    bool IsPresentServiceSupported(LPTSTR szSupportedServices);

    void DeleteSubTreeConfig(HTREEITEM hTreeRoot);

    void DoHelp();

	int LocalizeUIString(LPCTSTR szOrig, LPTSTR szLocalized);

	std::map<CString, int> m_mapLogUI;
	std::map<int, int> m_mapLogUIOrder;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGADVCPG_H__1821FE96_9846_11D1_8B99_080009DCC2FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logodbc.h ===
// LogODBC.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogODBC dialog

class CLogODBC : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogODBC)

// Construction
public:
	CLogODBC();
	~CLogODBC();

    // metabase target
    CString     m_szServer;
    CString     m_szMeta;
    IMSAdminBase* m_pMB;

// Dialog Data
	//{{AFX_DATA(CLogODBC)
	enum { IDD = IDD_LOG_ODBC };
	CEdit	m_cedit_password;
	CString	m_sz_datasource;
	CString	m_sz_password;
	CString	m_sz_table;
	CString	m_sz_username;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogODBC)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogODBC)
	afx_msg void OnChangeOdbcDatasource();
	afx_msg void OnChangeOdbcPassword();
	afx_msg void OnChangeOdbcTable();
	afx_msg void OnChangeOdbcUsername();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    void Init();

    // initialized flag
    BOOL    m_fInitialized;

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logtools.cpp ===
// common tools used by the various logging uis

#include "stdafx.h"
#include "logui.h"
#include "logtools.h"





//---------------------------------------------------------------
// Given the class ID of a server, it goes into the registry and
// sets the Apartment Model flag for that object.
// The strings used here are non-localized. They are also specific
// to this routine.
BOOL FSetObjectApartmentModel( REFCLSID clsid )
{
    LPOLESTR    pszwSid;
    LONG        err;
    HKEY        hKey;

    // transform the clsid into a string
    StringFromCLSID(
        clsid, //CLSID to be converted 
        &pszwSid //Address of output variable that receives a pointer to the resulting string 
        );

    // put it in a cstring
    CString szSid = pszwSid;

    // free the ole string
    CoTaskMemFree( pszwSid );

    // build the registry path
    CString szRegPath = _T("CLSID\\");
    szRegPath += szSid;
    szRegPath += _T("\\InProcServer32");

    // prep the apartment name
    CString szApartment = _T("Apartment");

    // open the registry key
    err = RegOpenKey(
            HKEY_CLASSES_ROOT,  // handle of open key  
            (LPCTSTR)szRegPath, // address of name of subkey to open  
            &hKey               // address of handle of open key  
            );
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set the apartment threading value
    err = RegSetValueEx(
            hKey, // handle of key to set value for  
            _T("ThreadingModel"), // address of value to set  
            0, // reserved  
            REG_SZ, // flag for value type  
            (PBYTE)(LPCTSTR)szApartment, // address of value data  
            (szApartment.GetLength() + 1) * sizeof(TCHAR)  // size of value data  
            ); 
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // close the registry key
    RegCloseKey( hKey );

    return TRUE;
}




//---------------------------------------------------------------
// tests a machine name to see if it is the local machine it is
// talking about
BOOL FIsLocalMachine( LPCTSTR psz )
	{
    CString szLocal;
    DWORD   cch = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    fAnswer;

    // get the actual name of the local machine
    fAnswer = GetComputerName(szLocal.GetBuffer(cch), &cch);
    szLocal.ReleaseBuffer();
    if ( !fAnswer )
        return FALSE;

    // compare and return
    fAnswer = (szLocal.CompareNoCase( psz ) == 0);
    return fAnswer;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logtools.h ===
BOOL FSetObjectApartmentModel( REFCLSID clsid );
BOOL FIsLocalMachine( LPCTSTR psz );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logextpg.h ===
// LogExtended.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogExtended dialog

class CLogExtended : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogExtended)

// Construction
public:
	CLogExtended();
	~CLogExtended();
    
    // metabase target
    CString     m_szServer;
    CString     m_szMeta;
    IMSAdminBase* m_pMB;

// Dialog Data
	//{{AFX_DATA(CLogExtended)
	enum { IDD = IDD_LOG_EXTENDED };
	BOOL	m_bool_bytesreceived;
	BOOL	m_bool_bytessent;
	BOOL	m_bool_clientip;
	BOOL	m_bool_cookie;
	BOOL	m_bool_date;
	BOOL	m_bool_httpstatus;
	BOOL	m_bool_referer;
	BOOL	m_bool_serverip;
	BOOL	m_bool_servername;
	BOOL	m_bool_servicename;
	BOOL	m_bool_time;
	BOOL	m_bool_timetaken;
	BOOL	m_bool_uriquery;
	BOOL	m_bool_uristem;
	BOOL	m_bool_useragent;
	BOOL	m_bool_username;
	BOOL	m_bool_win32status;
	BOOL	m_bool_method;
	BOOL	m_bool_serverport;
	BOOL	m_bool_version;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogExtended)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogExtended)
	afx_msg void OnChkBytesreceived();
	afx_msg void OnChkBytessent();
	afx_msg void OnChkClientip();
	afx_msg void OnChkCookie();
	afx_msg void OnChkDate();
	afx_msg void OnChkHttpstatus();
	afx_msg void OnChkReferer();
	afx_msg void OnChkServerip();
	afx_msg void OnChkServername();
	afx_msg void OnChkServicename();
	afx_msg void OnChkTime();
	afx_msg void OnChkTimetaken();
	afx_msg void OnChkUriQuery();
	afx_msg void OnChkUristem();
	afx_msg void OnChkUseragent();
	afx_msg void OnChkUsername();
	afx_msg void OnChkWin32status();
	afx_msg void OnMethod();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    void Init();

    // initialized flag
    BOOL    m_fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logextpg.cpp ===
// LogExtPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogExtPg.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>
#include <logconst.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogExtended property page

IMPLEMENT_DYNCREATE(CLogExtended, CPropertyPage)

CLogExtended::CLogExtended() : CPropertyPage(CLogExtended::IDD),
        m_fInitialized( FALSE )
    {
    //{{AFX_DATA_INIT(CLogExtended)
    m_bool_bytesreceived = FALSE;
    m_bool_bytessent = FALSE;
    m_bool_clientip = FALSE;
    m_bool_cookie = FALSE;
    m_bool_date = FALSE;
    m_bool_httpstatus = FALSE;
    m_bool_referer = FALSE;
    m_bool_serverip = FALSE;
    m_bool_servername = FALSE;
    m_bool_servicename = FALSE;
    m_bool_time = FALSE;
    m_bool_timetaken = FALSE;
    m_bool_uriquery = FALSE;
    m_bool_uristem = FALSE;
    m_bool_useragent = FALSE;
    m_bool_username = FALSE;
    m_bool_win32status = FALSE;
    m_bool_method = FALSE;
	m_bool_serverport = FALSE;
	m_bool_version = FALSE;
	//}}AFX_DATA_INIT
    }

CLogExtended::~CLogExtended()
    {
    }

void CLogExtended::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogExtended)
    DDX_Check(pDX, IDC_CHK_BYTESRECEIVED, m_bool_bytesreceived);
    DDX_Check(pDX, IDC_CHK_BYTESSENT, m_bool_bytessent);
    DDX_Check(pDX, IDC_CHK_CLIENTIP, m_bool_clientip);
    DDX_Check(pDX, IDC_CHK_COOKIE, m_bool_cookie);
    DDX_Check(pDX, IDC_CHK_DATE, m_bool_date);
    DDX_Check(pDX, IDC_CHK_HTTPSTATUS, m_bool_httpstatus);
    DDX_Check(pDX, IDC_CHK_REFERER, m_bool_referer);
    DDX_Check(pDX, IDC_CHK_SERVERIP, m_bool_serverip);
    DDX_Check(pDX, IDC_CHK_SERVERNAME, m_bool_servername);
    DDX_Check(pDX, IDC_CHK_SERVICENAME, m_bool_servicename);
    DDX_Check(pDX, IDC_CHK_TIME, m_bool_time);
    DDX_Check(pDX, IDC_CHK_TIMETAKEN, m_bool_timetaken);
    DDX_Check(pDX, IDC_CHK_URI_QUERY, m_bool_uriquery);
    DDX_Check(pDX, IDC_CHK_URISTEM, m_bool_uristem);
    DDX_Check(pDX, IDC_CHK_USERAGENT, m_bool_useragent);
    DDX_Check(pDX, IDC_CHK_USERNAME, m_bool_username);
    DDX_Check(pDX, IDC_CHK_WIN32STATUS, m_bool_win32status);
    DDX_Check(pDX, IDC_METHOD, m_bool_method);
	DDX_Check(pDX, IDC_CHK_SERVERPORT, m_bool_serverport);
	DDX_Check(pDX, IDC_CHK_VERSION, m_bool_version);
	//}}AFX_DATA_MAP
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CLogExtended, CPropertyPage)
    //{{AFX_MSG_MAP(CLogExtended)
	ON_BN_CLICKED(IDC_CHK_BYTESRECEIVED, OnChkBytesreceived)
	ON_BN_CLICKED(IDC_CHK_BYTESSENT, OnChkBytessent)
	ON_BN_CLICKED(IDC_CHK_CLIENTIP, OnChkClientip)
	ON_BN_CLICKED(IDC_CHK_COOKIE, OnChkCookie)
	ON_BN_CLICKED(IDC_CHK_DATE, OnChkDate)
	ON_BN_CLICKED(IDC_CHK_HTTPSTATUS, OnChkHttpstatus)
	ON_BN_CLICKED(IDC_CHK_REFERER, OnChkReferer)
	ON_BN_CLICKED(IDC_CHK_SERVERIP, OnChkServerip)
	ON_BN_CLICKED(IDC_CHK_SERVERNAME, OnChkServername)
	ON_BN_CLICKED(IDC_CHK_SERVICENAME, OnChkServicename)
	ON_BN_CLICKED(IDC_CHK_TIME, OnChkTime)
	ON_BN_CLICKED(IDC_CHK_TIMETAKEN, OnChkTimetaken)
	ON_BN_CLICKED(IDC_CHK_URI_QUERY, OnChkUriQuery)
	ON_BN_CLICKED(IDC_CHK_URISTEM, OnChkUristem)
	ON_BN_CLICKED(IDC_CHK_USERAGENT, OnChkUseragent)
	ON_BN_CLICKED(IDC_CHK_USERNAME, OnChkUsername)
	ON_BN_CLICKED(IDC_CHK_WIN32STATUS, OnChkWin32status)
	ON_BN_CLICKED(IDC_METHOD, OnMethod)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogExtended::DoHelp()
    {
    WinHelp( HIDD_LOGUI_EXTENDED );
    }

//--------------------------------------------------------------------------
void CLogExtended::Init()
    {
    DWORD   dwFlags;
    BOOL    fGotIt = FALSE;

    // we will be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // start with the logging period
        fGotIt = mbWrap.GetDword( _T(""), MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, &dwFlags, METADATA_INHERIT );
        // close the metabase
        mbWrap.Close();
        }

    // if we didn't get it, use the default values
    if ( !fGotIt )
        dwFlags = DEFAULT_EXTLOG_FIELDS;

    // seperate out all the fields
    UpdateData( TRUE );

    if ( dwFlags & EXTLOG_BYTES_RECV )  m_bool_bytesreceived =  TRUE;
    if ( dwFlags & EXTLOG_BYTES_SENT )  m_bool_bytessent =      TRUE;
    if ( dwFlags & EXTLOG_CLIENT_IP )   m_bool_clientip =       TRUE;
    if ( dwFlags & EXTLOG_COOKIE )      m_bool_cookie =         TRUE;
    if ( dwFlags & EXTLOG_DATE )        m_bool_date =           TRUE;
    if ( dwFlags & EXTLOG_HTTP_STATUS ) m_bool_httpstatus =     TRUE;
    if ( dwFlags & EXTLOG_REFERER )     m_bool_referer =        TRUE;
    if ( dwFlags & EXTLOG_SERVER_IP )   m_bool_serverip =       TRUE;
    if ( dwFlags & EXTLOG_SERVER_PORT )   m_bool_serverport =   TRUE;
    if ( dwFlags & EXTLOG_COMPUTER_NAME ) m_bool_servername =   TRUE;
    if ( dwFlags & EXTLOG_SITE_NAME )   m_bool_servicename =    TRUE;
    if ( dwFlags & EXTLOG_TIME )        m_bool_time =           TRUE;
    if ( dwFlags & EXTLOG_TIME_TAKEN )  m_bool_timetaken =      TRUE;
    if ( dwFlags & EXTLOG_URI_QUERY )   m_bool_uriquery =       TRUE;
    if ( dwFlags & EXTLOG_URI_STEM )    m_bool_uristem =        TRUE;
    if ( dwFlags & EXTLOG_USER_AGENT )  m_bool_useragent =      TRUE;
    if ( dwFlags & EXTLOG_USERNAME )    m_bool_username =       TRUE;
    if ( dwFlags & EXTLOG_WIN32_STATUS ) m_bool_win32status =   TRUE;
    if ( dwFlags & EXTLOG_METHOD )      m_bool_method =         TRUE;
    if ( dwFlags & EXTLOG_PROTOCOL_VERSION ) m_bool_version =   TRUE;

    // set the data back
    UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogExtended message handlers

//--------------------------------------------------------------------------
BOOL CLogExtended::OnSetActive()
    {
    // if we haven't been initialized yet, do so
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }

    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
BOOL CLogExtended::OnApply()
    {
    DWORD   dwFlags = 0;
    BOOL    f;

    // prepare the extended logging flag
    if ( m_bool_bytesreceived ) dwFlags |= EXTLOG_BYTES_RECV;
    if ( m_bool_bytessent )     dwFlags |= EXTLOG_BYTES_SENT;
    if ( m_bool_clientip )      dwFlags |= EXTLOG_CLIENT_IP;
    if ( m_bool_cookie )        dwFlags |= EXTLOG_COOKIE;
    if ( m_bool_date )          dwFlags |= EXTLOG_DATE;
    if ( m_bool_httpstatus )    dwFlags |= EXTLOG_HTTP_STATUS;
    if ( m_bool_referer )       dwFlags |= EXTLOG_REFERER;
    if ( m_bool_serverport )    dwFlags |= EXTLOG_SERVER_PORT;
    if ( m_bool_serverip )      dwFlags |= EXTLOG_SERVER_IP;
    if ( m_bool_servername )    dwFlags |= EXTLOG_COMPUTER_NAME;
    if ( m_bool_servicename )   dwFlags |= EXTLOG_SITE_NAME;
    if ( m_bool_time )          dwFlags |= EXTLOG_TIME;
    if ( m_bool_timetaken )     dwFlags |= EXTLOG_TIME_TAKEN;
    if ( m_bool_uriquery )      dwFlags |= EXTLOG_URI_QUERY;
    if ( m_bool_uristem )       dwFlags |= EXTLOG_URI_STEM;
    if ( m_bool_useragent )     dwFlags |= EXTLOG_USER_AGENT;
    if ( m_bool_username )      dwFlags |= EXTLOG_USERNAME;
    if ( m_bool_win32status )   dwFlags |= EXTLOG_WIN32_STATUS;
    if ( m_bool_method )        dwFlags |= EXTLOG_METHOD;
    if ( m_bool_version )       dwFlags |= EXTLOG_PROTOCOL_VERSION;

    // set the extended logging logging field mask
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_LOGEXT_FIELD_MASK,
                IIS_MD_UT_SERVER, dwFlags, TRUE );

    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkBytesreceived()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkBytessent()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkClientip()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkCookie()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkDate()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkHttpstatus()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkReferer()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkServerip()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkServername()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkServicename()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkTime()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkTimetaken()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUriQuery()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUristem()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUseragent()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUsername()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkWin32status()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnMethod()
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\loggenpg.h ===
// LogGenPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogGeneral dialog

class CLogGeneral : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogGeneral)

// Construction
public:
	CLogGeneral();
	~CLogGeneral();

    CComboBox*  m_pComboLog;

    // metabase target
    CString     m_szServer;
    CString     m_szMeta;
    IMSAdminBase* m_pMB;

    // editing local machine
    BOOL        m_fLocalMachine;
    BOOL        m_fShowLocalTimeCheckBox;

    // the two-letter file prefix
    CString szPrefix;
    // the longer file size prefix
    CString szSizePrefix;

// Dialog Data
	//{{AFX_DATA(CLogGeneral)
	enum { IDD = IDD_LOG_GENERAL };
	CButton	m_wndPeriod;
	CButton	m_wndUseLocalTime;
	CButton	m_cbttn_browse;
	CEdit	m_cedit_directory;
	CEdit	m_cedit_size;
	CSpinButtonCtrl	m_cspin_spin;
	CStatic	m_cstatic_units;
	CString	m_sz_directory;
	CString	m_sz_filesample;
	BOOL	m_fUseLocalTime;
	int		m_int_period;
	//}}AFX_DATA
    CILong  m_dword_filesize;
//	DWORD	m_dword_filesize;



// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogGeneral)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogGeneral)
	afx_msg void OnBrowse();
	afx_msg void OnLogDaily();
	afx_msg void OnLogMonthly();
	afx_msg void OnLogWhensize();
	afx_msg void OnLogWeekly();
	afx_msg void OnChangeLogDirectory();
	afx_msg void OnChangeLogSize();
	afx_msg void OnLogUnlimited();
	afx_msg void OnDeltaposSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLogHourly();
	afx_msg void OnUseLocalTime();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // update the sample file stirng
    virtual void UpdateSampleFileString();

    void    Init();
    void    UpdateDependants();

private:
    // initialized flag
    BOOL    m_fInitialized;
    BOOL    m_fIsModified;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\loggenpg.cpp ===
// LogGenPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogGenPg.h"
#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#include <shlobj.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define     SIZE_MBYTE          1048576
#define     MAX_LOGFILE_SIZE    4000

#define MD_LOGFILE_PERIOD_UNLIMITED  MD_LOGFILE_PERIOD_HOURLY + 1

//
// Support functions to map & unmap the weird logfile ordering to the UI ordering
//

/////////////////////////////////////////////////////////////////////////////

int MapLogFileTypeToUIIndex(int iLogFileType)
{
    int iUIIndex;

    switch (iLogFileType)
    {
    case MD_LOGFILE_PERIOD_HOURLY:
        iUIIndex = 0;
        break;

    case MD_LOGFILE_PERIOD_DAILY:
        iUIIndex = 1;
        break;

    case MD_LOGFILE_PERIOD_WEEKLY:
        iUIIndex = 2;
        break;

    case MD_LOGFILE_PERIOD_MONTHLY:
        iUIIndex = 3;
        break;

    case MD_LOGFILE_PERIOD_UNLIMITED:
        iUIIndex = 4;
        break;

    case MD_LOGFILE_PERIOD_NONE:
        iUIIndex = 5;
        break;
    }

    return iUIIndex;
}

/////////////////////////////////////////////////////////////////////////////

int MapUIIndexToLogFileType(int iUIIndex)
{
    int iLogFileType;

    switch (iUIIndex)
    {
    case 0:
        iLogFileType = MD_LOGFILE_PERIOD_HOURLY;
        break;

    case 1:
        iLogFileType = MD_LOGFILE_PERIOD_DAILY;
        break;

    case 2:
        iLogFileType = MD_LOGFILE_PERIOD_WEEKLY;
        break;

    case 3:
        iLogFileType = MD_LOGFILE_PERIOD_MONTHLY;
        break;

    case 4:
        iLogFileType = MD_LOGFILE_PERIOD_UNLIMITED;
        break;

    case 5:
        iLogFileType = MD_LOGFILE_PERIOD_NONE;
        break;
    }

    return iLogFileType;
}


/////////////////////////////////////////////////////////////////////////////
// CLogGeneral property page

IMPLEMENT_DYNCREATE(CLogGeneral, CPropertyPage)

//--------------------------------------------------------------------------
CLogGeneral::CLogGeneral() : CPropertyPage(CLogGeneral::IDD),
    m_fInitialized( FALSE ),
    m_pComboLog( NULL ),
    m_fLocalMachine( FALSE )
    {
    //{{AFX_DATA_INIT(CLogGeneral)
    m_sz_directory = _T("");
    m_sz_filesample = _T("");
    m_fShowLocalTimeCheckBox = FALSE;
    m_int_period = -1;
    //}}AFX_DATA_INIT

    m_fIsModified = FALSE;
}

//--------------------------------------------------------------------------
CLogGeneral::~CLogGeneral()
    {
    }

//--------------------------------------------------------------------------
void CLogGeneral::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogGeneral)
    DDX_Control(pDX, IDC_LOG_HOURLY, m_wndPeriod);
    DDX_Control(pDX, IDC_USE_LOCAL_TIME, m_wndUseLocalTime);
    DDX_Control(pDX, IDC_LOG_BROWSE, m_cbttn_browse);
    DDX_Control(pDX, IDC_LOG_DIRECTORY, m_cedit_directory);
    DDX_Control(pDX, IDC_LOG_SIZE, m_cedit_size);
    DDX_Control(pDX, IDC_SPIN, m_cspin_spin);
    DDX_Control(pDX, IDC_LOG_SIZE_UNITS, m_cstatic_units);
    DDX_Text(pDX, IDC_LOG_DIRECTORY, m_sz_directory);
    DDX_Text(pDX, IDC_LOG_FILE_SAMPLE, m_sz_filesample);
    DDX_Check(pDX, IDC_USE_LOCAL_TIME, m_fUseLocalTime);
    // DDX_Radio(pDX, IDC_LOG_HOURLY, m_int_period);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_LOG_SIZE, m_dword_filesize);
    DDV_MinMaxLong(pDX, m_dword_filesize, 0, MAX_LOGFILE_SIZE);

    //
    // Do the map & unmap between UI Index & Log File Type
    //

    if (pDX->m_bSaveAndValidate)
    {
        DDX_Radio(pDX, IDC_LOG_HOURLY, m_int_period);
        m_int_period = MapUIIndexToLogFileType(m_int_period);
    }
    else
    {
        int iUIIndex = MapLogFileTypeToUIIndex(m_int_period);
        DDX_Radio(pDX, IDC_LOG_HOURLY, iUIIndex);
    }
}


BEGIN_MESSAGE_MAP(CLogGeneral, CPropertyPage)
    //{{AFX_MSG_MAP(CLogGeneral)
    ON_BN_CLICKED(IDC_LOG_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_LOG_DAILY, OnLogDaily)
    ON_BN_CLICKED(IDC_LOG_MONTHLY, OnLogMonthly)
    ON_BN_CLICKED(IDC_LOG_WHENSIZE, OnLogWhensize)
    ON_BN_CLICKED(IDC_LOG_WEEKLY, OnLogWeekly)
    ON_EN_CHANGE(IDC_LOG_DIRECTORY, OnChangeLogDirectory)
    ON_EN_CHANGE(IDC_LOG_SIZE, OnChangeLogSize)
    ON_BN_CLICKED(IDC_LOG_UNLIMITED, OnLogUnlimited)
    ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN, OnDeltaposSpin)
    ON_BN_CLICKED(IDC_LOG_HOURLY, OnLogHourly)
    ON_BN_CLICKED(IDC_USE_LOCAL_TIME, OnUseLocalTime)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogGeneral::DoHelp()
    {
    WinHelp( HIDD_LOGUI_GENERIC );
    }

//--------------------------------------------------------------------------
void CLogGeneral::Init()
    {
    DWORD   dw;
    LPCTSTR  pstr;
    
    UpdateData( TRUE );

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
    {
    // start with the logging period
    if ( mbWrap.GetDword( _T(""), MD_LOGFILE_PERIOD, IIS_MD_UT_SERVER, &dw, METADATA_INHERIT ) )
        {
        // hey hey - period matches the metabase value. Thats so handy
        m_int_period = dw;
        }

    // now the truncate size
    if ( mbWrap.GetDword( _T(""), MD_LOGFILE_TRUNCATE_SIZE, IIS_MD_UT_SERVER, &dw, METADATA_INHERIT ) )
        {
        m_dword_filesize = dw / SIZE_MBYTE;
        }

    // check for the unlimited case - larger than 4 gigabytes
    if ( (m_dword_filesize > MAX_LOGFILE_SIZE) && (m_int_period == MD_LOGFILE_PERIOD_NONE) )
        {
        m_int_period = MD_LOGFILE_PERIOD_UNLIMITED;
        m_dword_filesize = 512;
        }

    // now the target directory
    pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGFILE_DIRECTORY, IIS_MD_UT_SERVER, EXPANDSZ_METADATA, &dw, METADATA_INHERIT );
    if ( pstr )
        {
        m_sz_directory = pstr;
        // free it
        mbWrap.FreeWrapData( (PVOID)pstr );
        }

    // now the use local time flag (only for w3c)
    if ( m_fShowLocalTimeCheckBox)
    {
        m_wndUseLocalTime.ShowWindow(SW_SHOW);

        if (mbWrap.GetDword( _T(""), MD_LOGFILE_LOCALTIME_ROLLOVER, IIS_MD_UT_SERVER, &dw, METADATA_INHERIT))
        {
            m_fUseLocalTime = dw;
        }

        if (( MD_LOGFILE_PERIOD_NONE == m_int_period) || ( MD_LOGFILE_PERIOD_UNLIMITED == m_int_period))
        {
            m_wndUseLocalTime.EnableWindow(FALSE);
        }
    }

    // close the metabase
    mbWrap.Close();
    }

    // put the date into place
    UpdateData( FALSE );

    // update the dependant items
    UpdateDependants();

    // and the sample file string
    UpdateSampleFileString();

    // finally, test if we are editing a remote machine. If we are not,
    // then disable the remote browsing function.
    if ( !m_fLocalMachine )
        m_cbttn_browse.EnableWindow( FALSE );
    }

//--------------------------------------------------------------------------
void CLogGeneral::UpdateDependants() 
    {
    UpdateData( TRUE );

    // enable or disable the file size depending on the period selected
    if ( m_int_period == MD_LOGFILE_PERIOD_MAXSIZE )
    {
    m_cspin_spin.EnableWindow( TRUE );
    m_cstatic_units.EnableWindow( TRUE );
    m_cedit_size.EnableWindow( TRUE );
    }
    else
    {
    m_cspin_spin.EnableWindow( FALSE );
    m_cstatic_units.EnableWindow( FALSE );
    m_cedit_size.EnableWindow( FALSE );
    }

    // put the date into place
    UpdateData( FALSE );
    }
    
//--------------------------------------------------------------------------
// update the sample file stirng
void CLogGeneral::UpdateSampleFileString()
    {
    CString szSample;

    UpdateData( TRUE );


    // ok first we have to generate a string to show what sub-node the logging stuff
    // is going to go into. This would be of the general form of the name of the server
    // followed by the virtual node of the server. Example: LM/W3SVC/1 would
    // become "W3SVC1/example" Unfortunately, all we have to build this thing out of
    // is the target metabase path. So we strip off the preceding LM/. Then we find the
    // next / character and take the number that follows it. If we are editing the 
    // master root properties then there will be no slash/number at the end at which point
    // we can just append a capital X character to signifiy this. The MMC is currently set
    // up to only show the logging properties if we are editing the master props or a virtual
    // server, so we shouldn't have to worry about stuff after the virtual server number

    // get rid of the preceding LM/ (Always three characters)
    m_sz_filesample = m_szMeta.Right( m_szMeta.GetLength() - 3 );

    // Find the location of the '/' character
    INT     iSlash = m_sz_filesample.Find( _T('/') );

    // if there was no last slash, then append the X, otherwise append the number
    if ( iSlash < 0 )
        {
        m_sz_filesample += _T('X');
        }
    else
        {
        m_sz_filesample = m_sz_filesample.Left(iSlash) +
                    m_sz_filesample.Right( m_sz_filesample.GetLength() - (iSlash+1) );
        }

    // add a final path type slash to signify that it is a partial path
    m_sz_filesample += _T('\\');

    // build the sample string
    switch( m_int_period )
        {
        case MD_LOGFILE_PERIOD_MAXSIZE:
            m_sz_filesample += szSizePrefix;
            szSample.LoadString( IDS_LOG_SIZE_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_DAILY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_DAILY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_WEEKLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_WEEKLY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_MONTHLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_MONTHLY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_HOURLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_HOURLY_FILE_SAMPLE );
            break;
        case MD_LOGFILE_PERIOD_UNLIMITED:
            m_sz_filesample += szSizePrefix;
            szSample.LoadString( IDS_LOG_UNLIMITED_FILESAMPLE );
            break;
        };

    // add the two together
    m_sz_filesample += szSample;

    // update the display
    UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogGeneral message handlers

//--------------------------------------------------------------------------
BOOL CLogGeneral::OnSetActive() 
    {
    // if this is the first time, inititalize the dialog
    if( !m_fInitialized )
    {
    Init();
    // set the flag so we don't do it again
    m_fInitialized = TRUE;
    }

    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
BOOL CLogGeneral::OnApply() 
    {
    DWORD   dw;

    if (!m_fIsModified)
    {
        // do the default action
        return CPropertyPage::OnApply();
    }
    
    UpdateData( TRUE );
    CString szDir = m_sz_directory;
    
    // while we can't confirm the existence of a remote directory,
    // we can at least make sure they entered something
    szDir.TrimLeft();
    if ( szDir.IsEmpty() )
    {
    AfxMessageBox( IDS_NEED_DIRECTORY );
    m_cedit_directory.SetFocus();
    return FALSE;
    }

    // we do not allow UNC names or Remote Drives

    if ( (_T('\\') == szDir[0] ) && ( _T('\\') == szDir[1]) )
    {
        AfxMessageBox( IDS_REMOTE_NOT_SUPPORTED );
        m_cedit_directory.SetFocus();
        return FALSE;
    }

    if ( ( _T(':') == szDir[1] ) && ( _T('\\') == szDir[2]) )
    {
        TCHAR    szDrive[4];

        CopyMemory(szDrive, (LPCTSTR)szDir, 3*sizeof(TCHAR));
        szDrive[3] = _T('\0');

        if ( DRIVE_REMOTE == GetDriveType(szDrive))
        {
            AfxMessageBox( IDS_REMOTE_NOT_SUPPORTED );
            m_cedit_directory.SetFocus();
            return FALSE;
        }
    }


    // prepare and open the metabase object
    CWrapMetaBase   mb;
    if ( !mb.FInit(m_pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mb, m_szMeta, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // prepare for the inheritence checks
        CCheckInheritList   listInherit;
        
        // start with the logging period
        dw = m_int_period;
        if ( m_int_period == MD_LOGFILE_PERIOD_UNLIMITED )
            dw = MD_LOGFILE_PERIOD_NONE;
            
        SetMBDword( &mb, &listInherit, _T(""), MD_LOGFILE_PERIOD,
                        IIS_MD_UT_SERVER, dw);

        // now the truncate size
        dw = m_dword_filesize * SIZE_MBYTE;
        if ( m_int_period == MD_LOGFILE_PERIOD_UNLIMITED )
            dw = 0xFFFFFFFF;
            
        SetMBDword(&mb, &listInherit, _T(""), MD_LOGFILE_TRUNCATE_SIZE,
                        IIS_MD_UT_SERVER, dw);
    
        // now the target directory
        SetMBData( &mb, &listInherit, _T(""), MD_LOGFILE_DIRECTORY, IIS_MD_UT_SERVER,
                        EXPANDSZ_METADATA, (PVOID)(LPCTSTR)szDir,
                        ((szDir.GetLength()+1) * sizeof(TCHAR)) + sizeof(TCHAR), FALSE );

        // now the use local time flag (only for w3c)

        if ( m_fShowLocalTimeCheckBox)
            {
            dw = m_fUseLocalTime;

            SetMBDword(&mb, &listInherit, _T(""), MD_LOGFILE_LOCALTIME_ROLLOVER,
                         IIS_MD_UT_SERVER, dw);
            }

        // close the metabase
        mb.Close();

        // do all the inheritence checks
        listInherit.CheckInheritence( m_szServer, m_szMeta );
        }

    // do the default action
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
void CLogGeneral::OnBrowse()
    {
    UpdateData( TRUE );

    BROWSEINFO bi; 
    LPTSTR lpBuffer; 
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user

    // Allocate a buffer to receive browse information.

    //
    // RONALDM: Insufficient buffer size fix, bug # 231144
    //
    //lpBuffer = (LPTSTR) GlobalAlloc( GPTR, MAX_PATH );

    lpBuffer = (LPTSTR) GlobalAlloc( GPTR, (MAX_PATH + 1) * sizeof(TCHAR) );

    if ( !lpBuffer )
    {
        return;
    }

    // Fill in the BROWSEINFO structure. 
    bi.hwndOwner = this->m_hWnd; 
    bi.pidlRoot = NULL; 
    bi.pszDisplayName = lpBuffer; 
    bi.lpszTitle = NULL; 
//    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_DONTGOBELOWDOMAIN; 
    bi.ulFlags = BIF_RETURNONLYFSDIRS; 
    bi.lpfn = NULL; 
    bi.lParam = 0; 

   // Browse for a folder and return its PIDL. 
    pidlBrowse = SHBrowseForFolder(&bi); 
    if (pidlBrowse != NULL)
    {
    // Show the display name, title, and file system path. 
    if (SHGetPathFromIDList(pidlBrowse, lpBuffer))
        m_sz_directory = lpBuffer;
 
    // Free the PIDL returned by SHBrowseForFolder. 
    GlobalFree(pidlBrowse);

    // put the string back
    UpdateData( FALSE );
    SetModified();
    m_fIsModified = TRUE;
    } 
 
    // Clean up. 
    GlobalFree( lpBuffer );
    }

//--------------------------------------------------------------------------
void CLogGeneral::OnLogDaily() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogMonthly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogWhensize() 
{
    m_wndUseLocalTime.EnableWindow(FALSE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogUnlimited() 
{
    m_wndUseLocalTime.EnableWindow(FALSE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogWeekly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogHourly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnChangeLogDirectory() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnChangeLogSize() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnUseLocalTime() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
// the spinbox has been spun. Alter the size of the log file
void CLogGeneral::OnDeltaposSpin(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
    *pResult = 0;

    // based on the delta in the pNMUpDown affect the value of the file
    // size. Note that pressing the up arrow in the spinbox passes us
    // a delta of -1, and pressing the down arrow passes 1. Since they
    // want the up arrow to increase the size of the file, we have to
    // add the opposite of the delta to the file size to get the right answer.

     UpdateData( TRUE );
    // move it by the amount in the delta
    m_dword_filesize -= pNMUpDown->iDelta;

    // check the boundaries. Since it is a dword, don't look for negatives
    if ( (m_dword_filesize < 0) && (pNMUpDown->iDelta > 0) )
        m_dword_filesize = (LONG)0;
    if ( (m_dword_filesize >= MAX_LOGFILE_SIZE) && (pNMUpDown->iDelta > 0) )
        m_dword_filesize = (LONG)0;
    else if ( (m_dword_filesize >= MAX_LOGFILE_SIZE) && (pNMUpDown->iDelta < 0) )
        m_dword_filesize = MAX_LOGFILE_SIZE;
    
    UpdateData( FALSE );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\metatool.h ===
class CCheckInheritList;

BOOL OpenAndCreate( CWrapMetaBase* pmb, LPCTSTR pszTarget, DWORD perm, BOOL fCreate );

BOOL SetMetaDword(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence);
BOOL SetMetaString(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence, BOOL fSecure);
BOOL SetMetaData(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence, BOOL fSecure );
BOOL SetMetaMultiSz(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence );


BOOL SetMBDword(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                DWORD dwValue);

BOOL SetMBString(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                CString sz,
                BOOL fSecure);

BOOL SetMBData(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                DWORD iDataType,
                PVOID pData,
                DWORD cbData,
                BOOL fSecure );

BOOL SetMBMultiSz(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                PVOID pData,
                DWORD cchmsz );




//-------------------------------------------------------------
class CCheckInheritList : public CObject
    {
public:
    // do the check on all the members of the check array
    void CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot );

    // add an item to check
    INT Add( DWORD dwMDIdentifier, DWORD dwMDDataType, DWORD dwMDUserType, DWORD dwMDAttributes );

protected:
    //--------------------------
    typedef struct _INHERIT_CHECK_ITEM
    {
        DWORD   dwMDIdentifier;
        DWORD   dwMDDataType;
        DWORD   dwMDUserType;
        DWORD   dwMDAttributes;

    }   INHERIT_CHECK_ITEM, *PINHERIT_CHECK_ITEM;

    // the array of items
    CArray< INHERIT_CHECK_ITEM, INHERIT_CHECK_ITEM>    rgbItems;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logodbc.cpp ===
// LogODBC.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogODBC.h"
#include "CnfrmPsD.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogODBC property page

IMPLEMENT_DYNCREATE(CLogODBC, CPropertyPage)

//--------------------------------------------------------------------------
CLogODBC::CLogODBC() : CPropertyPage(CLogODBC::IDD),
        m_fInitialized( FALSE )
    {
    //{{AFX_DATA_INIT(CLogODBC)
    m_sz_datasource = _T("");
    m_sz_password = _T("");
    m_sz_table = _T("");
    m_sz_username = _T("");
    //}}AFX_DATA_INIT

    m_szOrigPass.Empty();
    m_bPassTyped = FALSE;
    }

//--------------------------------------------------------------------------
CLogODBC::~CLogODBC()
    {
    }

//--------------------------------------------------------------------------
void CLogODBC::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogODBC)
	DDX_Control(pDX, IDC_ODBC_PASSWORD, m_cedit_password);
    DDX_Text(pDX, IDC_ODBC_DATASOURCE, m_sz_datasource);
    DDX_Text(pDX, IDC_ODBC_PASSWORD, m_sz_password);
    DDX_Text(pDX, IDC_ODBC_TABLE, m_sz_table);
    DDX_Text(pDX, IDC_ODBC_USERNAME, m_sz_username);
	//}}AFX_DATA_MAP
    }

//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CLogODBC, CPropertyPage)
    //{{AFX_MSG_MAP(CLogODBC)
    ON_EN_CHANGE(IDC_ODBC_DATASOURCE, OnChangeOdbcDatasource)
    ON_EN_CHANGE(IDC_ODBC_PASSWORD, OnChangeOdbcPassword)
	ON_EN_CHANGE(IDC_ODBC_TABLE, OnChangeOdbcTable)
	ON_EN_CHANGE(IDC_ODBC_USERNAME, OnChangeOdbcUsername)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogODBC::DoHelp()
    {
    WinHelp( HIDD_LOGUI_ODBC );
    }

//--------------------------------------------------------------------------
void CLogODBC::Init()
    {
    UpdateData( TRUE );
    DWORD   dw;
    LPCTSTR  pstr;

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // datasources
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_DATA_SOURCES, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_datasource = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // password
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_PASSWORD, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_password = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );

            m_szOrigPass = m_sz_password;
            if ( !m_sz_password.IsEmpty() )
                m_sz_password.LoadString( IDS_SHOWN_PASSWORD );
            }

        // table name
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_TABLE_NAME, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_table = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // user name
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_USER_NAME, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_username = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // close the metabase
        mbWrap.Close();
        }

    // put the data into place
    UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogODBC message handlers


//--------------------------------------------------------------------------
BOOL CLogODBC::OnApply() 
    {
    BOOL    f;
    UpdateData( TRUE );

    // confirm the password
    if ( m_bPassTyped )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return FALSE;
            }
        }


    // prepare and open the metabase object
    CWrapMetaBase   mb;
    if ( !mb.FInit(m_pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mb, m_szMeta, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // prepare for the inheritence checks
        CCheckInheritList   listInherit;

        f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_DATA_SOURCES,
                    IIS_MD_UT_SERVER, m_sz_datasource, FALSE);
    
        if ( m_bPassTyped )
            {
            f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_PASSWORD,
                        IIS_MD_UT_SERVER, m_sz_password, TRUE);
            }

        f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_TABLE_NAME,
                    IIS_MD_UT_SERVER, m_sz_table, FALSE);
        f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_USER_NAME,
                    IIS_MD_UT_SERVER, m_sz_username, FALSE);

        // close the metabase
        mb.Close();

        // do all the inheritence checks
        listInherit.CheckInheritence( m_szServer, m_szMeta );
        }


     

    // clear the modified flag
    SetModified( FALSE );

    // reset the internal password-typed flag
    m_szOrigPass = m_sz_password;
    m_bPassTyped = FALSE;

    
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
BOOL CLogODBC::OnSetActive() 
    {
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }
    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcDatasource() 
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcPassword() 
    {
    m_bPassTyped = TRUE;
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcTable() 
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcUsername() 
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\ncsappg.cpp ===
// NcsaPpg.cpp : Implementation of the CNcsaPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "NcsaPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CNcsaPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CNcsaPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CNcsaPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CNcsaPropPage, "LOGUI.NcsaPropPage.1",
	0x68871e46, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::CNcsaPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CNcsaPropPage

BOOL CNcsaPropPage::CNcsaPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_NCSA_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::CNcsaPropPage - Constructor

CNcsaPropPage::CNcsaPropPage() :
	COlePropertyPage(IDD, IDS_NCSA_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CNcsaPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::DoDataExchange - Moves data between page and properties

void CNcsaPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CNcsaPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\odbcppg.cpp ===
// OdbcPpg.cpp : Implementation of the COdbcPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "OdbcPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(COdbcPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(COdbcPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(COdbcPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(COdbcPropPage, "LOGUI.OdbcPropPage.1",
	0x68871e4e, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::COdbcPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for COdbcPropPage

BOOL COdbcPropPage::COdbcPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_ODBC_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::COdbcPropPage - Constructor

COdbcPropPage::COdbcPropPage() :
	COlePropertyPage(IDD, IDS_ODBC_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(COdbcPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::DoDataExchange - Moves data between page and properties

void COdbcPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(COdbcPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\odbcppg.h ===
// OdbcPpg.h : Declaration of the COdbcPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// COdbcPropPage : See OdbcPpg.cpp.cpp for implementation.

class COdbcPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(COdbcPropPage)
	DECLARE_OLECREATE_EX(COdbcPropPage)

// Constructor
public:
	COdbcPropPage();

// Dialog Data
	//{{AFX_DATA(COdbcPropPage)
	enum { IDD = IDD_PROPPAGE_ODBC };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(COdbcPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logui.cpp ===
// logui.cpp : Implementation of CLoguiApp and DLL registration.

#include "stdafx.h"
#include "logui.h"

#include "wrapmb.h"
#include <iiscnfg.h>
#include <iiscnfgp.h>
#include <inetinfo.h>

#include "initguid.h"
#include <logtype.h>
#include <ilogobj.hxx>

#include "uincsa.h"
#include "uiextnd.h"
#include "uimsft.h"
#include "uiodbc.h"

#include "dcomperm.h"

//_tlid


// the global factory objects
CFacNcsaLogUI       facNcsa;
CFacMsftLogUI       facMsft;
CFacOdbcLogUI       facOdbc;
CFacExtndLogUI      facExtnd;


const GUID CDECL BASED_CODE _tlid =
		{ 0x31dcab8a, 0xbb3e, 0x11d0, { 0x92, 0x99, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

// the key type strings for the metabaes keys
#define SZ_LOGGING_MAIN_TYPE    _T("IIsLogModules")
#define SZ_LOGGING_TYPE         _T("IIsLogModule")

BOOL _cdecl RegisterInMetabase( PWCHAR pszMachine );

int SetInfoAdminACL( CWrapMetaBase* pMB, LPCTSTR szSubKeyPath );

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CLoguiApp NEAR theApp;

HINSTANCE	g_hInstance = NULL;



//---------------------------------------------------------------
void CLoguiApp::PrepHelp( OLECHAR* pocMetabasePath )
    {
    // figure out the correct help file to use
    CString szMetaPath = pocMetabasePath;
    szMetaPath.MakeLower();

    // default to the w3 help
    UINT    iHelp = IDS_HELPLOC_W3SVCHELP;

    // test for ftp
    if ( szMetaPath.Find(_T("msftpsvc")) >= 0 )
        iHelp = IDS_HELPLOC_FTPHELP;

    // finally, we need to redirect the winhelp file location to something more desirable
    CString sz;
    CString szHelpLocation;
    sz.LoadString( iHelp );

    // expand the path
    ExpandEnvironmentStrings(
        sz,	                                        // pointer to string with environment variables 
        szHelpLocation.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables  
        MAX_PATH                                    // maximum characters in expanded string 
       );
    szHelpLocation.ReleaseBuffer();

    // free the existing path, and copy in the new one
    if ( m_pszHelpFilePath )
        free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpLocation);
    }


////////////////////////////////////////////////////////////////////////////
// CLoguiApp::InitInstance - DLL initialization

BOOL CLoguiApp::InitInstance()
    {
    g_hInstance = m_hInstance;
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	    {
        CString sz;
        // set the name of the application correctly
        sz.LoadString( IDS_LOGUI_ERR_TITLE );
        // Never free this string because now MF...kingC
		// uses it internally BEFORE call to this function
        //free((void*)m_pszAppName);
        m_pszAppName = _tcsdup(sz);
	    }

	return bInit;
    }

////////////////////////////////////////////////////////////////////////////
// CLoguiApp::ExitInstance - DLL termination

int CLoguiApp::ExitInstance()
    {
    return COleControlModule::ExitInstance();
    }


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

    // intialize the metabase /logging tree
    if ( !RegisterInMetabase( NULL ) )
        return GetLastError();

	return NOERROR;
    }


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
    {
	AFX_MANAGE_STATE(_afxModuleAddrThis);

//	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
//		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
    }


//-------------------------------------------------------------------------
// add all the base logging info to the /LM portion of the tree Also, add in
// the ftp and w3 service logging load strings
BOOL _cdecl RegisterInMetabase( PWCHAR pszMachine )
    {
    CString         sz;
    BOOL            f;
    DWORD           dw;
    BOOL            fODBCW3 = FALSE;
    BOOL            fODBCFTP = FALSE;
    DWORD           fAnswer = FALSE;
    CString         szAvail;
    CWrapMetaBase   mbWrap;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prep the metabase - during install we always target the local machine
    IMSAdminBase* pMB = FInitMetabaseWrapper( pszMachine );
    if ( !pMB )
        {
        goto CLEANUP_RES;
        }
    if ( !mbWrap.FInit(pMB) )
        {
        goto CLEANUP_RES;
        }

    // first, we will add the basic tree to the metabase
    // start with the bottom item
    // open the target
    if ( !mbWrap.Open( _T("/lm"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
        {
        goto CLEANUP_RES;
        }

    // test to see if we can do odbc logging
    if ( mbWrap.GetDword( _T("/w3svc/Info"), MD_SERVER_CAPABILITIES, IIS_MD_UT_SERVER, &dw ) )
        fODBCW3 = (dw & IIS_CAP1_ODBC_LOGGING) > 0;
    if ( mbWrap.GetDword( _T("/MSFTPSVC/Info"), MD_SERVER_CAPABILITIES, IIS_MD_UT_SERVER, &dw ) )
        fODBCFTP = (dw & IIS_CAP1_ODBC_LOGGING) > 0;

    // we shouldn't tie up the /lm object, so close it and open logging
    mbWrap.Close();

    // open the logging object
    if ( !mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_WRITE ) )
        {
        // the logging node doesn't exist. Create it
        if ( !mbWrap.Open( _T("/lm"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
            goto CLEANUP_RES;

        // add the logging object
        if ( mbWrap.AddObject(_T("logging")) )
            {
            // add the ACL to the node
            SetInfoAdminACL( &mbWrap, _T("logging") );
            }

        // we shouldn't tie up the /lm object, so close it and open logging
        mbWrap.Close();            

        // open the logging object
        if ( !mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_WRITE ) )
            goto CLEANUP_RES;
        }

    // set the logging key type
    mbWrap.SetString( _T(""), MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_MAIN_TYPE, 0 );

    // add ncsa first
    sz.LoadString( IDS_MTITLE_NCSA );
    if ( mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, NCSALOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, NCSALOGUI_CLSID );
        }

    // add odbc logging
    sz.LoadString( IDS_MTITLE_ODBC );
    if ( (fODBCW3 || fODBCFTP) && mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, ODBCLOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, ODBCLOGUI_CLSID );
        }

    // add microsoft logging
    sz.LoadString( IDS_MTITLE_MSFT );
    if ( mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, ASCLOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, ASCLOGUI_CLSID );
        }

    // add extended logging
    sz.LoadString( IDS_MTITLE_XTND );
    if ( mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, EXTLOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, EXTLOGUI_CLSID );
        }

    // close the wrapper
    mbWrap.Close();

    // prepare the available logging extensions string
    // start with w3svc
    sz.LoadString( IDS_MTITLE_NCSA );
    szAvail = sz;
    sz.LoadString( IDS_MTITLE_MSFT );
    szAvail += _T(',') + sz;
    sz.LoadString( IDS_MTITLE_XTND );
    szAvail += _T(',') + sz;
    if ( fODBCW3 )
        {
        sz.LoadString( IDS_MTITLE_ODBC );
        szAvail += _T(',') + sz;
        }
    // save the string
    if ( mbWrap.Open( _T("/lm/w3svc/Info"), METADATA_PERMISSION_WRITE ) )
        {
        f = mbWrap.SetString( _T(""), MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, szAvail );
        // close the wrapper
        mbWrap.Close();
        }

    // now ftp - no ncsa
    sz.LoadString( IDS_MTITLE_MSFT );
    szAvail = sz;
    sz.LoadString( IDS_MTITLE_XTND );
    szAvail += _T(',') + sz;
    if ( fODBCFTP )
        {
        sz.LoadString( IDS_MTITLE_ODBC );
        szAvail += _T(',') + sz;
        }
    // save the string
    if ( mbWrap.Open( _T("/lm/msftpsvc/Info"), METADATA_PERMISSION_WRITE ) )
        {
        f = mbWrap.SetString( _T(""), MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, szAvail );
        // close the wrapper
        mbWrap.Close();
        }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);
    fAnswer = TRUE;

CLEANUP_RES:

    // we want to be able to recover a meaningful error, so get it and set it again after
    // restoring the resource handle
    DWORD   err = GetLastError();

	// restore the resources
    if ( hOldRes )
	    AfxSetResourceHandle( hOldRes );

    // reset the error code
    SetLastError( err );

    // return the error - hopefully success
    return fAnswer;
    }


//-------------------------------------------------------------------------
int SetInfoAdminACL( CWrapMetaBase* pMB, LPCTSTR szSubKeyPath )
{
    int retCode=-1;
    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (NULL == pSD)
       goto Cleanup;
    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    // Get Local Admins Sid
    GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);

    // Get everyone Sid
    GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) + 
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) + 
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if (NULL == pACLNew)
       goto Cleanup;
    InitializeAcl(pACLNew, cbACL, ACL_REVISION);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        (MD_ACR_READ |
        MD_ACR_WRITE |
        MD_ACR_RESTRICTED_WRITE |
        MD_ACR_UNSECURE_PROPS_READ |
        MD_ACR_ENUM_KEYS |
        MD_ACR_WRITE_DAC),
        pAdminsSID);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        (MD_ACR_READ | MD_ACR_ENUM_KEYS),
        pEveryoneSID);

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);

    // Security descriptor blob must be self relative
    if (!MakeSelfRelativeSD(pSD, outpSD, &cboutpSD))
       goto Cleanup;
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if (NULL == outpSD)
       goto Cleanup;
    if (!MakeSelfRelativeSD( pSD, outpSD, &cboutpSD ))
       goto Cleanup;

    // below this modify pSD to outpSD

    // Apply the new security descriptor to the file
    dwLength = GetSecurityDescriptorLength(outpSD);


    // set the acl into the metabase at the given location
    b = pMB->SetData( szSubKeyPath, MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA,
                    (LPBYTE)outpSD, dwLength,
                    METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE );

   retCode = 0;

Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (outpSD)
     GlobalFree(outpSD);
  if (pAdminsSID)
    FreeSid(pAdminsSID);
  if (pEveryoneSID)
    FreeSid(pEveryoneSID);
  if (pSD)
    LocalFree((HLOCAL) pSD);
  if (pACLNew)
    LocalFree((HLOCAL) pACLNew);

  return (retCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\metatool.cpp ===
// metatool.cpp : implementation file
//

// some common tools used for "smart" writing to the metabase

#include "stdafx.h"

#define _COMSTATIC
#include <comprop.h>
#include <idlg.h>
#include <resource.h>
#include "wrapmb.h"
#include "metatool.h"


//----------------------------------------------------------------
// open the metabase with an option to create the directory if it doesn't
// exist. It would be nice to move this into wrapmb, but that is too big
// a change for now. Maybe we can do that later.
BOOL OpenAndCreate( CWrapMetaBase* pmb, LPCTSTR pszTarget, DWORD perm, BOOL fCreate )
    {
    BOOL    f;
    CString szTarget = pszTarget;

    // start by just trying to open it. easy easy.
    if ( pmb->Open(szTarget, perm) )
        return TRUE;

    // if requested, try to create the key if it doesn't exist
    if ( fCreate )
        {
        // find the nearest openable parent directory and open it
        CString szPartial;
        CString szBase = szTarget;
        do
            {
            szBase = szBase.Left( szBase.ReverseFind(_T('/')) );
            szPartial = szTarget.Right( szTarget.GetLength() - szBase.GetLength() - 1 );
            f = pmb->Open( szBase, METADATA_PERMISSION_WRITE | perm );
            } while (!f && !szBase.IsEmpty());

        // if all that failed, fail
        if ( !f ) return FALSE;

        // create the key that we really want
        f = pmb->AddObject( szPartial );
        pmb->Close();

        // if all that failed, fail
        if ( !f ) return FALSE;

        // try again
        if ( pmb->Open(szTarget, perm) )
            return TRUE;
        }

    // total washout
    return FALSE;
    }

//----------------------------------------------------------------
// starting at the root, check for values set on sub-keys that may need to be overridden
// and propmt the user for what to do
void CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot, 
                       DWORD dwMDIdentifier, 
                       DWORD dwMDDataType, 
                       DWORD dwMDUserType = IIS_MD_UT_SERVER, 
                       DWORD dwMDAttributes = METADATA_INHERIT)
    {

    //
    // Build a generic title in case this property is custom
    //

    CString strTitle;
    strTitle.Format(IDS_GENERIC_INHERITANCE_TITLE, dwMDIdentifier);

    CInheritanceDlg dlgInherit(
                            TRUE,       // Look in table first
                            dwMDIdentifier,
                            dwMDAttributes,
                            dwMDUserType,
                            dwMDDataType,   
                            strTitle,
                            FROM_WRITE_PROPERTY,
                            pszServer,
                            pszInheritRoot
                    );

    // if it worked, then run the dialog
    if ( !dlgInherit.IsEmpty() )
        dlgInherit.DoModal();
   }

// notice that the dwords and generic blobs are handled seperately even though
// we count route the dwords through the blob mechanisms. This is done for two
// reasone. 1) Handling dwords is much more efficient than handling blobs.
// and 2) Most of the values are dwords.

//----------------------------------------------------------------
// opens the metabase, writes out the value, then uses the inheritence
// checking functionality from the iisui.dll to check for the inherited
// properties and propt the user for what to do
BOOL SetMetaDword(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence)
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   dword;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        if ( mbWrap.GetDword(pszSub, idData, iType, &dword, 0) )
            {
            // set the changed flag
            fChanged = (dwValue != dword);
            }

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetDword( pszSub, idData, iType, dwValue );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;
  
    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData, DWORD_METADATA, iType);
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
BOOL SetMetaData(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence, BOOL fSecure )
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   cbTestData;
    DWORD   flags = METADATA_INHERIT;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot,
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        PVOID pTestData = mbWrap.GetData( pszSub, idData, iType,
                            iDataType, &cbTestData, 0 );
        if ( pTestData )
            {
            // set the changed flag
            if ( cbData == cbTestData )
                {
                fChanged = (memcmp(pData, pTestData, cbData) != 0);
                }            
            mbWrap.FreeWrapData( pTestData );
            }

        // set security if requested
        if ( fSecure )
            flags |= METADATA_SECURE;

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetData( pszSub, idData, iType, iDataType, pData, cbData, flags );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;

    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData , iDataType, iType);
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
BOOL SetMetaString(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence, BOOL fSecure)
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, STRING_METADATA, (LPTSTR)(LPCTSTR)sz,
            (sz.GetLength()+1)*sizeof(TCHAR), fCheckInheritence, fSecure );
    }

//----------------------------------------------------------------
BOOL SetMetaMultiSz(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence )
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, MULTISZ_METADATA, pData, cchmsz*2, fCheckInheritence, FALSE );
    }










//----------------------------------------------------------------
BOOL SetMBData(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fSecure )
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   cbTestData;
    DWORD   flags = METADATA_INHERIT;

    // attempt to get the current value - no inheritence
    PVOID pTestData = pMB->GetData( pszSub, idData, iType,
                        iDataType, &cbTestData, 0 );
    if ( pTestData )
        {
        // set the changed flag
        if ( cbData == cbTestData )
            {
            fChanged = (memcmp(pData, pTestData, cbData) != 0);
            }            
        pMB->FreeWrapData( pTestData );
        }

    // set security if requested
    if ( fSecure )
        flags |= METADATA_SECURE;

    // save it out, if it changed or is not there
    if ( fChanged )
        {
        fAnswer = pMB->SetData( pszSub, idData, iType, iDataType, pData, cbData, flags );
        }
        
    // add it to the change list
    if ( pInheritList && fChanged && fAnswer )
        {
        // prep the inheritence check record
        pInheritList->Add( idData, iDataType, iType, flags );
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
BOOL SetMBDword(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue)
    {
    return SetMBData(pMB, pInheritList, pszSub, idData,
            iType, DWORD_METADATA, &dwValue,
           sizeof(DWORD), FALSE );
    }

//----------------------------------------------------------------
BOOL SetMBString(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fSecure)
    {
    return SetMBData(pMB, pInheritList, pszSub, idData,
            iType, STRING_METADATA, (LPTSTR)(LPCTSTR)sz,
            (sz.GetLength()+1)*sizeof(TCHAR), fSecure );
    }

//----------------------------------------------------------------
BOOL SetMBMultiSz(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz )
    {
    return SetMBData(pMB, pInheritList, pszSub, idData,
            iType, MULTISZ_METADATA, pData, cchmsz*2, FALSE );
    }






//-------------------------------------------------------------
void CCheckInheritList::CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot )
    {
    // get the number of items to check
    DWORD   cItems = (DWORD)rgbItems.GetSize();

    // loop through the items, checking each
    for ( DWORD iItem = 0; iItem < cItems; iItem++ )
        {
        // check the inheritence on the item
        ::CheckInheritence( pszServer, pszInheritRoot, 
                           rgbItems[iItem].dwMDIdentifier, 
                           rgbItems[iItem].dwMDDataType, 
                           rgbItems[iItem].dwMDUserType, 
                           rgbItems[iItem].dwMDAttributes );
        
        }
    }

//-------------------------------------------------------------
INT CCheckInheritList::Add( DWORD dwMDIdentifier, DWORD dwMDDataType, DWORD dwMDUserType, DWORD dwMDAttributes )
    {
    INHERIT_CHECK_ITEM  item;
    item.dwMDIdentifier = dwMDIdentifier;
    item.dwMDDataType = dwMDDataType;
    item.dwMDUserType = dwMDUserType;
    item.dwMDAttributes = dwMDAttributes;
    return (INT)rgbItems.Add( item );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\logui.h ===
// logui.h : main header file for LOGUI.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#define _COMIMPORT

#include "resource.h"       // main symbols
#include <comprop.h>       // common properties symbols
#include "helpmap.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLoguiApp : See logui.cpp for implementation.

class CLoguiApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
    void PrepHelp( OLECHAR* pocMetabasePath );
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;


//    ..\wrapmb\obj\*\wrapmb.lib \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\msftppg.cpp ===
// MsftPpg.cpp : Implementation of the CMsftPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "MsftPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMsftPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsftPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMsftPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsftPropPage, "LOGUI.MsftPropPage.1",
	0x68871e52, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::CMsftPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsftPropPage

BOOL CMsftPropPage::CMsftPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSFT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::CMsftPropPage - Constructor

CMsftPropPage::CMsftPropPage() :
	COlePropertyPage(IDD, IDS_MSFT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMsftPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::DoDataExchange - Moves data between page and properties

void CMsftPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMsftPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\ncsappg.h ===
// NcsaPpg.h : Declaration of the CNcsaPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage : See NcsaPpg.cpp.cpp for implementation.

class CNcsaPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CNcsaPropPage)
	DECLARE_OLECREATE_EX(CNcsaPropPage)

// Constructor
public:
	CNcsaPropPage();

// Dialog Data
	//{{AFX_DATA(CNcsaPropPage)
	enum { IDD = IDD_PROPPAGE_NCSA };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CNcsaPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uiextnd.h ===
#ifndef _EXTNDLOGUI_H_
#define _EXTNDLOGUI_H_


class CFacExtndLogUI : COleObjectFactory
    {
    public:
        CFacExtndLogUI();
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class CExtndCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(CExtndCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpExtndLogUI : public ILogUIPlugin
    {

    public:
        CImpExtndLogUI();
        ~CImpExtndLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpLogUI




#endif  // _EXTNDLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//#define INITGUID

#ifndef _UNICODE
#define _UNICODE
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <afxtempl.h>

#include <aclapi.h>
#include <map>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\msftppg.h ===
// MsftPpg.h : Declaration of the CMsftPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMsftPropPage : See MsftPpg.cpp.cpp for implementation.

class CMsftPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMsftPropPage)
	DECLARE_OLECREATE_EX(CMsftPropPage)

// Constructor
public:
	CMsftPropPage();

// Dialog Data
	//{{AFX_DATA(CMsftPropPage)
	enum { IDD = IDD_PROPPAGE_MSFT };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMsftPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uiextnd.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "wrapmb.h"
#include "logui.h"
#include "uiextnd.h"
#include "LogGenPg.h"
#include "LogExtPg.h"
#include "LogAdvPg.h"
#include "logtools.h"

#include <inetprop.h>

#define OLE_NAME    _T("Extended_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacExtndLogUI::CFacExtndLogUI() :
        COleObjectFactory( CLSID_EXTLOGUI, RUNTIME_CLASS(CExtndCreator), TRUE, OLE_NAME )
    {
    }

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacExtndLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_EXTLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if (AfxOleRegisterServerClass(
				CLSID_EXTLOGUI,
				OLE_NAME,
				_T("LogUI extnd"),
				_T("LogUI extnd"),
				OAT_SERVER,
				(LPCTSTR *)rglpszServerRegister,
				(LPCTSTR *)rglpszServerOverwriteDLL
				)
			)
        {
            return FSetObjectApartmentModel( CLSID_EXTLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CExtndCreator, CCmdTarget)
LPUNKNOWN CExtndCreator::GetInterfaceHook(const void* piid)
    {
    return new CImpExtndLogUI;
    }

//====================== the action

//---------------------------------------------------------------
CImpExtndLogUI::CImpExtndLogUI():
        m_dwRefCount(0)
    {
//    guid = IID_LOGGINGUI;
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpExtndLogUI::~CImpExtndLogUI()
    {
    AfxOleUnlockApp();
    }


//---------------------------------------------------------------
HRESULT CImpExtndLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase* pMB = FInitMetabaseWrapper( pocMachineName );
    if ( !pMB )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // Things could (potentially maybe) throw here, so better protect it.
    try
    {
        // declare the property sheet
        CPropertySheet  propsheet( IDS_SHEET_EXTND_TITLE );
        
        // declare the property pages
        CLogGeneral         pageLogGeneral;
        CLogAdvanced        pageLogAdvanced;
        CLogExtended        pageLogExtended;

        // prepare the common pages
        pageLogGeneral.m_pMB        = pMB;
        pageLogGeneral.m_szMeta     = pocMetabasePath;
        pageLogGeneral.m_szServer   = pocMachineName;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_EXTND_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_EXTND_PREFIX );

        // make the use local time checkbox visible
        pageLogGeneral.m_fShowLocalTimeCheckBox = TRUE;

        // set the local flag
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        // add the pages to the sheet and run
        propsheet.AddPage( &pageLogGeneral );

        // turn on help
        propsheet.m_psh.dwFlags         |= PSH_HASHELP;
        pageLogGeneral.m_psp.dwFlags    |= PSP_HASHELP;

        //
        // Extract the service name from the metabase path
        //

        // For /LM/W3SVC/1 scenario

        CString m_szServiceName(pocMetabasePath+3);
        
        m_szServiceName = m_szServiceName.Left( m_szServiceName.ReverseFind('/'));

        // For /LM/W3SVC scenario

        if (m_szServiceName.IsEmpty())
        {
            m_szServiceName = pocMetabasePath+3;
        }

        CServerCapabilities     serverCap(pocMachineName, m_szServiceName);

        if ( SUCCEEDED(serverCap.LoadData()) && (serverCap.QueryMajorVersion() > 4))
        {
            pageLogAdvanced.m_pMB           = pMB;
            pageLogAdvanced.m_szMeta        = pocMetabasePath;
            pageLogAdvanced.m_szServer      = pocMachineName;
            pageLogAdvanced.m_szServiceName = m_szServiceName;

            // add the pages to the sheet and run
            propsheet.AddPage( &pageLogAdvanced );

            // turn on help
            pageLogAdvanced.m_psp.dwFlags   |= PSP_HASHELP;
        }
        else
        {          
            pageLogExtended.m_pMB       = pMB;
            pageLogExtended.m_szMeta    = pocMetabasePath;
            pageLogExtended.m_szServer  = pocMachineName;

            // add the pages to the sheet and run
            propsheet.AddPage( &pageLogExtended );

            // turn on help
            pageLogExtended.m_psp.dwFlags   |= PSP_HASHELP;
        }

        propsheet.DoModal();
    }
    catch ( CException e )
    {
    }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpExtndLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_EXTLOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpExtndLogUI::AddRef()
    {
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
    }

//---------------------------------------------------------------
ULONG CImpExtndLogUI::Release()
    {
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logui.rc
//
#define IDS_NCSA                        1
#define IDB_NCSA                        1
#define IDS_NCSA_PPG                    2
#define IDB_EXTND                       2
#define IDS_EXTND                       3
#define IDB_ODBC                        3
#define IDS_EXTND_PPG                   4
#define IDB_MSFT                        4
#define IDS_ODBC                        5
#define IDS_ODBC_PPG                    6
#define IDS_MSFT                        7
#define IDS_MSFT_PPG                    8
#define IDS_NCSA_PPG_CAPTION            100
#define IDD_PROPPAGE_NCSA               100
#define IDS_EXTND_PPG_CAPTION           101
#define IDD_PROPPAGE_EXTND              101
#define IDS_ODBC_PPG_CAPTION            102
#define IDD_PROPPAGE_ODBC               102
#define IDS_MSFT_PPG_CAPTION            103
#define IDD_PROPPAGE_MSFT               103
#define IDS_LOG_SHEETTITLE              104
#define IDS_LOG_INVALID_DIR             105
#define IDS_LOG_DAILY_FILESAMPLE        106
#define IDS_LOG_WEEKLY_FILESAMPLE       107
#define IDS_LOG_MONTHLY_FILESAMPLE      108
#define IDS_LOG_NCSA_PREFIX             109
#define IDS_GENERIC_INHERITANCE_TITLE   110
#define IDS_LOG_EXTND_PREFIX            111
#define IDS_LOG_MSFT_PREFIX             112
#define IDS_LOG_SIZE_FILESAMPLE         113
#define IDS_LOG_SIZE_NCSA_PREFIX        114
#define IDS_LOG_SIZE_EXTND_PREFIX       115
#define IDS_LOG_SIZE_MSFT_PREFIX        116
#define IDS_LOG_SIZE_NCSA_PREFIX4       117
#define IDS_MTITLE_NCSA                 118
#define IDS_MTITLE_ODBC                 119
#define IDS_MTITLE_MSFT                 120
#define IDS_MTITLE_XTND                 121
#define IDS_SHEET_NCSA_TITLE            122
#define IDS_SHEET_ODBC_TITLE            123
#define IDS_SHEET_MSFT_TITLE            124
#define IDS_SHEET_EXTND_TITLE           125
#define IDS_HELPLOC_W3SVCHELP           126
#define IDS_HELPLOC_FTPHELP             127
#define IDS_NEED_DIRECTORY              128
#define IDS_LOGUI_ERR_TITLE             129
#define IDS_SHOWN_PASSWORD              130
#define IDS_PASS_CONFIRM_FAIL           131
#define IDS_LOG_UNLIMITED_FILESAMPLE    132
#define IDS_LOG_HOURLY_FILE_SAMPLE      133
#define IDS_UNC_NOT_SUPPORTED           134
#define IDS_REMOTE_NOT_SUPPORTED        134
#define IDS_DATE		                135
#define IDS_TIME                        136
#define IDS_EXTENDED                    137
#define IDS_CLIENT                      138
#define IDS_USER                        139
#define IDS_SERVICE_NAME_T              140
#define IDS_SERVER_NAME_T               141
#define IDS_SERVER_IP                   142
#define IDS_SERVER_PORT                 143
#define IDS_METHOD                      144
#define IDS_URI_STEM                    145
#define IDS_URI_QUERY                   146
#define IDS_PROTOCOL                    147
#define IDS_WIN32                       148
#define IDS_BYTES_SENT_T                149
#define IDS_BYTES_RECEIVED              150
#define IDS_TIME_TAKEN                  151
#define IDS_PROTOCOL_VER                152
#define IDS_HOST                        153
#define IDS_USER_AGENT                  154
#define IDS_COOKIE_T                    155
#define IDS_REFERER                     156
#define IDS_PROCESS_ACCT                157
#define IDS_PROCESS_EVENT               158
#define IDS_PROCESS_TYPE                159
#define IDS_TOTAL_USER_TIME             160
#define IDS_TOTAL_KERNEL_TIME           161
#define IDS_TOTAL_PAGE_FAULTS           162
#define IDS_TOTAL_PROCESSES             163
#define IDS_ACTIVE_PROCESSES            164
#define IDS_TOTAL_TERM_PROCS            165
#define IDD_GEN_LOG                     201
#define IDC_RADIO1                      201
#define IDD_LOG_GENERAL                 201
#define IDC_LOG_UNLIMITED               201
#define IDC_LOG_DAILY                   202
#define IDD_LOG_EXTENDED                203
#define IDC_LOG_WEEKLY                  204
#define IDD_LOG_ODBC                    205
#define IDC_LOG_MONTHLY                 206
#define IDD_ODBC_CONFIRM_PASSWORD       207
#define IDC_LOG_HOURLY                  208
#define IDD_CONFIRM_ODBC_PASSWORD       209
#define IDD_LOG_ADVANCED                210
#define IDB_CHECKBOX                    211
#define IDC_LOG_WHENSIZE                212
#define IDC_SPIN                        213
#define IDC_CHK_DATE                    214
#define IDC_LOG_SIZE                    215
#define IDC_CHK_TIME                    216
#define IDC_LOG_DIRECTORY               217
#define IDC_CHK_CLIENTIP                218
#define IDC_LOG_BROWSE                  219
#define IDC_CHK_USERNAME                220
#define IDC_LOG_SIZE_UNITS              221
#define IDC_CHK_SERVICENAME             222
#define IDC_LOG_FILE_SAMPLE             223
#define IDC_CHK_SERVERNAME              224
#define IDC_CHK_SERVERIP                225
#define IDC_METHOD                      226
#define IDC_CHK_URISTEM                 227
#define IDC_CHK_URI_QUERY               228
#define IDC_CHK_HTTPSTATUS              229
#define IDC_CHK_WIN32STATUS             230
#define IDC_CHK_BYTESSENT               231
#define IDC_CHK_BYTESRECEIVED           232
#define IDC_CHK_TIMETAKEN               233
#define IDC_CHK_USERAGENT               234
#define IDC_CHK_COOKIE                  235
#define IDC_CHK_REFERER                 236
#define IDC_ODBC_DATASOURCE             237
#define IDC_ODBC_TABLE                  238
#define IDC_ODBC_USERNAME               239
#define IDC_ODBC_PASSWORD               240
#define IDC_CHK_SERVERPORT              241
#define IDC_CHK_VERSION                 242
#define IDC_PROP_TREE                   243
#define IDC_USE_LOCAL_TIME              244
#define IDC_ODBC_CONFIRM_PASSWORD       1032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        245
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         245
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uimsft.h ===
#ifndef _MSFTLOGUI_H_
#define _MSFTLOGUI_H_


class CFacMsftLogUI : COleObjectFactory
    {
    public:
        CFacMsftLogUI();
//        virtual CCmdTarget* OnCreateObject( );
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class CMsftCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(CMsftCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpMsftLogUI : public ILogUIPlugin
    {

    public:
        CImpMsftLogUI();
        ~CImpMsftLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpMsftLogUI




#endif  // _MSFTLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uimsft.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uimsft.h"
#include "LogGenPg.h"
#include "wrapmb.h"
#include "logtools.h"

#define OLE_NAME    _T("Msft_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacMsftLogUI::CFacMsftLogUI() :
        COleObjectFactory( CLSID_ASCLOGUI, RUNTIME_CLASS(CMsftCreator), TRUE, OLE_NAME )
    {
    }

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL

};

BOOL CFacMsftLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_ASCLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if ( AfxOleRegisterServerClass(
            CLSID_ASCLOGUI,
            OLE_NAME,
            _T("LogUI msft"),
            _T("LogUI msft"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_ASCLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CMsftCreator, CCmdTarget)
LPUNKNOWN CMsftCreator::GetInterfaceHook(const void* piid)
    {
    return new CImpMsftLogUI;
    }

//====================== the action

//---------------------------------------------------------------
CImpMsftLogUI::CImpMsftLogUI():
        m_dwRefCount(0)
    {
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpMsftLogUI::~CImpMsftLogUI()
    {
    AfxOleUnlockApp();
    }


//---------------------------------------------------------------
HRESULT CImpMsftLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase* pMB = FInitMetabaseWrapper( pocMachineName );
    if ( !pMB )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // prepare the property sheet for action
    CLogGeneral         pageLogGeneral;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_SHEET_MSFT_TITLE );

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // prepare the pages
        pageLogGeneral.m_pMB = pMB;
        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_MSFT_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_MSFT_PREFIX );

        // set the local flag
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        // add the pages to the sheet and run
        propsheet.AddPage( &pageLogGeneral );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpMsftLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_ASCLOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpMsftLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpMsftLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uincsa.h ===
#ifndef _NCSLOGUI_H_
#define _NCSLOGUI_H_


class CFacNcsaLogUI : COleObjectFactory
    {
    public:
        CFacNcsaLogUI();
//        virtual CCmdTarget* OnCreateObject( );
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class CNcsaCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(CNcsaCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpNcsaLogUI : public ILogUIPlugin
    {

    public:
        CImpNcsaLogUI();
        ~CImpNcsaLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpNcsaLogUI




#endif  // _NCSLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uiodbc.h ===
#ifndef _ODBCLOGUI_H_
#define _ODBCLOGUI_H_


class CFacOdbcLogUI : COleObjectFactory
    {
    public:
        CFacOdbcLogUI();
//        virtual CCmdTarget* OnCreateObject( );
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class COdbcCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(COdbcCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpOdbcLogUI : public ILogUIPlugin
    {

    public:
        CImpOdbcLogUI();
        ~CImpOdbcLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpOdbcLogUI




#endif  // _ODBCLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uincsa.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uincsa.h"
#include "LogGenPg.h"
#include "wrapmb.h"
#include "logtools.h"

#define OLE_NAME    _T("NCSA_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacNcsaLogUI::CFacNcsaLogUI() :
        COleObjectFactory( CLSID_NCSALOGUI, RUNTIME_CLASS(CNcsaCreator), TRUE, OLE_NAME )
    {
    }

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL,
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacNcsaLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_NCSALOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if ( AfxOleRegisterServerClass(
            CLSID_NCSALOGUI,
            OLE_NAME,
            _T("LogUI ncsa"),
            _T("LogUI ncsa"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_NCSALOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CNcsaCreator, CCmdTarget)
LPUNKNOWN CNcsaCreator::GetInterfaceHook(const void* piid)
    {
    return new CImpNcsaLogUI;
    }

//====================== the action

//---------------------------------------------------------------
CImpNcsaLogUI::CImpNcsaLogUI():
        m_dwRefCount(0)
    {
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpNcsaLogUI::~CImpNcsaLogUI()
    {
    AfxOleUnlockApp();
    }

//---------------------------------------------------------------
HRESULT CImpNcsaLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase* pMB = FInitMetabaseWrapper( pocMachineName );
    if ( !pMB )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // prepare the property sheet for action
    CLogGeneral         pageLogGeneral;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_SHEET_NCSA_TITLE );

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // prepare the pages
        pageLogGeneral.m_pMB = pMB;

        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_NCSA_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_NCSA_PREFIX );

        // set the local flag
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        // add the pages to the sheet and run
        propsheet.AddPage( &pageLogGeneral );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpNcsaLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_NCSALOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpNcsaLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpNcsaLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\uiodbc.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uiOdbc.h"

#include "LogGenPg.h"
#include "LogODBC.h"
#include "wrapmb.h"
#include "logtools.h"

#define OLE_NAME    _T("Odbc_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacOdbcLogUI::CFacOdbcLogUI() :
        COleObjectFactory( CLSID_ODBCLOGUI, RUNTIME_CLASS(COdbcCreator), TRUE, OLE_NAME )
    {
    }


//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacOdbcLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_ODBCLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if ( AfxOleRegisterServerClass(
            CLSID_ODBCLOGUI,
            OLE_NAME,
            _T("LogUI odbc"),
            _T("LogUI odbc"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_ODBCLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(COdbcCreator, CCmdTarget)
LPUNKNOWN COdbcCreator::GetInterfaceHook(const void* piid)
    {
 //   if ( *piid == IID_ILogPlugin )
        return new CImpOdbcLogUI;
 //   else
 //       return NULL;
    }

//====================== the action

//---------------------------------------------------------------
CImpOdbcLogUI::CImpOdbcLogUI():
        m_dwRefCount(0)
    {
//    guid = IID_LOGGINGUI;
    AfxOleLockApp();
    }

CImpOdbcLogUI::~CImpOdbcLogUI()
    {
    AfxOleUnlockApp();
    }


//---------------------------------------------------------------
HRESULT CImpOdbcLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase* pMB = FInitMetabaseWrapper( pocMachineName );
    if ( !pMB )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // prepare the property sheet for action
    CLogGeneral         pageLogGeneral;
    CLogODBC            pageLogODBC;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_SHEET_ODBC_TITLE );

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // prepare the pages
        pageLogODBC.m_pMB = pMB;
        pageLogGeneral.m_pMB = pMB;

        pageLogODBC.m_szMeta = pocMetabasePath;
        pageLogODBC.m_szServer = pocMachineName;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_EXTND_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_EXTND_PREFIX );

        // add the pages to the sheet and run
//        propsheet.AddPage( &pageLogGeneral );     // don't need general for ODBC
        propsheet.AddPage( &pageLogODBC );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;
	    pageLogODBC.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpOdbcLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_ODBCLOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpOdbcLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpOdbcLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer boydm

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"

/*
#define INITGUID

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <lm.h>

#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <ole2.h>
#include <coguid.h>

*/
#include <iadmw.h>

#include "iiscnfg.h"
#include "wrapmb.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define     MB_TIMEOUT          5000


// a macro to automatically cast the pointer to the mb object
//#define _pmb    ((MB*)m_pvMB)


// globals
//IMSAdminBase*                g_pMBCom = NULL;


//              $(BASEDIR)\private\iis\svcs\lib\*\isdebug.lib \
//              $(BASEDIR)\private\iis\svcs\lib\*\tsstr.lib \
//              $(BASEDIR)\private\iis\svcs\lib\*\tsres.lib
//TARGETLIBS=\
//         ..\..\..\svcs\lib\*\isdebug.lib \
//         ..\..\..\svcs\lib\*\tsstr.lib


//----------------------------------------------------------------
IMSAdminBase*   FInitMetabaseWrapper( OLECHAR* pocMachineName )
    {
    IClassFactory*  pcsfFactory = NULL;
    COSERVERINFO        csiMachineName;
    COSERVERINFO*       pcsiParam = NULL;
    HRESULT             hresError;
    IMSAdminBase*       pMBCom = NULL;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
                return FALSE;

        // create the instance of the interface
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)&pMBCom);

        // release the factory
        pcsfFactory->Release();

        // success
        return pMBCom;
        }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper( IMSAdminBase* pMBCom )
        {
        if ( !pMBCom )
            return FALSE;
        if ( pMBCom )
                {
                pMBCom->Release();
                pMBCom = NULL;
                }
        return TRUE;
        }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
                m_pMetabase( NULL ),
                m_hMeta( NULL ),
                m_count(0),
                m_pBuffer( NULL ),
                m_cbBuffer(0),
                m_pPathBuffer( NULL ),
                m_cchPathBuffer( 0 )
    {
    // attempt to allocate the general buffer
    m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
    if ( m_pBuffer )
        m_cbBuffer = BUFFER_SIZE;
    }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
    {
    // make sure the metabase handle is closed
    Close();

    // free the buffer
    if ( m_pBuffer )
        GlobalFree( m_pBuffer );
    m_pBuffer = NULL;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
    {
    BOOL            fAnswer = FALSE;

    // NULL was passed in, use the global reference - most cases will do this
    if ( pMBCom )
        m_pMetabase = (IMSAdminBase*)pMBCom;

    // if the interface is not there, fail
    if ( !m_pMetabase )
        return FALSE;

    // return success
    return TRUE;
    }


//==========================================================================================
// open, close and save the object and such

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( LPCTSTR pszPath, DWORD dwFlags )
        {
        return Open( METADATA_MASTER_ROOT_HANDLE, pszPath, dwFlags );
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath, DWORD dwFlags )
    {
    m_count++;
    HRESULT hRes;

    // if a metabase handle is already open, close it
    if ( m_hMeta )
        Close();

    hRes = m_pMetabase->OpenKey( hOpenRoot, pszPath, dwFlags, MB_TIMEOUT, &m_hMeta );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
        {
        if ( m_hMeta )
            {
            m_count--;
            m_pMetabase->CloseKey( m_hMeta );
            }
        m_hMeta = NULL;
        return TRUE;
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
        {
        HRESULT hRes = m_pMetabase->SaveData();

        if ( SUCCEEDED( hRes ))
            return TRUE;
        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
        }

// enumerate the objects
//----------------------------------------------------------------
// fortunately, we know that there is a max length to the name of any individual
// key in the metabase of 256 characters
BOOL CWrapMetaBase::EnumObjects( LPCTSTR pszPath, LPTSTR pName, DWORD Index )
    {
    // enumerate into the wide character buffer
    HRESULT hRes = m_pMetabase->EnumKeys( m_hMeta, pszPath, pName, Index );

    // Check for success
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->AddKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->DeleteKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
        {
        return m_hMeta;
        }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                DWORD dwValue, DWORD dwFlags )
    {
    return SetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            (PVOID) &dwValue,
            sizeof( DWORD ),
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPCTSTR pszValue, DWORD dwFlags )
    {
    int len = wcslen( pszValue )+1;
    DWORD cbWide = len * sizeof(WCHAR);

    // set the string into place
    BOOL fAnswer = SetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            (PVOID)pszValue,
            cbWide,            // string length ignored for inprocess clients
            dwFlags );

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                             DWORD* pdwValue, DWORD dwFlags )
    {
    DWORD cb = sizeof(DWORD);
    return GetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            pdwValue,
            &cb,
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPTSTR pszValue, DWORD* pcchValue, DWORD dwFlags )
    {
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pszValue,
            pcchValue,
            dwFlags ) )
        {
        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }

//----------------------------------------------------------------

BOOL CWrapMetaBase::GetMultiSZString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, 
                                     LPTSTR pszValue, DWORD* pcchValue, DWORD dwFlags)
{
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            MULTISZ_METADATA,
            pszValue,
            pcchValue,
            dwFlags ) )
        {
        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
}


//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType )
    {
    // go right ahead and delete it
    HRESULT hRes = m_pMetabase->DeleteData( m_hMeta, pszPath, dwPropID, dwDataType );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName )
    {
    // rename the key
    HRESULT hRes = m_pMetabase->RenameKey( m_hMeta, pszPathOld, pszNewName );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//=====================================================================================

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD cbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    // prepare the set data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // set the data
    hRes = m_pMetabase->SetData( m_hMeta, pszPath, &mdRecord );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // there was an error, clean up
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD* pcbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    // prepare the get data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // get the data
    hRes = m_pMetabase->GetData( m_hMeta, pszPath, &mdRecord, &dwRequiredLen );

    // test for success
    if ( SUCCEEDED( hRes ))
        {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
        }

    // there was a failure - clean up
    *pcbData = dwRequiredLen;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        DWORD* pcbData, DWORD dwFlags )
    {
    PVOID           pData = m_pBuffer;
    DWORD           cbData = m_cbBuffer;
    DWORD           err = 0;
    BOOL            f;

    // first - attempt to get the data in the buffer that has already been allocated;
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if the get data function worked, we can pretty much leave
    if ( f )
        {
        // set the data size
        *pcbData = cbData;
        // return the allocated buffer
        return pData;
        }

    // check the error - it could be some sort of memory error
    err = GetLastError();

    // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
    // otherwise, it is something we can't handle
    if ( err != ERROR_INSUFFICIENT_BUFFER )
        return NULL;

    // allocate the buffer
    pData = GlobalAlloc( GPTR, cbData );
    if ( !pData )
        return NULL;

    // first, get the size of the data that we are looking for
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if that getting failed, we need to cleanup
    if ( !f )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // set the data size
    *pcbData = cbData;

    // return the allocated buffer
    return pData;
    }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
    {
    // if it is trying to free the local buffer, do nothing
    if ( pData == m_pBuffer )
        return;

    // ah - but it was not the local buffer - we should dispose of it
    if ( pData )
        GlobalFree( pData );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\wrap.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
      mb.hxx

   Abstract:
      This module defines the USER-level wrapper class for access to the
      metabase

   Author:

       JohnL  09-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Revision History:

--*/

#ifndef _MB_HXX_
#define _MB_HXX_

#if !defined( dllexp)
#define dllexp               __declspec( dllexport)
#endif // !defined( dllexp)

//
//  Default timeout
//

#define MB_TIMEOUT           5000

//
//  IIS Service pointer
//

#define PINETSVC             g_pInetSvc

/************************************************************
 *   Type Definitions
 ************************************************************/


//
//  Simple wrapper class around the metabase APIs
//
//  The Metabase Interface pointer is assumed to remain valid for the lifetime
//  of this object.
//
//  The character counts for paths should include the terminating '\0'.
//
//

class MB
{
public:

    MB( IMSAdminBase * pMBCom )
        : _pMBCom( pMBCom ),
          _hMB   ( NULL )
    {
    }

    ~MB( VOID )
    {
        Close();
        _pMBCom = NULL;
    }








    inline
    BOOL Open( const TCHAR * pszPath,
               DWORD        dwFlags = METADATA_PERMISSION_READ )
    {
        return Open( METADATA_MASTER_ROOT_HANDLE,
                     pszPath,
                     dwFlags );
    }

    inline
    BOOL Open( METADATA_HANDLE hOpenRoot,
               const TCHAR *    pszPath,
               DWORD           dwFlags = METADATA_PERMISSION_READ );

    /*
    inline
    BOOL GetAll( const TCHAR *   pszPath,
                 DWORD          dwFlags,
                 DWORD          dwUserType,
                 BUFFER *       pBuff,
                 DWORD *        pcRecords,
                 DWORD *        pdwDataSetNumber );
*/

    inline
    BOOL GetDataSetNumber( const TCHAR *   pszPath,
                           DWORD *        pdwDataSetNumber );


    inline
    BOOL EnumObjects( const TCHAR * pszPath,
                      TCHAR *       Name,
                      DWORD        Index )
    {
        HRESULT hRes = _pMBCom->EnumKeys( _hMB,pszPath, Name, Index );

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }

    inline
    BOOL AddObject( const TCHAR * pszPath )
    {
        HRESULT hRes = _pMBCom->AddKey( _hMB, pszPath );
        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }


    //----------------------------------------------------------------- boydm
    inline
    BOOL RenameKey( const TCHAR* pszPath, const TCHAR* pszNewName )
    {
    HRESULT hRes = _pMBCom->RenameKey( _hMB, pszPath, pszNewName );
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

    inline
    BOOL DeleteObject( const TCHAR * pszPath )
    {
        HRESULT hRes = _pMBCom->DeleteKey( _hMB, pszPath );

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }

    inline
    BOOL Save( VOID )
    {
        HRESULT hRes = _pMBCom->SaveData();

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }

    BOOL SetDword( const TCHAR * pszPath,
                   DWORD        dwPropID,
                   DWORD        dwUserType,
                   DWORD        dwValue,
                   DWORD        dwFlags = METADATA_INHERIT )
    {
        return SetData( pszPath,
                        dwPropID,
                        dwUserType,
                        DWORD_METADATA,
                        (PVOID) &dwValue,
                        sizeof( DWORD ),
                        dwFlags );
    }

    BOOL SetString( const TCHAR * pszPath,
                    DWORD        dwPropID,
                    DWORD        dwUserType,
                    TCHAR *       pszValue,
                    DWORD        dwFlags = METADATA_INHERIT )
    {
#ifdef _UNICODE
        return SetData( pszPath,
                        dwPropID,
                        dwUserType,
                        STRING_METADATA,
                        pszValue,
                        (wcslen(pszValue)+1) * 2,          // byte count, not character count
                        dwFlags );
#else
        return SetData( pszPath,
                        dwPropID,
                        dwUserType,
                        STRING_METADATA,
                        pszValue,
                        strlen(pszValue)+1,          // string length ignored for inprocess clients
                        dwFlags );
#endif
    }

    BOOL GetDword( const TCHAR *  pszPath,
                   DWORD         dwPropID,
                   DWORD         dwUserType,
                   DWORD *       pdwValue,
                   DWORD         dwFlags = METADATA_INHERIT )
    {
        DWORD cb = sizeof(DWORD);

        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        DWORD_METADATA,
                        pdwValue,
                        &cb,
                        dwFlags );
    }

    BOOL GetString( const TCHAR *  pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    TCHAR *        pszValue,
                    DWORD *       pcbValue,
                    DWORD         dwFlags = METADATA_INHERIT )
    {
        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        STRING_METADATA,
                        pszValue,
                        pcbValue,
                        dwFlags );
    }

    /*
    inline
    BOOL GetStr( const TCHAR *  pszPath,
                 DWORD         dwPropID,
                 DWORD         dwUserType,
                 STR *         strValue,
                 DWORD         dwFlags = METADATA_INHERIT,
                 const TCHAR *  pszDefault = NULL );
    */

    inline
    BOOL SetData( const TCHAR * pszPath,
                  DWORD        dwPropID,
                  DWORD        dwUserType,
                  DWORD        dwDataType,
                  VOID *       pvData,
                  DWORD        cbData,
                  DWORD        dwFlags = METADATA_INHERIT );

    inline
    BOOL GetData( const TCHAR *  pszPath,
                  DWORD         dwPropID,
                  DWORD         dwUserType,
                  DWORD         dwDataType,
                  VOID *        pvData,
                  DWORD *       cbData,
                  DWORD         dwFlags = METADATA_INHERIT );

    inline
    BOOL DeleteData(const TCHAR *  pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    DWORD         dwDataType )
    {
        HRESULT hRes = _pMBCom->DeleteData( _hMB, pszPath,
                                                    dwPropID,
                                                    dwDataType );

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }
        SetLastError( HRESULTTOWIN32( hRes ));
        return(FALSE);
    }

    BOOL Close( VOID )
    {
        if ( _hMB )
        {
			_pMBCom->CloseKey( _hMB );
            _hMB = NULL;
        }

        return TRUE;
    }

    METADATA_HANDLE QueryHandle( VOID ) const
        { return _hMB; }

private:

    IMSAdminBase *       _pMBCom;
    METADATA_HANDLE _hMB;

};


inline
BOOL
MB::Open(
    METADATA_HANDLE hOpenRoot,
    const TCHAR *    pszPath,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Opens the metabase

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pszPath - Path to open
    dwFlags - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    hRes = _pMBCom->OpenKey( hOpenRoot, pszPath,
                                         dwFlags,
                                         MB_TIMEOUT,
                                         &_hMB );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

inline
BOOL
MB::SetData(
    const TCHAR * pszPath,
    DWORD        dwPropID,
    DWORD        dwUserType,
    DWORD        dwDataType,
    VOID *       pvData,
    DWORD        cbData,
    DWORD        dwFlags
    )
/*++

Routine Description:

    Sets a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    cbData - Size of data
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;


    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->SetData( _hMB, pszPath,
                                      &mdRecord );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

inline
BOOL
MB::GetData(
    const TCHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID *        pvData,
    DWORD *       pcbData,
    DWORD         dwFlags
    )
/*++

Routine Description:

    Retrieves a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->GetData( _hMB, pszPath,
                                      &mdRecord,
                                      &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
    }

    *pcbData = dwRequiredLen;

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

#ifdef O
inline
BOOL MB::GetAll(
    const TCHAR *   pszPath,
    DWORD          dwFlags,
    DWORD          dwUserType,
    BUFFER *       pBuff,
    DWORD *        pcRecords,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath - Path to set data on
    dwFlags - Inerhitance flags
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD   RequiredSize;
    HRESULT hRes;

TryAgain:

    hRes = _pMBCom->GetAllData( _hMB,
                            (unsigned TCHAR *)pszPath,
                            dwFlags,
                            dwUserType,
                            ALL_METADATA,
                            pcRecords,
                            pdwDataSetNumber,
                            pBuff->QuerySize(),
                            (PBYTE)pBuff->QueryPtr(),
                            &RequiredSize
                            );

    // See if we got it, and if we failed because of lack of buffer space
    // try again.

    if ( SUCCEEDED(hRes) )
    {
        return TRUE;
    }

    // Some sort of error, most likely not enough buffer space. Keep
    // trying until we get a non-fatal error.

    if (HRESULT_FACILITY(hRes) == FACILITY_WIN32 &&
        HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER) {

        // Not enough buffer space. RequiredSize contains the amount
        // the metabase thinks we need.

        if ( !pBuff->Resize(RequiredSize) ) {

            // Not enough memory to resize.
            return FALSE;
        }

        goto TryAgain;

    }

    return FALSE;
}
#endif

inline
BOOL MB::GetDataSetNumber(
    const TCHAR *   pszPath,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves the data set number and size of the data from the
    metabase.

Arguments:

    pszPath - Path to set data on
    pdwDataSetNumber - Where to return the data set number.

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    //
    //  We allow _hMB to be null (root handle) for this API (though technically
    //  all the APIs allow the metabase handle to be null)
    //

    hRes = _pMBCom->GetDataSetNumber( _hMB, pszPath, pdwDataSetNumber );

    return SUCCEEDED(hRes);
}

#ifdef O
inline
BOOL
MB::GetStr(
    const TCHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    STR *         pstrValue,
    DWORD         dwFlags,
    const TCHAR *  pszDefault
    )
/*++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath - Path to get data on
    dwPropID - property id to retrieve
    dwUserType - User type for this property
    pstrValue - string that receives the value
    dwFlags - Metabase flags
    pszDefault - Default value to use if the string isn't found, NULL
        for no default value (i.e., will return an error).

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD cbSize = pstrValue->QuerySize();

TryAgain:

    if ( !GetData( pszPath,
                   dwPropID,
                   dwUserType,
                   STRING_METADATA,
                   pstrValue->QueryStr(),
                   &cbSize,
                   dwFlags ))
    {
        if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
        {
            if ( pszDefault != NULL )
            {
                return pstrValue->Copy( pszDefault );
            }

            return FALSE;
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                  pstrValue->Resize( cbSize ) )
        {
            goto TryAgain;
        }

        return FALSE;
    }

    pstrValue->SetLen( cbSize );

    return TRUE;
}
#endif

#endif // _MB_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\logui\wrapmb.h ===
#ifndef _WRAPMB_
#define _WRAPMB_

#include "iadmw.h"

//--------------------------------------------------------
// startup & closeing utilities
IMSAdminBase* FInitMetabaseWrapper( OLECHAR* pocMachineName );
BOOL    FCloseMetabaseWrapper( IMSAdminBase* pMBCom );


//--------------------------------------------------------
class CWrapMetaBase
    {
    public:
    WORD m_count;
    // construct - destruct
    CWrapMetaBase();
    ~CWrapMetaBase();

    // second stage initialization
    BOOL FInit( PVOID pMBCom );

    // open, close and save the object and such
    BOOL Open( LPCTSTR pszPath, DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath,
                                            DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Close( void );
    BOOL Save( void );

    // enumerate the objects
    BOOL EnumObjects( LPCTSTR pszPath, LPTSTR Name, DWORD Index );

    // Add and delete objects
    BOOL AddObject( LPCTSTR pszPath );
    BOOL DeleteObject( LPCTSTR pszPath );

    // rename an object
    BOOL RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName );

    // access the metahandle
    METADATA_HANDLE QueryHandle();

    // setting values
    BOOL SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPCTSTR dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT );

    // getting values
    BOOL GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD* dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD* pcchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetMultiSZString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD* pcchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );
    PVOID GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );

    // deleting values
    BOOL DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType );

	// free memory returned by GetData
	void FreeWrapData( PVOID pData );

    protected:
    // pointer to the real metabase object as defined in mb.hxx
    // by casting it PVOID, those files including this will not have to include mb.hxx, which
    // is the whole point of wrapping it like this.
//        PVOID   m_pvMB;

    // pointer to the dcom interface it should use
    IMSAdminBase*       m_pMetabase;

    // the open metabase handle
    METADATA_HANDLE     m_hMeta;

    // size of the local buffer
    #define BUFFER_SIZE		2000

    // local buffer - allocated once, used many times
    PVOID	m_pBuffer;
    DWORD	m_cbBuffer;


    // path conversion utilities
    WCHAR* PrepPath( LPCTSTR psz );
    void UnprepPath();

    WCHAR*  m_pPathBuffer;
    DWORD   m_cchPathBuffer;
    };


#endif //_WRAPMB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\cinetmgr.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        cinetmgr.cpp

   Abstract:

        Snapin object

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "cinetmgr.h"
#include "connects.h"
#include "dataobj.h"
#include "afxdlgs.h"
#include "constr.h"
#include "metaback.h"
#include "shutdown.h"
#include <shlwapi.h>

#if !MSDEV_BUILD
//
// An odd difference between vc++ and sdk environments.
//
#include <atlimpl.cpp>
#endif !MSDEV_BUILD



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Image background colour for the toolbar buttons
//
#define RGB_BK_IMAGES (RGB(255,0,255))      // purple
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))


static HRESULT
GetSnapinHelpFile(LPOLESTR * lpCompiledHelpFile);

//
// Toolbar Definition.  String IDs for menu and tooltip text will be resolved at initialization
//
static MMCBUTTON SnapinButtons[] =
{
    { IDM_CONNECT    - 1, IDM_CONNECT,    TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_MENU_CONNECT,   (BSTR)IDS_MENU_TT_CONNECT },
 // { IDM_DISCOVER   - 1, IDM_DISCOVER,   TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_MENU_DISCOVER,   (BSTR)IDS_MENU_TT_CONNECT },
    { 0,                  0,              TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),                  _T("") },

    { IDM_START      - 1, IDM_START,      TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_MENU_START,     (BSTR)IDS_MENU_TT_START },
    { IDM_STOP       - 1, IDM_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_MENU_STOP,      (BSTR)IDS_MENU_TT_STOP  },
    { IDM_PAUSE      - 1, IDM_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, (BSTR)IDS_MENU_PAUSE,     (BSTR)IDS_MENU_TT_PAUSE },
    { 0,                  0,              TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),                  _T("") },

    //
    // Add-on tools come here
    //
};



#define NUM_BUTTONS (ARRAYLEN(SnapinButtons))
#define NUM_BITMAPS (5)



//
// Name of our taskpad group
//
const LPCTSTR g_cszTaskGroup = _T("CMTP1");



template <class TYPE>
TYPE * Extract(
    IN LPDATAOBJECT lpDataObject,
    IN unsigned int cf,
    IN int len = -1
    )
/*++

Routine Description:

    Template function to extract information of type TYPE from the data object

Arguments:

    LPDATAOBJECT lpDataObject       : Data object to extract data from
    unsigned int cf                 : Clipboard format describing the info type

Return Value:

    Pointer to type TYPE

--*/
{
    ASSERT(lpDataObject != NULL);

    TYPE * p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc =
    {
        (CLIPFORMAT)cf,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    //
    // Allocate memory for the stream
    //
    if (len < 0)
    {
        len = sizeof(TYPE);
    }

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

    do
    {
        if (stgmedium.hGlobal == NULL)
        {
            break;
        }

        HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);

        if (FAILED(hr))
        {
            break;
        }

        p = (TYPE *)stgmedium.hGlobal;

        if (p == NULL)
        {
            break;
        }
    }
    while (FALSE);

    return p;
}



//
// Data object extraction helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


/*
BOOL 
IsMMCMultiSelectDataObject(
    IN LPDATAOBJECT lpDataObject
    )
{
    if (lpDataObject == NULL)
    {
        return FALSE;
    }

    static UINT s_cf = 0;
    if (s_cf == 0)
    {
        //
        // Multi-select clipboard format not registered -- do it now
        //
        s_cf = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
    }

    FORMATETC fmt = {s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (lpDataObject->QueryGetData(&fmt) == S_OK);
}
*/


CLSID *
ExtractClassID(
    IN LPDATAOBJECT lpDataObject
    )
{
    return Extract<CLSID>(lpDataObject, CDataObject::m_cfCoClass);
}



GUID *
ExtractNodeType(
    IN LPDATAOBJECT lpDataObject
    )
{
    return Extract<GUID>(lpDataObject, CDataObject::m_cfNodeType);
}



wchar_t *
ExtractMachineName(
    IN LPDATAOBJECT lpDataObject
    )
{
    wchar_t * lpszMachineName = Extract<wchar_t>(
        lpDataObject,
        CDataObject::m_cfISMMachineName,
        (MAX_PATH + 1) * sizeof(wchar_t)
        );

    if (lpszMachineName == NULL)
    {
        //
        // This is an extension -- grab the computer management
        // name instead.
        //
        lpszMachineName = Extract<wchar_t>(
            lpDataObject,
            CDataObject::m_cfMyComputMachineName,
            (MAX_PATH + 1) * sizeof(wchar_t)
            );
    }

    return lpszMachineName;
}



INTERNAL *
ExtractInternalFormat(
    IN LPDATAOBJECT lpDataObject
    )
{
    ASSERT(lpDataObject != NULL);
    return Extract<INTERNAL>(lpDataObject, CDataObject::m_cfInternal);
}



//
// IEnumTask Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CEnumTasks::CEnumTasks()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pObject(NULL)
{
}



CEnumTasks::~CEnumTasks()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



HRESULT
CEnumTasks::Next(
    IN ULONG celt,
    IN MMC_TASK * rgelt,
    IN ULONG * pceltFetched
    )
/*++

Routine Description:

    Add next task to taskpad

Arguments:

    ULONG celt,
    MMC_TASK * rgelt,
    ULONG * pceltFetched

Return Value:

    HRESULT

--*/
{
    //
    // Callee fills MMC_TASK elements (via CoTaskMemAlloc)
    //
    ASSERT(!IsBadWritePtr(rgelt, celt * sizeof(MMC_TASK)));

    if (m_pObject == NULL)
    {
        //
        // Must be at the snap-in's root handle
        //
        return S_FALSE;
    }

    //
    // celt will actually always only be 1
    //
    ASSERT(celt == 1);
    HRESULT hr = S_FALSE;

    for (ULONG i = 0; i < celt; ++i)
    {
        MMC_TASK * task = &rgelt[i];

        hr = m_pObject->AddNextTaskpadItem(task);

        if (FAILED(hr))
        {
            if (pceltFetched)
            {
                *pceltFetched = i;
            }

            break;
        }
    }

    //
    // If we get here all is well
    //
    if(pceltFetched)
    {
        *pceltFetched = celt;
    }

    return hr;
}



HRESULT
CEnumTasks::Skip(
    IN ULONG celt
    )
/*++

Routine Description:

    Skip the task index

Arguments:

    ULONG celt      : Number of tasks to skip

Return Value:

    HRESULT

--*/
{
    return E_NOTIMPL;
}



HRESULT
CEnumTasks::Reset()
/*++

Routine Description:

    Result the taskpad enumeration index

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return E_NOTIMPL;
}



HRESULT
CEnumTasks::Clone(
    IN IEnumTASK ** ppenum
    )
/*++

Routine Description:

    Close a task -- obsolete, no longer supported by mmc

Arguments:

    IEnumTASK ** ppenum : Source task to clone

Return Value:

    HRESULT

--*/
{
    return E_NOTIMPL;
}



HRESULT
CEnumTasks::Init(
    IN IDataObject * pdo,
    IN LPOLESTR szTaskGroup
    )
/*++

Routine Description:

    Here is where we see what taskpad we are providing tasks for.
    In our case we know that we only have one taskpad.
    The string we test for is "CMTP1". This was the string following
    the '#' that we passed in GetResultViewType.

Arguments:

    IDataObject * pdo           : Data object
    LPOLESTR szTaskGroup        : Taskpad group name

Return Value:

    HRESULT

--*/
{
    //
    // Return ok if we can handle data object and group.
    //
    if (!lstrcmp(szTaskGroup, g_cszTaskGroup))
    {
        //
        // CODEWORK: How about a helper for this!
        //
        INTERNAL * pInternal = ExtractInternalFormat(pdo);

        if (pInternal == NULL)
        {
            //
            // Extension
            //
            return S_OK;
        }

        m_pObject = (CIISObject *)pInternal->m_cookie;

        return S_OK;
    }

    //
    // Should never happen
    //
    ASSERT(FALSE);

    return S_FALSE;
}


//
// CSnapin class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);



long CSnapin::lDataObjectRefCount = 0;



CSnapin::CSnapin()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pConsole(NULL),
      m_pHeader(NULL),
      m_pResult(NULL),
      m_pImageResult(NULL),
      m_pComponentData(NULL),
      m_pToolbar(NULL),
      m_pControlbar(NULL),
      m_pbmpToolbar(NULL),
      m_pConsoleVerb(NULL),
      m_oblResultItems(),
      m_strlRef(),
      m_fTaskView(FALSE),
      m_fSettingsChanged(FALSE),
      m_fIsExtension(FALSE),
      m_fWinSockInit(FALSE)
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);

#ifdef _DEBUG

    dbg_cRef = 0;

#endif // _DEBUG

}



CSnapin::~CSnapin()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
#ifdef _DEBUG

    ASSERT(dbg_cRef == 0);

#endif // _DEBUG

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    SAFE_RELEASE(m_pToolbar);
    SAFE_RELEASE(m_pControlbar);

    //
    // Make sure the interfaces have been released
    //
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    ASSERT(m_pToolbar == NULL);

    if (m_pbmpToolbar)
    {
        m_pbmpToolbar->DeleteObject();
        delete m_pbmpToolbar;
    }

    //
    // Should have been removed via notification, but just in case:
    //
    ASSERT(m_oblResultItems.GetCount() == 0);
    m_oblResultItems.RemoveAll();
}



LPTSTR
CSnapin::StringReferenceFromResourceID(
    IN UINT nID
    )
/*++

Routine Description:

    Load a string from the resource segment, add it to the internal
    string table, and return a pointer to it.  The pointer will be
    valid for the entire scope of the CSnapin object

Arguments

    UINT nID        : Resource ID

Return Value:

    A pointer to the string.

--*/
{
    CString str;
    VERIFY(str.LoadString(nID));
    m_strlRef.AddTail(str);
    CString & strRef = m_strlRef.GetAt(m_strlRef.GetTailPosition());

    return (LPTSTR)(LPCTSTR)strRef;
}



BOOL
CSnapin::IsEnumerating(
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Return TRUE if we are enumerating our main folder

Arguments:

    LPDATAOBJECT lpDataObject : Data object

Return Value:

    TRUE if we are enumerating our main folder, FALSE if not

--*/
{
    BOOL bResult = FALSE;

    ASSERT(lpDataObject);
    GUID * nodeType = ExtractNodeType(lpDataObject);

    //
    // Is this my main node (static folder node type)
    //
    bResult = ::IsEqualGUID(*nodeType, cInternetRootNode);

    //
    // Free resources
    //
    FREE_DATA(nodeType);

    return bResult;
}



//
// CSnapin's IComponent implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDMETHODIMP
CSnapin::GetResultViewType(
    IN  MMC_COOKIE cookie,
    OUT BSTR * ppViewType,
    OUT long * pViewOptions
    )
/*++

Routine Description:

    Tell MMC what our result view looks like

Arguments:

    MMC_COOKIE cookie   : Currently selected cookie
    BSTR * ppViewType   : Return view type here
    long * pViewOptions : View options

Return Value:

    S_FALSE to use default view type, S_OK indicates the
    view type is returned in *ppViewType

--*/
{
//
// Taskpads not supported for beta2
//
#if TASKPADS_SUPPORTED

    if (m_fTaskView)
    {
        //
        // We will use the default DHTML provided by MMC. It actually
        // resides as a resource inside MMC.EXE. We just get the path
        // to it and use that.
        //
        // The one piece of magic here is the text following the '#'. That
        // is the special way we have of identifying they taskpad we are
        // talking about. Here we say we are wanting to show a taskpad
        // that we refer to as "CMTP1". We will actually see this string
        // pass back to us later.  If someone is extending our taskpad,
        // they also need to know what this secret string is.
        //
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;

        CString strResURL;
        HRESULT hr = BuildResURL(strResURL, NULL);

        if (FAILED(hr))
        {
            return hr;
        }

        strResURL += _T("/default.htm#");
        strResURL += g_cszTaskGroup;

        TRACEEOLID("Taskpad URL is " << strResURL);
        *ppViewType = CoTaskDupString((LPCOLESTR)strResURL);

        return S_OK;
    }

#endif // TASKPADS_SUPPORTED

    //
    // Use default view
    //
    *pViewOptions = MMC_VIEW_OPTIONS_USEFONTLINKING;
    //*pViewOptions = MMC_VIEW_OPTIONS_USEFONTLINKING
    //    | MMC_VIEW_OPTIONS_LEXICAL_SORT;

    return S_FALSE;
}



STDMETHODIMP
CSnapin::Initialize(
    IN LPCONSOLE lpConsole
    )
/*++

Routine Description:

   Initialize the console

Arguments"

    LPCONSOLE lpConsole         : Pointer to console

Return Value:

    HRESULT

--*/
{
    ASSERT(lpConsole != NULL);

    ::AfxEnableControlContainer();

    //
    // Initialize IISUI extension DLL
    //

#ifndef _COMSTATIC

    //
    // Initialize IISUI extension DLL
    //
    InitIISUIDll();

#endif // _COMSTATIC

    //
    // Initialise winsock
    //
    // ISSUE: If proxy is installed, this might take a long time
    //        if the proxy server is in a hung state.
    //
    WSADATA wsaData;
    m_fWinSockInit = (::WSAStartup(MAKEWORD(1, 1), &wsaData) == 0);

    //
    // Save the IConsole pointer
    //
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    //
    // Load resource strings
    //
    LoadResources();

    //
    // QI for a IHeaderCtrl
    //
    HRESULT hr = m_pConsole->QueryInterface(
        IID_IHeaderCtrl,
        (void **)&m_pHeader
        );

    //
    // Give the console the header control interface pointer
    //
    if (SUCCEEDED(hr))
    {
        m_pConsole->SetHeader(m_pHeader);
    }

    m_pConsole->QueryInterface(
        IID_IResultData,
        (void **)&m_pResult
        );

    m_pConsole->QueryResultImageList(&m_pImageResult);
    m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    //
    //  Resolve tool tips texts
    //
    CString str;

    static BOOL fInitialised = FALSE;

    if (!fInitialised)
    {
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        for (int i = 0; i < NUM_BUTTONS; ++i)
        {
            if (SnapinButtons[i].idCommand != 0)
            {
                SnapinButtons[i].lpButtonText = StringReferenceFromResourceID(
                    (UINT)PtrToUlong(SnapinButtons[i].lpButtonText));

                SnapinButtons[i].lpTooltipText = StringReferenceFromResourceID(
                    (UINT)PtrToUlong(SnapinButtons[i].lpTooltipText));
            }
        }

        fInitialised = TRUE;
    }

    return S_OK;
}



STDMETHODIMP
CSnapin::Notify(
    IN LPDATAOBJECT lpDataObject,
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Notification handler

Arguments:

    LPDATAOBJECT lpDataObject   : Data object
    MMC_NOTIFY_TYPE event       : Event
    LPARAM arg                  : Argument
    LPARAM param                : Parameter

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    INTERNAL * pInternal = NULL;
    MMC_COOKIE cookie;

    switch(event)
    {
    case MMCN_REFRESH:
    case MMCN_RENAME:
        //
        // Delegate it to the IComponentData
        //
        ASSERT(m_pComponentData != NULL);
        hr = m_pComponentData->Notify(lpDataObject, event, arg, param);

    case MMCN_PROPERTY_CHANGE:
        hr = OnPropertyChange(lpDataObject);
        break;

    case MMCN_DELETE:
        //
        // Let IComponentData do the deletion, then refresh the parent object
        //
        ASSERT(m_pComponentData != NULL);
        hr = m_pComponentData->Notify(lpDataObject, event, arg, param);
        m_pComponentData->Notify(lpDataObject, MMCN_REFRESH, arg, param);

    case MMCN_VIEW_CHANGE:
        hr = OnUpdateView(lpDataObject);
        break;

    case MMCN_SNAPINHELP:
    case MMCN_CONTEXTHELP:
       {
          LPOLESTR pCompiledHelpFile = NULL;
          if (SUCCEEDED(hr = GetSnapinHelpFile(&pCompiledHelpFile)))
          {
             IDisplayHelp * pdh;
             if (SUCCEEDED(hr = m_pConsole->QueryInterface(
             		IID_IDisplayHelp, (void **)&pdh)))
             {
                CString topic = PathFindFileName(pCompiledHelpFile);
                topic += _T("::/iint1.htm");
				LPTSTR p = topic.GetBuffer(topic.GetLength());
           	    hr = pdh->ShowTopic(p);
				topic.ReleaseBuffer();
                pdh->Release();
             }
          }
          if (FAILED(hr))
          {
             CError err(hr);
             err.MessageBoxOnFailure();
          }
          CoTaskMemFree(pCompiledHelpFile);
       }
       break;

    default:
        //
        // don't process the internal format if the dataobject is null.
        //
        if (lpDataObject == NULL)
        {
            return S_OK;
        }

        INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal == NULL)
        {
            //
            // Extension
            //
            TRACEEOLID("This is an (CSnapin) EXTENSION");
            cookie = NULL;
            CIISObject::m_fIsExtension = m_fIsExtension = TRUE;
        }
        else
        {
            cookie = pInternal->m_cookie;
            FREE_DATA(pInternal);
        }

        switch(event)
        {
        case MMCN_CLICK:
        case MMCN_DBLCLICK:
            hr = OnResultItemClkOrDblClk(cookie, (event == MMCN_DBLCLICK));
            break;

        case MMCN_ADD_IMAGES:
            OnAddImages(cookie, arg, param);
            break;

        case MMCN_SHOW:
            hr = OnShow(cookie, arg, param);
            break;

        case MMCN_ACTIVATE:
            hr = OnActivate(cookie, arg, param);
            break;

        case MMCN_MINIMIZED:
            hr = OnMinimize(cookie, arg, param);
            break;

        case MMCN_BTN_CLICK:
            break;

        case MMCN_SELECT:
            HandleStandardVerbs(arg, lpDataObject);
            break;

        case MMCN_COLUMN_CLICK:
            break;

        case MMCN_MENU_BTNCLICK:
            break;

        default:
            ASSERT(FALSE);  // Handle new messages
            hr = E_UNEXPECTED;
            break;
        }
    }

    return hr;
}



STDMETHODIMP
CSnapin::Destroy(
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Destruction handler

Arguments:

    MMC_COOKIE cookie     : Currently selected cookie

Return Value:

    HRESULT

--*/
{
    //
    // Release the interfaces that we QI'ed
    //
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (m_pConsole != NULL)
    {
        //
        // Tell the console to release the header control interface
        //
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE_SETTONULL(m_pHeader);
        SAFE_RELEASE_SETTONULL(m_pResult);
        SAFE_RELEASE_SETTONULL(m_pImageResult);
        SAFE_RELEASE_SETTONULL(m_pConsole);
        SAFE_RELEASE_SETTONULL(m_pComponentData);
        SAFE_RELEASE_SETTONULL(m_pConsoleVerb);
        SAFE_RELEASE_SETTONULL(m_pToolbar);
        SAFE_RELEASE_SETTONULL(m_pControlbar);
    }

    //
    // Terminate use of the WinSock routines.
    //
    if (m_fWinSockInit)
    {
        ::WSACleanup();
        m_fWinSockInit = FALSE;
    }

    //
    // Everything OK
    //
    return S_OK;
}



STDMETHODIMP
CSnapin::QueryDataObject(
    IN  MMC_COOKIE cookie,
    IN  DATA_OBJECT_TYPES type,
    OUT LPDATAOBJECT * ppDataObject
    )
/*++

Routine Description:

    Get dataobject info

Arguments:

    MMC_COOKIE cookie   : cookie
    DATA_OBJECT_TYPES   : Data object type
    LPDATAOBJECT *      : Returns the data object

Return Value:

    HRESULT

--*/
{
    //
    // Delegate it to the IComponentData
    //
    ASSERT(m_pComponentData != NULL);

    return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
}



void
CSnapin::LoadResources()
/*++

Routine Description:

    Load resource belong to the main snapin

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Load strings from resources
    //
}



//
// IExtendPropertySheet Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDMETHODIMP
CSnapin::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle,
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle
    LPDATAOBJECT lpDataObject           : Data object

Return Value:

    HRESULT

--*/
{
    return static_cast<CComponentDataImpl *>(m_pComponentData)->CreatePropertyPages(
        lpProvider,
        handle,
        lpDataObject
        );
}



STDMETHODIMP
CSnapin::QueryPagesFor(
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Check to see if a property sheet should be brought up for this data
    object

Arguments:

    LPDATAOBJECT lpDataObject       : Data object

Return Value:

    S_OK, if properties may be brought up for this item, S_FALSE otherwise

--*/
{
    return static_cast<CComponentDataImpl *>(m_pComponentData)->QueryPagesFor(
        lpDataObject
        );
}



HRESULT
CSnapin::InitializeHeaders(
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Initialize the result view headers for this cookie

Arguments:

    MMC_COOKIE cookie     : Current cookie

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = (CIISObject *)cookie;

    //
    // The result pane is always one level behind the scope pane
    // for a folder object
    //
    if (pObject == NULL)
    {
        CIISMachine::InitializeHeaders(m_pHeader);
    }
    else
    {
        pObject->InitializeChildHeaders(m_pHeader);
    }

    return S_OK;
}



class CImage : public CObjectPlus
/*++

Class Description:

    A structure to tie a bitmap together with a background
    colour mask

Public Interface:

    CImage      : Constructor
    ~CImage     : Destructor

Notes: This image owns the bitmap and will delete it upon
       destruction.

--*/
{
//
// Constructor/Destructor
//
public:
    CImage(
        IN CBitmap * pbmp,
        IN COLORREF rgb
        )
        : m_pbmp(pbmp),
          m_rgb(rgb)
    {
    }

    ~CImage()
    {
        ASSERT(m_pbmp != NULL);
        m_pbmp->DeleteObject();
        delete m_pbmp;
    }

//
// Access
//
public:
    //
    // Get the bitmap object
    //
    CBitmap & GetBitmap() { return *m_pbmp; }

    //
    // Get the background colour definition
    //
    COLORREF & GetBkColor() { return m_rgb; }

private:
    CBitmap * m_pbmp;
    COLORREF m_rgb;
};



//
// Global oblists of service bitmaps -- used by scope and result side
//
CObListPlus g_obl16x16;
CObListPlus g_obl32x32;



//
// Add-on-tools definitions
//
CObListPlus g_oblAddOnTools;



HRESULT
CSnapin::InitializeBitmaps(
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Initialize the service bitmaps

Arguments:

    MMC_COOKIE cookie         : Currently selected cookie (CIISObject *)

Return Value:

    HRESULT

--*/
{
    ASSERT(m_pImageResult != NULL);

    CBitmap bmp16x16,
            bmp32x32,
            bmpMgr16x16,
            bmpMgr32x32;

    {
        //
        // Load the bitmaps from the dll
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        VERIFY(bmp16x16.LoadBitmap(IDB_VIEWS16));
        VERIFY(bmp32x32.LoadBitmap(IDB_VIEWS32));
        VERIFY(bmpMgr16x16.LoadBitmap(IDB_INETMGR16));
        VERIFY(bmpMgr32x32.LoadBitmap(IDB_INETMGR16));
    }

    //
    // Set the images
    //
    HRESULT hr = m_pImageResult->ImageListSetStrip(
        (LONG_PTR *)(HBITMAP)bmp16x16,
        (LONG_PTR *)(HBITMAP)bmp32x32,
        0,
        RGB_BK_IMAGES
        );
    ASSERT(hr == S_OK);
    
    //
    // Add on inetmgr bitmap
    //
    hr = m_pImageResult->ImageListSetStrip(
        (LONG_PTR *)(HBITMAP)bmpMgr16x16,
        (LONG_PTR *)(HBITMAP)bmpMgr32x32,
        BMP_INETMGR,
        RGB_BK_IMAGES
        );

    //
    // Add the ones from the service config DLLs
    //
    POSITION pos16x16 = g_obl16x16.GetHeadPosition();
    POSITION pos32x32 = g_obl32x32.GetHeadPosition();

    int i = BMP_SERVICE;

    while (pos16x16 && pos32x32)
    {
        CImage * pimg16x16 = (CImage *)g_obl16x16.GetNext(pos16x16);
        CImage * pimg32x32 = (CImage *)g_obl32x32.GetNext(pos32x32);
        ASSERT(pimg16x16 && pimg32x32);

        hr = m_pImageResult->ImageListSetStrip(
            (LONG_PTR *)(HBITMAP)pimg16x16->GetBitmap(),
            (LONG_PTR *)(HBITMAP)pimg32x32->GetBitmap(),
            i++,
            pimg16x16->GetBkColor()
            );

        ASSERT(hr == S_OK);
    }

    return hr;
}



STDMETHODIMP
CSnapin::GetDisplayInfo(
    IN LPRESULTDATAITEM lpResultDataItem
    )
/*++

Routine Description:

    Get display info for result item

Arguments:

    LPRESULTDATAITEM lpResultDataItem : Address of result data tiem

Return Value:

    HRESULT

--*/
{
    wchar_t * szString = _T("");

    ASSERT(lpResultDataItem != NULL);

    static int nImage = -1;
    static CString str;

    if (lpResultDataItem)
    {
        CIISObject * pObject = (CIISObject *)lpResultDataItem->lParam;
        ASSERT(pObject != NULL);

        if (pObject != NULL && pObject->IsValidObject())
        {
            pObject->GetResultDisplayInfo(lpResultDataItem->nCol, str, nImage);
            lpResultDataItem->str = (LPTSTR)(LPCTSTR)str;
            lpResultDataItem->nImage = nImage;
            return S_OK;
        }
    }
    return S_FALSE;
}



//
// IExtendContextMenu Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



STDMETHODIMP
CSnapin::AddMenuItems(
    IN LPDATAOBJECT lpDataObject,
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN long * pInsertionAllowed
    )
/*++

Routine Description:

    Add menu items -- pass it on the the component date

Arguments:

    LPDATAOBJECT lpDataObject                    : Data object
    LPCONTEXTMENUCALLBACK lpContextMenuCallback  : Context menu
    long * pInsertionAllowed                     : TRUE if insertion is allowed

Return Value:

    HRESULT

--*/
{
//
// Cut support for taskpads in beta2
//
#if TASKPADS_SUPPORTED

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //
        // Add View Menu Items
        //
        CIISObject::AddMenuItemByCommand(
            lpContextMenuCallback,
            IDM_VIEW_TASKPAD,
            m_fTaskView ? MF_CHECKED : 0
            );
    }

#endif // TASKPADS_SUPPORTED

    //
    // Pass it on to CComponentDataImpl
    //
    return static_cast<CComponentDataImpl *>(m_pComponentData)->AddMenuItems(
        lpDataObject,
        lpContextMenuCallback,
        pInsertionAllowed
        );
}



STDMETHODIMP
CSnapin::Command(
    IN long nCommandID,
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Command handler -- pass it on the component data

Arguments:

    long nCommandID             : Command ID
    LPDTATAOBJECT lpDataObject  : Data object

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    INTERNAL * pInternal = NULL;

    switch(nCommandID)
    {
    case -1:
        //
        // Built-in views -- everything handled.
        //
        m_fTaskView = FALSE;
        m_fSettingsChanged = TRUE;
        break;

#if TASKPADS_SUPPORTED

    //
    // No taskpad support in beta2
    //
    case IDM_VIEW_TASKPAD:
        //
        // Handle view change
        //
        m_fTaskView = !m_fTaskView;
        m_fSettingsChanged = TRUE;

        //
        // Reselect current scope item to force view change
        //
        pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal != NULL)
        {
            CIISObject * pObject = (CIISObject *)pInternal->m_cookie;
            FREE_DATA(pInternal);

            if (pObject)
            {
                m_pConsole->SelectScopeItem(pObject->GetScopeHandle());
            }
            else
            {
                //
                // Must be the root item
                //
                m_pConsole->SelectScopeItem(
                    static_cast<CComponentDataImpl *>(m_pComponentData)->GetRootHandle()
                    );
            }
        }
        break;

#endif // TASKPADS_SUPPORTED

    default:
        //
        // Pass it on to CComponentDataImpl
        //
        hr = static_cast<CComponentDataImpl *>(m_pComponentData)->Command(
            nCommandID,
            lpDataObject
            );
    }

    return hr;
}



//
// ITaskPad implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
CSnapin::TaskNotify(
    IN IDataObject * pdo,
    IN VARIANT * pvarg,
    IN VARIANT * pvparam
    )
/*++

Routine Description:

    Handle notification from taskpad

Arguments:

    IDataObject * pdo,
    VARIANT * pvarg,
    VARIANT * pvparam

Return Value:

    HRESULT

--*/
{
    if (pvarg->vt == VT_I4)
    {
        //
        // Pass it on to CComponentDataImpl
        //
        return static_cast<CComponentDataImpl *>(m_pComponentData)->Command(
            pvarg->lVal,
            pdo
            );
   }

   return S_OK;
}



HRESULT
CSnapin::GetTitle(
    IN  LPOLESTR szGroup,
    OUT LPOLESTR * lpszTitle
    )
/*++

Routine Description:

    Get the title of the taskpad

Arguments:

    LPOLESTR szGroup        : Group name
    LPOLESTR * szTitle      : Returns title

Return Value:

    HRESULT

--*/
{
    OLECHAR sztitle[] = L"IIS TaskPad";

    *lpszTitle = CoTaskDupString(sztitle);

    return *lpszTitle != NULL ? S_OK : E_OUTOFMEMORY;
}



HRESULT
CSnapin::GetDescriptiveText(
    IN  LPOLESTR szGroup,
    OUT LPOLESTR * lpszDescriptiveText
    )
/*++

Routine Description:

    Get the descriptive text

Arguments:

    LPOLESTR szGroup        : Group name
    LPOLESTR * szTitle      : Returns title

Return Value:

    HRESULT

--*/
{
    return E_NOTIMPL;
}



HRESULT
CSnapin::GetBanner(
    IN  LPOLESTR szGroup,
    OUT LPOLESTR * pszBitmapResource
    )
/*++

Routine Description:

    Get the banner resource

Arguments:

    LPOLESTR szGroup                : Group name
    LPOLESTR * pszBitmapResource    : Returns bitmap resource

Return Value:

    HRESULT

--*/
{
    CString strResURL;
    HRESULT hr = BuildResURL(strResURL);
    if (FAILED(hr))
    {
        return hr;
    }

    strResURL += _T("/img\\ntbanner.gif");
    TRACEEOLID(strResURL);

    *pszBitmapResource = CoTaskDupString((LPCOLESTR)strResURL);

    return *pszBitmapResource != NULL ? S_OK : E_OUTOFMEMORY;
}



HRESULT
CSnapin::GetBackground(
    IN  LPOLESTR szGroup,
    OUT MMC_TASK_DISPLAY_OBJECT * pTDO
    )
/*++

Routine Description:

    Get the background resource

Arguments:

    LPOLESTR szGroup                : Group name
    LPOLESTR * pszBitmapResource    : Returns bitmap resource

Return Value:

    HRESULT

--*/
{
    return E_NOTIMPL;
}



HRESULT
CSnapin::EnumTasks(
    IN  IDataObject * pdo,
    IN  LPOLESTR szTaskGroup,
    OUT IEnumTASK ** ppEnumTASK
    )
/*++

Routine Description:

    Enumerate the tasks on the taskpad

Arguments:

    IDataObject * pdo           : Data object selected;
    LPOLESTR szTaskGroup,       : Taskgroup name
    IEnumTASK ** ppEnumTASK     : Returns enumtask interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    try
    {
        ASSERT(ppEnumTASK != NULL);

        CComObject<CEnumTasks>* pObject;
        CComObject<CEnumTasks>::CreateInstance(&pObject);
        ASSERT(pObject != NULL);
        VERIFY(SUCCEEDED(pObject->Init(pdo, szTaskGroup)));

        hr = pObject->QueryInterface(
            IID_IEnumTASK,
            reinterpret_cast<void **>(ppEnumTASK)
            );
    }
    catch(CMemoryException * e)
    {
        e->Delete();
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//
// IExtendControlbar implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDMETHODIMP
CSnapin::SetControlbar(
    IN LPCONTROLBAR lpControlbar
    )
/*++

Routine Description:

    Set the control bar

Arguments:

    LPCONTROLBAR lpControlbar   : Pointer to control bar

Return Value:

    HRESULT

--*/
{
    if (lpControlbar != NULL)
    {
        //
        // Hold on to the controlbar interface.
        //
        if (m_pControlbar != NULL)
        {
            m_pControlbar->Release();
        }

        m_pControlbar = lpControlbar;
        m_pControlbar->AddRef();

        HRESULT hr = S_FALSE;

        //
        // Create the Toolbar
        //
        if (!m_pToolbar)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, (LPUNKNOWN *)&m_pToolbar);
            ASSERT(SUCCEEDED(hr));

            m_pbmpToolbar = new CBitmap;
            {
                //
                // Add the bitmap
                //
                AFX_MANAGE_STATE(AfxGetStaticModuleState());
                m_pbmpToolbar->LoadBitmap(IDB_TOOLBAR);
            }

            //
            // Add 16x16 bitmaps
            //
            hr = m_pToolbar->AddBitmap(
                NUM_BITMAPS,
                (HBITMAP)*m_pbmpToolbar,
                16,
                16,
                TB_COLORMASK
                );

            ASSERT(SUCCEEDED(hr));

            //
            // Add the buttons to the toolbar
            //
            hr = m_pToolbar->AddButtons(NUM_BUTTONS, SnapinButtons);
            ASSERT(SUCCEEDED(hr));

            //
            // Now add the add-on tools
            //
            POSITION pos = g_oblAddOnTools.GetHeadPosition();

            //
            // Toolbar buttons were created using buttonface
            // background colour
            //
            COLORREF rgbMask = ::GetSysColor(COLOR_BTNFACE);
            while (pos != NULL)
            {
                CISMShellExecutable * pTool =
                    (CISMShellExecutable *)g_oblAddOnTools.GetNext(pos);
                ASSERT(pTool != NULL);

                if (pTool->ShowInToolBar())
                {
                    if (pTool->InitializedOK())
                    {
                        //
                        // Add 16x16 image
                        //
                        hr = m_pToolbar->AddBitmap(
                            1,
                            pTool->GetBitmap(),
                            16,
                            16,
                            rgbMask
                            );
                        ASSERT(SUCCEEDED(hr));

                        hr = m_pToolbar->AddButtons(1, pTool->GetButton());
                        ASSERT(SUCCEEDED(hr));
                    }
                }
            }
        }
    }
    else
    {
        SAFE_RELEASE_SETTONULL(m_pControlbar);
    }

    return S_OK;
}



CISMShellExecutable *
CSnapin::GetCommandAt(
    IN CObListPlus & obl,
    IN int nIndex
    )
/*++

Routine Description:

    Get the add-on tool at the given index.

Arguments:

    int nIndex : Index where to look for the add-on tool

Return Value:

    Shell Executable object pointer, or NULL if the index was not valid

--*/
{
    if (nIndex < 0 || nIndex >= obl.GetCount())
    {
        TRACEEOLID("Invalid tool index requested");

        return NULL;
    }

    return (CISMShellExecutable *)obl.GetAt(obl.FindIndex(nIndex));
}



HRESULT
CSnapin::SetToolbarStates(
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Set toolbar states based on current selection

Arguments:

    MMC_COOKIE cookie     : Currently selected scope item cookie (CIISObject *)

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = (CIISObject *)cookie;

    if (m_pToolbar)
    {
        m_pToolbar->SetButtonState(
            IDM_CONNECT,
            ENABLED,
            !CIISObject::m_fIsExtension
            );

        m_pToolbar->SetButtonState(
            IDM_PAUSE,
            ENABLED,
            pObject && pObject->IsPausable()
            );

        m_pToolbar->SetButtonState(
            IDM_START,
            ENABLED,
            pObject && pObject->IsStartable()
            );

        m_pToolbar->SetButtonState(
            IDM_STOP,
            ENABLED,
            pObject && pObject->IsStoppable()
            );

        m_pToolbar->SetButtonState(
            IDM_PAUSE,
            BUTTONPRESSED,
            pObject && pObject->IsPaused()
            );
    }

    return S_OK;
}



HRESULT
CSnapin::OnButtonClick(
    IN LPDATAOBJECT lpDataObject,
    IN long lID
    )
/*++

Routine Description:

    Handle toolbar button click

Arguments:

    LPDATAOBJECT lpDataObject  : Current data object
    LONG lID                   : Button ID pressed

Return Value:

    HRESULT

--*/
{
    //
    // Check to see if the button ID is in the add-on tools
    // range
    //
    if (lID >= IDM_TOOLBAR)
    {
        INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);
        CIISObject * pObject = pInternal
            ? (CIISObject *)pInternal->m_cookie
            : NULL;

        //
        // Button ID was in the add-on tools range.  Match
        // up the ID with the add-on tool, and execute same.
        //
        CISMShellExecutable * pTool = GetCommandAt(
            g_oblAddOnTools,
            lID - IDM_TOOLBAR
            );

        ASSERT(pTool != NULL);
        if (pTool != NULL)
        {
           CError err;

           if (pObject == NULL)
           {
               //
               // Nothing selected, execute with no parameters
               //
               err = pTool->Execute();
           }
           else
           {
               //
               // Pass server/service to the add-on tool
               //
               LPCTSTR lpstrServer = pObject->GetMachineName();
               LPCTSTR lpstrService = pObject->GetServiceName();
               err = pTool->Execute(lpstrServer, lpstrService);
           }

           if (err.Failed())
           {
               AFX_MANAGE_STATE(AfxGetStaticModuleState());
               err.MessageBox();
           }
        }
        FREE_DATA(pInternal);
    }
    else
    {
        //
        // Otherwise, it maps to a menu command, pass it on to the
        // component data
        //
        ASSERT(m_pComponentData != NULL);
        ((CComponentDataImpl *)m_pComponentData)->Command(lID, lpDataObject);
    }

    return S_OK;
}



void
CSnapin::HandleStandardVerbs(
    IN LPARAM arg,
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Set the standard verb states based on current selection

Arguments:

    LPARAM arg                  : Argument
    LPDATAOBJECT lpDataObject   : Selected data object

Return Value:

    None

--*/
{
    if (lpDataObject == NULL || m_pConsoleVerb == NULL)
    {
        return;
    }

    CIISObject * pObject = NULL;
    INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

    if (pInternal != NULL)
    {
        pObject = (CIISObject *)pInternal->m_cookie;
    }

    m_pConsoleVerb->SetVerbState(
        MMC_VERB_RENAME,
        ENABLED,
        pObject && pObject->IsRenamable()
        );

    m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(
        MMC_VERB_DELETE,
        ENABLED,
        pObject && pObject->IsDeletable()
        );

    m_pConsoleVerb->SetVerbState(
        MMC_VERB_REFRESH,
        ENABLED,
        pObject && pObject->IsRefreshable()
        );

#ifdef MMC_PAGES

    BOOL fConfig = pObject && pObject->IsMMCConfigurable();
    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED,fConfig);

    if (pObject && pObject->IsLeafNode())
    {
        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }
    else
    {
        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }

#else

    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);

#endif

}



void
CSnapin::HandleToolbar(
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Handle toolbar states

Arguments:

    LPARAM arg          : Selection change notification argument
    LPARAM param        : Selection change notification parameter

Return Value:

    None.

--*/
{
    INTERNAL * pInternal = NULL;
    CIISObject * pObject = NULL;
    HRESULT hr;
    LPDATAOBJECT lpDataObject = NULL;
    BOOL bScope = (BOOL)LOWORD(arg);
    BOOL bSelect = (BOOL)HIWORD(arg);

    if (bScope)
    {
        lpDataObject = (LPDATAOBJECT)param;

        if (lpDataObject != NULL)
        {
            pInternal = ExtractInternalFormat(lpDataObject);
        }

        if (pInternal == NULL)
        {
            return;
        }

        pObject = (CIISObject *)pInternal->m_cookie;

        //
        // Attach the toolbars to the window
        //
        if (m_pControlbar != NULL)
        {
            hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN)m_pToolbar);
            ASSERT(SUCCEEDED(hr));
        }
    }
    else
    {
        //
        // Result Pane -- disable all if nothing selected.
        //
        if (bSelect)
        {
            lpDataObject = (LPDATAOBJECT)param;

            if (lpDataObject != NULL)
            {
                pInternal = ExtractInternalFormat(lpDataObject);
            }

            if (pInternal == NULL)
            {
                return;
            }

            pObject = (CIISObject *)pInternal->m_cookie;

            //
            // Attach the toolbars to the window
            //
            hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN)m_pToolbar);
            ASSERT(SUCCEEDED(hr));
        }
    }

    if (pInternal)
    {
        FREE_DATA(pInternal);
    }

    SetToolbarStates((MMC_COOKIE)pObject);
}



STDMETHODIMP
CSnapin::ControlbarNotify(
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Handle control bar notification

Arguments:

    MMC_NOTIFY_TYPE event       : Notification event
    LPARAM arg                  : argument as needed
    LPARAM param                : Parameter ad needed

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    switch (event)
    {
    case MMCN_BTN_CLICK:
        //
        // Note for MMC: it seems to be that arg and param
        // should be reversed here.  The MMCN_SELECT
        // casts the dataobject to the param (which makes
        // more sense anyway).
        //
        TRACEEOLID("CSnapin::ControlbarNotify - MMCN_BTN_CLICK");
        OnButtonClick((LPDATAOBJECT)arg, (long)PtrToUlong((PVOID)param));
        break;

    case MMCN_SELECT:
        TRACEEOLID("CSnapin::ControlbarNotify - MMCN_SEL_CHANGE");
        HandleToolbar(arg, param);
        break;

    case MMCN_HELP:
        break; // New

    default:
        //
        // Unhandled event
        //
        ASSERT(FALSE);
    }

    return hr;
}



STDMETHODIMP
CSnapin::CompareObjects(
    IN LPDATAOBJECT lpDataObjectA,
    IN LPDATAOBJECT lpDataObjectB
    )
/*++

Routine Description:

    Compare two data objects.  This method is used to see if a property
    sheet for the given data object is already open

Arguments:

    LPDATAOBJECT lpDataObjectA      : A data object
    LPDATAOBJECT lpDataObjectB      : B data object

Return Value:

    S_OK if they match, S_FALSE otherwise

--*/
{
    //
    // Delegate it to the IComponentData
    //
    ASSERT(m_pComponentData != NULL);

    return m_pComponentData->CompareObjects(lpDataObjectA, lpDataObjectB);
}



/* virtual */
HRESULT
CSnapin::Compare(
    IN  RDCOMPARE * prdc,
    OUT int * pnResult
    )
/*++

Routine Description:

    Compare method

Arguments:

    RDCOMPARE * prdc    : Compare structure
    int * pnResult      : Returns result

Return Value:

    HRESULT

--*/
{
    if (!pnResult || !prdc || !prdc->prdch1->cookie || !prdc->prdch2->cookie)
    {
        ASSERT(FALSE);

        return E_POINTER;
    }

    CIISObject * pObjectA = (CIISObject *)prdc->prdch1->cookie;
    CIISObject * pObjectB = (CIISObject *)prdc->prdch2->cookie;

    *pnResult = pObjectA->Compare(prdc->nColumn, pObjectB);

    return S_OK;
}



//
// IPersistStream interface members
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<




STDMETHODIMP
CSnapin::GetClassID(
    OUT CLSID * pClassID
    )
/*++

Routine Description:

    Get class ID

Arguments:

    CLSID * pClassID        : Returns class ID

Return Value:

    HRESULT

--*/
{
    ASSERT(pClassID != NULL);

    //
    // Copy the CLSID for this snapin
    //
    *pClassID = CLSID_Snapin;

    return E_NOTIMPL;
}



STDMETHODIMP
CSnapin::IsDirty()
/*++

Routine Description:

    Checks to see if the snapin's persistence stream is dirty

Arguments:

    None

Return Value:

    S_OK if the stream needs to be updated, S_FALSE otherwise

--*/
{
    return m_fSettingsChanged ? S_OK : S_FALSE;
}



STDMETHODIMP
CSnapin::Load(
    IN IStream * pStm
    )
/*++

Routine Description:

    Load the persisted information

Arguments:

    IStream * pStm              : Persistence stream

Return Value:

    HRESULT

--*/
{
    ASSERT(pStm != NULL);

    //
    // Verify a simple signature
    //
    DWORD dw = 0x1234;
    DWORD dw2;
    DWORD cBytesRead;
    HRESULT hr = S_OK;

    do
    {
        hr = pStm->Read(&dw2, sizeof(dw2), &cBytesRead);
        if (FAILED(hr))
        {
            break;
        }

        ASSERT(cBytesRead == sizeof(dw2) && dw2 == dw);

        //
        // Read settings
        //
        hr = pStm->Read(
            &m_fTaskView,
            sizeof(m_fTaskView),
            &cBytesRead
            );

        if (cBytesRead == 0)
        {
            //
            // Old style console file
            //
            TRACEEOLID("Warning: old-style console file encountered");
            m_fTaskView = FALSE;
        }
        else
        {
            ASSERT(cBytesRead == sizeof(m_fTaskView));
        }
    }
    while(FALSE);

#if !TASKPADS_SUPPORTED

    m_fTaskView = FALSE;

#endif // TASKPADS_SUPPORTED

    return hr;
}



STDMETHODIMP
CSnapin::Save(
    IN IStream * pStm,
    IN BOOL fClearDirty
    )
/*++

Routine Description:

    Save persistence information

Arguments:

    IStream * pStm              : Persistence stream
    BOOL fClearDirty            : TRUE to clear the dirty flag

Return Value:

    HRESULT

--*/
{
    ASSERT(pStm != NULL);

    //
    // Write a simple signature
    //
    DWORD dw = 0x1234;
    DWORD cBytesWritten;
    HRESULT hr = STG_E_CANTSAVE;

    do
    {
        hr = pStm->Write(&dw, sizeof(dw), &cBytesWritten);
        if (FAILED(hr))
        {
            break;
        }
        ASSERT(cBytesWritten == sizeof(dw));

        hr = pStm->Write(&m_fTaskView, sizeof(m_fTaskView), &cBytesWritten);
        ASSERT(cBytesWritten == sizeof(m_fTaskView));
    }
    while(FALSE);

    return hr;
}



STDMETHODIMP
CSnapin::GetSizeMax(
    ULARGE_INTEGER * pcbSize
    )
/*++

Routine Description:

    Get max size of persistence information

Arguments:

    ULARGE_INTEGER * pcbSize        : Returns the size

Return Value:

    HRESULT

--*/
{
    ASSERT(pcbSize != NULL);

    //
    // Set the size of the string to be saved
    //
    pcbSize->QuadPart = (ULONGLONG)sizeof(DWORD) + sizeof(m_fTaskView);

    return S_OK;
}


STDMETHODIMP 
CSnapin::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
   return GetSnapinHelpFile(lpCompiledHelpFile);
}

//
// IComponentData implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);



CComponentDataImpl::CComponentDataImpl()
/*++

Routine Description:

    Contructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pScope(NULL),
      m_pConsole(NULL),
      m_hIISRoot(NULL),
      m_fIsCacheDirty(FALSE),
      m_fIsExtension(FALSE),
      m_strlCachedServers(),
      m_ullDiscoveryMask((ULONGLONG)0L)
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    EmptyServerList();

#ifdef _DEBUG

    m_cDataObjects = 0;

#endif

}



CComponentDataImpl::~CComponentDataImpl()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    //
    // Some snap-in is hanging on to data objects.
    // If they access, it will crash!!!
    //
    ASSERT(m_cDataObjects == 0);
}



STDMETHODIMP
CComponentDataImpl::Initialize(
    IN LPUNKNOWN pUnknown
    )
/*++

Routine Description:

    Initalize the component data

Arguments:

    LPUNKNOWN pUnknown      : Pointer to IUnknown implementation

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    ASSERT(pUnknown != NULL);
    HRESULT hr;

    //
    // MMC should only call ::Initialize once!
    //
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_pScope);

    CIISObject::AttachScopeView(m_pScope);

    //
    // add the images for the scope tree
    //
    LPIMAGELIST lpScopeImage;

    hr = pUnknown->QueryInterface(IID_IConsole2, (void **)&m_pConsole);
    
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(hr == S_OK);

    //
    // Load the config services DLLs
    //
    GetServicesDLL();

    //
    // Get the add-on tools
    //
    GetToolMenu();

    //
    // Get the DLLs which contain computer property pages
    //
    GetISMMachinePages();

    CBitmap bmp16x16,
            bmp32x32,
            bmpMgr16x16,
            bmpMgr32x32;

    //
    // Load the bitmaps from the dll
    //
    // Must AFX_MANAGE_STATE here
    //
    {
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        VERIFY(bmp16x16.LoadBitmap(IDB_VIEWS16));
        VERIFY(bmp32x32.LoadBitmap(IDB_VIEWS32));
        VERIFY(bmpMgr16x16.LoadBitmap(IDB_INETMGR16));
        VERIFY(bmpMgr32x32.LoadBitmap(IDB_INETMGR16));
    }

    //
    // Set the images
    //
    hr = lpScopeImage->ImageListSetStrip(
        (LONG_PTR *)(HBITMAP)bmp16x16,
        (LONG_PTR *)(HBITMAP)bmp32x32,
        0,
        RGB_BK_IMAGES
        );
    ASSERT(hr == S_OK);

    //
    // Add on inetmgr bitmap
    //
    hr = lpScopeImage->ImageListSetStrip(
        (LONG_PTR *)(HBITMAP)bmpMgr16x16,
        (LONG_PTR *)(HBITMAP)bmpMgr32x32,
        BMP_INETMGR,
        RGB_BK_IMAGES
        );
    ASSERT(hr == S_OK);

    //
    // Add the ones from the service config DLL's
    //
    POSITION pos16x16 = g_obl16x16.GetHeadPosition();
    POSITION pos32x32 = g_obl32x32.GetHeadPosition();

    int i = BMP_SERVICE;
    while (pos16x16 && pos32x32)
    {
        CImage * pimg16x16 = (CImage *)g_obl16x16.GetNext(pos16x16);
        CImage * pimg32x32 = (CImage *)g_obl32x32.GetNext(pos32x32);
        ASSERT(pimg16x16 && pimg32x32);

        hr = lpScopeImage->ImageListSetStrip(
            (LONG_PTR *)(HBITMAP)pimg16x16->GetBitmap(),
            (LONG_PTR *)(HBITMAP)pimg32x32->GetBitmap(),
            i++,
            pimg16x16->GetBkColor()
            );

        ASSERT(hr == S_OK);
    }

    lpScopeImage->Release();

    return hr;
}



STDMETHODIMP
CComponentDataImpl::CreateComponent(
    IN LPCOMPONENT * ppComponent
    )
/*++

Routine Description:

    Create component

Arguments:

    LPCOMPONENT * ppComponent       : Address if COMPONENT

Return Value:

    HRESULT

--*/
{
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    //
    // Store IComponentData
    //
    pObject->SetIComponentData(this);

    return pObject->QueryInterface(IID_IComponent, (void **)ppComponent);
}




BOOL
CComponentDataImpl::FindOpenPropSheetOnNodeAndDescendants(
    IN LPPROPERTYSHEETPROVIDER piPropertySheetProvider,
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Starting with the current node, check to see if an open
    property sheet exists.  Keep looking through descendants also.
    As soon as an open property sheet is found, return TRUE.

Arguments:

    MMC_COOKIE cookie     : Cookie for currently selected item

Return Value:

    TRUE if an open property sheet is found, FALSE if not.

Notes:

    Function is called recursively

--*/
{
    HSCOPEITEM hScopeItem = NULL;
    CIISObject * pObject = (CIISObject *)cookie;

    if (pObject != NULL)
    {
        hScopeItem = pObject->GetScopeHandle();
    }

    //
    // Check the current node
    //
    HRESULT hr = piPropertySheetProvider->FindPropertySheet(
        (MMC_COOKIE)hScopeItem,
        NULL,
        NULL
        );

    if (hr == S_OK)
    {
        //
        // Found a sheet
        //
        return TRUE;
    }

    //
    // Now check the descendants for open sheets
    //
    ASSERT(m_pScope != NULL);

    //
    // Look for machine object off the root
    //
    HSCOPEITEM hChildItem;

    hr = m_pScope->GetChildItem(hScopeItem, &hChildItem, &cookie);
    while (hr == S_OK && hChildItem != NULL)
    {
        CIISObject * pObject = (CIISObject *)cookie;

        if (FindOpenPropSheetOnNodeAndDescendants(
            piPropertySheetProvider, 
            cookie
            ))
        {
            //
            // Found a sheet
            //
            return TRUE;
        }

        //
        // Advance to next child of the same parent.
        //
        hr = m_pScope->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    //
    // Not found
    //
    return FALSE;
}


/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CComponentDataImpl::Notify(
    IN LPDATAOBJECT lpDataObject,
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Notification message handler

Arguments:

    LPDATAOBJECT lpDataObject       : Selected item
    MMC_NOTIFY_TYPE event           : Notification message
    LPARAM arg                      : Notification Argument
    LPARAM param                    : Notification Parameter

Return Value:

    HRESULT

--*/
{
    if (event == MMCN_PROPERTY_CHANGE)
    {
        return OnProperties(param);
    }

    ASSERT(m_pScope != NULL);
    HRESULT hr = S_OK;

    INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

    MMC_COOKIE cookie;

    if (pInternal == NULL)
    {
        TRACEEOLID("Extension (CComponentDataImpl) Snapin");
        CIISObject::m_fIsExtension  = m_fIsExtension = TRUE;
        cookie = NULL;
    }
    else
    {
        cookie = pInternal->m_cookie;
        FREE_DATA(pInternal);
    }

    switch(event)
    {
    case MMCN_REFRESH:
        RefreshIISObject((CIISObject *)cookie, TRUE, arg);
        break;

    case MMCN_DELETE:
        DeleteObject((CIISObject *)cookie);
        break;

    case MMCN_RENAME:
        hr = OnRename(cookie, arg, param);
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = OnRemoveChildren(arg);
        break;

    case MMCN_EXPAND:
        hr = OnExpand(lpDataObject, arg, param);
        break;

    case MMCN_SELECT:
        hr = OnSelect(cookie, arg, param);
        break;

    case MMCN_CONTEXTMENU:
        hr = OnContextMenu(cookie, arg, param);
        break;

    default:
        break;
    }

    return hr;
}



STDMETHODIMP
CComponentDataImpl::Destroy()
/*++

Routine Description:

    Destroy component data

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SAFE_RELEASE_SETTONULL(m_pScope);
    SAFE_RELEASE_SETTONULL(m_pConsole);

    m_hIISRoot = NULL;

    //
    // Scope items will clean themselves up
    //
    return S_OK;
}



STDMETHODIMP
CComponentDataImpl::QueryDataObject(
    IN  MMC_COOKIE cookie,
    IN  DATA_OBJECT_TYPES type,
    OUT LPDATAOBJECT * ppDataObject
    )
/*++

Routine Description:

    Query data object

Arguments:

    MMC_COOKIE cookie               : Private data (i.e. a CIISObject *)
    DATA_OBJECT_TYPES type          : Data object type
    LPDATAOBJECT * ppDataObject     : Returns LPDATAOBJECT

Return Value:

    HRESULT

--*/
{
    ASSERT(ppDataObject != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);
    if (pObject == NULL)
       return E_UNEXPECTED;
    //
    // Save cookie and type for delayed rendering
    //
    pObject->SetType(type);
    pObject->SetCookie(cookie);

#ifdef _DEBUG

    pObject->SetComponentData(this);

#endif

    //
    // Store the coclass with the data object
    //
    pObject->SetClsid(GetCoClassID());

    return pObject->QueryInterface(IID_IDataObject, (void **)ppDataObject);
}



//
// IExtendPropertySheet Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDMETHODIMP
CComponentDataImpl::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle,
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    LPDATAOBJECT lpDataObject           : Data object

Return Value:

    HRESULT

--*/
{
#ifdef MMC_PAGES

    CIISObject * pObject = NULL;

    if (lpDataObject != NULL)
    {
        INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal)
        {
            pObject = (CIISObject *)pInternal->m_cookie;
            FREE_DATA(pInternal);
        }
    }

    ASSERT(pObject && pObject->IsMMCConfigurable());

    CError err(pObject->ConfigureMMC(lpProvider, (LPARAM)pObject, handle));

    //
    // ISSUE: MMC silently fails on this error.  Perhaps it should
    //        write the error message?
    //
    if (err.Failed())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        err.MessageBox();
    }

    return err;

#else

    return E_NOTIMPL;

#endif // MMC_PAGES

}



STDMETHODIMP
CComponentDataImpl::QueryPagesFor(
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Check to see if a property sheet should be brought up for this data
    object

Arguments:

    LPDATAOBJECT lpDataObject       : Data object

Return Value:

    S_OK, if properties may be brought up for this item, S_FALSE otherwise

--*/
{

#ifdef MMC_PAGES

    CIISObject * pObject = NULL;

    if (lpDataObject != NULL)
    {
        INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal)
        {
            pObject = (CIISObject *)pInternal->m_cookie;
            FREE_DATA(pInternal);
        }
    }

    return pObject && pObject->IsMMCConfigurable() ? S_OK : S_FALSE;

#else

    return S_FALSE;

#endif // MMC_PAGES
}



//
// IPersistStream interface members
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDMETHODIMP
CComponentDataImpl::GetClassID(
    OUT CLSID * pClassID
    )
/*++

Routine Description:

    Return the objects class ID

Arguments:

    CLSID pClassID  : Returns the class ID

Return Value:

    HRESULT

--*/
{
    ASSERT(pClassID != NULL);

    //
    // Copy the CLSID for this snapin
    //
    *pClassID = CLSID_Snapin;

    return S_OK;
}



STDMETHODIMP
CComponentDataImpl::IsDirty()
/*++

Routine Description:

    Determine if we need to save the cache

Arguments:

    None

Return Value:

    S_OK if the stream needs to be updated, S_FALSE otherwise

--*/
{
    if (m_fIsExtension)
    {
        //
        // Extension to computer management -- no private cache
        //
        return S_FALSE;
    }

    //
    // Primary snapin
    //
    return IsCacheDirty() ? S_OK : S_FALSE;
}




STDMETHODIMP
CComponentDataImpl::Load(
    IN IStream * pStm
    )
/*++

Routine Description:

    Load the persisted information

Arguments:

    IStream * pStm              : Persistence stream

Return Value:

    HRESULT

--*/
{
    ASSERT(pStm);

    DWORD cch;
    DWORD cBytesRead;
    LPTSTR lpstr;

    if (m_fIsExtension)
    {
        //
        // Extension to computer management -- no private cache
        //
        return S_OK;
    }

    //
    // First read the size of the string array
    //
    HRESULT hr = pStm->Read(&cch, sizeof(cch), &cBytesRead);

    if (FAILED(hr))
    {
        return E_FAIL;
    }

    //
    // Virgin cache
    //
    if (cBytesRead != sizeof(cch) || cch == 0)
    {
        return S_OK;
    }

    lpstr = AllocTString(cch);

    if (lpstr == NULL)
    {
        return E_FAIL;
    }

    hr = pStm->Read(lpstr, cch * sizeof(TCHAR), &cBytesRead);
    ASSERT(SUCCEEDED(hr) && cBytesRead == cch * sizeof(TCHAR));

    if (FAILED(hr))
    {
        return E_FAIL;
    }

    CStringList strl;
    ConvertDoubleNullListToStringList(lpstr, strl);

    for (POSITION pos = strl.GetHeadPosition(); pos!= NULL; )
    {
        CString & str = strl.GetNext(pos);
        AddServerToCache(str, FALSE);
    }

    FreeMem(lpstr);

    return hr;
}



STDMETHODIMP
CComponentDataImpl::Save(
    IN IStream * pStm,
    IN BOOL fClearDirty
    )
/*++

Routine Description:

    Save persistence information

Arguments:

    IStream * pStm              : Persistence stream
    BOOL fClearDirty            : TRUE to clear the dirty flag

Return Value:

    HRESULT

--*/
{
    ASSERT(pStm);

    if (m_fIsExtension)
    {
        //
        // Extension to computer management -- no private cache
        //
        return S_OK;
    }

    //
    // Flatten the cache
    //
    DWORD cch;
    LPTSTR lpstr;
    DWORD cBytesWritten;
    HRESULT hr = S_OK;

    DWORD err = ConvertStringListToDoubleNullList(
        GetCachedServers(),
        cch,
        lpstr
        );

    if (err == ERROR_SUCCESS)
    {
        //
        // First write the total size
        //
        hr = pStm->Write(&cch, sizeof(cch), &cBytesWritten);
        ASSERT(SUCCEEDED(hr) && cBytesWritten == sizeof(cch));

        if (FAILED(hr))
        {
            return STG_E_CANTSAVE;
        }

        //
        // Now write the body.
        //
        hr = pStm->Write(lpstr, cch * sizeof(TCHAR), &cBytesWritten);
        ASSERT(SUCCEEDED(hr) && cBytesWritten == cch * sizeof(TCHAR));

        if (FAILED(hr))
        {
            return STG_E_CANTSAVE;
        }

        if (fClearDirty)
        {
            ClearCacheDirty();
        }

        FreeMem(lpstr);
    }

    return S_OK;
}



STDMETHODIMP
CComponentDataImpl::GetSizeMax(
    OUT ULARGE_INTEGER * pcbSize
    )
/*++

Routine Description:

    Get max size of persistence information

Arguments:

    ULARGE_INTEGER * pcbSize        : Returns the size

Return Value:

    HRESULT

--*/
{
    ASSERT(pcbSize);

    //
    // Set the size of the string to be saved
    //
    pcbSize->QuadPart = (ULONGLONG)0;

    return S_OK;
}



//
// IExtendContextMenu implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDMETHODIMP
CComponentDataImpl::AddMenuItems(
    IN LPDATAOBJECT lpDataObject,
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN long * pInsertionAllowed
    )
/*++

Routine Description:

    Add menu items to the right-click context menu

Arguments:

    LPDATAOBJECT pDataObject                    : Select
    LPCONTEXTMENUCALLBACK pContextMenuCallback  : Context menu callback function
    long * pInsertionAllowed                    : ???

Return Value:

    HRESULT

--*/
{
    if (!(*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP))
    {
        //
        // Nothing to add to the action menu.
        //
        return S_OK;
    }

    INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

    if (pInternal == NULL)
    {
        //
        // Extensions not supported yet.
        //
        ASSERT(FALSE);

        return S_OK;
    }

    CIISObject * pObject = (CIISObject *)pInternal->m_cookie;

    FREE_DATA(pInternal);

    if (pObject == NULL)
    {
        //
        // Must be the static root, add connect menu item only.
        //
        CIISObject::AddMenuItemByCommand(lpContextMenuCallback, IDM_CONNECT);

        return S_OK;
    }

    return pObject->AddMenuItems(lpContextMenuCallback);
}



BOOL
CComponentDataImpl::DoChangeState(
    IN CIISObject * pObject,
    IN int nNewState
    )
/*++

Routine Description:

    Change the state of the selected object

Arguments:

    CIISObject * pObject : Selected object
    int nNewState     :   Desired new state

Return Value:

    TRUE for success, FALSE for failure.

Notes:

    In case of failure, this method will already have displayed
    an error message with the cause

--*/
{
    ASSERT(pObject != NULL);
    ASSERT(pObject->IsControllable());

    int nNumRunningChange = pObject->IsRunning()
        ? -1
        :  0;

    CError err;

    //
    // Temporarily override some messages
    //
    TEMP_ERROR_OVERRIDE(ERROR_BAD_DEV_TYPE, IDS_CLUSTER_ENABLED);
    TEMP_ERROR_OVERRIDE(ERROR_INVALID_PARAMETER, IDS_CANT_START_SERVICE);
    {
        //
        // Needed for CWaitCursor
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        CWaitCursor wait;
        err = pObject->ChangeState(nNewState);
    }

    if (err.Failed())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        err.MessageBox();
    }

    //
    // Refresh regardless
    //
    pObject->RefreshDisplayInfo();
    nNumRunningChange += pObject->IsRunning()
        ? +1
        : 0;

    AddToNumRunning(nNumRunningChange);
    //UpdateStatusBarNumbers();

    return err.Succeeded();
}



void
CComponentDataImpl::OnMetaBackRest(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Perform metabase backup/restore

Arguments:

    CIISObject * pObject : Selected object (should be machine node)

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(pObject->QueryGUID() == cMachineNode);

    CBackupDlg dlg(pObject->GetMachineName());
    dlg.DoModal();

    if (dlg.HasChangedMetabase())
    {
        RefreshIISObject(pObject, TRUE);
    }
}



void
CComponentDataImpl::OnIISShutDown(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Bring up IIS shutdown/restart dialogs

Arguments:

    CIISObject * pObject : Selected object (should be machine node)

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(pObject->QueryGUID() == cMachineNode);

    LPCTSTR lpszMachineName = pObject->GetMachineName();

    //
    // If a property sheet is open for this item, don't
    // allow deletion.
    //
    LPPROPERTYSHEETPROVIDER piPropertySheetProvider = NULL;

    HRESULT hr = m_pConsole->QueryInterface(
        IID_IPropertySheetProvider,
        (void **)&piPropertySheetProvider
        );

    if (FindOpenPropSheetOnNodeAndDescendants(
        piPropertySheetProvider,
        (ULONG_PTR)pObject
        ))
    {
        //
        // Already had properties open
        //
        ::AfxMessageBox(IDS_PROP_OPEN_SHUTDOWN);
        return;
    }

    CIISShutdownDlg dlg(lpszMachineName);
    dlg.DoModal();

    if (dlg.ServicesWereRestarted())
    {
        //
        // Rebind all metabase handles on this server
        //
        CServerInfo * pServerInfo;                                                 
        CObListIter obli(m_oblServers); 
                                                                               
        while (pServerInfo = (CServerInfo *)obli.Next())                          
        {                                                                        
            if (!::lstrcmpi(pServerInfo->QueryServerName(), lpszMachineName))
            {
                TRACEEOLID(
                    "Rebinding against " 
                    << pServerInfo->GetShortName()
                    << " on "
                    << lpszMachineName
                    );
                pServerInfo->ISMRebind();
            }
        }

        //
        // Now do a refresh on the computer node.  Since we've forced
        // the rebinding here, we should not get the disconnect warning.
        //
        RefreshIISObject(pObject, TRUE);
    }
}



void
CComponentDataImpl::OnConnectOne()
/*++

Routine Description:

    Connect to a single server

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TEMP_ERROR_OVERRIDE(EPT_S_NOT_REGISTERED, IDS_ERR_RPC_NA);
    TEMP_ERROR_OVERRIDE(RPC_S_SERVER_UNAVAILABLE, IDS_ERR_RPC_NA);
    TEMP_ERROR_OVERRIDE(RPC_S_UNKNOWN_IF, IDS_ERR_INTERFACE);
    TEMP_ERROR_OVERRIDE(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);

    ConnectServerDlg dlg;

    if (dlg.DoModal() == IDOK)
    {
        //
        // Clean up name.
        //
        CString strServerName(dlg.QueryServerName());

        int cServices = 0;

        //
        // The function will report the errors
        //
        CError err;
        {
            CWaitCursor wait;
            err = AddServerToList(
                TRUE,               // Cache
                FALSE,              // Handle errors
                strServerName,
                cServices
                );
        }

        if (err.Failed())
        {
            err.MessageBoxFormat(
                IDS_ERROR_CONNECTING,
                MB_OK,
                NO_HELP_CONTEXT,
                (LPCTSTR)strServerName
                );
        }
        else if (cServices == 0)
        {
            //
            // No errors, but no services found
            //
            ::AfxMessageBox(IDS_NO_SERVICE);
        }
    }
}



void
CComponentDataImpl::DoConfigure(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Configure the given iis object

Arguments:

    CIISObject * pObject : Object to be configured

Return Value:

    None

--*/
{
    CError err;

    //
    // We need a window handle for this, but MMC won't
    // give us one.  Fortunately, we know MMC to be
    // an MFC app, so we can sleazily grab it anyway.
    //
    CWnd * pMainWnd = NULL;
    {
        HWND hwnd;
        err = m_pConsole->GetMainWindow(&hwnd);

        if (err.Succeeded())
        {
            pMainWnd = CWnd::FromHandle(hwnd);
        }
    }
    ASSERT(pMainWnd != NULL);

    CWnd wnd;
    if (pMainWnd == NULL)
    {
        //
        // No main window in MMC?  Use NULL handle
        //
        pMainWnd = &wnd;
    }

    ASSERT(m_pConsole);
    ASSERT(pObject->IsConfigurable());
    err = pObject->Configure(pMainWnd);

    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    if (!err.MessageBoxOnFailure())
    {
        //
        // Refresh and display the entry
        //
        OnProperties((LPARAM)pObject);
    }
}



BOOL
CComponentDataImpl::DeleteObject(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Delete the given iisobject.  Ask for confirmation first.

Arguments:

    CIISObject * pObject    : Object to be deleted

Return Value:

    TRUE if the item was deleted successfully, 
    FALSE otherwise.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    BOOL fReturn = FALSE;

    //
    // If a property sheet is open for this item, don't
    // allow deletion.
    //
    LPPROPERTYSHEETPROVIDER piPropertySheetProvider = NULL;

    HRESULT hr = m_pConsole->QueryInterface(
        IID_IPropertySheetProvider,
        (void **)&piPropertySheetProvider
        );

    if (FindOpenPropSheetOnNodeAndDescendants(
        piPropertySheetProvider,
        (ULONG_PTR)pObject
        ))
    {
        //
        // Already had properties open
        //
        ::AfxMessageBox(IDS_PROP_OPEN);
    }
    else
    {
        CError err;

        // Before we go and delete this baby,
        // let's check if it's got a Cluster property set.
        if (pObject->IsClusterEnabled())
        {
            ::AfxMessageBox(IDS_CLUSTER_ENABLED_2);
        }
        else
        {
            if (!pObject->HandleUI() || NoYesMessageBox(IDS_CONFIRM_DELETE))
            {
                CWaitCursor wait;

                err = pObject->Delete();

                if (pObject->HandleUI())
                {
                    //
                    // Only complain if we're to handle the error messages.
                    // In e.g. the file system, explorer handles all error
                    // messages
                    //
                    err.MessageBoxOnFailure();
                }

                if (err.Succeeded())
                {
                    ASSERT(m_pScope);

                    //
                    // Delete the item from the view, but be careful that
                    // result item nodes store a scope handle, but which
                    // actually refers to the _parent_'s scope handle.
                    //
                    if (!pObject->ScopeHandleIsParent())
                    {
                        m_pScope->DeleteItem(pObject->GetScopeHandle(), TRUE);
                        delete pObject;
                    }

                    fReturn = TRUE;
                }
            }
        }
    }

    piPropertySheetProvider->Release();

    return fReturn;
}



void
CComponentDataImpl::DisconnectItem(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Delete the given iisobject.  Ask for confirmation first.

Arguments:

    CIISObject * pObject    : Object to be deleted

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // If a property sheet is open for this item, don't
    // allow deletion.
    //
    LPPROPERTYSHEETPROVIDER piPropertySheetProvider = NULL;

    HRESULT hr = m_pConsole->QueryInterface(
        IID_IPropertySheetProvider,
        (void **)&piPropertySheetProvider
        );

    if (FindOpenPropSheetOnNodeAndDescendants(
        piPropertySheetProvider,
        (ULONG_PTR)pObject
        ))
    {
        //
        // Already had properties open
        //
        ::AfxMessageBox(IDS_PROP_OPEN);
    }
    else
    {
        CString strMachine(pObject->GetMachineName());

        CString str, str2;
        VERIFY(str.LoadString(IDS_CONFIRM_DISCONNECT));
        str2.Format(str, strMachine);

        if (NoYesMessageBox(str2))
        {
            //
            // Remove from Cache and oblist
            //
            CError err(RemoveServerFromList(TRUE, strMachine));

            if (!err.MessageBoxOnFailure())
            {
                ASSERT(m_pScope);
                m_pScope->DeleteItem(pObject->GetScopeHandle(), TRUE);
                delete pObject;
            }
        }
    }

    piPropertySheetProvider->Release();
}



STDMETHODIMP
CComponentDataImpl::Command(
    IN long nCommandID,
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Command handler

Arguments:

    long nCommandID             : Command ID
    LPDATAOBJECT lpDataObject   : Selected Data object

Return Value:

    HRESULT

--*/
{
    if (nCommandID == IDM_CONNECT)
    {
        //
        // This is the only case that doesn't require a selected
        // data object.
        //
        OnConnectOne();

        return S_OK;
    }

    /*
    if (IsMMCMultiSelectDataObject(lpDataObject))
    {
        //
        // Do something for multi-select?
        //
        TRACEEOLID("Multiple selection");
    }
    */

    INTERNAL * pInternal = lpDataObject 
        ? ExtractInternalFormat(lpDataObject)
        : NULL;

    if (pInternal == NULL)
    {
        return S_OK;
    }

    CIISObject * pObject = (CIISObject *)pInternal->m_cookie;
    FREE_DATA(pInternal);

    CError err;
    switch (nCommandID)
    {
    case IDM_METABACKREST:
        OnMetaBackRest(pObject);
        break;

    case IDM_SHUTDOWN:
        OnIISShutDown(pObject);
        break;
  
    case IDM_DISCONNECT:
        DisconnectItem(pObject);
        break;

    case IDM_CONFIGURE:
        DoConfigure(pObject);
        break;

    case IDM_STOP:
        DoChangeState(pObject, INetServiceStopped);
        m_pConsole->UpdateAllViews(lpDataObject, 0L, (LONG_PTR)pObject);
        break;

    case IDM_START:
        DoChangeState(pObject, INetServiceRunning);
        m_pConsole->UpdateAllViews(lpDataObject, 0L, (LONG_PTR)pObject);
        break;

    case IDM_PAUSE:
        DoChangeState(
            pObject,
            pObject->IsPaused() ? INetServiceRunning : INetServicePaused
            );
        m_pConsole->UpdateAllViews(lpDataObject, 0L, (LONG_PTR)pObject);
        break;

    case IDM_EXPLORE:
        pObject->Explore();
        break;

    case IDM_OPEN:
        pObject->Open();
        break;

    case IDM_BROWSE:
        pObject->Browse();
        break;

    case IDM_TASK_SECURITY_WIZARD:
        {
            //
            // Launch the security wizard
            //
            err = pObject->SecurityWizard();
            err.MessageBoxOnFailure();
        }
        break;

    case IDM_NEW_INSTANCE:
        {
            //
            // Executed from another instance of the same type
            //
            ISMINSTANCEINFO ii;
            CServerInfo * pServerInfo = pObject->GetServerInfo();
            ASSERT(pServerInfo);

            err = pServerInfo->AddInstance(&ii, sizeof(ii));

            if (err.Succeeded())
            {
                CIISInstance * pInstance = new CIISInstance(&ii, pServerInfo);

                //
                // Add the new instance grouped with the service type,
                // and select it
                //
                BOOL fNext;
                HSCOPEITEM hParent = FindServerInfoParent(
                    GetRootHandle(),
                    pServerInfo
                    );
                ASSERT(hParent != NULL);

                HSCOPEITEM hSibling = FindNextInstanceSibling(
                    hParent,
                    pInstance,
                    &fNext
                    );

                HSCOPEITEM hItem = AddIISObject(
                    hParent,
                    pInstance,
                    hSibling,
                    fNext
                    );

                //
                // hItem could return NULL if the hParent
                // was not yet expanded.
                //
                if (hItem)
                {
                    m_pConsole->SelectScopeItem(hItem);
                }
            }
        }
        break;

    case IDM_NEW_VROOT:
        CIISChildNode * pChild;

        err = pObject->AddChildNode(pChild);

        if (err.Succeeded())
        {
            //
            // Insert prior to file/dir nodes, and select the item
            //
            HSCOPEITEM hItem = AddIISObject(
                pObject->GetScopeHandle(),
                pChild,
                FindNextVDirSibling(pObject->GetScopeHandle(), pChild)
                );

            //
            // hItem could return NULL if the parent object
            // was not yet expanded.
            //
            if (hItem)
            {
                m_pConsole->SelectScopeItem(hItem);
            }
        }
        break;

    default:
        //
        // Now try to get to the service that we're
        // supposed to create a new instance for.
        //
        if (nCommandID >= IDM_NEW_EX_INSTANCE)
        {
            int nID = nCommandID - IDM_NEW_EX_INSTANCE;
            CNewInstanceCmd * pcmd =
                (CNewInstanceCmd *)m_oblNewInstanceCmds.Index(nID);
            ASSERT(pcmd != NULL);

            if (pcmd)
            {
                ISMINSTANCEINFO ii;

                CServerInfo * pServerInfo = FindServerInfo(
                    pObject->GetMachineName(),
                    pcmd->GetServiceInfo()
                    );

                if (pServerInfo == NULL)
                {
                    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
                    ::AfxMessageBox(IDS_ERR_SERVICE_NOT_INSTALLED);
                    break;
                }

                ASSERT(pServerInfo);
                err = pServerInfo->AddInstance(&ii, sizeof(ii));

                if (err.Succeeded())
                {
                    //
                    // Add and select the item
                    //
                    CIISInstance * pInstance = new CIISInstance(
                        &ii,
                        pServerInfo
                        );

                    BOOL fNext;
                    HSCOPEITEM hSibling = FindNextInstanceSibling(
                        pObject->GetScopeHandle(),
                        pInstance,
                        &fNext
                        );

                    HSCOPEITEM hItem = AddIISObject(
                        pObject->GetScopeHandle(),
                        pInstance,
                        hSibling,
                        fNext
                        );
                    m_pConsole->SelectScopeItem(hItem);
                }
            }
        }
        else
        {
            //
            // Unknown command!
            //
            ASSERT(FALSE);
        }
        break;
    }

    return S_OK;
}



//
// Notification handlers for IComponentData
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
CComponentDataImpl::OnAdd(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Add handler

Arguments:

    MMC_COOKIE cookie       : Scope item cookie (CIISObject *)
    LPARAM arg              : Argument
    LPARAM param            : Parameter

Return Value:

    HRESULT

--*/
{
    return E_UNEXPECTED;
}



HRESULT
CComponentDataImpl::OnDelete(
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Handle deletion of the given scope item (CIISObject *)

Arguments:

    MMC_COOKIE cookie         : Casts to a CIISObject *

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = (CIISObject *)cookie;

    if (pObject == NULL)
    {
        return S_FALSE;
    }

    delete pObject;

    return S_OK;
}



HRESULT
CComponentDataImpl::OnRename(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Rename notification handler

Arguments:

    MMC_COOKIE cookie   : Currently selected cookie (CIISObject *)
    LPARAM arg          : Notification argument
    LPARAM param        : Notification parameter

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = (CIISObject *)cookie;

    if (pObject == NULL)
    {
        //
        // Can't rename this one
        //
        return S_FALSE;
    }

    if (!arg)
    {
        //
        // Check to see if we're renamable
        //
        return pObject->IsRenamable() ? S_OK : S_FALSE;
    }

    TEMP_ERROR_OVERRIDE(ERROR_ALREADY_EXISTS, IDS_ERR_DUP_VROOT);

    CError err;

    //
    // Do an actual rename
    //
    LPCTSTR lpstrNewName = (LPCTSTR)param;
    err = pObject->Rename(lpstrNewName);

    if (err.Succeeded())
    {
        //
        // Force a refresh on the children
        //
        pObject->DirtyChildren();
    }
    else
    {
        if (pObject->HandleUI())
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());
            err.MessageBox();
        }
    }

    return err.Succeeded() ? S_OK : S_FALSE;
}



HRESULT
CComponentDataImpl::OnRemoveChildren(
    IN LPARAM arg
    )
/*++

Routine Description:

    'Remove Children' notification handler

Arguments:

    LPARAM arg          : Notification argument

Return Value:

    HRESULT

--*/
{
	m_strlCachedServers.RemoveAll();
	return S_OK;
}



HRESULT
CComponentDataImpl::OnExpand(
    LPDATAOBJECT lpDataObject,
    LPARAM arg,
    LPARAM param
    )
/*++

Routine Description:

    Expand notification handler

Arguments:

    LPDATAOBJECT lpDataObject : Currently selected cookie (CIISObject *)
    LPARAM arg                : Notification argument
    LPARAM param              : Notification parameter

Return Value:

    HRESULT

--*/
{
    if (arg)
    {
        //
        // Did Initialize get called?
        //
        ASSERT(m_pScope != NULL);
        EnumerateScopePane(lpDataObject, param);
    }

    return S_OK;
}



HRESULT
CComponentDataImpl::OnSelect(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Selection notification handler

Arguments:

    MMC_COOKIE cookie   : Currently selected cookie (CIISObject *)
    LPARAM arg          : Notification argument
    LPARAM param        : Notification parameter

Return Value:

    HRESULT

--*/
{
    return E_UNEXPECTED;
}



HRESULT
CComponentDataImpl::OnContextMenu(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    Context Menu notification handler

Arguments:

    MMC_COOKIE cookie   : Currently selected cookie (CIISObject *)
    LPARAM arg          : Notification argument
    LPARAM param        : Notification parameter

Return Value:

    HRESULT

--*/
{
    return S_OK;
}



HRESULT
CComponentDataImpl::OnProperties(
    IN LPARAM param
    )
/*++

Routine Description:

    Properties change notification handler

Arguments:

    LPARAM arg          : Notification argument (CIISObject *)

Return Value:

    HRESULT

--*/
{
    if (param == NULL)
    {
        return S_OK;
    }

    CIISObject * pObject = (CIISObject *)param;
    ASSERT(pObject != NULL);

    if (pObject != NULL)
    {
        CString strOldPath(pObject->QueryPhysicalPath());
        CString strOldRedirect(pObject->QueryRedirPath()); 
        BOOL fOldChildRedirOnly = pObject->IsChildOnlyRedir();
        
        //
        // Refresh the data to see if either the physical or redirection
        // path has changed.  If it has, refresh the child objects
        //
        CError err(pObject->RefreshData());

        //
        // Determine if the file system needs to be refreshed
        //
        BOOL fRefreshFileSystem = err.Succeeded()
         && pObject->SupportsChildren() 
         && pObject->ChildrenExpanded()
         && pObject->SupportsFileSystem() 
         && strOldPath.CompareNoCase(pObject->QueryPhysicalPath()) != 0;

        //
        // Determine if everything needs to be refreshed
        //
        BOOL fFullRefresh = err.Succeeded()
         && pObject->SupportsChildren() 
         && pObject->ChildrenExpanded()
         && (strOldRedirect.CompareNoCase(pObject->QueryRedirPath()) != 0
               || fOldChildRedirOnly != pObject->IsChildOnlyRedir());

        TRACEEOLID("Refresh files: " 
            << fRefreshFileSystem 
            << " Full Refresh: "
            << fFullRefresh
            );
            
        RefreshIISObject(pObject, fFullRefresh); 

        if (!fFullRefresh && fRefreshFileSystem)
        {
            //
            // Not a full refresh -- the file system only.
            //
            CString strPhysicalPath, strMetaRoot;
            pObject->BuildPhysicalPath(strPhysicalPath);
            pObject->BuildFullPath(strMetaRoot, FALSE);

            //
            // Note: we can't use ExpandIISObject, because we're only
            // replacing specific nodes, not the entire subtree
            //
            AddFileSystem(
                pObject->GetScopeHandle(),
                strPhysicalPath,
                strMetaRoot,
                pObject->FindOwnerInstance(),
                GET_DIRECTORIES,
                DELETE_CURRENT_DIR_TREE
                );

            //
            // Mark this node to indicate that the child nodes
            // have been added.
            //
            pObject->CleanChildren();
        }

        //
        // Re-enumerate the result side if the current item is
        // selected.
        //
        if ((fRefreshFileSystem || fFullRefresh) && pObject->IsScopeSelected())
        {
            ASSERT(m_pConsole);
            m_pConsole->SelectScopeItem(pObject->GetScopeHandle());
        }
    }

    return S_OK;
}



CServerInfo *
CComponentDataImpl::FindServerInfo(
    IN LPCTSTR lpstrMachine,
    IN CServiceInfo * pServiceInfo
    )
/*++

Routine Description:

    Find specific server info (i.e. machine name / service info
    combination type)

Arguments:

    LPCTSTR lpstrMachine            : Machine name
    CServiceInfo * pServiceInfo     : Service info

Return Value:

    Server Info object pointer, or NULL

--*/
{
    CServerInfo * pServerInfo;
    CObListIter obli(m_oblServers);

    //
    // Search is sequential, because we don't foresee more then a few
    // of these objects in the cache
    //
    while (pServerInfo = (CServerInfo *)obli.Next())
    {
        if (!::lstrcmpi(pServerInfo->QueryServerName(), lpstrMachine)
            && pServerInfo->GetServiceInfo() == pServiceInfo)
        {
            //
            // Found it
            //
            return pServerInfo;
        }
    }

    return NULL;
}



void
CComponentDataImpl::RefreshIISObject(
    IN CIISObject * pObject,
    IN BOOL fExpandTree,
	IN HSCOPEITEM pParent
    )
/*++

Routine Description:

    Refresh object, and optionally re-enumerate its display

Arguments:

    CIISObject * pObject        : Object to be refreshed
    BOOL fExpandTree            : TRUE to expand its tree

Return Value:

    None

--*/
{
    ASSERT(pObject != NULL);

	CError err;

	CServerInfo * pServer = pObject->GetServerInfo();
	CMetaInterface * pInterface = NULL;
	
	if (pServer)
	{
		pInterface = GetMetaKeyFromHandle(pServer->GetHandle());
	}

	if (pInterface)
    {
        BEGIN_ASSURE_BINDING_SECTION
            err = pObject->RefreshData();
        END_ASSURE_BINDING_SECTION(err, pInterface, RPC_S_SERVER_UNAVAILABLE);
    }
    else
    {
        err = pObject->RefreshData();
    }

    if (err.Failed())
    {
          AFX_MANAGE_STATE(::AfxGetStaticModuleState());
          err.MessageBox();

          return;
    }

    pObject->RefreshDisplayInfo();

    //
    // Reenumerate its children if requested to do so and its necessary
    //
    if (fExpandTree)
    {
        if (pObject->ChildrenExpanded())
        {
            HSCOPEITEM hNode = pObject->GetScopeHandle();

            if (KillChildren(
                hNode,
                IDS_PROP_OPEN_REFRESH,
                DELETE_EVERYTHING,
                DONT_CONTINUE_ON_OPEN_SHEET
                ))
            {
                pObject->DirtyChildren();
                ExpandIISObject(hNode, pObject);
            }
        }

        //
        // Re-enumerate the result side,  if the current item is
        // selected.
        //
        if (pObject->IsScopeSelected())
        {
            ASSERT(m_pConsole);
            m_pConsole->SelectScopeItem(pObject->GetScopeHandle());
        }
    }
}



void
CComponentDataImpl::LoadDynamicExtensions(
    IN HSCOPEITEM hParent,
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Load dynamic snap-in extensions for the given node type.

Arguments:

    None

Return Value:

    None (if it fails, it always fails silently)

--*/
{
    //
    // We'll look here (on the server) to see if we need to load
    // extension snap-ins.
    //
    const TCHAR SERVICES_KEY[] = SZ_REMOTEIISEXT;

    if (pObject == NULL)
    {
        //
        // This should never happen, right?
        //
        ASSERT(FALSE);
        return;
    }

    CString str, strKey;

    //
    // Get base path for the given node type
    //
    strKey.Format(
        _T("%s\\%s"), 
        SERVICES_KEY, 
        GUIDToCString(pObject->QueryGUID(), str)
        );

    TRACEEOLID(
        pObject->GetMachineName() << 
        " Attempting to dynamically load extensions for " << 
        strKey);

    CError err;

    CRMCRegKey rkExtensions(REG_KEY, strKey, KEY_READ, pObject->GetMachineName());

    CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> pIConsoleNameSpace2
         = m_pConsole;
    
    if (pIConsoleNameSpace2 && rkExtensions.Ok())
    {
        DWORD dwType;
        GUID  guidExtension;
        CRMCRegValueIter rkValues(rkExtensions);

        //
        // Loop through, and attempt to add each extension found in the 
        // registry
        //
        while (rkValues.Next(&str, &dwType) == ERROR_SUCCESS)
        {
            TRACEEOLID("Found dynamic extension: " << str);

            err = ::CLSIDFromString((LPTSTR)(LPCTSTR)str, &guidExtension);

            if (err.Succeeded())
            {
                err = pIConsoleNameSpace2->AddExtension(hParent, &guidExtension);
            }

            TRACEEOLID("DynaLoad returned " << err);
        }
    }
}



void
CComponentDataImpl::ExpandIISObject(
    IN HSCOPEITEM hParent,
    IN CIISObject * pObject,
	 IN LPTSTR lpszMachineName
    )
/*++

Routine Description:

    Expand the given IIS object tree

Arguments:

    HSCOPEITEM hParent      : Handle to parent item
    CIISObject * pObject    : IISObject to expand

Return Value:

    None

--*/
{
    CError err;

    if (pObject != NULL)
    {
        ASSERT(hParent == pObject->GetScopeHandle());
    }

    //
    // make sure we QI'ed for the interface
    //
    ASSERT(m_pScope != NULL);

    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    {
        CWaitCursor wait;

        if (m_hIISRoot == NULL)
        {
            //
            // Store the IIS root node for future use
            //
            m_hIISRoot = hParent;
        }

        if (pObject == NULL)
        {
            //
            // Static root node -- populate with computers.
            //
            // This is done only once per session
            //
            ASSERT(GetRootHandle() == hParent);

            TRACEEOLID("Inserting static root node");
            AddCachedServersToView();

            CServerInfo * pServerInfo = NULL;
            CObListIter obli(m_oblServers);

            if (m_fIsExtension)
            {
                //
                // Since we're extending the computer management
                // snap-in, only add the one server info parent
                // object (only one computer, after all).
                // This is also necessary, because for some reason
                // I can't get the child item nodes of my parent,
                // even if I've added them myself, and so we'd get
                // duplicates.
                //
					 if (lpszMachineName != NULL && *lpszMachineName != 0)
					 {
						 CServerInfo * p;
					    while (p = (CServerInfo *)obli.Next())
						 {
							  if (!::lstrcmpi(p->QueryServerName(), lpszMachineName))
							  {
									pServerInfo = p;
									break;
							  }
						 }
					 }
					 else
					    pServerInfo = (CServerInfo *)obli.Next();
                ASSERT(pServerInfo != NULL);

                if (pServerInfo)
                {
                    AddServerInfoParent(hParent, pServerInfo);
                }
            }
            else
            {
                //
                // We're the primary snap-in, add all the server info
                // parent objects (computers) to the view
                //
                while (pServerInfo = (CServerInfo *)obli.Next())
                {
                    if (pServerInfo->IsServiceSelected())
                    {
                        //
                        // Add each item in the tree
                        //
                        AddServerInfoParent(hParent, pServerInfo);
                    }
                }
            }
        }
        else
        {
            if (!pObject->ChildrenExpanded())
            {
                //
                // Delete whatever children there may be
                //
                if (pObject->QueryGUID() == cMachineNode)
                {
                    CIISMachine * pMachine = (CIISMachine *)pObject;
                    CServerInfo * pServerInfo;
                    CObListIter obli(m_oblServers);

                    while (pServerInfo = (CServerInfo *)obli.Next())
                    {
                        if (pServerInfo->MatchServerName(pMachine->GetMachineName())
                         && pServerInfo->IsServiceSelected())
                        {
                            //
                            // Add each item in the tree
                            //
                            AddServerInfo(hParent, pServerInfo, FALSE);
                        }
                    }
                }

                CString strMetaPath;

                if (pObject->SupportsChildren())
                {
                    pObject->BuildFullPath(strMetaPath, FALSE);

                    //
                    // Expand the children off the root
                    //
                    AddVirtualRoots(
                        hParent,
                        strMetaPath,
                        pObject->FindOwnerInstance()
                        );
                }

                if (pObject->SupportsFileSystem())
                {
                    if (strMetaPath.IsEmpty())
                    {
                        pObject->BuildFullPath(strMetaPath, FALSE);
                    }

                    //
                    // Expand file system objects
                    //
                    CString strPhysicalPath;
                    pObject->BuildPhysicalPath(strPhysicalPath);

                    AddFileSystem(
                        hParent,
                        strPhysicalPath,
                        strMetaPath,
                        pObject->FindOwnerInstance(),
                        GET_DIRECTORIES,
                        DONT_DELETE_CURRENT_DIR_TREE
                        );
                }

                //
                // Now load the dynamic extensions
                //
                LoadDynamicExtensions(hParent, pObject);

                //
                // Mark this node to indicate that the child nodes
                // have been added.
                //
                pObject->CleanChildren();
            }
        }
    }

    err.MessageBoxOnFailure();
}



void
CComponentDataImpl::EnumerateScopePane(
    IN LPDATAOBJECT lpDataObject,
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Handle expansion of hParent scope item.

Arguments:

    LPDATAOBJECT lpDataObject       : Selected data object
    HSCOPEITEM hParent              : Scope handle of parent item or NULL

Return Value:

    None

--*/
{
    ASSERT(lpDataObject != NULL);

    INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);
    MMC_COOKIE cookie = 0L;
    LPTSTR lpszMachine = NULL;

    if (pInternal == NULL)
    {
        //
        // Not mine -- must be an extension;  Get the machine name
        //
        ASSERT(m_fIsExtension);

        lpszMachine = ExtractMachineName(lpDataObject);
        TRACEEOLID(lpszMachine);

        CString strServerName = PURE_COMPUTER_NAME(lpszMachine);

        if (strServerName.IsEmpty())
        {
            //
            // MyComputer reports "" for the computer name.
            // This means the local machine is indicated
            //
            DWORD dwSize = MAX_SERVERNAME_LEN;

            if (::GetComputerName(strServerName.GetBuffer(dwSize + 1), &dwSize))
            {
                strServerName.ReleaseBuffer();
            }
        }

        //
        // Since we're an extension, the cache will not be
        // loaded from the persistence stream, and we can
        // therefore guarantee that this will be the only
        // item in the cache.
        //
        AddServerToCache(strServerName, FALSE);
    }
    else
    {
        cookie = pInternal->m_cookie;
        FREE_DATA(pInternal);
    }

#ifdef _DEBUG

    CIISObject * pObject = (CIISObject *)cookie;

    if (pObject)
    {
        ASSERT(hParent == pObject->GetScopeHandle());
    }

#endif // _DEBUG

    ExpandIISObject(hParent, (CIISObject *)cookie, lpszMachine);
}



STDMETHODIMP
CComponentDataImpl::GetDisplayInfo(
    IN LPSCOPEDATAITEM lpScopeDataItem
    )
/*++

Routine Description:

    Get display info (text, bitmap) for the selected scope item

Arguments:

    LPSCOPEDATAITEM lpScopeDataItem     : Selected item

Return Value:

    HRESULT

--*/
{
    ASSERT(lpScopeDataItem != NULL);
    if (lpScopeDataItem == NULL)
    {
        return E_POINTER;
    }

    static CString strText;

    CIISObject * pObject = (CIISObject *)lpScopeDataItem->lParam;
    ASSERT(lpScopeDataItem->mask & SDI_STR);

    pObject->GetDisplayText(strText);

    lpScopeDataItem->displayname = (LPTSTR)(LPCTSTR)strText;
    ASSERT(lpScopeDataItem->displayname != NULL);

    return S_OK;
}



STDMETHODIMP
CComponentDataImpl::CompareObjects(
    IN LPDATAOBJECT lpDataObjectA,
    IN LPDATAOBJECT lpDataObjectB
    )
/*++

Routine Description:

    Compare two data objects.  This is used by MMC to determine whether a
    given node has a property sheet already open for it.

Arguments:

    LPDATAOBJECT lpDataObjectA      : Data object 1
    LPDATAOBJECT lpDataObjectB      : Data object 2

Return Value:

    S_OK if the objects are identical, S_FALSE otherwise

--*/
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
    {
        return E_POINTER;
    }

    //
    // Make sure both data object are mine
    //
    INTERNAL * pA;
    INTERNAL * pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectA);

    if (pA != NULL && pB != NULL)
    {
        //hr = (*pA == *pB) ? S_OK : S_FALSE;
        return S_OK;
    }

    FREE_DATA(pA);
    FREE_DATA(pB);

    return hr;
}



void
CComponentDataImpl::GetISMMachinePages()
/*++

Routine Description:

    Load the names of the DLL providing ISM machine property
    page extentions

Arguments:

Return Value:

--*/
{
/*  OBSOLETE
    OBSOLETE
    OBSOLETE
    OBSOLETE
    OBSOLETE

    CString strValueName;
    DWORD   dwValueType;

    CRMCRegKey       rkMachine(REG_KEY, SZ_ADDONMACHINEPAGES, KEY_READ);

    if (rkMachine.Ok())
    {
        return;
    }

    CRMCRegValueIter rvi(rkMachine);

    CIISMachine::AttachPages(&m_oblISMMachinePages);

    try
    {
        while (rvi.Next(&strValueName, &dwValueType) == ERROR_SUCCESS)
        {
            CString strValue;
            rkMachine.QueryValue(strValueName, strValue);
            TRACEEOLID("Registering machine pages in " << strValue);
            m_oblISMMachinePages.AddTail(new CISMMachinePageExt(strValue));
        }
    }
    catch(CException * e)
    {
        TRACEEOLID("!!!exception building ISM machine page list");
        e->ReportError();
        e->Delete();
    }
*/
}



void
CComponentDataImpl::ConvertBitmapFormats(
    IN  CBitmap & bmpSource,
    OUT CBitmap & bmp16x16,
    OUT CBitmap & bmp32x32
    )
/*++

Routine Description:

    Convert a ISM service config bitmap to 16x16 and 32x32 exactly.
    Downlevel services only included a single sized bitmap (usually
    16x16) for use in ISM.  We need a small one and a large one,
    so we expand as needed.

Arguments:

    IN  CBitmap & bmpSource : Source bitmap
    OUT CBitmap & bmp16x16  : 16x16 output bitmap
    OUT CBitmap & bmp32x32  : 32x32 output bitmap

Return Value:

    None

--*/
{
    CDC dcImage;
    CDC dc16x16;
    CDC dc32x32;

    VERIFY(dcImage.CreateCompatibleDC(NULL));
    VERIFY(dc16x16.CreateCompatibleDC(NULL));
    VERIFY(dc32x32.CreateCompatibleDC(NULL));

    CBitmap * pOld = dcImage.SelectObject(&bmpSource);
    BITMAP bm;
    VERIFY(bmpSource.GetObject(sizeof(bm), &bm));

    VERIFY(bmp16x16.CreateBitmap(16, 16, bm.bmPlanes, bm.bmBitsPixel, NULL));
    VERIFY(bmp32x32.CreateBitmap(32, 32, bm.bmPlanes, bm.bmBitsPixel, NULL));

    CBitmap * pOld16x16 = dc16x16.SelectObject(&bmp16x16);
    CBitmap * pOld32x32 = dc32x32.SelectObject(&bmp32x32);

    dc16x16.StretchBlt(0, 0, 16, 16, &dcImage, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
    dc32x32.StretchBlt(0, 0, 32, 32, &dcImage, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

    dc16x16.SelectObject(pOld16x16);
    dc32x32.SelectObject(pOld32x32);
    dcImage.SelectObject(pOld);
}



BOOL
CComponentDataImpl::VerifyBitmapSize(
    IN HBITMAP hBitmap,
    IN LONG nHeight,
    IN LONG nWidth
    )
/*++

Routine Description:

    Verify the given bitmap is of the right size

Arguments:

    HBITMAP hBitmap     : Bitmap handle
    LONG nHeight        : Height the bitmap should be
    LONG nWidth         : Width the bitmap should be

Return Value:

    TRUE if the bitmap is of the right size, FALSE otherwise

--*/
{
    BITMAP bm;
    int cb = GetObject(hBitmap, sizeof(BITMAP), &bm);

    return (cb == sizeof(BITMAP)
        && bm.bmWidth == nWidth
        && bm.bmHeight == nHeight
        );
}



BOOL
CComponentDataImpl::GetBitmapParms(
    IN  CServiceInfo * pServiceInfo,
    IN  BMP_TYPES bmpt,
    OUT CBitmap *& pbmp16x16,
    OUT CBitmap *& pbmp32x32,
    OUT COLORREF & rgbMask
    )
/*++

Routine Description:

    Get bitmap information from service info object

Arguments:

    CServiceInfo * pServiceInfo : Service info
    BMP_TYPES bmpt              : Type of info requested
    COLORREF & rgbMask          : Returns background mask

Return Value:

    None.

--*/
{
    ASSERT(pServiceInfo != NULL);

    UINT nID16x16 = 0;
    UINT nID32x32 = 0;
    HINSTANCE hMod = NULL;

    if (pServiceInfo->InitializedOK())
    {
        switch(bmpt)
        {
        case BMT_BUTTON:
            nID16x16 = pServiceInfo->QueryButtonBitmapID();
            nID32x32 = 0;
            rgbMask = pServiceInfo->QueryButtonBkMask();
            break;

        case BMT_SERVICE:
            nID16x16 = pServiceInfo->QueryServiceBitmapID();
            nID32x32 = pServiceInfo->QueryLargeServiceBitmapID();
            rgbMask = pServiceInfo->QueryServiceBkMask();
            break;

        case BMT_VROOT:
            ASSERT(pServiceInfo->SupportsChildren());
            nID16x16 = pServiceInfo->QueryChildBitmapID();
            nID32x32 = pServiceInfo->QueryLargeChildBitmapID();
            rgbMask = pServiceInfo->QueryChildBkMask();
            break;
        }

        if (nID16x16 != 0)
        {
            hMod = pServiceInfo->QueryInstanceHandle();
        }
        else
        {
            //
            // No bitmap provided by the service DLL, provide one from our
            // own resource segment.
            //
            nID16x16 = IDB_UNKNOWN;
            nID32x32 = 0;
            hMod = ::AfxGetResourceHandle();
            rgbMask = TB_COLORMASK;
        }
    }
    else
    {
        //
        // Add a disabled dummy button for a service
        // that didn't load.
        //
        nID16x16 = IDB_NOTLOADED;
        nID32x32 = 0;
        hMod = ::AfxGetResourceHandle();
        rgbMask = TB_COLORMASK;
    }

    if (nID16x16 == 0)
    {
        return FALSE;
    }

    pbmp16x16 = new CBitmap;
    pbmp32x32 = new CBitmap;

    if (pbmp16x16 == NULL || pbmp32x32 == NULL)
    {
        return FALSE;
    }

    HINSTANCE hOld = ::AfxGetResourceHandle();
    ::AfxSetResourceHandle(hMod);
    if (nID32x32 != 0)
    {
        //
        // Have explicit large and small images
        //
        VERIFY(pbmp16x16->LoadBitmap(nID16x16));
        VERIFY(pbmp32x32->LoadBitmap(nID32x32));

        //
        // Check to make sure they're the right size
        //
        if (!VerifyBitmapSize((HBITMAP)*pbmp16x16, 16, 16) ||
            !VerifyBitmapSize((HBITMAP)*pbmp32x32, 32, 32))
        {
            ASSERT(FALSE);
            TRACEEOLID("Bogus bitmap size provided by service bitmap");

            //
            // Synthesize based on small image.
            //
            delete pbmp32x32;
            CBitmap * pTmp = pbmp16x16;
            ConvertBitmapFormats(*pTmp, *pbmp16x16, *pbmp32x32);
            delete pTmp;
        }
    }
    else
    {
        //
        // Only have one image.  Synthesize small and large from this
        // image.
        //
        CBitmap bmp;
        VERIFY(bmp.LoadBitmap(nID16x16));

        //
        // Convert to 16x16 and 32x32 image
        //
        ConvertBitmapFormats(bmp, *pbmp16x16, *pbmp32x32);
    }

    ::AfxSetResourceHandle(hOld);

    return TRUE;
}



void
CComponentDataImpl::GetToolMenu()
/*++

Routine Description:

   Load the add-on tools

Arguments:

    None.

Return Value:

    None.

--*/
{
    CString strValueName;
    DWORD   dwValueType;
    int     cTools = 0;
    CRMCRegKey rkMachine(REG_KEY, SZ_ADDONTOOLS, KEY_READ);

    if (!rkMachine.Ok())
    {
        //
        // No registry entry
        //
        return;
    }

    CRMCRegValueIter rvi(rkMachine);
    static BOOL fInitialised = FALSE;

    if (fInitialised)
    {
        TRACEEOLID("Toolbar already initialised");
        return;
    }

    try
    {
        int nButton = IDM_TOOLBAR;

        while (rvi.Next(&strValueName, &dwValueType) == ERROR_SUCCESS)
        {
            CString strValue;
            BOOL    fExpanded;

            rkMachine.QueryValue(
                strValueName,
                strValue,
                EXPANSION_ON,
                &fExpanded
                );

            TRACEEOLID("Adding tool: " << strValueName);
            TRACEEOLID("From Path: " << strValue);
            TRACEEOLID("Expansion: " << fExpanded);

            CISMShellExecutable * pNewAddOnTool = new CISMShellExecutable(
                strValue,
                nButton - 1,
                nButton
                );

            if (!pNewAddOnTool->HasBitmap())
            {
                TRACEEOLID("Tossing useless toolbar item");
                delete pNewAddOnTool;

                continue;
            }

            g_oblAddOnTools.AddTail(pNewAddOnTool);
            ++nButton;
        }
    }
    catch(CException * e)
    {
        TRACEEOLID("!!!exception building tool menu");
        e->ReportError();
        e->Delete();
    }

    fInitialised = TRUE;
}



void
CComponentDataImpl::MatchupSuperDLLs()
/*++

Routine Description:

    Match up all dlls with superceed dlls

Arguments:

    None

Return Value:

    None

--*/
{
    POSITION pos = m_oblServices.GetHeadPosition();

    while(pos)
    {
        CServiceInfo * pService = (CServiceInfo *)m_oblServices.GetNext(pos);

        ASSERT(pService != NULL);

        if (pService->RequiresSuperDll())
        {
            //
            // Match up the super DLL
            //
            POSITION pos2 = m_oblServices.GetHeadPosition();

            while (pos2)
            {
                CServiceInfo * pService2 =
                    (CServiceInfo *)m_oblServices.GetNext(pos2);

                if (pService2->IsSuperDllFor(pService))
                {
                    pService->AssignSuperDll(pService2);
                    break;
                }
            }

            ASSERT(pService->HasSuperDll());
        }
    }
}



void
CComponentDataImpl::GetServicesDLL()
/*++

Routine Description:

    Load the add-on services.

Arguments:

    None

Return Value:

    None

--*/
{
    int     cServices = 0;
    HRESULT hr = S_OK;

    LPIMAGELIST lpScopeImage = NULL;
    LPIMAGELIST lpResultImage = NULL;

    ASSERT(m_pConsole);
    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(SUCCEEDED(hr));
    hr = m_pConsole->QueryResultImageList(&lpResultImage);
    ASSERT(SUCCEEDED(hr));

    //
    // Run through the list of installed services,
    // load its associated cfg dll, and build up
    // a discovery mask for each service.
    //
    CString    strValueName;
    DWORD      dwValueType;
    CRMCRegKey rkMachine(REG_KEY, SZ_ADDONSERVICES, KEY_READ);

    if (rkMachine.Ok())
    {
        CRMCRegValueIter rvi(rkMachine);

        CIISMachine::AttachNewInstanceCmds(&m_oblNewInstanceCmds);

        try
        {
            //
            // Now load the services
            //
            // AFX_MANAGE_STATE required to load service bitmaps
            // from the dlls
            //
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());

            int nBmpIndex = BMP_SERVICE;
            while (rvi.Next(&strValueName, &dwValueType) == ERROR_SUCCESS)
            {
                //
                // Expand environment variables in path if present.
                //
                CString strValue;
                BOOL fExpanded;
                rkMachine.QueryValue(
                    strValueName,
                    strValue,
                    EXPANSION_ON,
                    &fExpanded
                    );

                CServiceInfo * pServiceInfo = NULL;
                {
                    CWaitCursor wait;
                    TRACEEOLID("Adding service DLL: " << strValue);
                    pServiceInfo = new CServiceInfo(cServices, strValue);
                }

                CError err(pServiceInfo->QueryReturnCode());

                if (err.Failed())
                {
                    if (err.Win32Error() == ERROR_INVALID_PARAMETER)
                    {
                        //
                        // The ERROR_INVALID_PARAMETER error return code
                        // gets sent when the info buffer provided is too
                        // small for the configuration DLL
                        //
                        ::AfxMessageBox(
                            IDS_VERSION_INCOMPATIBLE,
                            MB_OK | MB_ICONEXCLAMATION
                            );
                    }
                    else
                    {
                        err.MessageBoxFormat(
                            IDS_ERR_NO_LOAD,
                            MB_OK | MB_ICONEXCLAMATION,
                            NO_HELP_CONTEXT,
                            (LPCTSTR)pServiceInfo->QueryDllName()
                            );
                    }

                    //
                    // Don't add it to the list
                    //
                    delete pServiceInfo;
                    continue;
                }

                AddServiceToList(pServiceInfo);

                //
                // If this service use inetsloc discovery,
                // add it to the mask.
                //
                if (pServiceInfo->UseInetSlocDiscover())
                {
                    m_ullDiscoveryMask |= pServiceInfo->QueryDiscoveryMask();
                }

                //
                // Add a bitmap representing the service
                // to the image list
                //
                CBitmap * pbmp16x16 = NULL;
                CBitmap * pbmp32x32 = NULL;
                COLORREF rgbMask;

                if (GetBitmapParms(
                    pServiceInfo,
                    BMT_SERVICE,
                    pbmp16x16,
                    pbmp32x32,
                    rgbMask
                    ))
                {
                    g_obl16x16.AddTail(new CImage(pbmp16x16, rgbMask));
                    g_obl32x32.AddTail(new CImage(pbmp32x32, rgbMask));

                    pServiceInfo->SetBitmapIndex(nBmpIndex++);
                }

                //
                // Add to the 'new instance' menu commands
                //
                if (pServiceInfo->SupportsInstances())
                {
                    //
                    // Add to new instances menu object
                    //
                    m_oblNewInstanceCmds.AddTail(new CNewInstanceCmd(pServiceInfo));
                }

                if (pServiceInfo->SupportsChildren())
                {
                    if (GetBitmapParms(
                        pServiceInfo,
                        BMT_VROOT,
                        pbmp16x16,
                        pbmp32x32,
                        rgbMask
                        ))
                    {
                        g_obl16x16.AddTail(new CImage(pbmp16x16, rgbMask));
                        g_obl32x32.AddTail(new CImage(pbmp32x32, rgbMask));

                        pServiceInfo->SetChildBitmapIndex(nBmpIndex++);
                    }
                }

                ++cServices;
            }

            MatchupSuperDLLs();
        }
        catch(CException * e)
        {
            TRACEEOLID("Exception loading library");
            e->ReportError();
            e->Delete();
        }
    }

    if (cServices == 0)
    {
        //
        // No services installed
        //
        CString str;

        VERIFY(str.LoadString(IDS_NO_SERVICES_INSTALLED));
        AfxMessageBox(str);
    }
}



BOOL
CComponentDataImpl::RemoveServerFromCache(
    IN LPCTSTR lpstrServer
    )
/*++

Routine Description:

    Remove machine from cache.

Arguments:

    LPCTSTR lpstrServer : computer name to be removed from cache

Return Value:

    None

--*/
{
    CStringList & strList = GetCachedServers();

    TRACEEOLID("Removing " << lpstrServer << " from cache");

    POSITION posOld;
    POSITION pos = strList.GetHeadPosition();
    int nResult;
    while(pos)
    {
        posOld = pos;
        CString & str = strList.GetNext(pos);
        nResult = str.CompareNoCase(lpstrServer);

        if (nResult == 0)
        {
            strList.RemoveAt(posOld);
            SetCacheDirty(TRUE);

            return TRUE;
        }

        if (nResult > 0)
        {
            //
            // We're not going to find it.
            //
            break;
        }
    }

    //
    // Didn't exist
    //
    ASSERT(FALSE && "Attempting to remove non-existent server from cache");
    return FALSE;
}



void
CComponentDataImpl::AddServerToCache(
    IN LPCTSTR lpstrServer,
    IN BOOL fSetCacheDirty      OPTIONAL
    )
/*++

Routine Description:

    Add machine name to the cache

Arguments:

    LPCTSTR lpstrServer : computer name to be added to the cache.
    BOOL fSetCacheDirty : TRUE to dirty the cache

Return Value:

    None

--*/
{
    CStringList & strList = GetCachedServers();

    TRACEEOLID("Adding " << lpstrServer << " to cache");

    CString strServer(lpstrServer);

    POSITION posOld;
    POSITION pos = strList.GetHeadPosition();
    int nResult;

    while(pos)
    {
        posOld = pos;
        CString & str = strList.GetNext(pos);
        nResult = str.CompareNoCase(strServer);

        if (nResult == 0)
        {
            //
            // Already existed in the case, ignore
            //
            return;
        }
        else if (nResult > 0)
        {
            //
            // Found the proper place
            //
            strList.InsertBefore(posOld, strServer);
            if (fSetCacheDirty)
            {
                SetCacheDirty();
            }

            return;
        }
    }

    //
    // Didn't exist yet, so add to list here
    //
    strList.AddTail(strServer);

    if (fSetCacheDirty)
    {
        SetCacheDirty();
    }
}


static BOOL
GetCommandLineServer(LPTSTR * pStr)
{
   BOOL bRes = FALSE;
   LPTSTR pCmdLine = GetCommandLine();
   int n;
   LPTSTR * pArgv = CommandLineToArgvW(pCmdLine, &n);
   *pStr = NULL;
   if (pArgv != NULL)
   {
      TCHAR szCmd[] = _T("/SERVER:");
      int len = sizeof(szCmd) / sizeof(TCHAR) - 1;
      for (int i = 0; i < n; i++)
      {
         if (CSTR_EQUAL == CompareString(LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE, pArgv[i], len, szCmd, len))
         {
            LPTSTR p = pArgv[i] + len;
            int count = 0;
            while (*p != _T(' ') && *p != 0)
            {
               p++;
               count++;
            }
            *pStr = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (count + 1));
            if (*pStr != NULL)
            {
               lstrcpyn(*pStr, pArgv[i] + len, count + 1);
               bRes = TRUE;
            }
            break;
         }
      }
      GlobalFree(pArgv);
   }
   return bRes;
}

void
CComponentDataImpl::AddCachedServersToView()
/*++

Routine Description:

    Move the cached servers to the scope view.

Arguments:

    None

Return Value:

    None

--*/
{
    CStringList & strlList = GetCachedServers();
    BOOL bCmdLine = FALSE;

    LPTSTR pCmdLine = NULL;
    if (GetCommandLineServer(&pCmdLine))
    {
       bCmdLine = TRUE;
       EmptyServerList();
       AddServerToCache(pCmdLine, FALSE);
       if (pCmdLine != NULL)
          LocalFree(pCmdLine);
    }
    else if (strlList.IsEmpty())
    {
        //
        // Nothing pre-selected or cached.
        // Add the local machine.
        //
        CString str;
        DWORD dwSize = MAX_SERVERNAME_LEN;

        if (::GetComputerName(str.GetBuffer(dwSize + 1), &dwSize))
        {
            //
            // Add local machine, though don't persist this later
            //
            str.ReleaseBuffer();
            AddServerToCache(str, FALSE);
        }
    }

    //
    // Now add everything cached to the current
    // view
    //
    CError err;
    for(POSITION pos = strlList.GetHeadPosition(); pos != NULL; )
    {
        CString & strMachine = strlList.GetNext(pos);
        int cServices;

        err = AddServerToList(
            FALSE,
            bCmdLine ? TRUE : FALSE,
            strMachine,
            cServices,
            m_oblServices
            );
        TRACEEOLID("adding " << strMachine << " to the view returned error code " << err);

        if (err.Failed())
        {
            //
            // Temporarily map RPC errors to friendlier error message
            //
            TEMP_ERROR_OVERRIDE(EPT_S_NOT_REGISTERED, IDS_ERR_RPC_NA);
            TEMP_ERROR_OVERRIDE(RPC_S_SERVER_UNAVAILABLE, IDS_ERR_RPC_NA);
            TEMP_ERROR_OVERRIDE(RPC_S_UNKNOWN_IF, IDS_ERR_INTERFACE);
            TEMP_ERROR_OVERRIDE(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);

            AFX_MANAGE_STATE(::AfxGetStaticModuleState());

            //
            // Give the option of removing from cache
            //
            if (err.MessageBoxFormat(
                IDS_ERROR_CONNECTING_CACHE,
                MB_YESNO | MB_DEFBUTTON1,
                NO_HELP_CONTEXT,
                (LPCTSTR)strMachine) != IDYES)
            {
                VERIFY(RemoveServerFromCache(strMachine));
            }
        }
        else if (cServices == 0)
        {
            //
            // No errors, but no services found
            //
            ::AfxMessageBox(IDS_NO_SERVICE);
        }
    }
}



CServiceInfo *
CComponentDataImpl::GetServiceAt(
    IN int nIndex
    )
/*++

Routine Description:

    Get the service object at the given index.

Arguments:

    int nIndex : Index where to look for the service info object

Return Value:

    Service info pointer, or NULL if the index was not valid

--*/
{
    if (nIndex < 0 || nIndex >= m_oblServices.GetCount())
    {
        TRACEEOLID("Invalid service index requested");
        return NULL;
    }

    return (CServiceInfo *)m_oblServices.GetAt(m_oblServices.FindIndex(nIndex));
}



void
CComponentDataImpl::EmptyServerList()
/*++

Routine Description:

    Empty server list

Arguments:

    None

Return Value:

    None

--*/
{
    m_oblServers.RemoveAll();
    m_cServers = m_cServicesRunning = 0;
}



DWORD
CComponentDataImpl::AddServerToList(
    IN BOOL fCache,
    IN LPINET_SERVER_INFO lpServerInfo,
    IN OUT CObListPlus & oblServices
    )
/*++

Routine Description:

    Add a service object for each service discovered
    to be belonging to this server.

Arguments:

    BOOL fCache                     : TRUE to cache
    LPINET_SERVER_INFO lpServerInfo : Discovery information (from inetsloc)
    CObListPlus & oblServices       : List of installed services

Return Value:

    Error return code

--*/
{
    TRACEEOLID("For Server " << lpServerInfo->ServerName);
    CServerInfo * pServerInfo;
    DWORD err = ERROR_SUCCESS;

    for (DWORD j = 0; j < lpServerInfo->Services.NumServices; ++j)
    {
        LPINET_SERVICE_INFO lpServiceInfo = lpServerInfo->Services.Services[j];

        try
        {
            //
            // Attempt to create a server info block
            //
            pServerInfo = new CServerInfo(
                lpServerInfo->ServerName,
                lpServiceInfo,
                oblServices
                );

            if (pServerInfo->IsConfigurable())
            {
                TRACEEOLID("Adding " << (DWORD)lpServiceInfo->ServiceMask);
                if (!AddToList(fCache, pServerInfo))
                {
                    TRACEEOLID("It already existed in the list");
                    delete pServerInfo;
                }
            }
            else
            {
                //
                // Toss it
                //
                TRACEEOLID("Tossing " << (DWORD)lpServiceInfo->ServiceMask);
                delete pServerInfo;
            }
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("AddServerList: memory exception");
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    return err;
}



DWORD
CComponentDataImpl::AddServerToList(
    IN  BOOL fCache,
    IN  BOOL fHandleErrors,
    IN  CString & strServerName,
    OUT int & cServices,
    IN  OUT CObListPlus & oblServices
    )
/*++

Routine Description:

    Add a service object for each service running
    on the machine listed above.

Arguments:

    BOOL fCache               : TRUE to cache the server
    BOOL fHandleErrors        : TRUE to display error messages, FALSE to abort
                                on error
    CString & strServerName   : Name of this server
    int & cServices           : # Services added
    CObListPlus & oblServices : List of installed services

Return Value:

    Error return code

--*/
{
    TEMP_ERROR_OVERRIDE(EPT_S_NOT_REGISTERED, IDS_ERR_RPC_NA);
    TEMP_ERROR_OVERRIDE(RPC_S_SERVER_UNAVAILABLE, IDS_ERR_RPC_NA);
    TEMP_ERROR_OVERRIDE(RPC_S_UNKNOWN_IF, IDS_ERR_INTERFACE);
    TEMP_ERROR_OVERRIDE(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);

    //
    // Loop through the services, and find out which ones
    // are installed on the target machine, if any.
    //
    CObListIter obli(oblServices);
    CServiceInfo * psi;

    cServices = 0;
    CError err;
    ISMSERVERINFO ServerInfo;

    CServerInfo::CleanServerName(strServerName);

    //
    // See if we can make contact with the machine
    //
    if (!DoesServerExist(strServerName))
    {
        //
        // No, quit right here
        //
        err = RPC_S_SERVER_UNAVAILABLE;

        if (fHandleErrors)
        {
            err.MessageBox();
        }

        return err.Win32Error();
    }

    while (psi = (CServiceInfo *)obli.Next())
    {
        int cErrors = 0;

        if (psi->InitializedOK())
        {
            TRACEEOLID("Trying: " << psi->GetShortName());

            ServerInfo.dwSize = sizeof(ServerInfo);

            {
                AFX_MANAGE_STATE(::AfxGetStaticModuleState());
                CWaitCursor wait;

                err = psi->ISMQueryServerInfo(
                    strServerName,
                    &ServerInfo
                    );
            }

            if (err.Win32Error() == ERROR_SERVICE_DOES_NOT_EXIST)
            {
                TRACEEOLID("Service not installed -- acceptable response");
                err.Reset();
            }
            else if (err.Win32Error() == ERROR_SERVICE_START_HANG)
            {
                TRACEEOLID("Service is hanging -- ignore silently");
                err.Reset();
            }
            else if (err.Succeeded())
            {
                //
                // Yes, this service is running on this
                // machine.
                //
                ++cServices;

                //
                // Add to list
                //
                try
                {
                    CServerInfo * pNewServer = new CServerInfo(
                        strServerName,
                        &ServerInfo,
                        psi
                        );

                    if (!AddToList(fCache, pNewServer, TRUE))
                    {
                        TRACEEOLID("It already existed in the list");
                        delete pNewServer;
                    }
                }
                catch(CMemoryException * e)
                {
                    TRACEEOLID("AddServerList: memory exception");
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    e->Delete();
                }
            }

            if (err.Failed())
            {
                if (!fHandleErrors)
                {
                    //
                    // Let the calling process handle the errors,
                    // we're stopping.
                    //
                    break;
                }

                ++cErrors;

                //
                // Display error about the service
                //
                AFX_MANAGE_STATE(::AfxGetStaticModuleState());
                err.MessageBoxFormat(
                    IDS_ERR_ENUMERATE_SVC,
                    MB_OK,
                    NO_HELP_CONTEXT,
                    (LPCTSTR)psi->GetShortName(),
                    (LPCTSTR)strServerName
                    );

                //
                // Optionally cancel here on no response.
                //
                //break;
            }
        }
    }

    return err.Win32Error();
}



DWORD
CComponentDataImpl::RemoveServerFromList(
    IN  BOOL fCache,
    IN  CString & strServerName
    )
/*++

Routine Description:

    Remove each service in the list belonging to the given computer name.

Arguments:

    CString & strServerName   : Name of this server

Return Value:

    Error return code

--*/
{
    CServerInfo::CleanServerName(strServerName);

    CServerInfo * pEntry;
    POSITION pos1, pos2;
    pos1 = m_oblServers.GetHeadPosition();

    while(pos1)
    {
        pos2 = pos1;
        pEntry = (CServerInfo *)m_oblServers.GetNext(pos1);

        if (pEntry->MatchServerName(strServerName))
        {
            m_oblServers.RemoveAt(pos2);
        }
    }

    if (fCache)
    {
        RemoveServerFromCache(strServerName);
    }

    return ERROR_SUCCESS;
}



void
CComponentDataImpl::Refresh()
/*++

Routine Description:

    Refresh the server list

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // AFX_MANAGE_STATE required for wait cursor
    //
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    POSITION pos;

    CWaitCursor wait;

    CServerInfo * pEntry;

    for(pos = m_oblServers.GetHeadPosition(); pos != NULL; /**/ )
    {
        pEntry = (CServerInfo *)m_oblServers.GetNext(pos);
        int oldState = pEntry->QueryServiceState();

        if (pEntry->Refresh() == ERROR_SUCCESS)
        {
            if (oldState != pEntry->QueryServiceState())
            {
                //
                // Take away this service from the total
                // running count if it was part of it
                // before, and (re-) add it if it's currently
                // running.
                //
                if (oldState == INetServiceRunning)
                {
                    --m_cServicesRunning;
                }
                if (pEntry->IsServiceRunning())
                {
                    ++m_cServicesRunning;
                }
            }

            //UpdateAllViews(NULL, HINT_REFRESHITEM, pEntry);
        }
    }
}



BOOL
CComponentDataImpl::AddToList(
    IN BOOL fCache,
    IN CServerInfo * pServerInfo,
    IN BOOL fSelect
    )
/*++

Routine Description:

    Add the service to the list if it didn't exist already,
    otherwise refresh the info if it did exist.  Return
    TRUE if the service was added, FALSE, if already
    existed and was refreshed.

Arguments:

    CServerInfo * pServerInfo : Server to add
    BOOL fSelect              : If TRUE, select the newly added item

Return Value:

    TRUE if added, FALSE otherwise

--*/
{
    POSITION pos;
    BOOL fFoundService = FALSE;
    BOOL fFoundServer = FALSE;
    BOOL fServiceAdded = FALSE;
    //int nAddHint = fSelect ? HINT_ADDITEM_SELECT : HINT_ADDITEM;

    CServerInfo * pEntry;
    for( pos = m_oblServers.GetHeadPosition();
         pos != NULL;
         m_oblServers.GetNext(pos)
       )
    {
        pEntry = (CServerInfo *)m_oblServers.GetAt(pos);

        if (pEntry->CompareByServer(pServerInfo) == 0)
        {
            fFoundServer = TRUE;

            //
            // Found the server, also the service?
            //
            if (pEntry->CompareByService(pServerInfo) == 0)
            {
                //
                // Yes, the service was found also -- update the information
                // if the service state has changed.
                //
                TRACEEOLID("Entry Already Existed");
                fFoundService = TRUE;

                if (pEntry->QueryServiceState()
                    != pServerInfo->QueryServiceState())
                {
                    TRACEEOLID("Service State has changed -- refreshing");

                    //
                    // Decrement the running counter if this service
                    // was part of that counter. The counter will be
                    // re-added if the service is still running
                    //
                    if (pEntry->IsServiceRunning())
                    {
                        --m_cServicesRunning;
                    }

                    *pEntry = *pServerInfo;

                    if (pEntry->IsServiceRunning())
                    {
                        ++m_cServicesRunning;
                    }
                    //UpdateAllViews(NULL, HINT_REFRESHITEM, pEntry);
                }
                break;
            }
        }
        else
        {
            if (fFoundServer)
            {
                //
                // Server name no longer matches, but did match
                // the last time, so we didn't find the service.
                // Insert it at the end of the services belonging
                // to this guy.
                //
                TRACEEOLID("Found new service belonging to known server");

                m_oblServers.InsertBefore(pos, pServerInfo);
                fServiceAdded = TRUE;   // Don't add again.

                if (pServerInfo->IsServiceRunning())
                {
                    ++m_cServicesRunning;
                }

                //UpdateAllViews(NULL, nAddHint, pServerInfo);
                break;
            }
        }
    }

    if (!fFoundService && !fServiceAdded)
    {
        //
        // Came to the end of the list without
        // finding the service -- add a new one
        // at the end.
        //
        TRACEEOLID("Adding new entry to tail");
        m_oblServers.AddTail(pServerInfo);

        if (pServerInfo->IsServiceRunning())
        {
            ++m_cServicesRunning;
        }

        if (!fFoundServer)
        {
            ++m_cServers;

            if (fCache)
            {
                AddServerToCache(pServerInfo->QueryServerName(), TRUE);
            }
        }

        if (fCache && GetRootHandle() != NULL)
        {
            //
            // View has already been expanded -- add it here.
            //
            if (pServerInfo->IsServiceSelected())
            {
                AddServerInfoParent(GetRootHandle(), pServerInfo);
            }
        }
    }

    return !fFoundService;
}

static HRESULT
GetSnapinHelpFile(LPOLESTR * lpCompiledHelpFile)
{
   if (lpCompiledHelpFile == NULL)
      return E_INVALIDARG;
   CString strFilePath, strWindowsPath, strBuffer;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Use system API to get windows directory.
	UINT uiResult = GetWindowsDirectory(strWindowsPath.GetBuffer(MAX_PATH), 
MAX_PATH);
   strWindowsPath.ReleaseBuffer();
	if (uiResult <= 0 || uiResult > MAX_PATH)
	{
		return E_FAIL;
	}

   if (!strFilePath.LoadString(IDS_HELPFILE))
   {
      return E_FAIL;
   }
   
   strBuffer = strWindowsPath;
   strBuffer += _T('\\');
   strBuffer += strFilePath;

   *lpCompiledHelpFile 
      = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strBuffer.GetLength() + 1) 
			* sizeof(_TCHAR)));
   if (*lpCompiledHelpFile == NULL)
      return E_OUTOFMEMORY;
   USES_CONVERSION;
   _tcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)strBuffer));
   return S_OK;
}

STDMETHODIMP 
CComponentDataImpl::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
   return GetSnapinHelpFile(lpCompiledHelpFile);
}

//
// About implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DEBUG_DECLARE_INSTANCE_COUNTER(CSnapinAboutImpl);



CSnapinAboutImpl::CSnapinAboutImpl()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}



CSnapinAboutImpl::~CSnapinAboutImpl()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapinAboutImpl);
}



HRESULT
CSnapinAboutImpl::AboutHelper(
    IN  UINT nID,
    OUT LPOLESTR * lpPtr
    )
/*++

Routine Description:

    "About" helper function

Arguments:

    UINT nID            : String resource ID
    LPOLESTR * lpPtr    : Return buffer for the string

Return Value:

    HRESULT

--*/
{
    if (lpPtr == NULL)
    {
        return E_POINTER;
    }

    CString s;
    VERIFY(::LoadString(
        _Module.GetModuleInstance(), 
        nID, 
        s.GetBuffer(255), 
        255));
    s.ReleaseBuffer();

    *lpPtr = (LPOLESTR)CoTaskMemAlloc((s.GetLength() + 1) * sizeof(wchar_t));

    if (*lpPtr == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy(*lpPtr, (LPCTSTR)s);

    return S_OK;
}



STDMETHODIMP
CSnapinAboutImpl::GetSnapinDescription(
    OUT LPOLESTR * lpDescription
    )
/*++

Routine Description:

    Get the snapin description

Arguments:

    LPOLESTR * lpDescription : String return buffer

Return Value:

    HRESULT

--*/
{
    return AboutHelper(IDS_SNAPIN_DESC, lpDescription);
}




STDMETHODIMP
CSnapinAboutImpl::GetProvider(
    OUT LPOLESTR * lpName
    )
/*++

Routine Description:

    Get the snapin provider string

Arguments:

    LPOLESTR * lpName : String return buffer

Return Value:

    HRESULT

--*/
{
    return AboutHelper(IDS_COMPANY, lpName);
}



STDMETHODIMP
CSnapinAboutImpl::GetSnapinVersion(
    IN LPOLESTR * lpVersion
    )
/*++

Routine Description:

    Get the snapin version string:

Arguments:

    LPOLESTR * lpVersion    : Version string

Return Value:

    HRESULT

--*/
{
    return AboutHelper(IDS_VERSION, lpVersion);
}



STDMETHODIMP
CSnapinAboutImpl::GetSnapinImage(
    IN HICON * hAppIcon
    )
/*++

Routine Description:

    Get the icon for this snapin

Arguments:

    HICON * hAppIcon : Return handle to the icon

Return Value:

    HRESULT

--*/
{
    if (hAppIcon == NULL)
    {
        return E_POINTER;
    }

    *hAppIcon = LoadIcon(
        _Module.GetModuleInstance(), 
        MAKEINTRESOURCE(IDI_ICON));

    ASSERT(*hAppIcon != NULL);

    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}



STDMETHODIMP
CSnapinAboutImpl::GetStaticFolderImage(
    OUT HBITMAP  * phSmallImage,
    OUT HBITMAP  * phSmallImageOpen,
    OUT HBITMAP  * phLargeImage,
    OUT COLORREF * prgbMask
    )
/*++

Routine Description:

    Get the static folder image

Arguments:

    HBITMAP * phSmallImage      : Small folder
    HBITMAP * phSmallImageOpen  : Small open folder
    HBITMAP * phLargeImage      : Large image
    COLORREF * prgbMask         : Mask

Return Value:

    HRESULT

--*/
{
    if (!phSmallImage || !phSmallImageOpen || !phLargeImage || !prgbMask)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    *phSmallImage = (HBITMAP)LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_INETMGR16),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );

    *phSmallImageOpen = (HBITMAP)LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_INETMGR16),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );

    *phLargeImage = (HBITMAP)LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_INETMGR32),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );

    *prgbMask = RGB_BK_IMAGES;

    return *phSmallImage && *phLargeImage ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\cinetmgr.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        cinetmgr.h

   Abstract:

        snapin definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#include "resource.h"

//
// AddFileSystem parameter helpers
//
#define GET_DIRECTORIES                 (TRUE)
#define GET_FILES                       (FALSE)

#define DELETE_CURRENT_DIR_TREE         (TRUE)
#define DONT_DELETE_CURRENT_DIR_TREE    (FALSE)

#define DELETE_FILES_ONLY               (TRUE)
#define DELETE_EVERYTHING               (FALSE)

#define CONTINUE_ON_OPEN_SHEET          (TRUE)
#define DONT_CONTINUE_ON_OPEN_SHEET     (FALSE)

//
// Forward Definitions
//
class CIISObject;

//
// Extraction Helpers
//
INTERNAL * ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *  ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *     ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *    ExtractClassID(LPDATAOBJECT lpDataObject);

//
// Taskpad enumeration
//
class CEnumTasks :
    public IEnumTASK,
    public CComObjectRoot
{
public:
    CEnumTasks();
    virtual ~CEnumTasks();

//
// IEnumTASKS implementation
//
public:
BEGIN_COM_MAP(CEnumTasks)
    COM_INTERFACE_ENTRY(IEnumTASK)
END_COM_MAP()

#if DBG==1
public:
    ULONG InternalAddRef() { return CComObjectRoot::InternalAddRef(); }
    ULONG InternalRelease() { return CComObjectRoot::InternalRelease(); }
    int dbg_InstID;
#endif // DBG==1

//
// IEnumTASK methods
//
public:
    STDMETHOD(Next)(
       OUT ULONG celt,
       OUT MMC_TASK * rgelt,
       OUT ULONG * pceltFetched
       );

    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumTASK ** ppenum);

public:
   HRESULT Init(IDataObject * pdo, LPOLESTR szTaskGroup);

private:
    CIISObject * m_pObject;
};


///////////////////////////////////////////////////////////////////////////////



class CComponentDataImpl:
    public IComponentData,
    public IExtendContextMenu,
    public IExtendPropertySheet,
    public IPersistStream,
    public ISnapinHelp,
    public CComObjectRoot,
    public CComCoClass<CComponentDataImpl, &CLSID_Snapin>
/*++

Class Description:

    Component Data Implementation class

Public Interface:

--*/
{
public:
    DECLARE_REGISTRY(
        CSnapin,
        _T("ISMSnapin.Snapin.1"),
        _T("ISMSnapin.Snapin"),
        IDS_SNAPIN_DESC,
        THREADFLAGS_BOTH
        )

BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    ~CComponentDataImpl();

public:
    //
    // Return CLSID
    //
    virtual const CLSID & GetCoClassID() { return CLSID_Snapin; }

//
// IComponentData interface members
//
public:
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT * ppComponent);
    STDMETHOD(Notify)(
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param
        );

    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(
        MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT * lplpDataObject
        );

    STDMETHOD(GetDisplayInfo)(LPSCOPEDATAITEM lpScopeDataItem);
    STDMETHOD(CompareObjects)(
        LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB
        );

//
// IExtendContextMenu
//
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK pCallbackUnknown,
        long * pInsertionAllowed
        );

    STDMETHOD(Command)(
        long nCommandID,
        LPDATAOBJECT lpDataObject
        );

//
// IExtendPropertySheet interface
//
public:
    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT lpDataObject
        );

    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

//
// IPersistStream interface members
//
public:
    STDMETHOD(GetClassID)(CLSID * pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream * pStm);
    STDMETHOD(Save)(IStream * pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER * pcbSize);

// ISnapinHelp helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
//
// Notify handler declarations
//
private:
    HRESULT OnAdd(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnDelete(MMC_COOKIE cookie);
    HRESULT OnRemoveChildren(LPARAM arg);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnContextMenu(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

#ifdef _DEBUG
public:
    ULONG InternalAddRef() { return CComObjectRoot::InternalAddRef(); }
    ULONG InternalRelease() { return CComObjectRoot::InternalRelease(); }
#endif // _DEBUG

//
// Scope item creation helpers
//
protected:
    void LoadDynamicExtensions(
        HSCOPEITEM pParent,
        CIISObject * pObject
        );

    void EnumerateScopePane(
        LPDATAOBJECT lpDataObject,
        HSCOPEITEM pParent
        );

    void ExpandIISObject(
        HSCOPEITEM pParent,
        CIISObject * pObject,
		  LPTSTR lpszMachineName = NULL
        );

    void RefreshIISObject(
        CIISObject * pObject,
        BOOL fExpandTree,
		HSCOPEITEM pParent = NULL
        );

//
// Access
//
public:
    //
    // Get the server list
    //
    CObListPlus & GetServerList() { return m_oblServers; }

    //
    // Add a service object for each service entry in this
    // inetsloc-discovered information.
    //
    DWORD AddServerToList(
        IN BOOL fCache,                 // TRUE to add it to the cache
        IN LPINET_SERVER_INFO lpsi,     // Discovery information
        IN CObListPlus & oblServices    // List of installed services
        );

    //
    // Add a service object for each service running
    // on the machine listed above.
    //
    DWORD AddServerToList(
        IN BOOL fCache,                 // TRUE to add to the cache
        IN BOOL fDisplayErrors,         // TRUE to handle errors
        IN CString & lpServerName,      // Name of this server
        IN int & cServices,             // # Services added
        IN CObListPlus & oblServices    // List of installed services
        );

    //
    // Add a service object for each service running
    // on the machine listed above.
    //
    DWORD AddServerToList(
        IN BOOL fCache,                 // TRUE to add to the cache
        IN BOOL fDisplayErrors,         // TRUE to handle errors
        IN CString & lpServerName,      // Name of this server
        IN int & cServices              // # Services added
        );

    //
    // Remove all service objects belonging to the given server name
    // from the list.
    //
    DWORD RemoveServerFromList(
        IN  BOOL fCache,
        IN  CString & strServerName
        );

    //
    //
    // Remove the entire list
    //
    void EmptyServerList();

    //
    // These numbers apply to the services in the mask
    //
    int QueryNumServers() const { return m_cServers; }
    int QueryNumServicesRunning() const { return m_cServicesRunning; }
    void AddToNumRunning(int nChange) { m_cServicesRunning += nChange; }
    void AddToNumServers(int nChange) {  m_cServers += nChange; }

    //
    // Find server info object
    //
    CServerInfo * FindServerInfo(
        IN LPCTSTR lpstrMachine,
        IN CServiceInfo * pServiceInfo
        );

    //
    // Refresh the list information
    //
    void Refresh();

    //
    // Return TRUE if the entry was actually added, FALSE
    // if it was merely refreshed.
    //
    BOOL AddToList(
        IN BOOL fCache,
        IN CServerInfo * pServerInfo,
        IN BOOL fSelect = FALSE
        );

    //
    // Get the scope item handle of the root of the snap-in
    //
    HSCOPEITEM GetRootHandle() const { return m_hIISRoot; }

//
// Private Access to doc object functions
//
protected:
    //
    // Matchup DLL with super dlls
    //
    void MatchupSuperDLLs();

    //
    // Load the service DLLs
    //
    void GetServicesDLL();

    //
    // Load the add-on tools
    //
    void GetToolMenu();

    //
    // Get the names DLL names containing the machine page
    // extentions
    //
    void GetISMMachinePages();

    //
    // Add the fully constructed service object
    // to the list.
    //
    void AddServiceToList(CServiceInfo * pServiceInfo);

    int QueryNumInstalledServices() const;

    CServiceInfo * GetServiceAt(int nIndex);

//
// Cache Functions
//
protected:
    void AddCachedServersToView();
    void AddServerToCache(LPCTSTR strServer, BOOL fSetCacheDirty);
    BOOL RemoveServerFromCache(LPCTSTR strServer);
    CStringList & GetCachedServers() { return m_strlCachedServers; }
    void SetCacheDirty(BOOL fDirty = TRUE) { m_fIsCacheDirty = fDirty;}
    void ClearCacheDirty() { m_fIsCacheDirty = FALSE; }
    BOOL IsCacheDirty() { return m_fIsCacheDirty; }

//
// Helpers
//
protected:
    //
    // Bitmap types, as used by GetBitmapParms
    //
    enum BMP_TYPES
    {
        BMT_BUTTON,
        BMT_SERVICE,
        BMT_VROOT,
    };

    //
    // Verify bitmap is of the proper dimensions
    //
    BOOL VerifyBitmapSize(
        IN HBITMAP hBitmap,
        IN LONG nHeight,
        IN LONG nWidth
        );

    //
    // Helper function to stretch and compress a bitmap to a
    // 16x16 and a 32x32 image
    //
    void ConvertBitmapFormats(
        IN  CBitmap & bmpSource,
        OUT CBitmap & bmp16x16,
        OUT CBitmap & bmp32x32
        );

    //
    // Fetch specific bitmap information from a service object
    //
    BOOL GetBitmapParms(
        IN  CServiceInfo * pServiceInfo,
        IN  BMP_TYPES bmpt,
        OUT CBitmap *& pbmp16x16,
        OUT CBitmap *& pbmp32x32,
        OUT COLORREF & rgbMask
        );

protected:
    void DoConfigure(CIISObject * pObject);
    void DisconnectItem(CIISObject * pObject);
    void OnConnectOne();
    void OnMetaBackRest(CIISObject * pObject);
    void OnIISShutDown(CIISObject * pObject);
    BOOL DeleteObject(CIISObject * pObject);
    BOOL DoChangeState(CIISObject * pObject, int nNewState);

    BOOL FindOpenPropSheetOnNodeAndDescendants(
        IN LPPROPERTYSHEETPROVIDER piPropertySheetProvider,
        IN MMC_COOKIE cookie
        );

    BOOL KillChildren(
        IN HSCOPEITEM hParent,
        IN UINT nOpenErrorMsg,
        IN BOOL fFileNodesOnly,
        IN BOOL fContinueOnOpenSheet
        );

    HSCOPEITEM FindNextInstanceSibling(
        HSCOPEITEM hParent,
        CIISObject * pObject,
        BOOL * pfNext
        );

    HSCOPEITEM FindNextVDirSibling(
        HSCOPEITEM hParent,
        CIISObject * pObject
        );

    HSCOPEITEM AddIISObject(
        HSCOPEITEM hParent,
        CIISObject * pObject,
        HSCOPEITEM hNextSibling = NULL,
        BOOL fNext              = TRUE
        );

    HSCOPEITEM FindServerInfoParent(
        HSCOPEITEM hParent,
        CServerInfo * pServerInfo
        );

    HSCOPEITEM AddServerInfoParent(
        HSCOPEITEM hParent,
        CServerInfo * pServerInfo
        );

    HSCOPEITEM ForceAddServerInfoParent(
        HSCOPEITEM hParent,
        CServerInfo * pServerInfo
        );

    HSCOPEITEM AddInstances(
        HSCOPEITEM hParent,
        CIISObject * pObject
        );

    HSCOPEITEM AddVirtualRoots(
        HSCOPEITEM hParent,
        LPCTSTR lpstrParentPath,
        CIISInstance * pObject
        );

    HSCOPEITEM AddFileSystem(
        HSCOPEITEM hParent,
        LPCTSTR lpstrRoot,
        LPCTSTR lpstrMetaRoot,
        CIISInstance * pObject,
        BOOL fGetDirs,
        BOOL fDeleteCurrentFileSystem
        );

    HSCOPEITEM AddServerInfo(
        HSCOPEITEM hRootNode,
        CServerInfo * pServerInfo,
        BOOL fAddParent
        );

    void AddScopeItemToResultPane(MMC_COOKIE cookie);

private:
    BOOL                m_fIsExtension;
    LPCONSOLENAMESPACE  m_pScope;
    //LPCONSOLE           m_pConsole;
    LPCONSOLE2           m_pConsole;
    HSCOPEITEM          m_hIISRoot;

    //
    // List of service info structures
    //
    CObListPlus m_oblServices;
    ULONGLONG m_ullDiscoveryMask;
    //
    // Server list;
    //
    CObListPlus m_oblServers;
    //
    // New instance commands for services that support it
    //
    CObListPlus m_oblNewInstanceCmds;

    //
    // Counts
    //
    int m_cServers;
    int m_cServicesRunning;

    //
    // Cache
    //
    BOOL        m_fIsCacheDirty;
    CStringList m_strlCachedServers;

#ifdef _DEBUG
    friend class CDataObject;
    int     m_cDataObjects;
#endif
};



//
// Snapin Description:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CSnapin :
    public IComponent,
    public IExtendContextMenu,
    public IExtendControlbar,
    public IExtendPropertySheet,
    public IExtendTaskPad,
    public IResultDataCompareEx,
    //public IResultOwnerData,
    public IPersistStream,
    public ISnapinHelp,
    public CComObjectRoot
/*++

Class Description:

    Main snapin object class

Public Interface:

    CSnapin     : Constructor
    ~CSnapin    : Destructor

--*/
{
//
// Constructor/Destructor
//
public:
    CSnapin();
    ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendTaskPad)
    COM_INTERFACE_ENTRY(IResultDataCompareEx)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;

//
// IComponent interface members
//
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);

    STDMETHOD(Notify)(
        LPDATAOBJECT lpDataObject,
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param
        );

    STDMETHOD(Destroy)(MMC_COOKIE cookie);

    STDMETHOD(GetResultViewType)(
        MMC_COOKIE cookie,
        BSTR * ppViewType,
        long * pViewOptions
        );

    STDMETHOD(QueryDataObject)(
        MMC_COOKIE cookie,
        DATA_OBJECT_TYPES type,
        LPDATAOBJECT * lplpDataObject
        );

    STDMETHOD(GetDisplayInfo)(
        LPRESULTDATAITEM lpResultDataItem
        );

    STDMETHOD(CompareObjects)(
        LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB
        );

//
// IResultDataCompareEx interface
//
public:
    STDMETHOD(Compare)(RDCOMPARE * prdc, int * pnResult);

//
// IExtendControlbar interface
//
public:
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(
        MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param
        );

//
// IExtendPropertySheet interface
//
public:
    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle,
        LPDATAOBJECT lpDataObject
        );
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

//
// IExtendTaskpad methods
//
public:
    STDMETHOD(TaskNotify)(IDataObject * pdo, VARIANT * arg, VARIANT * param);
    STDMETHOD(EnumTasks)(
        IN  IDataObject * pdo,
        IN  LPOLESTR szTaskGroup,
        OUT IEnumTASK ** ppEnumTASK
        );
    STDMETHOD(GetTitle)(LPOLESTR pszGroup, LPOLESTR * pszTitle);
    STDMETHOD(GetDescriptiveText)(LPOLESTR pszGroup, LPOLESTR * pszText);
    STDMETHOD(GetBanner)(LPOLESTR pszGroup, LPOLESTR * szBitmapResource);
    STDMETHOD(GetBackground)(
        LPOLESTR pszGroup,
        MMC_TASK_DISPLAY_OBJECT * pTDO
        );
    STDMETHOD(GetListPadInfo)(
        LPOLESTR pszGroup,
        MMC_LISTPAD_INFO * lpListPadInfo
        )
    {
        return E_NOTIMPL;
    }

//
// IPersistStream interface:
//
public:
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream * pStm);
    STDMETHOD(Save)(IStream * pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER * pcbSize);

// ISnapinHelp helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);

//
// IExtendContextMenu interface:
//
public:
    STDMETHOD(AddMenuItems)(
        LPDATAOBJECT pDataObject,
        LPCONTEXTMENUCALLBACK pCallbackUnknown,
        long * pInsertionAllowed
        );
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

//
// Helpers for CSnapin
//
public:
    void SetIComponentData(CComponentDataImpl * pData);

#if _DEBUG

public:
    int dbg_cRef;
    ULONG InternalAddRef() {++dbg_cRef; return CComObjectRoot::InternalAddRef();}
    ULONG InternalRelease() {--dbg_cRef; return CComObjectRoot::InternalRelease();}

#endif // _DEBUG

//
// Notify event handlers
//
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClkOrDblClk(MMC_COOKIE cookie, BOOL fDblClick);
    HRESULT OnButtonClick(LPDATAOBJECT lpDataObject, long lID);
    HRESULT SetToolbarStates(MMC_COOKIE cookie);
    void    DestroyItem(LPDATAOBJECT lpDataObject);
    void    HandleToolbar(LPARAM arg, LPARAM param);
    void    HandleStandardVerbs(LPARAM arg, LPDATAOBJECT lpDataObject);

//
// Helper functions
//
protected:
    LPTSTR StringReferenceFromResourceID(UINT nID);
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);
    CISMShellExecutable * GetCommandAt(CObListPlus & obl, int nIndex);

    void Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent);
    void EnumerateResultPane(MMC_COOKIE cookie);

    void AddFileSystem(
        HSCOPEITEM hParent,
        LPCTSTR lpstrRoot,
        LPCTSTR lpstrMetaRoot,
        CIISInstance * pInstance,
        BOOL fGetDirs
        );

//
// Result pane helpers
//
protected:
    HRESULT InitializeBitmaps(MMC_COOKIE cookie);

//
// Interface pointers
//
protected:
    BOOL                m_fWinSockInit; // Winsock initialized?
    BOOL                m_fTaskView;    // Taskpad view?
    BOOL                m_fSettingsChanged;
    BOOL                m_fIsExtension;
    LPCONSOLE           m_pConsole;     // Console's IConsole interface
    LPHEADERCTRL        m_pHeader;      // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    LPCONSOLEVERB       m_pConsoleVerb;
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list
    LPTOOLBAR           m_pToolbar;     // Toolbar for view
    LPCONTROLBAR        m_pControlbar;  // control bar to hold my tool bars
    //LPEXTENDTASKPAD     m_pTaskPad;
    //CComPtr<ITaskPad>   m_pITaskPad;
    CBitmap *           m_pbmpToolbar;  // Imagelist for the toolbar
    CStringList         m_strlRef;      // Referred strings;
    CObListPlus         m_oblResultItems; // Result item cache
};



inline void
CSnapin::SetIComponentData(
    IN CComponentDataImpl * pData
    )
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, (void **)&m_pComponentData);

    ASSERT(hr == S_OK);
}



class CSnapinAboutImpl :
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CSnapinAboutImpl, &CLSID_About>
/*++

Class Description:

    About dialog implementation

Public Interface:

    CSnapinAboutImpl    : Constructor
    ~CSnapinAboutImpl   : Destructor

--*/
{
//
// Constructor/Destructor
//
public:
    CSnapinAboutImpl();
    ~CSnapinAboutImpl();

public:
    DECLARE_REGISTRY(
        CSnapin,
        _T("ISMSnapin.About.1"),
        _T("ISMSnapin.About"),
        IDS_SNAPIN_DESC,
        THREADFLAGS_BOTH
        )

BEGIN_COM_MAP(CSnapinAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(
        HBITMAP * hSmallImage,
        HBITMAP * hSmallImageOpen,
        HBITMAP * hLargeImage,
        COLORREF * cMask
        );

//
// Internal functions
//
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR * lpPtr);
};



//
// Helper macro
//
#define FREE_DATA(pData) ASSERT(pData != NULL);\
    do { if (pData != NULL) GlobalFree(pData); } while(0);

//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline DWORD CComponentDataImpl::AddServerToList(
    IN BOOL fCache,
    IN BOOL fDisplayErrors,
    IN CString & lpServerName,
    IN int & cServices
    )
{
    return AddServerToList(
        fCache,
        fDisplayErrors,
        lpServerName,
        cServices,
        m_oblServices
        );
}

inline void CComponentDataImpl::AddServiceToList(CServiceInfo * pServiceInfo)
{
    m_oblServices.AddTail(pServiceInfo);
}

inline int CComponentDataImpl::QueryNumInstalledServices() const
{
    return (int) m_oblServices.GetCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\connects.cpp ===
/*++

   Copyright    (c)    1994-1998   Microsoft Corporation

   Module  Name :

        connects.cpp

   Abstract:

        "Connect to a single server" dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Functions Exported:

   Revision History:

--*/

//
// Include files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "connects.h"
#include "constr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define HIDD_CONNECT_SERVER      0x29cd9

ConnectServerDlg::ConnectServerDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CWnd * pParent : Optional pointer to parent window

Return Value:

    N/A

--*/
    : CDialog(ConnectServerDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(ConnectServerDlg)
    m_strServerName = _T("");
    //}}AFX_DATA_INIT
}




void
ConnectServerDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:
    
    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ConnectServerDlg)
    DDX_Control(pDX, IDC_SERVERNAME, m_edit_ServerName);
    DDX_Control(pDX, IDOK, m_button_Ok);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_SERVERNAME, m_strServerName);
    DDV_MaxChars(pDX, m_strServerName, MAX_SERVERNAME_LEN);
}




//
// Message Map
//
BEGIN_MESSAGE_MAP(ConnectServerDlg, CDialog)
    //{{AFX_MSG_MAP(ConnectServerDlg)
    ON_EN_CHANGE(IDC_SERVERNAME, OnChangeServername)
    ON_BN_CLICKED(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void
ConnectServerDlg::OnHelp()
{
   CString strHelpFile;
   CRMCRegKey rk(REG_KEY, SZ_PARAMETERS, KEY_READ);
   rk.QueryValue(SZ_HELPPATH, strHelpFile, EXPANSION_ON);
   strHelpFile += _T("\\inetmgr.hlp");

   CWnd * pWnd = ::AfxGetMainWnd();
   HWND hWndParent = pWnd != NULL
        ? pWnd->m_hWnd
        : NULL;

   ::WinHelp(m_hWnd, strHelpFile, HELP_CONTEXT, HIDD_CONNECT_SERVER);
}


void
ConnectServerDlg::OnChangeServername() 
/*++

Routine Description:

    Respond to change of text in the server edit control 
    by enabling or disabling the OK button depending on
    whether there's any text in the server name edit
    control.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(m_edit_ServerName.GetWindowTextLength() > 0);
}



BOOL 
ConnectServerDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // No server name has been entered yet.
    //
    m_button_Ok.EnableWindow(FALSE);
    
    return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\constr.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        constr.h

   Abstract:

        Registry constant definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _CONSTR_H_
#define _CONSTR_H_

// ==========================================================================
//
// Keys
//
// ==========================================================================

#define REG_KEY              HKEY_LOCAL_MACHINE

#define SZ_INETMGR_REG_KEY   _T("Software\\Microsoft\\INetMgr")
#define SZ_PARAMETERS        SZ_INETMGR_REG_KEY _T("\\Parameters")

#define SZ_ADDONSERVICES     SZ_PARAMETERS _T("\\AddOnServices")
#define SZ_ADDONTOOLS        SZ_PARAMETERS _T("\\AddOnTools")
#define SZ_ADDONHELP         SZ_PARAMETERS _T("\\AddOnHelp")
#define SZ_ADDONMACHINEPAGES SZ_PARAMETERS _T("\\AddOnMachinePages")

#define SZ_REMOTEIISEXT      _T("System\\CurrentControlSet\\Control\\IIS Extensions")

// ==========================================================================
//
// Values
//
// ==========================================================================

//
// Computer Values
//
#define SZ_MAJORVERSION      _T("MajorVersion")
#define SZ_MINORVERSION      _T("MinorVersion")
#define SZ_HELPPATH          _T("HelpLocation")

//
// User Values
//
#define SZ_X                 _T("x")
#define SZ_Y                 _T("y")
#define SZ_DX                _T("dx")
#define SZ_DY                _T("dy")
#define SZ_MODE              _T("Mode")
#define SZ_WAITTIME          _T("WaitTime")
#define SZ_VIEW              _T("View")
#define SZ_SHOW_SPLASH       _T("ShowSplash")

//
// Help File Document
//
#define SZ_HELP_DOC          _T("http://localhost/iishelp/iis/misc/default.asp")

// ==========================================================================
//
// Helper MACROS
//
// ==========================================================================
#define SET_INT_AS_DWORD(rk, value, nValue, dwParm)    \
    {                                                  \
        dwParm = (DWORD)nValue;                        \
        rk.SetValue( value, dwParm );                  \
    }

#define SET_DW_IF_EXIST(rk, value, dwParm, dwTarget)   \
    if (rk.QueryValue(value, dwParm) == ERROR_SUCCESS) \
    {                                                  \
        dwTarget = dwParm;                             \
    }                                                  

#endif // _CONSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\dataobj.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        dataobj.h

   Abstract:

        Snapin data object definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

class CDataObject: 
    public IDataObject, 
    public CComObjectRoot 
{
    friend class CSnapin;

//
// ATL Maps
//
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

//
// Construction/Destruction
//
public:
    CDataObject() 
    {
#ifdef _DEBUG
        m_ComponentData = NULL;
#endif // _DEBUG
    };

    ~CDataObject() 
    {
#ifdef _DEBUG
        m_ComponentData = NULL;
#endif // _DEBUG
    };

//
// Clipboard formats that are required by the console
//
public:
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    static unsigned int    m_cfInternal;        // internal

/*
    //
    // Multi-selection
    //
    static unsigned int    m_cfpMultiSelDataObj;
    static unsigned int    m_cfMultiObjTypes;
    static unsigned int    m_cfMultiSelDataObjs;
*/
    //
    // Published information
    //
    static unsigned int    m_cfMyComputMachineName;
    static unsigned int    m_cfISMMachineName;  // Machine name (e.g. "ronaldm2")
    static unsigned int    m_cfISMService;      // Service string (e.g. "w3svc")
    static unsigned int    m_cfISMInstance;     // Instance number
    static unsigned int    m_cfISMParentPath;
    static unsigned int    m_cfISMNode;
    static unsigned int    m_cfISMMetaPath;     // Complete metabase path
    
//
// Standard IDataObject methods
//
public:
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC * ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
#ifdef _DEBUG
        ASSERT(m_ComponentData != NULL);
        ++(m_ComponentData->m_cDataObjects);
#endif 
        return CComObjectRoot::InternalAddRef();
    }

    ULONG InternalRelease()
    {
#ifdef _DEBUG
        ASSERT(m_ComponentData != NULL);
        --(m_ComponentData->m_cDataObjects);
#endif 
        return CComObjectRoot::InternalRelease();
    }

//
// Not Implemented
//
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc) 
    { 
        return E_NOTIMPL; 
    };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { 
        return E_NOTIMPL; 
    };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { 
        return E_NOTIMPL; 
    };

    STDMETHOD(DAdvise)(
        IN LPFORMATETC lpFormatetc, 
        IN DWORD advf,
        IN LPADVISESINK pAdvSink, 
        IN LPDWORD pdwConnection
        )
    { 
        return E_NOTIMPL; 
    };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { 
        return E_NOTIMPL; 
    };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA * ppEnumAdvise)
    { 
        return E_NOTIMPL; 
    };

//
// Implementation
//
public:
    void SetType(
        IN DATA_OBJECT_TYPES type
        ) 
    { 
        ASSERT(m_internal.m_type == CCT_UNINITIALIZED); 
        m_internal.m_type = type; 
    }

    void SetCookie(
        IN MMC_COOKIE cookie
        ) 
    { 
        m_internal.m_cookie = cookie; 
    } 

    void SetClsid(
        IN const CLSID & clsid
        )
    { 
        m_internal.m_clsid = clsid; 
    }

#ifdef _DEBUG
    //
    // This is used only as a diagnostic in debug builds to track if 
    // anyone is hanging on to any data objects that's have been handed out
    // Snapins should view context data objects as ephemeral.
    //
public:
    void SetComponentData(
        IN CComponentDataImpl * pCCD
        ) 
    {
        ASSERT(m_ComponentData == NULL && pCCD != NULL); 
        m_ComponentData = pCCD;
    };

private:
    CComponentDataImpl * m_ComponentData;
#endif // _DEBUG

private:
    //
    // Field types as used by CreateMetaField
    //
    enum META_FIELD
    {
        META_SERVICE,
        META_INSTANCE,
        META_PARENT,
        META_NODE,
        /**/
        META_WHOLE
    };

    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateMachineName(LPSTGMEDIUM lpMedium);
    HRESULT CreateMetaField(LPSTGMEDIUM lpMedium, META_FIELD fld);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); 
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT Create(const void * pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;    
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\dataobj.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        dataobj.cpp

   Abstract:

        Snapin data object

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "cinetmgr.h"
#include "dataobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.
//
unsigned int CDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

/*
//
// Multi-select
//
unsigned int CDataObject::m_cfpMultiSelDataObj = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
unsigned int CDataObject::m_cfMultiObjTypes    = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
unsigned int CDataObject::m_cfMultiSelDataObjs = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
*/

//
// Internal
//
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(ISM_SNAPIN_INTERNAL);

//
// Published Information
//
unsigned int CDataObject::m_cfISMMachineName = RegisterClipboardFormat(ISM_SNAPIN_MACHINE_NAME);
unsigned int CDataObject::m_cfMyComputMachineName = RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
unsigned int CDataObject::m_cfISMService     = RegisterClipboardFormat(ISM_SNAPIN_SERVICE);
unsigned int CDataObject::m_cfISMInstance    = RegisterClipboardFormat(ISM_SNAPIN_INSTANCE);
unsigned int CDataObject::m_cfISMParentPath  = RegisterClipboardFormat(ISM_SNAPIN_PARENT_PATH);
unsigned int CDataObject::m_cfISMNode        = RegisterClipboardFormat(ISM_SNAPIN_NODE);
unsigned int CDataObject::m_cfISMMetaPath    = RegisterClipboardFormat(ISM_SNAPIN_META_PATH);




STDMETHODIMP 
CDataObject::GetDataHere(
    IN LPFORMATETC lpFormatetc,
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Write requested information type to the given medium

Arguments:

    LPFORMATETC lpFormatetc     : Format etc
    LPSTGMEDIUM lpMedium        : Medium to write to.

Return Value:

    HRESULT

--*/
{
    HRESULT hr = DV_E_CLIPFORMAT;

    //
    // Based on the CLIPFORMAT write data to the stream
    //
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfISMMachineName)
    {
        hr = CreateMachineName(lpMedium);
    }

/*
    multi-select pulled

    else if (cf == m_cfpMultiSelDataObj)
    {
        TRACEEOLID("CCF_MMC_MULTISELECT_DATAOBJECT");
    }
    else if (cf == m_cfMultiObjTypes)
    {
        TRACEEOLID("CCF_OBJECT_TYPES_IN_MULTI_SELECT");
    }
    else if (cf == m_cfMultiSelDataObjs)
    {
         TRACEEOLID("CCF_MULTI_SELECT_SNAPINS");
    }
*/

    else if (cf == m_cfISMService)
    {
        hr = CreateMetaField(lpMedium, META_SERVICE);
    }
    else if (cf == m_cfISMInstance)
    {
        hr = CreateMetaField(lpMedium, META_INSTANCE);
    }
    else if (cf == m_cfISMParentPath)
    {
        hr = CreateMetaField(lpMedium, META_PARENT);
    }
    else if (cf == m_cfISMNode)
    {
        hr = CreateMetaField(lpMedium, META_NODE);
    }
    else if (cf == m_cfISMMetaPath)
    {
        hr = CreateMetaField(lpMedium, META_WHOLE);
    }
    else
    {
        TRACEEOLID("Unrecognized format");
        hr = DV_E_CLIPFORMAT;
    }

    return hr;
}



STDMETHODIMP
CDataObject::GetData(
    IN LPFORMATETC lpFormatetcIn,
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Get data from the data object

Arguments:

    LPFORMATETC lpFormatetcIn   : Formatetc Input
    LPSTGMEDIUM lpMedium        : Pointer to medium

Return Value:

    HRESULT

--*/
{
    //
    // Not implemented
    //
    return E_NOTIMPL;
}



STDMETHODIMP
CDataObject::EnumFormatEtc(
    IN DWORD dwDirection,
    IN LPENUMFORMATETC * ppEnumFormatEtc
    )
/*++

Routine Description:

    Enumerate format etc information

Arguments:

    DWORD dwDirection                   : Direction
    LPENUMFORMATETC * ppEnumFormatEtc   : Format etc array


Return Value:

    HRESULT

--*/
{
    //
    // Not implemented
    //
    return E_NOTIMPL;
}



//
// CDataObject creation members
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
CDataObject::Create(
    IN const void * pBuffer,
    IN int len,
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Create information on the given medium

Arguments:

    const void * pBuffer        : Data buffer
    int len                     : Size of data
    LPSTGMEDIUM lpMedium        : Medium to write to.

Return Value:

    HRESULT

--*/
{
    HRESULT hr = DV_E_TYMED;

    //
    // Do some simple validation
    //
    if (pBuffer == NULL || lpMedium == NULL)
    {
        return E_POINTER;
    }

    //
    // Make sure the type medium is HGLOBAL
    //
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        //
        // Create the stream on the hGlobal passed in
        //
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            //
            // Write to the stream the number of bytes
            //
            unsigned long written;
            hr = lpStream->Write(pBuffer, len, &written);

            //
            // Because we called CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free
            // the HGLOBAL at the correct time.  This is according to
            // the IDataObject specification.
            //
            lpStream->Release();
        }
    }

    return hr;
}



HRESULT
CDataObject::CreateNodeTypeData(
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Create node type data on medium

Arguments:

    LPSTGMEDIUM lpMedium        : Medium to write to.

Return Value:

    HRESULT

--*/
{
    //
    // Create the node type object in GUID format
    //
    const GUID * pcObjectType = NULL;

    if (m_internal.m_cookie == NULL)
    {
        //
        // Blank CIISNode, must be the static root
        //
        pcObjectType = &cInternetRootNode;
    }
    else
    {
        //
        // Ask the object what kind of object it is.
        //
        CIISObject * pObject = (CIISObject *)m_internal.m_cookie;
        pcObjectType = pObject->GetGUIDPtr();
    }

    return Create((const void *)pcObjectType, sizeof(GUID), lpMedium);
}



HRESULT 
CDataObject::CreateNodeTypeStringData(
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Create node type in string format

Arguments:

    LPSTGMEDIUM lpMedium        : Medium to write to.

Return Value:

    HRESULT

--*/
{
    //
    // Create the node type object in GUID string format
    //
    const wchar_t * cszObjectType = NULL;
    CString str;

    if (m_internal.m_cookie == NULL)
    {
        //
        // This must be the static root node
        //
        cszObjectType = GUIDToCString(cInternetRootNode, str);
    }
    else
    {
        //
        // Ask the CIISObject what type it is
        //
        CIISObject * pObject = (CIISObject *)m_internal.m_cookie;
        cszObjectType = GUIDToCString(pObject->QueryGUID(), str);
    }

    return Create(
        cszObjectType,
        ((wcslen(cszObjectType) + 1) * sizeof(wchar_t)),
        lpMedium
        );
}



HRESULT
CDataObject::CreateDisplayName(
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    CDataObject implementations

Arguments:

Return Value:

    HRESULT

--*/
{
    //
    // This is the display name used in the scope pane and snap-in manager
    //
    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name
    //

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(
        szDispName,
        ((szDispName.GetLength() + 1) * sizeof(wchar_t)),
        lpMedium
        );
}



HRESULT
CDataObject::CreateInternal(
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    CDataObject implementations

Arguments:

Return Value:

    HRESULT

--*/
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}



HRESULT
CDataObject::CreateMachineName(
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Create the machine name

Arguments:

    LPSTGMEDIUM lpMedium  : Address of STGMEDIUM object

Return Value:

    HRESULT

--*/
{
    wchar_t pzName[MAX_PATH + 1] = {0};
    DWORD len; // = MAX_PATH + 1;

    CIISObject * pObject = (CIISObject *)m_internal.m_cookie;
    if (pObject == NULL)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    lstrcpyn(pzName, pObject->GetMachineName(), MAX_PATH);
	len = lstrlen(pzName);

    //
    // Add 1 for the NULL and calculate the bytes for the stream
    //
    return Create(pzName, ((len + 1) * sizeof(wchar_t)), lpMedium);
}



HRESULT
CDataObject::CreateMetaField(
    IN LPSTGMEDIUM lpMedium,
    IN META_FIELD fld
    )
/*++

Routine Description:

    Create a field from the metabase path, indicated by fld, or the entire
    path.

Arguments:

    LPSTGMEDIUM lpMedium  : Address of STGMEDIUM object
    META_FIELD fld        : Type of metabase information

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = (CIISObject *)m_internal.m_cookie;

    if (pObject == NULL)
    {
        //
        // Static root node has no metabase path
        //
        ASSERT(FALSE);
        return E_FAIL;
    }

    //
    // Generate complete metabase path for this node
    //
    CString strField;
    CString strMetaPath;
    pObject->BuildFullPath(strMetaPath, TRUE);

    if (fld == META_WHOLE)
    {
        //
        // Whole metabase path requested
        //
        strField = strMetaPath;
    }
    else
    {
        //
        // A portion of the metabase is requested.  Return the requested
        // portion
        //
        LPCTSTR lpMetaPath = (LPCTSTR)strMetaPath;
        LPCTSTR lpEndPath = lpMetaPath + strMetaPath.GetLength() + 1;
        LPCTSTR lpSvc = NULL;
        LPCTSTR lpInstance = NULL;
        LPCTSTR lpParent = NULL;
        LPCTSTR lpNode = NULL;

        //
        // Break up the metabase path in portions
        //
        if (lpSvc = _tcschr(lpMetaPath, _T('/')))
        {
            ++lpSvc;

            if (lpInstance = _tcschr(lpSvc, _T('/')))
            {
                ++lpInstance;

                if (lpParent = _tcschr(lpInstance, _T('/')))
                {
                    ++lpParent;
                    lpNode = _tcsrchr(lpParent, _T('/'));

                    if (lpNode)
                    {
                        ++lpNode;
                    }
                }
            }
        }

        int n1, n2;
        switch(fld)
        {
        case META_SERVICE:
            //
            // Requested the service string
            //
            if (lpSvc)
            {
                n1 = DIFF(lpSvc - lpMetaPath);
                n2 = lpInstance ? DIFF(lpInstance - lpSvc) : DIFF(lpEndPath - lpSvc);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
            break;

        case META_INSTANCE:
            //
            // Requested the instance number
            //
            if (lpInstance)
            {
                n1 = DIFF(lpInstance - lpMetaPath);
                n2 = lpParent ? DIFF(lpParent - lpInstance) : DIFF(lpEndPath - lpInstance);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }

            break;

        case META_PARENT:
            //
            // Requestd the parent path
            //
            if (lpParent)
            {
                n1 = DIFF(lpParent - lpMetaPath);
                n2 = lpNode ? DIFF(lpNode - lpParent) : DIFF(lpEndPath - lpParent);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
            break;

        case META_NODE:
            //
            // Requested the node name
            //
            if (lpNode)
            {
                n1 = DIFF(lpNode - lpMetaPath);
                n2 = DIFF(lpEndPath - lpNode);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
            break;

        default:
            //
            // Bogus
            //
            ASSERT(FALSE);
            return E_FAIL;
        }
    }

    TRACEEOLID("Requested metabase path data: " << strField);
    int len = strField.GetLength() + 1;

    return Create((LPCTSTR)strField, (len) * sizeof(TCHAR), lpMedium);
}



HRESULT
CDataObject::CreateCoClassID(
    IN LPSTGMEDIUM lpMedium
    )
/*++

Routine Description:

    Create the CoClassID

Arguments:

    LPSTGMEDIUM lpMedium        : Medium

Return Value:

    HRESULT

--*/
{
    //
    // Create the CoClass information
    //
    return Create((const void *)&m_internal.m_clsid, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\connects.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        connects.h

   Abstract:

        "Connect to a single server" dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class ConnectServerDlg : public CDialog
{
/*++

Class Description:

    Connect to a server dialog

Public Interface:

    ConnectServerDlg : Constructor

    QueryServerName  : Get the server name entered

--*/

//
// Construction
//
public:
    ConnectServerDlg(
        IN CWnd * pParent = NULL
        );   

//
// Access Functions
//
public:
    LPCTSTR QueryServerName() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(ConnectServerDlg)
    enum { IDD = IDD_CONNECT_SERVER };
    CEdit   m_edit_ServerName;
    CButton m_button_Ok;
    CString m_strServerName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(ConnectServerDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(ConnectServerDlg)
    afx_msg void OnChangeServername();
    afx_msg void OnHelp();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR ConnectServerDlg::QueryServerName() const
{
    return m_strServerName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\events.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        events.cpp

   Abstract:

        Handle snapin event notifications

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "cinetmgr.h"



//
// Event handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT 
CSnapin::OnFolder(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    'Folder change' notification handler

Arguments:

    MMC_COOKIE cookie   : Selected item
    LPARAM arg          : Notification Argument
    LPARAM param        : Notification Parameter

Return Value:

    HRESULT

--*/
{
    ASSERT(FALSE);

    return S_OK;
}



HRESULT 
CSnapin::OnAddImages(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    'Add Image' handler

Arguments:

    MMC_COOKIE cookie   : Selected item
    LPARAM arg          : Notification Argument
    LPARAM param        : Notification Parameter

Return Value:

    HRESULT

--*/
{
    //
    // if cookie is from a different snapin
    // if (IsMyCookie(cookie) == FALSE)
    //
    if (0)
    {
        //
        // add the images for the scope tree only
        //
        CBitmap bmp16x16;
        CBitmap bmp32x32;
        LPIMAGELIST lpImageList = reinterpret_cast<LPIMAGELIST>(arg);

        //
        // Load the bitmaps from the dll
        //
        {
            AFX_MANAGE_STATE(AfxGetStaticModuleState());
            bmp16x16.LoadBitmap(IDB_16x16);
            bmp32x32.LoadBitmap(IDB_32x32);
        }

        //
        // Set the images
        //
        lpImageList->ImageListSetStrip(
            reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
            reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
            0, RGB(255, 0, 255)
            );

        lpImageList->Release();
    }
    else
    {
        InitializeBitmaps(cookie);
    }

    return S_OK;
}



HRESULT 
CSnapin::OnShow(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    'Show' notification handler

Arguments:

    MMC_COOKIE cookie   : Selected item
    LPARAM arg          : Notification Argument
    LPARAM param        : Notification Parameter

Return Value:

    HRESULT

--*/
{
    //
    // Note - arg is TRUE when it is time to enumerate
    //
    if (arg)
    {
        //
        // Show the headers for this nodetype
        //
        InitializeHeaders(cookie);
        Enumerate(cookie, param);

        if (m_pControlbar)
        {
            SetToolbarStates(cookie);
        }
    }
    else
    {
        //
        // Free data associated with the result pane items, because
        // the node is no longer being displayed.
        // Note: The console will remove the items from the result pane
        //
        m_oblResultItems.RemoveAll();
    }

    return S_OK;
}



HRESULT 
CSnapin::OnActivate(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    'Activiation' notification handler

Arguments:

    MMC_COOKIE cookie   : Selected item
    LPARAM arg          : Notification Argument
    LPARAM param        : Notification Parameter

Return Value:

    HRESULT

--*/
{
    return S_OK;
}



HRESULT 
CSnapin::OnResultItemClkOrDblClk(
    IN MMC_COOKIE cookie,
    IN BOOL fDblClick
    )
/*++

Routine Description:

    Result item click/double click notification handler

Arguments:

    MMC_COOKIE cookie   : Selected item
    BOOL fDblClick      : TRUE if double click, FALSE for single click

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = (CIISObject *)cookie;

    if (pObject && !pObject->IsMMCConfigurable() && pObject->IsLeafNode())
    {
        //
        // Special case: Down-level object -- not mmc configurable, but
        // configuration is the default verb, so fake it.
        //
        if (fDblClick)
        {
            ((CComponentDataImpl *)m_pComponentData)->DoConfigure(pObject);

            return S_OK;
        }
    }

    //
    // Use the default verb
    //
    return S_FALSE;
}



HRESULT
CSnapin::OnMinimize(
    IN MMC_COOKIE cookie,
    IN LPARAM arg,
    IN LPARAM param
    )
/*++

Routine Description:

    'Minimize' handler

Arguments:

    MMC_COOKIE cookie   : Selected item
    LPARAM arg          : Notification Argument
    LPARAM param        : Notification Parameter

Return Value:

    HRESULT

--*/
{
    return S_OK;
}



HRESULT
CSnapin::OnPropertyChange(
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    'Property change' notification handler

Arguments:

    LPDATAOBJECT lpDataObject       : Selected data object

Return Value:

    HRESULT

--*/
{
    CIISObject * pObject = NULL;
    if (lpDataObject != NULL)
    {
        INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);
        if (pInternal != NULL)
        {
            pObject = (CIISObject *)pInternal->m_cookie;
            SetToolbarStates((MMC_COOKIE)pObject);
            FREE_DATA(pInternal);
        }
    }

    return S_OK;
}



HRESULT
CSnapin::OnUpdateView(
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    'Update View' notification handler

Arguments:

    LPDATAOBJECT lpDataObject       : Selected data object

Return Value:

    HRESULT

--*/
{
    return OnPropertyChange(lpDataObject);
}



void
CSnapin::Enumerate(
    IN MMC_COOKIE cookie,
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Scope item enumeration notification handler

Arguments:

    MMC_COOKIE cookie       : Selected cookie (i.e. IISObject *)
    HSCOPEITEM hParent      : Scope item to be enumerated

Return Value:

    None

--*/
{
    //
    // Add result view items
    //
    EnumerateResultPane(cookie);
}



void
CSnapin::AddFileSystem(
    IN HSCOPEITEM hParent,
    IN LPCTSTR lpstrRoot,
    IN LPCTSTR lpstrMetaRoot,
    IN CIISInstance * pInstance,
    IN BOOL fGetDirs
    )
/*++

Routine Description:

    Add file system to result view.

Arguments:

    HSCOPEITEM hParent          Parent scope item
    LPCTSTR lpstrRoot           Physical path
    LPCTSTR lpstrMetaRoot       Meta root
    CIISInstance * pInstance    Owning instance
    BOOL fGetDirs               TRUE for directories, FALSE for files

Return Value:

    None

--*/
{
    //
    // Save state - needed for CWaitCursor
    //
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD   dwBufferSize = 0L;
    int     cChildren = 0;
    CError  err;
	
    do
    {
		CWaitCursor();
		
        LPCTSTR lpstrOwner = pInstance->GetMachineName();
        ASSERT(lpstrOwner);

        CString strDir;

        if (::IsServerLocal(lpstrOwner) || ::IsUNCName(lpstrRoot))
        {
            //
            // Local directory, or already a unc path
            //
            strDir = lpstrRoot;
        }
        else
        {
            ::MakeUNCPath(strDir, lpstrOwner, lpstrRoot);
        }

        strDir.TrimLeft();
        strDir.TrimRight();

        if (strDir.IsEmpty())
        {
            //
            // Invalid path
            //
            break;
        }

        strDir += _T("\\*");

        WIN32_FIND_DATA w32data;
        HANDLE hFind = ::FindFirstFile(strDir, &w32data);

        if (hFind == INVALID_HANDLE_VALUE)
        {
            err.GetLastWinError();
            break;
        }

        //
        // Find metabase information to match up with
        // this entry
        //
        CWaitCursor wait;

        CString strRedirect;
        CString strBase;
        pInstance->BuildFullPath(strBase, TRUE);
        LPCTSTR lpPath = lpstrMetaRoot;

        while (lpPath && *lpPath && *lpPath != _T('/')) ++lpPath;

        if (lpPath && *lpPath)
        {
            strBase += lpPath;
        }

        TRACEEOLID("Opening: " << strBase);
        TRACEEOLID(lpstrMetaRoot);

        BOOL fCheckMetabase = TRUE;
        CMetaKey mk(
            lpstrOwner, 
            METADATA_PERMISSION_READ, 
            METADATA_MASTER_ROOT_HANDLE,
            strBase
            );

        CError errMB(mk.QueryResult());

        if (errMB.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Metabase path not found, not a problem.
            //
            TRACEEOLID("Parent node not in metabase");
            fCheckMetabase = FALSE;
            errMB.Reset();
        }
        else if (!errMB.MessageBoxOnFailure())
        {
            //
            // Opened successfully, read redirect string.
            //
            DWORD dwAttr;

            errMB = mk.QueryValue(
                MD_HTTP_REDIRECT, 
                strRedirect,
                NULL,                  // Inheritance override
                NULL,                  // Path
                &dwAttr
                );

            if (errMB.Succeeded())
            {
                if (IS_FLAG_SET(dwAttr, METADATA_INHERIT))
                {
                    int nComma = strRedirect.Find(_T(','));

                    if (nComma >= 0)
                    {
                        strRedirect.ReleaseBuffer(nComma);
                    }
                }
                else
                {
                    //
                    // Yes, there's a redirect on the parent, but it's
                    // not marked as inheritable, so it won't affect
                    // the children.
                    //
                    strRedirect.Empty();
                }
            }
        }

        //
        // Loop through the file system
        //
        do                                              
        {
            //
            // Check to see if this is a file or directory as desired.
            // Ignore anything starting with a dot.
            //
            TRACEEOLID(w32data.cFileName);
            BOOL fIsDir = 
                ((w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);

            if (fIsDir == fGetDirs && *w32data.cFileName != _T('.'))
            {
                CIISFileNode * pNode = new CIISFileNode(
                    w32data.cFileName,
                    w32data.dwFileAttributes,
                    pInstance,
                    strRedirect,
                    fIsDir
                    );

                if (pNode == NULL)
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //
                // For the result view -- only files, directories 
                // get added automatically
                //
                ASSERT(!fIsDir);

                if (fCheckMetabase)
                {
                    errMB = mk.DoesPathExist(w32data.cFileName);

                    if (errMB.Succeeded())
                    {
                        //
                        // Match up with metabase properties.  If the item
                        // is found in the metabase with a non-inherited vrpath,
                        // than a virtual root with this name exists, and this 
                        // file/directory should not be shown.
                        //
                        BOOL fVirtualDirectory;
                        CString strMetaRoot(lpstrMetaRoot);

                        errMB = pNode->FetchMetaInformation(
                            strMetaRoot, 
                            &fVirtualDirectory
                            );

                        if (errMB.Succeeded() && fVirtualDirectory) 
                        {
                            TRACEEOLID("file/directory exists as vroot -- tossing" 
                                << w32data.cFileName);
                            delete pNode;

                            continue;
                        }
                    }
                }
            
                //
                // This better be unassigned -- one scope item per IISobject!
                // Note that the scope handle we're setting is actually the
                // _parent_'s scope handle.
                //
                ASSERT(pNode->GetScopeHandle() == NULL);
                pNode->SetScopeHandle(hParent, TRUE); 

                //
                // Add the item
                //                
                RESULTDATAITEM ri;
                ::ZeroMemory(&ri, sizeof(ri));
                ri.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                ri.str = MMC_CALLBACK;
                ri.nImage = pNode->QueryBitmapIndex();
                ri.lParam = (LPARAM)pNode;
                m_pResult->InsertItem(&ri);

                //
                // Store 
                //
                m_oblResultItems.AddTail(pNode);
            }
        }
        while(err.Succeeded() && FindNextFile(hFind, &w32data));

        ::FindClose(hFind);
    }
    while(FALSE);

    if (err.Failed())
    {
        //
        // Behaviour change: Display the errors always on the result 
        // enumerator, and stop displaying them on the scope side 
        // (this way we avoid double error messages)
        //
        err.MessageBoxFormat(
            IDS_ERR_ENUMERATE_FILES,
            MB_OK,
            NO_HELP_CONTEXT
            );
    }
}



void
CSnapin::DestroyItem(
    IN LPDATAOBJECT lpDataObject
    )
/*++

Routine Description:

    Delete the contents of the given data object

Arguments:

    LPDATAOBJECT lpDataObject : Data object to be destroyed

Return Value:

    None

--*/
{
    CIISObject * pObject = NULL;

    if (lpDataObject)
    {
        INTERNAL * pInternal = ExtractInternalFormat(lpDataObject);

        if (pInternal)
        {
            pObject = (CIISObject *)pInternal->m_cookie;
            delete pObject;
            FREE_DATA(pInternal);
        }
    }
}



void
CSnapin::EnumerateResultPane(
    IN MMC_COOKIE cookie
    )
/*++

Routine Description:

    Enumerate the result pane

Arguments:

    MMC_COOKIE cookie     : Parent CIISObject (scope side)

Return Value:

    None

--*/
{
    //
    // Make sure we QI'ed for the interface
    //
    ASSERT(m_pResult != NULL);
    ASSERT(m_pComponentData != NULL);

    CIISObject * pObject = (CIISObject *)cookie;

    if (pObject == NULL)
    {
        //
        // Static root node -- owns no leaf nodes
        //
        return;
    }

    if (pObject->SupportsFileSystem())
    {
        CString strPhysicalPath, strMetaPath;
        pObject->BuildPhysicalPath(strPhysicalPath);
        pObject->BuildFullPath(strMetaPath, FALSE);

        AddFileSystem(
            pObject->GetScopeHandle(),
            strPhysicalPath,
            strMetaPath,
            pObject->FindOwnerInstance(),
            GET_FILES
            );
    }

    //m_pResult->Sort(0, 0, -1);
}



HSCOPEITEM
CComponentDataImpl::AddIISObject(
    IN HSCOPEITEM hParent,
    IN CIISObject * pObject,
    IN HSCOPEITEM hSibling,     OPTIONAL
    IN BOOL fNext               OPTIONAL
    )
/*++

Routine Description:

    Insert IIS object to the scope view

Arguments:

    HSCOPEITEM hParent      : Parent scope handle
    CIISObject * pObject    : Object to be added
    HSCOPEITEM hSibling     : NULL, or otherwise next sibling item
    BOOL fNext              : If hSibling != NULL, this is used to indicate
                            : Next (TRUE), or Previous (FALSE).

Return Value:

    Handle to scope item of the newly added item

--*/
{
    ASSERT(m_pScope != NULL);
    ASSERT(pObject != NULL);

    SCOPEDATAITEM item;
    ::ZeroMemory(&item, sizeof(SCOPEDATAITEM));

    item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;

    if (hSibling != NULL)
    {
        item.mask |= (fNext ? SDI_NEXT : SDI_PREVIOUS);
        item.relativeID = hSibling;
    }
    else
    {
        item.mask |= SDI_PARENT;
        item.relativeID = hParent;
    }

    //
    // No '+' sign if no child objects could possibly exist.
    // e.g. downlevel web services, etc.
    //
    item.cChildren = 
        (pObject->SupportsFileSystem() || pObject->SupportsChildren())
        ? 1 : 0;

    item.displayname = MMC_CALLBACK;
    item.nOpenImage = item.nImage = pObject->QueryBitmapIndex();
    item.lParam = (LPARAM)pObject;
    m_pScope->InsertItem(&item);

    //
    // This better be unassigned -- one scope item per IISobject!
    //
    ASSERT(pObject->GetScopeHandle() == NULL);
    pObject->SetScopeHandle(item.ID);

    return item.ID;
}



BOOL
CComponentDataImpl::KillChildren(
    IN HSCOPEITEM hParent,
    IN UINT nOpenErrorMsg,
    IN BOOL fFileNodesOnly,
    IN BOOL fContinueOnOpenSheet
    )
/*++

Routine Description:

    Kill all children of a given parent node.

Arguments:

    HSCOPEITEM hParent        : The infanticidal parent handle
    UINT nOpenErrorMsg        : Error indicating open prop sheet
    BOOL fFileNodesOnly       : TRUE to delete only file nodes
    BOOL fContinueOnOpenSheet : TRUE to continue on open sheet error

Return Value:

    TRUE if the nodes were deleted successfully -- FALSE if an open property
    sheet prevents deletions.

--*/
{
    ASSERT(m_pScope != NULL);
    ASSERT(nOpenErrorMsg > 0);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HSCOPEITEM hChildItem;
    MMC_COOKIE cookie;

    //
    // If a property sheet is open for this item, don't
    // allow deletion.
    //
    LPPROPERTYSHEETPROVIDER piPropertySheetProvider = NULL;

    CError err(m_pConsole->QueryInterface(
        IID_IPropertySheetProvider,
        (void **)&piPropertySheetProvider
        ));

    if (err.MessageBoxOnFailure())
    {
        return FALSE;
    }

    CWaitCursor wait;

    if (!fFileNodesOnly)
    {
        //
        // Loop through and find open property sheets on the
        // nodes.  
        //
        err = m_pScope->GetChildItem(hParent, &hChildItem, &cookie);

        while (err.Succeeded() && hChildItem != NULL)
        {
            CIISObject * pObject = (CIISObject *)cookie;
            HSCOPEITEM hTarget = NULL;

            if (FindOpenPropSheetOnNodeAndDescendants(
                piPropertySheetProvider,
                cookie
                ))
            {
                ::AfxMessageBox(nOpenErrorMsg);

                if (!fContinueOnOpenSheet)
                {
                    return FALSE;
                }
            }

            //
            // Advance to next child of the same parent.
            //
            err = m_pScope->GetNextItem(hChildItem, &hChildItem, &cookie);
        }
    }

    //
    // Having ensured that no relevant property sheets remain open,
    // we can start committing infanticide.
    //
    err = m_pScope->GetChildItem(hParent, &hChildItem, &cookie);

    while (err.Succeeded() && hChildItem != NULL)
    {
        CIISObject * pObject = (CIISObject *)cookie;
        TRACEEOLID("Deleting: " << pObject->GetNodeName());
        HSCOPEITEM hTarget = NULL;

        if (!fFileNodesOnly || pObject->IsFileSystemNode())
        {
            if (FindOpenPropSheetOnNodeAndDescendants(
                piPropertySheetProvider, 
                cookie
                ))
            {
                //
                // Can't kill this one then, display error, but continue
                //
                TRACEEOLID("Unable to kill child -- sheet open shouldn't happen!");
                ASSERT(FALSE && "Should have been closed in the first pass");    

                //
                // Message for retail.  How did he do it?
                //
                ::AfxMessageBox(nOpenErrorMsg);
                if (!fContinueOnOpenSheet)
                {
                    return FALSE;
                }
            }
            else
            {
                //
                // Remember that this one is to be deleted.
                //
                hTarget = hChildItem;
            }
        }

        //
        // Advance to next child of the same parent.
        //
        err = m_pScope->GetNextItem(hChildItem, &hChildItem, &cookie);

        if (hTarget)
        {
            //
            // Delete the item we remembered earlier.  This has to be done
            // after the GetNextItem() otherwise the hChildItem would be
            // bogus
            //
            HRESULT hr2 = m_pScope->DeleteItem(pObject->GetScopeHandle(), TRUE);
            delete pObject; 
        }
    }

    piPropertySheetProvider->Release();

    return TRUE;
}



HSCOPEITEM 
CComponentDataImpl::FindNextInstanceSibling(
    IN  HSCOPEITEM hParent,
    IN  CIISObject * pObject,
    OUT BOOL * pfNext
    )
/*++

Routine Descritpion:

    Find the 'next' or 'previous' instance sibling of the given object.
    That is, the instance we want to be inserted just in front of, or right
    after.

Arguments:

    HSCOPEITEM hParent      : Parent scope item
    CIISObject * pObject    : IISObject to be placed
    BOOL * pfNext           : Returns TRUE if sibling returned is Next, FALSE
                              if sibling is previous, undetermined if sibling
                              returned is NULL.

Return Value:

    The 'next' or 'previous' sibling item (scope item handle) that the
    pObject is to be inserted in front of, or right after (check *pfNext),
    or else NULL.

--*/
{
    //
    // Want to group by service type.  Find an appropriate
    // sibling.  Second key is instance ID.
    //
    MMC_COOKIE cookie;
    int nResult;
    HSCOPEITEM hItem;
    HSCOPEITEM hSibling = NULL;
    LPCTSTR lpSvcName = pObject->GetServiceName();
    DWORD dwID = pObject->QueryInstanceID();
    *pfNext = TRUE;

    TRACEEOLID("Service name: " << lpSvcName);
    TRACEEOLID("Instance ID#: " << dwID);

    BOOL fFoundSvc = FALSE;
    HRESULT hr = m_pScope->GetChildItem(hParent, &hItem, &cookie);

    while (hr == S_OK && hItem != NULL)
    {
        CIISObject * p = (CIISObject *)cookie;
        ASSERT(p != NULL);
        TRACEEOLID("Comparing against service: " << p->GetServiceName());
        nResult = lstrcmpi(lpSvcName, p->GetServiceName());

        if (nResult == 0)
        {
            //
            // Found same service type, now sort on instance ID
            //
            fFoundSvc = TRUE;
            hSibling = hItem;
            *pfNext = FALSE;

            DWORD dw = p->QueryInstanceID();
            TRACEEOLID("Comparing against instance ID#: " << dw);

            if (dwID <= dw)
            {
                *pfNext = TRUE;
                break;
            }
        }
        else if (nResult < 0)
        {
            //
            // Needs to be inserted before this one.
            //
            if (!fFoundSvc)
            {
                hSibling = hItem;
                *pfNext = TRUE;
            }

            break;
        }

        hr = m_pScope->GetNextItem(hItem, &hItem, &cookie);
    }

    return hSibling;
}



HSCOPEITEM
CComponentDataImpl::FindNextVDirSibling(
    IN HSCOPEITEM hParent,
    IN CIISObject * pObject
    )
/*++

Routine Descritpion:

    Find the 'next' virtual directory sibling of the given object.  That is,
    the vdir we want to be inserted just in front of.

Arguments:

    HSCOPEITEM hParent      : Parent scope item
    CIISObject * pObject    : IISObject to be placed

Return Value:

    The 'next' sibling item (scope item handle) that the pObject is to be
    inserted in front of, or else NULL

--*/
{
    //
    // Since VDIRs always are at the top of their list, the first
    // item with a different GUID is our 'next' sibling
    //
    HSCOPEITEM hItem;
    MMC_COOKIE cookie;
    GUID guid1 = pObject->QueryGUID();

    HRESULT hr = m_pScope->GetChildItem(hParent, &hItem, &cookie);

    while (hr == S_OK && hItem != NULL)
    {
        CIISObject * p = (CIISObject *)cookie;
        ASSERT(p != NULL);
        GUID guid2 = p->QueryGUID();

        if (guid1 != guid2)
        {
            //
            // Want to insert before this one
            //
            return hItem;
        }

        hr = m_pScope->GetNextItem(hItem, &hItem, &cookie);
    }

    //
    // Nothing found
    //
    return NULL;
}



HSCOPEITEM
CComponentDataImpl::FindServerInfoParent(
    IN HSCOPEITEM hParent,
    IN CServerInfo * pServerInfo
    )
/*++

Routine Description:

    Find server info parent object for this object.  The server info
    parent depends on the type of view, and can be a machine node,
    or a service collector node.

Arguments:

    HSCOPEITEM hParent          : Parent scope
    CServerInfo * pServerInfo

Return Value:

    The scope item handle of the appropriate parent object, or
    NULL if not found.

--*/
{
    ASSERT(m_pScope != NULL);

    //
    // Notes: The server info object parent is always a machine
    // node.  Find the one that maches the computer name.
    //
    HSCOPEITEM hItem;
    MMC_COOKIE cookie;

    HRESULT hr = m_pScope->GetChildItem(hParent, &hItem, &cookie);
    while (hr == S_OK && hItem != NULL)
    {
        CIISObject * pObject = (CIISObject *)cookie;

        //
        // Skip objects that we don't own
        //
        if (pObject != NULL)
        {
            ASSERT(pObject->QueryGUID() == cMachineNode);

            //
            // Compare computer names
            //
            CIISMachine * pMachine = (CIISMachine *)pObject;

            if (::lstrcmpi(pServerInfo->QueryServerName(),
                pMachine->GetMachineName()) == 0)
            {
                //
                // Found the item
                //
                return hItem;
            }
        }

        //
        // Advance to next child of the same parent.
        //
        hr = m_pScope->GetNextItem(hItem, &hItem, &cookie);
    }

    //
    // Not found
    //
    return NULL;
}



HSCOPEITEM
CComponentDataImpl::ForceAddServerInfoParent(
    IN HSCOPEITEM hParent,
    IN CServerInfo * pServerInfo
    )
/*++

Routine Description:

    Add a serverinfo object to the scope view

Arguments:

    HSCOPEITEM hParent          : Handle to parent scope item
    CServerInfo * pServerInfo   : Server info object

Return Value:

    Handle to the scope item of the newly inserted object

--*/
{
    //
    // Server info parents are always machine nodes now.
    //
   CIISMachine * pMachine = new CIISMachine(pServerInfo->QueryServerName());
   pMachine->m_fIsExtension = m_fIsExtension;
   return AddIISObject(hParent, pMachine);
}



HSCOPEITEM
CComponentDataImpl::AddServerInfoParent(
    IN HSCOPEITEM hRootNode,
    IN CServerInfo * pServerInfo
    )
/*++

Routine Description:

    Add server info parent object appropriate for the given object.  Look
    to see if one exists, otherwise add one.  Return the handle to the
    parent object.

Arguments:

    HSCOPEITEM hRootNode            : Root of the scope view
    CServerInfo * pServerInfo       : Server info object, whose parent we add

Return Value:

    Scope view handle to a suitable server info parent object

--*/
{
    HSCOPEITEM hParent = FindServerInfoParent(hRootNode, pServerInfo);

    if (hParent == NULL)
    {
        //
        // Parent doesn't exist, add it
        //
        hParent = ForceAddServerInfoParent(hRootNode, pServerInfo);
    }

    return hParent;
}



HSCOPEITEM
CComponentDataImpl::AddServerInfo(
    IN HSCOPEITEM hRootNode,
    IN CServerInfo * pServerInfo,
    IN BOOL fAddParent
    )
/*++

Routine Description:

    Add a serverinfo object to the scope view.  Find suitable parent object,
    and attach to it.

Arguments:

    HSCOPEITEM hRootNode                : Parent scope item handle
    CServerInfo * pServerInfo           : Server info object to be added.
    BOOL fAddParent                     : TRUE to add parent item, FALSE to add to
                                          the given parent scope item

Return Value:

    Handle to the newly added object.

--*/
{
    HSCOPEITEM hItem = NULL;
    HSCOPEITEM hParent = fAddParent
        ? AddServerInfoParent(hRootNode, pServerInfo)
        : hRootNode;

    CError err;

    ASSERT(hParent != NULL);

    try
    {
        //
        // Add it underneath the parent
        //
        if (!pServerInfo->SupportsInstances())
        {
            //
            // No instance support for this service
            // type.  Add a single down-level instance
            //
            CIISInstance * pInstance = new CIISInstance(pServerInfo);
            BOOL fNext;
            HSCOPEITEM hSibling = FindNextInstanceSibling(
                hParent,
                pInstance,
                &fNext
                );

            hItem = AddIISObject(hParent, pInstance, hSibling, fNext);
        }
        else
        {
            //
            // Add all virtual hosts (instances) at the same level
            // as a single instance item.  Temporarily wrap this
            // in a down-level instance.
            //
            CIISInstance inst(pServerInfo);
            hItem = AddInstances(hParent, &inst);
        }
    }
    catch(CMemoryException * e)
    {
        hItem = NULL;
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    if (err.Failed())
    {
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        err.MessageBox();
    }

    return hItem;
}


//
// CODEWORK: Mess, should merge with AddFileSystem in results
//
HSCOPEITEM
CComponentDataImpl::AddFileSystem(
    IN HSCOPEITEM hParent,
    IN LPCTSTR lpstrRoot,
    IN LPCTSTR lpstrMetaRoot,
    IN CIISInstance * pInstance,
    IN BOOL fGetDirs,
    IN BOOL fDeleteCurrentFileSystem
    )
/*++

Routine Description:

    Add file system objects on the scope side

Arguments:

    HSCOPEITEM hParent              : Parent scope item
    LPCTSTR lpstrRoot               : Phsysical root path
    LPCTSTR lpstrMetaRoot           : Meta root path
    CIISInstance * pInstance        : Owner instance
    BOOL fGetDirs                   : TRUE to get directories, FALSE for files
    BOOL fDeleteCurrentFileSystem   : TRUE to remove the current file/dir tree first

Return Value:

    Handle to the last scope item added.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(hParent != NULL);

    CError     err;
    HSCOPEITEM hItem = NULL;
    DWORD      dwBufferSize = 0L;
    int        cChildren = 0;

    do
    {
        if (fDeleteCurrentFileSystem)
        {
            TRACEEOLID("Deleting current file enumeration");

            if (!KillChildren(
                hParent,
                IDS_PROP_OPEN_CONTINUE,
                DELETE_FILES_ONLY,
                CONTINUE_ON_OPEN_SHEET
                ))
            {
                //
                // Failed to remove the file system that was already enumerated
                // here.  An error message will already have been displayed, so
                // quit gracefully here.
                //
                break;
            }
        }

        LPCTSTR lpstrOwner = pInstance->GetMachineName();
        ASSERT(lpstrOwner);

        //
        // Turn the path into a UNC path
        //
        CString strDir;

        if (::IsServerLocal(lpstrOwner) || ::IsUNCName(lpstrRoot))
        {
            //
            // Local directory, or already a unc path
            //
            strDir = lpstrRoot;
        }
        else
        {
            ::MakeUNCPath(strDir, lpstrOwner, lpstrRoot);
        }

        strDir.TrimLeft();
        strDir.TrimRight();

        if (strDir.IsEmpty())
        {
            //
            // Invalid path
            //
            break;
        }

        strDir += _T("\\*");
        WIN32_FIND_DATA w32data;
        HANDLE hFind = ::FindFirstFile(strDir, &w32data);

        if (hFind == INVALID_HANDLE_VALUE)
        {
            err.GetLastWinError();
            break;
        }

        //
        // See if the parent has a redirect on it
        //
        CWaitCursor wait;
        CString strRedirect;
        CString strBase;
        pInstance->BuildFullPath(strBase, TRUE);
        LPCTSTR lpPath = lpstrMetaRoot;

        while (lpPath && *lpPath && *lpPath != _T('/')) ++lpPath;

        if (lpPath && *lpPath)
        {
            strBase += lpPath;
        }

        TRACEEOLID("Opening: " << strBase);
        TRACEEOLID(lpstrMetaRoot);

        BOOL fCheckMetabase = TRUE;
        CMetaKey mk(
            lpstrOwner, 
            METADATA_PERMISSION_READ, 
            METADATA_MASTER_ROOT_HANDLE,
            strBase
            );
        CError errMB(mk.QueryResult());

        if (errMB.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Metabase path not found, not a problem.
            //
            TRACEEOLID("Parent node not in metabase");
            fCheckMetabase = FALSE;
            errMB.Reset();
        }
        else if (!errMB.MessageBoxOnFailure())
        {
            //
            // Opened successfully, read redirect string.
            //
            DWORD dwAttr;

            errMB = mk.QueryValue(
                MD_HTTP_REDIRECT, 
                strRedirect,
                NULL,                  // Inheritance override
                NULL,                  // Path
                &dwAttr
                );

            if (errMB.Succeeded())
            {
                if (IS_FLAG_SET(dwAttr, METADATA_INHERIT))
                {
                    int nComma = strRedirect.Find(_T(','));

                    if (nComma >= 0)
                    {
                        strRedirect.ReleaseBuffer(nComma);
                    }
                }
                else
                {
                    //
                    // Yes, there's a redirect on the parent, but it's
                    // not marked as inheritable, so it won't affect
                    // the children.
                    //
                    strRedirect.Empty();
                }
            }
        }

        //
        // Loop through the file system
        //
        do
        {
            //
            // Check to see if this is a file or directory/
            // Ignore anything starting with a dot.
            //
            TRACEEOLID(w32data.cFileName);
            BOOL fIsDir = ((w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);

            if (fIsDir == fGetDirs && *w32data.cFileName != _T('.'))
            {
                CIISFileNode * pNode = new CIISFileNode(
                    w32data.cFileName,
                    w32data.dwFileAttributes,
                    pInstance,
                    strRedirect,
                    fIsDir
                    );

                if (pNode == NULL)
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                if (fCheckMetabase)
                {
                    errMB = mk.DoesPathExist(w32data.cFileName);

                    ASSERT(errMB.Succeeded() 
                        || errMB.Win32Error() == ERROR_PATH_NOT_FOUND);

                    if (errMB.Succeeded())
                    {
                        //
                        // Match up with metabase properties.  If the item
                        // is found in the metabase with a non-inherited vrpath,
                        // than a virtual root with this name exists, and this 
                        // file/directory should not be shown.
                        //
                        BOOL fVirtualDirectory;
                        CString strMetaRoot(lpstrMetaRoot);

                        if (pNode->FetchMetaInformation(
                            strMetaRoot, 
                            &fVirtualDirectory
                            ) == ERROR_SUCCESS  && fVirtualDirectory)
                        {
                            TRACEEOLID(
                                "file/directory exists as vroot -- tossing" 
                                << w32data.cFileName
                                );
                            delete pNode;

                            continue;
                        }
                    }
                }

                //
                // Always added on at the end
                //
                hItem = AddIISObject(hParent, pNode);
            }
        }
        while(err.Succeeded() && FindNextFile(hFind, &w32data));

        ::FindClose(hFind);
    }
    while(FALSE);

    if (err.Failed())
    {
        //
        // Don't display file system errors -- leave those to result side
        // enumeration.
        //
        TRACEEOLID("Ate error message: " << err);
    }

    return hItem;
}



HSCOPEITEM
CComponentDataImpl::AddVirtualRoots(
    IN HSCOPEITEM hParent,
    IN LPCTSTR lpstrParentPath,
    IN CIISInstance * pInstance
    )
/*++

Routine Description:

    Add virtual roots to the scope view

Arguments:

    HSCOPEITEM hParent          : Handle to parent scope item
    LPCTSTR lpstrParentPath     : Parent metabase path
    CIISInstance * pInstance    : Owner instance

Return Value:

    Handle to the newly added scope item

--*/
{
    ASSERT(hParent != NULL);
    CServerInfo * pServerInfo = pInstance->GetServerInfo();
    ASSERT(pServerInfo != NULL);

    ISMCHILDINFO ii;
    HSCOPEITEM hItem = NULL;
    DWORD dwIndex = 0L;
    CError err;

    ZeroMemory(&ii, sizeof(ii));
    ii.dwSize = sizeof(ii);
    HANDLE hEnum = NULL;

    FOREVER
    {
        DWORD dwID = pInstance->QueryID();
        err = pServerInfo->ISMEnumerateChildren(
            &ii,
            &hEnum,
            dwID,
            lpstrParentPath
            );

        if (err.Failed())
        {
            break;
        }

        TRACEEOLID("Alias: " << ii.szAlias);
        TRACEEOLID("Path : " << ii.szPath);
        TRACEEOLID("Redir: " << ii.szRedirPath);

        if (*ii.szPath)
        {
            CIISChildNode * pChild = new CIISChildNode(&ii, pInstance);
            if (pChild == NULL)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            // Always added on at the end
            //
            hItem = AddIISObject(hParent, pChild);
        }
        else
        {
            TRACEEOLID("Tossing child without vrpath");
        }
    }

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        //
        // This is the normal way to end this
        //
        err.Reset();
    }

    if (err.Failed())
    {
        //
        // Display error
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        err.MessageBoxFormat(
            IDS_ERR_ENUMERATE_CHILD,
            MB_OK,
            NO_HELP_CONTEXT,
            (LPCTSTR)pServerInfo->GetServiceInfo()->GetShortName()
            );
    }

    return hItem;
}



HSCOPEITEM
CComponentDataImpl::AddInstances(
    IN HSCOPEITEM hParent,
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Add instances to the treeview

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle
    CIISObject * pObject    : Owning object

Return Value:

    Handle to the last instance added

--*/
{
    ASSERT(hParent != NULL);
    CServerInfo * pServerInfo = pObject->GetServerInfo();
    ASSERT(pServerInfo != NULL);

    ISMINSTANCEINFO ii;
    HSCOPEITEM hItem = NULL;
    DWORD dwIndex = 0L;
    CError err;

    ZeroMemory(&ii, sizeof(ii));
    ii.dwSize = sizeof(ii);
    HANDLE hEnum = NULL;

    HSCOPEITEM hSibling = NULL;

    FOREVER
    {
        //
        // Loop through...
        //
        err = pServerInfo->ISMEnumerateInstances(&ii, &hEnum);

        if (err.Failed())
        {
            break;
        }

        if (ii.dwError == ERROR_ACCESS_DENIED)
        {
            //
            // No point in listing this one
            //
            continue;
        }

        CIISInstance * pInstance = new CIISInstance(&ii, pServerInfo);
        if (pInstance == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Add grouped by service type
        //
        BOOL fNext;

        if (hSibling == NULL)
        {
            hSibling = FindNextInstanceSibling(
                hParent,
                pInstance,
                &fNext
                );
        }
        else
        {
            //
            // Keep appending
            //
            fNext = FALSE;
        }

        hSibling = hItem = AddIISObject(
            hParent,
            pInstance,
            hSibling,
            fNext
            );
    }
    
    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        //
        // This is the normal way to end this
        //
        err.Reset();
    }

    if (err.Failed())
    {
        //
        // Display error message
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        switch(err.Win32Error())
        {
        //
        // Non-fatal errors
        //
        case ERROR_PATH_NOT_FOUND:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_FILE_NOT_FOUND:
            ::AfxMessageBox(IDS_NON_FATAL_ERROR_INSTANCES);
            err.Reset();
            break;
        
        default:
            err.MessageBoxFormat(
                IDS_ERR_ENUMERATE_INST,
                MB_OK,
                NO_HELP_CONTEXT,
                (LPCTSTR)pServerInfo->GetServiceInfo()->GetShortName()
                );
        }
    }

    return hItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\guids.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guids.cpp

   Abstract:

        GUIDs as used by IIS snapin

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

//
// Internal private clipboard format
//
const wchar_t * ISM_SNAPIN_INTERNAL = L"ISM_SNAPIN_INTERNAL";

//
// Published formats
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const wchar_t * MYCOMPUT_MACHINE_NAME   = L"MMC_SNAPIN_MACHINE_NAME"; 
const wchar_t * ISM_SNAPIN_MACHINE_NAME = L"ISM_SNAPIN_MACHINE_NAME"; 
const wchar_t * ISM_SNAPIN_SERVICE =      L"ISM_SNAPIN_SERVICE";
const wchar_t * ISM_SNAPIN_INSTANCE =     L"ISM_SNAPIN_INSTANCE";
const wchar_t * ISM_SNAPIN_PARENT_PATH =  L"ISM_SNAPIN_PARENT_PATH";
const wchar_t * ISM_SNAPIN_NODE =         L"ISM_SNAPIN_NODE";
const wchar_t * ISM_SNAPIN_META_PATH =    L"ISM_SNAPIN_META_PATH";

//
// GUIDs
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Snapin GUID
//
// {A841B6C2-7577-11d0-BB1F-00A0C922E79C}
//
const CLSID CLSID_Snapin = {0xa841b6c2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// About GUID
//
// {A841B6D2-7577-11d0-BB1F-00A0C922E79C}
//
const CLSID CLSID_About =  {0xa841b6d2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// IIS Object GUIDS
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Internet Root Node GUID
//
const GUID cInternetRootNode = {0xa841b6c3, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Machine Node GUID
//
const GUID cMachineNode = {0xa841b6c4, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Service Collector Node GUID
//
const GUID cServiceCollectorNode = {0xa841b6c5, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Instance Collector Node GUID
//
const GUID cInstanceCollectorNode = {0xa841b6c6, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Instance Node GUID
//
const GUID cInstanceNode = {0xa841b6c7, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Child Node GUID
//
const GUID cChildNode = {0xa841b6c8, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// File Node GUID
//
const GUID cFileNode = {0xa841b6c9, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};


#include <initguid.h>
#include "iwamreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\inetmgr.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        inetmgr.cpp

   Abstract:

        Main program object

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Functions Exported:

   Revision History:

--*/

//
// Include files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "constr.h"

#include <dos.h>
#include <direct.h>


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Default HTML help topics file name
//
#define DEFAULT_HTML    _T("htmldocs\\inetdocs.htm")


LPOLESTR 
CoTaskDupString(
    IN LPCOLESTR szString
    )
/*++

Routine Description:

    Helper function to duplicate a OLESTR

Arguments:

    LPOLESTR szString       : Source string

Return Value:

    Pointer to the new string or NULL

--*/
{
    OLECHAR * lpString = (OLECHAR *)CoTaskMemAlloc(
        sizeof(OLECHAR)*(lstrlen(szString) + 1)
        );

    if (lpString != NULL)
    {
        lstrcpy(lpString, szString);
    }

    return lpString;
}



HRESULT 
BuildResURL(
    OUT CString & str, 
    IN  HINSTANCE hSourceInstance
    )
/*++

Routine Description:

    Helper function to generate "res://" type string

Arguments:

    CString & str               : Returns res:// string
    HINSTANCE hSourceInstance   : Source instance,
                                : or -1 for current module
                                : or NULL for calling app (MMC)

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;

    TCHAR atchModuleFileName[MAX_PATH + 1];
    int cch = ::GetModuleFileName(
        (hSourceInstance == (HINSTANCE) - 1) 
            ? ::AfxGetInstanceHandle() 
            : hSourceInstance,
        atchModuleFileName,
        sizeof(atchModuleFileName) / sizeof(OLECHAR)
        );

    if (!cch)
    {
        err.GetLastWinError();
        ASSERT(FALSE);

        return err;
    }

    str = _T("res://");
    str += atchModuleFileName;

    return err;
}



//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



LPCTSTR CServiceInfo::s_cszSupcfg = _T("::SUPCFG:");

//
// ISM Method VTable Definition
//
CServiceInfo::ISM_METHOD_DEF CServiceInfo::s_imdMethods[ISM_NUM_METHODS] =
{
//-----------ID----------------Must Have?--------------Method Name------------
    ISM_QUERY_SERVICE_INFO,     TRUE,           SZ_SERVICEINFO_PROC,
    ISM_DISCOVER_SERVERS,       FALSE,          SZ_DISCOVERY_PROC,      
    ISM_QUERY_SERVER_INFO,      TRUE,           SZ_SERVERINFO_PROC,
    ISM_CHANGE_SERVICE_STATE,   FALSE,          SZ_CHANGESTATE_PROC,
    ISM_CONFIGURE,              TRUE,           SZ_CONFIGURE_PROC,
    ISM_BIND,                   FALSE,          SZ_BIND_PROC,
    ISM_UNBIND,                 FALSE,          SZ_UNBIND_PROC,
    ISM_CONFIGURE_CHILD,        FALSE,          SZ_CONFIGURE_CHILD_PROC,
    ISM_ENUMERATE_INSTANCES,    FALSE,          SZ_ENUMERATE_INSTANCES_PROC,
    ISM_ENUMERATE_CHILDREN,     FALSE,          SZ_ENUMERATE_CHILDREN_PROC,
    ISM_ADD_INSTANCE,           FALSE,          SZ_ADD_INSTANCE_PROC,
    ISM_DELETE_INSTANCE,        FALSE,          SZ_DELETE_INSTANCE_PROC,
    ISM_ADD_CHILD,              FALSE,          SZ_ADD_CHILD_PROC,
    ISM_DELETE_CHILD,           FALSE,          SZ_DELETE_CHILD_PROC,
    ISM_RENAME_CHILD,           FALSE,          SZ_RENAME_CHILD_PROC,
    ISM_QUERY_INSTANCE_INFO,    FALSE,          SZ_QUERY_INSTANCE_INFO_PROC,
    ISM_QUERY_CHILD_INFO,       FALSE,          SZ_QUERY_CHILD_INFO_PROC,
    ISM_MMC_CONFIGURE,          FALSE,          SZ_MMC_CONFIGURE_PROC,
    ISM_MMC_CONFIGURE_CHILD,    FALSE,          SZ_MMC_CONFIGURE_CHILD_PROC,
    ISM_SECURITY_WIZARD,        FALSE,          SZ_SECURITY_WIZARD_PROC 
};



CServiceInfo::CServiceInfo(
    IN int nID,
    IN LPCTSTR lpDLLName
    )
/*++

Routine Description:

    Constructor for service info object.  Load the specified config DLL,
    and initialise the entry points.
                                                                       
Arguments:

    int nID           : The guaranteed unique ID assigned to this service
    LPCTSTR lpDLLName : The config DLL name to be loaded

Return Value:

    N/A

--*/
    : CObjectPlus(),
      m_hModule(NULL),
      m_psiMaster(NULL),
      m_strDLLName(lpDLLName),
      m_strSupDLLName(),

#ifndef USE_VTABLE

      m_pfnQueryServiceInfo(NULL),
      m_pfnDiscoverServers(NULL),
      m_pfnQueryServerInfo(NULL),
      m_pfnChangeServiceState(NULL),
      m_pfnConfigure(NULL),
      m_pfnConfigureChild(NULL), 
      m_pfnEnumerateInstances(NULL),
      m_pfnEnumerateChildren(NULL),
      m_pfnAddInstance(NULL),
      m_pfnDeleteInstance(NULL),
      m_pfnAddChild(NULL),
      m_pfnDeleteChild(NULL),
      m_pfnRenameChild(NULL),
      m_pfnQueryInstanceInfo(NULL),
      m_pfnQueryChildInfo(NULL),
      m_pfnISMMMCConfigureServers(NULL),
      m_pfnISMMMCConfigureChild(NULL),
      m_pfnISMSecurityWizard(NULL),

#endif // USE_VTABLE

      m_nID(nID),
      m_iBmpID(-1),
      m_iBmpChildID(-1)
{

#ifdef USE_VTABLE

    //
    // Initialize VTable
    //
    ZeroMemory(&m_rgpfnISMMethods, sizeof(m_rgpfnISMMethods));

#endif // USE_VTABLE

    //
    // Check for parameter options.
    //
    TRACEEOLID("Raw DLL name: " << m_strDLLName);

    //
    // Load super DLL
    //
    int nOpt = m_strDLLName.Find(s_cszSupcfg);
    if (nOpt >= 0)
    {
        m_strSupDLLName = m_strDLLName.Mid(nOpt + lstrlen(s_cszSupcfg));
        m_strDLLName.ReleaseBuffer(nOpt);

        TRACEEOLID("Superceed DLL: " << m_strSupDLLName);
    }
    
    TRACEEOLID("Attempting to load " << m_strDLLName);

    CError err;

    BOOL fMissingMethod = FALSE;
    m_hModule = ::AfxLoadLibrary(m_strDLLName);
    if (m_hModule == NULL)
    {
        err.GetLastWinError();

        if (err.Succeeded())
        {
            //
            // This shouldn't happen, but it sometimes does.
            // AfxLoadLibrary resets the last error somewhere???
            //
            TRACEEOLID("Error!!! Library not loaded, but last error returned 0");
            err = ERROR_DLL_NOT_FOUND;
        }

        TRACEEOLID("Failed to load " 
            << m_strDLLName
            << " GetLastError() returns " 
            << err
            );
    }
    else
    {
        TRACEEOLID(m_strDLLName << " LoadLibrary succeeded");

#ifdef USE_VTABLE

        //
        // Initialize VTable
        //
        for (int i = 0; i < ISM_NUM_METHODS; ++i)
        {
            m_rgpfnISMMethods[CServiceInfo::s_imdMethods[i].iID] = 
                (pfnISMMethod)GetProcAddress(
                    m_hModule, 
                    CServiceInfo::s_imdMethods[i].lpszMethodName
                    );

            if (CServiceInfo::s_imdMethods[i].fMustHave 
                && !m_rgpfnISMMethods[CServiceInfo::s_imdMethods[i].iID])
            {
                fMissingMethod = TRUE;
            }
        }

#else

        //
        // Initialise function pointers (not all need be
        // present)
        //
        m_pfnQueryServiceInfo = (pfnQueryServiceInfo)
            ::GetProcAddress(m_hModule, SZ_SERVICEINFO_PROC);
        m_pfnDiscoverServers = (pfnDiscoverServers)
            ::GetProcAddress(m_hModule, SZ_DISCOVERY_PROC);
        m_pfnQueryServerInfo = (pfnQueryServerInfo)
            ::GetProcAddress(m_hModule, SZ_SERVERINFO_PROC);
        m_pfnChangeServiceState = (pfnChangeServiceState)
            ::GetProcAddress(m_hModule, SZ_CHANGESTATE_PROC);
        m_pfnConfigure = (pfnConfigure)
            ::GetProcAddress(m_hModule, SZ_CONFIGURE_PROC);
        m_pfnBind = (pfnBind)
            ::GetProcAddress(m_hModule, SZ_BIND_PROC);
        m_pfnUnbind = (pfnUnbind)
            ::GetProcAddress(m_hModule, SZ_UNBIND_PROC);
        m_pfnConfigureChild = (pfnConfigureChild)
            ::GetProcAddress(m_hModule, SZ_CONFIGURE_CHILD_PROC);
        m_pfnEnumerateInstances = (pfnEnumerateInstances)
            ::GetProcAddress(m_hModule,  SZ_ENUMERATE_INSTANCES_PROC);
        m_pfnEnumerateChildren = (pfnEnumerateChildren)
            ::GetProcAddress(m_hModule, SZ_ENUMERATE_CHILDREN_PROC);
        m_pfnAddInstance = (pfnAddInstance)
            ::GetProcAddress(m_hModule, SZ_ADD_INSTANCE_PROC);
        m_pfnDeleteInstance  = (pfnDeleteInstance)
            ::GetProcAddress(m_hModule, SZ_DELETE_INSTANCE_PROC);
        m_pfnAddChild = (pfnAddChild)
            ::GetProcAddress(m_hModule, SZ_ADD_CHILD_PROC);
        m_pfnDeleteChild = (pfnDeleteChild)
            ::GetProcAddress(m_hModule, SZ_DELETE_CHILD_PROC);
        m_pfnRenameChild = (pfnRenameChild)
            ::GetProcAddress(m_hModule, SZ_RENAME_CHILD_PROC);
        m_pfnQueryInstanceInfo = (pfnQueryInstanceInfo)
            ::GetProcAddress(m_hModule, SZ_QUERY_INSTANCE_INFO_PROC);
        m_pfnQueryChildInfo = (pfnQueryChildInfo)
            ::GetProcAddress(m_hModule, SZ_QUERY_CHILD_INFO_PROC);
        m_pfnISMMMCConfigureServers = (pfnISMMMCConfigureServers)
            ::GetProcAddress(m_hModule, SZ_MMC_CONFIGURE_PROC);
        m_pfnISMMMCConfigureChild = (pfnISMMMCConfigureChild)
            ::GetProcAddress(m_hModule, SZ_MMC_CONFIGURE_CHILD_PROC);
        m_pfnISMSecurityWizard = (pfnISMSecurityWizard)
            ::GetProcAddress(m_hModule, SZ_SECURITY_WIZARD_PROC);

        fMissingMethod = m_pfnQueryServiceInfo == NULL
            || m_pfnQueryServerInfo    == NULL
            || m_pfnChangeServiceState == NULL
            || m_pfnConfigure          == NULL;

#endif // USE_VTABLE

        ::ZeroMemory(&m_si, sizeof(m_si));
        m_si.dwSize = sizeof(m_si);

        err = ISMQueryServiceInfo(&m_si);
    }

    if (err.Failed())
    {
        //
        // Fill in the short and long names
        // with default values.
        //
        CString strMenu, strToolTips, str;
        VERIFY(strMenu.LoadString(IDS_DEFAULT_SHORTNAME));
        VERIFY(strToolTips.LoadString(IDS_DEFAULT_LONGNAME));

        //
        // Since the structure was zero-filled to
        // begin with, lstrcpyn is ok, because
        // we will always have the terminating NULL
        //
        str.Format(strMenu, (LPCTSTR)lpDLLName);

        ::lstrcpyn(
            m_si.atchShortName, 
            (LPCTSTR)str, 
            sizeof((m_si.atchShortName) - 1) / sizeof(m_si.atchShortName[0])
            );

        str.Format(strToolTips, (LPCTSTR)lpDLLName);
        ::lstrcpyn(
            m_si.atchLongName, 
            (LPCTSTR)str, 
            sizeof((m_si.atchLongName) - 1) / sizeof(m_si.atchLongName[0])
            );
    }

    BOOL fInitOK = m_hModule != NULL
        && !fMissingMethod
        && err.Succeeded();

    //
    // The service is selected at startup
    // time if it loaded succesfully
    //
    m_fIsSelected = fInitOK;

    TRACEEOLID("Success = " << fInitOK);

    m_hrReturnCode = err;
}



CServiceInfo::~CServiceInfo()
/*++

Routine Description:

    Destruct the object by unloading the config DLL
                                                                       
Arguments:

    N/A

Return Value:

    N/A

--*/
{
    TRACEEOLID("Cleaning up service info");

    if (m_hModule != NULL)
    {
        TRACEEOLID("Unloading library");
        VERIFY(::AfxFreeLibrary(m_hModule));
    }
}



//
// ISM Api Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<




#ifdef USE_VTABLE



DWORD
CServiceInfo::ISMQueryServiceInfo(
    OUT ISMSERVICEINFO * psi
    )
/*++

Routine Description:

    Return service-specific information back to
    to the application.  This function is called
    by the service manager immediately after
    LoadLibary();
                                                                       
Arguments:

    ISMSERVICEINFO * psi : Service information returned.

Return Value:

    Error return code

--*/
{
    if (ISM_NO_VTABLE_ENTRY(ISM_QUERY_SERVICE_INFO))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    DWORD err = ISM_VTABLE(ISM_QUERY_SERVICE_INFO)(psi);

    if (RequiresSuperDll() && err == ERROR_SUCCESS)
    {
        //
        // This service is superceded.  Add "downlevel" to 
        // service name, if there's room.
        //
        CString strDL;
        VERIFY(strDL.LoadString(IDS_DOWNLEVEL));

        if (lstrlen(psi->atchShortName) + strDL.GetLength() < MAX_SNLEN)
        {
            lstrcat(psi->atchShortName, (LPCTSTR)strDL);
        }
    }

    return err;
}



DWORD
CServiceInfo::ISMQueryServerInfo(
    IN  LPCTSTR lpszServerName,    
    OUT ISMSERVERINFO * psi         
    )
/*++

Routine Description:

    Get information on a single server with regards to
    this service.
                                                                       
Arguments:

    LPCTSTR lpszServerName : Name of server.
    ISMSERVERINFO * psi     : Server information returned.
   
Return Value:

    Error return code

--*/
{
    DWORD err;

    if (HasSuperDll())
    {
        //
        // This config DLL is superceded by another one.  If _that_ service
        // is installed, then assume this one is not.
        //
        err = GetSuperDll()->ISMQueryServerInfo(lpszServerName, psi);
        if (err == ERROR_SUCCESS)
        {
            //
            // The superceding service is installed.  That means this
            // service is not.
            //
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }
    }

    if (ISM_NO_VTABLE_ENTRY(ISM_QUERY_SERVER_INFO))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    return ISM_VTABLE(ISM_QUERY_SERVER_INFO)(
            lpszServerName, 
            psi
            );
}


#else !USE_VTABLE

//
// CODEWORK: Most of these method below could be inlined
//



DWORD
CServiceInfo::ISMQueryServiceInfo(
    OUT ISMSERVICEINFO * psi
    )
/*++

Routine Description:

    Return service-specific information back to
    to the application.  This function is called
    by the service manager immediately after
    LoadLibary();
                                                                       
Arguments:

    ISMSERVICEINFO * psi : Service information returned.

Return Value:

    Error return code

--*/
{
    if (m_pfnQueryServiceInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    DWORD err = (*m_pfnQueryServiceInfo)(psi);

    if (RequiresSuperDll() && err == ERROR_SUCCESS)
    {
        //
        // This service is superceded.  Add "downlevel" to 
        // service name, if there's room.
        //
        CString strDL;
        VERIFY(strDL.LoadString(IDS_DOWNLEVEL));

        if (lstrlen(psi->atchShortName) + strDL.GetLength() < MAX_SNLEN)
        {
            lstrcat(psi->atchShortName, (LPCTSTR)strDL);
        }
    }

    return err;
}




DWORD
CServiceInfo::ISMQueryServerInfo(
    IN  LPCTSTR lpszServerName,     // Name of server.
    OUT ISMSERVERINFO * psi         // Server information returned.
    )
/*++

Routine Description:

    Get information on a single server with regards to
    this service.
                                                                       
Arguments:

    LPCTSTR lpszServerName : Name of server.
    ISMSERVERINFO * psi     : Server information returned.
   
Return Value:

    Error return code

--*/
{
    DWORD err;

    if (HasSuperDll())
    {
        //
        // This config DLL is superceded by another one.  If _that_ service
        // is installed, then assume this one is not.
        //
        err = GetSuperDll()->ISMQueryServerInfo(lpszServerName, psi);
        if (err == ERROR_SUCCESS)
        {
            //
            // The superceding service is installed.  That means this
            // service is not.
            //
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }
    }

    if (m_pfnQueryServerInfo != NULL)
    {
        return (*m_pfnQueryServerInfo)(lpszServerName, psi);
    }

    return ERROR_CAN_NOT_COMPLETE;
}



#endif // USE_VTABLE


//
// New Instance Command Class
// 
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CNewInstanceCmd::CNewInstanceCmd(
    IN CServiceInfo * pServiceInfo
    )
/*++

Routine Description:

    New instance command constructor.  Build a menu command
    for the create new submenu.

Arguments:

    CServiceInfo * pServiceInfo     : Service info object

Return Value:

    N/A

--*/
    : m_pServiceInfo(pServiceInfo)
{
    ASSERT(m_pServiceInfo != NULL);

    try
    {
        CString str;
        VERIFY(str.LoadString(IDS_MENU_EX_NEWINSTANCE));
        m_strMenuCommand.Format(str, m_pServiceInfo->GetShortName());
        VERIFY(str.LoadString(IDS_MENU_TT_EX_NEWINSTANCE));
        m_strTTText.Format(str, m_pServiceInfo->GetShortName());
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}



/* static */ 
CServiceInfo *
CServerInfo::FindServiceByMask(
    IN ULONGLONG ullTarget,
    IN CObListPlus & oblServices
    )
/*++

Routine Description:

    Given the inetsloc mask, return the service this
    fits.  Return NULL if the service was not found.
                                                                       
Arguments:

    ULONGLONG ullTarget        : The mask to look for
    CObListPlus & oblServices  : List of service objects in which to look
   
Return Value:

    Pointer to service object that uses this mask, or NULL if the 
    service isn't found

--*/
{
    CObListIter obli(oblServices);
    CServiceInfo * psi;

    //
    // Straight sequential search
    //
    TRACEEOLID("Looking for service with mask " << (DWORD)ullTarget);
    while (psi = (CServiceInfo *)obli.Next())
    {
        if (psi->InitializedOK()
         && psi->UseInetSlocDiscover()
         && psi->QueryDiscoveryMask() == ullTarget
           )
        {
            TRACEEOLID("Found it: " << psi->GetShortName());
            return psi;
        }
    }

    //
    // Didn't find it..
    //
    TRACEEOLID("Error: mask not matched up with any known service");

    return NULL;
}



/* static */ 
LPCTSTR
CServerInfo::CleanServerName(
    IN OUT CString & str
    )
/*++

Routine Description:

   Utility function to clean up a computer/hostname
                                                                       
Arguments:

    CString & str  : Server name to be cleaned up
   
Return Value:

    Pointer to the string

--*/
{
#ifdef ENFORCE_NETBIOS
    //
    // Clean up name, and enforce leading slashes
    //
    str.MakeUpper();

    try
    {
        if (!IS_NETBIOS_NAME(str))
        {
            str = _T("\\\\") + str;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception cleaning up server name");
        e->ReportError();
        e->Delete();
    }

#else
    //
    // If the name is NETBIOS, convert to upper case.  Otherwise
    // the name is assumed to be a hostname, and should be
    // converted to lower case.
    //
    if (IS_NETBIOS_NAME(str))
    {
        str.MakeUpper();
    }
    else
    {
        str.MakeLower();
    }

#endif // ENFORCE_NETBIOS

    return str;
}



CServerInfo::CServerInfo(
    IN LPCTSTR lpszServerName,     
    IN ISMSERVERINFO * psi,         
    IN CServiceInfo * pServiceInfo  
    )
/*++

Routine Description:

    Construct with a server name.  This is typically
    in response to a single connection attempt
                                                                       
Arguments:

    LPCTSTR lpszServerName     : Name of this server
    ISMSERVERINFO * psi         : Server info
    CServiceInfo * pServiceInfo : service that found it.
   
Return Value:

    N/A

--*/
    : m_strServerName(lpszServerName),
      m_strComment( psi->atchComment),
      m_nServiceState(psi->nState),
      m_hServer(NULL),
      m_pService(pServiceInfo)
{
    CServerInfo::CleanServerName(m_strServerName);

    if (m_pService != NULL)
    {
        //
        // Bind here
        //
        if (m_pService->IsK2Service())
        {
            ASSERT(m_hServer == NULL);
            HRESULT hr = m_pService->ISMBind(
                m_strServerName,
                &m_hServer
                );
        }
    }
    else
    {
        TRACEEOLID("Did not match up server with installed service");
    }
}



CServerInfo::CServerInfo(
    IN LPCSTR lpszServerName,        
    IN LPINET_SERVICE_INFO lpisi,   
    IN CObListPlus & oblServices   
    )
/*++

Routine Description:

    Construct with information from the inetsloc discover
    process.  Construction of the CString will automatically
    perform the ANSI/Unicode conversion,
                                                                       
Arguments:

    LPCSTR lpszServerName     : Name of this server (no "\\")
    LPINET_SERVICE_INFO lpisi  : Discovery information
    CObListPlus & oblServices  : List of installed services
   
Return Value:

    N/A

--*/
    : m_strServerName(lpszServerName),
      m_strComment(lpisi->ServiceComment),
      m_nServiceState(lpisi->ServiceState),
      m_hServer(NULL),
      m_pService(NULL)
{
    CServerInfo::CleanServerName(m_strServerName);

    m_pService = FindServiceByMask(lpisi->ServiceMask, oblServices);

    if (m_pService != NULL)
    {
        if (m_pService->IsK2Service())
        {
            ASSERT(m_hServer == NULL);
            HRESULT hr = m_pService->ISMBind(
                m_strServerName,
                &m_hServer
                );
        }
    }
    else
    {
        TRACEEOLID("Did not match up server with installed service");
    }
}



HRESULT 
CServerInfo::ISMRebind()
/*++

Routine Description:

    Handle lost connection.  Attempt to rebind.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (m_pService != NULL)
    {
        if (m_pService->IsK2Service())
        {
            //
            // Must be previously bound
            //
            ASSERT(m_hServer != NULL);

            //
            // This may cause a first chance exception, because
            // the handle could be invalid at this stage
            //
            hr = m_pService->ISMUnbind(m_hServer);

            hr = m_pService->ISMBind(
                m_strServerName,
                &m_hServer
                );
        }
    }

    return hr;
}


CServerInfo::CServerInfo(
    IN const CServerInfo & si
    )
/*++

Routine Description:

    Copy Constructor
                                                                       
Arguments:

    const CServerInfo & si : Source server info object
   
Return Value:

    N/A

--*/
    : m_strServerName(si.m_strServerName),
      m_strComment(si.m_strComment),
      m_nServiceState(si.m_nServiceState),
      m_hServer(NULL),
      m_pService(si.m_pService)
{
    //
    // Bind again here
    //
    if (m_pService->IsK2Service())
    {
        ASSERT(m_hServer == NULL);
        HRESULT hr = m_pService->ISMBind(
            m_strServerName,
            &m_hServer
            );
    }
}



CServerInfo::~CServerInfo()
/*++

Routine Description:

    Destruct the object.  Do not free in the pointer
    to the service, because we don't own it.
                                                                       
Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Unbind here
    //
    if (m_pService->IsK2Service())
    {
        m_pService->ISMUnbind(m_hServer);
    }
}



const CServerInfo &
CServerInfo::operator=(
    IN const CServerInfo & si
    )
/*++

Routine Description:

    Assignment operator
                                                                       
Arguments:

    const CServerInfo & si : Source server info object
   
Return Value:

    Reference to this object

--*/
{
    m_strServerName = si.m_strServerName;
    m_nServiceState = si.m_nServiceState;
    m_strComment = si.m_strComment;
    m_pService = si.m_pService;

    //
    // Need to rebind
    //
    if (m_pService->IsK2Service())
    {
        ASSERT(m_hServer == NULL);
        HRESULT hr = m_pService->ISMBind(
            m_strServerName,
            &m_hServer
            );
    }

    return *this;
}



BOOL
CServerInfo::operator==(
    IN CServerInfo & si
    )
/*++

Routine Description:

    Comparision Operator
                                                                       
Arguments:

    const CServerInfo & si : Server info object to be compared against
   
Return Value:

    TRUE if the objects are the same, FALSE otherwise

--*/
{
    //
    // Must be the same service type
    //
    if (m_pService != si.m_pService)
    {
        return FALSE;
    }

    //
    // And computer name
    //
    return ::lstrcmpi(
        QueryServerDisplayName(),
        si.QueryServerDisplayName()
        ) == 0;
}



DWORD
CServerInfo::ChangeServiceState(
    IN  int nNewState,
    OUT int * pnCurrentState,
    IN  DWORD dwInstance
    )
/*++

Routine Description:

    Change Service State on this computer (running,
    stopped, paused)
                                                                       
Arguments:

    int nNewState        : New service state INetServiceRunning, etc
    int * pnCurrentState : Pointer to current state
    DWORD dwInstance     : Instance ID whose state is to be changed
   
Return Value:

    Error return code

--*/
{
    ASSERT(m_pService != NULL);

    //
    // Allocate string with 2 terminating NULLS,
    // as required by the apis.
    //
    int nLen = m_strServerName.GetLength();
    LPTSTR lpServers = AllocTString(nLen + 2);
    if (lpServers == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ::lstrcpy(lpServers, m_strServerName);
    lpServers[nLen+1] = _T('\0');

    //
    // Call the actual api (0 -- means service)
    //
    DWORD err = m_pService->ISMChangeServiceState(
        nNewState,
        pnCurrentState, 
        dwInstance,  
        lpServers
        );

    FreeMem(lpServers);

    return err;
}



DWORD
CServerInfo::ConfigureServer(
    IN HWND hWnd,
    IN DWORD dwInstance
    )
/*++

Routine Description:

    Perform configuration on this server
                                                                       
Arguments:

    HWND hWnd         : Parent window handle
    DWORD dwInstance  : Instance ID to be configured
   
Return Value:

    Error return code

--*/
{
    ASSERT(m_pService != NULL);

    //
    // Allocate string with 2 terminating NULLS
    //
    // CODEWORK: Make this a helper function
    //
    int nLen = m_strServerName.GetLength();
    LPTSTR lpServers = AllocTString(nLen + 2);
    if (lpServers == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ::lstrcpy(lpServers, (LPCTSTR)m_strServerName);
    lpServers[nLen + 1] = _T('\0');

    DWORD err = m_pService->ISMConfigureServers(hWnd, dwInstance, lpServers);

    FreeMem(lpServers);

    return err;
}



HRESULT
CServerInfo::MMMCConfigureServer(
    IN PVOID   lpfnProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwInstance
    )
/*++

Routine Description:

    Bring up the service configuration property sheets, using the MMC 
    property mechanism.

Arguments:

    PVOID   lpfnProvider  : Provider callback
    LPARAM  param         : lparam to be passed to the sheet
    LONG_PTR handle        : console handle
    DWORD   dwInstance    : Instance number

Return Value:

    Error return code

--*/
{
    ASSERT(m_pService != NULL);

/*
    //
    // Allocate string with 2 terminating NULLS
    //
    int nLen = m_strServerName.GetLength();
    LPTSTR lpServers = AllocTString(nLen + 2);
    if (lpServers == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ::lstrcpy(lpServers, (LPCTSTR)m_strServerName);
    lpServers[nLen + 1] = _T('\0');
*/

    CError err(m_pService->ISMMMCConfigureServers(
        m_hServer,
        lpfnProvider,
        param,
        handle,
        dwInstance
        ));

    // FreeMem(lpServers);

    return err;
}



DWORD
CServerInfo::Refresh()
/*++

Routine Description:

    Attempt to refresh the comment and server state of
    the server object
                                                                       
Arguments:

    None

Return Value:

    Error return code

--*/
{
    ISMSERVERINFO si;
    si.dwSize = sizeof(si);

    CError err(m_pService->ISMQueryServerInfo(
        (LPCTSTR)m_strServerName, 
        &si
        ));

    if (err.Succeeded())
    {
        ASSERT(si.nState == INetServiceStopped ||
               si.nState == INetServicePaused  ||
               si.nState == INetServiceRunning ||
               si.nState == INetServiceUnknown);

        m_nServiceState = si.nState;
        m_strComment = si.atchComment;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\iisobj.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        iisobj.h

   Abstract:

        IIS Objects Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IISOBJ_H
#define _IISOBJ_H


//
// Forward Definitions
//
class CMenuEx;
class CServerInfo;
class CServiceInfo;
class CIISChildNode;
class CIISInstance;



#define MAX_COLUMNS (10)



//
// Bitmap indices into the imagelist
//
enum
{
    //
    // Indices into VIEW16 and VIEW32
    //
    BMP_LOCAL_COMPUTER,
    BMP_STOPPED,
    BMP_PAUSED,
    BMP_STARTED,
    BMP_UNKNOWN,
    BMP_ERROR,
    BMP_DIRECTORY,
    BMP_FILE,
    BMP_ROOT,               
    BMP_COMPUTER,
    BMP_APPLICATION,
    //
    // Added on singly from IMGR16 and IMGR32
    //
    BMP_INETMGR,
    //
    // Don't move this one, this is where the service bitmaps start
    //
    BMP_SERVICE
};



/* abstract */ class CIISObject : public CObjectPlus
/*++

Class Description:

    Base IIS-configurable object.  This is an abstract base class    

Public Interface:

    CIISObject                  : Constructor

    operator CServerInfo *      : Cast to serverinfo (could be NULL)
    operator LPCTSTR            : Cast to description string
    operator int                : Cast to bitmap index

    BOOL IsStartable            : TRUE if object can be started
    BOOL IsStoppable            : TRUE if object can be stopped

Virtual Public Interface (needs to be implemented in derived classes):

    BOOL IsControllable         : TRUE if object can be started/stopped
    BOOL IsPausable             : TRUE if object can be paused
    BOOL IsConfigurable         : TRUE if the object is configurable
    BOOL IsMMCConfigurable      : TRUE if the object is configurable with MMC
    BOOL IsAccessible           : FALSE if access was denied to this object
    BOOL IsDeletable            : TRUE if the object is deletable
    BOOL IsClusterEnabled       : TRUE if the object is cluster enabled
    BOOL IsCloneable            : TRUE if the item can be cloned.
    BOOL IsRenameable           : TRUE if the object can be renamed
    BOOL IsRunning              : TRUE if the object is in a running state
    BOOL IsStopped              : TRUE if the object is in a stopped state
    BOOL IsPaused               : TRUE if the object is in a paused state
    BOOL IsExplorable           : TRUE if the object is explorable
    BOOL IsOpenable             : TRUE if the object is openable
    BOOL IsBrowsable            : TRUE if the object is browsable
    BOOL CanConfigureStopped    : TRUE if the object can be configured while 
                                  stopped
    BOOL ChildrenOutOfDate      : TRUE if the object's children need to be 
                                  fetched
    BOOL IsLocalMachine         : TRUE if applicable machine name owner
                                  is local
    BOOL HandleUI          : TRUE if we need to confirm before deletion
    DWORD QueryErrorCode        : Return API error code (if applicable)
    DWORD ChangeState           : Change the current state of the object
    DWORD Configure             : Configure this object
    DWORD ConfigureMMC          : Configure this object with MMC
    DWORD Rename                : Rename the object
    int QueryState              : Return the (running/stopped/paused) state
    int QueryBitmapIndex        : Get the bitmap index for the object
    LPCTSTR GetStateText        : Get text representation of current state
    LPCTSTR GetDisplayText      : Generate display text for the object
    LPCTSTR GetMachineName      : Get machine name (if applicable)
    LPCTSTR GetServiceName      : Get service name (if applicable)
    LPCTSTR GetComment          : Get comment (if applicable)
    CServerInfo * GetServerInfo : Get server info object (if applicable)

--*/
{
protected:
    //
    // Protected constructor
    //
    CIISObject(
        IN const GUID guid,
        IN LPCTSTR lpszNodeName = _T(""),
        IN LPCTSTR lpszPhysicalPath = _T("")
        );

public:
    void SetScopeHandle(IN HSCOPEITEM hScopeItem, BOOL fIsParentScope = FALSE);
    HSCOPEITEM GetScopeHandle() const { return m_hScopeItem; }
    BOOL ScopeHandleIsParent() const { return m_fIsParentScope; }
    BOOL IsScopeSelected();

//
// Static Access
//
public:
    static void AttachScopeView(IN LPCONSOLENAMESPACE lpcnsScopeView);
    static LPCONSOLENAMESPACE GetScopeView();
    static BOOL m_fIsExtension;

//
// Virtual Interface
//
public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const { return FALSE; }
    virtual BOOL IsPausable() const { return FALSE; }
    virtual BOOL IsConfigurable() const { return FALSE; }
    virtual BOOL IsMMCConfigurable() const { return FALSE; }
    virtual BOOL IsAccessible() const { return TRUE; }
    virtual BOOL IsDeletable() const { return FALSE; }
    virtual BOOL IsClusterEnabled() const { return FALSE; }
    virtual BOOL HandleUI() const { return TRUE; }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const { return FALSE; }
    virtual BOOL IsStopped() const { return FALSE; }
    virtual BOOL IsPaused() const { return FALSE; }
    virtual BOOL IsRenamable() const { return FALSE; }
    virtual BOOL IsConnectable() const { return FALSE; }
    virtual BOOL IsExtension() const {return m_fIsExtension;}
    virtual BOOL IsClonable() const { return FALSE; }
    virtual BOOL IsBrowsable() const { return FALSE; }
    virtual BOOL IsExplorable() const { return FALSE; }
    virtual BOOL IsOpenable() const { return FALSE; }
    virtual BOOL IsRefreshable() const { return TRUE; }
    virtual BOOL CanConfigureStopped() const { return FALSE; }
    virtual BOOL ChildrenOutOfDate() const { return FALSE; }

    //
    // Get the error return code 
    //
    virtual HRESULT QueryErrorCode() const { return S_OK; }
    virtual int QueryState() const { return INetServiceUnknown; }

    //
    // Access Functions (must be implemented in the derived class)
    //
    virtual HRESULT ChangeState(IN int nNewState);
    virtual HRESULT Configure(IN CWnd * pParent);

    virtual HRESULT ConfigureMMC(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LPARAM param,
        IN LONG_PTR handle
        );

    virtual HRESULT RefreshData();
    virtual HRESULT Delete();
    virtual HRESULT SecurityWizard();
    virtual int Compare(int nCol, CIISObject * pObject);

    //
    // Bring up in "explore" view
    //
    virtual HRESULT Explore();

    //
    // Bring up in "open" view
    //
    virtual HRESULT Open();

    //
    // Bring up in the browser
    //
    virtual HRESULT Browse();

    static void InitializeHeaders(IN LPHEADERCTRL pHeader);
    virtual void InitializeChildHeaders(IN LPHEADERCTRL pHeader);
    virtual BOOL IsLeafNode() const { return FALSE; }

    virtual HRESULT AddMenuItems(
        IN LPCONTEXTMENUCALLBACK pContextMenuCallback
        );

    virtual HRESULT AddNextTaskpadItem(
        OUT MMC_TASK * pTask
        );

    virtual HRESULT AddChildNode(
        IN OUT CIISChildNode *& pChild
        );

    virtual BOOL ChildrenExpanded() const { return m_tmChildrenExpanded != 0L;}
    virtual void CleanChildren();
    virtual void DirtyChildren();
    virtual BOOL SupportsFileSystem() const { return FALSE; }
    virtual BOOL IsFileSystemNode() const { return FALSE; }
    virtual BOOL SupportsChildren() const { return FALSE; }
    virtual BOOL SupportsSecurityWizard() const { return FALSE; }
    virtual HRESULT ExpandChildren(HSCOPEITEM pParent);
    virtual HRESULT Rename(LPCTSTR NewName);
    virtual LPCTSTR GetStateText() const;

    //
    // Display Context Functions
    //
    /* PURE */ virtual int QueryBitmapIndex() const = 0;

    /* PURE */ virtual LPCTSTR GetDisplayText(
        OUT CString & strText
        ) const = 0;

    virtual void GetResultDisplayInfo(
        IN  int nCol,
        OUT CString & str,
        OUT int & nImage
        ) const;

    //
    // Get the machine name 
    //
    virtual LPCTSTR GetMachineName() const { return NULL; }

    //
    // Determine if the local machine name is local
    //
    virtual BOOL IsLocalMachine() const { return FALSE; }

    //
    // Get the service name
    //
    virtual LPCTSTR GetServiceName() const { return NULL; }

    //
    // Get the comment
    //
    virtual LPCTSTR GetComment() const { return NULL; }

    //
    // Get the server info (service/server pair)
    // object that controls this object
    //
    virtual CServerInfo * GetServerInfo() { return NULL; }

    //
    // Get metabase node name
    //
    virtual LPCTSTR QueryNodeName(BOOL fMetabasePath = FALSE) const { return m_strNodeName; }

    //
    // Find the owner instance
    //
    virtual CIISInstance * FindOwnerInstance() { return NULL; }

    //
    // Check to see if the current node is a terminal point
    // in the metabasepath
    // 
    virtual BOOL IsTerminalPoint(BOOL fFullMetaPath) const { return FALSE; }

    //
    // Get parent CIISObject 
    //
    virtual CIISObject * GetParentObject() const;

    //
    // Get parent path for this node
    //
    LPCTSTR BuildParentPath(
        OUT CString & strParentPath,
        BOOL fMetabasePath
        ) const;

    //
    // Get complete path for this node
    //
    LPCTSTR BuildFullPath(
        OUT CString & strPath,
        BOOL fMetabasePath
        ) const;

    //
    // Get complete physical path for this node
    //
    LPCTSTR BuildPhysicalPath(
        OUT CString & strPhysicalPath
        ) const;

//
// Assumed Functions
//
public:
    BOOL IsValidObject() const;
    BOOL IsStartable() const { return IsControllable() && !IsRunning(); }
    BOOL IsStoppable() const { return IsControllable() && (IsRunning() || IsPaused() ); }
    BOOL OK() const { return QueryErrorCode() == S_OK; }
    const GUID QueryGUID() const { return m_guid; }
    const GUID * GetGUIDPtr() { return &m_guid; }
    CString & GetNodeName() { return m_strNodeName; }
    LPCTSTR QueryPhysicalPath() const { return m_strPhysicalPath; }

    CString& GetPhysicalPath() { return m_strPhysicalPath; }

    BOOL IsVirtualDirectory() const { return !m_strPhysicalPath.IsEmpty(); }

    //
    // Get the redirected path
    //
    BOOL IsRedirected() const { return !m_strRedirPath.IsEmpty(); }
    BOOL IsChildOnlyRedir() const { return m_fChildOnlyRedir; }
    LPCTSTR QueryRedirPath() { return m_strRedirPath; }

    //
    // Get the instance ID
    //
    DWORD QueryInstanceID();

//
// Conversion Operators
//
public:
    operator CServerInfo *() { return GetServerInfo(); }

    //
    // Get display text
    //
    operator LPCTSTR();

    //
    // Get bitmap index
    //
    operator int() { return QueryBitmapIndex(); }

    //
    // GUID
    //
    operator const GUID() { return QueryGUID(); }

    //
    // Refresh display
    //
    void RefreshDisplayInfo();

public:
    //
    // Add Menu Command
    //
    static HRESULT AddMenuItemByCommand(
        IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
        IN LONG lCmdID,
        IN LONG fFlags = 0
        );

    static HRESULT AddTaskpadItemByInfo(
        OUT MMC_TASK * pTask,
        IN  LONG    lCommandID,
        IN  LPCTSTR lpszMouseOn,
        IN  LPCTSTR lpszMouseOff,
        IN  LPCTSTR lpszText,
        IN  LPCTSTR lpszHelpString
        );

    static HRESULT AddTaskpadItemByCommand(
        IN  LONG lCmdID,
        OUT MMC_TASK * pTask,
        IN  HINSTANCE hInstance = (HINSTANCE)-1
        );

protected:
    static CMenuEx s_mnu;
    static CString s_strProperties;
    static CString s_strRunning;
    static CString s_strPaused;
    static CString s_strStopped;
    static CString s_strUnknown;
    static CString s_strYes;
    static CString s_strNo;
    static CString s_strTCPIP;
    static CString s_strNetBIOS;
    static CString s_strDefaultIP;
    static CString s_strRedirect;
    static time_t s_lExpirationTime;
    static LPCONSOLENAMESPACE s_lpcnsScopeView;

protected:
    //
    // Result View Helpers
    //
    static void BuildResultView(
        IN LPHEADERCTRL pHeader,
        IN int cColumns,
        IN int * pnIDS,
        IN int * pnWidths
        );

    //
    // Determine if instances can be added on this
    // machine
    //
    static BOOL CanAddInstance(
        IN LPCTSTR lpszMachineName
        );

protected:
    //
    // GUID for runtime type checking 
    //
    const GUID m_guid;
    time_t m_tmChildrenExpanded;
    HSCOPEITEM m_hScopeItem;
    BOOL    m_fChildOnlyRedir;
    BOOL    m_fIsParentScope;
    CString m_strNodeName;
    CString m_strPhysicalPath;
    CString m_strRedirPath;
};



class CIISMachine : public CIISObject
{
/*++

Class Description:

    IIS Machine object.  This object contains only a machine name,
    and is the only object that does not have a CServerInfo pointer    

Public Interface:

    CIISMachine                 : Constructor

    BOOL IsConfigurable         : TRUE if the object is configurable
    DWORD Configure             : Configure this object
    int QueryBitmapIndex        : Get the bitmap index for the object
    CMenu * PrepareContextMenu  : Prepare context menu for object
    LPCTSTR GetDisplayText      : Generate display text for the object
    LPCTSTR GetMachineName      : Get machine name (if applicable)

--*/
public:
    CIISMachine(
        IN LPCTSTR lpszMachineName
        );

//
// Access Functions
//
public:
   BOOL m_fIsExtension;

//
// Virtual Interface
//
public:
    //
    // Yes, can connect from here
    //
    virtual BOOL IsConnectable() const { return TRUE; }
    virtual BOOL IsConfigurable() const;
    virtual BOOL IsMMCConfigurable() const { return m_fIsAdministrator; }
    virtual BOOL IsExtension() const {return m_fIsExtension;}
    virtual HRESULT RefreshData() { return ERROR_SUCCESS; }

    virtual HRESULT Configure(
        IN CWnd * pParent
        );

    virtual HRESULT ConfigureMMC(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LPARAM param,
        IN LONG_PTR handle
        );

    //
    // Display Context Functions
    //
    virtual int QueryBitmapIndex() const;

    virtual LPCTSTR GetDisplayText(
        OUT CString & strText
        ) const;

    virtual void GetResultDisplayInfo(
        IN  int nCol,
        OUT CString & str,
        OUT int & nImage
        ) const;

    virtual HRESULT AddMenuItems(
        IN LPCONTEXTMENUCALLBACK pContextMenuCallback
        );

    virtual HRESULT AddNextTaskpadItem(
        OUT MMC_TASK * pTask
        );

    virtual LPCTSTR GetMachineName() const { return m_strMachineName; }

    //
    // Check to see if the current node is a terminal point
    // in the metabasepath. Base class method doesn't work correctly
	// in case of extension
    // 
    virtual BOOL IsTerminalPoint(BOOL fFullMetaPath) const { return TRUE; }

    virtual BOOL IsLocalMachine() const { return m_fLocal; }

    static void InitializeHeaders(LPHEADERCTRL pHeader);

    virtual int Compare(int nCol, CIISObject * pObject);

    virtual void InitializeChildHeaders(LPHEADERCTRL pHeader);

public:
    inline static void AttachNewInstanceCmds(
        CObListPlus * poblNewInstanceCmds
        )
    {
        s_poblNewInstanceCmds = poblNewInstanceCmds;
    }

    // BOOL IsLocal() const { return m_fLocal; }

	// Check to see if current user is administrator on the box
	BOOL IsAdministrator() const
	{
		return m_fIsAdministrator;
	}

protected:
    static CObListPlus * s_poblNewInstanceCmds;
    static CString s_strLocalMachine;

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_NAME,
        COL_LOCAL,
        COL_TYPE,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int rgnLabels[COL_TOTAL];
    static int rgnWidths[COL_TOTAL];

private:
    CString m_strMachineName;
    CString m_strDisplayName;
    BOOL m_fLocal;
	BOOL m_fIsAdministrator;
};



class CIISInstance : public CIISObject
{
/*++

Class Description:

    IIS Instance object.  For down-level service types, this is a simple
    wrapper for the CServerInfo object. 

Public Interface:

    CIISInstance                : Constructors for regular and down-level

    QueryID                     : Get instance ID or 0 for down-level
    QueryServiceID              : Get the service ID
    operator ==                 : Compare service ID and instance ID
    IsDownLevel                 : TRUE if this is a down-level server w/o 
                                  instances
    SetViewType                 : Bitmap index and text change depending on
                                  if the object is in server, service view.
                                  or report view.
    BOOL IsControllable         : TRUE if object can be started/stopped
    BOOL IsPausable             : TRUE if object can be paused
    BOOL IsConfigurable         : TRUE if the object is configurable
    BOOL IsAccessible           : FALSE if access was denied to this object
    BOOL IsDeletable            : TRUE if the object is deletable
    BOOL IsClusterEnabled       : TRUE if the object is cluster enabled
    BOOL IsRunning              : TRUE if the object is in a running state
    BOOL IsStopped              : TRUE if the object is in a stopped state
    BOOL IsPaused               : TRUE if the object is in a paused state
    BOOL CanConfigureStopped    : TRUE if the object can be configured while
                                  stopped.
    DWORD ChangeState           : Change the current state of the object
    DWORD Configure             : Configure this object
    int QueryState              : Return the (running/stopped/paused) state
    int QueryBitmapIndex        : Get the bitmap index for the object
    LPCTSTR GetStateText        : Get text representation of current state
    LPCTSTR GetDisplayText      : Generate display text for the object
    LPCTSTR GetMachineName      : Get machine name (if applicable)
    LPCTSTR GetServiceName      : Get service name 
    LPCTSTR GetComment          : Get comment (if applicable)
    CServerInfo * GetServerInfo : Get server info object pointer

--*/
public:
    //
    // Constructor for down-level (single-instance server)
    //
    CIISInstance(
        IN CServerInfo * pServerInfo
        );

    CIISInstance(
        IN ISMINSTANCEINFO * pii,
        IN CServerInfo * pServerInfo
        );

    void InitializeFromStruct(
        IN ISMINSTANCEINFO * pii
        );

//
// Access Functions
//
public:
    DWORD QueryID() const { return m_dwID; }
    BOOL IsDownLevel() const { return m_fDownLevel; }
    DWORD QueryServiceID() const;
    BOOL operator ==(CIISInstance & target);

//
// Virtual Interface
//
public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const;
    virtual BOOL IsPausable() const;
    virtual BOOL IsConfigurable() const;
    virtual BOOL IsMMCConfigurable() const;
    virtual BOOL IsAccessible() const;
    virtual BOOL IsDeletable() const;
    virtual BOOL IsClusterEnabled() const;
    virtual BOOL SupportsFileSystem() const;
    virtual BOOL SupportsChildren() const;
    virtual BOOL SupportsSecurityWizard() const;
    virtual BOOL IsLeafNode() const;

    //
    // State Functions
    //
    virtual BOOL IsRunning() const;
    virtual BOOL IsStopped() const;
    virtual BOOL IsPaused() const;

    // 
    // Old single instances need to be running
    //
    virtual BOOL CanConfigureStopped() const { return !m_fDownLevel; }

    //
    // Get the error return code 
    //
    virtual HRESULT QueryErrorCode() const { return m_hrError; }

    virtual HRESULT AddChildNode(
        CIISChildNode *& pChild
        );

    virtual BOOL IsBrowsable() const { return !IsDownLevel() && HasWebProtocol() && IsRunning(); }
    virtual BOOL IsExplorable() const { return !IsDownLevel(); }
    virtual BOOL IsOpenable() const { return !IsDownLevel(); }

    virtual HRESULT AddMenuItems(
        IN LPCONTEXTMENUCALLBACK pContextMenuCallback
        );

    virtual HRESULT AddNextTaskpadItem(
        OUT MMC_TASK * pTask
        );

    //
    // Access Functions
    //
    virtual int QueryState() const;

    virtual HRESULT Delete();
    virtual HRESULT SecurityWizard();

    virtual HRESULT ChangeState(int nNewState);

    virtual HRESULT Configure(
        IN CWnd * pParent
        );

    virtual HRESULT ConfigureMMC(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LPARAM param,
        IN LONG_PTR handle
        );

    virtual HRESULT RefreshData();

    //
    // Display Context Functions
    //
    virtual int QueryBitmapIndex() const;

    virtual LPCTSTR GetStateText() const;

    virtual LPCTSTR GetDisplayText(
        OUT CString & strText
        ) const;

    virtual void GetResultDisplayInfo(
        IN  int nCol,
        OUT CString & str,
        OUT int & nImage
        ) const;

    //
    // Get the machine name
    //
    virtual LPCTSTR GetMachineName() const { return m_strMachine; }
    virtual BOOL IsLocalMachine() const { return m_fLocalMachine; }

    //
    // Get the service name
    //
    virtual LPCTSTR GetServiceName() const;

    //
    // Get the comment
    //
    virtual LPCTSTR GetComment() const;

    //
    // Build  result view
    //
    static  void InitializeHeaders(LPHEADERCTRL pHeader);
    virtual void InitializeChildHeaders(LPHEADERCTRL pHeader);
    virtual int Compare(int nCol, CIISObject * pObject);
    virtual BOOL ChildrenExpanded() const;
    virtual HRESULT ExpandChildren(HSCOPEITEM pParent);

    //
    // Get the server info (service/server pair)
    // object that controls this instance
    //
    virtual CServerInfo * GetServerInfo() { return m_pServerInfo; }
    virtual CIISInstance * FindOwnerInstance() { return this; }

    virtual BOOL IsTerminalPoint(IN BOOL fFullMetaPath) const;

    //
    // Get metabase node name
    //
    virtual LPCTSTR QueryNodeName(BOOL fMetabasePath = FALSE) const;

//
// Access
//
public:
    USHORT GetPort() const { return m_sPort; }
    BOOL HasComment() const { return !m_strComment.IsEmpty(); }
    BOOL HasIPAddress() const { return m_dwIPAddress != 0L; }
    DWORD GetIPAddress() const { return m_dwIPAddress; }
    BOOL HasHostHeaderName() const { return !m_strHostHeaderName.IsEmpty(); }
    LPCTSTR GetHostHeaderName() const { return (LPCTSTR)m_strHostHeaderName; }
    BOOL SupportsInstances() const;
    BOOL HasWebProtocol() const;
    HRESULT ShellBrowsePath(LPCTSTR lpszPath);

public:
    static void SetViewType(
        BOOL fServerView = TRUE,
        BOOL fAppendState = TRUE
        );

protected:
    static BOOL IsInitialized();
    static void InitializeStrings();

protected:
    static CString s_strFormatState;
    static BOOL s_fServerView;
    static BOOL s_fAppendState;

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
        COL_DOMAIN_NAME,
        COL_IP_ADDRESS,
        COL_TCP_PORT,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int rgnLabels[COL_TOTAL];
    static int rgnWidths[COL_TOTAL];

protected:
    int     m_nState;
    BOOL    m_fDownLevel;
    BOOL    m_fDeletable;
    BOOL    m_fClusterEnabled;
    BOOL    m_fLocalMachine;
    USHORT  m_sPort;
    DWORD   m_dwID;
    DWORD   m_dwIPAddress;
    HRESULT m_hrError;
    CString m_strHostHeaderName;
    CString m_strComment;
    CString m_strMachine;
    CServerInfo * m_pServerInfo;
};



class CIISChildNode : public CIISObject
/*++

Class Description:

    

Public Interface:


--*/
{
public:
    CIISChildNode(
        IN ISMCHILDINFO * pii,
        IN CIISInstance * pOwner
        );

    void InitializeFromStruct(
        IN ISMCHILDINFO * pii
        );

//
// Access Functions
//
public:
    BOOL IsEnabledApplication() const { return m_fEnabledApplication; }

    virtual CIISInstance * FindOwnerInstance() { return m_pOwner; }

    //
    // Get the server info (service/server pair)
    // object that controls this object
    //
    virtual CServerInfo * GetServerInfo();

    //
    // Get the machine name
    //
    virtual LPCTSTR GetMachineName() const;
    virtual BOOL IsLocalMachine() const;

    //
    // Get the service name
    //
    virtual LPCTSTR GetServiceName() const;

//
// Virtual Interface
//
public:
    //
    // Display Context Functions
    //
    virtual int QueryBitmapIndex() const;

    virtual LPCTSTR GetDisplayText(
        OUT CString & strText
        ) const;

    virtual void GetResultDisplayInfo(
        IN  int nCol,
        OUT CString & str,
        OUT int & nImage
        ) const;

    static void InitializeHeaders(LPHEADERCTRL pHeader);

    virtual void InitializeChildHeaders(LPHEADERCTRL pHeader);

    virtual HRESULT AddChildNode(
        IN OUT CIISChildNode *& pChild
        );

    virtual int Compare(
        IN int nCol, 
        IN CIISObject * pObject
        );

    virtual BOOL SupportsFileSystem() const;
    virtual BOOL SupportsChildren() const { return TRUE; }
    virtual BOOL SupportsSecurityWizard() const;
    virtual BOOL IsBrowsable() const { return m_pOwner && m_pOwner->IsBrowsable(); }
    virtual BOOL IsExplorable() const { return TRUE; }
    virtual BOOL IsOpenable() const { return TRUE; }
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsMMCConfigurable() const;
    virtual BOOL IsDeletable() const { return TRUE; }
    virtual BOOL IsRenamable() const { return TRUE; }
    virtual HRESULT QueryErrorCode() const { return m_hrError; }

    virtual HRESULT AddMenuItems(
        IN LPCONTEXTMENUCALLBACK pContextMenuCallback
        );

    virtual HRESULT AddNextTaskpadItem(
        OUT MMC_TASK * pTask
        );

    virtual HRESULT Rename(
        IN LPCTSTR NewName
        );

    virtual HRESULT Delete();

    virtual HRESULT SecurityWizard();

    virtual HRESULT Configure(
        IN CWnd * pParent
        );

    virtual HRESULT ConfigureMMC(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LPARAM param,
        IN LONG_PTR handle
        );

    virtual HRESULT RefreshData();

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS,
        COL_PATH,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int rgnLabels[COL_TOTAL];
    static int rgnWidths[COL_TOTAL];

protected:
    BOOL    m_fEnabledApplication;
    HRESULT m_hrError;
    CIISInstance * m_pOwner;
};



class CIISFileNode : public CIISObject
/*++

Class Description:

    

Public Interface:


--*/
{
public:
    CIISFileNode(
        IN LPCTSTR lpszAlias,        // Name of current node
        IN DWORD dwAttributes,
        IN CIISInstance * pOwner,
        IN LPCTSTR lpszRedirect,     // = NULL
        IN BOOL fDir = TRUE
        );

//
// Access Functions
//
public:
    BOOL IsEnabledApplication() const { return m_fEnabledApplication; }

    //
    // Get the redirected path
    //
    DWORD QueryAttributes() const { return m_dwAttributes; }
    BOOL IsDirectory() const;
    BOOL IsFile() const { return !IsDirectory(); }
    virtual CIISInstance * FindOwnerInstance() { return m_pOwner; }

    //
    // Get the server info (service/server pair)
    // object that controls this object
    //
    virtual CServerInfo * GetServerInfo();

    //
    // Get the machine name
    //
    virtual LPCTSTR GetMachineName() const;
    virtual BOOL IsLocalMachine() const;

    //
    // Get the service name
    //
    virtual LPCTSTR GetServiceName() const;

    //
    // Match up this file item to metabase properties
    //
    HRESULT FetchMetaInformation(
        IN  CString & strParent,
        OUT BOOL * pfVirtualDirectory = NULL
        );

//
// Virtual Interface
//
public:
    //
    // Display Context Functions
    //
    virtual int QueryBitmapIndex() const;

    virtual LPCTSTR GetDisplayText(
        OUT CString & strText
        ) const;

    virtual void GetResultDisplayInfo(
        IN  int nCol,
        OUT CString & str,
        OUT int & nImage
        ) const;

    static void InitializeHeaders(LPHEADERCTRL pHeader);

    virtual void InitializeChildHeaders(LPHEADERCTRL pHeader);

    virtual int Compare(int nCol, CIISObject * pObject);

    virtual BOOL SupportsFileSystem() const { return IsDirectory(); }

    virtual BOOL IsFileSystemNode() const { return TRUE; }

    virtual BOOL SupportsChildren() const { return IsDirectory(); }

    virtual BOOL SupportsSecurityWizard() const;

    virtual BOOL IsDeletable() const { return TRUE; }

    //
    // Let explorer handle the UI for deletion/renaming
    //
    virtual BOOL HandleUI() const { return FALSE; }

    virtual BOOL IsRenamable() const { return TRUE; }

    virtual BOOL IsConfigurable() const { return TRUE; }

    virtual BOOL IsMMCConfigurable() const { return m_pOwner->IsMMCConfigurable(); }

    virtual HRESULT Configure(
        IN CWnd * pParent
        );

    virtual HRESULT ConfigureMMC(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LPARAM param,
        IN LONG_PTR handle
        );

    virtual HRESULT AddChildNode(
        CIISChildNode *& pChild
        );

    virtual HRESULT RefreshData();
    virtual BOOL IsExplorable() const { return IsDirectory(); }
    virtual BOOL IsOpenable() const { return TRUE; }
    virtual BOOL IsBrowsable() const { return m_pOwner && m_pOwner->IsBrowsable(); }

    //
    // Get parent CIISObject 
    //
    virtual CIISObject * GetParentObject() const;

    //
    // Add menu items
    //
    virtual HRESULT AddMenuItems(
        IN LPCONTEXTMENUCALLBACK pContextMenuCallback
        );

    virtual HRESULT AddNextTaskpadItem(
        OUT MMC_TASK * pTask
        );

    virtual HRESULT Rename(
        IN LPCTSTR NewName
        );

    virtual HRESULT Delete();

    virtual HRESULT SecurityWizard();

    BOOL IsDir() const { return m_fDir; }

    virtual BOOL IsLeafNode() const { return !IsDir(); }


protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS,
        COL_PATH,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int rgnLabels[COL_TOTAL];
    static int rgnWidths[COL_TOTAL];

protected:
    BOOL    m_fDir;
    BOOL    m_fEnabledApplication;
    DWORD   m_dwAttributes;
    CIISInstance * m_pOwner;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CIISObject::SetScopeHandle(
    IN HSCOPEITEM hScopeItem,
    IN BOOL fIsParentScope 
    )
{
    ASSERT(m_hScopeItem == NULL);
    m_hScopeItem = hScopeItem;
    m_fIsParentScope = fIsParentScope;
}

inline /* static */ void CIISObject::AttachScopeView(
    IN LPCONSOLENAMESPACE lpcnsScopeView
    )
{
    ASSERT(lpcnsScopeView != NULL);
    s_lpcnsScopeView = lpcnsScopeView;
}

inline /* static */ LPCONSOLENAMESPACE CIISObject::GetScopeView()
{
    ASSERT(s_lpcnsScopeView != NULL);
    return s_lpcnsScopeView;
}

inline /* virtual */ HRESULT CIISObject::ChangeState(IN int nNewState)
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ HRESULT CIISObject::Configure(IN CWnd * pParent)
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ HRESULT CIISObject::ConfigureMMC(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LPARAM param,
    IN LONG_PTR handle
    )
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ HRESULT CIISObject::RefreshData()
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ HRESULT CIISObject::Delete()
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ HRESULT CIISObject::SecurityWizard()
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ int CIISObject::Compare(int nCol, CIISObject * pObject)
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return 0;
}

inline /* static */ void CIISObject::InitializeHeaders(IN LPHEADERCTRL pHeader)
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
}

inline /* virtual */ void CIISObject::InitializeChildHeaders(
    IN LPHEADERCTRL pHeader
    )
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
}

inline /* virtual */ HRESULT CIISObject::AddChildNode(
    IN OUT CIISChildNode *& pChild
    )
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ void CIISObject::CleanChildren()
{
    time(&m_tmChildrenExpanded);
}

inline /* virtual */ void CIISObject::DirtyChildren()
{
    m_tmChildrenExpanded = 0L;
}

inline /* virtual */ HRESULT CIISObject::ExpandChildren(HSCOPEITEM pParent)
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ HRESULT CIISObject::Rename(IN LPCTSTR NewName)
{
    TRACEEOLID("Must be implemented in the derived class");
    ASSERT(FALSE);
    return CError::HResult(ERROR_INVALID_FUNCTION);
}

inline /* virtual */ LPCTSTR CIISObject::GetStateText() const
{
    return CIISObject::s_strUnknown;
}        

inline /* virtual */ void CIISObject::GetResultDisplayInfo(
    IN  int nCol,
    OUT CString & str,
    OUT int & nImage
    ) const
{
    ASSERT(nCol == 0);
    nImage = QueryBitmapIndex();
    GetDisplayText(str);
}

inline DWORD CIISInstance::QueryServiceID() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->QueryServiceID();
}

inline BOOL CIISInstance::operator ==(CIISInstance & target)
{
    return QueryServiceID() == target.QueryServiceID()
        && QueryID() == target.QueryID()
        && GetServerInfo() == target.GetServerInfo();
}

inline /* virtual */ BOOL CIISInstance::IsControllable() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->CanControlService();
}

inline /* virtual */ BOOL CIISInstance::IsPausable() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->CanPauseService() 
       && (IsRunning() || IsPaused());
}

inline /* virtual */ BOOL CIISInstance::IsConfigurable() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->IsConfigurable();
}

inline /*virtual */ BOOL CIISInstance::IsMMCConfigurable() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->SupportsMMC();
}

inline /* virtual */ BOOL CIISInstance::IsAccessible() const
{
    return IsDownLevel() || (QueryErrorCode() == ERROR_SUCCESS);
}

inline /* virtual */ BOOL CIISInstance::IsDeletable() const
{
    return !IsDownLevel() && m_fDeletable;
}

inline /* virtual */ BOOL CIISInstance::IsClusterEnabled() const
{
    return !IsDownLevel() && m_fClusterEnabled;
}

inline /* virtual */ BOOL CIISInstance::SupportsFileSystem() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->SupportsFileSystem();
}

inline /* virtual */ BOOL CIISInstance::SupportsSecurityWizard() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->SupportsSecurityWizard();
}

inline /* virtual */ BOOL CIISInstance::SupportsChildren() const
{
    ASSERT(m_pServerInfo != NULL);
    return !IsDownLevel() && m_pServerInfo->SupportsChildren();
}

inline /* virtual */ BOOL CIISInstance::IsLeafNode() const
{
    return !SupportsFileSystem() && !SupportsChildren();
}

inline /* virtual */ LPCTSTR CIISInstance::GetServiceName() const
{
    ASSERT(m_pServerInfo != NULL);
    return m_pServerInfo->GetServiceName();
}

inline /* virtual */ BOOL CIISInstance::IsTerminalPoint(
    IN BOOL fFullMetaPath
    ) const
{ 
    //
    // Metabase paths terminate at an instance
    //
    return TRUE;
}

inline /* virtual */ LPCTSTR CIISInstance::QueryNodeName(BOOL fMetabasePath) const
{
    return fMetabasePath ? (LPCTSTR)m_strNodeName : g_cszRoot;
}

inline BOOL CIISInstance::SupportsInstances() const
{
    return !IsDownLevel() && m_pServerInfo && m_pServerInfo->SupportsInstances();
}

inline BOOL CIISInstance::HasWebProtocol() const
{
    return !IsDownLevel() && m_pServerInfo && m_pServerInfo->HasWebProtocol();
}

inline /* static */ void CIISInstance::SetViewType(
    BOOL fServerView,
    BOOL fAppendState
    )
{
    CIISInstance::s_fServerView = fServerView;
    CIISInstance::s_fAppendState = fAppendState;
}

inline /* static */ BOOL CIISInstance::IsInitialized()
{
    return !CIISInstance::s_strFormatState.IsEmpty();
}

inline /* virtual */ CServerInfo * CIISChildNode::GetServerInfo() 
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->GetServerInfo();
}

inline /* virtual */ LPCTSTR CIISChildNode::GetMachineName() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->GetMachineName();
}

inline /* virtual */ BOOL CIISChildNode::IsLocalMachine() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->IsLocalMachine();
}

inline /* virtual */ LPCTSTR CIISChildNode::GetServiceName() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->GetServiceName();
}

inline /* virtual */ BOOL CIISChildNode::SupportsFileSystem() const
{
    ASSERT(m_pOwner != NULL);
    return !IsRedirected() && m_pOwner->SupportsFileSystem();
}

inline /* virtual */ BOOL CIISChildNode::SupportsSecurityWizard() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->SupportsSecurityWizard();
}

inline /* virtual */ BOOL CIISChildNode::IsMMCConfigurable() const
{
    return m_pOwner->IsMMCConfigurable();
}

inline BOOL CIISFileNode::IsDirectory() const
{
    return (m_dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
}

inline /* virtual */ CServerInfo * CIISFileNode::GetServerInfo() 
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->GetServerInfo();
}

inline /* virtual */ BOOL CIISFileNode::SupportsSecurityWizard() const
{
    ASSERT(m_pOwner != NULL);
    return IsDirectory() && m_pOwner->SupportsSecurityWizard();
}

inline /* virtual */ LPCTSTR CIISFileNode::GetMachineName() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->GetMachineName();
}

inline /* virtual */ BOOL CIISFileNode::IsLocalMachine() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->IsLocalMachine();
}

inline /* virtual */ LPCTSTR CIISFileNode::GetServiceName() const
{
    ASSERT(m_pOwner != NULL);
    return m_pOwner->GetServiceName();
}

#endif // _IIS_OBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\inetmgr.h ===
/*++

   Copyright    (c)    1994-1998   Microsoft Corporation

   Module  Name :

        inetmgr.h

   Abstract:

        Main program object and class definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _INETMGR_H_
#define _INETMGR_H_

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include <lmcons.h>
#include <wtypes.h>
#include <iis64.h>

extern "C"
{
    typedef unsigned hyper ULONGLONG;
    #include "svcloc.h"
}

#include "comprop.h"
#include "svrinfo.h"
#include "resource.h"       // main symbols



LPOLESTR
CoTaskDupString(
    IN LPCOLESTR szString
    );


#define CoTaskStringFree(szString)\
    if (szString) CoTaskMemFree(szString);


HRESULT
BuildResURL(
    OUT CString & str,
    IN  HINSTANCE hSourceInstance = (HINSTANCE)-1
    );

struct INTERNAL
/*++

Routine Description:

    Internal information structure.  This is used to get the private information
    from the data object.

Public Interface:

    INTERNAL            : Constructor
    ~INTERNAL           : Destructor

--*/
{
    INTERNAL()
        : m_type(CCT_UNINITIALIZED),
          m_cookie(-1)
    {
        ::ZeroMemory(&m_clsid, sizeof(CLSID));
    };

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;         // What context is the data object.
    MMC_COOKIE          m_cookie;       // What object the cookie represents
    CString             m_string;       //
    CLSID               m_clsid;        // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
        {
            return *this;
        }

        //
        // Deep copy the information
        //
        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;
        CopyMemory(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs) { return rhs.m_string == m_string; }
};



//
// Menu Commands, listed in toolbar order.
//
// IMPORTANT! -- this must be kept in sync with MenuItemDefs
// in iisobj.cpp
//
enum
{
    IDM_INVALID,            /* invalid command ID */
    IDM_CONNECT,
    IDM_DISCOVER,
    IDM_START,
    IDM_STOP,
    IDM_PAUSE,
    /**/
    IDM_TOOLBAR             /* Toolbar commands start here */
};



//
// Additional menu commands that do not show up in the toolbar
//
enum
{
    IDM_EXPLORE = IDM_TOOLBAR,
    IDM_OPEN,
    IDM_BROWSE,
    IDM_CONFIGURE,
    IDM_DISCONNECT,
    IDM_METABACKREST,
    IDM_SHUTDOWN,
    IDM_NEW_VROOT,
    IDM_NEW_INSTANCE,
    IDM_VIEW_TASKPAD,
    IDM_TASK_SECURITY_WIZARD,

    //
    // Don't move this last one -- it will be used
    // as an offset for service specific new instance
    // commands
    //
    IDM_NEW_EX_INSTANCE
};


//
// Background colour mask of our own toolbar bitmaps.
//
#define TB_COLORMASK        RGB(192,192,192)    // Lt. Gray

//
// Default discovery wait time
//
#define DEFAULT_WAIT_TIME   (30000L)            // 30 seconds



class CServiceInfo : public CObjectPlus
/*++

Class Description:

    Service info descriptor class.  This is used for downlevel ISM objects.

Public Interface:

    CServiceInfo             : Constructor
    ~CServiceInfo            : Destructor

    QueryInstanceHandle      : Get the instance handle of the config dll
                               for this service
    QueryISMVersion          : Get the ISM version the config DLL was written
                               for.
    QueryDiscoveryMask       : Get the inetsloc discovery mask
    QueryButtonBkMask        : Get the background mask for the toolbar button
    QueryButtonBitmapID      : Get the toolbar button resource ID
    QueryServiceBkMask       : Get the background mask for the view
    QueryServiceBitmapID     : Get the view bitmap resource ID
    QueryServiceID           : Get the service ID assigned to this service
    GetShortName             : Get the short name of the service
    GetLongName              : Get the full name of the service
    UseInetSlocDiscover      : TRUE if the service uses inetsloc discovery
    CanControlService        : TRUE if the service is controllable
    CanPauseService          : TRUE if the service is pausable
    UseNormalColorMapping    : TRUE if normal colour mapping should be used
    SupportsInstances        : TRUE if the service has instances
    SupportsChildren         : TRUE if the service has children
    UnderstandsInstanceCodes : TRUE if instance ID codes are understood.
    HasWebProtocol           : TRYE if the service supports a web protocol name
    IsSelected               : TRUE if the service type is selected in the
                               toolbar.
    SelectService            : Set the selection state of the service
    QueryReturnCode          : Get the error return code of the service
    InitializedOK            : TRUE if the service config DLL was initialized
                               OK.

    ISMQueryServiceInfo      : Call the query service info API
    ISMDiscoverServers       : Call the discover servers API
    ISMQueryServerInfo       : Call the query server info API
    ISMChangeServiceState    : Call the change service state API
    ISMConfigureServers      : Call the configure server API
    ISMEnumerateInstances    : Call the enumerate instances API
    ISMConfigureChild        : Call the configure child API

--*/
{
protected:
    //
    // ISM Method prototype
    //
    typedef HRESULT (APIENTRY * pfnISMMethod)(...);

    //
    // ISM Method Definition
    //
    typedef struct tagISM_METHOD_DEF
    {
        int     iID;
        BOOL    fMustHave;
        LPCSTR  lpszMethodName;
    } ISM_METHOD_DEF;

    //
    // VTable entry IDs
    //
    enum
    {
        ISM_QUERY_SERVICE_INFO,
        ISM_DISCOVER_SERVERS,
        ISM_QUERY_SERVER_INFO,
        ISM_CHANGE_SERVICE_STATE,
        ISM_CONFIGURE,
        ISM_BIND,
        ISM_UNBIND,
        ISM_CONFIGURE_CHILD,
        ISM_ENUMERATE_INSTANCES,
        ISM_ENUMERATE_CHILDREN,
        ISM_ADD_INSTANCE,
        ISM_DELETE_INSTANCE,
        ISM_ADD_CHILD,
        ISM_DELETE_CHILD,
        ISM_RENAME_CHILD,
        ISM_QUERY_INSTANCE_INFO,
        ISM_QUERY_CHILD_INFO,
        ISM_MMC_CONFIGURE,
        ISM_MMC_CONFIGURE_CHILD,
        ISM_SECURITY_WIZARD,
        /* Don't move this one */
        ISM_NUM_METHODS
    };

    //
    // ISM Method VTable Definition
    //
    static ISM_METHOD_DEF s_imdMethods[ISM_NUM_METHODS];

//
// Construction/Destruction
//
public:
    //
    // Construct with DLL Name and a sequential unique
    // ID Number.
    //
    CServiceInfo(
        IN int nID,
        IN LPCTSTR lpDLLName
        );

    ~CServiceInfo();

//
// Access Functions
//
public:
    //
    // Get the instance handle
    //
    HINSTANCE QueryInstanceHandle() const { return m_hModule; }

    //
    // Get the ISM version number
    //
    DWORD QueryISMVersion() const { return m_si.dwVersion; }

    //
    // Get the discovery mask
    //
    ULONGLONG QueryDiscoveryMask() const { return m_si.ullDiscoveryMask; }

    //
    // Get toolbar background button mask for this service
    //
    COLORREF QueryButtonBkMask() const { return m_si.rgbButtonBkMask; }

    //
    // Get toolbar button bitmap id for this service
    //
    UINT QueryButtonBitmapID() const { return m_si.nButtonBitmapID; }

    //
    // Get the colour background mask for this service
    //
    COLORREF QueryServiceBkMask() const { return m_si.rgbServiceBkMask; }

    //
    // Get the resource ID for the service bitmap for this service
    //
    UINT QueryServiceBitmapID() const { return m_si.nServiceBitmapID; }

    //
    // Return TRUE if the service has 32x32 bitmap id
    //
    BOOL HasLargeServiceBitmapID() const { return m_si.nLargeServiceBitmapID != 0; }

    //
    // Get the large service bitmap background colour mask
    //
    COLORREF QueryLargeServiceBkMask() const { return m_si.rgbLargeServiceBkMask; }

    //
    // Get the resource ID of the large service bitmap
    //
    UINT QueryLargeServiceBitmapID() const { return m_si.nLargeServiceBitmapID; }

    //
    // Get the colour background mask for the child bitmap
    //
    COLORREF QueryChildBkMask() const { return m_si.rgbChildBkMask; }

    //
    // Get the bitmap ID for a child node
    //
    UINT QueryChildBitmapID() const { return m_si.nChildBitmapID; }

    //
    // Get the background colour mask for the large child bitmap
    //
    COLORREF QueryLargeChildBkMask() const { return m_si.rgbLargeChildBkMask; }

    //
    // Get the resource ID for the large child bitmap
    //
    UINT QueryLargeChildBitmapID() const { return m_si.nLargeChildBitmapID; }

    //
    // Get the ID assigned to this service
    //
    int QueryServiceID() const { return m_nID; }

    //
    // Get the short name for this service
    //
    LPCTSTR GetShortName() const { return m_si.atchShortName; }

    //
    // Get the longer name for this service
    //
    LPCTSTR GetLongName() const { return m_si.atchLongName; }

    //
    // Get the protocol for this service (if any)
    //
    LPCTSTR GetProtocol() const { return m_si.atchProtocol; }

    //
    // Get the metabase service name (if any)
    //
    LPCTSTR GetMetabaseName() const { return m_si.atchMetaBaseName; }

//
// Access Service Type Functions
//
public:
    //
    // TRUE if the service is a downlevel replacement service
    //
    BOOL RequiresSuperDll() const { return !m_strSupDLLName.IsEmpty(); }
    BOOL IsSuperDllFor(CServiceInfo * pTarget) const;
    BOOL HasSuperDll() const { return m_psiMaster != NULL; }
    void AssignSuperDll(CServiceInfo * pTarget);
    CServiceInfo * GetSuperDll();
    LPCTSTR QueryDllName() const { return m_strDLLName; }

    BOOL UseInetSlocDiscover() const;

    //
    // Return TRUE if the service is controllable
    //
    BOOL CanControlService() const;

    //
    // Return TRUE if the service is pausable
    //
    BOOL CanPauseService() const;

    //
    // Return TRUE if the service and toolbar bitmaps use default
    // background colour mapping (the background colour masks
    // will be ignored)
    //
    BOOL UseNormalColorMapping() const;

    //
    // True if the service supports file and directory properties
    //
    BOOL SupportsFileSystem() const;

    //
    // Does the service support Instances
    //
    BOOL SupportsInstances() const;

    //
    // Does the service support children
    //
    BOOL SupportsChildren() const;

    //
    // TRUE if the service supports the security wizard
    //
    BOOL SupportsSecurityWizard() const;

    //
    // Does the service understance instance ID codes
    // -- eventhough it may not actually support
    // instances
    //
    BOOL UnderstandsInstanceCodes() const;

    //
    // TRUE if the service supports prot://address browsing
    //
    BOOL HasWebProtocol() const;

    //
    // Use MMC property pages to show the property sheet for this
    // service?
    //
    BOOL SupportsMMC() const;

    //
    // Does the service support the extended K2 services?
    //
    BOOL IsK2Service() const;

    //
    // Is this service currently selected to be in
    // the service view?
    //
    BOOL IsSelected() const { return m_fIsSelected; }

    //
    // Select/Deselect this service
    //
    void SelectService(
        IN BOOL fSelected = TRUE
        );

    //
    // Get error return code
    //
    HRESULT QueryReturnCode() const { return m_hrReturnCode; }

    //
    // Was the module loaded, and all function ptrs initialised?
    //
    BOOL InitializedOK() const { return SUCCEEDED(m_hrReturnCode); }

//
// The bitmap indices refer to the index in inetmgr's
// master image list where they are stored, and have nothing
// to do with the resource IDs
//
public:
    //
    // Get the inetmgr assigned index for the service bitmap
    //
    int QueryBitmapIndex() const { return m_iBmpID; }

    //
    // Get the inetmgr assigned index for the child
    //
    int QueryChildBitmapIndex() const { return m_iBmpChildID; }

    //
    // Assign the service bitmap index
    //
    void SetBitmapIndex(IN int iID);

    //
    // Assign the child bitmap index
    //
    void SetChildBitmapIndex(IN int iID);

//
// ISM API Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
public:

    //
    // Return service-specific information back to
    // to the application.  This function is called
    // by the service manager immediately after
    // LoadLibary();
    //
    DWORD ISMQueryServiceInfo(
        OUT ISMSERVICEINFO * psi        // Service information returned.
        );

    //
    // Perform a discovery (if not using inetsloc discovery)
    // The application will call this API the first time with
    // a BufferSize of 0, which should return the required buffer
    // size. Next it will attempt to allocate a buffer of that
    // size, and then pass a pointer to that buffer to the api.
    //
    DWORD ISMDiscoverServers(
        OUT ISMSERVERINFO * psi,        // Server info buffer.
        IN  OUT DWORD * pdwBufferSize,  // Size required/available.
        OUT int * cServers              // Number of servers in buffer.
        );

    //
    // Get information on a single server with regards to
    // this service.
    //
    DWORD ISMQueryServerInfo(
        IN  LPCTSTR lpszServerName,     // Name of server.
        OUT ISMSERVERINFO * psi         // Server information returned.
        );

    //
    // Change the state of the service (started, stopped, paused) for the
    // listed servers.
    //
    DWORD ISMChangeServiceState(
        IN  int   nNewState,            // INetService* definition.
        OUT int * pnCurrentState,       // Current state information
        IN  DWORD dwInstance,           // /* K2 */ -- Instance number
                                        // (0 - for non-instance)
        IN  LPCTSTR lpszServers         // Double NULL terminated list of servers.
        );

    //
    // The big-one:  Show the configuration dialog or
    // property sheets, whatever, and allow the user
    // to make changes as needed.
    //
    DWORD ISMConfigureServers(
        IN HWND hWnd,                   // Main app window handle
        IN DWORD dwInstance,            // /* K2 */ -- Instance number
                                        // (0 - for non-instance)
        IN LPCTSTR lpszServers          // Double NULL terminated list of servers
        );

    ///////////////////////////////////////////////////////////////////////////
    //                                                                       //
    // K2 Methods Below                                                      //
    //                                                                       //
    ///////////////////////////////////////////////////////////////////////////

    //
    // Bind to a server, and return a HANDLE.  This handle is 
    // merely an opaque identifier that's meaningful to the 
    // service configuration module.
    //
    HRESULT ISMBind(
        IN  LPCTSTR lpszServer,         // Server name
        OUT HANDLE *phServer            // Returns handle
        );

    //
    // Sever the connection.  The service configuration
    // module does whatever needs to be done to cleanup
    //
    HRESULT ISMUnbind(
        IN HANDLE hServer               // Server handle
        );

    //
    // Enumerate instances
    //
    HRESULT ISMEnumerateInstances(
        IN HANDLE hServer,              // Server handle
        IN OUT ISMINSTANCEINFO * pii,   // Instance info buffer
        IN OUT HANDLE * pdwEnum         // Enumeration handle
        );

    //
    // Add an instance
    //
    HRESULT ISMAddInstance(
        IN HANDLE  hServer,             // Server handle
        IN DWORD   dwSourceInstance,    // Source instance ID to clone
        OUT ISMINSTANCEINFO * pii,      // Instance info buffer.  May be NULL
        IN DWORD   dwBufferSize         // Size of buffer
        );

    //
    // Delete an instance
    //
    HRESULT ISMDeleteInstance(
        IN HANDLE hServer,              // Server handle
        IN DWORD  dwInstance            // Instance to be deleted
        );

    //
    // Get instance specific information.
    //
    HRESULT ISMQueryInstanceInfo(
        IN  HANDLE hServer,             // Server handle
        IN  BOOL   fInherit,            // TRUE to inherit, FALSE otherwise
        OUT ISMINSTANCEINFO * pii,      // Instance info buffer
        IN  DWORD   dwInstance          // Instance number
        );

    //
    // Enumerate children.  
    //
    HRESULT ISMEnumerateChildren(
        IN HANDLE hServer,              // Server handle
        IN OUT ISMCHILDINFO * pii,      // Child info buffer
        IN OUT HANDLE * phEnum,         // Enumeration handle
        IN DWORD   dwInstance,          // Instance
        IN LPCTSTR lpszParent           // Parent path
        );

    //
    // Add a child
    //
    HRESULT ISMAddChild(
        IN  HANDLE  hServer,            // Server handle
        OUT ISMCHILDINFO * pii,         // Child info buffer
        IN  DWORD   dwBufferSize,       // Size of info buffer
        IN  DWORD   dwInstance,         // Parent instance
        IN  LPCTSTR lpszParent          // Parent path
        );

    //
    // Delete a child
    //
    HRESULT ISMDeleteChild(
        IN HANDLE  hServer,             // Server handle
        IN DWORD   dwInstance,          // Parent instance
        IN LPCTSTR lpszParent,          // Parent path
        IN LPCTSTR lpszAlias            // Alias of child to be deleted
        );

    //
    // Rename a child
    //
    HRESULT ISMRenameChild(
        IN HANDLE  hServer,             // Server handle
        IN DWORD   dwInstance,          // Parent instance
        IN LPCTSTR lpszParent,          // Parent path
        IN LPCTSTR lpszAlias,           // Alias of child to be renamed
        IN LPCTSTR lpszNewName          // New alias of child
        );

    //
    // Configure Child
    //
    HRESULT ISMConfigureChild(
        IN HANDLE  hServer,             // Server handle
        IN HWND    hWnd,                // Main app window handle
        IN DWORD   dwAttributes,        // Child attributes
        IN DWORD   dwInstance,          // Parent instance
        IN LPCTSTR lpszParent,          // Parent path
        IN LPCTSTR lpszAlias            // Child alias
        );

    //
    // Get child-specific info
    //
    HRESULT ISMQueryChildInfo(
        IN  HANDLE  hServer,            // Server handle
        IN  BOOL    fInherit,           // TRUE to inherit, FALSE otherwise
        OUT ISMCHILDINFO * pii,         // Child info buffer
        IN  DWORD   dwInstance,         // Parent instance
        IN  LPCTSTR lpszParent,         // Parent Path ("" for root)
        IN  LPCTSTR lpszAlias           // Alias of child to be deleted
        );

    //
    // Configure servers using MMC property pages
    //
    HRESULT ISMMMCConfigureServers(
        IN HANDLE hServer,              // Server handle
        IN PVOID lpfnProvider,          // MMC Parameter
        IN LPARAM param,                // MMC Parameter
        IN LONG_PTR handle,              // MMC Parameter
        IN DWORD dwInstance             // Instance number
        );

    //
    // Configure Child using MMC property pages
    //
    HRESULT ISMMMCConfigureChild(
        IN HANDLE  hServer,             // Server handle
        IN PVOID   lpfnProvider,        // MMC Parameter
        IN LPARAM  param,               // MMC Parameter
        IN LONG_PTR handle,              // MMC Parameter
        IN DWORD   dwAttributes,        // Child attributes
        IN DWORD   dwInstance,          // Parent instance
        IN LPCTSTR lpszParent,          // Parent path
        IN LPCTSTR lpszAlias            // Child alias
        );

    //
    // Launch security wizard
    //
    HRESULT ISMSecurityWizard(
        HANDLE  hServer,            // Server handle
        DWORD   dwInstance,         // Instance number
        LPCTSTR lpszParent,         // Parent path
        LPCTSTR lpszAlias           // Child alias name
        );

//
// Function Pointers
//
protected:

#ifdef USE_VTABLE

    //
    // ISM Method VTable
    //
    pfnISMMethod              m_rgpfnISMMethods[ISM_NUM_METHODS];

#else // !USE_VTABLE

    //
    // ISM Api Function pointers
    //
    pfnQueryServiceInfo       m_pfnQueryServiceInfo;
    pfnDiscoverServers        m_pfnDiscoverServers;
    pfnQueryServerInfo        m_pfnQueryServerInfo;
    pfnChangeServiceState     m_pfnChangeServiceState;
    pfnConfigure              m_pfnConfigure;
    pfnBind                   m_pfnBind;
    pfnUnbind                 m_pfnUnbind;
    pfnConfigureChild         m_pfnConfigureChild;
    pfnEnumerateInstances     m_pfnEnumerateInstances;
    pfnEnumerateChildren      m_pfnEnumerateChildren;
    pfnAddInstance            m_pfnAddInstance;
    pfnDeleteInstance         m_pfnDeleteInstance;
    pfnAddChild               m_pfnAddChild;
    pfnDeleteChild            m_pfnDeleteChild;
    pfnRenameChild            m_pfnRenameChild;
    pfnQueryInstanceInfo      m_pfnQueryInstanceInfo;
    pfnQueryChildInfo         m_pfnQueryChildInfo;
    pfnISMMMCConfigureServers m_pfnISMMMCConfigureServers;
    pfnISMMMCConfigureChild   m_pfnISMMMCConfigureChild;
    pfnISMSecurityWizard      m_pfnISMSecurityWizard;

#endif //  USE_VTABLE

protected:
    static LPCTSTR            s_cszSupcfg;

protected:
    CServiceInfo *            m_psiMaster;

private:
    int m_nID;                      // Service ID
    int m_iBmpID;                   // Bitmap ID index
    int m_iBmpChildID;              // Child bitmap ID index
    CString m_strDLLName;           // DLL Name
    CString m_strSupDLLName;        // Superceed configuration DLL name.
    ISMSERVICEINFO m_si;            // Service Info.
    HINSTANCE m_hModule;            // Library handle
    HRESULT m_hrReturnCode;
    BOOL    m_fIsSelected;
};



class CNewInstanceCmd : public CObjectPlus
/*++

Class Description:

    New instance command object.  MMC adds these items at the machine
    node level for create new.

Public Interface:

    CNewInstanceCmd     : Constructor

    GetServiceInfo      : Get the service info object
    GetMenuCommand      : Get the menu command that describes this object
    GetTTText           : Get the tool tips text

--*/
{
public:
    CNewInstanceCmd(
        IN CServiceInfo * pServiceInfo
        );

public:
    CServiceInfo * GetServiceInfo() { return m_pServiceInfo; }
    CString & GetMenuCommand() { return m_strMenuCommand; }
    CString & GetTTText() { return m_strTTText; }

    HINSTANCE QueryInstanceHandle();

private:
    CServiceInfo * m_pServiceInfo;
    CString m_strMenuCommand;
    CString m_strTTText;
};



class CServerInfo : public CObjectPlus
{
/*++

Class Description:

    Server info class.  Each object describes a single server/service
    relationship.

Public Interface:

    CServerInfo              : Various constructors
    ~CServerInfo             : Destructor

    operator=                : Assignment operator
    CompareByServer          : Comparison function to compare server names
    CompareByService         : Comparison function to compare services
    operator ==              : Comparison operator
    CleanServerName          : Static function to clean up a computer/hostname
    ConfigureServer          : Configure instance on this this server
    ConfigureChild           : Configure child on this server
    ChangeServiceState       : Change the server or instance state
    QueryServerName          : Return the API-suitable name
    QueryServerDisplayName   : Get the display name of the server
    GetServerComment         : Get the server comment
    GetServiceStatePtr       : Get service state pointer
    QueryServiceState        : Find out service state (running,
                               paused, stopped, unknown)
    IsServiceRunning         : TRUE if the service is running
    IsServiceStopped         : TRUE if the service is stopped
    IsServicePaused          : TRUE if the service is paused
    IsServiceStatusUnknown   : TRUE if the service status cannot be determined
    IsConfigurable           : TRUE if the service is configurable

    QueryInstanceHandle      : Get the config DLL instance handle
    IsServiceSelected        : TRUE if the service is selected in the toolbar
    GetServiceName           : Get the (short) service name.
    QueryServiceID           : Get ID code assigned to the config DLL
    CanControlService        : TRUE if this service controllable
    CanPauseService          : TRUE if this service is pausable
    SupportsInstances        : TRUE if the service supports instances
    SupportsChildren         : TRUE if the service supports children
    UnderstandsInstanceCodes : TRUE if the service understands instance IDs
    QueryServiceBitmapID     : Get the bitmap resource ID of the service
    Refresh                  : Refresh information

--*/
//
// Construction/Destruction
//
public:
    //
    // Construct with a server name.  This is typically
    // in response to a single connection attempt.
    //
    CServerInfo(
        IN  LPCTSTR lpszServerName,      // Name of this server
        OUT ISMSERVERINFO * psi,         // Server info
        IN  CServiceInfo * pServiceInfo  // service that found it.
        );

    //
    // Construct with information from the inetsloc discover
    // process.
    //
    CServerInfo(
        IN LPCSTR lpszServerName,        // Name of this server
        IN LPINET_SERVICE_INFO lpisi,    // Discovery information
        IN CObListPlus & oblServices     // List of installed services
        );

    //
    // Copy constructor
    //
    CServerInfo(
        IN const CServerInfo &si
        );

    ~CServerInfo();

    //
    // Assignment operator
    //
    const CServerInfo & operator=(
        IN const CServerInfo &si
        );

    //
    // Comparison Functions and operators
    //
    int CompareByServer(IN CServerInfo * psi) const;

    //
    // Compare server names
    //
    BOOL MatchServerName(IN LPCTSTR lpszServerName) const;

    //
    // Compare two services
    //
    int CompareByService(IN CServerInfo * psi);

    //
    // Compare two service
    //
    BOOL operator ==(
        IN CServerInfo & si
        );

public:
    //
    // Utility function to clean up a computer/hostname
    //
    static LPCTSTR CleanServerName(
        IN CString & str
        );

//
// Server Info Access Functions
//
public:
    //
    // Perform configuration on this server
    //
    DWORD ConfigureServer(
        IN HWND  hWnd,                          // Window handle
        IN DWORD dwInstance = MASTER_INSTANCE   // Instance number
        );

    //
    // Configure servers using MMC property pages
    //
    HRESULT MMMCConfigureServer(
        IN PVOID   lpfnProvider,                // MMC Parameter
        IN LPARAM  param,                       // MMC Parameter
        IN LONG_PTR handle,                      // MMC Parameter
        IN DWORD   dwInstance                   // Instance number
        );

    //
    // Perform configuration on a child
    //
    HRESULT ConfigureChild(
        IN HWND    hWnd,                        // Window handle
        IN DWORD   dwAttributes,                // Child attributes
        IN DWORD   dwInstance,                  // Parent instance
        IN LPCTSTR lpszParent,                  // Parent path
        IN LPCTSTR lpszAlias                    // Child alias
        );

    //
    // Perform configuration on a child using MMC property pages
    //
    HRESULT MMCConfigureChild(
        IN PVOID   lpfnProvider,                // MMC parameter
        IN LPARAM  param,                       // MMC parameter
        IN LONG_PTR handle,                      // MMC parameter
        IN DWORD   dwAttributes,                // Child attributes
        IN DWORD   dwInstance,                  // Instance number
        IN LPCTSTR lpszParent,                  // Parent path
        IN LPCTSTR lpszAlias                    // Child alias
        );

    //
    // Rename a child node
    //
    HRESULT RenameChild(
        IN DWORD   dwInstance,                  // Parent instance
        IN LPCTSTR lpszParent,                  // Parent path
        IN LPCTSTR lpszAlias,                   // Alias of child to be renamed
        IN LPCTSTR lpszNewName                  // New alias of child
        );

    //
    // Add a child
    //
    HRESULT AddChild(
        IN ISMCHILDINFO * pii,                  // Child info buffer or NULL
        IN DWORD   dwBufferSize,                // Size of info buffer
        IN DWORD   dwInstance,                  // Parent instance
        IN LPCTSTR lpszParent                   // Parent Path ("" for root)
        );

    //
    // Delete a child
    //
    HRESULT DeleteChild(
        IN DWORD   dwInstance,                  // Parent instance
        IN LPCTSTR lpszParent,                  // Parent Path ("" for root)
        IN LPCTSTR lpszAlias                    // Alias of child to be deleted
        );

    //
    // Get instance specific information
    //
    HRESULT QueryInstanceInfo(
        IN  BOOL   fInherit,                    // TRUE to inherit,
                                                // FALSE otherwise
        OUT ISMINSTANCEINFO * pii,              // Returns instance info
        IN  DWORD   dwInstance                  // Instance number
        );

    //
    // Get child specific information
    //
    HRESULT QueryChildInfo(
        IN  BOOL    fInherit,                   // TRUE to inherit, 
                                                // FALSE otherwise
        OUT ISMCHILDINFO * pii,                 // Returns child info
        IN  DWORD   dwInstance,                 // Instance number
        IN  LPCTSTR lpszParent,                 // Parent path
        IN  LPCTSTR lpszAlias                   // Alias name
        );

    //
    // Add an instance
    //
    HRESULT AddInstance(
        OUT ISMINSTANCEINFO * pii,              // Instance info buffer or NULL
        IN  DWORD   dwBufferSize                // Size of buffer
        );

    //
    // Delete an instance
    //
    HRESULT DeleteInstance(
        IN DWORD dwInstance                     // Instance to be deleted
        );

    //
    // Enumerate children.  
    //
    HRESULT ISMEnumerateChildren(
        IN OUT ISMCHILDINFO * pii,              // Child info buffer
        IN OUT HANDLE * phEnum,                 // Enumeration handle
        IN DWORD   dwInstance,                  // Instance
        IN LPCTSTR lpszParent                   // Parent path
        );

    //
    // Enumerate instances
    //
    HRESULT ISMEnumerateInstances(
        IN OUT ISMINSTANCEINFO * pii,           // Instance info buffer
        IN OUT HANDLE * pdwEnum                 // Enumeration handle
        );

    //
    // Launch security wizard
    //
    HRESULT ISMSecurityWizard(
        DWORD   dwInstance,         // Instance number
        LPCTSTR lpszParent,         // Parent path
        LPCTSTR lpszAlias           // Child alias name
        );

    //
    // Change service state
    //
    DWORD ChangeServiceState(
        IN  int nNewState,                      // New state to set
        OUT int * pnCurrentState,               // Returns current state
        IN  DWORD dwInstance = MASTER_INSTANCE  // Instance number
        );

    //
    // Return the API-suitable name (with
    // backslashes)
    //
    LPCTSTR QueryServerName() const { return (LPCTSTR)m_strServerName; }

    //
    // Return the name without backslashes,
    // suitable for display.
    //
    LPCTSTR QueryServerDisplayName() const;

    //
    // Obtain the server comment
    //
    CString & GetServerComment() { return m_strComment; }

    //
    // Allow modification
    //
    int * GetServiceStatePtr() { return &m_nServiceState; }

    //
    // Find out service state (running, stopped, paused)
    //
    int QueryServiceState() const { return m_nServiceState; }

    //
    // Return TRUE if the service is currently running
    //
    BOOL IsServiceRunning() const;

    //
    // Return TRUE if the service is currently stopped
    //
    BOOL IsServiceStopped() const;

    //
    // Return TRUE if the service is currently paused
    //
    BOOL IsServicePaused() const;

    //
    // Return TRUE if the service status is unknown
    //
    BOOL IsServiceStatusUnknown() const;

    //
    // Were we able to match it up to one of our installed services?
    //
    BOOL IsConfigurable() const { return m_pService != NULL; }

//
// Service Info Access Functions
//
public:

    //
    // Attempt to rebind lost connection...
    //
    HRESULT ISMRebind();

    //
    // Get the service info object
    //
    CServiceInfo * GetServiceInfo() { return m_pService; }

    //
    // Get the short name for this service
    //
    LPCTSTR GetShortName() const;

    //
    // Get the longer name for this service
    //
    LPCTSTR GetLongName() const;

    //
    // Get Server Handle
    //
    HANDLE GetHandle() { return m_hServer; }

    //
    // Get the protocol for this service (if any)
    //
    LPCTSTR GetProtocol() const;

    //
    // Get the metabase name for this service (if any)
    //
    LPCTSTR GetMetabaseName() const;

    //
    // Get the instance handle for the dll
    //
    HINSTANCE QueryInstanceHandle();

    //
    // Check to see if we're in the service mask -- that
    // is, is the button depressed, and should we show
    // this service in the view?
    //
    BOOL IsServiceSelected() const;

    //
    // Get the (short) service name.
    //
    LPCTSTR GetServiceName() const;

    //
    // Get the assigned service ID
    //
    int QueryServiceID() const;

    //
    // Get the assigned bitmap index for this service
    //
    int QueryBitmapIndex() const;

    //
    // Get the assigned child bitmap index
    //
    int QueryChildBitmapIndex() const;

    //
    // Is this service controllable?
    //
    BOOL CanControlService() const;

    //
    // Is the service pausable?
    //
    BOOL CanPauseService() const;

    //
    // Does the service support instances?
    //
    BOOL SupportsInstances() const;

    //
    // Does the service support children?
    //
    BOOL SupportsChildren() const;

    //
    // Use file system?
    //
    BOOL SupportsFileSystem() const;

    //
    // TRUE if the service supports a security wizard
    //
    BOOL SupportsSecurityWizard() const;

    //
    // Does the service understance instance ID codes
    // -- eventhough it may not actually support
    // instances
    //
    BOOL UnderstandsInstanceCodes() const;

    //
    // TRUE if the service supports prot://address browsing
    //
    BOOL HasWebProtocol() const;

    //
    // Use MMC property pages to show the property sheet for this
    // service?
    //
    BOOL SupportsMMC() const;

    //
    // Does the service support the extended K2 services?
    //
    BOOL IsK2Service() const;

    //
    // Get the service bitmap ID (used for display
    // in some views)
    //
    UINT QueryServiceBitmapID() const;

    //
    // Refresh information
    //
    DWORD Refresh();

protected:
    //
    // Given the inetsloc mask, return the service this
    // fits.  Return NULL if the service was not found.
    //
    static CServiceInfo * FindServiceByMask(
        ULONGLONG ullTarget,
        CObListPlus & oblServices
        );

private:
    //
    // Name is maintained in API friendly format
    //
    CString m_strServerName;

    //
    // Maintain  server handle for K2 services
    //
    HANDLE  m_hServer;

    //
    // comment
    //
    CString m_strComment;

    //
    // Service state (started/stopped/paused)
    //
    int m_nServiceState;

    //
    // A pointer referring back to the service that
    // it belongs to.  This class does not own
    // this pointer.
    //
    CServiceInfo * m_pService;
};



class CSnapinApp : public CWinApp
/*++

Class Description:

    Main app object

Public Interface:

    InitInstance        : Instance initiation handler
    ExitInstance        : Exit instance handler

--*/
{
//
// Initialization
//
public:
    CSnapinApp();

public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();

//
// Access
//
public:
    void SetHelpPath(CServerInfo * pItem = NULL);
    LPCTSTR QueryInetMgrHelpPath() const { return m_strInetMgrHelpPath; }

protected:
    //{{AFX_MSG(CSnapinApp)
    afx_msg void OnHelp();
    afx_msg void OnContextHelp();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    LPCTSTR m_lpOriginalHelpPath;
    CString m_strHelpPath;
    CString m_strInetMgrHelpPath;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CServiceInfo::IsSuperDllFor(CServiceInfo * pTarget) const
{
    return pTarget->m_strSupDLLName.CompareNoCase(m_strDLLName) == 0;
}

inline void CServiceInfo::AssignSuperDll(CServiceInfo * pTarget)
{
    ASSERT(m_psiMaster == NULL);
    m_psiMaster = pTarget;
}

inline CServiceInfo * CServiceInfo::GetSuperDll()
{
    ASSERT(m_psiMaster != NULL);
    return m_psiMaster;
}

inline BOOL CServiceInfo::UseInetSlocDiscover() const
{
    return (m_si.flServiceInfoFlags & ISMI_INETSLOCDISCOVER) != 0;
}

inline BOOL CServiceInfo::CanControlService() const
{
    return (m_si.flServiceInfoFlags & ISMI_CANCONTROLSERVICE) != 0;
}

inline BOOL CServiceInfo::CanPauseService() const
{
    return (m_si.flServiceInfoFlags & ISMI_CANPAUSESERVICE) != 0;
}

inline BOOL CServiceInfo::UseNormalColorMapping() const
{
    return (m_si.flServiceInfoFlags & ISMI_NORMALTBMAPPING) != 0;
}

inline BOOL CServiceInfo::SupportsFileSystem() const
{
    return (m_si.flServiceInfoFlags & ISMI_FILESYSTEM) != 0;
}

inline BOOL CServiceInfo::SupportsSecurityWizard() const
{
    return (m_si.flServiceInfoFlags & ISMI_SECURITYWIZARD) != 0;
}

inline BOOL CServiceInfo::SupportsInstances() const
{
    return (m_si.flServiceInfoFlags & ISMI_INSTANCES) != 0;
}

inline BOOL CServiceInfo::SupportsChildren() const
{
    return (m_si.flServiceInfoFlags & ISMI_CHILDREN) != 0;
}

inline BOOL CServiceInfo::UnderstandsInstanceCodes() const
{
    return (m_si.flServiceInfoFlags & ISMI_UNDERSTANDINSTANCE) != 0;
}

inline BOOL CServiceInfo::HasWebProtocol() const
{
    return (m_si.flServiceInfoFlags & ISMI_HASWEBPROTOCOL) != 0;
}

inline BOOL CServiceInfo::SupportsMMC() const
{
#ifdef USE_VTABLE
    return m_rgpfnISMMethods[ISM_MMC_CONFIGURE] != NULL;
#else
    return m_pfnISMMMCConfigureServers != NULL;
#endif // USE_VTABLE
}

inline BOOL CServiceInfo::IsK2Service() const
{
#ifdef USE_VTABLE
    return m_rgpfnISMMethods[ISM_BIND] != NULL;
#else
    return m_pfnBind != NULL;
#endif // USE_VTABLE
}

inline void CServiceInfo::SelectService(BOOL fSelected)
{
    m_fIsSelected = fSelected;
}

#ifdef USE_VTABLE

//
// Helper Macros to access VTable
//
#define ISM_VTABLE_ENTRY(iID)\
    (m_rgpfnISMMethods[iID] != NULL)

#define ISM_NO_VTABLE_ENTRY(iID)\
    (m_rgpfnISMMethods[iID] == NULL)

#define ASSERT_VTABLE_ENTRY(iID)\
    ASSERT(iID >= 0 && iID < ISM_NUM_METHODS);\
    ASSERT(ISM_VTABLE_ENTRY(iID));

#define ISM_VTABLE(iID)\
    (*m_rgpfnISMMethods[iID])

inline DWORD CServiceInfo::ISMDiscoverServers(
    OUT ISMSERVERINFO * psi,        
    IN  OUT DWORD * pdwBufferSize,  
    OUT int * pcServers             
    )
{
    ASSERT_VTABLE_ENTRY(ISM_DISCOVER_SERVERS);
    return ISM_VTABLE(ISM_DISCOVER_SERVERS)(
        psi,
        pdwBufferSize,
        pcServers
        );
}

inline DWORD CServiceInfo::ISMChangeServiceState(
    IN  int     nNewState,            
    OUT int *   pnCurrentState,       
    IN  DWORD   dwInstance,           
    IN  LPCTSTR lpszServers       
    )
{
    ASSERT_VTABLE_ENTRY(ISM_CHANGE_SERVICE_STATE);
    return ISM_VTABLE(ISM_CHANGE_SERVICE_STATE)(
        nNewState,
        pnCurrentState,
        dwInstance,
        lpszServers
        );
}

inline DWORD CServiceInfo::ISMConfigureServers(
    IN HWND    hWnd,          
    IN DWORD   dwInstance,   
    IN LPCTSTR lpszServers 
    )
{
    ASSERT_VTABLE_ENTRY(ISM_CONFIGURE);
    return ISM_VTABLE(ISM_CONFIGURE)(
        hWnd,
        dwInstance,
        lpszServers
        );
}

inline HRESULT CServiceInfo::ISMBind(
    IN  LPCTSTR lpszServer,
    OUT HANDLE *phServer   
    )
{
    ASSERT_VTABLE_ENTRY(ISM_BIND);
    return ISM_VTABLE(ISM_BIND)(lpszServer, phServer);
}

inline HRESULT CServiceInfo::ISMUnbind(
    IN HANDLE hServer   
    )
{
    ASSERT_VTABLE_ENTRY(ISM_UNBIND);
    return ISM_VTABLE(ISM_UNBIND)(hServer);
}

inline HRESULT CServiceInfo::ISMEnumerateInstances(
    IN HANDLE hServer,
    IN OUT ISMINSTANCEINFO * pii,
    IN OUT HANDLE * phEnum
    )
{
    ASSERT_VTABLE_ENTRY(ISM_ENUMERATE_INSTANCES);
    return ISM_VTABLE(ISM_ENUMERATE_INSTANCES)(
        hServer,
        pii,
        phEnum
        );
}

inline HRESULT CServiceInfo::ISMAddInstance(
    IN  HANDLE  hServer,
    IN  DWORD   dwSourceInstance,     
    OUT ISMINSTANCEINFO * pii,      
    IN  DWORD   dwBufferSize       
    )
{
    ASSERT_VTABLE_ENTRY(ISM_ADD_INSTANCE);
    return ISM_VTABLE(ISM_ADD_INSTANCE)(
        hServer,
        dwSourceInstance,
        pii,
        dwBufferSize
        );
}

inline HRESULT CServiceInfo::ISMDeleteInstance(
    IN HANDLE hServer,
    IN DWORD  dwInstance          
    )
{
    ASSERT_VTABLE_ENTRY(ISM_DELETE_INSTANCE);
    return ISM_VTABLE(ISM_DELETE_INSTANCE)(
        hServer,
        dwInstance
        );
}

inline HRESULT CServiceInfo::ISMQueryInstanceInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,            
    OUT ISMINSTANCEINFO * pii,
    IN  DWORD   dwInstance    
    )
{
    ASSERT_VTABLE_ENTRY(ISM_QUERY_INSTANCE_INFO);
    return ISM_VTABLE(ISM_QUERY_INSTANCE_INFO)(
        hServer,
        fInherit,
        pii,
        dwInstance
        );
}

inline HRESULT CServiceInfo::ISMEnumerateChildren(
    IN HANDLE hServer,
    IN OUT ISMCHILDINFO * pii,
    IN OUT HANDLE * pdwEnum,  
    IN DWORD   dwInstance,    
    IN LPCTSTR lpszParent     
    )
{
    ASSERT_VTABLE_ENTRY(ISM_ENUMERATE_CHILDREN);
    return ISM_VTABLE(ISM_ENUMERATE_CHILDREN)(
        hServer,
        pii,
        pdwEnum,
        dwInstance,
        lpszParent
        );
}

inline HRESULT CServiceInfo::ISMQueryChildInfo(
    IN  HANDLE  hServer,
    IN  BOOL   fInherit,            
    OUT ISMCHILDINFO * pii,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent,
    IN  LPCTSTR lpszAlias  
    )
{
    ASSERT_VTABLE_ENTRY(ISM_QUERY_CHILD_INFO);
    return ISM_VTABLE(ISM_QUERY_CHILD_INFO)(
        hServer,
        fInherit,
        pii,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMConfigureChild(
    IN HANDLE  hServer,
    IN HWND    hWnd,         
    IN DWORD   dwAttributes, 
    IN DWORD   dwInstance,   
    IN LPCTSTR lpszParent,   
    IN LPCTSTR lpszAlias     
    )
{
    ASSERT_VTABLE_ENTRY(ISM_CONFIGURE_CHILD);
    return ISM_VTABLE(ISM_CONFIGURE_CHILD)(
        hServer,
        hWnd,
        dwAttributes,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMAddChild(
    IN  HANDLE  hServer,
    OUT ISMCHILDINFO * pii,  
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwInstance, 
    IN  LPCTSTR lpszParent  
    )
{
    ASSERT_VTABLE_ENTRY(ISM_ADD_CHILD);
    return ISM_VTABLE(ISM_ADD_CHILD)(
        hServer,
        pii,
        dwBufferSize,
        dwInstance,
        lpszParent
        );
}

inline HRESULT CServiceInfo::ISMSecurityWizard(
    HANDLE  hServer,            
    DWORD   dwInstance,         
    LPCTSTR lpszParent,         
    LPCTSTR lpszAlias           
    )
{
    ASSERT_VTABLE_ENTRY(ISM_SECURITY_WIZARD);
    return ISM_VTABLE(ISM_SECURITY_WIZARD)(
        hServer,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMDeleteChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,   
    IN LPCTSTR lpszParent,   
    IN LPCTSTR lpszAlias     
    )
{
    ASSERT_VTABLE_ENTRY(ISM_DELETE_CHILD);
    return ISM_VTABLE(ISM_DELETE_CHILD)(
        hServer,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMRenameChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,   
    IN LPCTSTR lpszParent,   
    IN LPCTSTR lpszAlias,    
    IN LPCTSTR lpszNewAlias  
    )
{
    ASSERT_VTABLE_ENTRY(ISM_RENAME_CHILD);
    return ISM_VTABLE(ISM_RENAME_CHILD)(
        hServer,
        dwInstance,
        lpszParent,
        lpszAlias,
        lpszNewAlias
        );
}

inline HRESULT CServiceInfo::ISMMMCConfigureServers(
    IN HANDLE  hServer,
    IN PVOID   lpfnProvider,          
    IN LPARAM  param,                
    IN LONG_PTR handle,              
    IN DWORD   dwInstance            
    )
{
    ASSERT_VTABLE_ENTRY(ISM_MMC_CONFIGURE);
    return ISM_VTABLE(ISM_MMC_CONFIGURE)(
        hServer,
        lpfnProvider,
        param,
        handle,
        dwInstance
        );
}

inline HRESULT CServiceInfo::ISMMMCConfigureChild(
    IN HANDLE  hServer,
    IN PVOID   lpfnProvider, 
    IN LPARAM  param,        
    IN LONG_PTR handle,       
    IN DWORD   dwAttributes, 
    IN DWORD   dwInstance,   
    IN LPCTSTR lpszParent,   
    IN LPCTSTR lpszAlias     
    )
{
    ASSERT_VTABLE_ENTRY(ISM_MMC_CONFIGURE_CHILD);
    return ISM_VTABLE(ISM_MMC_CONFIGURE_CHILD)(
        hServer,
        lpfnProvider,
        param,
        handle,
        dwAttributes,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

#else ! USE_VTABLE



inline DWORD CServiceInfo::ISMDiscoverServers(
    OUT ISMSERVERINFO * psi,        
    IN  OUT DWORD * pdwBufferSize,      
    OUT int * pcServers             
    )
{
    ASSERT(m_pfnDiscoverServers != NULL);
    return (*m_pfnDiscoverServers)(psi, pdwBufferSize, pcServers);
}

inline DWORD CServiceInfo::ISMChangeServiceState(
    IN  int nNewState,              
    OUT int * pnCurrentState,       
    IN  DWORD dwInstance,           
    IN  LPCTSTR lpszServers        
    )
{
    ASSERT(m_pfnChangeServiceState != NULL);
    return (*m_pfnChangeServiceState)(
        nNewState,
        pnCurrentState, 
        dwInstance, 
        lpszServers
        );
}

inline DWORD CServiceInfo::ISMConfigureServers(
    IN HWND hWnd,          
    IN DWORD dwInstance,   
    IN LPCTSTR lpszServers
    )
{
    ASSERT(m_pfnConfigure != NULL);
    return (*m_pfnConfigure)(hWnd, dwInstance, lpszServers);
}


inline HRESULT CServiceInfo::ISMBind(
    IN  LPCTSTR lpszServer,         
    OUT HANDLE *phServer            
    )
{
    ASSERT(m_pfnBind != NULL);
    return (*m_pfnBind)(lpszServer, phServer);
}

inline HRESULT CServiceInfo::ISMUnbind(
    IN HANDLE hServer               
    )
{
    ASSERT(m_pfnUnbind != NULL);
    return (*m_pfnUnbind)(hServer);
}

inline HRESULT CServiceInfo::ISMEnumerateInstances(
    IN HANDLE hServer,
    IN OUT ISMINSTANCEINFO * pii,  
    IN OUT HANDLE * phEnum
    )
{
    ASSERT(m_pfnEnumerateInstances != NULL);
    return (*m_pfnEnumerateInstances)(hServer, pii, phEnum);
}

inline HRESULT CServiceInfo::ISMEnumerateChildren(
    IN HANDLE hServer,
    IN OUT ISMCHILDINFO * pii,    
    IN OUT HANDLE * phEnum, 
    IN DWORD dwInstance,          
    IN LPCTSTR lpszParent        
    )
{
    ASSERT(m_pfnEnumerateChildren != NULL);
    return (*m_pfnEnumerateChildren)(
        hServer,
        pii,
        phEnum,
        dwInstance,
        lpszParent
        );
}

inline HRESULT CServiceInfo::ISMConfigureChild(
    IN HANDLE  hServer,
    IN HWND    hWnd,                  
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
{
    ASSERT(m_pfnConfigureChild != NULL);
    return (*m_pfnConfigureChild)(
        hServer,
        hWnd, 
        dwAttributes,
        dwInstance, 
        lpszParent, 
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMAddInstance(
    IN  HANDLE  hServer,
    IN  DWORD   dwSourceInstance, 
    OUT ISMINSTANCEINFO * pii,  
    IN  DWORD   dwBufferSize   
    )
{
    ASSERT(m_pfnAddInstance != NULL);
    return (*m_pfnAddInstance)(hServer, dwSourceInstance, pii, dwBufferSize);
}

inline HRESULT CServiceInfo::ISMDeleteInstance(
    IN HANDLE  hServer,
    IN DWORD   dwInstance         
    )
{
    ASSERT(m_pfnDeleteInstance != NULL);
    return (*m_pfnDeleteInstance)(hServer, dwInstance);
}

inline HRESULT CServiceInfo::ISMQueryInstanceInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,            
    OUT ISMINSTANCEINFO * pii,  
    IN  DWORD   dwInstance      
    )
{
    ASSERT(m_pfnQueryInstanceInfo != NULL);
    return (*m_pfnQueryInstanceInfo)(hServer, fInherit, pii, dwInstance);
}

inline HRESULT CServiceInfo::ISMQueryChildInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,
    OUT ISMCHILDINFO * pii,        
    IN  DWORD   dwInstance,        
    IN  LPCTSTR lpszParent,       
    IN  LPCTSTR lpszAlias         
    )
{
    ASSERT(m_pfnQueryChildInfo != NULL);
    return (*m_pfnQueryChildInfo)(
        hServer,
        fInherit,
        pii, 
        dwInstance, 
        lpszParent, 
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMAddChild(
    IN  HANDLE  hServer,
    OUT ISMCHILDINFO * pii,           
    IN  DWORD   dwBufferSize,         
    IN  DWORD   dwInstance,           
    IN  LPCTSTR lpszParent           
    )
{
    ASSERT(m_pfnAddChild != NULL);
    return (*m_pfnAddChild)(
        hServer,
        pii, 
        dwBufferSize, 
        dwInstance, 
        lpszParent
        );
}

inline HRESULT CServiceInfo::ISMSecurityWizard(
    HANDLE  hServer,            
    DWORD   dwInstance,         
    LPCTSTR lpszParent,         
    LPCTSTR lpszAlias           
    )
{
    ASSERT(m_pfnISMSecurityWizard != NULL);
    return (*m_pfnISMSecurityWizard)(
        hServer,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServiceInfo::ISMDeleteChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,            
    IN LPCTSTR lpszParent,           
    IN LPCTSTR lpszAlias             
    )
{
    ASSERT(m_pfnDeleteChild != NULL);
    return (*m_pfnDeleteChild)(hServer, dwInstance, lpszParent, lpszAlias);
}

inline HRESULT CServiceInfo::ISMRenameChild(
    IN HANDLE  hServer,              
    IN DWORD   dwInstance,           
    IN LPCTSTR lpszParent,           
    IN LPCTSTR lpszAlias,            
    IN LPCTSTR lpszNewAlias          
    )
{
    ASSERT(m_pfnDeleteChild != NULL);
    return (*m_pfnRenameChild)(
        hServer, 
        dwInstance, 
        lpszParent, 
        lpszAlias, 
        lpszNewAlias
        );
}

inline HRESULT CServiceInfo::ISMMMCConfigureServers(
    IN HANDLE  hServer,
    IN PVOID   lpfnProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwInstance
    )
{
    ASSERT(m_pfnISMMMCConfigureServers != NULL);
    return (*m_pfnISMMMCConfigureServers)(
        hServer,
        lpfnProvider,
        param,
        handle,
        dwInstance
        );
}

inline HRESULT CServiceInfo::ISMMMCConfigureChild(
    IN HANDLE  hServer,
    IN PVOID   lpfnProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,      
    IN LPCTSTR lpszParent,     
    IN LPCTSTR lpszAlias
    )
{
    ASSERT(m_pfnISMMMCConfigureChild != NULL);
    return (*m_pfnISMMMCConfigureChild)(
        hServer,
        lpfnProvider,
        param,
        handle,
        dwAttributes,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

#endif // USE_VTABLE

//
// Assign the service bitmap index
//
inline void CServiceInfo::SetBitmapIndex(int iID)
{
    m_iBmpID = iID;
}

//
// Assign the child bitmap index
//
inline void CServiceInfo::SetChildBitmapIndex(int iID)
{
    m_iBmpChildID = iID;
}

inline HINSTANCE CNewInstanceCmd::QueryInstanceHandle()
{
    return GetServiceInfo()->QueryInstanceHandle();
}

inline int CServerInfo::CompareByServer(CServerInfo * psi) const
{
    return ::lstrcmpi(
        QueryServerDisplayName(),
        psi->QueryServerDisplayName()
        );
}

inline BOOL CServerInfo::MatchServerName(LPCTSTR lpszServerName) const
{
    return ::lstrcmpi(QueryServerDisplayName(), lpszServerName) == 0;
}

inline int CServerInfo::CompareByService(CServerInfo * psi)
{
    return ::lstrcmpi(GetServiceName(), psi->GetServiceName());
}

inline HRESULT CServerInfo::ConfigureChild(
    IN HWND    hWnd,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
{
    ASSERT(m_pService);
    return m_pService->ISMConfigureChild(
        m_hServer,
        hWnd,
        dwAttributes,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServerInfo::MMCConfigureChild(
    IN PVOID   lpfnProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
{
    ASSERT(m_pService);
    return m_pService->ISMMMCConfigureChild(
        m_hServer,
        lpfnProvider,
        param,
        handle,
        dwAttributes,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServerInfo::RenameChild(
    DWORD   dwInstance,            
    LPCTSTR lpszParent,           
    LPCTSTR lpszAlias,            
    LPCTSTR lpszNewName           
    )
{
    ASSERT(m_pService);
    return m_pService->ISMRenameChild(
        m_hServer,
        dwInstance,
        lpszParent,
        lpszAlias, 
        lpszNewName
        );
}

inline HRESULT CServerInfo::AddChild(
    ISMCHILDINFO * pii,     
    DWORD   dwBufferSize,   
    DWORD   dwInstance,     
    LPCTSTR lpszParent      
    )
{
    ASSERT(m_pService);
    return m_pService->ISMAddChild(
        m_hServer,
        pii,
        dwBufferSize,
        dwInstance,
        lpszParent
        );
}

inline HRESULT CServerInfo::ISMSecurityWizard(
    DWORD   dwInstance,         // Instance number
    LPCTSTR lpszParent,         // Parent path
    LPCTSTR lpszAlias           // Child alias name
    )
{
    ASSERT(m_pService);
    return m_pService->ISMSecurityWizard(
        m_hServer,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}


inline HRESULT CServerInfo::DeleteChild(
    DWORD   dwInstance,     
    LPCTSTR lpszParent,     
    LPCTSTR lpszAlias       
    )
{
    ASSERT(m_pService);
    return m_pService->ISMDeleteChild(
        m_hServer,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServerInfo::QueryInstanceInfo(
    BOOL    fInherit,            
    ISMINSTANCEINFO * pii,
    DWORD   dwInstance
    )
{
    ASSERT(m_pService);
    return m_pService->ISMQueryInstanceInfo(
        m_hServer,
        fInherit,
        pii,
        dwInstance
        );
}

inline HRESULT CServerInfo::QueryChildInfo(
    BOOL    fInherit,            
    ISMCHILDINFO * pii,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias
    )
{
    ASSERT(m_pService);
    return m_pService->ISMQueryChildInfo(
        m_hServer,
        fInherit,
        pii,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}

inline HRESULT CServerInfo::AddInstance(
    ISMINSTANCEINFO * pii,  
    DWORD dwBufferSize    
    )
{
    ASSERT(m_pService);
    return m_pService->ISMAddInstance(
        m_hServer,
        0L,         // Source instance
        pii,
        dwBufferSize
        );
}

inline HRESULT CServerInfo::DeleteInstance(
    DWORD   dwInstance      
    )
{
    ASSERT(m_pService);
    return m_pService->ISMDeleteInstance(m_hServer, dwInstance);
}

inline HRESULT CServerInfo::ISMEnumerateChildren(
    ISMCHILDINFO * pii,              
    HANDLE * phEnum,                 
    DWORD   dwInstance,                  
    LPCTSTR lpszParent                   
    )
{
    ASSERT(m_pService);
    return m_pService->ISMEnumerateChildren(
        m_hServer,
        pii,
        phEnum,
        dwInstance,
        lpszParent
        );
}

inline HRESULT CServerInfo::ISMEnumerateInstances(
    ISMINSTANCEINFO * pii,
    HANDLE * pdwEnum      
    )
{
    ASSERT(m_pService);
    return m_pService->ISMEnumerateInstances(m_hServer, pii, pdwEnum);
}

inline LPCTSTR CServerInfo::QueryServerDisplayName() const
{
#ifdef ENFORCE_NETBIOS
    return ((LPCTSTR)m_strServerName) + 2;
#else
    return (LPCTSTR)m_strServerName;
#endif // ENFORCE_NETBIOS
}

inline BOOL CServerInfo::IsServiceRunning() const
{
    return m_nServiceState == INetServiceRunning;
}

inline BOOL CServerInfo::IsServiceStopped() const
{
    return m_nServiceState == INetServiceStopped;
}

inline BOOL CServerInfo::IsServicePaused() const
{
    return m_nServiceState == INetServicePaused;
}

inline BOOL CServerInfo::IsServiceStatusUnknown() const
{
    return m_nServiceState == INetServiceUnknown;
}

inline HINSTANCE CServerInfo::QueryInstanceHandle()
{
    ASSERT(m_pService != NULL);
    return m_pService->QueryInstanceHandle();
}

inline BOOL CServerInfo::IsServiceSelected() const
{
    ASSERT(m_pService != NULL);
    return m_pService->IsSelected();
}

inline LPCTSTR CServerInfo::GetServiceName() const
{
    ASSERT(m_pService != NULL);
    return m_pService->GetShortName();
}

inline int CServerInfo::QueryServiceID() const
{
    ASSERT(m_pService != NULL);
    return m_pService->QueryServiceID();
}

inline int CServerInfo::QueryBitmapIndex() const
{
    ASSERT(m_pService != NULL);
    return m_pService->QueryBitmapIndex();
}

inline int CServerInfo::QueryChildBitmapIndex() const
{
    ASSERT(m_pService != NULL);
    return m_pService->QueryChildBitmapIndex();
}

inline LPCTSTR CServerInfo::GetShortName() const
{ 
    ASSERT(m_pService != NULL);
    return m_pService->GetShortName();
}

inline LPCTSTR CServerInfo::GetLongName() const
{
    ASSERT(m_pService != NULL);
    return m_pService->GetLongName();
}

inline LPCTSTR CServerInfo::GetProtocol() const 
{
    ASSERT(m_pService != NULL);
    return m_pService->GetProtocol();
}

inline LPCTSTR CServerInfo::GetMetabaseName() const 
{ 
    ASSERT(m_pService != NULL);
    return m_pService->GetMetabaseName();
}

inline BOOL CServerInfo::CanControlService() const
{
    ASSERT(m_pService != NULL);
    return m_pService->CanControlService();
}

inline BOOL CServerInfo::CanPauseService() const
{
    ASSERT(m_pService != NULL);
    return m_pService->CanPauseService();
}

inline BOOL CServerInfo::SupportsInstances() const
{
    ASSERT(m_pService != NULL);
    return m_pService->SupportsInstances();
}

inline BOOL CServerInfo::SupportsChildren() const
{
    ASSERT(m_pService != NULL);
    return m_pService->SupportsChildren();
}

inline BOOL CServerInfo::SupportsFileSystem() const
{
    ASSERT(m_pService != NULL);
    return m_pService->SupportsFileSystem();
}

inline BOOL CServerInfo::SupportsSecurityWizard() const
{
    ASSERT(m_pService != NULL);
    return m_pService->SupportsSecurityWizard();
}

inline BOOL CServerInfo::UnderstandsInstanceCodes() const
{
    ASSERT(m_pService != NULL);
    return m_pService->UnderstandsInstanceCodes();
}

inline BOOL CServerInfo::HasWebProtocol() const
{
    ASSERT(m_pService != NULL);
    return m_pService->HasWebProtocol();
}

inline BOOL CServerInfo::SupportsMMC() const
{
    ASSERT(m_pService != NULL);
    return m_pService->SupportsMMC();
}

inline BOOL CServerInfo::IsK2Service() const
{
    ASSERT(m_pService != NULL);
    return m_pService->IsK2Service();
}

inline UINT CServerInfo::QueryServiceBitmapID() const
{
    ASSERT(m_pService != NULL);
    return m_pService->QueryServiceBitmapID();
}

extern CSnapinApp theApp;


#include "iisobj.h"
#include "menuex.h"

#endif  // _INETMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\guids.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guids.h

   Abstract:

        GUIDs as used by IIS snapin definition

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// New Clipboard format that has the Type and Cookie
//
extern const wchar_t * ISM_SNAPIN_INTERNAL;

//
// Published context information for extensions to extend
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

extern const wchar_t * MYCOMPUT_MACHINE_NAME;
extern const wchar_t * ISM_SNAPIN_MACHINE_NAME;
extern const wchar_t * ISM_SNAPIN_SERVICE;
extern const wchar_t * ISM_SNAPIN_INSTANCE;
extern const wchar_t * ISM_SNAPIN_PARENT_PATH;
extern const wchar_t * ISM_SNAPIN_NODE;
extern const wchar_t * ISM_SNAPIN_META_PATH;

//
// GUIDS
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Snapin GUID
//
extern const CLSID CLSID_Snapin;                 // In-Proc server GUID
extern const CLSID CLSID_About;                  // About GUID

//
// IIS Object GUIDS
//
extern const GUID cInternetRootNode;             // Internet root node       num
extern const GUID cMachineNode;                  // Machine node             num
extern const GUID cServiceCollectorNode;         // Service Collector node   num
extern const GUID cInstanceCollectorNode;        // Instance Collector node  num
extern const GUID cInstanceNode;                 // Instance node            num
extern const GUID cChildNode;                    // Child node               num
extern const GUID cFileNode;                     // File node                num
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\menuex.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        menuex.cpp

   Abstract:

        Menu extension classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"

#include "inetmgr.h"
#include "menuex.h"
#include "constr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// Static member initialization;
//
const TCHAR CISMShellExecutable::s_chField = _T(';');
const TCHAR CISMShellExecutable::s_chEscape = _T('$');
const TCHAR CISMShellExecutable::s_chService = _T('S');
const TCHAR CISMShellExecutable::s_chComputer = _T('C');



/* static */
HICON
CISMShellExecutable::GetShellIcon(
    IN LPCTSTR lpszShellExecutable
    )
/*++

Routine Description:

    Extract icon from the given shell executable
                                                                       
Arguments:

    LPCTSTR lpszShellExecutable : Executable name (or shell document)

Return Value:

    Handle to the icon or NULL

--*/ 
{
    SHFILEINFO shfi;

    ::SHGetFileInfo(
        lpszShellExecutable, 
        0L, 
        &shfi, 
        sizeof(shfi), 
        SHGFI_ICON | SHGFI_SHELLICONSIZE | SHGFI_SMALLICON
        );

    //
    // Will be NULL if SHGetFileInfo failed
    //
    return shfi.hIcon;
}



/* static */
HICON
CISMShellExecutable::ExtractIcon(
    IN LPCTSTR lpszIconSource,
    IN UINT nIconOffset
    )
/*++

Routine Description:

    Extract icon specified by index from the given file
                                                                       
Arguments:

    LPCTSTR lpszIconSource : Source of the icon file
    UINT nIconOffset       : The 0-based icon index within the file

Return Value:

    Handle to the icon or NULL

--*/ 
{
    HICON hIconSmall = NULL;

    ::ExtractIconEx(lpszIconSource, nIconOffset, NULL, &hIconSmall, 1);

    return hIconSmall;
}



/* static */
LPTSTR
CISMShellExecutable::GetField(
    IN LPTSTR pchLine OPTIONAL
    )
/*++

Routine Description:

    Similar to strtok, this function reads fields from the source string
    separated by semi-colons.  When one is found, it is changed to a NULL,
    and the pointer to the current string is returned.  Subsequent calls
    to this function may use pchLine as NULL, meaning continue where we
    left off.  This function differs from strtok, in that only the first
    separator character is skipped.  Having multiple ones in a row, e.g.
    ";;;", would return each field as an empty field, and not just skip
    past all of them.  Also, quoted fields are returned in their entirety,
    and any separator characters in them are not treated as separators.

Arguments:

    LPTSTR pchLine : Beginning string pointer or NULL

Return Value:

    String pointer to the next field, or NULL if no further fields are
    available.

--*/ 
{
    static LPTSTR pchEnd = NULL;
    static BOOL fEOL = FALSE;
    LPTSTR pch;

    //
    // Initialize beginning line pointer
    //
    if (pchLine != NULL)
    {
        //
        // Starting with a new string
        //
        fEOL = FALSE;
        pch = pchLine;
    }
    else
    {
        //
        // Continue where we left off if there was any
        // thing more to read
        //
        if (fEOL)
        {
            return NULL;
        }

        //
        // Must have been called at least once with non-NULL
        // parameter
        //
        ASSERT(pchEnd != NULL);

        pch = ++pchEnd;
    }

    pchEnd = pch;

    //
    // Quotes are handled seperately
    //
    if (*pchEnd == _T('\"') )
    {
        //
        // Skip ahead to closing quote
        //
        ++pch;
        do
        {
            ++pchEnd;
        }
        while (*pchEnd && *pchEnd != _T('\"') );

        if (!*pchEnd)
        {
            fEOL = TRUE;
        }
        else
        {
            *(pchEnd++) = _T('\0');
        }

        return pch;
    }

    //
    // Else look for the field separator 
    // Allowing for null fields
    //
    if (*pchEnd != CISMShellExecutable::s_chField) 
    {
        do
        {
            ++pchEnd;
        }
        while (*pchEnd && * pchEnd != CISMShellExecutable::s_chField);
    }

    if (!*pchEnd)
    {
        fEOL = TRUE;
    }
    else
    {
        *pchEnd = _T('\0');
    }

    return pch;
}



/* static */
DWORD
CISMShellExecutable::ExpandEscapeCodes(
    OUT CString & strDest,
    IN  LPCTSTR lpSrc,
    IN  LPCTSTR lpszComputer OPTIONAL,
    IN  LPCTSTR lpszService  OPTIONAL
    )
/*++

Routine Description:

    Expand the escape codes in the string with computer or service
    strings. See note at constructor below
                                                                       
Arguments:

    CString & strDest    : Destination string
    LPCTSTR lpSrc        : Original source string
    LPCTSTR lpszComputer : Computer name
    LPCTSTR lpszService  : Service name

Return Value:

    Error return code

--*/ 
{
    DWORD err = ERROR_SUCCESS;

    try
    {
        strDest.Empty();

        while(*lpSrc)
        {
            if (*lpSrc == CISMShellExecutable::s_chEscape)
            {
                TCHAR ch = *(++lpSrc);
                CharUpper((LPTSTR)ch);
                switch(ch)
                {
                case CISMShellExecutable::s_chComputer:
                    if (lpszComputer)
                    {
                        strDest += PURE_COMPUTER_NAME(lpszComputer);
                    }
                    break;

                case CISMShellExecutable::s_chService:
                    if (lpszService)
                    {
                        strDest += lpszService;
                    }
                    break;

                case CISMShellExecutable::s_chEscape:
                    strDest += CISMShellExecutable::s_chEscape;
                    break;

                case _T('\0'):
                default:
                    //
                    // Ignored
                    //
                    break;
                }
            }
            else
            {
                strDest += *lpSrc;
            }

            ++lpSrc;
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}

//
// Helper macros to parse description line
//
#define PARSE_STR_FIELD(src, dest)                         \
{                                                          \
    LPTSTR lp = CISMShellExecutable::GetField((LPTSTR)src);\
    if (lp != NULL)                                        \
    {                                                      \
        dest = lp;                                         \
        TRACEEOLID("Field is " << dest);                   \
    }                                                      \
}

#define PARSE_INT_FIELD(src, dest, def)                    \
{                                                          \
    LPTSTR lp = CISMShellExecutable::GetField((LPTSTR)src);\
    dest = (lp != NULL ? ::_ttoi(lp) : def);               \
    TRACEEOLID("Numeric field is " << dest);               \
}

//
// Helper macro for conditional expansion
//
#define SAFE_EXPAND(err, dest, src, server, service)       \
{                                                          \
    err = ExpandEscapeCodes(dest, src, server, service);   \
    if (err != ERROR_SUCCESS)                              \
    {                                                      \
        break;                                             \
    }                                                      \
}



CISMShellExecutable::CISMShellExecutable(
    IN LPCTSTR lpszRegistryValue,
    IN int nBitmapID,
    IN int nCmd
    )
/*++

Routine Description:

    Constructor.  Read the description from the registry and initialize the
    fields.
                                                                       
Arguments:

    LPCTSTR lpszRegistryValue : Registry value
    int     nButton           : Toolbar ID

Return Value:

    N/A

Notes:

    Fields
    =======

    The registry description consists of fields separated by semi-colons
    The fields are as follows:
    
    1) executable name          : Executable name or shell document
    2) tool tips text           : Text to appear in the toolbar
    3) selection arguments      : Command line options if there is a selection
    4) non-selection arguments  : Command line options if nothing is selected
    5) working directory        : CWD if not set
    6) show in toolbar          : If zero, not shown in toolbar, anything else
                                  will show in toolbar.  
                                  CAVEAT: Empty is translated to mean 'yes'
    7) icon path                : Where to get the toolbar icon (if empty,
                                  the executable name will be used
    8) icon index               : If the above is specified, the icon index
                                  0 otherwise

    1) Is mandatory, all other fields are optional.  

    Escape Codes
    ============

    Any field may contain escape codes that are filled in at runtime. These
    escape codes are as follows:

    $S  : Replaced with service name (if selected -- skipped otherwise)
    $C  : Replaced with computer name (if selected -- skipped otherwise)
    $$  : Replaced with a single $

--*/ 
    : m_strCommand(),
      m_strParms(),
      m_strNoSelectionParms(),
      m_strToolTipsText(),
      m_hIcon(NULL),
      m_pBitmap(NULL),
      m_pmmcButton(NULL),
      m_nBitmapID(nBitmapID),
      m_nCmd(nCmd),
      m_fShowInToolbar(TRUE)
{
    try
    {
        CString strIconFile;
        UINT nIconOffset;

        PARSE_STR_FIELD(lpszRegistryValue, m_strCommand);
        PARSE_STR_FIELD(NULL, m_strToolTipsText);
        PARSE_STR_FIELD(NULL, m_strParms);
        PARSE_STR_FIELD(NULL, m_strNoSelectionParms);
        PARSE_STR_FIELD(NULL, m_strDefaultDirectory);
        PARSE_INT_FIELD(NULL, m_fShowInToolbar, TRUE);
        PARSE_STR_FIELD(NULL, strIconFile);
        PARSE_INT_FIELD(NULL, nIconOffset, 0);

        //
        // If no tooltips text, give it the executable name
        //
        if (m_strToolTipsText.IsEmpty())
        {
            m_strToolTipsText = m_strCommand;
        }

        if (!m_strCommand.IsEmpty() && m_fShowInToolbar)
        {
            //
            // If no specific icon source file is specified,
            // just use what the shell would use.
            //
            if (strIconFile.IsEmpty())
            {
                m_hIcon = GetShellIcon(m_strCommand);
            }
            else
            {
                m_hIcon = ExtractIcon(strIconFile, nIconOffset);
            }

            //
            // Provide the ? icon if nothing is proviced in the binary
            //
            if (m_hIcon == NULL)
            {
                m_pBitmap = new CBitmap;

                if (!m_pBitmap->LoadMappedBitmap(IDB_UNKNOWN))
                {
                    TRACEEOLID("Can't load unknown toolbar button bitmap");
                    delete m_pBitmap;
                    m_pBitmap = NULL;
                }
            }
            else
            {
                ExtractBitmapFromIcon(m_hIcon, m_pBitmap);
            }

            //
            // Now build the MMC button structure
            //
            if (HasBitmap())
            {
                m_pmmcButton = (MMCBUTTON *)AllocMem(sizeof(MMCBUTTON));
                if (m_pmmcButton != NULL)
                {
                   m_pmmcButton->nBitmap = m_nBitmapID;
                   m_pmmcButton->idCommand = m_nCmd;
                   m_pmmcButton->fsState = TBSTATE_ENABLED;
                   m_pmmcButton->fsType = TBSTYLE_BUTTON;
                   m_pmmcButton->lpButtonText = _T(" ");
                   m_pmmcButton->lpTooltipText = (LPTSTR)(LPCTSTR)m_strToolTipsText;
                }
            }
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!Exception initializing add-on-tool");
        e->ReportError();
        e->Delete();
    }
}



CISMShellExecutable::~CISMShellExecutable()
/*++

Routine Description:
    
    Destructor
                                                                           
Arguments:

    N/A

Return Value:

    N/A

--*/ 
{
    if (m_pBitmap)
    {
        //
        // I don't think I own this...
        //
        m_pBitmap->DeleteObject();
        delete m_pBitmap;
    }

    if (m_pmmcButton)
    {
        FreeMem(m_pmmcButton);
    }
}



void
CISMShellExecutable::ExtractBitmapFromIcon(
    IN  HICON hIcon,
    OUT CBitmap *& pBitmap
    )
/*++

Routine Description:

    Extract bitmap information from icon

Arguments:

    HICON hIcon             : Input icon handle
    CBitmap *& pBitmap      : Returns bitmap info

Return Value:

    None

--*/
{
    try
    {
        pBitmap = new CBitmap();

        //
        // Get bitmap info from icon
        //
        ICONINFO ii;
        ASSERT(hIcon != NULL);
        ::GetIconInfo(hIcon, &ii);

        BITMAP bm;

        //
        // Determine size of the image
        //
        ::GetObject(ii.hbmColor, sizeof(bm), &bm);

        //
        // Now create a new bitmap by drawing the icon on
        // a button face background colour
        //
        CDC dcMem;

        dcMem.CreateCompatibleDC(NULL);
        pBitmap->CreateBitmapIndirect(&bm);

        CBitmap * pOld = dcMem.SelectObject(pBitmap);

        COLORREF crOld = dcMem.SetBkColor(::GetSysColor(COLOR_BTNFACE));
        CRect rc(0, 0, bm.bmWidth, bm.bmHeight);
        CBrush br(::GetSysColor(COLOR_BTNFACE));
        dcMem.FillRect(&rc, &br);

        ::DrawIconEx(
            dcMem.m_hDC, 
            0, 
            0, 
            hIcon, 
            bm.bmWidth,
            bm.bmHeight, 
            0, 
            NULL, 
            DI_NORMAL
            );

        dcMem.SetBkColor(crOld);
        dcMem.SelectObject(pOld);
    }
    catch(CException * e)
    {
        TRACEEOLID("!!! Exception adding icon based button");
        e->ReportError();
        e->Delete();
    }   
}



LPCTSTR 
CISMShellExecutable::GetToolTipsText(
    CString & str,
    IN LPCTSTR lpszServer OPTIONAL,
    IN LPCTSTR lpszService OPTIONAL
    )
/*++

Routine Description:
    
    Get the tooltips text.  Optionally perform escape code 
    expansion
                                                                           
Arguments:

    LPCTSTR lpstrServer  : Currently selected server (or NULL)
    LPCTSTR lpstrService : Currently selected service (or NULL)

Return Value:

    Pointer to string

--*/ 
{
    ExpandEscapeCodes(str, m_strToolTipsText, lpszServer, lpszService);

    return (LPCTSTR)str;
}



DWORD
CISMShellExecutable::Execute(
    IN LPCTSTR lpszServer OPTIONAL, 
    IN LPCTSTR lpszService OPTIONAL
    )
/*++

Routine Description:
    
    Execute the current module
                                                                           
Arguments:

    LPCTSTR lpszServer  : Currently selected server (or NULL)
    LPCTSTR lpszService : Currently selected service (or NULL)

Return Value:

    Error return code

--*/ 
{
    DWORD err = ERROR_SUCCESS;
    CString strCommand;
    CString strParms;
    CString strDefaultDirectory;

    do
    {
        //
        // Expand escape codes as appropriate
        //
        SAFE_EXPAND(err, strCommand, m_strCommand, lpszServer, lpszService);
        SAFE_EXPAND(err, strParms, lpszServer 
            ? m_strParms : m_strNoSelectionParms, lpszServer, lpszService);
        SAFE_EXPAND(err, strDefaultDirectory, m_strDefaultDirectory,    
            lpszServer, lpszService);

        if (::ShellExecute(
            NULL, 
            _T("open"), 
            strCommand, 
            strParms, 
            strDefaultDirectory, 
            SW_SHOW
            ) <= (HINSTANCE)32)
        {
            err = ::GetLastError();
        }
    }
    while(FALSE);

    return err;
}

/* OBSOLETE

//
// Add Machine Page Procedure Name
//
#define ADDMACHINEPAGE_PROC "ISMAddMachinePages"



BOOL 
AddISMPage(
    IN HPROPSHEETPAGE hPage, 
    IN LPARAM lParam
    )
/*++

Routine Description:

    Callback function to be used for ISM machine property sheet
    extention modules to add pages to the property sheet.
                                                                       
Arguments:

    HPROPSHEETPAGE hPage   : Handle to page to be added
    LPARAM lParam          : LParam given to the extention module.
                             Privately, this is a cast to the property
                             sheet structure.

Return Value:

    TRUE for success, FALSE for failure.  In case of failure, GetLastError
    will reveal the reason.

--/
{
    //
    // The extention module has been given the propsheet
    // cunningly disguised as an LPARAM.  If they've messed
    // with the lparam, this will propably crash.
    //
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    HPROPSHEETPAGE * pOld = ppsh->phpage;
    ppsh->phpage = (HPROPSHEETPAGE *)AllocMem(ppsh->nPages + 1);
    if (ppsh->phpage == NULL)
    {
        //
        // Memory failure
        //
        ppsh->nPages = 0;
        TRACEEOLID("Memory failure building machine property sheet");
        ::SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
    }

    //
    // Save the old handles
    //
    if (pOld)
    {
        for (UINT i = 0; i < ppsh->nPages; ++i)
        {
            ppsh->phpage[i] = pOld[i];
        }

        FreeMem(pOld);
    }

    //
    // Add the new page
    //
    ppsh->phpage[ppsh->nPages++] = hPage;

    TRACEEOLID("Succesfully built machine property sheet with " 
        << ppsh->nPages << " pages.");

    return TRUE;
}



CISMMachinePageExt::CISMMachinePageExt(
    IN LPCTSTR lpstrDLLName
    )
/*++

Routine Description:

    Constructor for ISM Machine property sheet extender.
                                                                       
Arguments:

    LPCTSTR lpstrDLLName : Name of the DLL.

Return Value:

    N/A

Notes:

    This will not attempt to load and resolve the DLL

--/
    : m_strDLLName(lpstrDLLName),
      m_hDLL(NULL),
      m_lpfn(NULL)
{
}



CISMMachinePageExt::~CISMMachinePageExt()
/*++

Routine Description:

    Destructor
                                                                       
Arguments:

    N/A

Return Value:

    N/A

Notes:

    This will unload the DLL if it is still loaded, but this should
    have been done with the UnLoad method beforehand.

--/
{
    //
    // Should have been unloaded by now
    //
    ASSERT(m_hDLL == NULL);
    if (m_hDLL)
    {
        VERIFY(UnLoad());
    }
}



//
// Prototype
//
DWORD
ISMAddMachinePages(
    IN LPCTSTR lpstrMachineName,
    IN LPFNADDPROPSHEETPAGE lpfnAddPage,
    IN LPARAM lParam,
    IN HINSTANCE hInstance
    );



DWORD
CISMMachinePageExt::Load()
/*++

Routine Description:

    Load the DLL, and resolve the exposed interface
                                                                       
Arguments:

    None

Return Value:

    Error return code;

--/
{
#ifdef _COMSTATIC

    m_lpfn = &ISMAddMachinePages;

    return ERROR_SUCCESS;

#else

    //
    // Make sure it's not already loaded
    //
    ASSERT(m_hDLL == NULL);
    m_hDLL = ::AfxLoadLibrary(m_strDLLName);
    if (m_hDLL)
    {
        m_lpfn = (LPFNADDMACHINEPAGE)::GetProcAddress(
            m_hDLL, ADDMACHINEPAGE_PROC);

        if (m_lpfn)
        {   
            return ERROR_SUCCESS;
        }
    }

    return ::GetLastError();

#endif // _COMSTATIC
}



BOOL
CISMMachinePageExt::UnLoad()
/*++

Routine Description:

    Unload the extention DLL
                                                                       
Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--/
{
#ifdef _COMSTATIC

    return TRUE;

#else

    BOOL fResult = FALSE;

    if (m_hDLL)
    {
        fResult = ::AfxFreeLibrary(m_hDLL);
        m_hDLL = NULL;
        m_lpfn = NULL;
    }

    return fResult;

#endif // _COMSTATIC
}


*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\iisobj.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        iisobj.cpp

   Abstract:

        IIS Objects

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "inetmgr.h"
#include "iisobj.h"
#include "machine.h"
#include <shlwapi.h>
#include "guids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Static initialization
//
BOOL    CIISObject::m_fIsExtension = FALSE;
CString CIISObject::s_strProperties;
CString CIISObject::s_strRunning;
CString CIISObject::s_strPaused;
CString CIISObject::s_strStopped;
CString CIISObject::s_strUnknown;
CString CIISObject::s_strYes;
CString CIISObject::s_strNo;
CString CIISObject::s_strTCPIP;
CString CIISObject::s_strNetBIOS;
CString CIISObject::s_strDefaultIP;
CString CIISObject::s_strRedirect;
time_t  CIISObject::s_lExpirationTime = (5L * 60L); // 5 Minutes
LPCONSOLENAMESPACE CIISObject::s_lpcnsScopeView = NULL;



//
// Backup/restore taskpad gif resource
//
#define RES_TASKPAD_BACKUP          _T("/img\\backup.gif")



LPCTSTR
PrependParentPath(
    IN OUT CString & strPath,
    IN LPCTSTR lpszParent,
    IN TCHAR chSep
    )
/*++

Routine Description:

    Helper function to prepend a new parent to the given path

Arguments:

    CString & strPath       : Current path
    LPCTSTR lpszParent      : Parent to be prepended
    TCHAR chSep             : Separator character

Return Value:

    Pointer to the path

--*/
{
    if (strPath.IsEmpty())
    {
        strPath = lpszParent;
    }
    else
    {
        CString strTail(strPath);
        strPath = lpszParent;
        strPath += chSep;
        strPath += strTail; 
    }

    TRACEEOLID("PrependParentPath: " << strPath);

    return strPath;
}



HRESULT
ShellExecuteDirectory(
    IN LPCTSTR lpszCommand,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Shell Open or explore on a given directory path

Arguments:

    LPCTSTR lpszCommand    : "open" or "explore"
    LPCTSTR lpszOwner      : Owner server
    LPCTSTR lpszDirectory  : Directory path

Return Value:

    Error return code.

--*/
{
    CString strDir;

    if (::IsServerLocal(lpszOwner) || ::IsUNCName(lpszDirectory))
    {
        //
        // Local directory, or already a unc path
        //
        strDir = lpszDirectory;
    }
    else
    {
        ::MakeUNCPath(strDir, lpszOwner, lpszDirectory);
    }

    TRACEEOLID("Attempting to " << lpszCommand << " Path: " << strDir);

    CError err;
    {
        //
        // AFX_MANAGE_STATE required for wait cursor
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState() );
        CWaitCursor wait;

        if (::ShellExecute(
            NULL, 
            lpszCommand, 
            strDir, 
            NULL,
            _T(""), 
            SW_SHOW
            ) <= (HINSTANCE)32)
        {
            err.GetLastWinError();
        }
    }

    return err;
}



/* static */
void
CIISObject::BuildResultView(
    IN LPHEADERCTRL pHeader,
    IN int cColumns,
    IN int * pnIDS,
    IN int * pnWidths
    )
/*++

Routine Description:

    Build the result view columns

Routine Description:

    LPHEADERCTRL pHeader    : Header control
    int cColumns            : Number of columns
    int * pnIDS             : Array of column header strings
    int * pnWidths          : Array of column widths

Routine Description:

    None

--*/
{
    ASSERT(pHeader != NULL);

    //
    // Needed for loadstring
    //
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString str;

    for (int n = 0; n < cColumns; ++n)
    {
        VERIFY(str.LoadString(pnIDS[n]));
        pHeader->InsertColumn(n, str, LVCFMT_LEFT, pnWidths[n]);
    }
}



/* static */
BOOL
CIISObject::CanAddInstance(
    IN LPCTSTR lpszMachineName
    )
/*++

Routine Description:

    Helper function to determine if instances may be added on
    this machine

Arguments:

    LPCTSTR lpszMachineName        : Machine name

Return Value:

    TRUE if instances can be added

--*/
{
    //
    // Assume W3svc and ftpsvc have the same capabilities.
    //
    CServerCapabilities * pcap;
    
    pcap = new CServerCapabilities(lpszMachineName, SZ_MBN_WEB);

    if (!pcap)
    {
        return FALSE;
    }

    if (FAILED(pcap->LoadData()))
    {
        //
        // Try ftp
        //
        delete pcap;
        pcap = new CServerCapabilities(lpszMachineName, SZ_MBN_FTP);
    }
    
    if (!pcap || FAILED(pcap->LoadData()))
    {
        if (pcap)
        {
            delete pcap;
        }

        return FALSE;
    }

    BOOL fCanAdd = pcap->HasMultipleSites();

    delete pcap;

    return fCanAdd;
}



BOOL
CIISObject::IsScopeSelected()
/*++

Routine Description:

    Return TRUE if the scope is currently selected

Arguments:

    None

Return Value:

    TRUE if the item is currently selected, FALSE otherwise

--*/
{
    ASSERT(s_lpcnsScopeView != NULL);

    HSCOPEITEM hItem = GetScopeHandle();
    ASSERT(hItem != NULL);

    if (hItem != NULL)
    {
        SCOPEDATAITEM item;
        ::ZeroMemory(&item, sizeof(SCOPEDATAITEM));
        item.mask = SDI_STATE;
        item.nState = MMC_SCOPE_ITEM_STATE_EXPANDEDONCE;
        item.ID = hItem;

        HRESULT hr = s_lpcnsScopeView->GetItem(&item);

        if (SUCCEEDED(hr))
        {
            return (item.nState & MMC_SCOPE_ITEM_STATE_EXPANDEDONCE) != 0;
        }
    }

    return FALSE;    
}



void
CIISObject::RefreshDisplayInfo()
/*++

Routine Description:

    Refresh the display info parameters in the scope view

Arguments:

    None

Return Value:

    None

--*/
{
    if (IsLeafNode())
    {
        //
        // Not supported on result items
        //
        return;
    }

    ASSERT(s_lpcnsScopeView != NULL);

    HSCOPEITEM hItem = GetScopeHandle();
    ASSERT(hItem != NULL);

    SCOPEDATAITEM item;
    ::ZeroMemory(&item, sizeof(SCOPEDATAITEM));

    //
    // Since we're using a callback, this is
    // all we need to do here
    //
    item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
    item.displayname = MMC_CALLBACK;
    item.nOpenImage = item.nImage = QueryBitmapIndex();
    item.ID = hItem;

    s_lpcnsScopeView->SetItem(&item);
}
    


CIISObject::CIISObject(
    IN const GUID guid,
    IN LPCTSTR lpszNodeName,        OPTIONAL
    IN LPCTSTR lpszPhysicalPath     OPTIONAL
    )
/*++

Routine Description:

    Constructor for CIISObject.  Initialise static member functions
    if not yet initialized.  This is a protected constructor of
    an abstract base class.
                                                                       
Arguments:

    const GUID guid             : GUID of the object
    LPCTSTR lpszNodeName        : Node name
    LPCTSTR lpszPhysicalPath    : Physical path (or empty)

Return Value:

    N/A

--*/
    : m_hScopeItem(NULL),
      m_guid(guid),
      m_strNodeName(lpszNodeName),
      m_strPhysicalPath(lpszPhysicalPath),
      m_strRedirPath(),
      m_fChildOnlyRedir(FALSE),
      m_fIsParentScope(FALSE),
      m_tmChildrenExpanded(0L)
{
    //
    // Initialize static members
    //
    if (CIISObject::s_strRunning.IsEmpty())
    {
        //
        // AFX_MANAGE_STATE required for resource load
        //
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        TRACEEOLID("Initializing static strings");

        VERIFY(CIISObject::s_strRunning.LoadString(IDS_RUNNING));
        VERIFY(CIISObject::s_strPaused.LoadString(IDS_PAUSED));
        VERIFY(CIISObject::s_strStopped.LoadString(IDS_STOPPED));
        VERIFY(CIISObject::s_strUnknown.LoadString(IDS_UNKNOWN));
        VERIFY(CIISObject::s_strProperties.LoadString(IDS_MENU_PROPERTIES));
        VERIFY(CIISObject::s_strYes.LoadString(IDS_YES));
        VERIFY(CIISObject::s_strNo.LoadString(IDS_NO));
        VERIFY(CIISObject::s_strTCPIP.LoadString(IDS_TCPIP));
        VERIFY(CIISObject::s_strNetBIOS.LoadString(IDS_NETBIOS));
        VERIFY(CIISObject::s_strDefaultIP.LoadString(IDS_DEFAULT_IP));
        VERIFY(CIISObject::s_strRedirect.LoadString(IDS_REDIRECTED));    
    }
}

BOOL CIISObject::IsValidObject() const
{
    // CIISObject could have only one of the following GUIDs
    GUID guid = QueryGUID();
    if (    guid == cInternetRootNode
        ||  guid == cMachineNode
        ||  guid == cServiceCollectorNode
        ||  guid == cInstanceCollectorNode
        ||  guid == cInstanceNode
        ||  guid == cChildNode
        ||  guid == cFileNode
        )
        return TRUE;
    return FALSE;
}

CIISObject::operator LPCTSTR()
/*++

Routine Description:

    Typecast operator to call out the display text
                                                                       
Arguments:

    N/A

Return Value:

    Display text

--*/
{
    static CString strText;

    return GetDisplayText(strText);
}    

//
// Separator menu item definition
//
CONTEXTMENUITEM menuSep = 
{
    NULL,
    NULL,
    -1,
    CCM_INSERTIONPOINTID_PRIMARY_TOP,
    0,
    CCM_SPECIAL_SEPARATOR
};



//
// Menu item definition that uses resource definitions, and
// provides some additional information for taskpads.
//
typedef struct tagCONTEXTMENUITEM_RC
{
    UINT nNameID;
    UINT nStatusID;
    UINT nDescriptionID;
    LONG lCmdID;
    LONG lInsertionPointID;
    LONG fSpecialFlags;
    LPCTSTR lpszMouseOverBitmap;
    LPCTSTR lpszMouseOffBitmap;
} CONTEXTMENUITEM_RC;



//
// Important!  The array indices below must ALWAYS be one
// less than the menu ID -- keep in sync with enumeration
// in inetmgr.h!!!!
//
static CONTEXTMENUITEM_RC menuItemDefs[] = 
{
    //
    // Menu Commands in toolbar order
    //
    { IDS_MENU_CONNECT,         IDS_MENU_TT_CONNECT,         -1,                          IDM_CONNECT,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_DISCOVER,        IDS_MENU_TT_DISCOVER,        -1,                          IDM_DISCOVER,             CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_START,           IDS_MENU_TT_START,           -1,                          IDM_START,                CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_STOP,            IDS_MENU_TT_STOP,            -1,                          IDM_STOP,                 CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_PAUSE,           IDS_MENU_TT_PAUSE,           -1,                          IDM_PAUSE,                CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    //
    // These are menu commands that do not show up in the toolbar
    //
    { IDS_MENU_EXPLORE,         IDS_MENU_TT_EXPLORE,         -1,                          IDM_EXPLORE,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_OPEN,            IDS_MENU_TT_OPEN,            -1,                          IDM_OPEN,                 CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_BROWSE,          IDS_MENU_TT_BROWSE,          -1,                          IDM_BROWSE,               CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_PROPERTIES,      IDS_MENU_TT_PROPERTIES,      -1,                          IDM_CONFIGURE,            CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_DISCONNECT,      IDS_MENU_TT_DISCONNECT,      -1,                          IDM_DISCONNECT,           CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_BACKUP,          IDS_MENU_TT_BACKUP,          IDS_MENU_TT_BACKUP,          IDM_METABACKREST,         CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_SHUTDOWN_IIS,    IDS_MENU_TT_SHUTDOWN_IIS,    -1,                          IDM_SHUTDOWN,             CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL, NULL, },
    { IDS_MENU_NEWVROOT,        IDS_MENU_TT_NEWVROOT,        IDS_MENU_DS_NEWVROOT,        IDM_NEW_VROOT,            CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWVROOT, RES_TASKPAD_NEWVROOT, },
    { IDS_MENU_NEWINSTANCE,     IDS_MENU_TT_NEWINSTANCE,     IDS_MENU_DS_NEWINSTANCE,     IDM_NEW_INSTANCE,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_TASKPAD,         IDS_MENU_TT_TASKPAD,         -1,                          IDM_VIEW_TASKPAD,         CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, NULL, NULL, },
    { IDS_MENU_SECURITY_WIZARD, IDS_MENU_TT_SECURITY_WIZARD, IDS_MENU_TT_SECURITY_WIZARD, IDM_TASK_SECURITY_WIZARD, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, RES_TASKPAD_SECWIZ, RES_TASKPAD_SECWIZ, },             
};



/* static */
HRESULT
CIISObject::AddMenuItemByCommand(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN LONG lCmdID,

    IN LONG fFlags
    )
/*++

Routine Description:

    Add menu item by command

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Callback pointer
    LONG lCmdID                                 : Command ID
    LONG fFlags                                 : Flags
    
Return Value:

    HRESULT

--*/
{
    ASSERT(lpContextMenuCallback != NULL);

    //
    // Offset 1 menu commands
    //
    LONG l = lCmdID -1; 

    CString strName;
    CString strStatus;

    {
        //
        // AFX_MANAGE_STATE required for resource load
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        VERIFY(strName.LoadString(menuItemDefs[l].nNameID));
        VERIFY(strStatus.LoadString(menuItemDefs[l].nStatusID));
    }

    CONTEXTMENUITEM cmi;
    cmi.strName = strName.GetBuffer(0);
    cmi.strStatusBarText = strStatus.GetBuffer(0);
    cmi.lCommandID = menuItemDefs[l].lCmdID;
    cmi.lInsertionPointID = menuItemDefs[l].lInsertionPointID;
    cmi.fFlags = fFlags;
    cmi.fSpecialFlags = menuItemDefs[l].fSpecialFlags;

    return lpContextMenuCallback->AddItem(&cmi);
}



/* static */
HRESULT
CIISObject::AddTaskpadItemByInfo(
    OUT MMC_TASK * pTask,
    IN  LONG    lCommandID,
    IN  LPCTSTR lpszMouseOn,
    IN  LPCTSTR lpszMouseOff,
    IN  LPCTSTR lpszText,
    IN  LPCTSTR lpszHelpString
    )
/*++

Routine Description:

    Add taskpad item from the information given

Arguments:

    MMC_TASK * pTask            : Task info
    LPCTSTR lpszMouseOn         : Mouse on URL
    LPCTSTR lpszMouseOff        : Mouse off URL
    LPCTSTR lpszText            : Text to be displayed
    LPCTSTR lpszHelpString      : Help string

Return Value:

    HRESULT

--*/
{
    TRACEEOLID(lpszMouseOn);
    TRACEEOLID(lpszMouseOff);

    pTask->sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_VANILLA_GIF;

    pTask->sDisplayObject.uBitmap.szMouseOverBitmap 
        = CoTaskDupString((LPCOLESTR)lpszMouseOn);
    pTask->sDisplayObject.uBitmap.szMouseOffBitmap 
        = CoTaskDupString((LPCOLESTR)lpszMouseOff);
    pTask->szText = CoTaskDupString((LPCOLESTR)lpszText);
    pTask->szHelpString = CoTaskDupString((LPCOLESTR)lpszHelpString);

    if (pTask->sDisplayObject.uBitmap.szMouseOverBitmap
     && pTask->sDisplayObject.uBitmap.szMouseOffBitmap
     && pTask->szText
     && pTask->szHelpString
       )
    {
        //
        // Add action
        //
        pTask->eActionType = MMC_ACTION_ID;
        pTask->nCommandID = lCommandID;

        return S_OK;
    }

    //
    // Failed
    //
    CoTaskStringFree(pTask->sDisplayObject.uBitmap.szMouseOverBitmap);
    CoTaskStringFree(pTask->sDisplayObject.uBitmap.szMouseOffBitmap);
    CoTaskStringFree(pTask->szText);
    CoTaskStringFree(pTask->szHelpString);

    return S_FALSE;
}



/* static */
HRESULT
CIISObject::AddTaskpadItemByCommand(
    IN  LONG lCmdID,
    OUT MMC_TASK * pTask,
    IN  HINSTANCE hInstance     OPTIONAL
    )
/*++

Routine Description:

    Add taskpad item by command

Arguments:

    LONG lCmdID             : Command ID
    CString & strResURL     : Resource ID    
    MMC_TASK * pTask        : Task structure to be filled in

Return Value:

    HRESULT

--*/
{
    ASSERT(pTask != NULL);

    //
    // Offset 1 menu commands
    //
    LONG l = lCmdID -1; 

    CString strName;
    CString strStatus;

    CString strResURL;
    HRESULT hr = BuildResURL(strResURL, hInstance);

    if (FAILED(hr))
    {
        return hr;
    }

    {
        //
        // AFX_MANAGE_STATE required for resource load
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        VERIFY(strName.LoadString(menuItemDefs[l].nStatusID));
        VERIFY(strStatus.LoadString(menuItemDefs[l].nDescriptionID));
    }

    //
    // Make sure this menu command was intended to go onto a taskpad
    //
    ASSERT(menuItemDefs[l].lpszMouseOverBitmap != NULL);
    ASSERT(menuItemDefs[l].lpszMouseOffBitmap != NULL);    

    //
    // Fill out bitmap URL (use defaults if nothing provided)
    //
    CString strMouseOn(strResURL);
    CString strMouseOff(strResURL);

    strMouseOn += menuItemDefs[l].lpszMouseOverBitmap;
    strMouseOff += menuItemDefs[l].lpszMouseOffBitmap;

    return AddTaskpadItemByInfo(
        pTask,
        menuItemDefs[l].lCmdID,
        strMouseOn,
        strMouseOff,
        strName,
        strStatus
        );
}



/* virtual */ 
HRESULT 
CIISObject::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback
    )
/*++

Routine Description:

    Add menu items to the context that are valid for this
    object

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Callback

Return Value:

    HRESULT

--*/
{
    if (IsConnectable() && !m_fIsExtension)
    {
        AddMenuItemByCommand(lpContextMenuCallback, IDM_CONNECT);    
        AddMenuItemByCommand(lpContextMenuCallback, IDM_DISCONNECT);    
    }

    if (IsExplorable())
    {
        lpContextMenuCallback->AddItem(&menuSep);
        AddMenuItemByCommand(lpContextMenuCallback, IDM_EXPLORE);
    }
               
    if (IsOpenable())
    {
        AddMenuItemByCommand(lpContextMenuCallback, IDM_OPEN);
    }

    if (IsBrowsable())
    {
        AddMenuItemByCommand(lpContextMenuCallback, IDM_BROWSE);
    }

    if (IsControllable())
    {
        lpContextMenuCallback->AddItem(&menuSep);

        UINT nPauseFlags = IsPausable() ? 0 : MF_GRAYED;

        if (IsPaused())
        {
            nPauseFlags |= MF_CHECKED;
        }

        AddMenuItemByCommand(lpContextMenuCallback, IDM_START,  IsStartable() ? 0 : MF_GRAYED);
        AddMenuItemByCommand(lpContextMenuCallback, IDM_STOP,   IsStoppable()   ? 0 : MF_GRAYED);
        AddMenuItemByCommand(lpContextMenuCallback, IDM_PAUSE,  nPauseFlags);
    }

#ifdef MMC_PAGES

    //
    // Bring up private config menu item only if not
    // configurable through MMC
    //
    if (IsConfigurable() && !IsMMCConfigurable())
    {
        lpContextMenuCallback->AddItem(&menuSep);
        AddMenuItemByCommand(lpContextMenuCallback, IDM_CONFIGURE);
    }

#else

    if (IsConfigurable())
    {
        lpContextMenuCallback->AddItem(&menuSep);
        AddMenuItemByCommand(lpContextMenuCallback, IDM_CONFIGURE);
    }

#endif // MMC_PAGES

    return S_OK;
}



/* virtual */
HRESULT
CIISObject::AddNextTaskpadItem(
    OUT MMC_TASK * pTask
    )
/*++

Routine Description:

    Add next taskpad item

Arguments:

    MMC_TASK * pTask    : Task structure to fill in

Return Value:

    HRESULT

--*/
{
    //
    // CODEWORK:  Because of enumeration, this isn't easy
    //            to handle the way menu items are handled
    //
    ASSERT(FALSE);

    return S_FALSE;
}



/* virtual */
CIISObject * 
CIISObject::GetParentObject() const
/*++

Routine Description:

    Get the parent object (in the scope view) of this object.

Arguments:

    None

Return Value:

    Pointer to the parent object, or NULL if not found

--*/
{
    MMC_COOKIE cookie;
    HSCOPEITEM hParent;

    HRESULT hr = GetScopeView()->GetParentItem(
        GetScopeHandle(), 
        &hParent, 
        &cookie
        );

    if (hParent == NULL || cookie == 0L || FAILED(hr))
    {
        //
        // None found
        //
        return NULL;
    }

    return (CIISObject *)cookie;
}



LPCTSTR
CIISObject::BuildParentPath(
    OUT CString & strParent,
    IN  BOOL fMetabasePath
    ) const
/*++

Routine Description:

    Walk up the parent nodes to build either a metabase path,
    or a physical path to the parent of this node.

Arguments:

    CString & strParent     : Returns the parent path
    BOOL fMetabasePath      : If TRUE want full metabse path
                              If FALSE, relative path from the instance only

Return Value:

    Pointer to the path

--*/
{
    const CIISObject * pObject = this;

    //
    // Walk up the tree to build a proper parent path
    //
    for (;;)
    {
        if (pObject->IsTerminalPoint(fMetabasePath))
        {
            break;
        }

        pObject = pObject->GetParentObject();

        if (pObject == NULL)
        {
            //
            // Should have stopped before this.
            //
            ASSERT(FALSE);
            break;
        }

        PrependParentPath(
            strParent, 
            pObject->QueryNodeName(fMetabasePath), 
            g_chSep
            );

        //
        // Keep looking
        //
    }

    TRACEEOLID("BuildParentPath: " << strParent);
    
    return strParent;
}



LPCTSTR
CIISObject::BuildFullPath(
    OUT CString & strPath,
    IN  BOOL fMetabasePath
    ) const
/*++ 

Routine Description:

    Build complete path for the current object.  Either a metabase path or
    a directory path.

Arguments:

Return Value:

    Pointer to the path

--*/
{
    strPath = QueryNodeName(fMetabasePath);
    BuildParentPath(strPath, fMetabasePath);
    TRACEEOLID("CIISObject::BuildFullPath:" << strPath);

    return strPath;
}



LPCTSTR 
CIISObject::BuildPhysicalPath(
    OUT CString & strPhysicalPath
    ) const
/*++

Routine Description:

    Build a physical path for the current node.  Starting with the current
    node, walk up the tree appending node names until a virtual directory
    with a real physical path is found

Arguments:

    CString & strPhysicalPath       : Returns file path

Return Value:

    Pointer to path

--*/
{
    const CIISObject * pObject = this;

    //
    // Walk up the tree to build a physical path
    //
    for (;;)
    {
        if (pObject->IsVirtualDirectory())
        {
            //
            // Path is properly terminated here
            //
            PrependParentPath(
                strPhysicalPath, 
                pObject->QueryPhysicalPath(), 
                _T('\\')
                );
            break;
        }

        PrependParentPath(
            strPhysicalPath, 
            pObject->QueryNodeName(), 
            _T('\\')
            );

        pObject = pObject->GetParentObject();

        if (pObject == NULL)
        {
            //
            // Should have stopped before this.
            //
            ASSERT(FALSE);
            break;
        }

        //
        // Keep looking
        //
    }

    TRACEEOLID("BuildPhysicalPath: " << strPhysicalPath);
    
    return strPhysicalPath;
}



DWORD
CIISObject::QueryInstanceID()
/*++

Routine Description:

    Return the ID of the owner instance

Arguments:

    None

Return Value:

    Owner instance ID or 0xffffffff

--*/
{
    CIISInstance * pInstance = FindOwnerInstance();
    
    return pInstance ? pInstance->QueryID() : 0xffffffff;
}



HRESULT
CIISObject::Open()
/*++

Routine Description:

    Open the physical path of the current node in the explorer

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CString strPath;
    BuildPhysicalPath(strPath);

    return ShellExecuteDirectory(_T("open"), GetMachineName(), strPath);
}



HRESULT
CIISObject::Explore()
/*++

Routine Description:

    "explore" the physical path of the current node

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CString strPath;
    BuildPhysicalPath(strPath);

    return ShellExecuteDirectory(_T("explore"), GetMachineName(), strPath);
}



HRESULT
CIISObject::Browse()
/*++

Routine Description:

    Bring up the current path in the browser.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CString strPath;

    BuildFullPath(strPath, FALSE);

    CIISInstance * pInstance = FindOwnerInstance();

    if (pInstance == NULL)
    {
        ASSERT(FALSE);

        return CError::HResult(ERROR_INVALID_PARAMETER);
    }

    return pInstance->ShellBrowsePath(strPath);
}



//
// Machine pages
//
CObListPlus * CIISMachine::s_poblNewInstanceCmds = NULL;
CString CIISMachine::s_strLocalMachine;



//
// Define result view for machine objects
//
int CIISMachine::rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_COMPUTER_NAME,
    IDS_RESULT_COMPUTER_LOCAL,
    IDS_RESULT_COMPUTER_CONNECTION_TYPE,
    IDS_RESULT_STATUS,
};
    


int CIISMachine::rgnWidths[COL_TOTAL] =
{
    200,
    50,
    100,
    200,
};



/* static */
void
CIISMachine::InitializeHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result view headers for a machine object

Arguments:

    LPHEADERCTRL pHeader : Pointer to header control

Return Value:

    None.

--*/
{
    CIISObject::BuildResultView(pHeader, COL_TOTAL, rgnLabels, rgnWidths);
}



CIISMachine::CIISMachine(
    IN LPCTSTR lpszMachineName
    )
/*++

Routine Description:

    Constructor for machine object
                                                                       
Arguments:

    LPCTSTR lpszMachineName : Machine name

Return Value:

    N/A

--*/
    : CIISObject(cMachineNode),
      m_strMachineName(lpszMachineName),
      m_fLocal(::IsServerLocal(lpszMachineName))
{
    ASSERT(lpszMachineName != NULL);

    VERIFY(m_strDisplayName.LoadString(IDS_NODENAME));

    //
    // Initialize static members
    //
    if (CIISMachine::s_strLocalMachine.IsEmpty())
    {
        //
        // AFX_MANAGE_STATE required for resource load
        //
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        TRACEEOLID("Initializing static strings");
        VERIFY(CIISMachine::s_strLocalMachine.LoadString(IDS_LOCAL_COMPUTER));
    }
	// Determine if current user is administrator
	CMetaKey key(lpszMachineName);
	if (key.Succeeded())
	{
		DWORD err = DetermineIfAdministrator(
			&key,
			_T("w3svc"),
			0,
			&m_fIsAdministrator);
		if (err != ERROR_SUCCESS)
		{
			err = DetermineIfAdministrator(
			   &key,
			   _T("msftpsvc"),
			   0,
			   &m_fIsAdministrator);
		}
	}
}



/* virtual */
BOOL 
CIISMachine::IsConfigurable() const
/*++

Routine Description:

    Determine if the machine is configurable, that is at least
    one property page handler was registered for it.
                                                                       
Arguments:

    None

Return Value:

    TRUE if the machine is configurable, FALSE otherwise

--*/
{
    //
    // Codework: do a metabase check here
    //    
    return m_fIsAdministrator;
    //return  CIISMachine::s_poblISMMachinePages != NULL
    //     && CIISMachine::s_poblISMMachinePages->GetCount() > 0;
}



/* virtual */
HRESULT
CIISMachine::Configure(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Configure the machine object.  In order for the machine object to
    be configurable, at least one property page add-on function must
    be defined.
                                                                       
Arguments:

    CWnd * pParent : Parent window handle

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

    CError err;

/*
    try
    {
        CString strTitle, str;
        
        VERIFY(str.LoadString(IDS_MACHINE_PROPERTIES));

        strTitle.Format(str, GetMachineName());

        PROPSHEETHEADER psh;
        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_DEFAULT | PSH_HASHELP;
        psh.hwndParent = pParent ? pParent->m_hWnd : NULL;
        psh.hInstance = NULL;
        psh.pszIcon = NULL;
        psh.pszCaption = (LPTSTR)(LPCTSTR)strTitle;
        psh.nStartPage = 0;
        psh.nPages = 0;
        psh.phpage = NULL;
        psh.pfnCallback = NULL;

        ASSERT(CIISMachine::s_poblISMMachinePages != NULL);
        CObListIter obli(*CIISMachine::s_poblISMMachinePages);
        CISMMachinePageExt * pipe;
        while (pipe = (CISMMachinePageExt *)obli.Next())
        {
            DWORD errDLL = pipe->Load();
            if (errDLL == ERROR_SUCCESS)
            {
                errDLL = pipe->AddPages(GetMachineName(), &psh);
            }

            if (errDLL != ERROR_SUCCESS)
            {
                //
                // Unable to load, display error message
                // with the name of the DLL.  This does not
                // necessarily pose problems for the rest
                // of the property sheet.
                //
                ::DisplayFmtMessage(
                    IDS_ERR_NO_LOAD,
                    MB_OK,
                    0,
                    (LPCTSTR)*pipe,
                    ::GetSystemMessage(errDLL)
                    );
            }
        }

        if (psh.nPages > 0)
        {
            //
            // Display the property sheet
            //
            PropertySheet(&psh);

            //
            // Now clean up the property sheet structure
            //
            // FreeMem(psh.phpage);
        }

        //
        // Unload the extentions
        //
        obli.Reset();
        while (pipe = (CISMMachinePageExt *)obli.Next())
        {
            if ((HINSTANCE)*pipe)
            {
                VERIFY(pipe->UnLoad());
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }
*/

    return err;
}



/* virtual */
HRESULT
CIISMachine::ConfigureMMC(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LPARAM param,
    IN LONG_PTR handle
    )
/*++

Routine Description:

    Configure using MMC property sheets

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Prop sheet provider
    LPARAM param                        : Prop parameter
    LONG_PTR handle                     : console handle

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HINSTANCE hOld = AfxGetResourceHandle();
    AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));

    HINSTANCE hInstance = AfxGetInstanceHandle();
    CIISMachinePage * ppgMachine = new CIISMachinePage(
        GetMachineName(),
        hInstance
        );

    AfxSetResourceHandle(hOld);

    if (ppgMachine)
    {
        CError err(ppgMachine->QueryResult());

        if (err.Failed())
        {
            if (err == REGDB_E_CLASSNOTREG)
            {
                //
                // There isn't a metabase -- fail gracefully
                //
                ::AfxMessageBox(IDS_NO_MACHINE_PROPS);
                err.Reset();
            }

            delete ppgMachine;

            return err;
        }

        //
        // Patch MFC property page class.
        //
        ppgMachine->m_psp.dwFlags |= PSP_HASHELP;
        MMCPropPageCallback(&ppgMachine->m_psp);

        HPROPSHEETPAGE hPage = CreatePropertySheetPage(
            (LPCPROPSHEETPAGE)&ppgMachine->m_psp
            );

        if (hPage != NULL)
        {
            lpProvider->AddPage(hPage);

            return ERROR_SUCCESS;
        }
    }

    return ERROR_NOT_ENOUGH_MEMORY;   
}



/* virtual */ 
HRESULT 
CIISMachine::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback
    )
/*++

Routine Description:

    Add menu items for machine object

Arguments:

    LPCONTEXTMENUCALLBACK pContextMenuCallback : Context menu items callback

Return Value:

    HRESULT

--*/
{
    CIISObject::AddMenuItems(lpContextMenuCallback);

    //
    // Add metabase backup/restore
    //
    lpContextMenuCallback->AddItem(&menuSep);
    AddMenuItemByCommand(lpContextMenuCallback, IDM_METABACKREST);

    //
    // Add 'IIS shutdown' command
    //
    // ISSUE: Should there be a capability bit?
    //
    AddMenuItemByCommand(lpContextMenuCallback, IDM_SHUTDOWN);

    if (!CanAddInstance(GetMachineName()))
    {
        return FALSE;
    }

    //
    // Add one 'new instance' for every service that supports
    // instances
    //
    ASSERT(CIISMachine::s_poblNewInstanceCmds);

    POSITION pos = CIISMachine::s_poblNewInstanceCmds->GetHeadPosition();

    int lCommandID = IDM_NEW_EX_INSTANCE;
    HRESULT hr;

    while(pos)
    {
        CNewInstanceCmd * pcmd = 
            (CNewInstanceCmd *)s_poblNewInstanceCmds->GetNext(pos);
        ASSERT(pcmd != NULL);

        CONTEXTMENUITEM cmi;
        cmi.strName = pcmd->GetMenuCommand().GetBuffer(0);
        cmi.strStatusBarText = pcmd->GetTTText().GetBuffer(0);
        cmi.lCommandID = lCommandID++;
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
        cmi.fFlags = 0;
        cmi.fSpecialFlags = 0;

        hr = lpContextMenuCallback->AddItem(&cmi);
        ASSERT(SUCCEEDED(hr));
    }

    return S_OK;
}



/* virtual */
HRESULT
CIISMachine::AddNextTaskpadItem(
    OUT MMC_TASK * pTask
    )
/*++

Routine Description:

    Add next taskpad item

Arguments:

    MMC_TASK * pTask    : Task structure to fill in

Return Value:

    HRESULT

--*/
{
    //
    // Add one 'new instance' for every service that supports
    // instances
    //
    ASSERT(CIISMachine::s_poblNewInstanceCmds);

    static POSITION pos = NULL;
    static BOOL fShownBackup = FALSE;
    static int lCommandID = -1;

    HRESULT hr;

    CString strName, strStatus, strMouseOn, strMouseOff;
    long lCmdID;

    //
    // Metabase backup/restore
    //
    if (!fShownBackup)
    {
        //
        // AFX_MANAGE_STATE required for resource load
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        CString strResURL;
        hr = BuildResURL(strResURL);

        if (FAILED(hr))
        {
            return hr;
        }
    
        VERIFY(strName.LoadString(IDS_MENU_BACKUP));
        VERIFY(strStatus.LoadString(IDS_MENU_TT_BACKUP));

        strMouseOn = strResURL + RES_TASKPAD_BACKUP;
        strMouseOff = strMouseOn;
        lCmdID = IDM_METABACKREST;

        ++fShownBackup;
    }
    else
    {
        //
        // Display the new instance commands for each service that 
        // supports it.
        //
        if (lCommandID == -1)
        {
            //
            // Initialize (use lCommandID == -1 as a flag
            // to indicate we're at the beginning of the list)
            //
            if (CanAddInstance(GetMachineName()))
            {
                pos = CIISMachine::s_poblNewInstanceCmds->GetHeadPosition();
                lCommandID = IDM_NEW_EX_INSTANCE;
            }
            else
            {
                return S_FALSE;
            }
        }

        if (pos == NULL)
        {
            //
            // No more items remain in the list.
            //
            lCommandID = -1;
            fShownBackup = FALSE;

            return S_FALSE;
        }

        CNewInstanceCmd * pcmd = 
            (CNewInstanceCmd *)s_poblNewInstanceCmds->GetNext(pos);
        ASSERT(pcmd != NULL);

        CString strResURL;
        hr = BuildResURL(strResURL, pcmd->QueryInstanceHandle());

        if (FAILED(hr))
        {
            return hr;
        }

        //
        // AFX_MANAGE_STATE required for resource load
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        VERIFY(strStatus.LoadString(IDS_MENU_DS_NEWINSTANCE));

        strMouseOn = strResURL + RES_TASKPAD_NEWSITE;
        strMouseOff = strMouseOn;
        strName = pcmd->GetTTText();

        lCmdID = lCommandID++;
    }

    return AddTaskpadItemByInfo(
        pTask,
        lCmdID,
        strMouseOn,
        strMouseOff,
        strName,
        strStatus
        );
}



/* virtual */
LPCTSTR 
CIISMachine::GetDisplayText(
    OUT CString & strText
    ) const
/*++

Routine Description:

    Get the display text of this object
                                                                       
Arguments:

    CString & strText : String in which display text is to be returned

Return Value:

    Pointer to the string

--*/
{
    try
    {
        if (m_fIsExtension)
        {
            //
            // This is an extension
            //
            strText = m_strDisplayName;
        }
        else
        {
            if (IsLocalMachine())
            {
                ASSERT(!s_strLocalMachine.IsEmpty());
                strText.Format(s_strLocalMachine, m_strMachineName);
            }
            else
            {
                strText = m_strMachineName;
            }
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in GetDisplayText");
        e->ReportError();
        e->Delete();
    }

    return strText;
}



/* virtual */
int 
CIISMachine::QueryBitmapIndex() const
/*++

Routine Description:

    Determine the bitmap index that represents the current item

Arguments:

    None

Return Value:

    Index into the bitmap strip

--*/
{
    if (m_fIsExtension)
    {
        return BMP_INETMGR;
    }

    return IsLocalMachine() ? BMP_LOCAL_COMPUTER : BMP_COMPUTER;
}



/* virtual */
void 
CIISMachine::GetResultDisplayInfo(
    IN  int nCol,
    OUT CString & str,
    OUT int & nImage
    ) const
/*++

Routine Description:

    Get result data item display information.

Arguments:

    int nCol            : Column number
    CString &  str      : String data
    int & nImage        : Image number

Return Value:

    None    

--*/
{
    //
    // Need different icon for extension...
    //
    nImage = QueryBitmapIndex();

    str.Empty();

    switch(nCol)
    {
    case COL_NAME:  // Computer Name
        GetDisplayText(str);
        break;

    case COL_LOCAL: // Local
        if (m_fIsExtension)
        {
            //
            // If we're an extension, display the type
            //
            AFX_MANAGE_STATE(AfxGetStaticModuleState());
            VERIFY(str.LoadString(IDS_SNAPIN_TYPE));
        }
        else
        {
            //
            // 
            str = IsLocalMachine()
                ? CIISObject::s_strYes
                : CIISObject::s_strNo;
        }
        break;

    case COL_TYPE: // Connection Type
        if (m_fIsExtension)
        {
            //
            // If we're an extension snap-in we should display
            // the snap-in description in this column
            //
            AFX_MANAGE_STATE(AfxGetStaticModuleState());
            VERIFY(str.LoadString(IDS_SNAPIN_DESC));
        }
        else
        {
            str = IS_NETBIOS_NAME(GetMachineName())
                ? CIISObject::s_strNetBIOS
                : CIISObject::s_strTCPIP;
        }
        break;

    case COL_STATUS:
        break;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
    }
}



int 
CIISMachine::Compare(
    IN int nCol, 
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Compare against another CIISObject

Arguments:

    int nCol                : Compare on this column
    CIISObject * pObject    : Compare against this object

Routine Description:

    Comparison Return Value

--*/
{
    ASSERT(QueryGUID() == pObject->QueryGUID());
    if (QueryGUID() != pObject->QueryGUID())
    {
        //
        // Invalid comparison
        //
        return +1;
    }

    CString str1, str2;
    int n1, n2;

    CIISMachine * pMachine = (CIISMachine *)pObject;

    switch(nCol)
    {
    case COL_NAME: // Computer Name
        GetDisplayText(str1);
        pMachine->GetDisplayText(str2);
        return str1.CompareNoCase(str2);

    case COL_LOCAL: // Local
        n1 = IsLocalMachine();
        n2 = pMachine->IsLocalMachine();   
        return n1 - n2;

    case COL_TYPE: // Connection Type
        n1 = IS_NETBIOS_NAME(GetMachineName());
        n2 = IS_NETBIOS_NAME(pMachine->GetMachineName());
        return n1 - n2;

    case COL_STATUS:
        return 0;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
    }

    return -1;
}



void
CIISMachine::InitializeChildHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Build result view underneath

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    CIISInstance::InitializeHeaders(pHeader);
}



//
// Static Initialization
//
CString CIISInstance::s_strFormatState;
BOOL CIISInstance::s_fServerView = TRUE;
BOOL CIISInstance::s_fAppendState = TRUE;



//
// Instance Result View definition
//
int CIISInstance::rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_SERVICE_STATE,
    IDS_RESULT_SERVICE_DOMAIN_NAME,
    IDS_RESULT_SERVICE_IP_ADDRESS,
    IDS_RESULT_SERVICE_TCP_PORT,
    IDS_RESULT_STATUS,
};
    


int CIISInstance::rgnWidths[COL_TOTAL] =
{
    180,
    70,
    120,
    105,
    40,
    200,
};



/* static */
void 
CIISInstance::InitializeStrings()
/*++

Routine Description:

    Static method to initialize the strings.    
                                                                       
Arguments:

    None

Return Value:

    None

--*/
{
    if (!IsInitialized())
    {
        TRACEEOLID("Initializing static strings");

        //
        // iisui.dll is an extension DLL, and this should 
        // load automatically, but doesn't -- why?
        //
        HINSTANCE hOld = AfxGetResourceHandle();
        AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));
        VERIFY(CIISInstance::s_strFormatState.LoadString(IDS_INSTANCE_STATE_FMT));
        AfxSetResourceHandle(hOld);
    }
}



/* static */
void
CIISInstance::InitializeHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    CIISObject::BuildResultView(pHeader, COL_TOTAL, rgnLabels, rgnWidths);
}



CIISInstance::CIISInstance(
    IN CServerInfo * pServerInfo
    )
/*++

Routine Description:

    Constructor for instance object without instance ID code.  In other
    words, this is a wrapper for a plain-old down-level CServerInfo
    object.
                                                                       
Arguments:

    CServerInfo * pServerInfo : Controlling server info

Return Value:

    N/A

--*/
    : CIISObject(cInstanceNode),
      m_fDownLevel(TRUE),
      m_fDeletable(FALSE),
      m_fClusterEnabled(FALSE),
      m_fLocalMachine(FALSE),
      m_hrError(S_OK),
      m_sPort(0),
      m_dwIPAddress(0L),
      m_strHostHeaderName(),
      m_strComment(),
      m_strMachine(),
      m_pServerInfo(pServerInfo)
{
    if (!IsInitialized())
    {
        CIISInstance::InitializeStrings();
    }

    //
    // Some service types do not support instances, but
    // still understand the instance codes
    //
    ASSERT(m_pServerInfo != NULL);
    m_dwID = 0L;
    m_strMachine = m_pServerInfo->QueryServerName();
    m_fLocalMachine = ::IsServerLocal(m_strMachine);
}



CIISInstance::CIISInstance(
    IN ISMINSTANCEINFO * pii,
    IN CServerInfo * pServerInfo
    )
/*++

Routine Description:

    Initialize IIS Instance from ISMINSTANCEINFO structure

Arguments:

    ISMINSTANCEINFO * pii     : Pointer to ISMINSTANCEINFO structure
    CServerInfo * pServerInfo : Server info structure

Return Value:

    N/A

--*/
    : CIISObject(cInstanceNode),
      m_fDownLevel(FALSE),
      m_fLocalMachine(),
      m_strMachine(),
      m_pServerInfo(pServerInfo)
{
    InitializeFromStruct(pii);

    if (!IsInitialized())
    {
        CIISInstance::InitializeStrings();
    }

    ASSERT(m_pServerInfo != NULL);
    m_strMachine = m_pServerInfo->QueryServerName();
    m_fLocalMachine = ::IsServerLocal(m_strMachine);
}



void
CIISInstance::InitializeFromStruct(
    IN ISMINSTANCEINFO * pii
    )
/*++

Routine Description:

    Initialize data from ISMINSTANCEINFO structure

Arguments:

    ISMINSTANCEINFO * pii     : Pointer to ISMINSTANCEINFO structure

Return Value:

    None.

--*/
{
    ASSERT(pii);

    m_dwID              = pii->dwID;
    m_strHostHeaderName = pii->szServerName;
    m_strComment        = pii->szComment;
    m_nState            = pii->nState;
    m_dwIPAddress       = pii->dwIPAddress;
    m_sPort             = pii->sPort;
    m_fDeletable        = pii->fDeletable;
    m_fClusterEnabled   = pii->fClusterEnabled;
    
    CError err(pii->dwError);
    m_hrError           = err;

    m_strRedirPath      = pii->szRedirPath;
    m_fChildOnlyRedir   = pii->fChildOnlyRedir;

    //
    // Home directory path should exist unless someone's been
    // messing up the metabase.
    //
    m_strPhysicalPath   = pii->szPath;

    m_strNodeName.Format(_T("%s%c%s%c%ld%c%s"),
        g_cszMachine,
        g_chSep,
        GetServerInfo()->GetMetabaseName(),
        g_chSep,
        m_dwID,
        g_chSep,
        g_cszRoot
        );

    TRACEEOLID(m_strNodeName);
}               



/* virtual */
BOOL 
CIISInstance::IsRunning() const
/*++

Routine Description:

    Check to see if this instance is currently running.

Arguments:

    None.

Return Value:

    TRUE if currently running

Notes:

    On a down-level (v3) version, this applies to the service, not
    the instance

--*/
{
    if (IsDownLevel())
    {
        ASSERT(m_pServerInfo != NULL);
        return m_pServerInfo->IsServiceRunning();
    }

    return m_nState == INetServiceRunning;
}



/* virtual */
BOOL 
CIISInstance::IsStopped() const
/*++

Routine Description:

    Check to see if this instance is currently stopped.

Arguments:

    None.

Return Value:

    TRUE if currently stopped

Notes:

    On a down-level (v3) version, this applies to the server, not
    the instance

--*/
{
    if (IsDownLevel())
    {
        ASSERT(m_pServerInfo != NULL);
        return m_pServerInfo->IsServiceStopped();
    }

    return m_nState == INetServiceStopped;
}



/* virtual */
BOOL 
CIISInstance::IsPaused() const
/*++

Routine Description:

    Check to see if this instance is currently paused.

Arguments:

    None.

Return Value:

    TRUE if currently paused

Notes:

    On a down-level (v3) version, this applies to the server, not
    the instance

--*/
{
    if (IsDownLevel())
    {
        ASSERT(m_pServerInfo != NULL);

        return m_pServerInfo->IsServicePaused();
    }

    return m_nState == INetServicePaused;
}



/* virtual */
int
CIISInstance::QueryState() const
/*++

Routine Description:

    Get the ISM state of the instance

Arguments:

    None.

Return Value:

    The ISM (INet*) state of the instance

Notes:

    On a down-level (v3) version, this applies to the server, not
    the instance

--*/
{
    if (IsDownLevel())
    {
        return m_pServerInfo->QueryServiceState();
    }

    return m_nState;
}



/* virtual */
HRESULT
CIISInstance::ChangeState(
    IN int nNewState
    )
/*++

Routine Description:

    Change the ISM state of the instance

Arguments:

    int nNewState

Return Value:

    Error Return Code

Notes:

    On a down-level (v3) version, this applies to the server, not
    the instance

--*/
{
    ASSERT(m_pServerInfo != NULL);

    int * pnCurrentState;
    DWORD dwID;

    if (IsClusterEnabled())
    {
        //
        // Not supported on cluster server
        //
        return ERROR_BAD_DEV_TYPE;
    }

    if (IsDownLevel())
    {
        dwID = 0;
        pnCurrentState = m_pServerInfo->GetServiceStatePtr();
    }
    else
    {   
        dwID = QueryID();
        pnCurrentState = &m_nState;
    }

    return m_pServerInfo->ChangeServiceState(nNewState, pnCurrentState, dwID);
}



/* virtual */
HRESULT
CIISInstance::Configure(
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Configure the instance object

Arguments:

    CWnd * pParent      : Optional parent window

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_pServerInfo != NULL);

    //
    // Set help file
    //
    theApp.SetHelpPath(m_pServerInfo);

    CError err(m_pServerInfo->ConfigureServer(pParent->m_hWnd, QueryID()));

    //
    // Restore help path
    //
    theApp.SetHelpPath();

    if (err.Succeeded())
    {
        RefreshData();
    }

    return err;
}



/* virtual */
HRESULT
CIISInstance::RefreshData()
/*++

Routine Description:

    Refresh internal data

Arguments:

    None

Return Value:

    Error return code.

--*/
{
    CError err;

    if (!IsDownLevel())
    {
        ISMINSTANCEINFO ii;
        err = m_pServerInfo->QueryInstanceInfo(
            WITHOUT_INHERITANCE, 
            &ii, 
            QueryID()
            );

        if (err.Succeeded())
        {
            InitializeFromStruct(&ii);        
        }
    }

    return err;
}



/* virtual */
HRESULT
CIISInstance::ConfigureMMC(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LPARAM param,
    IN LONG_PTR handle
    )
/*++

Routine Description:

    Configure using MMC property sheets

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Prop sheet provider
    LPARAM param                        : Prop parameter
    LONG_PTR handle                     : console handle

Return Value:

    Error return code

--*/
{
    ASSERT(m_pServerInfo != NULL);

    return m_pServerInfo->MMMCConfigureServer(
        lpProvider,
        param,
        handle,
        QueryID()
        );
}



/* virtual */
LPCTSTR 
CIISInstance::GetStateText() const
/*++

Routine Description:

    Return text representation of current state (running/paused/stopped).
                                                                       
Arguments:

    None

Return Value:

    Pointer to the string

--*/
{
    ASSERT(!CIISObject::s_strRunning.IsEmpty());

    return IsStopped()
        ? CIISObject::s_strStopped
        : IsPaused()
            ? CIISObject::s_strPaused
            : IsRunning()
                ? CIISObject::s_strRunning
                : CIISObject::s_strUnknown;
}



/* virtual */
LPCTSTR 
CIISInstance::GetDisplayText(
    OUT CString & strText
    ) const
/*++

Routine Description:

    Get the display text of this object
                                                                       
Arguments:

    CString & strText : String in which display text is to be returned

Return Value:

    Pointer to the string

--*/
{
    try
    {
        if (m_fDownLevel)
        {
            ASSERT(m_pServerInfo != NULL);

            if (CIISInstance::s_fServerView)
            {
                strText = m_pServerInfo->GetServiceName();
            }
            else
            {
                strText = m_pServerInfo->QueryServerName();
            }
        }
        else
        {
            //
            // GetDisplayText loads from resources
            //
            AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

            CIPAddress ia(m_dwIPAddress);

            CInstanceProps::GetDisplayText(
                strText,
                GetComment(),
                GetHostHeaderName(),
                m_pServerInfo->GetServiceName(),
                ia,
                m_sPort,
                m_dwID
                );
        }

        //
        // Append state (paused, etc) if not running
        //
        if (CIISInstance::s_fAppendState && !IsRunning())
        {
            CString strState;
            strState.Format(CIISInstance::s_strFormatState, GetStateText());
            strText += strState;    
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in GetDisplayText");
        e->ReportError();
        e->Delete();
    }

    return strText;
}



/* virtual */
HRESULT
CIISInstance::AddChildNode(
    IN OUT CIISChildNode *& pChild
    )
/*++

Routine Description:

    Add child node under current node

Arguments:

    CIISChildNode *& pChild     : Child node to be added

Return Value:

    Error return code.

--*/
{
    pChild = NULL;

    ISMCHILDINFO ii;
    CString strParent(g_cszRoot);
    CError err(GetServerInfo()->AddChild(
        &ii, 
        sizeof(ii), 
        QueryID(), 
        strParent
        ));

    if (err.Succeeded())
    {
        pChild = new CIISChildNode(&ii, this);
    }

    return err;
}



/* virtual */
BOOL 
CIISInstance::ChildrenExpanded() const
/*++

Routine Description:

    Determine if the child items of this node have already been expanded

Arguments:

    None

Return Value:

    TRUE if the items do not need expansion, FALSE if they do.

--*/
{
    ASSERT(m_pServerInfo != NULL);

    if (m_pServerInfo->SupportsChildren())
    {
        //
        // Note: timestamps ignored, because MMC will never send me another
        // expansion notification, so we can't refresh after a certain time.
        //
        return m_tmChildrenExpanded > 0L;
    }

    //
    // Can't drill down any lower than this.
    //
    return TRUE;
}



/* virtual */
HRESULT
CIISInstance::ExpandChildren(
    IN HSCOPEITEM pParent
    )
/*++

Routine Description:

    Mark the children as being expanded.

Arguments:

    HSCOPEITEM pParent      : Parent scope item

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pServerInfo != NULL);

    if (m_pServerInfo->SupportsChildren() )
    {
        //
        // Mark the last epxansion time as being now.
        //
        time(&m_tmChildrenExpanded);

        return S_OK;
    }

    //
    // Can't drill down any lower than this.
    //
    return CError::HResult(ERROR_INVALID_FUNCTION);
}



/* virtual */
int 
CIISInstance::QueryBitmapIndex() const
/*++

Routine Description:

    Get the bitmap index of the object.  This varies with the state
    of the view
                                                                       
Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    ASSERT(m_pServerInfo != NULL);

/*
    return OK()
        ?  m_pServerInfo->QueryBitmapIndex()
        :  BMP_ERROR;
*/

    return m_pServerInfo->QueryBitmapIndex();
}



/* virtual */ 
HRESULT 
CIISInstance::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK pContextMenuCallback
    )
/*++

Routine Description:

    Add context menu items for the instance

Arguments:

    LPCONTEXTMENUCALLBACK pContextMenuCallback : Context menu callback

Return Value:

    HRESULT

--*/
{
    CIISObject::AddMenuItems(pContextMenuCallback);

    if (SupportsInstances() && CanAddInstance(GetMachineName()))
    {
        AddMenuItemByCommand(pContextMenuCallback, IDM_NEW_INSTANCE);    
    }
    
    if (SupportsChildren())
    {
        AddMenuItemByCommand(pContextMenuCallback, IDM_NEW_VROOT);
    }

    if (SupportsSecurityWizard())
    {
        AddMenuItemByCommand(pContextMenuCallback, IDM_TASK_SECURITY_WIZARD);
    }

    return S_OK;
}



/* virtual */
HRESULT
CIISInstance::AddNextTaskpadItem(
    OUT MMC_TASK * pTask
    )
/*++

Routine Description:

    Add next taskpad item

Arguments:

    MMC_TASK * pTask    : Task structure to fill in

Return Value:

    HRESULT

--*/
{
    //
    // CODEWORK:  Ideally I would call the base class here, but that's
    //            a pain with enumeration
    //
    static int iIndex = 0;

    //
    // Fall through on the switch until an applicable command is found
    //
    UINT nID;
    switch(iIndex)
    {
    case 0:
        if (SupportsInstances() && CanAddInstance(GetMachineName()))
        {
            nID = IDM_NEW_INSTANCE;
            break;
        }

        ++iIndex;

        //
        // Fall through
        //
        
    case 1:    
        if (SupportsChildren())
        {
            nID = IDM_NEW_VROOT;
            break;
        }
        
        ++iIndex;

        //
        // Fall through
        //

    case 2:
        if (SupportsSecurityWizard())
        {
            nID = IDM_TASK_SECURITY_WIZARD;
            break;
        }

        ++iIndex;

        //
        // Fall through
        //

    default:
        //
        // All done
        //
        iIndex = 0;
        return S_FALSE;
    }


    HRESULT hr = AddTaskpadItemByCommand(
        nID, 
        pTask, 
        GetServerInfo()->QueryInstanceHandle()
        );

    if (SUCCEEDED(hr))
    {
        ++iIndex;
    }

    return hr;
}



HRESULT
CIISInstance::Delete()
/*++

Routine Description:

    Handle deletion of the current item

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(m_pServerInfo != NULL);

    return m_pServerInfo->DeleteInstance(m_dwID);
}



HRESULT
CIISInstance::SecurityWizard()
/*++

Routine Description:

    Launch the security wizard on this instance

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(m_pServerInfo != NULL);
    ASSERT(m_pServerInfo->SupportsSecurityWizard());

    CString strPhysicalPath;
    BuildPhysicalPath(strPhysicalPath);

    return m_pServerInfo->ISMSecurityWizard(m_dwID,  _T(""), g_cszRoot);
}



int 
CIISInstance::Compare(
    IN int nCol, 
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Compare against another CIISObject

Arguments:

    int nCol                : Compare on this column
    CIISObject * pObject    : Compare against this object

Routine Description:

    Comparison Return Value

--*/
{
    ASSERT(QueryGUID() == pObject->QueryGUID());

    if (QueryGUID() != pObject->QueryGUID())
    {
        //
        // Invalid comparison
        //
        return +1;
    }

    CString str1, str2;
    CIPAddress ia1, ia2;
    DWORD dw1, dw2;
    int n1, n2;
    CIISInstance * pInstance = (CIISInstance *)pObject;

    switch(nCol)
    {
    case COL_DESCRIPTION:   // Description
        GetDisplayText(str1);
        pInstance->GetDisplayText(str2);
        return str1.CompareNoCase(str2);

    case COL_STATE:         // State 
        str1 = GetStateText();
        str2 = pInstance->GetStateText();
        return str1.CompareNoCase(str2);

    case COL_DOMAIN_NAME:   // Domain name
        str1 = GetHostHeaderName();
        str2 = pInstance->GetHostHeaderName();
        return str1.CompareNoCase(str2);

    case COL_IP_ADDRESS:    // IP Address
        ia1 = GetIPAddress();
        ia2 = pInstance->GetIPAddress();
        return ia1.CompareItem(ia2);

    case COL_TCP_PORT:      // Port
        n1 = GetPort();
        n2 = pInstance->GetPort();
        return n1 - n2;

    case COL_STATUS:
        dw1 = m_hrError;
        dw2 = pInstance->QueryError();
        return dw1 > dw2 ? +1 : dw1==dw2 ? 0 : -1;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
        return 0;
    }

    return -1;
}



/* virtual */
void 
CIISInstance::GetResultDisplayInfo(
    IN  int nCol,
    OUT CString & str,
    OUT int & nImage
    ) const
/*++

Routine Description:

    Get result data item display information.

Arguments:

    int nCol            : Column number
    CString &  str      : String data
    int & nImage        : Image number

Return Value:

    None    

--*/
{
    nImage = QueryBitmapIndex();
    CIPAddress ia;

    str.Empty();
    switch(nCol)
    {
    case COL_DESCRIPTION:   // Description
        GetDisplayText(str);
        break;

    case COL_STATE:         // State 
        if (OK())
        {
            str = GetStateText();
        }
        break;

    case COL_DOMAIN_NAME:   // Domain name
        if (OK())
        {
            str = GetHostHeaderName();
        }
        break;

    case COL_IP_ADDRESS:    // IP Address
        if (!IsDownLevel() && OK())
        {
            ia = GetIPAddress();
            if (ia.IsZeroValue())
            {
                str = CIISObject::s_strDefaultIP;
            }
            else
            {
                ia.QueryIPAddress(str);
            }
        }
        break;

    case COL_TCP_PORT:      // Port
        if (OK())
        {
            if (GetPort())
            {
                str.Format(_T("%u"), GetPort());
            }
            else
            {
                str.Empty();
            }
        }
        break;

    case COL_STATUS:
        if (!OK())
        {
            CError::TextFromHRESULT(QueryErrorCode(), str);
        }
        break;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
    }
}



/* virtual */ 
LPCTSTR 
CIISInstance::GetComment() const
/*++

Routine Description:

    Get the comment string

Arguments:

    None

Return Value:

    Pointer to the comment string

--*/
{
    if (IsDownLevel())
    {
        ASSERT(m_pServerInfo != NULL);
        return m_pServerInfo->GetServerComment();
    }

    return m_strComment;
}



HRESULT
CIISInstance::ShellBrowsePath(
    IN LPCTSTR lpszPath
    )
/*++

Routine Description:

    Generate an URL from the instance and path information given, and
    attempt to resolve that URL

Arguments:

    IN LPCTSTR lpszPath             : Path

Return Value:

    Error return code

--*/
{
    CString strDir;
    CString strOwner;

    ASSERT(IsBrowsable());

    ///////////////////////////////////////////////////////////////////////////
    //
    // Try to build an URL.  Use in order of priority:
    //
    //     Domain name:port/root
    //     ip address:port/root
    //     computer name:port/root
    //
    if (HasHostHeaderName())
    {
        strOwner = GetHostHeaderName();
    }
    else if (HasIPAddress())
    {
        CIPAddress ia(GetIPAddress());
        ia.QueryIPAddress(strOwner);
    }
    else
    {
        //
        // Use the computer name (w/o backslashes)
        //
		if (IsLocalMachine())
		{
			strOwner = _T("localhost");
		}
		else
		{
			LPCTSTR lpOwner = GetMachineName();
			strOwner = PURE_COMPUTER_NAME(lpOwner);
		}
    }

    int nPort = GetPort();

    LPCTSTR lpProtocol = GetServerInfo()->GetProtocol();

    if (lpProtocol == NULL)
    {
        return CError::HResult(ERROR_INVALID_PARAMETER);
    }

    //
    // "Root" is a metabase concept which has no place in the 
    // path.
    //
    TRACEEOLID(lpszPath);
    lpszPath += lstrlen(g_cszRoot);
    strDir.Format(
        _T("%s://%s:%u%s"), 
        lpProtocol, 
        (LPCTSTR)strOwner, 
        nPort, 
        lpszPath
        );

    TRACEEOLID("Attempting to open URL: " << strDir);

    CError err;
    {
        //
        // AFX_MANAGE_STATE required for wait cursor
        //
        AFX_MANAGE_STATE(AfxGetStaticModuleState());    
        CWaitCursor wait;

        if (::ShellExecute(
            NULL, 
            _T("open"), 
            strDir, 
            NULL,
             _T(""), 
             SW_SHOW
             ) <= (HINSTANCE)32)
        {
            err.GetLastWinError();
        }
    }

    return err;
}



void 
CIISInstance::InitializeChildHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    CIISChildNode::InitializeHeaders(pHeader);
}



int CIISChildNode::rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_VDIR_ALIAS,
    IDS_RESULT_PATH,
    IDS_RESULT_STATUS,
};



int CIISChildNode::rgnWidths[COL_TOTAL] =
{
    120,
    300,
    200,
};



/* static */
void
CIISChildNode::InitializeHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    CIISObject::BuildResultView(pHeader, COL_TOTAL, rgnLabels, rgnWidths);
}



void
CIISChildNode::InitializeChildHeaders(
    LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result headers for a child item

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    InitializeHeaders(pHeader);
}




CIISChildNode::CIISChildNode(
    IN ISMCHILDINFO * pii,
    IN CIISInstance * pOwner
    )
/*++

Routine Description:

    Initialize child node object from ISMCHILDINFO structure information

Arguments:

    ISMCHILDINFO * pii     : Pointer to ISMCHILDINFO structure
    CIISInstance * pOwner  : Owner instance

Return Value:

    N/A

--*/
    : CIISObject(cChildNode),
      m_pOwner(pOwner)
{
    InitializeFromStruct(pii);
}



void 
CIISChildNode::InitializeFromStruct(
    IN ISMCHILDINFO * pii
    )
/*++

Routine Description:

    Initialize data from ISMCHILDINFO structure

Arguments:

    ISMCHILDINFO * pii     : Pointer to ISMCHILDINFO structure

Return Value:

    None.

--*/

{
    ASSERT(pii);
    ASSERT(pii->szAlias);
    ASSERT(pii->szPath);

    try
    {
        m_fEnabledApplication = pii->fEnabledApplication;
        CError err(pii->dwError);
        m_hrError = err;
        m_strRedirPath = pii->szRedirPath;
        m_fChildOnlyRedir = pii->fChildOnlyRedir;

        //
        // Initialize base objects
        //
        m_strNodeName = pii->szAlias;
        m_strPhysicalPath = pii->szPath;
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}



/* virtual */
int 
CIISChildNode::QueryBitmapIndex() const
/*++

Routine Description:

    Get the bitmap index of the object.  This varies with the state
    of the view
                                                                       
Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    if (!OK())
    {
        return BMP_ERROR;
    }

    if (IsEnabledApplication())
    {
        return BMP_APPLICATION;
    }

    if (IsVirtualDirectory())
    {
        ASSERT(m_pOwner != NULL);

        return m_pOwner->GetServerInfo()->QueryChildBitmapIndex();
    }

    return BMP_DIRECTORY;
}



/* virtual */
LPCTSTR 
CIISChildNode::GetDisplayText(
    OUT CString & strText
    ) const
/*++

Routine Description:

    Get the display text of this object
                                                                       
Arguments:

    CString & strText : String in which display text is to be returned

Return Value:

    Pointer to the string

--*/
{
    strText = m_strNodeName;

    return strText;
}



/* virtual */ 
HRESULT 
CIISChildNode::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK pContextMenuCallback
    )
/*++

Routine Description:

    Add context menu items relevant to this node

Arguments:

    LPCONTEXTMENUCALLBACK pContextMenuCallback

Return Value:

    HRESULT

--*/
{
    CIISObject::AddMenuItems(pContextMenuCallback);

    AddMenuItemByCommand(pContextMenuCallback, IDM_NEW_VROOT);

    if (SupportsSecurityWizard())
    {
        AddMenuItemByCommand(pContextMenuCallback, IDM_TASK_SECURITY_WIZARD);
    }

    return S_OK;
}



/* virtual */
HRESULT
CIISChildNode::AddNextTaskpadItem(
    OUT MMC_TASK * pTask
    )
/*++

Routine Description:

    Add next taskpad item

Arguments:

    MMC_TASK * pTask    : Task structure to fill in

Return Value:

    HRESULT

--*/
{
    //
    // CODEWORK:  Ideally I would call the base class here, but that's
    //            a pain with enumeration
    //
    static int iIndex = 0;

    //
    // Fall through on the switch until an applicable command is found
    //
    UINT nID;
    switch(iIndex)
    {
    case 0:
        nID = IDM_NEW_VROOT;
        break;

    case 1:
        if (SupportsSecurityWizard())
        {
            nID = IDM_TASK_SECURITY_WIZARD;
            break;
        }

        ++iIndex;

        //
        // Fall through
        //
                
    default:
        //
        // All done
        //
        iIndex = 0;
        return S_FALSE;
    }

    HRESULT hr = AddTaskpadItemByCommand(
        nID, 
        pTask,
        GetServerInfo()->QueryInstanceHandle()
        );

    if (SUCCEEDED(hr))
    {
        ++iIndex;
    }

    return hr;
}



int 
CIISChildNode::Compare(
    IN int nCol, 
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Compare against another CIISObject

Arguments:

    int nCol                : Compare on this column
    CIISObject * pObject    : Compare against this object

Routine Description:

    Comparison Return Value

--*/
{
    ASSERT(QueryGUID() == pObject->QueryGUID());
    if (QueryGUID() != pObject->QueryGUID())
    {
        //
        // Invalid comparison
        //
        return +1;
    }

    DWORD dw1, dw2;

    CIISChildNode * pChild = (CIISChildNode *)pObject;

    switch(nCol)
    {
    case COL_ALIAS:         // Alias
        return m_strNodeName.CompareNoCase(pChild->m_strNodeName);

    case COL_PATH:          // Path
        dw1 = IsRedirected();
        dw2 = pChild->IsRedirected();
        if (dw1 != dw2)
        {
            return dw1 > dw2 ? +1 : -1;
        }

        return GetPhysicalPath().CompareNoCase(pChild->GetPhysicalPath());

    case COL_STATUS:
        dw1 = m_hrError;
        dw2 = pChild->QueryError();
        return dw1 > dw2 ? +1 : dw1==dw2 ? 0 : -1;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
    }

    return -1;
}



/* virtual */
void 
CIISChildNode::GetResultDisplayInfo(
    IN  int nCol,
    OUT CString & str,
    OUT int & nImage
    ) const
/*++

Routine Description:

    Get result data item display information.

Arguments:

    int nCol            : Column number
    CString &  str      : String data
    int & nImage        : Image number

Return Value:

    None    

--*/
{
    nImage = QueryBitmapIndex();

    str.Empty();
    switch(nCol)
    {
    case COL_ALIAS:         // Alias
        str = m_strNodeName;
        break;

    case COL_PATH:          // Path
        if (IsRedirected())
        {
            str.Format(s_strRedirect, m_strRedirPath);
        }
        else
        {
            str = m_strPhysicalPath;
        }
        break;

    case COL_STATUS:
        if (!OK())
        {
            CError::TextFromHRESULT(QueryErrorCode(), str);
        }
        break;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
    }
}



/* virtual */
HRESULT
CIISChildNode::Configure(
    IN CWnd * pParent
    )
/*++

Routine Description:

    Configure the child node object
                                                                       
Arguments:

    CWnd * pParent : Parent window handle

Return Value:

    Error return code

--*/

{
    ASSERT(m_pOwner != NULL);

    //
    // Ok, build a metabase path on the fly now by getting
    // the nodes of the parents up until the owning instance.
    //
    CString strParent;
    BuildParentPath(strParent, FALSE);

    //
    // Set help file
    //
    theApp.SetHelpPath(GetServerInfo());

    CError err(GetServerInfo()->ConfigureChild(
        pParent->m_hWnd, 
        FILE_ATTRIBUTE_VIRTUAL_DIRECTORY,
        m_pOwner->QueryID(), 
        strParent,
        m_strNodeName
        ));

    //
    // Set help file
    //
    theApp.SetHelpPath();

    if (err.Succeeded())
    {
        RefreshData();
    }

    return err;
}



/* virtual */
HRESULT
CIISChildNode::RefreshData()
/*++

Routine Description:

    Refresh internal data

Arguments:

    None

Return Value:

    Error return code.

--*/
{
    ISMCHILDINFO ii;

    CString strParent;
    BuildParentPath(strParent, FALSE);

    CError err(GetServerInfo()->QueryChildInfo(
        WITH_INHERITANCE,
        &ii, 
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        ));

    if (err.Succeeded())
    {
        InitializeFromStruct(&ii);        
    }

    return err;
}



/* virtual */
HRESULT
CIISChildNode::ConfigureMMC(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LPARAM param,
    IN LONG_PTR handle
    )
/*++

Routine Description:

    Configure using MMC property sheets

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Prop sheet provider
    LPARAM param                        : Prop parameter
    LONG_PTR handle                      : console handle

Return Value:

    Error return code

--*/
{
    ASSERT(m_pOwner != NULL);

    CString strParent;
    BuildParentPath(strParent, FALSE);

    return GetServerInfo()->MMCConfigureChild(lpProvider, 
        param,
        handle,
        FILE_ATTRIBUTE_VIRTUAL_DIRECTORY,
        m_pOwner->QueryID(), 
        strParent,
        m_strNodeName
        );
}



/* virtual */
HRESULT
CIISChildNode::AddChildNode(
    CIISChildNode *& pChild
    )
/*++

Routine Description:

    Add child node under current node

Arguments:

    CIISChildNode *& pChild     : Child node to be added

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pOwner != NULL);
    ISMCHILDINFO ii;

    CString strPath;
    BuildFullPath(strPath, FALSE);

    pChild = NULL;
    CError err(GetServerInfo()->AddChild(
        &ii, 
        sizeof(ii), 
        m_pOwner->QueryID(), 
        strPath
        ));

    if (err.Succeeded())
    {
        pChild = new CIISChildNode(&ii, m_pOwner);
    }

    return err;
}



/* virtual */
HRESULT
CIISChildNode::Rename(
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename the current node

Arguments:

    LPCTSTR lpszNewName        : New name

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pOwner != NULL);

    CString strPath;
    BuildParentPath(strPath, FALSE);

    CError err(GetServerInfo()->RenameChild(
        m_pOwner->QueryID(), 
        strPath, 
        m_strNodeName, 
        lpszNewName
        ));

    if (err.Succeeded())
    {
        m_strNodeName = lpszNewName;
    }

    return err;
}



HRESULT
CIISChildNode::Delete()
/*++

Routine Description:

    Delete the current node

Arguments:

    None

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pOwner != NULL);

    CString strParent;
    BuildParentPath(strParent, FALSE);

    return GetServerInfo()->DeleteChild(
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        );
}



HRESULT
CIISChildNode::SecurityWizard()
/*++

Routine Description:

    Launch the security wizard on this child node

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(m_pOwner != NULL);

    CString strParent;
    BuildParentPath(strParent, FALSE);

    return GetServerInfo()->ISMSecurityWizard(
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        );
}



int CIISFileNode::rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_VDIR_ALIAS,
    IDS_RESULT_PATH,
    IDS_RESULT_STATUS,
};
    


int CIISFileNode::rgnWidths[COL_TOTAL] =
{
    120,
    300,
    200,
};



/* static */
void
CIISFileNode::InitializeHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    CIISObject::BuildResultView(pHeader, COL_TOTAL, rgnLabels, rgnWidths);
}



void
CIISFileNode::InitializeChildHeaders(
    IN LPHEADERCTRL pHeader
    )
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL pHeader : Header control

Return Value:

    None

--*/
{
    InitializeHeaders(pHeader);
}



CIISFileNode::CIISFileNode(
    IN LPCTSTR lpszAlias,  
    IN DWORD dwAttributes,
    IN CIISInstance * pOwner,
    IN LPCTSTR lpszRedirect,
    IN BOOL fDir               OPTIONAL
    )
/*++

Routine Description:

    Constructor for file object
                                                                       
Arguments:

    LPCTSTR lpszPath     : Path name
    DWORD dwAttributes    : Attributes
    CIISInstance * pOwner : Owner instance
    BOOL fDir             : TRUE for directory, FALSE for file

Return Value:

    N/A

--*/
    : CIISObject(cFileNode, lpszAlias),
      m_dwAttributes(dwAttributes),
      m_pOwner(pOwner),
      m_fEnabledApplication(FALSE),
      m_fDir(fDir)
{
    m_strRedirPath = lpszRedirect;
}



/* virtual */
int 
CIISFileNode::QueryBitmapIndex() const
/*++

Routine Description:

    Get the bitmap index of the object.  This varies with the state
    of the view
                                                                       
Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    if (IsEnabledApplication())
    {
        return BMP_APPLICATION;
    }

    return IsDirectory() ? BMP_DIRECTORY : BMP_FILE;
}



/* virtual */
LPCTSTR 
CIISFileNode::GetDisplayText(
    OUT CString & strText
    ) const
/*++

Routine Description:

    Get the display text of this object
                                                                       
Arguments:

    CString & strText : String in which display text is to be returned

Return Value:

    Pointer to the string

--*/
{
    strText = m_strNodeName;

    return strText;
}



int 
CIISFileNode::Compare(
    IN int nCol, 
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Compare against another CIISObject

Arguments:

    int nCol                : Compare on this column
    CIISObject * pObject    : Compare against this object

Routine Description:

    Comparison Return Value

--*/
{
    ASSERT(QueryGUID() == pObject->QueryGUID());
    if (QueryGUID() != pObject->QueryGUID())
    {
        //
        // Invalid comparison
        //
        return +1;
    }

    return m_strNodeName.CompareNoCase(pObject->GetNodeName());
}



/* virtual */
void 
CIISFileNode::GetResultDisplayInfo(
    IN  int nCol,
    OUT CString & str,
    OUT int & nImage
    ) const
/*++

Routine Description:

    Get result data item display information.

Arguments:

    int nCol            : Column number
    CString &  str      : String data
    int & nImage        : Image number

Return Value:

    None    

--*/
{
    nImage = QueryBitmapIndex();
    str.Empty();

    switch(nCol)
    {
    case COL_ALIAS:
        str = m_strNodeName;
        break;

    case COL_PATH:          // Path
        if (IsRedirected())
        {
            str.Format(s_strRedirect, m_strRedirPath);
        }
        else
        {
            str.Empty();
        }
        break;

    case COL_STATUS:
        if (!OK())
        {
            CError::TextFromHRESULT(QueryErrorCode(), str);
        }
        break;

    default:
        //
        // No other columns current supported
        //
        ASSERT(FALSE);
    }
}



/* virtual */
CIISObject *
CIISFileNode::GetParentObject() const
/*++

Routine Description:

    Get the parent object (in the scope view) of this object.

Arguments:

    None

Return Value:

    Pointer to the parent object, or NULL if not found

--*/
{
    if (!IsDir())
    {
        //
        // File nodes exist on the result side only, and the scope 
        // item handle they have points to their _parent_ not to 
        // themselves.
        //
        SCOPEDATAITEM sdi;
        sdi.mask = SDI_PARAM;
        sdi.ID = GetScopeHandle(); 
        HRESULT hr = GetScopeView()->GetItem(&sdi);

        return (CIISObject *)sdi.lParam;
    }

    //
    // Directory nodes work like anyone else
    //
    return CIISObject::GetParentObject();
}



/* virtual */
HRESULT
CIISFileNode::Configure(
    IN CWnd * pParent
    )
/*++

Routine Description:

    Configure using private property sheet provider

Arguments:

    CWnd * pParent      : Parent window

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pOwner != NULL);

    CString strParent;
    BuildParentPath(strParent, FALSE);

    //
    // Set help file
    //
    theApp.SetHelpPath(GetServerInfo());

    CError err(GetServerInfo()->ConfigureChild(
        pParent->m_hWnd, 
        m_dwAttributes,
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        ));

    //
    // Restore help file
    //
    theApp.SetHelpPath();

    if (err.Succeeded())
    {
        RefreshData();
    }

    return err;
}



/* virtual */
HRESULT
CIISFileNode::Rename(
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename the current node

Arguments:

    LPCTSTR lpszNewName        : New name

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pOwner != NULL);
	ASSERT(lpszNewName != NULL);

	// We need to check if this new name is OK
	LPTSTR p = (LPTSTR)lpszNewName;
	if (*p == 0)
	{
		AFX_MANAGE_STATE(::AfxGetStaticModuleState() );
		::AfxMessageBox(IDS_ERR_EMPTY_FILENAME, MB_ICONSTOP);
		return ERROR_BAD_PATHNAME;
	}

	while (*p != 0)
	{
		UINT type = PathGetCharType(*p);
		if (type & (GCT_LFNCHAR | GCT_SHORTCHAR))
		{
			p++;
			continue;
		}
		else
		{
			AFX_MANAGE_STATE(::AfxGetStaticModuleState() );
			::AfxMessageBox(IDS_ERR_INVALID_CHAR, MB_ICONSTOP);
			return ERROR_BAD_PATHNAME;
		}
	}

    CString strPath, strPhysicalPath, strDir, strNewName;
    BuildPhysicalPath(strPhysicalPath);
    BuildParentPath(strPath, FALSE);

    //
    // First make sure there's no conflicting name in the metabase
    //
    ISMCHILDINFO ii;
    ii.dwSize = sizeof(ii);

    CError err(GetServerInfo()->QueryChildInfo(
        WITHOUT_INHERITANCE,
        &ii,
        m_pOwner->QueryID(), 
        strPath, 
        lpszNewName
        ));

    if (err.Succeeded())
    {
        //
        // That won't do -- the name already exists in the metabase
        // We handle the UI for this message
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState() );
        ::AfxMessageBox(IDS_ERR_DUP_METABASE);

        return ERROR_ALREADY_EXISTS;
    }

    if (IsLocalMachine() || ::IsUNCName(strPhysicalPath))
    {
        //
        // Local directory, or already a unc path
        //
        strDir = strPhysicalPath;
    }
    else
    {
        ::MakeUNCPath(strDir, GetMachineName(), strPhysicalPath);
    }

    //
    // Have to make a fully qualified destination name
    //
    strNewName = strDir;
    int iPos = strNewName.ReverseFind(_T('\\'));

    if (iPos <= 0)
    {
        //
        // Bogus file name path!
        //
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    strNewName.ReleaseBuffer(iPos + 1);
    strNewName += lpszNewName;

    TRACEEOLID("Attempting to rename file/directory: " << strDir);
    TRACEEOLID("To " << strNewName);

    //
    // Convert to double-null terminated list of null terminated
    // strings
    //
    TCHAR szPath[MAX_PATH + 1];
    TCHAR szDest[MAX_PATH + 1];
    ZeroMemory(szPath, sizeof(szPath));
    ZeroMemory(szDest, sizeof(szDest));
    _tcscpy(szPath, strDir);
    _tcscpy(szDest, strNewName);

    CWnd * pWnd = AfxGetMainWnd();

    //
    // Attempt to delete using shell APIs
    //
    SHFILEOPSTRUCT sos;
    ZeroMemory(&sos, sizeof(sos));
    sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
    sos.wFunc = FO_RENAME;
    sos.pFrom = szPath;
    sos.pTo = szDest;
    sos.fFlags = FOF_ALLOWUNDO;

    int iReturn = SHFileOperation(&sos);

    if (sos.fAnyOperationsAborted)
    {
        err = ERROR_CANCELLED;
    }

    err = iReturn;

    if (!iReturn && !sos.fAnyOperationsAborted)
    {
        //
        // Successful rename -- now handle the metabase
        // rename as well.
        //
        err = GetServerInfo()->RenameChild(
            m_pOwner->QueryID(), 
            strPath, 
            m_strNodeName, 
            lpszNewName
            );

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND
         || err.Win32Error() == ERROR_FILE_NOT_FOUND
           )
        {
            //
            // Harmless
            //
            err.Reset();
        }

        if (err.Succeeded())
        {
            m_strNodeName = lpszNewName;
        }
    }

    return err;
}



HRESULT
CIISFileNode::Delete()
/*++

Routine Description:

    Delete the current node

Arguments:

    None

Return Value:

    Error return code.

--*/
{
    CString strPhysicalPath, strDir;
    BuildPhysicalPath(strPhysicalPath);

    if (IsLocalMachine() || ::IsUNCName(strPhysicalPath))
    {
        //
        // Local directory, or already a unc path
        //
        strDir = strPhysicalPath;
    }
    else
    {
        ::MakeUNCPath(strDir, GetMachineName(), strPhysicalPath);
    }

    TRACEEOLID("Attempting to remove file/directory: " << strDir);

    //
    // Convert to double-null terminated list of null terminated
    // strings
    //
    TCHAR szPath[MAX_PATH + 1];
    ZeroMemory(szPath, sizeof(szPath));
    _tcscpy(szPath, strDir);

    CWnd * pWnd = AfxGetMainWnd();

    //
    // Attempt to delete using shell APIs
    //
    SHFILEOPSTRUCT sos;
    ZeroMemory(&sos, sizeof(sos));
    sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
    sos.wFunc = FO_DELETE;
    sos.pFrom = szPath;
    sos.fFlags = FOF_ALLOWUNDO;

    CError err;
    // Use assignment to avoid conversion and wrong constructor call
    err = ::SHFileOperation(&sos);

    if (sos.fAnyOperationsAborted)
    {
        err = ERROR_CANCELLED;
    }

    if (err.Succeeded())
    {
        //
        // Successful deletion -- now delete metabase properties
        ASSERT(m_pOwner != NULL);

        CString strParent;
        BuildParentPath(strParent, FALSE);

        err = GetServerInfo()->DeleteChild(
            m_pOwner->QueryID(), 
            strParent, 
            m_strNodeName
            );

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND
         || err.Win32Error() == ERROR_FILE_NOT_FOUND
           )
        {
            //
            // Harmless
            //
            err.Reset();
        }
    }

    return err;
}




HRESULT
CIISFileNode::FetchMetaInformation(
    IN  CString & strParent,
    OUT BOOL * pfVirtualDirectory           OPTIONAL
    )
/*++

Routine Description:
    
    Fetch metabase information on this item.

Arguments:

    CString & strParent         : Parent path
    BOOL * pfVirtualDirectory   : Directory

Return Value:

    Error return code.

--*/
{
    ISMCHILDINFO ii;

    CError err(GetServerInfo()->QueryChildInfo(
        WITH_INHERITANCE,
        &ii, 
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        ));

    if (err.Succeeded())
    {
        //
        // Exists in the metabase
        //
        m_fEnabledApplication = ii.fEnabledApplication;
        m_strRedirPath = ii.szRedirPath;
        m_fChildOnlyRedir = ii.fChildOnlyRedir;

        if (pfVirtualDirectory)
        {
            *pfVirtualDirectory = !ii.fInheritedPath;
        }
    }
    else
    {
        //
        // No entry for this in the metabase
        //
        m_fEnabledApplication = FALSE; 
        m_strRedirPath.Empty();
    }

    return S_OK;
}



/* virtual */
HRESULT
CIISFileNode::RefreshData()
/*++

Routine Description:

    Refresh internal data

Arguments:

    None

Return Value:

    Error return code.

--*/
{
    CString strParent;
    BuildParentPath(strParent, FALSE);

    return FetchMetaInformation(strParent);
}



/* virtual */
HRESULT
CIISFileNode::ConfigureMMC(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LPARAM param,
    IN LONG_PTR handle
    )
/*++

Routine Description:

    Configure using MMC property sheet provider

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider      : Property sheet provider
    LPARAM param                            : Parameter
    LONG_PTR handle                          : Handle

Return Value:

    Error return code

--*/
{
    ASSERT(m_pOwner != NULL);

    CString strParent;
    BuildParentPath(strParent, FALSE);

    return GetServerInfo()->MMCConfigureChild(
        lpProvider, 
        param,
        handle,
        m_dwAttributes,
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        );
}



/* virtual */ 
HRESULT 
CIISFileNode::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK pContextMenuCallback
    )
/*++

Routine Description:

    Add context menu items relevant to this node

Arguments:

    LPCONTEXTMENUCALLBACK pContextMenuCallback

Return Value:

    HRESULT

--*/
{
    CIISObject::AddMenuItems(pContextMenuCallback);

    if (IsDir())
    {
        AddMenuItemByCommand(pContextMenuCallback, IDM_NEW_VROOT);
    }

    if (SupportsSecurityWizard())
    {
        AddMenuItemByCommand(pContextMenuCallback, IDM_TASK_SECURITY_WIZARD);
    }

    return S_OK;
}



/* virtual */
HRESULT
CIISFileNode::AddNextTaskpadItem(
    OUT MMC_TASK * pTask
    )
/*++

Routine Description:

    Add next taskpad item

Arguments:

    MMC_TASK * pTask    : Task structure to fill in

Return Value:

    HRESULT

--*/
{
    //
    // CODEWORK:  Ideally I would call be the base class here, but that's
    //            a pain with enumeration
    //
    static int iIndex = 0;

    //
    // Fall through on the switch until an applicable command is found
    //
    UINT nID;

    switch(iIndex)
    {
    case 0:
        if (IsDir())
        {
            nID = IDM_NEW_VROOT;
            break;
        }
                
    default:
        //
        // All done
        //
        iIndex = 0;
        return S_FALSE;
    }

    HRESULT hr = AddTaskpadItemByCommand(
        nID, 
        pTask,
        GetServerInfo()->QueryInstanceHandle()
        );

    if (SUCCEEDED(hr))
    {
        ++iIndex;
    }

    return hr;
}



/* virtual */
HRESULT
CIISFileNode::AddChildNode(
    IN CIISChildNode *& pChild
    )
/*++

Routine Description:

    Add child node under current node

Arguments:

    CIISChildNode *& pChild     : Child node to be added

Return Value:

    Error return code.

--*/
{
    ASSERT(m_pOwner != NULL);
    ISMCHILDINFO ii;

    CString strPath;
    BuildFullPath(strPath, FALSE);

    pChild = NULL;
    CError err(GetServerInfo()->AddChild(
        &ii, 
        sizeof(ii), 
        m_pOwner->QueryID(), 
        strPath
        ));

    if (err.Succeeded())
    {
        pChild = new CIISChildNode(
            &ii,
            m_pOwner
            );
    }

    return err;
}



HRESULT
CIISFileNode::SecurityWizard()
/*++

Routine Description:

    Launch the security wizard on this file node

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(m_pOwner != NULL);
    ASSERT(SupportsSecurityWizard());

    CString strParent;
    BuildParentPath(strParent, FALSE);

    return GetServerInfo()->ISMSecurityWizard(
        m_pOwner->QueryID(), 
        strParent, 
        m_strNodeName
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\mycomput.h ===
// Nodetypes for the Computer Management snapin
// created by UUIDGEN 4/1/97 JonN

#ifndef _UUIDS_COMPUTER_MANAGEMENT_
#define _UUIDS_COMPUTER_MANAGEMENT_

#define struuidNodetypeComputer      "{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeDrive         "{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeSystemTools   "{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeServerApps    "{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
#define struuidNodetypeStorage       "{476e644a-aaff-11d0-b944-00c04fd8d5b0}"

#define lstruuidNodetypeComputer    L"{476e6446-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeDrive       L"{476e6447-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeSystemTools L"{476e6448-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeServerApps  L"{476e6449-aaff-11d0-b944-00c04fd8d5b0}"
#define lstruuidNodetypeStorage     L"{476e644a-aaff-11d0-b944-00c04fd8d5b0}"

#define structuuidNodetypeComputer    \
    { 0x476e6446, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeDrive       \
    { 0x476e6447, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeSystemTools \
    { 0x476e6448, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeServerApps  \
    { 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }
#define structuuidNodetypeStorage     \
    { 0x476e644a, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } }

#endif // _UUIDS_COMPUTER_MANAGEMENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\metaback.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        metaback.cpp

   Abstract:

        Metabase backup and restore dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "mddefw.h"
#include "metaback.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// CBackupsListBox : a listbox of CBackup objects
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Column width relative weights
//
#define WT_LOCATION      8
#define WT_VERSION       2
#define WT_DATE          6



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("MetaBack");



IMPLEMENT_DYNAMIC(CBackupsListBox, CHeaderListBox);



const int CBackupsListBox::nBitmaps = 1;



CBackupsListBox::CBackupsListBox()
/*++

Routine Description:

    Backups listbox constructor

Arguments:

    None

Return Value:

    N/A

--*/
     : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
}



void
CBackupsListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CBackupFile * p = (CBackupFile *)ds.m_ItemData;
    ASSERT(p != NULL);

    DrawBitmap(ds, 0, 0);

    CString strVersion;
    strVersion.Format(_T("%ld"), p->QueryVersion());

#define MAXLEN (128)

    CTime tm;
    p->GetTime(tm);

    SYSTEMTIME stm =
    {
        (WORD)tm.GetYear(),
        (WORD)tm.GetMonth(),
        (WORD)tm.GetDayOfWeek(),
        (WORD)tm.GetDay(),
        (WORD)tm.GetHour(),
        (WORD)tm.GetMinute(),
        (WORD)tm.GetSecond(),
        0   // Milliseconds
    };

    CString strDate, strTime;
    LPTSTR lp = strDate.GetBuffer(MAXLEN);
    ::GetDateFormat(
        LOCALE_USER_DEFAULT,
        DATE_SHORTDATE,
        &stm,
        NULL,
        lp,
        MAXLEN
        );
    strDate.ReleaseBuffer();

    lp = strTime.GetBuffer(MAXLEN);
    GetTimeFormat(LOCALE_USER_DEFAULT, 0L, &stm, NULL, lp, MAXLEN);
    strTime.ReleaseBuffer();

    strDate += _T(" ");
    strDate += strTime;

    ColumnText(ds, 0, TRUE, (LPCTSTR)p->QueryLocation());
    ColumnText(ds, 1, FALSE, strVersion);
    ColumnText(ds, 2, FALSE, strDate);
}



/* virtual */
BOOL
CBackupsListBox::Initialize()
/*++

Routine Description:

    initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE if initialized successfully, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    InsertColumn(0, WT_LOCATION, IDS_BACKUP_LOCATION);
    InsertColumn(1, WT_VERSION, IDS_BACKUP_VERSION);
    InsertColumn(2, WT_DATE, IDS_BACKUP_DATE);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
    if (!SetWidthsFromReg())
    {
        DistributeColumns();
    }

    return TRUE;
}



//
// Backup file object properties dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CBkupPropDlg::CBkupPropDlg(
    IN LPCTSTR lpszServer,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    LPCTSTR lpszServer  : Server name
    CWnd * pParent      : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CBkupPropDlg::IDD, pParent),
      m_strServer(lpszServer),
      m_strName(),
      m_strPassword()
{

#if 0 // Keep class-wizard happy

    //{{AFX_DATA_INIT(CBkupPropDlg)
    m_strName = _T("");
    m_strPassword = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



void 
CBkupPropDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CBkupPropDlg)
    DDX_Control(pDX, IDC_EDIT_BACKUP_NAME, m_edit_Name);
    DDX_Control(pDX, IDC_BACKUP_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_edit_PasswordConfirm);
    DDX_Control(pDX, IDC_USE_PASSWORD, m_button_Password);
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Text(pDX, IDC_EDIT_BACKUP_NAME, m_strName);
    DDV_MaxChars(pDX, m_strName, MD_BACKUP_MAX_LEN - 1);
    //}}AFX_DATA_MAP
    if (m_button_Password.GetCheck())
    {
      DDX_Text(pDX, IDC_BACKUP_PASSWORD, m_strPassword);
      DDV_MinChars(pDX, m_strPassword, MIN_PASSWORD_LENGTH);
      DDX_Text(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_strPasswordConfirm);
      DDV_MinChars(pDX, m_strPasswordConfirm, MIN_PASSWORD_LENGTH);
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CBkupPropDlg, CDialog)
    //{{AFX_MSG_MAP(CBkupPropDlg)
    ON_EN_CHANGE(IDC_EDIT_BACKUP_NAME, OnChangeEditBackupName)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD, OnChangeEditPassword)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD_CONFIRM, OnChangeEditPassword)
    ON_BN_CLICKED(IDC_USE_PASSWORD, OnUsePassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CBkupPropDlg::OnChangeEditBackupName() 
/*++

Routine Description:

    Backup name edit change notification handler.

Arguments:

    None.

Return Value:

    None.

--*/
{
   BOOL bEnableOK = m_edit_Name.GetWindowTextLength() > 0;
   m_button_OK.EnableWindow(bEnableOK);
   if (bEnableOK && m_button_Password.GetCheck())
      m_button_OK.EnableWindow(
         m_edit_Password.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
         && m_edit_PasswordConfirm.GetWindowTextLength() >= MIN_PASSWORD_LENGTH);
}


void 
CBkupPropDlg::OnChangeEditPassword() 
{
    m_button_OK.EnableWindow(
       m_edit_Password.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
       && m_edit_PasswordConfirm.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
       && m_edit_Name.GetWindowTextLength() > 0);
}


BOOL 
CBkupPropDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();
    
    m_button_OK.EnableWindow(FALSE);
    m_button_Password.SetCheck(FALSE);
    m_edit_Password.EnableWindow(FALSE);
    m_edit_PasswordConfirm.EnableWindow(FALSE);
    
    return TRUE;  
}


void
CBkupPropDlg::OnUsePassword()
{
   BOOL bUseIt = m_button_Password.GetCheck();
   m_edit_Password.EnableWindow(bUseIt);
   m_edit_PasswordConfirm.EnableWindow(bUseIt);
   if (bUseIt)
   {
       OnChangeEditPassword();
   }
}


void
CBkupPropDlg::OnOK()
/*++

Routine Description:

    'OK' button handler -- create the backup.

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        if (m_button_Password.GetCheck() && m_strPassword.Compare(m_strPasswordConfirm) != 0)
        {
           AfxMessageBox(IDS_PASSWORDS_DOESNT_MATCH);
           return;
        }
        BeginWaitCursor();

        CMetaBack mb(m_strServer);
        CError err(mb.QueryResult());

        if (err.Succeeded())
        {
           if (m_button_Password.GetCheck())
           {
              err = mb.BackupWithPassword(m_strName, m_strPassword);
           }
           else
           {
              err = mb.BackupWithPassword(m_strName, _T(""));
           }
        }

        EndWaitCursor();

        if (err.Failed())
        {
            //
            // Special error message if IISADMIN just didn't
            // like the name.
            //
            if (err.Win32Error() == ERROR_INVALID_PARAMETER)
            {
                ::AfxMessageBox(IDS_BACKUP_BAD_NAME);
                ((CEdit *)GetDlgItem(IDC_EDIT_BACKUP_NAME))->SetSel(0, -1);
            }
            else
            {
               ASSERT(FALSE);
                err.MessageBox();
            }

            //
            // Don't dismiss the dialog
            //
            return;
        }

        CDialog::OnOK();
    }
}



//
// Metabase/Restore dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CBackupDlg::CBackupDlg(
    IN LPCTSTR lpszServer,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    LPCTSTR lpszServer          : Server name
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : m_strServer(lpszServer),
      m_list_Backups(),
      m_ListBoxRes(IDB_BACKUPS, m_list_Backups.nBitmaps),
      m_oblBackups(),
      m_fChangedMetabase(FALSE),
      CDialog(CBackupDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CBackupDlg)
    //}}AFX_DATA_INIT

    m_list_Backups.AttachResources(&m_ListBoxRes);
}



void 
CBackupDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBackupDlg)
    DDX_Control(pDX, IDC_BUTTON_RESTORE, m_button_Restore);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_Delete);
    DDX_Control(pDX, IDOK, m_button_Close);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_BACKUPS, m_list_Backups);
}



void
CBackupDlg::SetControlStates()
/*++

Routine Description:

    Setting control states depending on the state of the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Restore.EnableWindow(m_list_Backups.GetSelCount() == 1);
    m_button_Delete.EnableWindow(m_list_Backups.GetSelCount() > 0);
}



HRESULT
CBackupDlg::EnumerateBackups(
    LPCTSTR lpszSelect  OPTIONAL
    )
/*++

Routine Description:

    Enumerate all existing backups, and add them to the listbox

Arguments:

    LPCTSTR lpszSelect      : Optional item to select

Return Value:

    HRESULT

Notes:

    The highest version number of the given name (if any) will
    be selected.

--*/
{
    CWaitCursor wait;

    m_list_Backups.SetRedraw(FALSE);
    m_list_Backups.ResetContent();
    m_oblBackups.RemoveAll();

    int nSel = LB_ERR;

    CMetaBack mb(m_strServer);
    CError err(mb.QueryResult());

    if (err.Succeeded())
    {
        DWORD dwVersion;
        FILETIME ft;
        TCHAR szPath[MAX_PATH + 1] = _T("");

        int nItem = 0;

        FOREVER
        {
            *szPath = _T('\0');
            err = mb.Next(&dwVersion, szPath, &ft);

            if (err.Failed())
            {
                break;
            }

            TRACEEOLID(szPath << " v" << dwVersion);

            CBackupFile * pItem = new CBackupFile(szPath, dwVersion, &ft);
            m_oblBackups.AddTail(pItem);
            m_list_Backups.AddItem(pItem);

            if (lpszSelect != NULL && lstrcmpi(lpszSelect, szPath) == 0)
            {
                //
                // Remember selection for later
                //
                nSel = nItem;
            }

            ++nItem;
        }

        if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
        {
            //
            // Finished enumeration successfully
            //
            err.Reset();
        }
    }

    //
    // Select item requested if any
    //
    m_list_Backups.SetCurSel(nSel);
    m_list_Backups.SetRedraw(TRUE);
    SetControlStates();

    return err;
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CBackupDlg, CDialog)
    //{{AFX_MSG_MAP(CBackupDlg)
    ON_BN_CLICKED(IDC_BUTTON_CREATE, OnButtonCreate)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_RESTORE, OnButtonRestore)
    ON_LBN_DBLCLK(IDC_LIST_BACKUPS, OnDblclkListBackups)
    ON_LBN_SELCHANGE(IDC_LIST_BACKUPS, OnSelchangeListBackups)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CBackupDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler

Arguments:

    None

Return Value:

    TRUE if successfully initialized, FALSE otherwise.

--*/
{
    CDialog::OnInitDialog();

    TEMP_ERROR_OVERRIDE(REGDB_E_CLASSNOTREG, IDS_NO_BACKUP_RESTORE);

    m_list_Backups.Initialize();

    CError err(EnumerateBackups());

    if (err.Failed())
    {
        err.MessageBox();
        EndDialog(IDCANCEL);
    }

    return TRUE;
}



void
CBackupDlg::OnButtonCreate()
/*++

Routine Description:

    "Create" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBkupPropDlg dlg(m_strServer, this);

    if (dlg.DoModal() == IDOK)
    {
        //
        // We can only return OK if the creation worked
        // which is done in the properties dialog.
        //
        EnumerateBackups(dlg.QueryName());
    }
}



void
CBackupDlg::OnButtonDelete()
/*++

Routine Description:

    "Delete" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (!NoYesMessageBox(IDS_CONFIRM_DELETE_ITEMS))
    {
        //
        // Changed his mind
        //
        return;
    }

    m_list_Backups.SetRedraw(FALSE);
    CWaitCursor wait;

    CMetaBack mb(m_strServer);
    CError err(mb.QueryResult());

    if (err.MessageBoxOnFailure())
    {
        return;
    }

    int nSel = 0;
    CBackupFile * pItem;

    while ((pItem = m_list_Backups.GetNextSelectedItem(&nSel)) != NULL)
    {
        TRACEEOLID("Deleting backup " 
            << pItem->QueryLocation() 
            << " v" 
            << pItem->QueryVersion()
            );

        err = mb.Delete(
            pItem->QueryLocation(),
            pItem->QueryVersion()
            );

        if (err.MessageBoxOnFailure())
        {
            break;
        }

        m_list_Backups.DeleteString(nSel);

        //
        // Don't advance counter to account for shift
        //
    }

    m_list_Backups.SetRedraw(TRUE);
    SetControlStates();

    //
    // Ensure focus is not on a disabled button.
    //
    m_button_Close.SetFocus();
}



void 
CBackupDlg::OnButtonRestore() 
/*++

Routine Description:

    'Restore' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBackupFile * pItem = GetSelectedListItem();
    ASSERT(pItem != NULL);

    if (pItem != NULL)
    {
        if (NoYesMessageBox(IDS_RESTORE_CONFIRM))
        {
            CMetaBack mb(m_strServer);
            CError err(mb.QueryResult());

            if (err.Succeeded())
            {
                //
                // the WAM stuff takes a while
                //
                CWaitCursor wait;

                //
                // Restore method will take care of WAM save/recover
                //
                err = mb.RestoreWithPassword(pItem->QueryLocation(), pItem->QueryVersion(), _T(""));
            }

            if (err.Win32Error() == ERROR_WRONG_PASSWORD)
            {
                CBackupPassword dlg(this);
                if (dlg.DoModal() == IDOK)
                {
                   CWaitCursor wait;
                   err = mb.RestoreWithPassword(pItem->QueryLocation(), pItem->QueryVersion(), dlg.m_password);
                   if (err.Win32Error() == ERROR_WRONG_PASSWORD)
                   {
                      ::AfxMessageBox(
                          IDS_WRONG_PASSWORD, 
                          MB_OK | MB_ICONEXCLAMATION
                          );
                      return;
                   }
                   else if (err.Failed())
                   {
                      ::AfxMessageBox(
                          IDS_ERR_CANNOT_RESTORE, 
                          MB_OK | MB_ICONEXCLAMATION
                          );
                      return;
                   }
                   else
                   {
                      ::AfxMessageBox(IDS_SUCCESS, MB_OK | MB_ICONINFORMATION);
                      m_button_Close.SetFocus();
                      m_fChangedMetabase = TRUE;
                   }
                }
                else
                {
                   return;
                }
            }
            else
               err.MessageBox();
        }
    }
}



void
CBackupDlg::OnDblclkListBackups()
/*++

Routine Description:

    Backup list "double click" notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Nothing presents itself as an obvious action here
    //
}



void
CBackupDlg::OnSelchangeListBackups()
/*++

Routine Description:

    Backup list "selection change" notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}


/*
void
CBackupDlg::OnHelp()
/*++

Routine Description:

    "Help" button handler

Arguments:

    None

Return Value:

    None

--/
{
    DWORD dwHelpID = (DWORD)m_nIDHelp + HID_BASE_RESOURCE;
    
    //
    // Make sure the help id matched what we told the 
    // doc writers
    //
    ASSERT(dwHelpID == 0x207D1);

    ::WinHelp(
        m_hWnd,
        theApp.QueryInetMgrHelpPath(),
        HELP_CONTEXT,
        dwHelpID
        );
}

*/

CBackupPassword::CBackupPassword(CWnd * pParent) :
   CDialog(CBackupPassword::IDD, pParent)
{
}


BEGIN_MESSAGE_MAP(CBackupPassword, CDialog)
    //{{AFX_MSG_MAP(CBackupPassword)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD, OnChangedPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void 
CBackupPassword::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CBackupPassword)
    DDX_Control(pDX, IDC_BACKUP_PASSWORD, m_edit);
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Text(pDX, IDC_BACKUP_PASSWORD, m_password);
    //}}AFX_DATA_MAP
}

BOOL 
CBackupPassword::OnInitDialog() 
{
    CDialog::OnInitDialog();
   
    m_button_OK.EnableWindow(FALSE);
//    ::SetFocus(GetDlgItem(IDC_BACKUP_PASSWORD)->m_hWnd);
    
    return FALSE;  
}

void 
CBackupPassword::OnChangedPassword() 
{
    m_button_OK.EnableWindow(
       m_edit.GetWindowTextLength() > 0);
}

////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\menuex.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        menuex.h

   Abstract:

        Menu helper classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MENUEX_H
#define _MENUEX_H

//
// Forward Definitions
//
class CIISObject;
class CIISItemInfo;



class CISMShellExecutable : public CObjectPlus
/*++

Class Description:

    Executable object.  This may be a shell document, or an executable

Public Interface:

    CShellExecutable  : Constructor for executable object
    
    Execute           : Execute the add-on-tool
    QueryToolTipsText : Get the tooltips text
    HasIcon           : Icon was loaded
    GetIcon           : Get icon handle
    ShowInToolBar     : Whether or not the item is to be shown in the toolbar
    InitializedOK     : TRUE if the object initialized ok

--*/
{
public:
    //
    // Constructor
    //
    CISMShellExecutable(
        IN LPCTSTR lpszRegistryValue,
        IN int nBitmapID,
        IN int nCmd
        );

    ~CISMShellExecutable();

public:
    //
    // Execute with current selection or
    // no parameters
    //
    DWORD Execute(
        IN LPCTSTR lpszServer = NULL, 
        IN LPCTSTR lpszService = NULL
        );

    LPCTSTR GetToolTipsText(
        CString & str,
        IN LPCTSTR lpstrServer = NULL,
        IN LPCTSTR lpstrService = NULL
        );

    BOOL HasIcon() const { return m_hIcon != NULL; }
    HICON GetIcon() const { return m_hIcon; }
    BOOL HasBitmap() const { return m_pBitmap != NULL; }
    BOOL InitializedOK() const { return !m_strCommand.IsEmpty(); }
    BOOL ShowInToolBar() const { return m_fShowInToolbar; }
    MMCBUTTON * GetButton() { return m_pmmcButton; }
    HBITMAP GetBitmap() { ASSERT(m_pBitmap); return (HBITMAP)*m_pBitmap; }
    int GetBitmapIndex() const { return m_nBitmapID; }

protected:
    static void ExtractBitmapFromIcon(
        IN  HICON hIcon,
        OUT CBitmap *& pBitmap
        );

    static HICON GetShellIcon(
        IN LPCTSTR lpszShellExecutable
        );

    static HICON ExtractIcon(
        IN LPCTSTR lpszIconSource,
        IN UINT nIconOffset = 0
        );

    static LPTSTR GetField(
        IN LPTSTR pchLine = NULL
        );

    static DWORD ExpandEscapeCodes(
        OUT CString & strDest,
        IN  LPCTSTR lpSrc,
        IN  LPCTSTR lpszComputer = NULL,
        IN  LPCTSTR lpszService = NULL
        );

protected:
    static const TCHAR s_chField;
    static const TCHAR s_chEscape;
    static const TCHAR s_chService;
    static const TCHAR s_chComputer;
    
private:
    int     m_nBitmapID;
    int     m_nCmd;
    HICON   m_hIcon;
    BOOL    m_fShowInToolbar;
    CString m_strCommand;
    CString m_strDefaultDirectory;
    CString m_strParms;
    CString m_strNoSelectionParms;
    CString m_strToolTipsText;
    CBitmap * m_pBitmap;
    MMCBUTTON * m_pmmcButton;
};


#endif // _MENUEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by minetmgr.rc
//
#define IDS_RECONNECT_WARNING           90
#define IDS_ERR_INVALID_CHAR            91
#define IDS_ERR_EMPTY_FILENAME          92
#define IDB_TOOLBAR1                    207
#define IDB_TOOLBAR                     207
#define IDB_TOOLBAR2                    208
#define IDB_BACKUPS                     209
#define IDD_PROPERTIES                  2000
#define IDD_METABACKREST                2001
#define IDD_BACKUP                      2002
#define IDD_SHUTDOWN                    2003
#define IDI_SHUTDOWN                    2004
#define IDD_SD_PROGRESS                 2005
#define IDD_PASSWORD                    2008
#define IDS_SNAPIN_DESC                 3001
#define IDS_NAME                        3002
#define IDS_SIZE                        3003
#define IDS_MENU_HELPER                 3003
#define IDS_TYPE                        3004
#define IDS_COMPANY                     3004
#define IDS_NODENAME                    3005
#define IDS_STRING6                     3006
#define IDS_TREEROOT                    3006
#define IDS_DEFAULT_SHORTNAME           3007
#define IDS_DEFAULT_LONGNAME            3008
#define IDS_VERSION                     3009
#define IDS_STOPPED                     3010
#define IDS_PAUSED                      3011
#define IDS_RUNNING                     3012
#define IDS_UNKNOWN                     3013
#define IDS_MACHINE_PROPERTIES          3014
#define IDS_EXT_NODENAME                3015
#define IDS_SNAPIN_TYPE                 3016
#define IDS_LOCAL_COMPUTER              3018
#define IDS_ERR_NO_LOAD                 3019
#define IDS_VERSION_INCOMPATIBLE        3020
#define IDS_ERROR_CONNECTING            3021
#define IDS_YES                         3022
#define IDS_NO                          3023
#define IDS_TCPIP                       3024
#define IDS_NETBIOS                     3025
#define IDS_ACCESS_DENIED               3026
#define IDS_REDIRECTED                  3027
#define IDS_ERROR_CONNECTING_CACHE      3028
#define IDS_RESULT_COMPUTER_NAME        3030
#define IDS_RESULT_COMPUTER_LOCAL       3031
#define IDS_RESULT_COMPUTER_CONNECTION_TYPE 3032
#define IDS_DEFAULT_IP                  3033
#define IDS_NO_SERVICES_INSTALLED       3034
#define IDS_RESULT_SERVICE_DESCRIPTION  3036
#define IDS_RESULT_SERVICE_DOMAIN_NAME  3037
#define IDS_RESULT_SERVICE_IP_ADDRESS   3038
#define IDS_RESULT_SERVICE_TCP_PORT     3039
#define IDS_RESULT_SERVICE_STATE        3040
#define IDS_RESULT_VDIR_ALIAS           3041
#define IDS_RESULT_PATH                 3042
#define IDS_NO_SERVICE                  3043
#define IDS_RESULT_ATTRIBUTES           3044
#define IDS_NON_FATAL_ERROR_INSTANCES   3045
#define IDS_CONFIRM_DELETE              3046
#define IDS_CONFIRM_DISCONNECT          3047
#define IDS_RESULT_STATUS               3048
#define IDS_CONFIRM_DELETE_ITEMS        3049
#define IDS_MENU_CONNECT                3100
#define IDS_MENU_DISCOVER               3101
#define IDS_MENU_PROPERTIES             3102
#define IDS_MENU_START                  3103
#define IDS_MENU_STOP                   3104
#define IDS_MENU_PAUSE                  3105
#define IDS_MENU_DELETE                 3106
#define IDD_GENERAL                     3107
#define IDS_MENU_EXPLORE                3107
#define IDS_MENU_OPEN                   3108
#define IDS_MENU_BROWSE                 3109
#define IDS_MENU_NEWINSTANCE            3110
#define IDS_MENU_NEWVROOT               3111
#define IDS_MENU_EX_NEWINSTANCE         3112
#define IDS_ERR_SERVICE_NOT_INSTALLED   3113
#define IDS_ERR_WIZARD                  3114
#define IDS_MENU_TASKPAD                3114
#define IDS_MENU_DISCONNECT             3115
#define IDS_MENU_SECURITY_WIZARD        3116
#define IDI_IISPRODUCT                  3117
#define IDI_ICON                        3128
#define IDB_DISCOVERY                   3135
#define IDB_C1                          3136
#define IDD_DISCOVERY                   3137
#define IDD_CONNECT_SERVER              3153
#define IDD_NODE_PROPERTIES             3154
#define IDB_START                       3157
#define IDB_STOP                        3158
#define IDB_PAUSE                       3159
#define IDB_PROPERTIES                  3160
#define IDB_UNKNOWN                     3162
#define IDB_NOTLOADED                   3163
#define IDB_VIEWS                       3164
#define IDB_VIEWS16                     3164
#define IDB_NOTOOL                      3165
#define IDB_ADD                         3168
#define IDB_DELETE                      3169
#define IDB_TEMP                        3171
#define IDB_STATS                       3173
#define IDB_LOGO                        3175
#define IDB_VIEWS32                     3176
#define IDB_INETMGR16                   3177
#define IDB_INETMGR32                   3178
#define IDS_MENU_TT_CONNECT             3200
#define IDC_NEW_FOLDER                  3201
#define IDS_MENU_TT_DISCOVER            3201
#define IDB_16x16                       3202
#define IDS_MENU_TT_PROPERTIES          3202
#define IDB_32x32                       3203
#define IDS_MENU_TT_START               3203
#define IDS_MENU_TT_STOP                3204
#define IDI_FOLDER                      3205
#define IDS_MENU_TT_PAUSE               3205
#define IDS_MENU_TT_DELETE              3206
#define IDS_MENU_TT_EXPLORE             3207
#define IDC_CHECK2                      3207
#define IDS_MENU_TT_OPEN                3208
#define IDC_LIST_BACKUPS                3208
#define IDS_MENU_TT_BROWSE              3209
#define IDC_BUTTON_CREATE               3209
#define IDS_MENU_TT_NEWINSTANCE         3210
#define IDC_BUTTON_RESTORE              3210
#define IDS_MENU_TT_NEWVROOT            3211
#define IDC_BUTTON_DELETE               3211
#define IDS_MENU_TT_EX_NEWINSTANCE      3212
#define IDS_MENU_TT_DISCONNECT          3213
#define IDC_EDIT_BACKUP_NAME            3213
#define IDS_MENU_BACKUP                 3214
#define IDS_MENU_TT_BACKUP              3215
#define IDS_BACKUP_LOCATION             3216
#define IDS_BACKUP_VERSION              3217
#define IDS_BACKUP_DATE                 3218
#define IDS_BACKUP_CONFIRM_DELETE       3219
#define IDS_MENU_SHUTDOWN_IIS           3219
#define IDS_RESTORE_CONFIRM             3220
#define IDS_NO_MACHINE_PROPS            3221
#define IDS_PROP_OPEN                   3222
#define IDS_PROP_OPEN_SAVE              3223
#define IDS_PROP_OPEN_CONTINUE          3224
#define IDS_ERR_CANNOT_RESTORE          3225
#define IDS_SUCCESS                     3226
#define IDS_ERR_ENUMERATE_INST          3227
#define IDS_ERR_ENUMERATE_CHILD         3228
#define IDS_DOWNLEVEL                   3229
#define IDS_NO_BACKUP_RESTORE           3230
#define IDS_CLUSTER_ENABLED             3231
#define IDS_PROP_OPEN_REFRESH           3232
#define IDS_MENU_TT_TASKPAD             3233
#define IDS_ERR_ENUMERATE_FILES         3234
#define IDS_ERR_ENUMERATE_SVC           3235
#define IDS_BACKUP_BAD_NAME             3236
#define IDS_MENU_DS_NEWINSTANCE         3237
#define IDC_COMBO_RESTART               3237
#define IDS_MENU_DS_NEWVROOT            3238
#define IDC_STATIC_DETAILS              3238
#define IDS_MENU_TT_SECURITY_WIZARD     3239
#define IDC_PROGRESS_SHUTDOWN           3239
#define IDS_MENU_TT_SHUTDOWN_IIS        3240
#define IDC_STATIC_PROGRESS             3240
#define IDS_IIS_START                   3241
#define IDS_IIS_STOP                    3242
#define IDS_IIS_SHUTDOWN                3243
#define IDS_IIS_RESTART                 3244
#define IDS_IIS_START_DETAILS           3245
#define IDS_IIS_STOP_DETAILS            3246
#define IDS_IIS_SHUTDOWN_DETAILS        3247
#define IDS_IIS_RESTART_DETAILS         3248
#define IDS_ERR_DUP_METABASE            3249
#define IDS_ERR_NO_SHUTDOWN             3250
#define IDS_SHUTDOWN_PROGRESS           3251
#define IDS_PROP_OPEN_SHUTDOWN          3252
#define IDS_ERR_SHUTDOWN_ACCESS_DENIED  3253
#define IDS_HELPFILE                    3254
#define IDC_USE_PASSWORD                3255
#define IDS_CLUSTER_ENABLED_2           3255
#define IDC_BACKUP_PASSWORD             3256
#define IDC_BACKUP_PASSWORD_CONFIRM     3257
#define IDC_SERVERNAME                  3301
#define IDC_ANIMATE_PROGRESS            3302
#define IDS_PASSWORDS_DOESNT_MATCH      57345
#define IDS_WRONG_PASSWORD              57346

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2009
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         3259
#define _APS_NEXT_SYMED_VALUE           3108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\metaback.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        metaback.h

   Abstract:

        Metabase backup and restore dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __METABACK_H__
#define __METABACK_H__



class CBackupFile : public CObjectPlus
/*++

Class Description:

    Backup location object

Public Interface:

    CBackupFile     : Constructor

    QueryVersion    : Get the version number
    QueryLocation   : Get the location name
    GetTime         : Get the time

--*/
{
//
// Constructor
//
public:
    CBackupFile(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion,
        IN FILETIME * pft
        );

public:
    DWORD QueryVersion() const { return m_dwVersion; }
    LPCTSTR QueryLocation() const { return m_strLocation; }
    void GetTime(OUT CTime & tim);

private:
    DWORD m_dwVersion;
    CString m_strLocation;
    FILETIME m_ft;
};




class CBackupsListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of CBackupFile objects

Public Interface:

    CBackupsListBox         : Constructor

    GetItem                 : Get backup object at index
    AddItem                 : Add item to listbox
    InsertItem              : Insert item into the listbox
    Initialize              : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CBackupsListBox);

public:
    static const nBitmaps;  // Number of bitmaps

public:
    CBackupsListBox();

public:
    CBackupFile * GetItem(UINT nIndex);
    CBackupFile * GetNextSelectedItem(int * pnStartingIndex);
    int AddItem(CBackupFile * pItem);
    int InsertItem(int nPos, CBackupFile * pItem);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);
};



class CBkupPropDlg : public CDialog
/*++

Class Description:

    Backup file properties dialog

Public Interface:

    CBkupPropDlg        : Constructor

    QueryName           : Return the name of the backup file

--*/
{
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CBkupPropDlg(
        IN LPCTSTR lpszServer,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    LPCTSTR QueryName() const { return m_strName; }
    LPCTSTR QueryPassword() const { return m_strPassword; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBkupPropDlg)
    enum { IDD = IDD_BACKUP };
    CString m_strName;
    CEdit   m_edit_Name;
	 CString m_strPassword;
	 CEdit   m_edit_Password;
	 CString m_strPasswordConfirm;
	 CEdit   m_edit_PasswordConfirm;
	 CButton m_button_Password;
    CButton m_button_OK;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CBkupPropDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CBkupPropDlg)
    afx_msg void OnChangeEditBackupName();
    afx_msg void OnChangeEditPassword();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnUsePassword();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strServer;
};

#define MIN_PASSWORD_LENGTH	1

class CBackupPassword : public CDialog
{
public:
   CBackupPassword(CWnd * pParent);

    //{{AFX_DATA(CBackupPassword)
    enum { IDD = IDD_PASSWORD };
    CEdit m_edit;
    CButton m_button_OK;
	 CString m_password;
    //}}AFX_DATA

    virtual void DoDataExchange(CDataExchange * pDX);

protected:
    //{{AFX_MSG(CBackupPassword)
    afx_msg void OnChangedPassword();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CString m_confirm_password;
};

class CBackupDlg : public CDialog
/*++

Class Description:

    Metabase backup/restore dialog

Public Interface:

    CBackupDlg              : Constructor

    HasChangedMetabase      : TRUE if the metabase was changed

--*/
{
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CBackupDlg(
        IN LPCTSTR lpszServer,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    BOOL HasChangedMetabase() const { return m_fChangedMetabase; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBackupDlg)
    enum { IDD = IDD_METABACKREST };
    CButton m_button_Restore;
    CButton m_button_Delete;
    CButton m_button_Close;
    //}}AFX_DATA

    CBackupsListBox m_list_Backups;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CBackupDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CBackupDlg)
    afx_msg void OnButtonCreate();
    afx_msg void OnButtonDelete();
    afx_msg void OnButtonRestore();
    afx_msg void OnDblclkListBackups();
    afx_msg void OnSelchangeListBackups();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    HRESULT EnumerateBackups(IN LPCTSTR lpszSelect = NULL);
    CBackupFile * GetSelectedListItem(OUT int * pnSel = NULL);

private:
    BOOL                 m_fChangedMetabase;
    CString              m_strServer;
    CObListPlus          m_oblBackups;
    CRMCListBoxResources m_ListBoxRes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBackupFile::CBackupFile(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion,
    IN FILETIME * pft
    )
    : m_dwVersion(dwVersion),
      m_strLocation(lpszLocation)
{
    CopyMemory(&m_ft, pft, sizeof(m_ft));
}

inline void CBackupFile::GetTime(
    OUT CTime & tim
    )
{
    tim = m_ft;
}

inline CBackupFile * CBackupsListBox::GetItem(UINT nIndex)
{
    return (CBackupFile *)GetItemDataPtr(nIndex);
}

inline CBackupFile * CBackupsListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CBackupFile *)CHeaderListBox::GetNextSelectedItem(pnStartingIndex);
}

inline int CBackupsListBox::AddItem(CBackupFile * pItem)
{
    return AddString((LPCTSTR)pItem);
}

inline int CBackupsListBox::InsertItem(int nPos, CBackupFile * pItem)
{
    return InsertString(nPos, (LPCTSTR)pItem);
}

inline CBackupFile * CBackupDlg::GetSelectedListItem(
    OUT int * pnSel
    )
{
    return (CBackupFile *)m_list_Backups.GetSelectedListItem(pnSel);
}



#endif // __METABACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\sdprg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        sdprg.h

   Abstract:

        IIS Shutdown/restart dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "sdprg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Timer ID and values
//
#define ID_TIMER (1)
#define A_SECOND (1000L)



CShutProgressDlg::CShutProgressDlg(
    IN IISCOMMAND * pCommand
    )
/*++

Routine Description:

    Constructor for shutdown progress dialog

Arguments:

    IISCOMMAND * pCommand       : Command structure

Return Value:

    N/A

--*/
    : CDialog(CShutProgressDlg::IDD, pCommand->pParent),
      m_pCommand(pCommand),
      m_uTimeoutSec(pCommand->dwMilliseconds / A_SECOND)
{
    //{{AFX_DATA_INIT(CShutProgressDlg)
    //}}AFX_DATA_INIT
}



void
CShutProgressDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CShutProgressDlg)
    DDX_Control(pDX, IDC_STATIC_PROGRESS, m_static_ProgressMsg);
    DDX_Control(pDX, IDC_PROGRESS_SHUTDOWN, m_prgShutdown);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CShutProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CShutProgressDlg)
    ON_WM_TIMER()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CShutProgressDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    VERIFY(m_strProgress.LoadString(IDS_SHUTDOWN_PROGRESS));

    m_nProgress = 0;
#if _MFC_VER >= 0x0600
    m_prgShutdown.SetRange32(0, m_uTimeoutSec);
#else
    m_prgShutdown.SetRange(0, m_uTimeoutSec);
#endif
    m_prgShutdown.SetPos(m_nProgress);
    m_prgShutdown.SetStep(1);

    //
    // Start the progress bar ticking, once per second.
    //
    UINT_PTR nID = SetTimer(ID_TIMER, A_SECOND, NULL);

    if (nID != ID_TIMER)
    {
        //
        // Failed to create the timer.  Pop up an error, and
        // cancel the dialog.
        //
        CError err(ERROR_NO_SYSTEM_RESOURCES);
        err.MessageBox();
        EndDialog(IDCANCEL);
    }

    return TRUE;
}



void
CShutProgressDlg::OnTimer(
    IN UINT nIDEvent
    )
/*++

Routine Description:

    Timer handler.  Upgrade the progressbar with another second on the clock

Arguments:

    UINT nIDEvent       : Timer id

Return Value:

    None

--*/
{
    ASSERT(nIDEvent == ID_TIMER);

    m_prgShutdown.SetPos(++m_nProgress);

    //
    // Display progress on the tick marker
    //
    CString str;
    str.Format(m_strProgress, m_uTimeoutSec - (UINT)m_nProgress  + 1);
    m_static_ProgressMsg.SetWindowText(str);

    //
    // Check to see if the stop thread has finished its action already
    //
    BOOL fFinished;

    EnterCriticalSection(&m_pCommand->cs);
    fFinished = m_pCommand->fFinished;
    LeaveCriticalSection(&m_pCommand->cs);

    if (fFinished)
    {
        //
        // The worker thread has finished, so there's no reason to
        // keep the user in suspense -- dismiss the dialog
        //
        EndDialog(IDCANCEL);
    }

    if ((UINT)m_nProgress > m_uTimeoutSec)
    {
        //
        // We've timed out -- tell the main thread to Kill!()
        //
        OnOK();
    }

    //
    // I doubt there's any default processing here, but anyway...
    //
    CDialog::OnTimer(nIDEvent);
}



void
CShutProgressDlg::OnDestroy()
/*++

Routine Description:

    Handle dialog destruction, kill the timer.

Arguments:

    None

Return Value:

    None

--*/
{
    CDialog::OnDestroy();

    KillTimer(ID_TIMER);
}



void
CShutProgressDlg::OnOK()
/*++

Routine Description:

    OK handler -- ok button maps to "Kill Now!"

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Kill!
    //
    EndDialog(IDOK);
}



void
CShutProgressDlg::OnCancel()
/*++

Routine Description:

    Cancel button handler.  This dialog cannot be cancelled, so the cancel
    notification is eaten.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Eat cancel command (user pressed escape)
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\sdprg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        sdprg.h

   Abstract:

        IIS Shutdown/restart progress dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SDPRG_H__
#define __SDPRG_H__


//
// IIS Service Command
//
typedef struct tagIISCOMMAND
{
    TCHAR   szServer[MAX_PATH + 1];
    BOOL    fFinished;
    HRESULT hReturn;
    DWORD   dwMilliseconds;
    CWnd  * pParent;
    CRITICAL_SECTION cs;
}   
IISCOMMAND;



class CShutProgressDlg : public CDialog
/*++

Class Description:

    Shutdown progress indicator dialog.  Displays a progress bar, and gives
    the opportunity to kill immediately.

Public Interface:

    CShutProgressDlg        Constructor

Notes:

    This dialog displays a progress bar with the number of seconds for shutdown.

    The return value is IDOK if Kill() should be executed, or if no further action
    is required.

--*/
{
//
// Construction
//
public:
    CShutProgressDlg(
        IN IISCOMMAND * pCommand
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CShutProgressDlg)
    enum { IDD = IDD_SD_PROGRESS };
    CStatic       m_static_ProgressMsg;
    CProgressCtrl m_prgShutdown;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CShutProgressDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX); 
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CShutProgressDlg)
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnDestroy();
    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    int     m_nProgress;
    UINT    m_uTimeoutSec;
    IISCOMMAND * m_pCommand;
    CString m_strProgress;
};



#endif  // __SDPRG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\minetmgr.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        minetmgr.cpp

   Abstract:

        Snapin object

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "initguid.h"
#include "cinetmgr.h"
#include "constr.h"
#include "mycomput.h"

//
// Registry Definitions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR g_cszCLSID           = _T("CLSID");
const LPCTSTR g_cszLS32            = _T("LocalServer32");
const LPCTSTR g_cszIPS32           = _T("InprocServer32");
const LPCTSTR g_cszMMCBasePath     = _T("Software\\Microsoft\\MMC");
const LPCTSTR g_cszSnapins         = _T("Snapins");
const LPCTSTR g_cszNameString      = _T("NameString");
const LPCTSTR g_cszNameStringInd   = _T("NameStringIndirect");
const LPCTSTR g_cszProvider        = _T("Provider");
const LPCTSTR g_cszVersion         = _T("Version");
const LPCTSTR g_cszStandAlone      = _T("StandAlone");
const LPCTSTR g_cszNodeTypes       = _T("NodeTypes");
const LPCTSTR g_cszAbout           = _T("About");
const LPCTSTR g_cszExtensions      = _T("Extensions");
const LPCTSTR g_cszNameSpace       = _T("NameSpace");
const LPCTSTR g_cszDynamicExt      = _T("Dynamic Extensions");
const LPCTSTR g_cszValProvider     = _T("Microsoft");
const LPCTSTR g_cszValVersion      = _T("5.0");
const LPCTSTR g_cszMyCompMsc       = _T("%SystemRoot%\\system32\\compmgmt.msc");
const LPCTSTR g_cszServerAppsLoc   = _T("System\\CurrentControlSet\\Control\\Server Applications");



CFlexComModule _Module;




HRESULT WINAPI 
CFlexComModule::UpdateRegistryClass(
    IN const CLSID & clsid,
    IN LPCTSTR lpszProgID,
    IN LPCTSTR lpszVerIndProgID,
    IN UINT nDescID,
    IN DWORD dwFlags,
    IN BOOL bRegister
    )
/*++

Routine Description:

    Override of UpdateRegistry to change the path to a path that uses
    a %systemroot%\... EXPAND_SZ path

Arguments:

    const CLSID& clsid          : GUID
    LPCTSTR lpszProgID          : Program ID
    LPCTSTR lpszVerIndProgID    : Version independent program ID
    UINT nDescID                : Description resource ID
    DWORD dwFlags               : Flags
    BOOL bRegister              : TRUE for register, FALSE for unregister

Return Value:

    HRESULT

--*/
{
    //
    // Call base class as normal
    //
    CError err = CComModule::UpdateRegistryClass(
        clsid, 
        lpszProgID,
        lpszVerIndProgID, 
        nDescID, 
        dwFlags, 
        bRegister
        );

    if (bRegister && err.Succeeded())
    {
        CString str, strKey, strCLSID;
        GUIDToCString(clsid, strCLSID);

        //
        // Change the path in InProcServer32/LocalServer32 to a 
        // REG_EXPAND_SZ path
        //
        strKey.Format(_T("%s\\%s"), 
            g_cszCLSID, 
            strCLSID
            );

        CRMCRegKey rkCLSID(HKEY_CLASSES_ROOT, strKey, KEY_ENUMERATE_SUB_KEYS);
        if (!rkCLSID.Ok())
        {
            //
            // This should have been created by 
            // _Module.RegisterServer
            //
            err.GetLastWinError();
            return err;
        }

        //
        // Look for inproc32 or local32
        //
        CRMCRegKey rkInProc(rkCLSID, g_cszIPS32);
        CRMCRegKey rkLocProc(rkCLSID,  g_cszLS32);
        CRMCRegKey * prk = rkInProc.Ok()
            ? &rkInProc
            : rkLocProc.Ok()
                ? &rkLocProc
                : NULL;

        if (prk == NULL)
        {
            err.GetLastWinError();
            return err;
        }

        //
        // Rewrite entry as an REG_EXPAND_SZ
        //
        err = prk->QueryValue(NULL, str);
        if (err.Succeeded())
        {
            err = prk->SetValue(NULL, str, TRUE);        
        }
    }

    return err;
}



BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Snapin, CComponentDataImpl)
    OBJECT_ENTRY(CLSID_About,  CSnapinAboutImpl)
END_OBJECT_MAP()



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// Message Map
//
BEGIN_MESSAGE_MAP(CSnapinApp, CWinApp)
    //{{AFX_MSG_MAP(CConfigDll)
    //}}AFX_MSG_MAP
    //
    // Global help commands
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()


#ifdef _DEBUG

//
// Allocation tracker
//
BOOL 
TrackAllocHook( 
    IN size_t nSize, 
    IN BOOL bObject, 
    IN LONG lRequestNumber 
    )
{
    //
    // Track lRequestNumber here
    //
    //TRACEEOLID("allocation # " << lRequestNumber);

    return TRUE;
}

#endif // _DEBUG



CSnapinApp::CSnapinApp()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CWinApp()
{

#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

    AfxSetAllocHook(TrackAllocHook);

#endif // _DEBUG

}



void
CSnapinApp::SetHelpPath(
    IN CServerInfo * pItem OPTIONAL
    )
/*++

Routine Description:

    Change the default help path

Arguments:

    CServerInfo * pItem : New help path owner or NULL to reset the help path

Return Value:

    None

Notes:

    A call to SetHelpPath() without parameters restores the help path.

    The help handler for the snapin is used to support help for down-level
    inetmgr extensions that do not have their own help handler.  Since many
    of these extensions are MFC-based, help is expected to be provided in the
    CWinApp object.  

--*/
{
    if (pItem == NULL)
    {
        //
        // Restore help path back to the inetmgr app
        //
        ASSERT(m_lpOriginalHelpPath != NULL);
        m_pszHelpFilePath = m_strInetMgrHelpPath;
        return;
    }

    //
    // Set the current help path equal to the one expected
    // from the config dll name
    //
    LPTSTR lpPath = m_strHelpPath.GetBuffer(MAX_PATH + 1);
    ::GetModuleFileName(pItem->QueryInstanceHandle(), lpPath, MAX_PATH);
    LPTSTR lp2 = _tcsrchr(lpPath, _T('.'));
    ASSERT(lp2 != NULL);
    if (lp2 != NULL)
      *lp2 = '\0';
    m_strHelpPath.ReleaseBuffer();
    m_strHelpPath += _T(".HLP");
    m_pszHelpFilePath = m_strHelpPath;
}



BOOL 
CSnapinApp::InitInstance()
/*++

Routine Description

    Instance initiation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    _Module.Init(ObjectMap, m_hInstance);

    //
    // Save a pointer to the old help file
    //
    m_lpOriginalHelpPath = m_pszHelpFilePath;

    //
    // Build up inetmgr help path, expanding 
    // the help path if necessary.
    //
    CRMCRegKey rk(REG_KEY, SZ_PARAMETERS, KEY_READ);
    rk.QueryValue(SZ_HELPPATH, m_strInetMgrHelpPath, EXPANSION_ON);
    m_strInetMgrHelpPath += _T("\\inetmgr.hlp");
    TRACEEOLID("Initialized help file " << m_strInetMgrHelpPath);

    m_pszHelpFilePath = m_strInetMgrHelpPath;
    
    return CWinApp::InitInstance();
}



int 
CSnapinApp::ExitInstance()
/*++

Routine Description:

    Exit instance handler

Arguments:

    None

Return Value:

    0 for success

--*/
{
    _Module.Term();

    //
    // Restore original help file path so it can be deleted
    //
    ASSERT(m_lpOriginalHelpPath != NULL);
    m_pszHelpFilePath = m_lpOriginalHelpPath;

    return CWinApp::ExitInstance();
}



//
// Instantiate the app object
//
CSnapinApp theApp;



STDAPI 
DllCanUnloadNow()
/*++

Routine Description:

    Used to determine whether the DLL can be unloaded by OLE

Arguments:

    None
    
Return Value:    
    
    HRESULT    

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

#ifdef _DEBUG

    HRESULT hr = ::AfxDllCanUnloadNow();
    LONG l = _Module.GetLockCount();
    TRACEEOLID("Module lock count " << l);
    BOOL fCanUnLoad = (l == 0 && hr == S_OK);

#endif // _DEBUG

    return (::AfxDllCanUnloadNow() == S_OK 
        && _Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}



STDAPI 
DllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    IN LPVOID * ppv
    )
/*++

Routine Description:

    Returns a class factory to create an object of the requested type

Arguments:

    REFCLSID rclsid
    REFIID riid
    LPVOID * ppv
    
Return Value:    
    
    HRESULT    

--*/
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}



STDAPI 
DllRegisterServer()
/*++

Routine Description:

    DllRegisterServer - Adds entries to the system registry

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    //
    // Registers object, typelib and all interfaces in typelib
    //
    CError err(_Module.RegisterServer(FALSE));

    if (err.Failed())
    {
        return err;
    }

    CString str, strKey, strExtKey;

    try
    {
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        //
        // Create the primary snapin nodes
        //
        CString strNameString((LPCTSTR)IDS_NODENAME);
        CString strNameStringInd;
        // Fix for bug 96801: moving strings from the Registry to resources (MUI requirement)
        TCHAR path[MAX_PATH];
        GetModuleFileName(_Module.GetResourceInstance(), path, MAX_PATH - 1);
        strNameStringInd.Format(_T("@%s,-%d"), path, IDS_NODENAME);
        TRACEEOLID("MUI-lized snapin name: " << strNameStringInd);

        CString strProvider(g_cszValProvider);
        CString strVersion(g_cszValVersion);
        CString str;
    
        strKey.Format(
            _T("%s\\%s\\%s"), 
            g_cszMMCBasePath, 
            g_cszSnapins,
            GUIDToCString(CLSID_Snapin, str)
            );
        TRACEEOLID(strKey);

        CString strAbout;
        GUIDToCString(CLSID_About, strAbout);

        CRMCRegKey rkSnapins(NULL, HKEY_LOCAL_MACHINE, strKey);
        rkSnapins.SetValue(g_cszAbout,      strAbout);
        rkSnapins.SetValue(g_cszNameString, strNameString);
        rkSnapins.SetValue(g_cszNameStringInd, strNameStringInd);
        rkSnapins.SetValue(g_cszProvider,   strProvider);
        rkSnapins.SetValue(g_cszVersion,    strVersion);

        CRMCRegKey rkStandAlone(NULL, rkSnapins, g_cszStandAlone);
        CRMCRegKey rkNodeTypes (NULL, rkSnapins, g_cszNodeTypes);

        //
        // Create the nodetype GUIDS
        //
        CRMCRegKey rkN1(NULL, rkNodeTypes, GUIDToCString(cInternetRootNode, str));
        CRMCRegKey rkN2(NULL, rkNodeTypes, GUIDToCString(cMachineNode, str));
        CRMCRegKey rkN3(NULL, rkNodeTypes, GUIDToCString(cInstanceNode, str));
        CRMCRegKey rkN4(NULL, rkNodeTypes, GUIDToCString(cChildNode, str));
        CRMCRegKey rkN5(NULL, rkNodeTypes, GUIDToCString(cFileNode, str));

        {
            //
            // Register as a dynamic extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

            TRACEEOLID(strExtKey);

            CRMCRegKey rkMMCNodeTypes(NULL, HKEY_LOCAL_MACHINE, strExtKey);
            rkMMCNodeTypes.SetValue(            
                GUIDToCString(CLSID_Snapin, str),
                strNameString
                );
        }

        {
            //
            // Register as a namespace extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

            TRACEEOLID(strExtKey);

            CRMCRegKey rkMMCNodeTypes(NULL, HKEY_LOCAL_MACHINE, strExtKey);
            rkMMCNodeTypes.SetValue(            
                GUIDToCString(CLSID_Snapin, str),
                strNameString
                );
        }

        //
        // This key indicates that the service in question is available
        // on the local machine
        //
        CRMCRegKey rkCompMgmt(
            NULL, 
            HKEY_LOCAL_MACHINE, 
            g_cszServerAppsLoc
            );

        GUIDToCString(CLSID_Snapin, str);
        rkCompMgmt.SetValue(
            GUIDToCString(CLSID_Snapin, str),
            strNameString
            );
    }
    catch(CMemoryException * e)
    {
        e->Delete();
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    catch(COleException * e)
    {
        e->Delete();
        err = SELFREG_E_CLASS;
    }

    return err;
}



STDAPI 
DllUnregisterServer()
/*++

Routine Description:

    DllUnregisterServer - Removes entries from the system registry

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    CError err;

    try
    {
        CString strKey(g_cszMMCBasePath);
        strKey += _T("\\");
        strKey += g_cszSnapins;

        TRACEEOLID(strKey);

        CRMCRegKey rkBase(HKEY_LOCAL_MACHINE, strKey);
        CString str, strExtKey;
        {
            CRMCRegKey rkCLSID(rkBase, GUIDToCString(CLSID_Snapin, str));
            ::RegDeleteKey(rkCLSID, g_cszStandAlone);
            {
                CRMCRegKey rkNodeTypes(rkCLSID, g_cszNodeTypes);
                ::RegDeleteKey(rkNodeTypes, GUIDToCString(cInternetRootNode, str));
                ::RegDeleteKey(rkNodeTypes, GUIDToCString(cMachineNode, str));
                ::RegDeleteKey(rkNodeTypes, GUIDToCString(cInstanceNode, str));
                ::RegDeleteKey(rkNodeTypes, GUIDToCString(cChildNode, str));
                ::RegDeleteKey(rkNodeTypes, GUIDToCString(cFileNode, str));
            }

            ::RegDeleteKey(rkCLSID, g_cszNodeTypes);
        }

        ::RegDeleteKey(rkBase, GUIDToCString(CLSID_Snapin, str));

        {
            //
            // Delete a dynamic extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

            CRMCRegKey rkMMCNodeTypes(HKEY_LOCAL_MACHINE, strExtKey);
            ::RegDeleteValue(rkMMCNodeTypes, GUIDToCString(CLSID_Snapin, str));
        }

        {
            //
            // Delete the namespace extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

            CRMCRegKey rkMMCNodeTypes(HKEY_LOCAL_MACHINE, strExtKey);
            ::RegDeleteValue(rkMMCNodeTypes, GUIDToCString(CLSID_Snapin, str));
        }

        //
        // And the service itself no longer available on the local 
        // computer
        //
        CRMCRegKey rkCompMgmt(
            HKEY_LOCAL_MACHINE, 
            g_cszServerAppsLoc
            );
        ::RegDeleteValue(rkCompMgmt, GUIDToCString(CLSID_Snapin, str));
    }
    catch(CException * e)
    {
        err.GetLastWinError();
        e->Delete();
    }

    if (err.Failed())
    {
        return err.Failed();
    }

    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\ndmgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0158 */
/* at Tue Apr 21 11:41:41 1998
 */
/* Compiler settings for ndmgr.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ndmgr_h__
#define __ndmgr_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPropertySheetNotify_FWD_DEFINED__
#define __IPropertySheetNotify_FWD_DEFINED__
typedef interface IPropertySheetNotify IPropertySheetNotify;
#endif  /* __IPropertySheetNotify_FWD_DEFINED__ */


#ifndef __IFramePrivate_FWD_DEFINED__
#define __IFramePrivate_FWD_DEFINED__
typedef interface IFramePrivate IFramePrivate;
#endif  /* __IFramePrivate_FWD_DEFINED__ */


#ifndef __IScopeDataPrivate_FWD_DEFINED__
#define __IScopeDataPrivate_FWD_DEFINED__
typedef interface IScopeDataPrivate IScopeDataPrivate;
#endif  /* __IScopeDataPrivate_FWD_DEFINED__ */


#ifndef __IImageListPrivate_FWD_DEFINED__
#define __IImageListPrivate_FWD_DEFINED__
typedef interface IImageListPrivate IImageListPrivate;
#endif  /* __IImageListPrivate_FWD_DEFINED__ */


#ifndef __IResultDataPrivate_FWD_DEFINED__
#define __IResultDataPrivate_FWD_DEFINED__
typedef interface IResultDataPrivate IResultDataPrivate;
#endif  /* __IResultDataPrivate_FWD_DEFINED__ */


#ifndef __IScopeTree_FWD_DEFINED__
#define __IScopeTree_FWD_DEFINED__
typedef interface IScopeTree IScopeTree;
#endif  /* __IScopeTree_FWD_DEFINED__ */


#ifndef __IScopeTreeIter_FWD_DEFINED__
#define __IScopeTreeIter_FWD_DEFINED__
typedef interface IScopeTreeIter IScopeTreeIter;
#endif  /* __IScopeTreeIter_FWD_DEFINED__ */


#ifndef __INodeCallback_FWD_DEFINED__
#define __INodeCallback_FWD_DEFINED__
typedef interface INodeCallback INodeCallback;
#endif  /* __INodeCallback_FWD_DEFINED__ */


#ifndef __IControlbarsCache_FWD_DEFINED__
#define __IControlbarsCache_FWD_DEFINED__
typedef interface IControlbarsCache IControlbarsCache;
#endif  /* __IControlbarsCache_FWD_DEFINED__ */


#ifndef __IContextMenuProviderPrivate_FWD_DEFINED__
#define __IContextMenuProviderPrivate_FWD_DEFINED__
typedef interface IContextMenuProviderPrivate IContextMenuProviderPrivate;
#endif  /* __IContextMenuProviderPrivate_FWD_DEFINED__ */


#ifndef __INodeType_FWD_DEFINED__
#define __INodeType_FWD_DEFINED__
typedef interface INodeType INodeType;
#endif  /* __INodeType_FWD_DEFINED__ */


#ifndef __INodeTypesCache_FWD_DEFINED__
#define __INodeTypesCache_FWD_DEFINED__
typedef interface INodeTypesCache INodeTypesCache;
#endif  /* __INodeTypesCache_FWD_DEFINED__ */


#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif  /* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumNodeTypes_FWD_DEFINED__
#define __IEnumNodeTypes_FWD_DEFINED__
typedef interface IEnumNodeTypes IEnumNodeTypes;
#endif  /* __IEnumNodeTypes_FWD_DEFINED__ */


#ifndef __IDocConfig_FWD_DEFINED__
#define __IDocConfig_FWD_DEFINED__
typedef interface IDocConfig IDocConfig;
#endif  /* __IDocConfig_FWD_DEFINED__ */


#ifndef __NodeInit_FWD_DEFINED__
#define __NodeInit_FWD_DEFINED__

#ifdef __cplusplus
typedef class NodeInit NodeInit;
#else
typedef struct NodeInit NodeInit;
#endif /* __cplusplus */

#endif  /* __NodeInit_FWD_DEFINED__ */


#ifndef __ScopeTree_FWD_DEFINED__
#define __ScopeTree_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScopeTree ScopeTree;
#else
typedef struct ScopeTree ScopeTree;
#endif /* __cplusplus */

#endif  /* __ScopeTree_FWD_DEFINED__ */


#ifndef __MMCDocConfig_FWD_DEFINED__
#define __MMCDocConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class MMCDocConfig MMCDocConfig;
#else
typedef struct MMCDocConfig MMCDocConfig;
#endif /* __cplusplus */

#endif  /* __MMCDocConfig_FWD_DEFINED__ */


#ifndef __IPropertySheetProviderPrivate_FWD_DEFINED__
#define __IPropertySheetProviderPrivate_FWD_DEFINED__
typedef interface IPropertySheetProviderPrivate IPropertySheetProviderPrivate;
#endif  /* __IPropertySheetProviderPrivate_FWD_DEFINED__ */


#ifndef __IMMCListView_FWD_DEFINED__
#define __IMMCListView_FWD_DEFINED__
typedef interface IMMCListView IMMCListView;
#endif  /* __IMMCListView_FWD_DEFINED__ */


#ifndef __ITaskPadHost_FWD_DEFINED__
#define __ITaskPadHost_FWD_DEFINED__
typedef interface ITaskPadHost ITaskPadHost;
#endif  /* __ITaskPadHost_FWD_DEFINED__ */


/* header files for imported files */
#include "mmc.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_ndmgr_0000 */
/* [local] */ 

















typedef IFramePrivate __RPC_FAR *LPFRAMEPRIVATE;

typedef IScopeDataPrivate __RPC_FAR *LPSCOPEDATAPRIVATE;

typedef IResultDataPrivate __RPC_FAR *LPRESULTDATAPRIVATE;

typedef IImageListPrivate __RPC_FAR *LPIMAGELISTPRIVATE;

typedef IPropertySheetNotify __RPC_FAR *LPPROPERTYSHEETNOTIFY;

typedef INodeCallback __RPC_FAR *LPNODECALLBACK;

typedef IScopeTreeIter __RPC_FAR *LPSCOPETREEITER;

typedef IScopeTree __RPC_FAR *LPSCOPETREE;

typedef INodeType __RPC_FAR *LPNODETYPE;

typedef INodeTypesCache __RPC_FAR *LPNODETYPESCACHE;

typedef IEnumGUID __RPC_FAR *LPENUMGUID;

typedef IEnumNodeTypes __RPC_FAR *LPENUMNODETYPES;

typedef IDocConfig __RPC_FAR *LPDOCCONFIG;

typedef IMMCListView __RPC_FAR *LPMMCLISTVIEW;

typedef IPropertySheetProviderPrivate __RPC_FAR *LPPROPERTYSHEETPROVIDERPRIVATE;

typedef struct _TREEITEM __RPC_FAR *HTREEITEM;

typedef struct  _DataWindowData
    {
    MMC_COOKIE cookie;
    LONG_PTR lpMasterNode;
    LPDATAOBJECT pDataObject;
    HWND hDlg;
    }   DataWindowData;

STDAPI MMCIsMTNodeValid(void* pMTNode, BOOL bReset);
#define MAINFRAME_CLASS_NAME   L"MMCMainFrame"
#define DATAWINDOW_CLASS_NAME  L"MMCDataWindow"
#define WINDOW_DATA_SIZE       (sizeof (DataWindowData *))
#define WINDOW_DATA_PTR_SLOT   0
#define MAX_ITEM_TEXT_LEN      1024
typedef 
enum _MID_LIST
    {   MID_VIEW    = 1,
    MID_VIEW_LARGE  = MID_VIEW + 1,
    MID_VIEW_SMALL  = MID_VIEW_LARGE + 1,
    MID_VIEW_LIST   = MID_VIEW_SMALL + 1,
    MID_VIEW_DETAIL = MID_VIEW_LIST + 1,
    MID_VIEW_FILTERED   = MID_VIEW_DETAIL + 1,
    MID_VIEW_HTML   = MID_VIEW_FILTERED + 1,
    MID_ARRANGE_ICONS   = MID_VIEW_HTML + 1,
    MID_LINE_UP_ICONS   = MID_ARRANGE_ICONS + 1,
    MID_PROPERTIES  = MID_LINE_UP_ICONS + 1,
    MID_CREATE_NEW  = MID_PROPERTIES + 1,
    MID_CREATE_NEW_FOLDER   = MID_CREATE_NEW + 1,
    MID_CREATE_NEW_SHORTCUT = MID_CREATE_NEW_FOLDER + 1,
    MID_CREATE_NEW_HTML = MID_CREATE_NEW_SHORTCUT + 1,
    MID_CREATE_NEW_OCX  = MID_CREATE_NEW_HTML + 1,
    MID_CREATE_NEW_MONITOR  = MID_CREATE_NEW_OCX + 1,
    MID_CREATE_NEW_TASKPADITEM  = MID_CREATE_NEW_MONITOR + 1,
    MID_TASK    = MID_CREATE_NEW_TASKPADITEM + 1,
    MID_SCOPE_PANE  = MID_TASK + 1,
    MID_SELECT_ALL  = MID_SCOPE_PANE + 1,
    MID_EXPLORE = MID_SELECT_ALL + 1,
    MID_OPEN    = MID_EXPLORE + 1,
    MID_CUT = MID_OPEN + 1,
    MID_COPY    = MID_CUT + 1,
    MID_PASTE   = MID_COPY + 1,
    MID_DELETE  = MID_PASTE + 1,
    MID_PRINT   = MID_DELETE + 1,
    MID_REFRESH = MID_PRINT + 1,
    MID_RENAME  = MID_REFRESH + 1,
    MID_DOCKING = MID_RENAME + 1,
    MID_ARRANGE_NAME    = MID_DOCKING + 1,
    MID_ARRANGE_TYPE    = MID_ARRANGE_NAME + 1,
    MID_ARRANGE_SIZE    = MID_ARRANGE_TYPE + 1,
    MID_ARRANGE_DATE    = MID_ARRANGE_SIZE + 1,
    MID_ARRANGE_AUTO    = MID_ARRANGE_DATE + 1,
    MID_SNAPINMANAGER   = MID_ARRANGE_AUTO + 1,
    MID_DESC_BAR    = MID_SNAPINMANAGER + 1,
    MID_TOOLBARS    = MID_DESC_BAR + 1,
    MID_STD_MENUS   = MID_TOOLBARS + 1,
    MID_STD_BUTTONS = MID_STD_MENUS + 1,
    MID_SNAPIN_MENUS    = MID_STD_BUTTONS + 1,
    MID_SNAPIN_BUTTONS  = MID_SNAPIN_MENUS + 1,
    MID_STATUS_BAR  = MID_SNAPIN_BUTTONS + 1,
    MID_LAST    = MID_STATUS_BAR + 1
    }   MID_LIST;

typedef struct  _CCLVLParam_tag
    {
    DWORD flags;
    LPARAM lParam;
    COMPONENTID ID;
    int nIndex;
    }   CCLVLParam_tag;

typedef struct  _CCLVSortParams
    {
    BOOL bAscending;
    int nCol;
    HWND hListview;
    LPRESULTDATACOMPARE lpSnapinCallback;
    LPARAM lUserParam;
    }   CCLVSortParams;

#define MMC_S_INCOMPLETE    ( 0xff0001 )

#define MMC_E_INVALID_FILE  ( 0x80ff0002 )

typedef struct  _PROPERTYNOTIFYINFO
    {
    LPCOMPONENTDATA pComponentData;
    LPCOMPONENT pComponent;
    BOOL fScopePane;
    HWND hwnd;
    }   PROPERTYNOTIFYINFO;

typedef 
enum _CONTEXT_MENU_TYPES
    {   CONTEXT_MENU_DEFAULT    = 0,
    CONTEXT_MENU_VIEW   = 1
    }   CONTEXT_MENU_TYPES;

typedef LONG_PTR HMTNODE;

typedef LONG_PTR HNODE;

typedef unsigned long MTNODEID;

#define ROOTNODEID  ( 1 )

typedef struct  _CONTEXTMENUNODEINFO
    {
    POINT m_displayPoint;
    POINT m_listviewPoint;
    BOOL m_bDisplaySnapinMgr;
    BOOL m_bScopeAllowed;
    CONTEXT_MENU_TYPES m_eContextMenuType;
    DATA_OBJECT_TYPES m_eDataObjectType;
    BOOL m_bBackground;
    BOOL m_bMultiSelect;
    HWND m_hWnd;
    HWND m_hScopePane;
    long m_lSelected;
    LPMMCLISTVIEW m_pListView;
    LPARAM m_resultItemParam;
    HNODE m_hSelectedScopeNode;
    HTREEITEM m_htiRClicked;
    BOOL m_bTempSelect;
    long m_menuItem;
    long m_menuOwner;
    long m_Command;
    LPOLESTR m_lpszName;
    }   CONTEXTMENUNODEINFO;

typedef CONTEXTMENUNODEINFO __RPC_FAR *LPCONTEXTMENUNODEINFO;

typedef PROPERTYNOTIFYINFO __RPC_FAR *LPPROPERTYNOTIFYINFO;

#define LVDATA_BACKGROUND   ( -2 )

#define LVDATA_CUSTOMOCX    ( -3 )

#define LVDATA_CUSTOMWEB    ( -4 )

#define LVDATA_MULTISELECT  ( -5 )

#define LVDATA_ERROR    ( -10 )

#define SPECIAL_LVDATA_MIN  ( -10 )

#define SPECIAL_LVDATA_MAX  ( -2 )

#define IS_SPECIAL_LVDATA(d) (((d) >= SPECIAL_LVDATA_MIN) && ((d) <= SPECIAL_LVDATA_MAX))
typedef struct  _SELECTIONINFO
    {
    BOOL m_bScope;
    BOOL m_bBackground;
    IUnknown __RPC_FAR *m_pView;
    MMC_COOKIE m_lCookie;
    MMC_CONSOLE_VERB m_eCmdID;
    BOOL m_bDueToFocusChange;
    BOOL m_bResultPaneIsOCX;
    BOOL m_bResultPaneIsWeb;
    }   SELECTIONINFO;

typedef struct  _HELPDOCINFO
    {
    BOOL m_fInvalid;
    DWORD m_dwIndex;
    DWORD m_dwTime[ 2 ];
    }   HELPDOCINFO;

typedef struct  _MMC_ILISTPAD_INFO
    {
    MMC_LISTPAD_INFO info;
    LPOLESTR szClsid;
    }   MMC_ILISTPAD_INFO;

typedef 
enum _NCLBK_NOTIFY_TYPE
    {   NCLBK_NONE  = 0x9000,
    NCLBK_ACTIVATE  = 0x9001,
    NCLBK_CACHEHINT = 0x9002,
    NCLBK_CLICK = 0x9003,
    NCLBK_CONTEXTMENU   = 0x9004,
    NCLBK_COPY  = 0x9005,
    NCLBK_CUT   = 0x9006,
    NCLBK_DBLCLICK  = 0x9007,
    NCLBK_DELETE    = 0x9008,
    NCLBK_EXPAND    = 0x9009,
    NCLBK_EXPANDED  = 0x900a,
    NCLBK_FINDITEM  = 0x900b,
    NCLBK_FOLDER    = 0x900c,
    NCLBK_MINIMIZED = 0x900d,
    NCLBK_MULTI_SELECT  = 0x900e,
    NCLBK_NEW_NODE_UPDATE   = 0x900f,
    NCLBK_PASTE = 0x9010,
    NCLBK_PRINT = 0x9011,
    NCLBK_PROPERTIES    = 0x9012,
    NCLBK_PROPERTY_CHANGE   = 0x9013,
    NCLBK_QUERYPASTE    = 0x9014,
    NCLBK_REFRESH   = 0x9015,
    NCLBK_RENAME    = 0x9016,
    NCLBK_SELECT    = 0x9017,
    NCLBK_SHOW  = 0x9018,
    NCLBK_SORT  = 0x9019,
    NCLBK_ROOTITEMSEL   = 0x901a,
    NCLBK_SHOWWEBBAR    = 0x901b,
    NCLBK_SCOPEPANEVISIBLE  = 0x901c,
    NCLBK_SNAPINHELP    = 0x901d,
    NCLBK_CONTEXTHELP   = 0x901e,
    NCLBK_SNAPINNAME    = 0x901f,
    NCLBK_INITOCX   = 0x9020,
    NCLBK_FILTER_CHANGE = 0x9021,
    NCLBK_FILTERBTN_CLICK   = 0x9022,
    NCLBK_UPDATEPASTEBTN    = 0x9023,
    NCLBK_TASKNOTIFY    = 0x9024,
    NCLBK_GETPRIMARYTASK    = 0x9025,
    NCLBK_WEBBARCHANGE  = 0x9026,
    NCLBK_GETHELPDOC    = 0x9027,
    NCLBK_HASHELPDOC    = 0x9028,
    NCLBK_LISTPAD   = 0x9029,
    NCLBK_RESTORE_VIEW  = 0x902a
    }   NCLBK_NOTIFY_TYPE;

#define CCF_MULTI_SELECT_STATIC_DATA    ( L"CCF_MULTI_SELECT_STATIC_DATA" )

#define CCF_NEWNODE ( L"CCF_NEWNODE" )

extern const CLSID CLSID_NDMGR_SNAPIN;

extern const GUID GUID_MMC_NEWNODETYPE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0000_v0_0_s_ifspec;

#ifndef __IPropertySheetNotify_INTERFACE_DEFINED__
#define __IPropertySheetNotify_INTERFACE_DEFINED__

/* interface IPropertySheetNotify */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IPropertySheetNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d700dd8e-2646-11d0-a2a7-00c04fd909dd")
    IPropertySheetNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPPROPERTYNOTIFYINFO pNotify,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IPropertySheetNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IPropertySheetNotify __RPC_FAR * This,
            /* [in] */ LPPROPERTYNOTIFYINFO pNotify,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } IPropertySheetNotifyVtbl;

    interface IPropertySheetNotify
    {
        CONST_VTBL struct IPropertySheetNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetNotify_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetNotify_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetNotify_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IPropertySheetNotify_Notify(This,pNotify,lParam)    \
    (This)->lpVtbl -> Notify(This,pNotify,lParam)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySheetNotify_Notify_Proxy( 
    IPropertySheetNotify __RPC_FAR * This,
    /* [in] */ LPPROPERTYNOTIFYINFO pNotify,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IPropertySheetNotify_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPropertySheetNotify_INTERFACE_DEFINED__ */


#ifndef __IFramePrivate_INTERFACE_DEFINED__
#define __IFramePrivate_INTERFACE_DEFINED__

/* interface IFramePrivate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFramePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d71d1f2a-1ba2-11d0-a29b-00c04fd909dd")
    IFramePrivate : public IConsole2
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetResultView( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTaskPadList( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetComponentID( 
            /* [out] */ COMPONENTID __RPC_FAR *lpComponentID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetComponentID( 
            /* [in] */ COMPONENTID id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ LONG_PTR lMTNode,
            /* [in] */ HNODE hNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ LPCOMPONENT lpComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeTree( 
            /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetScopeTree( 
            /* [in] */ IScopeTree __RPC_FAR *pScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateScopeImageList( 
            /* [in] */ REFCLSID refClsidSnapIn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetUsedByExtension( 
            /* [in] */ BOOL bExtension) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InitViewData( 
            /* [in] */ LONG_PTR lViewData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CleanupViewData( 
            /* [in] */ LONG_PTR lViewData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DisableToolbars( 
            /* [in] */ LONG_PTR lViewData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableMenuButtons( 
            /* [in] */ LONG_PTR lViewData,
            /* [in] */ BOOL bEnableUpOneLevel) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IFramePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IFramePrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IFramePrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ BOOL bExpand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsTaskpadViewPreferred )( 
            IFramePrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusText )( 
            IFramePrivate __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszStatusText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResultView )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTaskPadList )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentID )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ COMPONENTID __RPC_FAR *lpComponentID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentID )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ COMPONENTID id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNode )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR lMTNode,
            /* [in] */ HNODE hNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LPCOMPONENT lpComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeTree )( 
            IFramePrivate __RPC_FAR * This,
            /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScopeTree )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ IScopeTree __RPC_FAR *pScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateScopeImageList )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ REFCLSID refClsidSnapIn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUsedByExtension )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ BOOL bExtension);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitViewData )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR lViewData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CleanupViewData )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR lViewData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableToolbars )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR lViewData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableMenuButtons )( 
            IFramePrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR lViewData,
            /* [in] */ BOOL bEnableUpOneLevel);
        
        END_INTERFACE
    } IFramePrivateVtbl;

    interface IFramePrivate
    {
        CONST_VTBL struct IFramePrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFramePrivate_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFramePrivate_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IFramePrivate_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IFramePrivate_SetHeader(This,pHeader)   \
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IFramePrivate_SetToolbar(This,pToolbar) \
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IFramePrivate_QueryResultView(This,pUnknown)    \
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IFramePrivate_QueryScopeImageList(This,ppImageList) \
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IFramePrivate_QueryResultImageList(This,ppImageList)    \
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IFramePrivate_UpdateAllViews(This,lpDataObject,data,hint)   \
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IFramePrivate_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)  \
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IFramePrivate_QueryConsoleVerb(This,ppConsoleVerb)  \
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IFramePrivate_SelectScopeItem(This,hScopeItem)  \
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IFramePrivate_GetMainWindow(This,phwnd) \
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IFramePrivate_NewWindow(This,hScopeItem,lOptions)   \
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)


#define IFramePrivate_Expand(This,hItem,bExpand)    \
    (This)->lpVtbl -> Expand(This,hItem,bExpand)

#define IFramePrivate_IsTaskpadViewPreferred(This)  \
    (This)->lpVtbl -> IsTaskpadViewPreferred(This)

#define IFramePrivate_SetStatusText(This,pszStatusText) \
    (This)->lpVtbl -> SetStatusText(This,pszStatusText)


#define IFramePrivate_SetResultView(This,pUnknown)  \
    (This)->lpVtbl -> SetResultView(This,pUnknown)

#define IFramePrivate_SetTaskPadList(This,pUnknown) \
    (This)->lpVtbl -> SetTaskPadList(This,pUnknown)

#define IFramePrivate_GetComponentID(This,lpComponentID)    \
    (This)->lpVtbl -> GetComponentID(This,lpComponentID)

#define IFramePrivate_SetComponentID(This,id)   \
    (This)->lpVtbl -> SetComponentID(This,id)

#define IFramePrivate_SetNode(This,lMTNode,hNode)   \
    (This)->lpVtbl -> SetNode(This,lMTNode,hNode)

#define IFramePrivate_SetComponent(This,lpComponent)    \
    (This)->lpVtbl -> SetComponent(This,lpComponent)

#define IFramePrivate_QueryScopeTree(This,ppScopeTree)  \
    (This)->lpVtbl -> QueryScopeTree(This,ppScopeTree)

#define IFramePrivate_SetScopeTree(This,pScopeTree) \
    (This)->lpVtbl -> SetScopeTree(This,pScopeTree)

#define IFramePrivate_CreateScopeImageList(This,refClsidSnapIn) \
    (This)->lpVtbl -> CreateScopeImageList(This,refClsidSnapIn)

#define IFramePrivate_SetUsedByExtension(This,bExtension)   \
    (This)->lpVtbl -> SetUsedByExtension(This,bExtension)

#define IFramePrivate_InitViewData(This,lViewData)  \
    (This)->lpVtbl -> InitViewData(This,lViewData)

#define IFramePrivate_CleanupViewData(This,lViewData)   \
    (This)->lpVtbl -> CleanupViewData(This,lViewData)

#define IFramePrivate_DisableToolbars(This,lViewData)   \
    (This)->lpVtbl -> DisableToolbars(This,lViewData)

#define IFramePrivate_EnableMenuButtons(This,lViewData,bEnableUpOneLevel)   \
    (This)->lpVtbl -> EnableMenuButtons(This,lViewData,bEnableUpOneLevel)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetResultView_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IFramePrivate_SetResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetTaskPadList_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IFramePrivate_SetTaskPadList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_GetComponentID_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [out] */ COMPONENTID __RPC_FAR *lpComponentID);


void __RPC_STUB IFramePrivate_GetComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetComponentID_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ COMPONENTID id);


void __RPC_STUB IFramePrivate_SetComponentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetNode_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LONG_PTR lMTNode,
    /* [in] */ HNODE hNode);


void __RPC_STUB IFramePrivate_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetComponent_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LPCOMPONENT lpComponent);


void __RPC_STUB IFramePrivate_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_QueryScopeTree_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [out] */ IScopeTree __RPC_FAR *__RPC_FAR *ppScopeTree);


void __RPC_STUB IFramePrivate_QueryScopeTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetScopeTree_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ IScopeTree __RPC_FAR *pScopeTree);


void __RPC_STUB IFramePrivate_SetScopeTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_CreateScopeImageList_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ REFCLSID refClsidSnapIn);


void __RPC_STUB IFramePrivate_CreateScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_SetUsedByExtension_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ BOOL bExtension);


void __RPC_STUB IFramePrivate_SetUsedByExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_InitViewData_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LONG_PTR lViewData);


void __RPC_STUB IFramePrivate_InitViewData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_CleanupViewData_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LONG_PTR lViewData);


void __RPC_STUB IFramePrivate_CleanupViewData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_DisableToolbars_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LONG_PTR lViewData);


void __RPC_STUB IFramePrivate_DisableToolbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IFramePrivate_EnableMenuButtons_Proxy( 
    IFramePrivate __RPC_FAR * This,
    /* [in] */ LONG_PTR lViewData,
    /* [in] */ BOOL bEnableUpOneLevel);


void __RPC_STUB IFramePrivate_EnableMenuButtons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IFramePrivate_INTERFACE_DEFINED__ */


#ifndef __IScopeDataPrivate_INTERFACE_DEFINED__
#define __IScopeDataPrivate_INTERFACE_DEFINED__

/* interface IScopeDataPrivate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IScopeDataPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60BD2FE0-F7C5-11cf-8AFD-00AA003CA9F6")
    IScopeDataPrivate : public IConsoleNameSpace2
    {
    public:
    };
    
#else   /* C style interface */

    typedef struct IScopeDataPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeDataPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtension )( 
            IScopeDataPrivate __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ LPCLSID lpClsid);
        
        END_INTERFACE
    } IScopeDataPrivateVtbl;

    interface IScopeDataPrivate
    {
        CONST_VTBL struct IScopeDataPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeDataPrivate_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeDataPrivate_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IScopeDataPrivate_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IScopeDataPrivate_InsertItem(This,item) \
    (This)->lpVtbl -> InsertItem(This,item)

#define IScopeDataPrivate_DeleteItem(This,hItem,fDeleteThis)    \
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IScopeDataPrivate_SetItem(This,item)    \
    (This)->lpVtbl -> SetItem(This,item)

#define IScopeDataPrivate_GetItem(This,item)    \
    (This)->lpVtbl -> GetItem(This,item)

#define IScopeDataPrivate_GetChildItem(This,item,pItemChild,pCookie)    \
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,pCookie)

#define IScopeDataPrivate_GetNextItem(This,item,pItemNext,pCookie)  \
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,pCookie)

#define IScopeDataPrivate_GetParentItem(This,item,pItemParent,pCookie)  \
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,pCookie)


#define IScopeDataPrivate_Expand(This,hItem)    \
    (This)->lpVtbl -> Expand(This,hItem)

#define IScopeDataPrivate_AddExtension(This,hItem,lpClsid)  \
    (This)->lpVtbl -> AddExtension(This,hItem,lpClsid)


#endif /* COBJMACROS */


#endif  /* C style interface */




#endif  /* __IScopeDataPrivate_INTERFACE_DEFINED__ */


#ifndef __IImageListPrivate_INTERFACE_DEFINED__
#define __IImageListPrivate_INTERFACE_DEFINED__

/* interface IImageListPrivate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IImageListPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7538C620-0083-11d0-8B00-00AA003CA9F6")
    IImageListPrivate : public IImageList
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapRsltImage( 
            COMPONENTID id,
            /* [in] */ int nIndex,
            /* [out] */ int __RPC_FAR *retVal) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IImageListPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageListPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageListPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageListPrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapRsltImage )( 
            IImageListPrivate __RPC_FAR * This,
            COMPONENTID id,
            /* [in] */ int nIndex,
            /* [out] */ int __RPC_FAR *retVal);
        
        END_INTERFACE
    } IImageListPrivateVtbl;

    interface IImageListPrivate
    {
        CONST_VTBL struct IImageListPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageListPrivate_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageListPrivate_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IImageListPrivate_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IImageListPrivate_ImageListSetIcon(This,pIcon,nLoc) \
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageListPrivate_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)   \
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)


#define IImageListPrivate_MapRsltImage(This,id,nIndex,retVal)   \
    (This)->lpVtbl -> MapRsltImage(This,id,nIndex,retVal)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageListPrivate_MapRsltImage_Proxy( 
    IImageListPrivate __RPC_FAR * This,
    COMPONENTID id,
    /* [in] */ int nIndex,
    /* [out] */ int __RPC_FAR *retVal);


void __RPC_STUB IImageListPrivate_MapRsltImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IImageListPrivate_INTERFACE_DEFINED__ */


#ifndef __IResultDataPrivate_INTERFACE_DEFINED__
#define __IResultDataPrivate_INTERFACE_DEFINED__

/* interface IResultDataPrivate */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultDataPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EBA2300-0854-11d0-8B03-00AA003CA9F6")
    IResultDataPrivate : public IResultData
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListStyle( 
            /* [out] */ long __RPC_FAR *pStyle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetListStyle( 
            /* [in] */ long Style) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Arrange( 
            long style) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InternalSort( 
            LONG_PTR lpHeaderCtl,
            LPARAM lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResetResultData( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ResultHitTest( 
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [out] */ int __RPC_FAR *piIndex,
            /* [out] */ unsigned int __RPC_FAR *pflags,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
            /* [out] */ COMPONENTID __RPC_FAR *pComponentID) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IResultDataPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pStyle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStyle )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ long Style);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Arrange )( 
            IResultDataPrivate __RPC_FAR * This,
            long style);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InternalSort )( 
            IResultDataPrivate __RPC_FAR * This,
            LONG_PTR lpHeaderCtl,
            LPARAM lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetResultData )( 
            IResultDataPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResultHitTest )( 
            IResultDataPrivate __RPC_FAR * This,
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [out] */ int __RPC_FAR *piIndex,
            /* [out] */ unsigned int __RPC_FAR *pflags,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
            /* [out] */ COMPONENTID __RPC_FAR *pComponentID);
        
        END_INTERFACE
    } IResultDataPrivateVtbl;

    interface IResultDataPrivate
    {
        CONST_VTBL struct IResultDataPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataPrivate_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataPrivate_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IResultDataPrivate_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IResultDataPrivate_InsertItem(This,item)    \
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultDataPrivate_DeleteItem(This,itemID,nCol) \
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultDataPrivate_FindItemByLParam(This,lParam,pItemID)    \
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultDataPrivate_DeleteAllRsltItems(This) \
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultDataPrivate_SetItem(This,item)   \
    (This)->lpVtbl -> SetItem(This,item)

#define IResultDataPrivate_GetItem(This,item)   \
    (This)->lpVtbl -> GetItem(This,item)

#define IResultDataPrivate_GetNextItem(This,item)   \
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultDataPrivate_ModifyItemState(This,nIndex,itemID,uAdd,uRemove) \
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultDataPrivate_ModifyViewStyle(This,add,remove) \
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultDataPrivate_SetViewMode(This,lViewMode)  \
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultDataPrivate_GetViewMode(This,lViewMode)  \
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultDataPrivate_UpdateItem(This,itemID)  \
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultDataPrivate_Sort(This,nColumn,dwSortOptions,lUserParam)  \
    (This)->lpVtbl -> Sort(This,nColumn,dwSortOptions,lUserParam)

#define IResultDataPrivate_SetDescBarText(This,DescText)    \
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultDataPrivate_SetItemCount(This,nItemCount,dwOptions)  \
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)


#define IResultDataPrivate_GetListStyle(This,pStyle)    \
    (This)->lpVtbl -> GetListStyle(This,pStyle)

#define IResultDataPrivate_SetListStyle(This,Style) \
    (This)->lpVtbl -> SetListStyle(This,Style)

#define IResultDataPrivate_Arrange(This,style)  \
    (This)->lpVtbl -> Arrange(This,style)

#define IResultDataPrivate_InternalSort(This,lpHeaderCtl,lUserParam)    \
    (This)->lpVtbl -> InternalSort(This,lpHeaderCtl,lUserParam)

#define IResultDataPrivate_ResetResultData(This)    \
    (This)->lpVtbl -> ResetResultData(This)

#define IResultDataPrivate_ResultHitTest(This,nX,nY,piIndex,pflags,pItemID,pComponentID)    \
    (This)->lpVtbl -> ResultHitTest(This,nX,nY,piIndex,pflags,pItemID,pComponentID)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_GetListStyle_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pStyle);


void __RPC_STUB IResultDataPrivate_GetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_SetListStyle_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [in] */ long Style);


void __RPC_STUB IResultDataPrivate_SetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_Arrange_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    long style);


void __RPC_STUB IResultDataPrivate_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_InternalSort_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    LONG_PTR lpHeaderCtl,
    LPARAM lUserParam);


void __RPC_STUB IResultDataPrivate_InternalSort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_ResetResultData_Proxy( 
    IResultDataPrivate __RPC_FAR * This);


void __RPC_STUB IResultDataPrivate_ResetResultData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataPrivate_ResultHitTest_Proxy( 
    IResultDataPrivate __RPC_FAR * This,
    /* [in] */ int nX,
    /* [in] */ int nY,
    /* [out] */ int __RPC_FAR *piIndex,
    /* [out] */ unsigned int __RPC_FAR *pflags,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID,
    /* [out] */ COMPONENTID __RPC_FAR *pComponentID);


void __RPC_STUB IResultDataPrivate_ResultHitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IResultDataPrivate_INTERFACE_DEFINED__ */


#ifndef __IScopeTree_INTERFACE_DEFINED__
#define __IScopeTree_INTERFACE_DEFINED__

/* interface IScopeTree */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IScopeTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8dbf067-5fb2-11d0-a986-00c04fd8d565")
    IScopeTree : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HWND hFrameWindow) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryIterator( 
            /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryNodeCallback( 
            /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ HMTNODE hMTNode,
            /* [in] */ LONG_PTR lViewData,
            /* [in] */ BOOL fRootNode,
            /* [out] */ HNODE __RPC_FAR *phNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteView( 
            /* [in] */ int nView) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CopyView( 
            /* [in] */ int nDestView,
            /* [in] */ int nSrcView) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DestroyNode( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bDestroyStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Find( 
            /* [in] */ MTNODEID mID,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImageList( 
            /* [out] */ PLONG_PTR plImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RunSnapIn( 
            /* [in] */ HWND hwndParent,
            /* [out] */ BOOL __RPC_FAR *pbSnapInCacheChange) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidDocFile( 
            /* [in] */ IStorage __RPC_FAR *pStorage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsValidDocFileName( 
            /* [in] */ LPOLESTR filename) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIDFromPath( 
            /* [in] */ MTNODEID idStatic,
            /* [in] */ const BYTE __RPC_FAR *pbPath,
            /* [in] */ UINT cbPath,
            /* [out] */ MTNODEID __RPC_FAR *pID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetIDPath( 
            /* [in] */ MTNODEID id,
            /* [out] */ MTNODEID __RPC_FAR *__RPC_FAR *ppIDs,
            /* [out] */ long __RPC_FAR *pLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [out] */ MTNODEID __RPC_FAR *pID) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IScopeTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeTree __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeTree __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HWND hFrameWindow);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIterator )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNodeCallback )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HMTNODE hMTNode,
            /* [in] */ LONG_PTR lViewData,
            /* [in] */ BOOL fRootNode,
            /* [out] */ HNODE __RPC_FAR *phNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteView )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ int nView);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyView )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ int nDestView,
            /* [in] */ int nSrcView);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyNode )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bDestroyStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Find )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ MTNODEID mID,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImageList )( 
            IScopeTree __RPC_FAR * This,
            /* [out] */ PLONG_PTR plImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RunSnapIn )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [out] */ BOOL __RPC_FAR *pbSnapInCacheChange);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidDocFile )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ IStorage __RPC_FAR *pStorage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsValidDocFileName )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ LPOLESTR filename);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDFromPath )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ MTNODEID idStatic,
            /* [in] */ const BYTE __RPC_FAR *pbPath,
            /* [in] */ UINT cbPath,
            /* [out] */ MTNODEID __RPC_FAR *pID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDPath )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ MTNODEID id,
            /* [out] */ MTNODEID __RPC_FAR *__RPC_FAR *ppIDs,
            /* [out] */ long __RPC_FAR *pLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetID )( 
            IScopeTree __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [out] */ MTNODEID __RPC_FAR *pID);
        
        END_INTERFACE
    } IScopeTreeVtbl;

    interface IScopeTree
    {
        CONST_VTBL struct IScopeTreeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeTree_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeTree_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IScopeTree_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IScopeTree_Initialize(This,hFrameWindow)    \
    (This)->lpVtbl -> Initialize(This,hFrameWindow)

#define IScopeTree_QueryIterator(This,lpIter)   \
    (This)->lpVtbl -> QueryIterator(This,lpIter)

#define IScopeTree_QueryNodeCallback(This,ppNodeCallback)   \
    (This)->lpVtbl -> QueryNodeCallback(This,ppNodeCallback)

#define IScopeTree_CreateNode(This,hMTNode,lViewData,fRootNode,phNode)  \
    (This)->lpVtbl -> CreateNode(This,hMTNode,lViewData,fRootNode,phNode)

#define IScopeTree_DeleteView(This,nView)   \
    (This)->lpVtbl -> DeleteView(This,nView)

#define IScopeTree_CopyView(This,nDestView,nSrcView)    \
    (This)->lpVtbl -> CopyView(This,nDestView,nSrcView)

#define IScopeTree_DestroyNode(This,hNode,bDestroyStorage)  \
    (This)->lpVtbl -> DestroyNode(This,hNode,bDestroyStorage)

#define IScopeTree_Find(This,mID,phMTNode)  \
    (This)->lpVtbl -> Find(This,mID,phMTNode)

#define IScopeTree_GetImageList(This,plImageList)   \
    (This)->lpVtbl -> GetImageList(This,plImageList)

#define IScopeTree_RunSnapIn(This,hwndParent,pbSnapInCacheChange)   \
    (This)->lpVtbl -> RunSnapIn(This,hwndParent,pbSnapInCacheChange)

#define IScopeTree_IsValidDocFile(This,pStorage)    \
    (This)->lpVtbl -> IsValidDocFile(This,pStorage)

#define IScopeTree_IsValidDocFileName(This,filename)    \
    (This)->lpVtbl -> IsValidDocFileName(This,filename)

#define IScopeTree_GetIDFromPath(This,idStatic,pbPath,cbPath,pID)   \
    (This)->lpVtbl -> GetIDFromPath(This,idStatic,pbPath,cbPath,pID)

#define IScopeTree_GetIDPath(This,id,ppIDs,pLength) \
    (This)->lpVtbl -> GetIDPath(This,id,ppIDs,pLength)

#define IScopeTree_GetID(This,pDataObject,pID)  \
    (This)->lpVtbl -> GetID(This,pDataObject,pID)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_Initialize_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HWND hFrameWindow);


void __RPC_STUB IScopeTree_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_QueryIterator_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ IScopeTreeIter __RPC_FAR *__RPC_FAR *lpIter);


void __RPC_STUB IScopeTree_QueryIterator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_QueryNodeCallback_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ INodeCallback __RPC_FAR *__RPC_FAR *ppNodeCallback);


void __RPC_STUB IScopeTree_QueryNodeCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_CreateNode_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HMTNODE hMTNode,
    /* [in] */ LONG_PTR lViewData,
    /* [in] */ BOOL fRootNode,
    /* [out] */ HNODE __RPC_FAR *phNode);


void __RPC_STUB IScopeTree_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_DeleteView_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ int nView);


void __RPC_STUB IScopeTree_DeleteView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_CopyView_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ int nDestView,
    /* [in] */ int nSrcView);


void __RPC_STUB IScopeTree_CopyView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_DestroyNode_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bDestroyStorage);


void __RPC_STUB IScopeTree_DestroyNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_Find_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ MTNODEID mID,
    /* [out] */ HMTNODE __RPC_FAR *phMTNode);


void __RPC_STUB IScopeTree_Find_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetImageList_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [out] */ PLONG_PTR plImageList);


void __RPC_STUB IScopeTree_GetImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_RunSnapIn_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [out] */ BOOL __RPC_FAR *pbSnapInCacheChange);


void __RPC_STUB IScopeTree_RunSnapIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_IsValidDocFile_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ IStorage __RPC_FAR *pStorage);


void __RPC_STUB IScopeTree_IsValidDocFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_IsValidDocFileName_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ LPOLESTR filename);


void __RPC_STUB IScopeTree_IsValidDocFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetIDFromPath_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ MTNODEID idStatic,
    /* [in] */ const BYTE __RPC_FAR *pbPath,
    /* [in] */ UINT cbPath,
    /* [out] */ MTNODEID __RPC_FAR *pID);


void __RPC_STUB IScopeTree_GetIDFromPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetIDPath_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ MTNODEID id,
    /* [out] */ MTNODEID __RPC_FAR *__RPC_FAR *ppIDs,
    /* [out] */ long __RPC_FAR *pLength);


void __RPC_STUB IScopeTree_GetIDPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTree_GetID_Proxy( 
    IScopeTree __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT pDataObject,
    /* [out] */ MTNODEID __RPC_FAR *pID);


void __RPC_STUB IScopeTree_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IScopeTree_INTERFACE_DEFINED__ */


#ifndef __IScopeTreeIter_INTERFACE_DEFINED__
#define __IScopeTreeIter_INTERFACE_DEFINED__

/* interface IScopeTreeIter */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IScopeTreeIter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d779f8d1-6057-11d0-a986-00c04fd8d565")
    IScopeTreeIter : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCurrent( 
            /* [in] */ HMTNODE hStartMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ UINT nRequested,
            /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
            /* [out] */ UINT __RPC_FAR *pnFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Child( 
            /* [out] */ HMTNODE __RPC_FAR *phsiChild) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Parent( 
            /* [out] */ HMTNODE __RPC_FAR *phsiParent) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IScopeTreeIterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScopeTreeIter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScopeTreeIter __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCurrent )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ HMTNODE hStartMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [in] */ UINT nRequested,
            /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
            /* [out] */ UINT __RPC_FAR *pnFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Child )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [out] */ HMTNODE __RPC_FAR *phsiChild);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Parent )( 
            IScopeTreeIter __RPC_FAR * This,
            /* [out] */ HMTNODE __RPC_FAR *phsiParent);
        
        END_INTERFACE
    } IScopeTreeIterVtbl;

    interface IScopeTreeIter
    {
        CONST_VTBL struct IScopeTreeIterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScopeTreeIter_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScopeTreeIter_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IScopeTreeIter_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IScopeTreeIter_SetCurrent(This,hStartMTNode)    \
    (This)->lpVtbl -> SetCurrent(This,hStartMTNode)

#define IScopeTreeIter_Next(This,nRequested,rghScopeItems,pnFetched)    \
    (This)->lpVtbl -> Next(This,nRequested,rghScopeItems,pnFetched)

#define IScopeTreeIter_Child(This,phsiChild)    \
    (This)->lpVtbl -> Child(This,phsiChild)

#define IScopeTreeIter_Parent(This,phsiParent)  \
    (This)->lpVtbl -> Parent(This,phsiParent)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_SetCurrent_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [in] */ HMTNODE hStartMTNode);


void __RPC_STUB IScopeTreeIter_SetCurrent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Next_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [in] */ UINT nRequested,
    /* [out] */ HMTNODE __RPC_FAR *rghScopeItems,
    /* [out] */ UINT __RPC_FAR *pnFetched);


void __RPC_STUB IScopeTreeIter_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Child_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [out] */ HMTNODE __RPC_FAR *phsiChild);


void __RPC_STUB IScopeTreeIter_Child_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IScopeTreeIter_Parent_Proxy( 
    IScopeTreeIter __RPC_FAR * This,
    /* [out] */ HMTNODE __RPC_FAR *phsiParent);


void __RPC_STUB IScopeTreeIter_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IScopeTreeIter_INTERFACE_DEFINED__ */


#ifndef __INodeCallback_INTERFACE_DEFINED__
#define __INodeCallback_INTERFACE_DEFINED__

/* interface INodeCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INodeCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b241fced-5fb3-11d0-a986-00c04fd8d565")
    INodeCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IScopeTree __RPC_FAR *pIScopeTree) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetImages( 
            /* [in] */ HNODE hNode,
            /* [out] */ int __RPC_FAR *iImage,
            int __RPC_FAR *iSelectedImage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWindowTitle( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDispInfo( 
            /* [in] */ HNODE hNode,
            /* [in] */ LPARAM dispInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultPane( 
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetControl( 
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [out] */ LONG_PTR __RPC_FAR *plControl) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControl( 
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [in] */ LONG_PTR lControl,
            /* [in] */ LONG_PTR destroyer,
            /* [in] */ IUnknown __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetResultItemID( 
            /* [in] */ HNODE hNode,
            /* [in] */ HRESULTITEM riID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultItemID( 
            /* [in] */ HNODE hNode,
            /* [out] */ HRESULTITEM __RPC_FAR *priID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNodeID( 
            /* [in] */ HNODE hNode,
            /* [out] */ MTNODEID __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [in] */ HNODE hNode,
            /* [out] */ MTNODEID __RPC_FAR *pnID,
            /* [out] */ unsigned char __RPC_FAR *__RPC_FAR *pbPath,
            /* [out] */ UINT __RPC_FAR *pcbPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticParentID( 
            /* [in] */ HNODE hNode,
            /* [out] */ MTNODEID __RPC_FAR *pnID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HNODE hNode,
            /* [in] */ NCLBK_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNode( 
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMTNodePath( 
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
            /* [out] */ long __RPC_FAR *plLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsExpandable( 
            /* [in] */ HNODE hNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCopyDataObject( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bScope,
            /* [in] */ BOOL bMultiSel,
            /* [in] */ LONG_PTR lvData,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Drop( 
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bMove,
            /* [in] */ IDataObject __RPC_FAR *pDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTaskEnumerator( 
            /* [in] */ HNODE hNode,
            /* [in] */ LPOLESTR pszTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateWindowLayout( 
            /* [in] */ LONG_PTR lViewData,
            /* [in] */ long lToolbarsDisplayed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddCustomFolderImage( 
            /* [in] */ HNODE hNode,
            /* [in] */ IImageListPrivate __RPC_FAR *pImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PreLoad( 
            /* [in] */ HNODE hNode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListPadInfo( 
            /* [in] */ HNODE hNode,
            /* [in] */ IExtendTaskPad __RPC_FAR *pExtendTaskPad,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ MMC_ILISTPAD_INFO __RPC_FAR *pIListPadInfo) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTaskPadList( 
            /* [in] */ HNODE hNode,
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct INodeCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ IScopeTree __RPC_FAR *pIScopeTree);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImages )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ int __RPC_FAR *iImage,
            int __RPC_FAR *iSelectedImage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayName )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindowTitle )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *pTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispInfo )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ LPARAM dispInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ UINT __RPC_FAR *pnState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultPane )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetControl )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [out] */ LONG_PTR __RPC_FAR *plControl);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControl )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ CLSID clsid,
            /* [in] */ LONG_PTR lControl,
            /* [in] */ LONG_PTR destroyer,
            /* [in] */ IUnknown __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResultItemID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ HRESULTITEM riID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultItemID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HRESULTITEM __RPC_FAR *priID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNodeID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ MTNODEID __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPath )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ MTNODEID __RPC_FAR *pnID,
            /* [out] */ unsigned char __RPC_FAR *__RPC_FAR *pbPath,
            /* [out] */ UINT __RPC_FAR *pcbPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticParentID )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ MTNODEID __RPC_FAR *pnID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ NCLBK_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNode )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *phMTNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMTNodePath )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
            /* [out] */ long __RPC_FAR *plLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsExpandable )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCopyDataObject )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bScope,
            /* [in] */ BOOL bMultiSel,
            /* [in] */ LONG_PTR lvData,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Drop )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ BOOL bMove,
            /* [in] */ IDataObject __RPC_FAR *pDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTaskEnumerator )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ LPOLESTR pszTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateWindowLayout )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ LONG_PTR lViewData,
            /* [in] */ long lToolbarsDisplayed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddCustomFolderImage )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ IImageListPrivate __RPC_FAR *pImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PreLoad )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListPadInfo )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ IExtendTaskPad __RPC_FAR *pExtendTaskPad,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ MMC_ILISTPAD_INFO __RPC_FAR *pIListPadInfo);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTaskPadList )( 
            INodeCallback __RPC_FAR * This,
            /* [in] */ HNODE hNode,
            /* [in] */ LPUNKNOWN pUnknown);
        
        END_INTERFACE
    } INodeCallbackVtbl;

    interface INodeCallback
    {
        CONST_VTBL struct INodeCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeCallback_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeCallback_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define INodeCallback_Release(This) \
    (This)->lpVtbl -> Release(This)


#define INodeCallback_Initialize(This,pIScopeTree)  \
    (This)->lpVtbl -> Initialize(This,pIScopeTree)

#define INodeCallback_GetImages(This,hNode,iImage,iSelectedImage)   \
    (This)->lpVtbl -> GetImages(This,hNode,iImage,iSelectedImage)

#define INodeCallback_GetDisplayName(This,hNode,pName)  \
    (This)->lpVtbl -> GetDisplayName(This,hNode,pName)

#define INodeCallback_GetWindowTitle(This,hNode,pTitle) \
    (This)->lpVtbl -> GetWindowTitle(This,hNode,pTitle)

#define INodeCallback_GetDispInfo(This,hNode,dispInfo)  \
    (This)->lpVtbl -> GetDispInfo(This,hNode,dispInfo)

#define INodeCallback_GetState(This,hNode,pnState)  \
    (This)->lpVtbl -> GetState(This,hNode,pnState)

#define INodeCallback_GetResultPane(This,hNode,ppszResultPane,pViewOptions) \
    (This)->lpVtbl -> GetResultPane(This,hNode,ppszResultPane,pViewOptions)

#define INodeCallback_GetControl(This,hNode,clsid,plControl)    \
    (This)->lpVtbl -> GetControl(This,hNode,clsid,plControl)

#define INodeCallback_SetControl(This,hNode,clsid,lControl,destroyer,pUnknown)  \
    (This)->lpVtbl -> SetControl(This,hNode,clsid,lControl,destroyer,pUnknown)

#define INodeCallback_SetResultItemID(This,hNode,riID)  \
    (This)->lpVtbl -> SetResultItemID(This,hNode,riID)

#define INodeCallback_GetResultItemID(This,hNode,priID) \
    (This)->lpVtbl -> GetResultItemID(This,hNode,priID)

#define INodeCallback_GetMTNodeID(This,hNode,pnID)  \
    (This)->lpVtbl -> GetMTNodeID(This,hNode,pnID)

#define INodeCallback_GetPath(This,hNode,pnID,pbPath,pcbPath)   \
    (This)->lpVtbl -> GetPath(This,hNode,pnID,pbPath,pcbPath)

#define INodeCallback_GetStaticParentID(This,hNode,pnID)    \
    (This)->lpVtbl -> GetStaticParentID(This,hNode,pnID)

#define INodeCallback_Notify(This,hNode,event,arg,param)    \
    (This)->lpVtbl -> Notify(This,hNode,event,arg,param)

#define INodeCallback_GetMTNode(This,hNode,phMTNode)    \
    (This)->lpVtbl -> GetMTNode(This,hNode,phMTNode)

#define INodeCallback_GetMTNodePath(This,hNode,pphMTNode,plLength)  \
    (This)->lpVtbl -> GetMTNodePath(This,hNode,pphMTNode,plLength)

#define INodeCallback_IsExpandable(This,hNode)  \
    (This)->lpVtbl -> IsExpandable(This,hNode)

#define INodeCallback_GetCopyDataObject(This,hNode,bScope,bMultiSel,lvData,ppDataObject)    \
    (This)->lpVtbl -> GetCopyDataObject(This,hNode,bScope,bMultiSel,lvData,ppDataObject)

#define INodeCallback_Drop(This,hNode,bMove,pDataObject)    \
    (This)->lpVtbl -> Drop(This,hNode,bMove,pDataObject)

#define INodeCallback_GetTaskEnumerator(This,hNode,pszTaskGroup,ppEnumTask) \
    (This)->lpVtbl -> GetTaskEnumerator(This,hNode,pszTaskGroup,ppEnumTask)

#define INodeCallback_UpdateWindowLayout(This,lViewData,lToolbarsDisplayed) \
    (This)->lpVtbl -> UpdateWindowLayout(This,lViewData,lToolbarsDisplayed)

#define INodeCallback_AddCustomFolderImage(This,hNode,pImageList)   \
    (This)->lpVtbl -> AddCustomFolderImage(This,hNode,pImageList)

#define INodeCallback_PreLoad(This,hNode)   \
    (This)->lpVtbl -> PreLoad(This,hNode)

#define INodeCallback_GetListPadInfo(This,hNode,pExtendTaskPad,szTaskGroup,pIListPadInfo)   \
    (This)->lpVtbl -> GetListPadInfo(This,hNode,pExtendTaskPad,szTaskGroup,pIListPadInfo)

#define INodeCallback_SetTaskPadList(This,hNode,pUnknown)   \
    (This)->lpVtbl -> SetTaskPadList(This,hNode,pUnknown)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Initialize_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ IScopeTree __RPC_FAR *pIScopeTree);


void __RPC_STUB INodeCallback_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetImages_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ int __RPC_FAR *iImage,
    int __RPC_FAR *iSelectedImage);


void __RPC_STUB INodeCallback_GetImages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetDisplayName_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *pName);


void __RPC_STUB INodeCallback_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetWindowTitle_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *pTitle);


void __RPC_STUB INodeCallback_GetWindowTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetDispInfo_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ LPARAM dispInfo);


void __RPC_STUB INodeCallback_GetDispInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetState_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ UINT __RPC_FAR *pnState);


void __RPC_STUB INodeCallback_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetResultPane_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ LPOLESTR __RPC_FAR *ppszResultPane,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB INodeCallback_GetResultPane_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetControl_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ CLSID clsid,
    /* [out] */ LONG_PTR __RPC_FAR *plControl);


void __RPC_STUB INodeCallback_GetControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetControl_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ CLSID clsid,
    /* [in] */ LONG_PTR lControl,
    /* [in] */ LONG_PTR destroyer,
    /* [in] */ IUnknown __RPC_FAR *pUnknown);


void __RPC_STUB INodeCallback_SetControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetResultItemID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ HRESULTITEM riID);


void __RPC_STUB INodeCallback_SetResultItemID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetResultItemID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HRESULTITEM __RPC_FAR *priID);


void __RPC_STUB INodeCallback_GetResultItemID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNodeID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ MTNODEID __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetMTNodeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetPath_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ MTNODEID __RPC_FAR *pnID,
    /* [out] */ unsigned char __RPC_FAR *__RPC_FAR *pbPath,
    /* [out] */ UINT __RPC_FAR *pcbPath);


void __RPC_STUB INodeCallback_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetStaticParentID_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ MTNODEID __RPC_FAR *pnID);


void __RPC_STUB INodeCallback_GetStaticParentID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Notify_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ NCLBK_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB INodeCallback_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNode_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HMTNODE __RPC_FAR *phMTNode);


void __RPC_STUB INodeCallback_GetMTNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetMTNodePath_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [out] */ HMTNODE __RPC_FAR *__RPC_FAR *pphMTNode,
    /* [out] */ long __RPC_FAR *plLength);


void __RPC_STUB INodeCallback_GetMTNodePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_IsExpandable_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode);


void __RPC_STUB INodeCallback_IsExpandable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetCopyDataObject_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bScope,
    /* [in] */ BOOL bMultiSel,
    /* [in] */ LONG_PTR lvData,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB INodeCallback_GetCopyDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_Drop_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ BOOL bMove,
    /* [in] */ IDataObject __RPC_FAR *pDataObject);


void __RPC_STUB INodeCallback_Drop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetTaskEnumerator_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ LPOLESTR pszTaskGroup,
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTask);


void __RPC_STUB INodeCallback_GetTaskEnumerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_UpdateWindowLayout_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ LONG_PTR lViewData,
    /* [in] */ long lToolbarsDisplayed);


void __RPC_STUB INodeCallback_UpdateWindowLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_AddCustomFolderImage_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ IImageListPrivate __RPC_FAR *pImageList);


void __RPC_STUB INodeCallback_AddCustomFolderImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_PreLoad_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode);


void __RPC_STUB INodeCallback_PreLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_GetListPadInfo_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ IExtendTaskPad __RPC_FAR *pExtendTaskPad,
    /* [string][in] */ LPOLESTR szTaskGroup,
    /* [out] */ MMC_ILISTPAD_INFO __RPC_FAR *pIListPadInfo);


void __RPC_STUB INodeCallback_GetListPadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE INodeCallback_SetTaskPadList_Proxy( 
    INodeCallback __RPC_FAR * This,
    /* [in] */ HNODE hNode,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB INodeCallback_SetTaskPadList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __INodeCallback_INTERFACE_DEFINED__ */


#ifndef __IControlbarsCache_INTERFACE_DEFINED__
#define __IControlbarsCache_INTERFACE_DEFINED__

/* interface IControlbarsCache */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IControlbarsCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9fcd38-b9a0-11d0-a79d-00c04fd8d565")
    IControlbarsCache : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DetachControlbars( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IControlbarsCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbarsCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbarsCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbarsCache __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DetachControlbars )( 
            IControlbarsCache __RPC_FAR * This);
        
        END_INTERFACE
    } IControlbarsCacheVtbl;

    interface IControlbarsCache
    {
        CONST_VTBL struct IControlbarsCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbarsCache_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbarsCache_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IControlbarsCache_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IControlbarsCache_DetachControlbars(This)   \
    (This)->lpVtbl -> DetachControlbars(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbarsCache_DetachControlbars_Proxy( 
    IControlbarsCache __RPC_FAR * This);


void __RPC_STUB IControlbarsCache_DetachControlbars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IControlbarsCache_INTERFACE_DEFINED__ */


#ifndef __IContextMenuProviderPrivate_INTERFACE_DEFINED__
#define __IContextMenuProviderPrivate_INTERFACE_DEFINED__

/* interface IContextMenuProviderPrivate */
/* [unique][helpstring][object][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9275b092-fe48-11d0-a7c9-00c04fd8d565")
    IContextMenuProviderPrivate : public IContextMenuProvider
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMultiSelectExtensionItems( 
            LONG_PTR lMultiSelection) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IContextMenuProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuProviderPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyMenuList )( 
            IContextMenuProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryExtensionItems )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddThirdPartyExtensionItems )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMultiSelectExtensionItems )( 
            IContextMenuProviderPrivate __RPC_FAR * This,
            LONG_PTR lMultiSelection);
        
        END_INTERFACE
    } IContextMenuProviderPrivateVtbl;

    interface IContextMenuProviderPrivate
    {
        CONST_VTBL struct IContextMenuProviderPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuProviderPrivate_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuProviderPrivate_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuProviderPrivate_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IContextMenuProviderPrivate_AddItem(This,pItem) \
    (This)->lpVtbl -> AddItem(This,pItem)


#define IContextMenuProviderPrivate_EmptyMenuList(This) \
    (This)->lpVtbl -> EmptyMenuList(This)

#define IContextMenuProviderPrivate_AddPrimaryExtensionItems(This,piExtension,piDataObject) \
    (This)->lpVtbl -> AddPrimaryExtensionItems(This,piExtension,piDataObject)

#define IContextMenuProviderPrivate_AddThirdPartyExtensionItems(This,piDataObject)  \
    (This)->lpVtbl -> AddThirdPartyExtensionItems(This,piDataObject)

#define IContextMenuProviderPrivate_ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)   \
    (This)->lpVtbl -> ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)


#define IContextMenuProviderPrivate_AddMultiSelectExtensionItems(This,lMultiSelection)  \
    (This)->lpVtbl -> AddMultiSelectExtensionItems(This,lMultiSelection)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProviderPrivate_AddMultiSelectExtensionItems_Proxy( 
    IContextMenuProviderPrivate __RPC_FAR * This,
    LONG_PTR lMultiSelection);


void __RPC_STUB IContextMenuProviderPrivate_AddMultiSelectExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IContextMenuProviderPrivate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ndmgr_0148 */
/* [local] */ 

typedef 
enum _EXTESION_TYPE
    {   EXTESION_NAMESPACE  = 0x1,
    EXTESION_CONTEXTMENU    = 0x2,
    EXTESION_TOOLBAR    = 0x3,
    EXTESION_PROPERTYSHEET  = 0x4
    }   EXTESION_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0148_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0148_v0_0_s_ifspec;

#ifndef __INodeType_INTERFACE_DEFINED__
#define __INodeType_INTERFACE_DEFINED__

/* interface INodeType */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INodeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B08A8368-967F-11D0-A799-00C04FD8D565")
    INodeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNodeTypeID( 
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddExtension( 
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveExtension( 
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtensions( 
            /* [in] */ EXTESION_TYPE extnType,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct INodeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNodeTypeID )( 
            INodeType __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtension )( 
            INodeType __RPC_FAR * This,
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveExtension )( 
            INodeType __RPC_FAR * This,
            /* [in] */ GUID guidSnapIn,
            /* [in] */ EXTESION_TYPE extnType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtensions )( 
            INodeType __RPC_FAR * This,
            /* [in] */ EXTESION_TYPE extnType,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID);
        
        END_INTERFACE
    } INodeTypeVtbl;

    interface INodeType
    {
        CONST_VTBL struct INodeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeType_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeType_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define INodeType_Release(This) \
    (This)->lpVtbl -> Release(This)


#define INodeType_GetNodeTypeID(This,pGUID) \
    (This)->lpVtbl -> GetNodeTypeID(This,pGUID)

#define INodeType_AddExtension(This,guidSnapIn,extnType)    \
    (This)->lpVtbl -> AddExtension(This,guidSnapIn,extnType)

#define INodeType_RemoveExtension(This,guidSnapIn,extnType) \
    (This)->lpVtbl -> RemoveExtension(This,guidSnapIn,extnType)

#define INodeType_EnumExtensions(This,extnType,ppEnumGUID)  \
    (This)->lpVtbl -> EnumExtensions(This,extnType,ppEnumGUID)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE INodeType_GetNodeTypeID_Proxy( 
    INodeType __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB INodeType_GetNodeTypeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_AddExtension_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ GUID guidSnapIn,
    /* [in] */ EXTESION_TYPE extnType);


void __RPC_STUB INodeType_AddExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_RemoveExtension_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ GUID guidSnapIn,
    /* [in] */ EXTESION_TYPE extnType);


void __RPC_STUB INodeType_RemoveExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeType_EnumExtensions_Proxy( 
    INodeType __RPC_FAR * This,
    /* [in] */ EXTESION_TYPE extnType,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppEnumGUID);


void __RPC_STUB INodeType_EnumExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __INodeType_INTERFACE_DEFINED__ */


#ifndef __INodeTypesCache_INTERFACE_DEFINED__
#define __INodeTypesCache_INTERFACE_DEFINED__

/* interface INodeTypesCache */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_INodeTypesCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE40436E-9671-11D0-A799-00C04FD8D565")
    INodeTypesCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateNodeType( 
            /* [in] */ GUID guidNodeType,
            /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteNodeType( 
            /* [in] */ GUID guidNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumNodeTypes( 
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct INodeTypesCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INodeTypesCache __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INodeTypesCache __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNodeType )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ GUID guidNodeType,
            /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteNodeType )( 
            INodeTypesCache __RPC_FAR * This,
            /* [in] */ GUID guidNodeType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumNodeTypes )( 
            INodeTypesCache __RPC_FAR * This,
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes);
        
        END_INTERFACE
    } INodeTypesCacheVtbl;

    interface INodeTypesCache
    {
        CONST_VTBL struct INodeTypesCacheVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INodeTypesCache_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INodeTypesCache_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define INodeTypesCache_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define INodeTypesCache_CreateNodeType(This,guidNodeType,ppNodeType)    \
    (This)->lpVtbl -> CreateNodeType(This,guidNodeType,ppNodeType)

#define INodeTypesCache_DeleteNodeType(This,guidNodeType)   \
    (This)->lpVtbl -> DeleteNodeType(This,guidNodeType)

#define INodeTypesCache_EnumNodeTypes(This,ppEnumNodeTypes) \
    (This)->lpVtbl -> EnumNodeTypes(This,ppEnumNodeTypes)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE INodeTypesCache_CreateNodeType_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [in] */ GUID guidNodeType,
    /* [out] */ INodeType __RPC_FAR *__RPC_FAR *ppNodeType);


void __RPC_STUB INodeTypesCache_CreateNodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeTypesCache_DeleteNodeType_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [in] */ GUID guidNodeType);


void __RPC_STUB INodeTypesCache_DeleteNodeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INodeTypesCache_EnumNodeTypes_Proxy( 
    INodeTypesCache __RPC_FAR * This,
    /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppEnumNodeTypes);


void __RPC_STUB INodeTypesCache_EnumNodeTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __INodeTypesCache_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ndmgr_0150 */
/* [local] */ 

#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0150_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0150_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/* interface IEnumGUID */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)    \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)   \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)   \
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)    \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumGUID_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ndmgr_0151 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0151_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0151_v0_0_s_ifspec;

#ifndef __IEnumNodeTypes_INTERFACE_DEFINED__
#define __IEnumNodeTypes_INTERFACE_DEFINED__

/* interface IEnumNodeTypes */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumNodeTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABBD61E6-9686-11D0-A799-00C04FD8D565")
    IEnumNodeTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumNodeTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumNodeTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumNodeTypes __RPC_FAR * This,
            /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumNodeTypesVtbl;

    interface IEnumNodeTypes
    {
        CONST_VTBL struct IEnumNodeTypesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNodeTypes_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNodeTypes_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IEnumNodeTypes_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnumNodeTypes_Next(This,celt,rgelt,pceltFetched)   \
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumNodeTypes_Skip(This,celt)  \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNodeTypes_Reset(This)  \
    (This)->lpVtbl -> Reset(This)

#define IEnumNodeTypes_Clone(This,ppenum)   \
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Next_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ INodeType __RPC_FAR *__RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumNodeTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Skip_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumNodeTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Reset_Proxy( 
    IEnumNodeTypes __RPC_FAR * This);


void __RPC_STUB IEnumNodeTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNodeTypes_Clone_Proxy( 
    IEnumNodeTypes __RPC_FAR * This,
    /* [out] */ IEnumNodeTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumNodeTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumNodeTypes_INTERFACE_DEFINED__ */


#ifndef __IDocConfig_INTERFACE_DEFINED__
#define __IDocConfig_INTERFACE_DEFINED__

/* interface IDocConfig */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDocConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F1E752C2-FD72-11D0-AEF6-00C04FB6DD2C")
    IDocConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseFile( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveFile( 
            /* [optional][in] */ BSTR bstrFilePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableSnapInExtension( 
            /* [in] */ BSTR bstrSnapInCLSID,
            /* [in] */ BSTR bstrExtensionCLSID,
            /* [in] */ VARIANT_BOOL bEnable) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDocConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDocConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenFile )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseFile )( 
            IDocConfig __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveFile )( 
            IDocConfig __RPC_FAR * This,
            /* [optional][in] */ BSTR bstrFilePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableSnapInExtension )( 
            IDocConfig __RPC_FAR * This,
            /* [in] */ BSTR bstrSnapInCLSID,
            /* [in] */ BSTR bstrExtensionCLSID,
            /* [in] */ VARIANT_BOOL bEnable);
        
        END_INTERFACE
    } IDocConfigVtbl;

    interface IDocConfig
    {
        CONST_VTBL struct IDocConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocConfig_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocConfig_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDocConfig_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDocConfig_GetTypeInfoCount(This,pctinfo)   \
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDocConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)    \
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDocConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)  \
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDocConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)    \
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDocConfig_OpenFile(This,bstrFilePath)  \
    (This)->lpVtbl -> OpenFile(This,bstrFilePath)

#define IDocConfig_CloseFile(This)  \
    (This)->lpVtbl -> CloseFile(This)

#define IDocConfig_SaveFile(This,bstrFilePath)  \
    (This)->lpVtbl -> SaveFile(This,bstrFilePath)

#define IDocConfig_EnableSnapInExtension(This,bstrSnapInCLSID,bstrExtensionCLSID,bEnable)   \
    (This)->lpVtbl -> EnableSnapInExtension(This,bstrSnapInCLSID,bstrExtensionCLSID,bEnable)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_OpenFile_Proxy( 
    IDocConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrFilePath);


void __RPC_STUB IDocConfig_OpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_CloseFile_Proxy( 
    IDocConfig __RPC_FAR * This);


void __RPC_STUB IDocConfig_CloseFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_SaveFile_Proxy( 
    IDocConfig __RPC_FAR * This,
    /* [optional][in] */ BSTR bstrFilePath);


void __RPC_STUB IDocConfig_SaveFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDocConfig_EnableSnapInExtension_Proxy( 
    IDocConfig __RPC_FAR * This,
    /* [in] */ BSTR bstrSnapInCLSID,
    /* [in] */ BSTR bstrExtensionCLSID,
    /* [in] */ VARIANT_BOOL bEnable);


void __RPC_STUB IDocConfig_EnableSnapInExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDocConfig_INTERFACE_DEFINED__ */



#ifndef __NODEMGRLib_LIBRARY_DEFINED__
#define __NODEMGRLib_LIBRARY_DEFINED__

/* library NODEMGRLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NODEMGRLib;

EXTERN_C const CLSID CLSID_NodeInit;

#ifdef __cplusplus

class DECLSPEC_UUID("43136EB5-D36C-11CF-ADBC-00AA00A80033")
NodeInit;
#endif

EXTERN_C const CLSID CLSID_ScopeTree;

#ifdef __cplusplus

class DECLSPEC_UUID("7F1899DA-62A6-11d0-A2C6-00C04FD909DD")
ScopeTree;
#endif

EXTERN_C const CLSID CLSID_MMCDocConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("F1E752C3-FD72-11D0-AEF6-00C04FB6DD2C")
MMCDocConfig;
#endif
#endif /* __NODEMGRLib_LIBRARY_DEFINED__ */

#ifndef __IPropertySheetProviderPrivate_INTERFACE_DEFINED__
#define __IPropertySheetProviderPrivate_INTERFACE_DEFINED__

/* interface IPropertySheetProviderPrivate */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPropertySheetProviderPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FEF554F8-A55A-11D0-A7D7-00C04FD909DD")
    IPropertySheetProviderPrivate : public IPropertySheetProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowEx( 
            /* [in] */ HWND hwnd,
            /* [in] */ int page,
            /* [in] */ BOOL bModalPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertySheetEx( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObject,
            /* [in] */ LONG_PTR lpMasterTreeNode,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMultiSelectionExtensionPages( 
            LONG_PTR lMultiSelection) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IPropertySheetProviderPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LONG_PTR window,
            /* [in] */ int page);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowEx )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ int page,
            /* [in] */ BOOL bModalPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheetEx )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObject,
            /* [in] */ LONG_PTR lpMasterTreeNode,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMultiSelectionExtensionPages )( 
            IPropertySheetProviderPrivate __RPC_FAR * This,
            LONG_PTR lMultiSelection);
        
        END_INTERFACE
    } IPropertySheetProviderPrivateVtbl;

    interface IPropertySheetProviderPrivate
    {
        CONST_VTBL struct IPropertySheetProviderPrivateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProviderPrivate_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProviderPrivate_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProviderPrivate_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProviderPrivate_CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)   \
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)

#define IPropertySheetProviderPrivate_FindPropertySheet(This,cookie,lpComponent,lpDataObject)   \
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProviderPrivate_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)    \
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProviderPrivate_AddExtensionPages(This)   \
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProviderPrivate_Show(This,window,page)    \
    (This)->lpVtbl -> Show(This,window,page)


#define IPropertySheetProviderPrivate_ShowEx(This,hwnd,page,bModalPage) \
    (This)->lpVtbl -> ShowEx(This,hwnd,page,bModalPage)

#define IPropertySheetProviderPrivate_CreatePropertySheetEx(This,title,type,cookie,pIDataObject,lpMasterTreeNode,dwOptions) \
    (This)->lpVtbl -> CreatePropertySheetEx(This,title,type,cookie,pIDataObject,lpMasterTreeNode,dwOptions)

#define IPropertySheetProviderPrivate_AddMultiSelectionExtensionPages(This,lMultiSelection) \
    (This)->lpVtbl -> AddMultiSelectionExtensionPages(This,lMultiSelection)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_ShowEx_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ int page,
    /* [in] */ BOOL bModalPage);


void __RPC_STUB IPropertySheetProviderPrivate_ShowEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_CreatePropertySheetEx_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ LPDATAOBJECT pIDataObject,
    /* [in] */ LONG_PTR lpMasterTreeNode,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IPropertySheetProviderPrivate_CreatePropertySheetEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProviderPrivate_AddMultiSelectionExtensionPages_Proxy( 
    IPropertySheetProviderPrivate __RPC_FAR * This,
    LONG_PTR lMultiSelection);


void __RPC_STUB IPropertySheetProviderPrivate_AddMultiSelectionExtensionPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPropertySheetProviderPrivate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ndmgr_0155 */
/* [local] */ 

typedef LPARAM CCLVItemID;

#define CCLV_HEADERPAD  ( 15 )



extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0155_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0155_v0_0_s_ifspec;

#ifndef __IMMCListView_INTERFACE_DEFINED__
#define __IMMCListView_INTERFACE_DEFINED__

/* interface IMMCListView */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMMCListView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1B3C1392-D68B-11CF-8C2B-00AA003CA9F6")
    IMMCListView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetListStyle( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetListStyle( 
            /* [in] */ long nNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewMode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewMode( 
            /* [in] */ long nViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long iconNdx,
            /* [in] */ LPARAM lParam,
            /* [in] */ long state,
            /* [in] */ long ownerID,
            /* [in] */ long itemIndex,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByString( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long nCol,
            /* [in] */ long occurrence,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ long owner,
            /* [in] */ LPARAM lParam,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ long subIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindColumnByString( 
            /* [in] */ LPOLESTR str,
            /* [in] */ long occurrence,
            /* [out] */ long __RPC_FAR *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAllItems( 
            /* [in] */ long ownerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumn( 
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumn( 
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ long __RPC_FAR *nFormat,
            /* [out] */ int __RPC_FAR *width) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnCount( 
            /* [out] */ int __RPC_FAR *nColCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nImage,
            /* [in] */ LPARAM lParam,
            /* [in] */ long nState,
            /* [in] */ long ownerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ int __RPC_FAR *nImage,
            /* [in] */ LPARAM __RPC_FAR *lParam,
            /* [out] */ unsigned int __RPC_FAR *nState,
            /* [in] */ long ownerID,
            /* [out] */ BOOL __RPC_FAR *pbScopeItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ COMPONENTID ownerID,
            /* [in] */ long nIndex,
            /* [in] */ UINT nState,
            /* [out] */ LPARAM __RPC_FAR *plParam,
            /* [out] */ long __RPC_FAR *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLParam( 
            /* [in] */ long nItem,
            /* [out] */ LPARAM __RPC_FAR *pLParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ long nItem,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ UINT add,
            /* [in] */ UINT remove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ long nID,
            /* [in] */ HICON hIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImageStrip( 
            /* [in] */ long nID,
            /* [in] */ HBITMAP hbmSmall,
            /* [in] */ HBITMAP hbmLarge,
            /* [in] */ long nStartLoc,
            /* [in] */ long cMask,
            /* [in] */ long nEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapImage( 
            /* [in] */ long nID,
            /* [in] */ long nLoc,
            /* [out] */ int __RPC_FAR *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [in] */ int __RPC_FAR *piItem,
            /* [out] */ UINT __RPC_FAR *flags,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Arrange( 
            /* [in] */ long style) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ CCLVItemID itemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RedrawItem( 
            /* [in] */ CCLVItemID itemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ LPARAM lUserParam,
            /* [in] */ long __RPC_FAR *pParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualMode( 
            /* [in] */ BOOL bVirtual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repaint( 
            /* [in] */ BOOL bErase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChangeTimeOut( 
            /* [in] */ ULONG lTimeout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumnFilter( 
            /* [in] */ int nCol,
            /* [in] */ DWORD dwType,
            /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColumnFilter( 
            /* [in] */ int nCol,
            /* [out][in] */ DWORD __RPC_FAR *dwType,
            /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IMMCListViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMMCListView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStyle )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStyle )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nNewValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nViewMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long iconNdx,
            /* [in] */ LPARAM lParam,
            /* [in] */ long state,
            /* [in] */ long ownerID,
            /* [in] */ long itemIndex,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByString )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nCol,
            /* [in] */ long occurrence,
            /* [in] */ long ownerID,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long owner,
            /* [in] */ LPARAM lParam,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long subIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindColumnByString )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPOLESTR str,
            /* [in] */ long occurrence,
            /* [out] */ long __RPC_FAR *pResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllItems )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long ownerID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [in] */ LPCOLESTR str,
            /* [in] */ long nFormat,
            /* [in] */ long width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumn )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ long __RPC_FAR *nFormat,
            /* [out] */ int __RPC_FAR *width);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnCount )( 
            IMMCListView __RPC_FAR * This,
            /* [out] */ int __RPC_FAR *nColCnt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [in] */ LPOLESTR str,
            /* [in] */ long nImage,
            /* [in] */ LPARAM lParam,
            /* [in] */ long nState,
            /* [in] */ long ownerID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ long nCol,
            /* [out] */ LPOLESTR __RPC_FAR *str,
            /* [out] */ int __RPC_FAR *nImage,
            /* [in] */ LPARAM __RPC_FAR *lParam,
            /* [out] */ unsigned int __RPC_FAR *nState,
            /* [in] */ long ownerID,
            /* [out] */ BOOL __RPC_FAR *pbScopeItem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ COMPONENTID ownerID,
            /* [in] */ long nIndex,
            /* [in] */ UINT nState,
            /* [out] */ LPARAM __RPC_FAR *plParam,
            /* [out] */ long __RPC_FAR *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLParam )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nItem,
            /* [out] */ LPARAM __RPC_FAR *pLParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nItem,
            /* [in] */ CCLVItemID itemID,
            /* [in] */ UINT add,
            /* [in] */ UINT remove);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIcon )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ HICON hIcon,
            /* [in] */ long nLoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImageStrip )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ HBITMAP hbmSmall,
            /* [in] */ HBITMAP hbmLarge,
            /* [in] */ long nStartLoc,
            /* [in] */ long cMask,
            /* [in] */ long nEntries);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapImage )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long nID,
            /* [in] */ long nLoc,
            /* [out] */ int __RPC_FAR *pResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IMMCListView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HitTest )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nX,
            /* [in] */ int nY,
            /* [in] */ int __RPC_FAR *piItem,
            /* [out] */ UINT __RPC_FAR *flags,
            /* [out] */ CCLVItemID __RPC_FAR *pItemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Arrange )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ long style);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RedrawItem )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ CCLVItemID itemID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ long __RPC_FAR *pParams);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVirtualMode )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ BOOL bVirtual);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Repaint )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ BOOL bErase);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChangeTimeOut )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ ULONG lTimeout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnFilter )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ DWORD dwType,
            /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnFilter )( 
            IMMCListView __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out][in] */ DWORD __RPC_FAR *dwType,
            /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);
        
        END_INTERFACE
    } IMMCListViewVtbl;

    interface IMMCListView
    {
        CONST_VTBL struct IMMCListViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMMCListView_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMMCListView_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IMMCListView_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IMMCListView_GetListStyle(This) \
    (This)->lpVtbl -> GetListStyle(This)

#define IMMCListView_SetListStyle(This,nNewValue)   \
    (This)->lpVtbl -> SetListStyle(This,nNewValue)

#define IMMCListView_GetViewMode(This)  \
    (This)->lpVtbl -> GetViewMode(This)

#define IMMCListView_SetViewMode(This,nViewMode)    \
    (This)->lpVtbl -> SetViewMode(This,nViewMode)

#define IMMCListView_InsertItem(This,str,iconNdx,lParam,state,ownerID,itemIndex,pItemID)    \
    (This)->lpVtbl -> InsertItem(This,str,iconNdx,lParam,state,ownerID,itemIndex,pItemID)

#define IMMCListView_DeleteItem(This,itemID,nCol)   \
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IMMCListView_FindItemByString(This,str,nCol,occurrence,ownerID,pItemID) \
    (This)->lpVtbl -> FindItemByString(This,str,nCol,occurrence,ownerID,pItemID)

#define IMMCListView_FindItemByLParam(This,owner,lParam,pItemID)    \
    (This)->lpVtbl -> FindItemByLParam(This,owner,lParam,pItemID)

#define IMMCListView_InsertColumn(This,nCol,str,nFormat,width)  \
    (This)->lpVtbl -> InsertColumn(This,nCol,str,nFormat,width)

#define IMMCListView_DeleteColumn(This,subIndex)    \
    (This)->lpVtbl -> DeleteColumn(This,subIndex)

#define IMMCListView_FindColumnByString(This,str,occurrence,pResult)    \
    (This)->lpVtbl -> FindColumnByString(This,str,occurrence,pResult)

#define IMMCListView_DeleteAllItems(This,ownerID)   \
    (This)->lpVtbl -> DeleteAllItems(This,ownerID)

#define IMMCListView_SetColumn(This,nCol,str,nFormat,width) \
    (This)->lpVtbl -> SetColumn(This,nCol,str,nFormat,width)

#define IMMCListView_GetColumn(This,nCol,str,nFormat,width) \
    (This)->lpVtbl -> GetColumn(This,nCol,str,nFormat,width)

#define IMMCListView_GetColumnCount(This,nColCnt)   \
    (This)->lpVtbl -> GetColumnCount(This,nColCnt)

#define IMMCListView_SetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID)  \
    (This)->lpVtbl -> SetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID)

#define IMMCListView_GetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID,pbScopeItem)  \
    (This)->lpVtbl -> GetItem(This,nIndex,itemID,nCol,str,nImage,lParam,nState,ownerID,pbScopeItem)

#define IMMCListView_GetNextItem(This,ownerID,nIndex,nState,plParam,pnIndex)    \
    (This)->lpVtbl -> GetNextItem(This,ownerID,nIndex,nState,plParam,pnIndex)

#define IMMCListView_GetLParam(This,nItem,pLParam)  \
    (This)->lpVtbl -> GetLParam(This,nItem,pLParam)

#define IMMCListView_ModifyItemState(This,nItem,itemID,add,remove)  \
    (This)->lpVtbl -> ModifyItemState(This,nItem,itemID,add,remove)

#define IMMCListView_SetIcon(This,nID,hIcon,nLoc)   \
    (This)->lpVtbl -> SetIcon(This,nID,hIcon,nLoc)

#define IMMCListView_SetImageStrip(This,nID,hbmSmall,hbmLarge,nStartLoc,cMask,nEntries) \
    (This)->lpVtbl -> SetImageStrip(This,nID,hbmSmall,hbmLarge,nStartLoc,cMask,nEntries)

#define IMMCListView_MapImage(This,nID,nLoc,pResult)    \
    (This)->lpVtbl -> MapImage(This,nID,nLoc,pResult)

#define IMMCListView_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IMMCListView_HitTest(This,nX,nY,piItem,flags,pItemID)   \
    (This)->lpVtbl -> HitTest(This,nX,nY,piItem,flags,pItemID)

#define IMMCListView_Arrange(This,style)    \
    (This)->lpVtbl -> Arrange(This,style)

#define IMMCListView_UpdateItem(This,itemID)    \
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IMMCListView_RedrawItem(This,itemID)    \
    (This)->lpVtbl -> RedrawItem(This,itemID)

#define IMMCListView_Sort(This,lUserParam,pParams)  \
    (This)->lpVtbl -> Sort(This,lUserParam,pParams)

#define IMMCListView_SetItemCount(This,nItemCount,dwOptions)    \
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#define IMMCListView_SetVirtualMode(This,bVirtual)  \
    (This)->lpVtbl -> SetVirtualMode(This,bVirtual)

#define IMMCListView_Repaint(This,bErase)   \
    (This)->lpVtbl -> Repaint(This,bErase)

#define IMMCListView_SetChangeTimeOut(This,lTimeout)    \
    (This)->lpVtbl -> SetChangeTimeOut(This,lTimeout)

#define IMMCListView_SetColumnFilter(This,nCol,dwType,pFilterData)  \
    (This)->lpVtbl -> SetColumnFilter(This,nCol,dwType,pFilterData)

#define IMMCListView_GetColumnFilter(This,nCol,dwType,pFilterData)  \
    (This)->lpVtbl -> GetColumnFilter(This,nCol,dwType,pFilterData)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IMMCListView_GetListStyle_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_GetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetListStyle_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nNewValue);


void __RPC_STUB IMMCListView_SetListStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetViewMode_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_GetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetViewMode_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nViewMode);


void __RPC_STUB IMMCListView_SetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_InsertItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long iconNdx,
    /* [in] */ LPARAM lParam,
    /* [in] */ long state,
    /* [in] */ long ownerID,
    /* [in] */ long itemIndex,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol);


void __RPC_STUB IMMCListView_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindItemByString_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long nCol,
    /* [in] */ long occurrence,
    /* [in] */ long ownerID,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_FindItemByString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindItemByLParam_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long owner,
    /* [in] */ LPARAM lParam,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_InsertColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [in] */ LPCOLESTR str,
    /* [in] */ long nFormat,
    /* [in] */ long width);


void __RPC_STUB IMMCListView_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long subIndex);


void __RPC_STUB IMMCListView_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_FindColumnByString_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPOLESTR str,
    /* [in] */ long occurrence,
    /* [out] */ long __RPC_FAR *pResult);


void __RPC_STUB IMMCListView_FindColumnByString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_DeleteAllItems_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long ownerID);


void __RPC_STUB IMMCListView_DeleteAllItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [in] */ LPCOLESTR str,
    /* [in] */ long nFormat,
    /* [in] */ long width);


void __RPC_STUB IMMCListView_SetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetColumn_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nCol,
    /* [out] */ LPOLESTR __RPC_FAR *str,
    /* [out] */ long __RPC_FAR *nFormat,
    /* [out] */ int __RPC_FAR *width);


void __RPC_STUB IMMCListView_GetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetColumnCount_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [out] */ int __RPC_FAR *nColCnt);


void __RPC_STUB IMMCListView_GetColumnCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol,
    /* [in] */ LPOLESTR str,
    /* [in] */ long nImage,
    /* [in] */ LPARAM lParam,
    /* [in] */ long nState,
    /* [in] */ long ownerID);


void __RPC_STUB IMMCListView_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ long nCol,
    /* [out] */ LPOLESTR __RPC_FAR *str,
    /* [out] */ int __RPC_FAR *nImage,
    /* [in] */ LPARAM __RPC_FAR *lParam,
    /* [out] */ unsigned int __RPC_FAR *nState,
    /* [in] */ long ownerID,
    /* [out] */ BOOL __RPC_FAR *pbScopeItem);


void __RPC_STUB IMMCListView_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetNextItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ COMPONENTID ownerID,
    /* [in] */ long nIndex,
    /* [in] */ UINT nState,
    /* [out] */ LPARAM __RPC_FAR *plParam,
    /* [out] */ long __RPC_FAR *pnIndex);


void __RPC_STUB IMMCListView_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetLParam_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nItem,
    /* [out] */ LPARAM __RPC_FAR *pLParam);


void __RPC_STUB IMMCListView_GetLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_ModifyItemState_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nItem,
    /* [in] */ CCLVItemID itemID,
    /* [in] */ UINT add,
    /* [in] */ UINT remove);


void __RPC_STUB IMMCListView_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetIcon_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ HICON hIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IMMCListView_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetImageStrip_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ HBITMAP hbmSmall,
    /* [in] */ HBITMAP hbmLarge,
    /* [in] */ long nStartLoc,
    /* [in] */ long cMask,
    /* [in] */ long nEntries);


void __RPC_STUB IMMCListView_SetImageStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_MapImage_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long nID,
    /* [in] */ long nLoc,
    /* [out] */ int __RPC_FAR *pResult);


void __RPC_STUB IMMCListView_MapImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Reset_Proxy( 
    IMMCListView __RPC_FAR * This);


void __RPC_STUB IMMCListView_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_HitTest_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nX,
    /* [in] */ int nY,
    /* [in] */ int __RPC_FAR *piItem,
    /* [out] */ UINT __RPC_FAR *flags,
    /* [out] */ CCLVItemID __RPC_FAR *pItemID);


void __RPC_STUB IMMCListView_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Arrange_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ long style);


void __RPC_STUB IMMCListView_Arrange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_UpdateItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID);


void __RPC_STUB IMMCListView_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_RedrawItem_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ CCLVItemID itemID);


void __RPC_STUB IMMCListView_RedrawItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Sort_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ LPARAM lUserParam,
    /* [in] */ long __RPC_FAR *pParams);


void __RPC_STUB IMMCListView_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetItemCount_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IMMCListView_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetVirtualMode_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ BOOL bVirtual);


void __RPC_STUB IMMCListView_SetVirtualMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_Repaint_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ BOOL bErase);


void __RPC_STUB IMMCListView_Repaint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetChangeTimeOut_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ ULONG lTimeout);


void __RPC_STUB IMMCListView_SetChangeTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_SetColumnFilter_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ DWORD dwType,
    /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);


void __RPC_STUB IMMCListView_SetColumnFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMMCListView_GetColumnFilter_Proxy( 
    IMMCListView __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out][in] */ DWORD __RPC_FAR *dwType,
    /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);


void __RPC_STUB IMMCListView_GetColumnFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IMMCListView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ndmgr_0156 */
/* [local] */ 

struct  MMC_ITASK
    {
    MMC_TASK task;
    LPOLESTR szClsid;
    };


extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ndmgr_0156_v0_0_s_ifspec;

#ifndef __ITaskPadHost_INTERFACE_DEFINED__
#define __ITaskPadHost_INTERFACE_DEFINED__

/* interface ITaskPadHost */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITaskPadHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4f7606d0-5568-11d1-9fea-00600832db4a")
    ITaskPadHost : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TaskNotify( 
            /* [string][in] */ BSTR szClsid,
            /* [in] */ VARIANT __RPC_FAR *pvArg,
            /* [in] */ VARIANT __RPC_FAR *pvParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTaskEnumerator( 
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPrimaryTask( 
            /* [out] */ IExtendTaskPad __RPC_FAR *__RPC_FAR *ppExtendTaskPad) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ BSTR __RPC_FAR *szTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBanner( 
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ BSTR __RPC_FAR *szBitmapResource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ BSTR __RPC_FAR *szBitmapResource) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListPadInfo( 
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ MMC_ILISTPAD_INFO __RPC_FAR *pIListPadInfo) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ITaskPadHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITaskPadHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITaskPadHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITaskPadHost __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TaskNotify )( 
            ITaskPadHost __RPC_FAR * This,
            /* [string][in] */ BSTR szClsid,
            /* [in] */ VARIANT __RPC_FAR *pvArg,
            /* [in] */ VARIANT __RPC_FAR *pvParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTaskEnumerator )( 
            ITaskPadHost __RPC_FAR * This,
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPrimaryTask )( 
            ITaskPadHost __RPC_FAR * This,
            /* [out] */ IExtendTaskPad __RPC_FAR *__RPC_FAR *ppExtendTaskPad);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTitle )( 
            ITaskPadHost __RPC_FAR * This,
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ BSTR __RPC_FAR *szTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBanner )( 
            ITaskPadHost __RPC_FAR * This,
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ BSTR __RPC_FAR *szBitmapResource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackground )( 
            ITaskPadHost __RPC_FAR * This,
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ BSTR __RPC_FAR *szBitmapResource);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListPadInfo )( 
            ITaskPadHost __RPC_FAR * This,
            /* [in] */ BSTR szTaskGroup,
            /* [out] */ MMC_ILISTPAD_INFO __RPC_FAR *pIListPadInfo);
        
        END_INTERFACE
    } ITaskPadHostVtbl;

    interface ITaskPadHost
    {
        CONST_VTBL struct ITaskPadHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITaskPadHost_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITaskPadHost_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define ITaskPadHost_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define ITaskPadHost_TaskNotify(This,szClsid,pvArg,pvParam) \
    (This)->lpVtbl -> TaskNotify(This,szClsid,pvArg,pvParam)

#define ITaskPadHost_GetTaskEnumerator(This,szTaskGroup,ppEnumTASK) \
    (This)->lpVtbl -> GetTaskEnumerator(This,szTaskGroup,ppEnumTASK)

#define ITaskPadHost_GetPrimaryTask(This,ppExtendTaskPad)   \
    (This)->lpVtbl -> GetPrimaryTask(This,ppExtendTaskPad)

#define ITaskPadHost_GetTitle(This,szTaskGroup,szTitle) \
    (This)->lpVtbl -> GetTitle(This,szTaskGroup,szTitle)

#define ITaskPadHost_GetBanner(This,szTaskGroup,szBitmapResource)   \
    (This)->lpVtbl -> GetBanner(This,szTaskGroup,szBitmapResource)

#define ITaskPadHost_GetBackground(This,szTaskGroup,szBitmapResource)   \
    (This)->lpVtbl -> GetBackground(This,szTaskGroup,szBitmapResource)

#define ITaskPadHost_GetListPadInfo(This,szTaskGroup,pIListPadInfo) \
    (This)->lpVtbl -> GetListPadInfo(This,szTaskGroup,pIListPadInfo)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_TaskNotify_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [string][in] */ BSTR szClsid,
    /* [in] */ VARIANT __RPC_FAR *pvArg,
    /* [in] */ VARIANT __RPC_FAR *pvParam);


void __RPC_STUB ITaskPadHost_TaskNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_GetTaskEnumerator_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [in] */ BSTR szTaskGroup,
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);


void __RPC_STUB ITaskPadHost_GetTaskEnumerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_GetPrimaryTask_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [out] */ IExtendTaskPad __RPC_FAR *__RPC_FAR *ppExtendTaskPad);


void __RPC_STUB ITaskPadHost_GetPrimaryTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_GetTitle_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [in] */ BSTR szTaskGroup,
    /* [out] */ BSTR __RPC_FAR *szTitle);


void __RPC_STUB ITaskPadHost_GetTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_GetBanner_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [in] */ BSTR szTaskGroup,
    /* [out] */ BSTR __RPC_FAR *szBitmapResource);


void __RPC_STUB ITaskPadHost_GetBanner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_GetBackground_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [in] */ BSTR szTaskGroup,
    /* [out] */ BSTR __RPC_FAR *szBitmapResource);


void __RPC_STUB ITaskPadHost_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ITaskPadHost_GetListPadInfo_Proxy( 
    ITaskPadHost __RPC_FAR * This,
    /* [in] */ BSTR szTaskGroup,
    /* [out] */ MMC_ILISTPAD_INFO __RPC_FAR *pIListPadInfo);


void __RPC_STUB ITaskPadHost_GetListPadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ITaskPadHost_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long __RPC_FAR *, HBITMAP __RPC_FAR * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long __RPC_FAR *, HICON __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\shutdown.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        shutdown.cpp

   Abstract:

        IIS Shutdown/restart dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "inetmgr.h"
#include "sdprg.h"
#include "shutdown.h"



//
// Shutdown in microseconds
//
#define IIS_SHUTDOWN_TIMEOUT        30000L      // 30 Ms



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CIISShutdownDlg::CIISShutdownDlg(
    IN LPCTSTR lpszServer,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    LPCTSTR lpszServer  : Server name
    CWnd * pParent      : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CIISShutdownDlg::IDD, pParent),
      m_fServicesRestarted(FALSE),
      m_fLocalMachine(::IsServerLocal(lpszServer)),
      m_strServer(lpszServer)
{
    //{{AFX_DATA_INIT(CIISShutdownDlg)
    //}}AFX_DATA_INIT
}



void 
CIISShutdownDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIISShutdownDlg)
    DDX_Control(pDX, IDC_COMBO_RESTART,  m_combo_Restart);
    DDX_Control(pDX, IDC_STATIC_DETAILS, m_static_Details);
    //}}AFX_DATA_MAP
}



void
CIISShutdownDlg::SetDetailsText()
/*++

Routine Description:

    Set the details text to correspond to what's in the combo box

Arguments:

    None

Return Value:

    None

--*/
{
    UINT nSel = m_combo_Restart.GetCurSel();

    ASSERT(nSel >= 0 && nSel < NUM_ISC_ITEMS);

    m_static_Details.SetWindowText(m_strDetails[nSel]);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISShutdownDlg, CDialog)
    //{{AFX_MSG_MAP(CIISShutdownDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_RESTART, OnSelchangeComboRestart)
    ON_CBN_DBLCLK(IDC_COMBO_RESTART, OnDblclkComboRestart)
    ON_BN_CLICKED(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CRITICAL_SECTION gcs;

UINT
__cdecl
StopIISServices(
    IN LPVOID pParam
    )
/*++

Routine Description:

    Worker thread to perform IIS Service Control Command

Arguments:

    LPVOID * pParam     : Casts to IISCOMMAND (see above)

Return Value:

    UINT

--*/
{
    IISCOMMAND * pCmd = (IISCOMMAND *)pParam;

    //MessageBeep(0);

    // 
    // This thread needs its own CoInitialize
    //
    CError err(CoInitialize(NULL));             

    CIISSvcControl isc(pCmd->szServer);
    err = isc.QueryResult();

    // Block access to pCmd:
    // if user will click on "End Now" then process will
    // be killed and pCmd could by deleted async in parent
    // code -- this is why we need gcs
    EnterCriticalSection(&gcs);

    if (err.Succeeded())
    {
        err = isc.Stop(IIS_SHUTDOWN_TIMEOUT, TRUE);
    }

    //
    // Clean Up, returning the error code
    //
    EnterCriticalSection(&pCmd->cs);
    pCmd->fFinished = TRUE;
    pCmd->hReturn   = err;
    LeaveCriticalSection(&pCmd->cs);

    LeaveCriticalSection(&gcs);

    return 0;
}



HRESULT
CIISShutdownDlg::PerformCommand(
    IN int iCmd
    )
/*++

Routine Description:

    Perform restart command

Arguments:

    int iCmd - One of the following commands:

        ISC_START
        ISC_STOP
        ISC_SHUTDOWN
        ISC_RESTART

Return Value:

    HRESULT

--*/
{
    //
    // Make sure the service is supported
    //
    BeginWaitCursor();
    CIISSvcControl isc(m_strServer);
    EndWaitCursor();

    CError err(isc.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    //
    // Create command structure to hand off to 
    // worker thread
    //
    IISCOMMAND * pCommand = new IISCOMMAND;

    if (!pCommand)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    ZeroMemory(pCommand, sizeof(IISCOMMAND));
    lstrcpy(pCommand->szServer, m_strServer);
    pCommand->dwMilliseconds = IIS_SHUTDOWN_TIMEOUT;
    pCommand->pParent = this;

    InitializeCriticalSection(&pCommand->cs);
    InitializeCriticalSection(&gcs);

    CShutProgressDlg dlg(pCommand);
    CWinThread * pStopThread = NULL;
    BOOL fStartServices      = FALSE;
    INT_PTR nReturn          = IDCANCEL;

    //
    // Fire off the thread that does the actual work, while we
    // put up the progress UI
    //
    switch(iCmd)
    {
    case ISC_RESTART:
        ++fStartServices;
        //
        // Fall through...
        //
    case ISC_STOP:
        //
        // Stop the services in the workerthread
        //
        pStopThread = AfxBeginThread(&StopIISServices, pCommand);
        nReturn = dlg.DoModal();
        break;

    case ISC_START:
        ++fStartServices;
        break;

    case ISC_SHUTDOWN:
        BeginWaitCursor();
        err = isc.Reboot(IIS_SHUTDOWN_TIMEOUT, m_fLocalMachine);
        EndWaitCursor();
        break;

    default:
        //
        // Internal error!
        //
        ASSERT(FALSE && "Invalid command code!");
        err = ERROR_INVALID_FUNCTION;
    }

    //
    // Determine if a kill is necessary (timed-out or user
    // pressed 'Kill')
    //
    BeginWaitCursor();

    if (nReturn == IDOK)
    {
        TRACEEOLID("Killing now!");
        err = isc.Kill();
        Sleep(1000L);
    }
    else
    {
        //
        // Waiting for the thread to finish
        //
        if (pStopThread != NULL)
        {
            BOOL fDone = FALSE;

            while(!fDone)
            {
                TRACEEOLID("Checking to see if thread has finished");

                EnterCriticalSection(&pCommand->cs);

                if (pCommand->fFinished)
                {
                    err = pCommand->hReturn;
                    ++fDone;
                }

                LeaveCriticalSection(&pCommand->cs);

                //
                // Pause a bit...
                //
                if (!fDone)
                {
                    Sleep(500);
                }
            }
        }
    }

    //
    // Everything should be stopped, start it up again
    // if necessary.
    //
    if (err.Succeeded() && fStartServices)
    {
        err = isc.Start(IIS_SHUTDOWN_TIMEOUT);
        m_fServicesRestarted = err.Succeeded();
    }

    EndWaitCursor();

    //
    // Clean Up
    //
    EnterCriticalSection(&gcs);
    DeleteCriticalSection(&pCommand->cs);
    delete pCommand;
    LeaveCriticalSection(&gcs);

    DeleteCriticalSection(&gcs);

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CIISShutdownDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Load combobox text and details
    //
    CString strFmt, str;

    //
    // This may take a second or two...
    //
    BeginWaitCursor();
    CIISSvcControl isc(m_strServer);
    EndWaitCursor();

    CError err(isc.QueryResult());

    if (err.Failed())
    {
        //
        // Failed to obtain interface -- quit now.
        //
        if (err.HResult() == REGDB_E_CLASSNOTREG
         || err.HResult() == CS_E_PACKAGE_NOTFOUND
           )
        {
            //
            // Friendly message about the interface not being supported
            //
            AfxMessageBox(IDS_ERR_NO_SHUTDOWN);
        }
        else
        {
            err.MessageBox();
        }

        EndDialog(IDCANCEL);
    }

/* TEST code

    if (isc.Succeeded())
    {
        //LPBYTE   pbBuffer;
        BYTE     abBuffer[4096];
        DWORD    dwReq;
        DWORD    dwNumServices;

        HRESULT hr = isc.Status(sizeof(abBuffer), abBuffer, &dwReq, &dwNumServices);

        TRACEEOLID(hr);
    }

*/

    UINT nOption = IDS_IIS_START;
    UINT nDetails = IDS_IIS_START_DETAILS;

    for (int i = ISC_START; i <= ISC_RESTART; ++i)
    {
        VERIFY(strFmt.LoadString(nOption++));
        str.Format(strFmt, (LPCTSTR)m_strServer);
        VERIFY(m_strDetails[i].LoadString(nDetails++));

        m_combo_Restart.AddString(str);
    }
    
    m_combo_Restart.SetCurSel(ISC_RESTART);
    m_combo_Restart.SetFocus();

    SetDetailsText();
    
    return FALSE;  
}



void 
CIISShutdownDlg::OnSelchangeComboRestart() 
/*++

Routine Description:

    Selection change notification handler.  Change the text in the details
    static text to reflect the new selection in the combo box

Arguments:

    None

Return Value:

    None

--*/
{
    SetDetailsText();
}



void 
CIISShutdownDlg::OnDblclkComboRestart() 
/*++

Routine Description:

    Double-click notification handler.  Maps to OK

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Go with the current selection
    //
    OnOK();
}



void 
CIISShutdownDlg::OnOK() 
/*++

Routine Description:

    "OK" button has been pressed, and perform the selected action.

Arguments:

    None

Return Value:

    None

--*/
{
    int iCmd = m_combo_Restart.GetCurSel();

    CError err = PerformCommand(iCmd);

    if (!err.MessageBoxOnFailure())
    {
        //
        // No error, dismiss the dialog
        //
        CDialog::OnOK();
    }

    //
    // Failed -- do not dismiss the dialog
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\stdafx.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        stdafx.cpp

   Abstract:

        Pre-compiled header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\shutdown.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        shutdown.h

   Abstract:

        IIS Shutdown/restart dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SHUTDOWN_H__
#define __SHUTDOWN_H__



enum
{
    //
    // Note: make sure that associated resource IDs remain
    //       sequential.
    //
    ISC_START,
    ISC_STOP,
    ISC_SHUTDOWN,
    ISC_RESTART,
    /**/
    NUM_ISC_ITEMS
};



class CIISShutdownDlg : public CDialog
/*++

Class Description:

    IIS Shutdown/Restart dialog

Public Interface:

    CIISShutdownDlg         - Constructor

    ServicesWereRestarted   Returns true if the services were restarted

--*/
{
//
// Construction
//
public:
    CIISShutdownDlg(
        IN LPCTSTR lpszServer,
        IN CWnd * pParent       = NULL
        );

//
// Access
//
public:
    BOOL ServicesWereRestarted() const { return m_fServicesRestarted; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISShutdownDlg)
    enum { IDD = IDD_SHUTDOWN };
    CStatic     m_static_Details;
    CComboBox   m_combo_Restart;
    //}}AFX_DATA

    CString m_strDetails[NUM_ISC_ITEMS];

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIISShutdownDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIISShutdownDlg)
    afx_msg void OnSelchangeComboRestart();
    afx_msg void OnDblclkComboRestart();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetDetailsText();
    HRESULT PerformCommand(int iCmd);

private:
    CString m_strServer;
    BOOL m_fServicesRestarted;
    BOOL m_fLocalMachine;
};



#endif // __SHUTDOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\advdlg.h ===
// AdvDlg.h : header file
//


#define SZ_MB_DIRGLOBALS_OBJECT "/LM/W3SVC/1//"
#define SZ_MB_ROOTDIR_OBJECT    "/LM/W3SVC/1//"

/////////////////////////////////////////////////////////////////////////////
// CVirtDir object - for maintaining the list
class CVirtDir : public CObject
    {
public:
    CVirtDir(BOOL bRoot = FALSE);

    // interfaces with the metabase
    BOOL FSaveToMetabase();
    BOOL FRemoveFromMetabase( BOOL fSaveMB = TRUE );

    // initialize the class as a new class - involves asking the user to pick a dir
    BOOL FInitAsNew();

    // get the appropriate error string for the list
    void GetErrorStr( CString &sz );

    BOOL Edit();

    // public members
    CString     m_szPath;
    CString     m_szAlias;
    CString     m_szMetaAlias;
    BOOL        m_fIsRoot;
    };

/////////////////////////////////////////////////////////////////////////////
// CAdvancedDlg dialog

class CAdvancedDlg : public CDialog
    {
// Construction
public:
    CAdvancedDlg(CWnd* pParent = NULL);   // standard constructor

    virtual BOOL OnInitDialog();

    void RefreshGlobals();
    void RefreshList();

// Dialog Data
    //{{AFX_DATA(CAdvancedDlg)
    enum { IDD = IDD_ADVANCED };
    CStatic m_cstatic_default;
    CEdit   m_cedit_default;
    CButton m_cbutton_change;
    CListCtrl   m_clistctrl_list;
    CButton m_cbutton_remove;
    CString m_sz_defaultdoc;
    BOOL    m_f_browsingallowed;
    BOOL    m_f_enabledefault;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAdvancedDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAdvancedDlg)
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAdd();
    afx_msg void OnChange();
    afx_msg void OnRemove();
    afx_msg void OnEnabledefault();
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRefresh();
    afx_msg void OnBrowsingAllowed();
    afx_msg void OnKillfocusDefaultDoc();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // more initialization methods
    BOOL FInitGlobalParameters();
    BOOL FInitList();
    BOOL FillList();
    void AddToDisplayList( CVirtDir* pDir );

    // refreshing utilities
    void EmptyOutList();

    // apply utilities
    void ApplyGlobalParameters();
//  void ApplyList();

    // utilities
    void EnableDependantButtons();
//  void SetModified( BOOL bChanged = TRUE ) { m_modified = bChanged; EnableDependantButtons(); }

//  DWORD IDirInModList( CVirtDir* pDir );
//  DWORD IDirInNewList( CVirtDir* pDir );

    // members
//  BOOL        m_modified;
    CImageList  m_imageList;
    CString     m_szSaved;

    BOOL        m_fApplyingGlobals;

    // edited dirs already saved in the metabase
//  CTypedPtrArray<CObArray, CVirtDir*>     m_ModifiedList;
    // new dirs that are to be added
//  CTypedPtrArray<CObArray, CVirtDir*>     m_NewList;
    // dirs that are to be deleted
//  CTypedPtrArray<CObArray, CVirtDir*>     m_DeleteList;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\chrtdraw.cpp ===
// ChrtDraw.cpp : implementation file
//

#include "stdafx.h"

#include "pwsDoc.h"
#include "PWSChart.h"
#include "PwsForm.h"

#include <pwsdata.hxx>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//------------------------------------------------------------------
// update the chart displaying the data
void CPwsForm::UpdateChart()
    {
    CString sz;
    PPWS_DATA   pData = (PPWS_DATA)m_pChartData;

    if ( !pData ) return;

    // start by getting the current PWS Data from the server
    if ( !GetPwsData(pData) )
        {
        return;
        }

    // update the current users - easy
    sz.Format( "%d", pData->nTotalSessions );
    m_cstatic_sessions.SetWindowText(sz);

    // tell the chart object to do its thing
    m_cstatic_chart.DrawChart();

    // update the scale shown on the chart
    sz.Format( "%d", m_cstatic_chart.GetDataMax() );
    m_cstatic_yscale.SetWindowText(sz);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\mmc\stdafx.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        stdafx.cpp

   Abstract:

        Pre-compiled header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#define OEMRESOURCE         // Give me OEM resource definitions
#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxdisp.h>        // CG: added by OLE Control Containment component
#include <afxpriv.h>
#include <atlbase.h>

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <tchar.h>

class CFlexComModule : public CComModule
{
public:
    CFlexComModule() : CComModule() {}
    HRESULT WINAPI UpdateRegistryClass(
        const CLSID& clsid, 
        LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, 
        UINT nDescID, 
        DWORD dwFlags, 
        BOOL bRegister
        );
};

//extern CComModule _Module;
extern CFlexComModule _Module;
#include <atlcom.h>


#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(x) struct
#endif // MIDL_INTERFACE

#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__ 440
#endif // __RPCNDR_H_VERSION__


#pragma comment(lib, "mmc")
#include <mmc.h>
#include "afxtempl.h"

#include "guids.h"
#include "winsock2.h"     //  WinSock definitions

#include <aclapi.h>

//
// Debug instance counter
//
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    //char buf[100];
    //wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    //::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\advdlg.cpp ===
// AdvDlg.cpp : implementation file
//

// NOTE: This files makes the assumption that there are a reasonable number of published.
// If there are thousands, or hundreds of thousands of them - it will be slow because it
// rescans the metabase after changes. Then again, this whole product is intended for
// sites that are MUCH smaller than that.


#include "stdafx.h"
#include "AdvDlg.h"
#include "pwsDoc.h"
#include "PWSChart.h"
#include "PwsForm.h"

#include <mddef.h>
#include "EdDir.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_ALIAS               0
#define COL_DIRECTORY           1
#define COL_ERROR               2
// a global reference to the form view - for ease of access
extern CPwsForm*    g_p_FormView;

/////////////////////////////////////////////////////////////////////////////
// CAdvancedDlg dialog


//-----------------------------------------------------------------
CAdvancedDlg::CAdvancedDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CAdvancedDlg::IDD, pParent),
    m_fApplyingGlobals( FALSE )
    {
    //{{AFX_DATA_INIT(CAdvancedDlg)
    m_sz_defaultdoc = _T("");
    m_f_browsingallowed = FALSE;
    m_f_enabledefault = FALSE;
    //}}AFX_DATA_INIT
    }


//-----------------------------------------------------------------
void CAdvancedDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAdvancedDlg)
    DDX_Control(pDX, IDC_STATIC_DEFAULT, m_cstatic_default);
    DDX_Control(pDX, IDC_DEFAULT_DOC, m_cedit_default);
    DDX_Control(pDX, IDC_CHANGE, m_cbutton_change);
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_REMOVE, m_cbutton_remove);
    DDX_Text(pDX, IDC_DEFAULT_DOC, m_sz_defaultdoc);
    DDX_Check(pDX, IDC_BROWSING_ALLOWED, m_f_browsingallowed);
    DDX_Check(pDX, IDC_ENABLEDEFAULT, m_f_enabledefault);
    //}}AFX_DATA_MAP
    }

//-----------------------------------------------------------------
BEGIN_MESSAGE_MAP(CAdvancedDlg, CDialog)
    //{{AFX_MSG_MAP(CAdvancedDlg)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_CHANGE, OnChange)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_ENABLEDEFAULT, OnEnabledefault)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
    ON_BN_CLICKED(IDC_BROWSING_ALLOWED, OnBrowsingAllowed)
    ON_EN_KILLFOCUS(IDC_DEFAULT_DOC, OnKillfocusDefaultDoc)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------
BOOL CAdvancedDlg::FInitList()
    {
    CString sz;
    int             i;

    // setup the alias field
    sz.LoadString( IDS_ALIAS );
    i = m_clistctrl_list.InsertColumn( COL_ALIAS, sz, LVCFMT_LEFT, 95 );

    // setup the directory field
    sz.LoadString( IDS_DIRECTORY );
    i = m_clistctrl_list.InsertColumn( COL_DIRECTORY, sz, LVCFMT_LEFT, 225);
    // setup the match criteria column
    sz.LoadString( IDS_ERROR );
    i = m_clistctrl_list.InsertColumn( COL_ERROR, sz, LVCFMT_LEFT, 95 );

    // prepare the list's image list
    if ( m_imageList.Create( IDB_LIST_IMAGES, 17, 3, 0x00FF00FF ) )
        // set the image list into the list control
        m_clistctrl_list.SetImageList( &m_imageList, LVSIL_SMALL );

    return TRUE;
    }

//-----------------------------------------------------------------
BOOL CAdvancedDlg::FInitGlobalParameters()
    {
    CHAR    buff[MAX_PATH];
    DWORD   dword;

    m_fApplyingGlobals = TRUE;

    // prep the mb objcet
    CWrapMetaBase   mb;
    if ( !FInitMetabaseWrapper(NULL) )
        return FALSE;

    if ( !mb.FInit() ) {
        FCloseMetabaseWrapper();
        return FALSE;
    }
    
    // open the root directory object
    if ( !mb.Open(SZ_MB_DIRGLOBALS_OBJECT) )
        {
        AfxMessageBox( IDS_MetaError );
        FCloseMetabaseWrapper();
        return (DWORD)-1;
        }

    // Get the parameters from the metabase and put them into the dialog
    if ( mb.GetDword( "", MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, &dword ) )
        {
        m_f_browsingallowed = (dword & MD_DIRBROW_ENABLED) > 0;
        m_f_enabledefault = (dword & MD_DIRBROW_LOADDEFAULT) > 0;
        }
    else
        {
        m_f_browsingallowed = FALSE;
        m_f_enabledefault = FALSE;
        }

    // get the default document string
    dword = MAX_PATH;
    if ( mb.GetString( "", MD_DEFAULT_LOAD_FILE, IIS_MD_UT_FILE, buff, &dword ) )
        m_sz_defaultdoc = buff;
    m_szSaved = m_sz_defaultdoc;

    // update the data
    UpdateData( FALSE );

    // enable or disable the default document string as appropriate
    OnEnabledefault();
    // close the metabase object
    mb.Close();
    FCloseMetabaseWrapper();

    m_fApplyingGlobals = FALSE;
    return TRUE;
    }


//-----------------------------------------------------------------
BOOL CAdvancedDlg::FillList()
    {
    CHAR    buff[MAX_PATH];
    DWORD   cbpath;

    CVirtDir*       pDir;

    // prep the mb objcet
    CWrapMetaBase   mb;
    if ( !FInitMetabaseWrapper(NULL) )
        return FALSE;

    if ( !mb.FInit() ) {
        FCloseMetabaseWrapper();
        return FALSE;
    }

    // open the root directory object
    if ( !mb.Open(SZ_MB_ROOTDIR_OBJECT) )
        {
        AfxMessageBox( IDS_MetaError );
        FCloseMetabaseWrapper();
        return (DWORD)-1;
        }

    // create the root <home> directory object
    pDir = new CVirtDir( TRUE );        // true means this is the root
    pDir->m_szAlias.LoadString( IDS_HOME_DIRECTORY );
    pDir->m_szMetaAlias.Empty();
    // get the directory path
    cbpath = MAX_PATH;
    mb.GetString( "", MD_VR_PATH, IIS_MD_UT_FILE, buff, &cbpath);
    pDir->m_szPath = buff;
    // add the item to the list
    AddToDisplayList( pDir );

    // enumerate the directories, adding each to the list
    DWORD index = 0;
    while ( mb.EnumObjects("", buff, index) )
        {
        // create the new directory object
        pDir = new CVirtDir();

        // set the alias
        pDir->m_szAlias = buff;
        pDir->m_szMetaAlias = buff;

        // get the directory path
        cbpath = MAX_PATH;
        if ( !mb.GetString( buff, MD_VR_PATH, IIS_MD_UT_FILE, buff, &cbpath) )
                break;
        pDir->m_szPath = buff;

        // add the item to the list
        AddToDisplayList( pDir );

        // advance the index
        index++;
        }

    // close the metabase object
    mb.Close();
    FCloseMetabaseWrapper();
    return TRUE;
    }

//-----------------------------------------------------------------
void CAdvancedDlg::AddToDisplayList( CVirtDir* pDir )
    {
    CString szErr;
    DWORD   i = m_clistctrl_list.GetSelectedCount();

    // add the item to the end of the list - with the alias text
    i = m_clistctrl_list.InsertItem( i, pDir->m_szAlias, 0 );

    // fill in the directory in the list
    m_clistctrl_list.SetItemText( i, COL_DIRECTORY, pDir->m_szPath );

    // fill in the error string
    pDir->GetErrorStr( szErr );
    m_clistctrl_list.SetItemText( i, COL_ERROR, szErr );

    // attach the object itself to the list as private data.
    m_clistctrl_list.SetItemData( i, (DWORD)pDir );
    }

//-----------------------------------------------------------------
void CAdvancedDlg::EnableDependantButtons()
    {
    CVirtDir*   pDir;

    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();
    // get index of the selected list item
    int iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );

    // get the pDir from the list
    pDir = (CVirtDir*)m_clistctrl_list.GetItemData( iList );
    ASSERT( pDir );

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_change.EnableWindow( TRUE );
        m_cbutton_remove.EnableWindow( !pDir->m_fIsRoot );  // cannot remove the root
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_change.EnableWindow( FALSE );
        m_cbutton_remove.EnableWindow( FALSE );
        }
    }


/////////////////////////////////////////////////////////////////////////////
// CAdvancedDlg message handlers
//---------------------------------------------------------------------------
BOOL CAdvancedDlg::OnInitDialog()
    {
//DebugBreak();
    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // initialize the global parameters
    FInitGlobalParameters();

    // initialize the list
    FInitList();
    FillList();
    EnableDependantButtons();

    // exchange the data
    UpdateData( FALSE );

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::RefreshGlobals()
    {
    UpdateData( TRUE );
    FInitGlobalParameters();
    UpdateData( FALSE );
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::RefreshList()
    {
    // first, delete all the virdir objects referenced by the list
    EmptyOutList();
    // re-fill the list
    FillList();
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnRefresh()
    {
    m_fApplyingGlobals = TRUE;
    RefreshGlobals();
    m_fApplyingGlobals = FALSE;
    RefreshList();
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::EmptyOutList()
    {
    CVirtDir*   pVDir;

    // get the number of elements in the list
    DWORD cItems = m_clistctrl_list.GetItemCount();
    for ( DWORD iItem = 0; iItem < cItems; iItem++ )
        {
        // get the virt dir pointer
        pVDir = (CVirtDir*)m_clistctrl_list.GetItemData( iItem );
        // delete the vit dir
        if ( pVDir )
            delete pVDir;
        }

    // empty the list itself
    m_clistctrl_list.DeleteAllItems();
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnCancel()
    {
    // clean up the list
    EmptyOutList();
    ShowWindow(SW_HIDE);
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnKillfocusDefaultDoc()
    {
    UpdateData( TRUE );
    // apply it to the metabase right-away
    if ( !m_fApplyingGlobals )
        {
        m_fApplyingGlobals = TRUE;
        // apply it to the metabase right-away
        ApplyGlobalParameters();
        RefreshGlobals();
        if ( g_p_FormView )
            g_p_FormView->UpdateDirInfo();
        m_fApplyingGlobals = FALSE;
        }
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnBrowsingAllowed()
    {
    UpdateData( TRUE );
    // apply it to the metabase right-away
    if ( !m_fApplyingGlobals )
        {
        m_fApplyingGlobals = TRUE;
        // apply it to the metabase right-away
        ApplyGlobalParameters();
        RefreshGlobals();
        if ( g_p_FormView )
            g_p_FormView->UpdateDirInfo();
        m_fApplyingGlobals = FALSE;
        }
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnEnabledefault()
    {
    UpdateData( TRUE );
    // enable or disable the default document string as appropriate
    if ( m_f_enabledefault )
        {
        m_sz_defaultdoc = m_szSaved;
        // enable things
        m_cedit_default.EnableWindow( TRUE );
        m_cstatic_default.EnableWindow( TRUE );
        }
    else
        {
        m_szSaved = m_sz_defaultdoc;
        m_sz_defaultdoc.Empty();
        // disable things
        m_cedit_default.EnableWindow( FALSE );
        m_cstatic_default.EnableWindow( FALSE );
        }
    UpdateData( FALSE );
    
    if ( !m_fApplyingGlobals )
        {
        m_fApplyingGlobals = TRUE;
        // apply it to the metabase right-away
        ApplyGlobalParameters();
        RefreshGlobals();
        if ( g_p_FormView )
            g_p_FormView->UpdateDirInfo();
        m_fApplyingGlobals = FALSE;
        }
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
        {
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        *pResult = 0;

        // enable the correct items
        EnableDependantButtons();
        }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnAdd()
    {
    // create the new directory object
    CVirtDir* pDir = new CVirtDir();

        // give the new directory some defaults
        pDir->m_szPath.Empty();
        pDir->m_szAlias.Empty();
        pDir->m_szMetaAlias.Empty();

    // Edit the rule. If it fails, remove it from the list
    if ( pDir->Edit() )
        {
        // save the item to the metabase
        pDir->FSaveToMetabase();
        // refresh the list
        RefreshList();
        }

    // in all cases, delete the pDir object. If it was saved to the metabase,
    // it was picked up again during the refresh
    delete pDir;
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
        {
        *pResult = 0;
        // if something in the list was double clicked, edit it
        if ( m_clistctrl_list.GetSelectedCount() > 0 )
                OnChange();
        }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnChange()
    {
    CVirtDir*       pDir;
    int                     iList;
    CString         szErr;

    // there had better be one selected
    if ( m_clistctrl_list.GetSelectedCount() != 1 )
        return;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // get the pDir from the list
    pDir = (CVirtDir*)m_clistctrl_list.GetItemData( iList );

    // edit the pDir, update it if successful, delete if not
    if ( pDir->Edit() )
        {
        // save the item to the metabase
        pDir->FSaveToMetabase();
        // refresh the list
        RefreshList();
        }
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::OnRemove()
    {
    int         iList;
    CVirtDir*   pDir;

    // there had better be one selected
    if ( m_clistctrl_list.GetSelectedCount() != 1 )
        return;

    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_REMOVE, MB_OKCANCEL) != IDOK )
        return;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // get the pDir from the list
    pDir = (CVirtDir*)m_clistctrl_list.GetItemData( iList );

    // remove the item from the metabase
    pDir->FRemoveFromMetabase();

    // refresh the list
    RefreshList();
    }

//---------------------------------------------------------------------------
void CAdvancedDlg::ApplyGlobalParameters()
    {
    DWORD   dword;
    BOOL    f;

    // prep the mb objcet
    CWrapMetaBase   mb;
    if ( !FInitMetabaseWrapper(NULL) )
        return;

    if ( !mb.FInit() ) {
        FCloseMetabaseWrapper();
        return;
    }

    // open the root directory object
    if ( !mb.Open(SZ_MB_DIRGLOBALS_OBJECT, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) )
        {
        DWORD err = GetLastError();
        CString sz;
        sz.LoadString( IDS_MetaError );
        sz.Format( "%s\nError = %d", sz, err );
        AfxMessageBox( sz );
        FCloseMetabaseWrapper();
        return;
        }

    // to prepare the browsing flag for saving - we must get the current value
    if ( mb.GetDword( "", MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, &dword ) )
        {
        // start by setting or clearing the browsing allowed flag
        if ( m_f_browsingallowed )
            dword |= MD_DIRBROW_ENABLED;        // set the flag
        else
            dword &= ~MD_DIRBROW_ENABLED;       // clear the flag
        
        // next, set or clear the enable default flag
        if ( m_f_enabledefault )
            dword |= MD_DIRBROW_LOADDEFAULT;        // set the flag
        else
            dword &= ~MD_DIRBROW_LOADDEFAULT;       // clear the flag

        // save the browsing flag
        f = mb.SetDword( "", MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, dword );
        }


    // save the default string
    if ( m_f_enabledefault )
        f = mb.SetString( "", MD_DEFAULT_LOAD_FILE, IIS_MD_UT_FILE, (LPCSTR)m_sz_defaultdoc );

    // close the metabase object
    mb.Close();
    FCloseMetabaseWrapper();
    return;
    }

/////////////////////////////////////////////////////////////////////////////
// CVirtDir object - for maintaining the list
//---------------------------------------------------------------------------
CVirtDir::CVirtDir(BOOL bRoot) :
    m_fIsRoot(bRoot)
    {}

    //---------------------------------------------------------------------------
BOOL CVirtDir::FInitAsNew()
    {
    return TRUE;
    }

//---------------------------------------------------------------------------
void CVirtDir::GetErrorStr( CString &sz )
    {
    // see if the specified path is valid
    if ( GetFileAttributes(m_szPath) == 0xFFFFFFFF )
            sz.LoadString( IDS_ERR_PATH_INVALID );
    else
            sz.Empty();
    }

//---------------------------------------------------------------------------
BOOL CVirtDir::Edit()
    {
    CEditDirectory  dlg;
    dlg.pDir = this;
    dlg.m_sz_alias = m_szAlias;
    dlg.m_sz_path = m_szPath;
    if ( dlg.DoModal() == IDOK )
            {
            m_szAlias = dlg.m_sz_alias;
            m_szPath = dlg.m_sz_path;
            return TRUE;
            }
    return FALSE;
    }


//---------------------------------------------------------------------------
BOOL CVirtDir::FSaveToMetabase()
    {
    BOOL    fSuccess = TRUE;
    CString sz;
    DWORD   err;

    // if the alias name has changed, we must first remove the original object
    // from the metabase, then re-add it with the new name
    if ( !m_fIsRoot && (m_szAlias != m_szMetaAlias) )
        {
        fSuccess = FRemoveFromMetabase( FALSE );    // false to not save the metabase
        m_szMetaAlias.Empty();
        if ( !fSuccess ) return FALSE;
        }

    // prep the metabase
    CWrapMetaBase   mb;
    if ( !FInitMetabaseWrapper(NULL) )
        return FALSE;

    if ( !mb.FInit() ) {
        FCloseMetabaseWrapper();
        return FALSE;
    }

    // the first thing we do is open the metabase with WRITE permissions
    // open the metabase object
    if ( !mb.Open(SZ_MB_ROOTDIR_OBJECT, METADATA_PERMISSION_WRITE) )
        {
        err = GetLastError();
        sz.LoadString( IDS_MetaError );
        sz.Format( "%s\nError = %d", sz, err );
        AfxMessageBox( sz );
        FCloseMetabaseWrapper();
        return FALSE;
        }

    // if the object is new, then there is nothing in the metaAlias string.
    // in that case we should start by creating a new object in the metabase
    if ( !m_fIsRoot && m_szMetaAlias.IsEmpty() )
        {
        fSuccess = mb.AddObject( m_szAlias );
        m_szMetaAlias = m_szAlias;
        }

    // now we can save the directory data - but only if the object is there
    if ( fSuccess )     // test the object existence
        {
        fSuccess = mb.SetString( m_szMetaAlias, MD_VR_PATH, IIS_MD_UT_FILE, m_szPath );
        }

    // save the metabase
    mb.Save();

    // close the object
    mb.Close();
    FCloseMetabaseWrapper();

    // if there was an error - say something intelligent
    if ( !fSuccess )
        {
        err = GetLastError();
        sz.LoadString( IDS_MetaError );
        sz.Format( "%s\nError = %d", sz, err );
        AfxMessageBox( sz );
        }

    // return the answer
    return fSuccess;
    }

//---------------------------------------------------------------------------
BOOL CVirtDir::FRemoveFromMetabase( BOOL fSaveMB )
    {
    BOOL    fSuccess = TRUE;
    CString sz;
    DWORD   err;

    // Never remove a root object.
    if ( m_szMetaAlias.IsEmpty() )
        return fSuccess;

    // prep the metabase
    CWrapMetaBase   mb;
    if ( !FInitMetabaseWrapper(NULL) )
        return FALSE;

    if ( !mb.FInit() ) {
        FCloseMetabaseWrapper();
        return FALSE;
    }

    // the first thing we do is open the metabase with WRITE permissions
    // open the metabase object
    if ( !mb.Open(SZ_MB_ROOTDIR_OBJECT, METADATA_PERMISSION_WRITE) )
        {
        err = GetLastError();
        sz.LoadString( IDS_MetaError );
        sz.Format( "%s\nError = %d", sz, err );
        AfxMessageBox( sz );
        FCloseMetabaseWrapper();
        return FALSE;
        }

    // delete the item
    fSuccess = mb.DeleteObject( m_szMetaAlias );

    // save the metabase - if requested
    if ( fSaveMB )
        mb.Save();

    //
    // close the metawrapper
    //

    mb.Close();
    FCloseMetabaseWrapper();
    
    // if there was an error - say something intelligent
    if ( !fSuccess )
        {
        err = GetLastError();
        sz.LoadString( IDS_MetaError );
        sz.Format( "%s\nError = %d", sz, err );
        AfxMessageBox( sz );
        }

    // return the answer
    return fSuccess;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\eddir.cpp ===
// EdDir.cpp : implementation file
//

#include "stdafx.h"
#include "EdDir.h"

#include "mbobjs.h"
#include "resource.h"

#include <shlobj.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditDirectory dialog


CEditDirectory::CEditDirectory(CWnd* pParent /*=NULL*/)
    : CDialog(CEditDirectory::IDD, pParent),
    m_fHome( FALSE ),
    m_fNewItem( FALSE ),
    m_idsTitle( 0 )
    {
    //{{AFX_DATA_INIT(CEditDirectory)
    m_sz_alias = _T("");
    m_sz_path = _T("");
    m_bool_read = FALSE;
    m_bool_source = FALSE;
    m_bool_write = FALSE;
    m_int_AppPerms = -1;
    //}}AFX_DATA_INIT

    m_cedit_path.LoadIllegalChars( IDS_ILLEGAL_PHYS_PATH_CHARS );
    m_cedit_alias.LoadIllegalChars( IDS_ILLEGAL_VIRT_DIR_CHARS );
    }


void CEditDirectory::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditDirectory)
    DDX_Control(pDX, IDC_SOURCE, m_cbtn_source);
    DDX_Control(pDX, IDC_PATH, m_cedit_path);
    DDX_Control(pDX, IDC_ALIAS, m_cedit_alias);
    DDX_Text(pDX, IDC_ALIAS, m_sz_alias);
    DDX_Text(pDX, IDC_PATH, m_sz_path);
    DDX_Check(pDX, IDC_READ, m_bool_read);
    DDX_Check(pDX, IDC_SOURCE, m_bool_source);
    DDX_Check(pDX, IDC_WRITE, m_bool_write);
    DDX_Radio(pDX, IDC_RDO_NONE, m_int_AppPerms);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CEditDirectory, CDialog)
    ON_WM_CONTEXTMENU()
    //{{AFX_MSG_MAP(CEditDirectory)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_READ, OnRead)
    ON_BN_CLICKED(IDC_SOURCE, OnSource)
    ON_BN_CLICKED(IDC_WRITE, OnWrite)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
BOOL CEditDirectory::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // if there is a requested title for the dialog, use it
    if ( m_idsTitle )
        {
        CString szTitle;
        szTitle.LoadString( m_idsTitle );
        SetWindowText( szTitle );
        }

    // if this is the root directory, disable editing of the alias
    if ( m_fHome )
        m_cedit_alias.EnableWindow( FALSE );

    // keep a copy of the original alias for later verification
    m_szOrigAlias = m_sz_alias;

    m_bOldSourceControl = m_bool_source;
    EnableSourceControl();

    // return the answer
    return f;
    }

/////////////////////////////////////////////////////////////////////////////
// CEditDirectory message handlers

//----------------------------------------------------------------
void CEditDirectory::OnBrowse()
    {
    UpdateData( TRUE );

    BROWSEINFO bi;
    LPTSTR lpBuffer;
    LPITEMIDLIST pidlBrowse;    // PIDL selected by user

    // Allocate a buffer to receive browse information.
    lpBuffer = (LPTSTR) GlobalAlloc( GPTR, (MAX_PATH + 1) * sizeof(TCHAR) );
    if ( !lpBuffer )
    {
        return;
    }

    // load the title
    CString szTitle;
    szTitle.LoadString( IDS_CHOOSE_DIR );

    // Fill in the BROWSEINFO structure.
    bi.hwndOwner = this->m_hWnd;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = lpBuffer;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_DONTGOBELOWDOMAIN;
    bi.lpfn = NULL;
    bi.lParam = 0;

    // Browse for a folder and return its PIDL.
    pidlBrowse = SHBrowseForFolder(&bi);
    if (pidlBrowse != NULL)
        {
        // Show the display name, title, and file system path.
        if (SHGetPathFromIDList(pidlBrowse, lpBuffer))
        {
            m_sz_path = lpBuffer;
        }

        // Free the PIDL returned by SHBrowseForFolder.
        GlobalFree(pidlBrowse);

        // put the string back
        UpdateData( FALSE );
        }

    // Clean up.
    GlobalFree( lpBuffer );
    }

//----------------------------------------------------------------
    // we now have to test the physical path that the alias points to
    // 1) it must be a valid path. This prevents dumb users from entering
    // a garbage path. 2) it can't be a redirected hard drive. 3) (I may not
    // get to this part now) it would be nice if it is on a local hard drive
    // but doesn't exist that the user be asked if they want to create
    // the directory. If they say yes, create it.
BOOL CEditDirectory::VerifyDirectoryPath( CString szPath )
    {
    CString     sz;
    DWORD       attrib;

    // first we test the drive to see if it is local or remote
    // but before that we need to get the drive letter
    _tsplitpath( (LPCTSTR)szPath, sz.GetBuffer(_MAX_DRIVE+1), NULL, NULL, NULL );
    sz.ReleaseBuffer();

    // it can't be a unc path
    if ( sz.IsEmpty() )
        {
        AfxMessageBox( IDS_ERR_USE_VALID_DRIVE );
        return FALSE;
        }
    
    // test the drive and only accept valid, non-remote drives
    attrib = GetDriveType( (LPCTSTR)sz );
    if ( (attrib == DRIVE_REMOTE) )
        {
        AfxMessageBox( IDS_ERR_USE_VALID_DRIVE );
        return FALSE;
        }

    // now that we know it is a valid drive, get the attributes of the file
    attrib = GetFileAttributes( szPath );

    // if the directory doesn't exists
    if ( attrib == 0xffffffff )
        {
        CString     szMessage;
        AfxFormatString1( szMessage, IDS_MAKE_DIRECTORY, szPath );
        if ( AfxMessageBox( szMessage, MB_YESNO ) == IDNO )
            return FALSE;

        // create the directory
        if ( !CreateDirectory((LPCTSTR)szPath, NULL) )
            {
            AfxMessageBox( IDS_ERR_MAKE_DIRECTORY );
            return FALSE;
            }

        // reget the attibutes for the final check below
        attrib = GetFileAttributes( szPath );
        }
    
    // if the use chose a file, or something not a directory, tell them no.
    if ( (attrib == 0xffffffff) || ((attrib & FILE_ATTRIBUTE_DIRECTORY) == 0) )
        {
        AfxMessageBox( IDS_ERR_USE_VALID_DIR );
        return FALSE;
        }

    // it is OK
    return TRUE;
    }

//----------------------------------------------------------------
// we need to make sure that there is something in the alias field
// an empty alias is not OK
void CEditDirectory::OnOK()
    {
    UpdateData( TRUE );

    // if write and script or execute is set, it creates a potential security hole.
    // warn the user of this situation before continuing
    if ( m_bool_write && ((m_int_AppPerms==APPPERM_SCRIPTS)||(m_int_AppPerms==APPPERM_EXECUTE)) )
        {
        if ( AfxMessageBox( IDS_WRITEEXECUTE_WARNING, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES )
            return;
        }

    // trim leading and trailing spaces
    m_sz_alias.TrimLeft();
    m_sz_alias.TrimRight();
    m_sz_path.TrimLeft();
    m_sz_path.TrimRight();

    // first test is to see if there is anything in the alias
    if ( m_sz_alias.IsEmpty() )
        {
        AfxMessageBox( IDS_EMPTY_ALIAS );
        return;
        }

    // we now have to test the physical path that the alias points to
    // 1) it must be a valid path. This prevents dumb users from entering
    // a garbage path. 2) it can't be a redirected hard drive. 3) (I may not
    // get to this part now) it would be nice if it is on a local hard drive
    // but doesn't exist that the user be asked if they want to create
    // the directory. If they say yes, create it.
    // VerifyDirectoryPath takes care of any error messages
    if ( !VerifyDirectoryPath(m_sz_path) )
        return;

    // Now we need to make sure that alias isn't already taken
    CString szTestPath = SZ_MB_ROOT;
    szTestPath += m_szMetaPath.Left( m_szMetaPath.ReverseFind('/') + 1 );
    szTestPath += m_sz_alias;

    // if we can open the metabase object, then it is already taken
    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // try to open the object
    // however, if it is not a new object, and the alias has not changed, do not
    // see if the object is there becuase we know that it is and it is ok in this case
    // use a case insensitive compare because thats what the metabase uses
    if ( m_sz_alias.CompareNoCase(m_szOrigAlias) || m_fNewItem )
        {
        if ( mb.Open(szTestPath) )
            {
            // we did open it! Close it right away
            mb.Close();
            // tell the user to pick another name
            CString     szMessage;
            AfxFormatString1( szMessage, IDS_ALIAS_IS_TAKEN, m_sz_alias );
            AfxMessageBox( szMessage );
            return;
            }
        }

    // make sure the string goes back
    UpdateData( FALSE );

    // do the default...
    CDialog::OnOK();
    }

//----------------------------------------------------------------
void CEditDirectory::WinHelp(DWORD dwData, UINT nCmd) 
    {
    CDialog::WinHelp(dwData, nCmd);
    }

/////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
void CEditDirectory::EnableSourceControl()
    {
    // get the currect button values
    UpdateData( TRUE );

    // if both read and write are unchecked, then we clear and disable source control
    if ( !m_bool_read && !m_bool_write )
        {
        // save the value of source control
        m_bOldSourceControl = m_bool_source;

        // clear the source control
        m_bool_source = FALSE;
        UpdateData( FALSE );

        // disable the source control window
        m_cbtn_source.EnableWindow( FALSE );
        }
    else
        {
        // we enable source control
        // disable the source control window
        m_cbtn_source.EnableWindow( TRUE );

        // and set the value back
        m_bool_source = m_bOldSourceControl;
        UpdateData( FALSE );
        }
    }

//----------------------------------------------------------------
void CEditDirectory::OnSource() 
    {
    // get the currect button values
    UpdateData( TRUE );
    // save the value of source control
    m_bOldSourceControl = m_bool_source;
    }

//----------------------------------------------------------------
void CEditDirectory::OnRead() 
    {
    EnableSourceControl();
    }

//----------------------------------------------------------------
void CEditDirectory::OnWrite() 
    {
    EnableSourceControl();
    }

/////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
void CVDEdit::LoadIllegalChars( int idChars )
    {
    szExclude.LoadString( idChars );
    }

//----------------------------------------------------------------
BOOL CVDEdit::OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
    {
    // if it is a character
    if ( message == WM_CHAR )
        {
        TCHAR chCharCode = (TCHAR)wParam;

        // test for bad or control characters
        if (_tcschr(szExclude, chCharCode))
            {
            MessageBeep(0);
            return 1;
            }
        }

    // return the default answer
    return CEdit::OnWndMsg( message, wParam, lParam, pResult);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\eddir.h ===
// EdDir.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// CDNEdit

class CVDEdit : public CEdit
    {
    public:
        void LoadIllegalChars( int idChars );

    protected:
        virtual BOOL OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
        CString szExclude;
    };

/////////////////////////////////////////////////////////////////////////////
// CEditDirectory dialog

class CEditDirectory : public CDialog
{
// Construction
public:

    enum {
        APPPERM_NONE = 0,
        APPPERM_SCRIPTS,
        APPPERM_EXECUTE
        };

    CEditDirectory(CWnd* pParent = NULL);   // standard constructor
    virtual BOOL OnInitDialog();

    // flag to saw if we are editing the root directory
    BOOL    m_fHome;

    // flag to indicate that this is a new item
    BOOL    m_fNewItem;

    // string resource id for the dialog title - if 0, uses the default
    INT     m_idsTitle;

    // path of the directory in the metabase - used to make sure the
    // new alias does not step on some existing alias in the metabase
    CString m_szMetaPath;

// Dialog Data
    //{{AFX_DATA(CEditDirectory)
    enum { IDD = IDD_DIRECTORY };
    CButton m_cbtn_source;
    CVDEdit m_cedit_path;
    CVDEdit m_cedit_alias;
    CString m_sz_alias;
    CString m_sz_path;
    BOOL    m_bool_read;
    BOOL    m_bool_source;
    BOOL    m_bool_write;
    int     m_int_AppPerms;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEditDirectory)
    public:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CEditDirectory)
    afx_msg void OnBrowse();
    virtual void OnOK();
    afx_msg void OnRead();
    afx_msg void OnSource();
    afx_msg void OnWrite();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // place holder to store the old value of the source control option
    BOOL        m_bOldSourceControl;

    BOOL VerifyDirectoryPath( CString szPath );
    void EnableSourceControl();

    // keep a copy of the original alias for later verification
    CString     m_szOrigAlias;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\formadv.cpp ===
// FormAdv.cpp : implementation file
//

#include "stdafx.h"
#include "pwsform.h"
#include <inetcom.h>
#include "mbobjs.h"

#include "Title.h"
#include "Sink.h"
#include "pwsdoc.h"
#include "EdDir.h"
#include "FormAdv.h"
#include "resource.h"

#include <iwamreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// the key type string for the virtual directories
#define MDSZ_W3_VDIR_TYPE                       _T("IIsWebVirtualDir")

#define WIDE_MAX_PATH                           ( MAX_PATH * sizeof(WCHAR) )

// tree view icons
enum {
    IMAGE_GOOD_FOLDER = 0,
    IMAGE_SERVER,
    IAMGE_BAD_FOLDER
    };

#define         WM_UPDATE_VITRUAL_TREE          WM_USER


CFormAdvanced*          g_FormAdv = NULL;
extern CPwsDoc*         g_p_Doc;
extern CPWSForm*        g_pCurrentForm;

/////////////////////////////////////////////////////////////////////////////
// CFormAdvanced

IMPLEMENT_DYNCREATE(CFormAdvanced, CFormView)

//------------------------------------------------------------------------
CFormAdvanced::CFormAdvanced()
    : CPWSForm(CFormAdvanced::IDD),
    m_hRoot( NULL ),
    m_DirHelpID( 0 )
    {
    //{{AFX_DATA_INIT(CFormAdvanced)
    m_sz_default_doc = _T("");
    m_bool_allow_browsing = FALSE;
    m_bool_enable_default = FALSE;
    m_bool_save_log = FALSE;
    //}}AFX_DATA_INIT
    }

//------------------------------------------------------------------------
CFormAdvanced::~CFormAdvanced()
    {
    g_FormAdv = NULL;
    }

//------------------------------------------------------------------------
void CFormAdvanced::DoDataExchange(CDataExchange* pDX)
    {
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFormAdvanced)
    DDX_Control(pDX, IDC_REMOVE, m_cbtn_remove);
    DDX_Control(pDX, IDC_TITLE_BAR, m_ctitle_title);
    DDX_Control(pDX, IDC_TREE, m_ctreectrl_tree);
    DDX_Control(pDX, IDC_DEFAULT_TITLE, m_csz_default_doc_title);
    DDX_Control(pDX, IDC_DEFAULT_DOC, m_csz_default_doc);
    DDX_Text(pDX, IDC_DEFAULT_DOC, m_sz_default_doc);
    DDX_Check(pDX, IDC_DIR_BROWSE, m_bool_allow_browsing);
    DDX_Check(pDX, IDC_ENABLE_DEFAULT, m_bool_enable_default);
    DDX_Check(pDX, IDC_SAVE_LOG, m_bool_save_log);
    //}}AFX_DATA_MAP
    }


//------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CFormAdvanced, CFormView)
    ON_WM_CONTEXTMENU()
    //{{AFX_MSG_MAP(CFormAdvanced)
    ON_EN_KILLFOCUS(IDC_DEFAULT_DOC, OnKillfocusDefaultDoc)
    ON_BN_CLICKED(IDC_ENABLE_DEFAULT, OnEnableDefault)
    ON_BN_CLICKED(IDC_DIR_BROWSE, OnDirBrowse)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_TREE, OnDblclkTree)
    ON_BN_CLICKED(IDC_SAVE_LOG, OnSaveLog)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_COMMAND(ID_ADD_VIRT, OnAddVirt)
    ON_UPDATE_COMMAND_UI(ID_ADD_VIRT, OnUpdateAddVirt)
    ON_COMMAND(ID_PROPERTIES_VIRT, OnPropertiesVirt)
    ON_UPDATE_COMMAND_UI(ID_PROPERTIES_VIRT, OnUpdatePropertiesVirt)
    ON_UPDATE_COMMAND_UI(ID_DELETE_VIRT, OnUpdateDeleteVirt)
    ON_COMMAND(ID_DELETE_VIRT, OnDeleteVirt)
    ON_UPDATE_COMMAND_UI(ID_BROWSE_VIRT, OnUpdateBrowseVirt)
    ON_COMMAND(ID_BROWSE_VIRT, OnBrowseVirt)
    ON_UPDATE_COMMAND_UI(ID_EXPLORE_VIRT, OnUpdateExploreVirt)
    ON_COMMAND(ID_EXPLORE_VIRT, OnExploreVirt)
    ON_UPDATE_COMMAND_UI(ID_OPEN_VIRT, OnUpdateOpenVirt)
    ON_COMMAND(ID_OPEN_VIRT, OnOpenVirt)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_NOTIFY(TVN_SELCHANGED, IDC_TREE, OnSelchangedTree)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFormAdvanced diagnostics

#ifdef _DEBUG
void CFormAdvanced::AssertValid() const
    {
    CFormView::AssertValid();
    }

void CFormAdvanced::Dump(CDumpContext& dc) const
    {
    CFormView::Dump(dc);
    }
#endif //_DEBUG


//------------------------------------------------------------------------
// initialize the trees - done once
void CFormAdvanced::InitTree()
    {
    // prepare the list's image list
    if ( m_imageList.Create( IDB_LIST_IMAGES, 17, 5, 0x00FF00FF ) )
        // set the image list into the list control
        m_ctreectrl_tree.SetImageList( &m_imageList, TVSIL_NORMAL );
    }

//------------------------------------------------------------------------
// empty all the items out of the tree
void CFormAdvanced::EmptyTree()
    {
    m_ctreectrl_tree.DeleteAllItems();
    m_hRoot = NULL;
    }

//------------------------------------------------------------------------
// given an item in the tree, build its relative metabase path
void CFormAdvanced::BuildMetaPath( HTREEITEM hItem, CString &sz )
    {
    // clear the path to start with
    sz.Empty();
     // keep building as long as this is not the root node
    while( hItem != m_hRoot )
        {
        // since we are working backwards, add the nodes to the front of the string
        sz = m_ctreectrl_tree.GetItemText( hItem ) + sz;

        // move up a level to the parent
        hItem = m_ctreectrl_tree.GetParentItem( hItem );
        }
   }

//------------------------------------------------------------------------
BOOL CFormAdvanced::FIsVirtualDirectoryValid( CWrapMetaBase *pmb, CString szRelPath )
    {
    CString sz;
    BOOL    fAnswer = FALSE;

    // we need to load the virtual directory path and see if it really exists
    // and thus show the appropriate image
    fAnswer = pmb->GetString( 
        szRelPath, 
        MD_VR_PATH, 
        IIS_MD_UT_FILE, 
        sz.GetBuffer(WIDE_MAX_PATH), 
        WIDE_MAX_PATH, 
        METADATA_INHERIT
        );

    sz.ReleaseBuffer();

    if ( fAnswer )
        {
        fAnswer = FALSE;
        DWORD dwAttrib = GetFileAttributes( sz );
        // it can't be an error and the directory flag must be set
        if ( (dwAttrib != 0xFFFFFFFF) && 
            ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) != 0) )
            fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }

//------------------------------------------------------------------------
// set the appropriate tree image for a given item
void CFormAdvanced::SetTreeImage( CWrapMetaBase *pmb, CString szRelPath, HTREEITEM hItem )
    {
    BOOL    f;
    int     iTreeImage;

    // we need to load the virtual directory path and see if it really exists
    // and thus show the appropriate image
    if ( FIsVirtualDirectoryValid( pmb, szRelPath ) )
        iTreeImage = IMAGE_GOOD_FOLDER;
    else
        iTreeImage = IAMGE_BAD_FOLDER;

    // set the image
    f = m_ctreectrl_tree.SetItemImage( hItem, iTreeImage, iTreeImage );
    }

//------------------------------------------------------------------------
// write out item data
void CFormAdvanced::WriteItemData( CWrapMetaBase *pmb, CString szRelPath, CEditDirectory *pdlg )
    {
    DWORD   dword;
    BOOL    f;

     // set the path into place
    f = pmb->SetString( szRelPath, MD_VR_PATH, IIS_MD_UT_FILE, (LPCTSTR)pdlg->m_sz_path );

    // put the access flags into place. There are other flags than the ones that are manupulated
    // here, so be careful to read the value first, then flip the flags, then write it back
    dword = 0;
    pmb->GetDword( szRelPath, MD_ACCESS_PERM, IIS_MD_UT_FILE, &dword, METADATA_INHERIT );

    // read permissions
    if ( pdlg->m_bool_read )
        dword |= MD_ACCESS_READ;        // set the flag
    else
        dword &= ~MD_ACCESS_READ;       // clear the flag

    // write permissions
    if ( pdlg->m_bool_write )
        dword |= MD_ACCESS_WRITE;           // set the flag
    else
        dword &= ~MD_ACCESS_WRITE;          // clear the flag

    // read source permissions
    if ( pdlg->m_bool_source )
        dword |= MD_ACCESS_SOURCE;      // set the flag
    else
        dword &= ~MD_ACCESS_SOURCE;     // clear the flag

    // since the app permissions are now a set of radio buttons, use a case to discern
    switch ( pdlg->m_int_AppPerms )
        {
        case CEditDirectory::APPPERM_NONE:
            dword &= ~MD_ACCESS_SCRIPT;     // clear the flag
            dword &= ~MD_ACCESS_EXECUTE;    // clear the flag
            break;
        case CEditDirectory::APPPERM_SCRIPTS:
            dword |= MD_ACCESS_SCRIPT;      // set the flag
            dword &= ~MD_ACCESS_EXECUTE;    // clear the flag
            break;
        case CEditDirectory::APPPERM_EXECUTE:
            dword |= MD_ACCESS_SCRIPT;      // set the flag
            dword |= MD_ACCESS_EXECUTE;     // set the flag
            break;
        };
    
    // write the dword back into the metabase
    f = pmb->SetDword( szRelPath, MD_ACCESS_PERM, IIS_MD_UT_FILE, dword );
    }

//------------------------------------------------------------------------
// edit the selected item in the tree (calls EditTreeItem)
void CFormAdvanced::EditSelectedItem()
    {
    CString     szRelativePath;
    CString     szOrigAlias;
    BOOL        f;
    DWORD       err;
    DWORD       dword;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // start by building the relative path name from the root node
    HTREEITEM   hItemEdit = m_ctreectrl_tree.GetSelectedItem();

    // build the path
    BuildMetaPath( hItemEdit, szRelativePath );

    // prepare the edit dialog
    CEditDirectory  dlg;

    // if this is the home directory - let it know
    if ( hItemEdit == m_hRoot )
        {
        dlg.m_fHome = TRUE;
        dlg.m_sz_alias.LoadString( IDS_HOME_DIRECTORY );
        }
    else
        {
        dlg.m_fHome = FALSE;
        szOrigAlias = m_ctreectrl_tree.GetItemText( hItemEdit );
        // get rid of the preceding '/' character
        szOrigAlias = szOrigAlias.Right( szOrigAlias.GetLength() - 1 );
        dlg.m_sz_alias = szOrigAlias;
        }

    // tell the edit dialog where this alias goes
    dlg.m_szMetaPath = szRelativePath;

    // now load in the directory path from the metabase
    // go for the root directory first
    if ( mb.Open(SZ_MB_ROOT) )
        {
        CString    sz;
        f = mb.GetString( 
            szRelativePath, 
            MD_VR_PATH, 
            IIS_MD_UT_FILE,
            sz.GetBuffer(WIDE_MAX_PATH), 
            WIDE_MAX_PATH, 
            METADATA_INHERIT
            );

        sz.ReleaseBuffer();
        if ( f )
            {
            dlg.m_sz_path = sz;
            }

        // now prep the access permisions
        if ( mb.GetDword( szRelativePath, MD_ACCESS_PERM, IIS_MD_UT_FILE, &dword, METADATA_INHERIT ) )
            {
            // break the flags out into the dialog items
            dlg.m_bool_read = (dword & MD_ACCESS_READ) > 0;
            dlg.m_bool_write = (dword & MD_ACCESS_WRITE) > 0;
            dlg.m_bool_source = (dword & MD_ACCESS_SOURCE) > 0;

            // application permissions are a set of radio buttons, so break it out that way
            dlg.m_int_AppPerms = CEditDirectory::APPPERM_NONE;
            if ( dword & MD_ACCESS_EXECUTE )
                {
                dlg.m_int_AppPerms = CEditDirectory::APPPERM_EXECUTE;
                }
            else if ( dword & MD_ACCESS_SCRIPT )
                {
                dlg.m_int_AppPerms = CEditDirectory::APPPERM_SCRIPTS;
                }
            }

        // close the metabase object
        mb.Close();
        }

    // now edit the item
    if ( dlg.DoModal() == IDOK )
        {
        // remove the WAM application - recoverable
        CString szWAMLocation;
        szWAMLocation = SZ_MB_ROOT;
        szWAMLocation += szRelativePath;
        BOOL fWAM = MakeWAMApplication( szWAMLocation, FALSE, TRUE, FALSE );

        // write out the directory information
        if ( mb.Open(SZ_MB_ROOT, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE) )
            {
            // write out the data
            WriteItemData( &mb, szRelativePath, &dlg );

            // update the tree image
            SetTreeImage( &mb, szRelativePath, hItemEdit );

            // if this is not the root - AND the alias has changed, rename the object in the metabase
            // DO THIS LAST!! becuase it actually changes the metabase path
            if ( (hItemEdit != m_hRoot) && (dlg.m_sz_alias != szOrigAlias) )
                {
                CString    szNew = szRelativePath;

                // truncate off the last part of the name
                szNew = szNew.Left( szNew.ReverseFind(_T('/')) + 1 );
                // add on the new name
                szNew += dlg.m_sz_alias;

                // rename the key in the metabase
                f = mb.RenameObject( szRelativePath, dlg.m_sz_alias );

                if ( !f )
                    err = GetLastError();

                // build the display name
                CString szName = '/';
                szName += dlg.m_sz_alias;

                // rename the item in the tree view with the display name
                m_ctreectrl_tree.SetItemText( hItemEdit, szName );
                }

            // close the metabase object
            mb.Close();
            }

        // recover the WAM application
        if ( fWAM )
            {
            // build the path
            BuildMetaPath( hItemEdit, szRelativePath );
            // set the WAM app
            szWAMLocation = SZ_MB_ROOT;
            szWAMLocation += szRelativePath;
            MakeWAMApplication( szWAMLocation, TRUE, TRUE, FALSE );
            }
        }
    }

/////////////////////////////////////////////////////////////////////////////
// Update info from the metabase

 //------------------------------------------------------------------------
// recursively add all the items to the tree
void CFormAdvanced::RecurseAddVDItems( CWrapMetaBase* pmb, LPCTSTR szMB, HTREEITEM hParent )
    {
    CString         szEnum;
    CString         szMBPath;
    HTREEITEM       hItem;
    DWORD           index = 0;

    // enumerate the sub-directories of the open directory and add them
    // to the tree. Recurse each to add its children as well
    // enumerate the directories, adding each to the list
    while ( pmb->EnumObjects(szMB, szEnum.GetBuffer(WIDE_MAX_PATH), WIDE_MAX_PATH, index) )
        {
        szEnum.ReleaseBuffer();

        // build the display name for this item
        szMBPath = _T('/');
        szMBPath += szEnum;

        // add the item to the tree
        hItem = m_ctreectrl_tree.InsertItem( szMBPath, hParent, TVI_SORT );

        // build the metabase path for this item
        szMBPath = szMB;
        szMBPath += _T('/');
        szMBPath += szEnum;

        // we need to load the virtual directory path and see if it really exists
        // and thus show the appropriate image
        SetTreeImage( pmb, szMBPath, hItem );

        // recurse the item
        RecurseAddVDItems( pmb, szMBPath, hItem );

        // advance the index
        index++;
        }
    szEnum.ReleaseBuffer();

    // expand the parent
    m_ctreectrl_tree.Expand( hParent, TVE_EXPAND );
    }


//------------------------------------------------------------------------
// to rebuild the tree, first we add the homedirectory and open the metabase
// at that location. Then we recursively add all the subdirectories
void CFormAdvanced::UpdateVirtualTree()
    {
    BOOL f;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // go for the root directory first
    if ( mb.Open(SZ_MB_ROOT) )
        {
        // prep the home directory name
        CString szHome;
        szHome.LoadString( IDS_HOME_DIRECTORY );

        // insert the root item into the tree
        m_hRoot = m_ctreectrl_tree.InsertItem( szHome );
        f = m_ctreectrl_tree.SetItemImage( m_hRoot, IMAGE_SERVER, IMAGE_SERVER );

        // do the recursive adding thing
        RecurseAddVDItems( &mb, _T(""), m_hRoot );

        // close the metabase object
        mb.Close();
        }
    }

//------------------------------------------------------------------------
// update the default document info from the metabase
void CFormAdvanced::UpdateBrowseInfo()
    {
    DWORD       dword;
    PWCHAR      pBuff;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // get ready
    UpdateData( TRUE );

    // go for the root directory first
    if ( mb.Open(SZ_MB_ROOT) )
        {
        // first, the default directory string. Because this is a comma-list, it could get rather long.
        // thus, instead of reading it into a static buffer, we should get it into a allocated one, read
        // the string, and clean up
        pBuff = (PWCHAR)mb.GetData( 
            _T(""), 
            MD_DEFAULT_LOAD_FILE, 
            IIS_MD_UT_FILE, 
            STRING_METADATA, 
            &dword 
            );

        if ( !pBuff )
            {
            DWORD err = GetLastError( );
            if ( err == RPC_E_SERVERCALL_RETRYLATER )
                {
                // we should try again later
                PostMessage( WM_UPDATE_BROWSEINFO );
                mb.Close();
                return;
                }
            }
        if ( pBuff )
            {
            m_sz_default_doc = pBuff;
            // clean up
            mb.FreeWrapData(pBuff); 
            }
        else
            {
            m_sz_default_doc.Empty();
            }

        // now the dword representing the boolean flags
        if ( mb.GetDword( 
            _T(""), 
            MD_DIRECTORY_BROWSING, 
            IIS_MD_UT_FILE, 
            &dword, 
            METADATA_INHERIT 
            ))
        {
            m_bool_allow_browsing = (dword & MD_DIRBROW_ENABLED) > 0;
            m_bool_enable_default = (dword & MD_DIRBROW_LOADDEFAULT) > 0;
        }

        // close the metabase object
        mb.Close();
        }

    // put the answers back
    UpdateData( FALSE );

    // enable the default doc items as appropriate
    EnableItems();
    }

//------------------------------------------------------------------------
// update the save log info from the metabase
void CFormAdvanced::UpdateSaveLog()
    {
    DWORD       dword;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // get ready
    UpdateData( TRUE );

    // open for the root key
    if ( mb.Open(MB_SERVER_KEY_UPDATE) )
        {
        // get the dword representing log type
        if ( mb.GetDword( _T(""), MD_LOG_TYPE, IIS_MD_UT_SERVER, &dword, METADATA_INHERIT ) )
            {
            m_bool_save_log = (dword == INET_LOG_TO_FILE) || (dword == INET_LOG_TO_SQL);
            }

        // close the metabase object
        mb.Close();
        }

    // put the data into place
    UpdateData( FALSE );
    }

//------------------------------------------------------------------------
void CFormAdvanced::EnableItems()
    {
    UpdateData(TRUE);

    // enable the default document windows as necessary
    m_csz_default_doc_title.EnableWindow( m_bool_enable_default );
    m_csz_default_doc.EnableWindow( m_bool_enable_default );

    // if the root is selected, disable the remove button
    // get the handle of the selected item in the tree
    HTREEITEM   hItem = m_ctreectrl_tree.GetSelectedItem();
    m_cbtn_remove.EnableWindow( (hItem != m_hRoot) );
    }

/////////////////////////////////////////////////////////////////////////////
// Write info to the metabase


//------------------------------------------------------------------------
// Write the default document & browsing info to the metabase
void CFormAdvanced::SaveBrowseInfo()
    {
    DWORD       dword;
    BOOL        f;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // write out the correct data
    UpdateData( TRUE );

    // go for the root directory first
    if ( mb.Open(SZ_MB_ROOT, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE) )
        {
        // first, write out the boolean flags
        // to prepare the browsing flag for saving - we must get the current value
        if ( mb.GetDword( _T(""), MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, &dword ) )
            {
            // start by setting or clearing the browsing allowed flag
            if ( m_bool_allow_browsing )
                dword |= MD_DIRBROW_ENABLED;        // set the flag
            else
                dword &= ~MD_DIRBROW_ENABLED;       // clear the flag
        
            // next, set or clear the enable default flag
            if ( m_bool_enable_default )
                dword |= MD_DIRBROW_LOADDEFAULT;        // set the flag
            else
                dword &= ~MD_DIRBROW_LOADDEFAULT;       // clear the flag

            // save the browsing flag
            f = mb.SetDword( _T(""), MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, dword );
            }

        // if the default file is enabled, then write it out too
        if ( m_bool_enable_default )
            f = mb.SetString( _T(""), MD_DEFAULT_LOAD_FILE, IIS_MD_UT_FILE, (LPCTSTR)m_sz_default_doc );

        // close the metabase object
        mb.Close();
        }
    }

//------------------------------------------------------------------------
// Write the save log info to the metabase
void CFormAdvanced::SaveSaveLog()
    {
     DWORD       dword;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // get ready
    UpdateData( TRUE );

    // open for the root key
    if ( mb.Open(MB_SERVER_KEY_UPDATE, METADATA_PERMISSION_WRITE) )
        {
        if ( m_bool_save_log )
            dword = INET_LOG_TO_FILE;
        else
            dword = INET_LOG_DISABLED;

        // write out the flag
        mb.SetDword( _T(""), MD_LOG_TYPE, IIS_MD_UT_SERVER, dword );

        // close the metabase object
        mb.Close();
        }

    // put the data into place
    UpdateData( FALSE );
   }


/////////////////////////////////////////////////////////////////////////////
// CFormAdvanced message handlers

//------------------------------------------------------------------------
void CFormAdvanced::OnInitialUpdate()
    {
    CFormView::OnInitialUpdate();

    // initialize the VD tree
    InitTree();

    // update the virtural directory tree
    UpdateVirtualTree();

    // update the directory browsing related information
    UpdateBrowseInfo();

    // update the logging information
    UpdateSaveLog();

    // let the sink object know we are here
    g_FormAdv = this;
    g_pCurrentForm = this;
    }

//------------------------------------------------------------------------
void CFormAdvanced::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
    {
    // do the appropriate action based on the type of change
    if ( (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT) ||
        (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT) ||
        (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_RENAME_OBJECT) )
        {
        PostMessage( WM_UPDATE_TREEINFO );
        }
    else if ( pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
        // we are only concerned with changes in the state of the server here
        // thus, we can just look for the MD_SERVER_STATE id
        for ( DWORD iElement = 0; iElement < dwMDNumElements; iElement++ )
            {
            // each change has a list of IDs...
            for ( DWORD iID = 0; iID < pcoChangeList[iElement].dwMDNumDataIDs; iID++ )
                {
                // look for the ids that we are interested in
                switch( pcoChangeList[iElement].pdwMDDataIDs[iID] )
                    {
                    case MD_DIRECTORY_BROWSING:
                    case MD_DEFAULT_LOAD_FILE:
                        PostMessage( WM_UPDATE_BROWSEINFO );
                        break;

                    case MD_LOG_TYPE:
                            PostMessage( WM_UPDATE_LOGINFO );
                        break;
                    default:
                        // do nothing
                        break;
                    };
                }
            }
        }
   }

 //------------------------------------------------------------------------
LRESULT CFormAdvanced::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
    {
    // process the update message
    switch( message )
        {
        case WM_UPDATE_BROWSEINFO:
            UpdateBrowseInfo();
            break;
        case WM_UPDATE_LOGINFO:
            break;
        case WM_UPDATE_TREEINFO:
            EmptyTree();
            UpdateVirtualTree();
            break;
        };

    // do the normal thing
    return CFormView::WindowProc(message, wParam, lParam);
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnKillfocusDefaultDoc()
    {
    // write out the change to the metabase
    SaveBrowseInfo();
    // also, make sure we are showing the latest info
    UpdateBrowseInfo();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnEnableDefault()
    {
    // write out the change to the metabase
    SaveBrowseInfo();
    // also, make sure we are showing the latest info
    UpdateBrowseInfo();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnDirBrowse()
    {
    // write out the change to the metabase
    SaveBrowseInfo();
    // also, make sure we are showing the latest info
    UpdateBrowseInfo();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnSaveLog()
    {
    // write out the change to the metabase
    SaveSaveLog();
    // also, make sure we are showing the latest info
    UpdateSaveLog();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnEdit()
    {
    // prep the help
    m_DirHelpID = IDD_DIRECTORY;
    EditSelectedItem();
    m_DirHelpID = 0;
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnDblclkTree(NMHDR* pNMHDR, LRESULT* pResult)
    {
    m_DirHelpID = IDD_DIRECTORY;
    EditSelectedItem();
    m_DirHelpID = 0;
    *pResult = 1;
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnAdd()
    {
    HTREEITEM   hItem;
    BOOL        fSuccess = FALSE;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // get the parent of the item
    HTREEITEM   hParent = m_ctreectrl_tree.GetSelectedItem();

    // build a path going to the parent - then add on one more /
    CString szRelativePath;
    BuildMetaPath( hParent, szRelativePath );
    szRelativePath += _T('/');

    // start by editing a set of default values
    CEditDirectory  dlg;
    dlg.m_sz_alias.LoadString( IDS_DEF_ALIAS );
    dlg.m_bool_read = TRUE;
    dlg.m_bool_write = FALSE;
    dlg.m_bool_source = FALSE;
    dlg.m_int_AppPerms = CEditDirectory::APPPERM_SCRIPTS;
    dlg.m_szMetaPath = szRelativePath;
    dlg.m_fNewItem = TRUE;

    // tell the dialog to use the add directory title
    dlg.m_idsTitle = IDS_ADD_DIRECTORY;

    // prep the help
    m_DirHelpID = 0x0504;

    // if the user edits and says OK, then make the item and add it in and all that
    if ( dlg.DoModal() == IDOK )
        {
        // the WAM stuff can take a few seconds so...
        CWaitCursor waitcursor;

        // where to put this new item in the tree??
        // if there is no selected item, default to the root
        if ( !hParent )
            hParent = m_hRoot;

        // add on the new child to the relative path
        szRelativePath += dlg.m_sz_alias;

        // open the metabase
        if ( mb.Open(SZ_MB_ROOT, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE) )
            {
            // add the object to the metabase
            if ( mb.AddObject( szRelativePath ) )
                {
                // so far, so good
                fSuccess = TRUE;

                // set the key type
                mb.SetString( szRelativePath, MD_KEY_TYPE, IIS_MD_UT_SERVER, MDSZ_W3_VDIR_TYPE, 0 );

                // write out the object's data
                WriteItemData( &mb, szRelativePath, &dlg );

                // build the display name
                CString szName = _T('/');
                szName += dlg.m_sz_alias;

                // add the item to the tree
                hItem = m_ctreectrl_tree.InsertItem( szName, hParent, TVI_SORT );
                SetTreeImage( &mb, szRelativePath, hItem );
                }

            // close the metabase object
            mb.Close();

            // create the WAM application at the new virtual directory location
            if ( fSuccess )
                {
                CString szWAMLocation;
                szWAMLocation = SZ_MB_ROOT;
                szWAMLocation += szRelativePath;
                if ( !MakeWAMApplication( szWAMLocation, TRUE ) )
                    {
                    // it failed to create the WAM application, but we require it.
                    fSuccess = FALSE;

                    // remove the virtual directory
                    // open the metabase
                    if ( mb.Open(SZ_MB_ROOT, METADATA_PERMISSION_WRITE) )
                        {
                        // remove the object from the metabase
                        mb.DeleteObject( szRelativePath );
                        }
                    }
                }

            }

        // make sure the parent is expanded
        m_ctreectrl_tree.Expand( hParent, TVE_EXPAND );

        // if it failed, put up an alert to that affect
        if ( !fSuccess )
            AfxMessageBox( IDS_ERR_ADD_VIRT );
        }

    // unprep the help
    m_DirHelpID = 0;
    }

//------------------------------------------------------------------------
// This routine takes a path to a virutal directory in the metabase and creates
// a WAM application there. Most of the code is actually obtaining and maintaining
// the interface to the WAM ole object
// szPath       The path to the metabase
// fCreate      True if creating an application, FALSE if deleting an existing app
BOOL CFormAdvanced::MakeWAMApplication( IN CString &szPath, IN BOOL fCreate, IN BOOL fRecover, IN BOOL fRecurse )
    {
    IClassFactory*      pcsfFactory = NULL;
    IWamAdmin2*         pWAM;
    HRESULT             hresError;
    BOOL                fAnswer = FALSE;

    hresError = CoGetClassObject( CLSID_WamAdmin, CLSCTX_SERVER, NULL,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
        return FALSE;

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin2, (void **)&pWAM);
    if (FAILED(hresError))
        return FALSE;

    // release the factory
    pcsfFactory->Release();

    // this part will be nicer after it is converted to unicode
    WCHAR* pwch;
    // allocate the name buffer
    pwch = new WCHAR[szPath.GetLength() + 2];
    if ( !pwch )
        {
        pWAM->Release();
        return FALSE;
        }

    // unicodize the name into the buffer
    if ( pwch )
        {

#ifdef _UNICODE
        lstrcpy(pwch, szPath);
#else
        MultiByteToWideChar( 
            CP_ACP, 
            MB_PRECOMPOSED, 
            szPath, 
            -1,
            pwch, 
            szPath.GetLength() + 1 
            );

#endif // _UNICODE


        // create the in-proc application, if requested
        if ( fCreate )
            {
            if ( fRecover )
                hresError = pWAM->AppRecover( pwch, fRecurse );
            else
                hresError = pWAM->AppCreate2( pwch, eAppRunOutProcInDefaultPool );
            }
        else
            {
            // delete the application. Because the whole virtual dir is going away,
            // delete any applications lower down in the tree as well
            if ( fRecover )
                hresError = pWAM->AppDeleteRecoverable( pwch, fRecurse );
            else
                hresError = pWAM->AppDelete( pwch, fRecurse );
            }

        // check the error code
        fAnswer = SUCCEEDED( hresError );

        // clean up
        delete pwch;
        }

    // release the logging ui
    pWAM->Release();

    // return the answer
    return fAnswer;
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnRemove()
    {
    BOOL    fSuccess = FALSE;

    // get the handle of the selected item in the tree
    HTREEITEM   hItem = m_ctreectrl_tree.GetSelectedItem();
    // make sure its not the root
    if ( hItem == m_hRoot ) return;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // get the name of the item
    CString sz;
    CString szItem = m_ctreectrl_tree.GetItemText( hItem );

    // munge the name into the confirm string
    AfxFormatString1( sz, IDS_CONFIRM_REMOVE, szItem );

    // ask the user if the really want to do this
    if ( AfxMessageBox( sz, MB_YESNO ) == IDYES )
        {
        CString szRelativePath;

        // the WAM stuff can take a few seconds so...
        CWaitCursor waitcursor;

        // build the item's relative path in the metabase
        BuildMetaPath( hItem, szRelativePath );

        // delete the WAM application at the virtual directory location
        CString szWAMLocation;
        szWAMLocation = SZ_MB_ROOT;
        szWAMLocation += szRelativePath;
        fSuccess = MakeWAMApplication( szWAMLocation, FALSE );

        // open the metabase
        if ( fSuccess && mb.Open(SZ_MB_ROOT, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE) )
            {
            // remove the item from the metabase
            HRESULT hresError = mb.DeleteObject( szRelativePath );
            // check the error code
            fSuccess = SUCCEEDED( hresError );

            // close the metabase object
            mb.Close();
            }

        // remove the item from the tree
        m_ctreectrl_tree.DeleteItem( hItem );

        // if we did not succeed, tell the user
        if ( !fSuccess )
            AfxMessageBox( IDS_ERR_REMOVE_VIRT );
        }
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnContextMenu(CWnd* pWnd, CPoint point)
    {
    UINT    idMenu;
    UINT    flags;


    // first, we need to convert the point from form coordinates, to tree coordinates
    CPoint  ptTree = point;
    ::ScreenToClient( m_ctreectrl_tree.m_hWnd, &ptTree );

    // get the tree item that has been right-clicked on
    HTREEITEM hHitItem = m_ctreectrl_tree.HitTest( ptTree, &flags );

    // if we didn't hit an item, leave
    if ( !hHitItem )
        return;

    // quick, make sure it is selected - if it isn't - select it
    if ( m_ctreectrl_tree.GetSelectedItem() != hHitItem )
        {
        m_ctreectrl_tree.Select( hHitItem, TVGN_CARET );
        }

    // show the appropriate menu based on the selection
    if ( hHitItem == m_hRoot )
        idMenu = CG_IDR_POPUP_ADV_ROOT;
    else
        idMenu = CG_IDR_POPUP_ADV_VIRT;

    CMenu menu;
    VERIFY(menu.LoadMenu(idMenu));

    CMenu* pPopup = menu.GetSubMenu(0);
    ASSERT(pPopup != NULL);

    CWnd* pWndPopupOwner = this;
    while (pWndPopupOwner->GetStyle() & WS_CHILD)
    pWndPopupOwner = pWndPopupOwner->GetParent();

    pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, pWndPopupOwner);
    }

//------------------------------------------------------------------------
BOOL CFormAdvanced::PreTranslateMessage(MSG* pMsg)
{
    // CG: This block was added by the Pop-up Menu component
    {
        // Shift+F10: show pop-up menu.
        if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
            (pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||  // it's Shift+F10 OR
            (pMsg->message == WM_CONTEXTMENU))                                  // Natural keyboard key
        {
            CRect rect;
            GetClientRect(rect);
            ClientToScreen(rect);

            CPoint point = rect.TopLeft();
            point.Offset(5, 5);
            OnContextMenu(NULL, point);

            return TRUE;
        }
    }

    return CFormView::PreTranslateMessage(pMsg);
}

//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateAddVirt(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( TRUE );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnAddVirt()
    {
    OnAdd();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnUpdatePropertiesVirt(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( TRUE );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnPropertiesVirt()
    {
    OnEdit();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateDeleteVirt(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( TRUE );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnDeleteVirt()
    {
    OnRemove();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateBrowseVirt(CCmdUI* pCmdUI)
    {
    CString szURL;
    pCmdUI->Enable( g_p_Doc && g_p_Doc->BuildHomePageString(szURL) &&
                m_ctreectrl_tree.GetSelectedItem() );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnBrowseVirt()
    {
    CString szURL;
    CString szRelative;

    // get the beginning part of the url
    if ( !g_p_Doc ) return;
    if ( !g_p_Doc->BuildHomePageString( szURL ) )
        return;

    // get the selected item's relative URL path
    BuildMetaPath( m_ctreectrl_tree.GetSelectedItem(), szRelative );

    // put it all together...
    szURL += szRelative;

    // and do it to it!
    ShellExecute(
        NULL,   // handle to parent window
        NULL,   // pointer to string that specifies operation to perform
        szURL,  // pointer to filename or folder name string
        NULL,   // pointer to string that specifies executable-file parameters
        NULL,   // pointer to string that specifies default directory
        SW_SHOW     // whether file is shown when opened
       );
    }


//------------------------------------------------------------------------
BOOL CFormAdvanced::FIsVirtualDirectoryValid( HTREEITEM hItem )
    {
    BOOL    fValid = FALSE;
    if ( !hItem )
        return FALSE;

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return FALSE;

    // build the metabase path
    CString szMB;
    BuildMetaPath( m_ctreectrl_tree.GetSelectedItem(), szMB );

    // open the metabase
    if ( mb.Open(SZ_MB_ROOT) )
        {
        // do the test
        fValid = FIsVirtualDirectoryValid( &mb, szMB );
        // close the metabase object
        mb.Close();
        }

    // finally, return the answer
    return fValid;
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateExploreVirt(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( FIsVirtualDirectoryValid(m_ctreectrl_tree.GetSelectedItem()) );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnExploreVirt()
    {
    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // build the metabase path
    CString szMB;
    BuildMetaPath( m_ctreectrl_tree.GetSelectedItem(), szMB );

    // open the metabase
    if ( mb.Open(SZ_MB_ROOT) )
        {
        CString sz;
        BOOL f = mb.GetString( szMB, MD_VR_PATH, IIS_MD_UT_FILE,
                    sz.GetBuffer( WIDE_MAX_PATH ), WIDE_MAX_PATH, METADATA_INHERIT);
        sz.ReleaseBuffer();
        if ( f )
            {
            // explore it!
            ShellExecute(
                NULL,           // handle to parent window
                _T("explore"),  // pointer to string that specifies operation to perform
                sz,             // pointer to filename or folder name string
                NULL,           // pointer to string that specifies executable-file parameters
                NULL,           // pointer to string that specifies default directory
                SW_SHOW         // whether file is shown when opened
               );
            }
        // close the metabase object
        mb.Close();
        }
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateOpenVirt(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( FIsVirtualDirectoryValid(m_ctreectrl_tree.GetSelectedItem()) );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnOpenVirt()
    {
    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // build the metabase path
    CString szMB;
    BuildMetaPath( m_ctreectrl_tree.GetSelectedItem(), szMB );

    // open the metabase
    if ( mb.Open(SZ_MB_ROOT) )
        {
        CString sz;
        BOOL f = mb.GetString( szMB, MD_VR_PATH, IIS_MD_UT_FILE,
                    sz.GetBuffer(WIDE_MAX_PATH), WIDE_MAX_PATH, METADATA_INHERIT);
        sz.ReleaseBuffer();
        if ( f )
            {
            // explore it!
            ShellExecute(
                NULL,       // handle to parent window
                _T("open"), // pointer to string that specifies operation to perform
                sz,         // pointer to filename or folder name string
                NULL,       // pointer to string that specifies executable-file parameters
                NULL,       // pointer to string that specifies default directory
                SW_SHOW     // whether file is shown when opened
               );
            }
        // close the metabase object
        mb.Close();
        }
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnFinalRelease()
    {
    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;
    // make sure the metabase saves the chagnes
    mb.Save();
    CFormView::OnFinalRelease();
    }

//------------------------------------------------------------------------
WORD CFormAdvanced::GetContextHelpID()
    {
    if ( m_DirHelpID )
        return m_DirHelpID;
    return CFormAdvanced::IDD;
    }


//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateEditCopy(CCmdUI* pCmdUI) 
    {
    pCmdUI->Enable( m_csz_default_doc.IsWindowEnabled() );
    }


//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateEditPaste(CCmdUI* pCmdUI) 
    {
    pCmdUI->Enable( m_csz_default_doc.IsWindowEnabled() );
    }


//------------------------------------------------------------------------
void CFormAdvanced::OnUpdateEditCut(CCmdUI* pCmdUI) 
    {
    pCmdUI->Enable( m_csz_default_doc.IsWindowEnabled() );
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnEditCut() 
    {
    m_csz_default_doc.Cut();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnEditCopy() 
    {
    m_csz_default_doc.Copy();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnEditPaste() 
    {
    m_csz_default_doc.Paste();
    }

//------------------------------------------------------------------------
void CFormAdvanced::OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    // check the remove button
    EnableItems();
    *pResult = 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\formadv.h ===
// FormAdv.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFormAdvanced form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFormAdvanced : public CPWSForm
//class CFormAdvanced : public CFormView
{
protected:
    afx_msg void OnContextMenu(CWnd*, CPoint point);
    CFormAdvanced();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(CFormAdvanced)

// Form Data
public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //{{AFX_DATA(CFormAdvanced)
    enum { IDD = IDD_PAGE_ADV };
    CButton m_cbtn_remove;
    CStaticTitle    m_ctitle_title;
    CTreeCtrl   m_ctreectrl_tree;
    CStatic m_csz_default_doc_title;
    CEdit   m_csz_default_doc;
    CString m_sz_default_doc;
    BOOL    m_bool_allow_browsing;
    BOOL    m_bool_enable_default;
    BOOL    m_bool_save_log;
    //}}AFX_DATA

// Attributes
public:
    virtual WORD GetContextHelpID();

// Operations
public:
    // sink updating
    void SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFormAdvanced)
    public:
    virtual void OnInitialUpdate();
    virtual void OnFinalRelease();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CFormAdvanced();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
    //{{AFX_MSG(CFormAdvanced)
    afx_msg void OnKillfocusDefaultDoc();
    afx_msg void OnEnableDefault();
    afx_msg void OnDirBrowse();
    afx_msg void OnEdit();
    afx_msg void OnDblclkTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSaveLog();
    afx_msg void OnAdd();
    afx_msg void OnRemove();
    afx_msg void OnAddVirt();
    afx_msg void OnUpdateAddVirt(CCmdUI* pCmdUI);
    afx_msg void OnPropertiesVirt();
    afx_msg void OnUpdatePropertiesVirt(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDeleteVirt(CCmdUI* pCmdUI);
    afx_msg void OnDeleteVirt();
    afx_msg void OnUpdateBrowseVirt(CCmdUI* pCmdUI);
    afx_msg void OnBrowseVirt();
    afx_msg void OnUpdateExploreVirt(CCmdUI* pCmdUI);
    afx_msg void OnExploreVirt();
    afx_msg void OnUpdateOpenVirt(CCmdUI* pCmdUI);
    afx_msg void OnOpenVirt();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
    afx_msg void OnEditCut();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()


    // tree maintenance utilities
    // initialize the trees - done once
    void InitTree();
    // empty all the items out of the tree
    void EmptyTree();
    // recursively add all the items to the tree
    void RecurseAddVDItems( CWrapMetaBase* pmb, LPCTSTR szMB, HTREEITEM hParent );
    // edit the selected item in the tree (calls EditTreeItem)
    void EditSelectedItem();
    void WriteItemData( CWrapMetaBase *pmb, CString szRelPath, CEditDirectory *pdlg );
    void SetTreeImage( CWrapMetaBase *pmb, CString szRelPath, HTREEITEM hItem );
    BOOL FIsVirtualDirectoryValid( CWrapMetaBase *pmb, CString szRelPath );
    BOOL FIsVirtualDirectoryValid( HTREEITEM hItem );

    // update the default document & browsing info from the metabase
    void UpdateBrowseInfo();
    // update the save log info from the metabase
    void UpdateSaveLog();
    // update the tree of virutal directories
    void UpdateVirtualTree();

    // Write the default document & browsing info to the metabase
    void SaveBrowseInfo();
    // Write the save log info to the metabase
    void SaveSaveLog();

    void EnableItems();

    // given an item in the tree, build its relative metabase path
    void BuildMetaPath( HTREEITEM hItem, CString &sz );

    // create a WAM application
    BOOL MakeWAMApplication( IN CString &szPath, IN BOOL fCreate, IN BOOL fRecover = FALSE, IN BOOL fRecurse = TRUE );

    // the root tree item
    HTREEITEM   m_hRoot;
    CImageList  m_imageList;

    WORD        m_DirHelpID;
    };





/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\formie.cpp ===
// FormIE.cpp : implementation file
//

#include "stdafx.h"
#include "pwsform.h"
#include "resource.h"
#include "Title.h"
#include "FormIE.h"
#include "ServCntr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CPWSForm*        g_pCurrentForm;
extern WORD             g_InitialPane;
extern WORD             g_InitialIELocation;
extern CString          g_AdditionalIEURL;

#define HIDD_PAGE_IE_DEFAULT    0x0500

/////////////////////////////////////////////////////////////////////////////
// CFormIE

IMPLEMENT_DYNCREATE(CFormIE, CFormView)

CFormIE::CFormIE()
    : CPWSForm(CFormIE::IDD)
    {
    //{{AFX_DATA_INIT(CFormIE)
    //}}AFX_DATA_INIT
    g_pCurrentForm = this;
    }

CFormIE::~CFormIE()
    {
    //m_ie.Release();
    }

void CFormIE::DoDataExchange(CDataExchange* pDX)
    {
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFormIE)
    DDX_Control(pDX, IDC_ICON_WEBSITE, m_icon_website);
    DDX_Control(pDX, IDC_ICON_TOUR, m_icon_tour);
    DDX_Control(pDX, IDC_ICON_PUBWIZ, m_icon_pubwiz);
    DDX_Control(pDX, IDC_TITLE_BAR, m_ctitle_title);
    DDX_Control(pDX, IDC_EXPLORER, m_ie);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CFormIE, CFormView)
    //{{AFX_MSG_MAP(CFormIE)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFormIE diagnostics

#ifdef _DEBUG
void CFormIE::AssertValid() const
{
    CFormView::AssertValid();
}

void CFormIE::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFormIE message handlers

//-----------------------------------------------------------------
void CFormIE::SetTitle( UINT nID )
    {
    CString sz;
    sz.LoadString( nID );
    m_ctitle_title.SetWindowText( sz );
    }

//-----------------------------------------------------------------
void CFormIE::GoToURL( LPCTSTR pszURL )
    {
    m_ie.Navigate( pszURL, NULL, NULL, NULL,  NULL );
    }

//-----------------------------------------------------------------
WORD CFormIE::GetContextHelpID()
    {
    // return the default id
    return HIDD_PAGE_IE_DEFAULT;
    }

//-----------------------------------------------------------------
void CFormIE::GoToTour()
    {
    CString szURL;

    // the tour is not to be served, but opened through a file-open
    // thus we need to build the string for the browser
    CW3ServerControl::GetServerDirectory( szURL );

    // load the rest of the path
    CString szPartial;
    szPartial.LoadString( IDS_HTML_TOUR );

    // build the full path
    szURL += szPartial;
    GoToURL( szURL );

    // set the right title
    SetTitle( IDS_TITLE_TOUR );
    //set the right icon
    m_icon_pubwiz.ShowWindow( SW_HIDE  );
    m_icon_website.ShowWindow( SW_HIDE  );
    m_icon_tour.ShowWindow( SW_SHOW  );
    }

//-----------------------------------------------------------------
void CFormIE::GoToWebsite()
    {
    // go to the correct URL
    CString szURL;
    szURL.LoadString( IDS_HTML_WEBSITE );
    GoToURL( szURL );
    // set the right title
    SetTitle( IDS_TITLE_WEBSITE );
    //set the right icon
    m_icon_pubwiz.ShowWindow( SW_HIDE  );
    m_icon_tour.ShowWindow( SW_HIDE  );
    m_icon_website.ShowWindow( SW_SHOW  );
    }

//-----------------------------------------------------------------
void CFormIE::GoToPubWizard()
    {
    CString szEmpty;
    GoToPubWizard( szEmpty );
    }

//-----------------------------------------------------------------
void CFormIE::GoToPubWizard( CString& szAdditional )
    {
    // go to the correct URL
    CString szURL;
    szURL.LoadString( IDS_HTML_ABOUTME );

    // Add the addition part of the url
    szURL += szAdditional;

    GoToURL( szURL );
    // set the right title
    SetTitle( IDS_TITLE_ABOUTME );
    //set the right icon
    m_icon_website.ShowWindow( SW_HIDE  );
    m_icon_tour.ShowWindow( SW_HIDE  );
    m_icon_pubwiz.ShowWindow( SW_SHOW  );
    }

//-----------------------------------------------------------------
void CFormIE::OnInitialUpdate() 
    {
    CFormView::OnInitialUpdate();

    // if this is not the starting point of the app, then
    // g_InitialPane will be something else
    if ( g_InitialPane != PANE_IE )
        return;

    // we only want to do this once
    g_InitialPane = PANE_MAIN;
    
    // if the app is just starting up and the g_InitialPane is
    // set to the ie pane, then we need to send it to the right place
    CWaitCursor    wait;

    // tell the user to sit tight
    SetTitle( IDS_PLEASE_WAIT_IE_LOADING );
    UpdateWindow( );

    // go to the correct URL
    switch( g_InitialIELocation )
        {
        case INIT_IE_TOUR:
            GoToTour();
            break;
        case INIT_IE_WEBSITE:
            GoToWebsite();
            break;
        case INIT_IE_PUBWIZ:
            GoToPubWizard( g_AdditionalIEURL );
            break;
        };
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\formie.h ===
// FormIE.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFormIE form view
//{{AFX_INCLUDES()
#include "webbrows.h"
//}}AFX_INCLUDES

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFormIE : public CPWSForm
{
protected:
    CFormIE();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(CFormIE)

// Form Data
public:
    //{{AFX_DATA(CFormIE)
    enum { IDD = IDD_PAGE_IE };
    CStatic m_icon_website;
    CStatic m_icon_tour;
    CStatic m_icon_pubwiz;
    CStaticTitle    m_ctitle_title;
    CWebBrowser m_ie;
    //}}AFX_DATA

// Attributes
public:
    void SetTitle( UINT nID );
    virtual WORD GetContextHelpID();


// Operations
public:
    void GoToURL( LPCTSTR pszURL );

    void GoToTour();
    void GoToWebsite();
    void GoToPubWizard();
    void GoToPubWizard( CString& szAdditional );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFormIE)
    public:
    virtual void OnInitialUpdate();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CFormIE();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
    //{{AFX_MSG(CFormIE)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)
        Boyd Multerer (boydm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//

#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iwamreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\formmain.cpp ===
// FormMain.cpp : implementation file
//
//  Create April 10, 1997       boydm

#include "stdafx.h"
#include "pwsform.h"
#include "resource.h"
#include <pwsdata.hxx>
#include <locale.h>
#include "Sink.h"
#include "pwsDoc.h"

#include "Title.h"
#include "HotLink.h"
#include "PWSChart.h"

#include "FormMain.h"

#include "ServCntr.h"

#include "mbobjs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CPwsDoc*     g_p_Doc;
extern CPWSForm*    g_pCurrentForm;
extern BOOL         g_fShutdownMode;
CFormMain*          g_FormMain = NULL;


enum {
    CHART_REQUESTS_DAY = 0,
    CHART_REQUESTS_HOUR,
    CHART_VISITORS_DAY,
    CHART_VISITORS_HOUR
    };


#define TIMER_CODE     'PWSf'
//#define TIMER_DELAY     10          // fast update test
#define TIMER_DELAY     10000        // update every 1h0 seconds

/////////////////////////////////////////////////////////////////////////////
// CFormMain

IMPLEMENT_DYNCREATE(CFormMain, CFormView)

//------------------------------------------------------------------------
CFormMain::CFormMain()
    : CPWSForm(CFormMain::IDD),
    m_pPWSData( NULL ),
    m_state( 0 )
{
    //{{AFX_DATA_INIT(CFormMain)
    m_sz_active_connections = _T("");
    m_sz_bytes_served = _T("");
    m_sz_max_connections = _T("");
    m_sz_requests = _T("");
    m_sz_start_date = _T("");
    m_sz_start_time = _T("");
    m_sz_visitors = _T("");
    m_sz_avail = _T("");
    m_sz_clickstart = _T("");
    m_int_chartoptions = -1;
    m_sz_legend = _T("");
    m_sz_HiValue = _T("");
    //}}AFX_DATA_INIT

    // allocate space for the pws data record
    m_pPWSData = new PWS_DATA;
    m_pwschart_chart.SetDataPointer( m_pPWSData );

    // tell the hotlinks what to do
    m_hotlink_home.m_fBrowse = TRUE;
    m_hotlink_directory.m_fExplore = TRUE;


    OSVERSIONINFO info_os;
    info_os.dwOSVersionInfoSize = sizeof(info_os);

    // record what sort of operating system we are running on
    m_fIsWinNT = FALSE;
    if ( GetVersionEx( &info_os ) )
        {
        if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_NT )
            m_fIsWinNT = TRUE;
        }
    }

//-----------------------------------------------------------------
WORD CFormMain::GetContextHelpID()
    {
    return CFormMain::IDD;
    }

//------------------------------------------------------------------------
CFormMain::~CFormMain()
    {
    g_FormMain = NULL;

    // free the chart data
    if ( m_pPWSData )
        delete m_pPWSData;
    m_pPWSData = NULL;

    // kill the timer
    KillTimer( TIMER_CODE );
    }

//------------------------------------------------------------------------
void CFormMain::DoDataExchange(CDataExchange* pDX)
    {
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFormMain)
    DDX_Control(pDX, IDC_CHART_OPTIONS, m_ccombobox_options);
    DDX_Control(pDX, IDC_CHART, m_pwschart_chart);
    DDX_Control(pDX, IDC_TITLE_BAR, m_statictitle_title);
    DDX_Control(pDX, IDC_HOMEPAGE_LOC, m_hotlink_home);
    DDX_Control(pDX, IDC_HOMEDIR_LOC, m_hotlink_directory);
    DDX_Control(pDX, IDC_START_TIME, m_csz_start_time);
    DDX_Control(pDX, IDC_ACTIVE_CONNECTIONS_TITLE, m_cs_ac_title);
    DDX_Control(pDX, IDC_MAX_CONNECTIONS_TITLE, m_cs_mc_title);
    DDX_Control(pDX, IDC_MONITORING_TITLE, m_cs_mn_title);
    DDX_Control(pDX, IDC_REQUESTS_TITLE, m_cs_rq_title);
    DDX_Control(pDX, IDC_VISITORS_TITLE, m_cs_vs_title);
    DDX_Control(pDX, IDC_BYTES_SERVED_TITLE, m_cs_bs_title);
    DDX_Control(pDX, IDC_BTN_STARTSTOP, m_cbutton_startstop);
    DDX_Text(pDX, IDC_ACTIVE_CONNECTIONS, m_sz_active_connections);
    DDX_Text(pDX, IDC_BYTES_SERVED, m_sz_bytes_served);
    DDX_Text(pDX, IDC_MAX_CONNECTIONS, m_sz_max_connections);
    DDX_Text(pDX, IDC_REQUESTS, m_sz_requests);
    DDX_Text(pDX, IDC_START_DATE, m_sz_start_date);
    DDX_Text(pDX, IDC_START_TIME, m_sz_start_time);
    DDX_Text(pDX, IDC_VISITORS, m_sz_visitors);
    DDX_Text(pDX, IDC_ON_AND_AVAILABLE, m_sz_avail);
    DDX_Text(pDX, IDC_CLICK_START, m_sz_clickstart);
    DDX_CBIndex(pDX, IDC_CHART_OPTIONS, m_int_chartoptions);
    DDX_Text(pDX, IDC_LEGEND, m_sz_legend);
    DDX_Text(pDX, IDC_HI_VALUE, m_sz_HiValue);
    //}}AFX_DATA_MAP
    }


//------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CFormMain, CFormView)
    //{{AFX_MSG_MAP(CFormMain)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_BTN_STARTSTOP, OnBtnStartstop)
    ON_CBN_SELCHANGE(IDC_CHART_OPTIONS, OnSelchangeChartOptions)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFormMain diagnostics

#ifdef _DEBUG
//------------------------------------------------------------------------
void CFormMain::AssertValid() const
{
    CFormView::AssertValid();
}

//------------------------------------------------------------------------
void CFormMain::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}
#endif //_DEBUG


//------------------------------------------------------------------------
// update the basic monitoring information
// the pwsdata pointer should have already been updated
void CFormMain::UpdateMonitorInfo()
    {
    // the pws pointer had better be there
    if ( !m_pPWSData )
        return;

    // if the server is stopped, we really have no need to update anything
    if ( m_state == MD_SERVER_STATE_STOPPED || m_state == MD_SERVER_STATE_STOPPING ||
        m_state == MD_SERVER_STATE_STARTING )
        return;

    // update the info in the monitoring section of the form
    UpdateData( TRUE );

    // start with the active connections
    m_sz_active_connections.Format(_T("%u"), m_pPWSData->nSessions);

    // number of visitors since startup
    m_sz_visitors.Format(_T("%u"), m_pPWSData->nTotalSessionsStart);

    // number of requests since startup
    m_sz_requests.Format(_T("%u"), m_pPWSData->nHitsStart);

    // number of bytes served since startup
    m_sz_bytes_served.Format(_T("%u"), m_pPWSData->nBytesSentStart);

    // max concurrent sessions since startup
    m_sz_max_connections.Format(_T("%u"), m_pPWSData->nMaxSessionsStart);

    // set the server start date and time strings
    CString szTime;
    GetTimeFormat(
        LOCALE_USER_DEFAULT,        // locale for which time is to be formatted  
        TIME_NOSECONDS,             // flags specifying function options  
        &m_pPWSData->timeStart,     // time to be formatted  
        NULL,                       // time format string  
        szTime.GetBuffer(MAX_PATH*2), // buffer for storing formatted string  
        MAX_PATH                    // size, in bytes or characters, of the buffer  
        );
    szTime.ReleaseBuffer();

    // prepare the time string
    AfxFormatString1( m_sz_start_time, IDS_START_TIME, szTime );

    // now the date string
    GetDateFormat(
        LOCALE_USER_DEFAULT,                    // locale for which date is to be formatted  
        DATE_SHORTDATE,                         // flags specifying function options  
        &m_pPWSData->timeStart,                 // date to be formatted  
        NULL,                                   // date format string  
        m_sz_start_date.GetBuffer(MAX_PATH*2),  // buffer for storing formatted string  
        MAX_PATH                                // size of buffer  
        );
    m_sz_start_date.ReleaseBuffer();


    // set the data back
    UpdateData( FALSE );
    }


//------------------------------------------------------------------------
// we need to keep the state of the chart persistent per user. This means in
// the registry. Not the metabase

// defined in pws.h
//#define   SZ_REG_PWS_PREFS            "Software\\Microsoft\\IISPersonal"
//#define   SZ_REG_PWS_SHOWTIPS         "ChartOption"

void CFormMain::SavePersistentSettings()
    {
    // save the value in the registry
    DWORD       err;
    HKEY        hKey;

    UpdateData( TRUE );

    BOOL        fShowTips = TRUE;
    DWORD       type = REG_DWORD;
    DWORD       data = m_int_chartoptions;
    DWORD       cbData = sizeof(data);
    DWORD       dwDisposition;

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_CURRENT_USER,  // handle of open key
            SZ_REG_PWS_PREFS,   // address of name of subkey to open
            0,                  // reserved
            KEY_WRITE,          // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key, try creating a new one
    if ( err != ERROR_SUCCESS )
        {
        // try to make a new key
        err = RegCreateKeyEx(
                HKEY_CURRENT_USER, 
                SZ_REG_PWS_PREFS, 
                NULL, 
                _T(""), 
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS, 
                NULL, 
                &hKey, 
                &dwDisposition 
                );

        // if we still didn't get the key - fail
        if ( err != ERROR_SUCCESS )
            return;
        }

    // save the value in the registry
    RegSetValueEx( hKey, SZ_REG_PWS_CHART, NULL, type, (PUCHAR)&data, cbData );

    // all done, close the key before leaving
    RegCloseKey( hKey );
    }

//------------------------------------------------------------------------
void CFormMain::RestorePersistentSettings()
    {
    BOOL        fShowTips = TRUE;
    DWORD       err;
    HKEY        hKey;
    DWORD       type = REG_DWORD;
    DWORD       data;
    DWORD       cbData = sizeof(data);

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_CURRENT_USER,  // handle of open key
            SZ_REG_PWS_PREFS,   // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        {
        m_ccombobox_options.SetCurSel(CHART_REQUESTS_DAY);
        return;
        }

    // query the value of the registry
    err = RegQueryValueEx( hKey, SZ_REG_PWS_CHART, NULL, &type, (PUCHAR)&data, &cbData );
    if ( err == ERROR_SUCCESS )
        m_ccombobox_options.SetCurSel( data );
    else
        m_ccombobox_options.SetCurSel(CHART_REQUESTS_DAY);

    // all done, close the key before leaving
    RegCloseKey( hKey );
    }

//------------------------------------------------------------------------
void CFormMain::OnDestroy() 
    {
    SavePersistentSettings();
    CFormView::OnDestroy();
    }


/////////////////////////////////////////////////////////////////////////////
// CFormMain message handlers

//------------------------------------------------------------------------
void CFormMain::OnInitialUpdate()
    {
    // start the pane going
    CFormView::OnInitialUpdate();

    // fill in the options on the chart combo box from resource strings
    CString     szOption;
    // requests per day
    szOption.LoadString( IDS_CHARTOPTS_RQPERDAY );
    m_ccombobox_options.AddString( szOption );
    // requests per hour
    szOption.LoadString( IDS_CHARTOPTS_RQPERHOUR );
    m_ccombobox_options.AddString( szOption );
    // visitors per day
    szOption.LoadString( IDS_CHARTOPTS_VPERDAY );
    m_ccombobox_options.AddString( szOption );
    // visitors per hour
    szOption.LoadString( IDS_CHARTOPTS_VPERHOUR );
    m_ccombobox_options.AddString( szOption );
    
    RestorePersistentSettings();

    // let the sink object know we are here
    g_FormMain = this;
    g_pCurrentForm = this;

     // udpate the server state right away
    UpdateServerState();

    // update the pws data right away
    UpdatePWSData();

    // update the monitor info right away
    UpdateMonitorInfo();

    // update the locations
    UpdateLocations();

    // update the chart right away
    OnSelchangeChartOptions();

    // we need to update the monitor on a timer loop
    // start up the timer mechanism
    SetTimer( TIMER_CODE, TIMER_DELAY, NULL );
    }

//------------------------------------------------------------------------
void CFormMain::OnTimer(UINT nIDEvent)
    {
    // make sure it is our timer
    if ( nIDEvent != TIMER_CODE )
        return;

    // if the server is stopped, we really have no need to update anything
    if ( m_state == MD_SERVER_STATE_STOPPED || m_state == MD_SERVER_STATE_STOPPING ||
        m_state == MD_SERVER_STATE_STARTING )
        return;

    // update the monitoring information
    if ( UpdatePWSData() )
        {
        // update the monitor info
        UpdateMonitorInfo();
        // update the chart
        UpdateChart();

        // do NOT access the metabase here. Any updates due to changes in the metabase
        // should be done through the sink mechanism below
        }
    }

//------------------------------------------------------------------------
void CFormMain::UpdateServerState()
    {
    BOOL    fUpdate = FALSE;
    CString sz;

    // first things first. Update the data reflecting the state of the server
    UpdateStateData();

    // prepare to update the items
    UpdateData( TRUE );

    // show the appropriate items
    switch( m_state )
        {
        case MD_SERVER_STATE_PAUSED:
            // because the server must be started when we pause (otherwise
            // the option isn't available) we convienently don't need to
            // worry about enabling buttons here.
            // special case strings
            m_sz_avail.LoadString( IDS_PAUSED_NAVAIL );
            m_sz_clickstart.LoadString( IDS_CLICK_CONTINUE );
            // display the right thing in the start/stop button
            sz.LoadString( IDS_CONTINUE );
            m_cbutton_startstop.SetWindowText( sz );
            m_hotlink_home.SetTitle( "" );
            break;

        case MD_SERVER_STATE_PAUSING:
            m_sz_avail.LoadString( IDS_PAUSING_WAIT );
            m_sz_clickstart.LoadString( IDS_CLICK_STOP );
            sz.LoadString( IDS_STOP );
            m_cbutton_startstop.SetWindowText( sz );
            break;

        case MD_SERVER_STATE_CONTINUING:
            m_sz_avail.LoadString( IDS_CONTINUING_WAIT );
            m_sz_clickstart.LoadString( IDS_CLICK_STOP );
            sz.LoadString( IDS_STOP );
            m_cbutton_startstop.SetWindowText( sz );
            break;

        case MD_SERVER_STATE_STARTING:
            // special case strings
            m_sz_avail.LoadString( IDS_STARTING_WAIT );
            m_sz_clickstart.LoadString( IDS_CLICK_STOP );
            // display the right thing in the start/stop button
            sz.LoadString( IDS_STOP );
            m_cbutton_startstop.SetWindowText( sz );
            break;
        case MD_SERVER_STATE_STARTED:
            // special case strings
            m_sz_avail.LoadString( IDS_ON_AND_AVAILABLE );
            m_sz_clickstart.LoadString( IDS_CLICK_STOP );

            // enable out the monitoring title strings
            m_cs_bs_title.EnableWindow( TRUE );
            m_cs_ac_title.EnableWindow( TRUE );
            m_cs_mc_title.EnableWindow( TRUE );
            m_cs_mn_title.EnableWindow( TRUE );
            m_cs_rq_title.EnableWindow( TRUE );
            m_cs_vs_title.EnableWindow( TRUE );
            m_csz_start_time.EnableWindow( TRUE );

            // display the right thing in the start/stop button
            sz.LoadString( IDS_STOP );
            m_cbutton_startstop.SetWindowText( sz );

            // we do want to update the rest
            fUpdate = TRUE;
            break;
        case MD_SERVER_STATE_STOPPED:
        case MD_SERVER_STATE_STOPPING:
            // clear out the monitoring strings
            m_sz_active_connections.Empty();
            m_sz_bytes_served.Empty();
            m_sz_max_connections.Empty();
            m_sz_requests.Empty();
            m_sz_start_date.Empty();
            m_sz_visitors.Empty();

            m_hotlink_home.SetTitle( "" );
            m_hotlink_directory.SetTitle( "" );

            // gray out the monitoring title strings
            m_cs_bs_title.EnableWindow( FALSE );
            m_cs_ac_title.EnableWindow( FALSE );
            m_cs_mc_title.EnableWindow( FALSE );
            m_cs_mn_title.EnableWindow( FALSE );
            m_cs_rq_title.EnableWindow( FALSE );
            m_cs_vs_title.EnableWindow( FALSE );
            m_csz_start_time.EnableWindow( FALSE );

            // special case strings
            m_sz_start_time.LoadString( IDS_NOT_RUNNING );
            m_sz_avail.LoadString( IDS_OFF_AND_NAVAIL );
            m_sz_clickstart.LoadString( IDS_CLICK_START );

            // display the right thing in the start/stop button
            sz.LoadString( IDS_START );
            m_cbutton_startstop.SetWindowText( sz );
            break;
        };

    // set the strings back into the dialog
    UpdateData( FALSE );

    // if the server is on, we have some more updating to do...
    if ( fUpdate )
        {
        UpdatePWSData();
        UpdateMonitorInfo();
        UpdateLocations();
        }
    }


//------------------------------------------------------------------------
void CFormMain::UpdateStateData()
    {
    CW3ServerControl    serverControler;

    //get the state
    int state = serverControler.GetServerState();

    // if it is the try again code, post the message again
    // and do nothing
    if ( state == STATE_TRY_AGAIN )
        {
        // we should try again later
        PostMessage( WM_UPDATE_SERVER_STATE );
        }
    else
        m_state = state;
    }

//------------------------------------------------------------------------
void CFormMain::UpdateLocations()
    {
    CString szBuff;
    BOOL    f;
    DWORD   dword;
    BOOL    fDefaultEnabled = FALSE;

    // if the server is stopped, we really have no need to update anything
    switch( m_state )
        {
        case MD_SERVER_STATE_STOPPED:
        case MD_SERVER_STATE_STOPPING:
        case MD_SERVER_STATE_STARTING:
        case MD_SERVER_STATE_PAUSING:
        case MD_SERVER_STATE_CONTINUING:
            return;
        };

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit() )
        return;

    // get the info we will need later
    if ( mb.Open(SZ_MB_ROOT) )
        {
        // if paused, don't update the home page
        if ( m_state == MD_SERVER_STATE_STARTED )
            {
            // see if the default document is enabled
            if ( mb.GetDword( _T(""), MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, &dword, METADATA_INHERIT ) )
                {
                fDefaultEnabled = (dword & MD_DIRBROW_LOADDEFAULT) > 0;
                }
            else
                {
                DWORD err = GetLastError( );
                if ( err == RPC_E_SERVERCALL_RETRYLATER )
                    {
                    // we should try again later
                    PostMessage( WM_UPDATE_LOCATIONS );
                    mb.Close();
                    return;
                    }
                }
            }

        // now, the default directory
        f = mb.GetString( 
            _T(""), 
            MD_VR_PATH, 
            IIS_MD_UT_FILE, 
            szBuff.GetBuffer(MAX_PATH*4), 
            MAX_PATH*4, 
            METADATA_INHERIT
            );

        szBuff.ReleaseBuffer();
        if ( !f )
            {
            DWORD err = GetLastError( );
            if ( err == RPC_E_SERVERCALL_RETRYLATER )
                {
                // we should try again later
                PostMessage( WM_UPDATE_LOCATIONS );
                mb.Close();
                return;
                }
            }

        // close the metabase object
        mb.Close();
        }


    // get ready
    UpdateData( TRUE );

    // actually we let the doc object build the homepage name - it gets used in multiple places
    if ( g_p_Doc  )
        {
        CString sz;
        // first, see if the default documents feature is turned on. if it isn't, tell
        // the user that they don't have a homepage, even though the server is on
        if ( m_state == MD_SERVER_STATE_PAUSED )
            m_sz_avail.LoadString( IDS_PAUSED_NAVAIL );
        else if ( fDefaultEnabled )
            {
            if ( m_state == MD_SERVER_STATE_STARTED )
                m_sz_avail.LoadString( IDS_ON_AND_AVAILABLE );
            else
                m_sz_avail.LoadString( IDS_OFF_AND_NAVAIL );
            g_p_Doc->BuildHomePageString( sz );
            m_hotlink_home.SetTitle( sz );
            }
        else
            {
            m_sz_avail.LoadString( IDS_ON_AND_NAVAIL );
            // default doc is not enabled
            m_hotlink_home.SetTitle( "" );
            }
        }

    // set the root directory
    m_hotlink_directory.SetTitle( szBuff );

    // put the answers back
    UpdateData( FALSE );
    }

//------------------------------------------------------------------------
void CFormMain::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
    {
    if ( pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
        // we are only concerned with changes in the state of the server here
        // thus, we can just look for the MD_SERVER_STATE id
        for ( DWORD iElement = 0; iElement < dwMDNumElements; iElement++ )
            {
            // each change has a list of IDs...
            for ( DWORD iID = 0; iID < pcoChangeList[iElement].dwMDNumDataIDs; iID++ )
                {
                // look for the ids that we are interested in
                switch( pcoChangeList[iElement].pdwMDDataIDs[iID] )
                    {
                    case MD_SERVER_STATE:
                        PostMessage( WM_UPDATE_SERVER_STATE );
                        break;
                    case MD_VR_PATH:
                    case MD_DEFAULT_LOAD_FILE:
                    case MD_DIRECTORY_BROWSING:
                        PostMessage( WM_UPDATE_LOCATIONS );
                        break;
                    default:
                        // do nothing
                        break;
                    };
                }
            }
        }
    }


//------------------------------------------------------------------------
// here to catch my user_update messages
LRESULT CFormMain::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
    {
    // look for special update messages
    switch( message )
        {
        case WM_UPDATE_SERVER_STATE:
            UpdateServerState();
            break;
        case WM_UPDATE_LOCATIONS:
            UpdateLocations();
            break;
        };

    return CFormView::WindowProc(message, wParam, lParam);
    }

//------------------------------------------------------------------------
void CFormMain::OnBtnStartstop()
    {
    // put up the wait cursor
    CWaitCursor         wait;
    CW3ServerControl    serverController;

    // if the server is Totally shut down, start it up from scratch
    if ( g_fShutdownMode )
        {
        // initialize the metabase interface
        if ( !FInitMetabaseWrapper(NULL) )
            {
            AfxMessageBox( IDS_ERROR_START );
            return;
            }

        // start up the sink mechanism too
        if ( !g_p_Doc->InitializeSink() )
            {
            AfxMessageBox( IDS_ERROR_START );
            FCloseMetabaseWrapper();
            return;
            };

        // clear the shutdown mode flag
        g_fShutdownMode = FALSE;
        }

    // send the appropriate command
    switch( m_state )
        {
        case MD_SERVER_STATE_STOPPED:
        case MD_SERVER_STATE_STOPPING:
            serverController.StartServer();
            break;
        case MD_SERVER_STATE_STARTED:
        case MD_SERVER_STATE_STARTING:
        case MD_SERVER_STATE_PAUSING:
        case MD_SERVER_STATE_CONTINUING:
            serverController.StopServer();
            break;
        case MD_SERVER_STATE_PAUSED:
            serverController.ContinueServer();
            break;
        };        

    // if this is not win nt (i.e. its win95), check the state now
    if ( !m_fIsWinNT )
        UpdateServerState();
    }

//------------------------------------------------------------------------
void CFormMain::OnSelchangeChartOptions()
    {
    CString sz;

    // get the form data
    UpdateData( TRUE );

    // do the time scale stuff
    switch( m_int_chartoptions )
        {
        case CHART_REQUESTS_DAY:
        case CHART_VISITORS_DAY:
            m_sz_legend.LoadString( IDS_DAYS );
            m_pwschart_chart.SetTimePeriod( PWS_CHART_DAILY );
            break;
        case CHART_REQUESTS_HOUR:
        case CHART_VISITORS_HOUR:
           m_sz_legend.LoadString( IDS_HOURS );
           m_pwschart_chart.SetTimePeriod( PWS_CHART_HOURLY );
           break;
        };

    // do the value type stuff
    switch( m_int_chartoptions )
        {
        case CHART_REQUESTS_DAY:
            m_pwschart_chart.SetDataType( PWS_CHART_HITS );
            break;
        case CHART_VISITORS_DAY:
            m_pwschart_chart.SetDataType( PWS_CHART_SESSIONS );
            break;
        case CHART_REQUESTS_HOUR:
             m_pwschart_chart.SetDataType( PWS_CHART_HITS );
            break;
        case CHART_VISITORS_HOUR:
            m_pwschart_chart.SetDataType( PWS_CHART_SESSIONS );
            break;
        };

    // put the data back
    UpdateData( FALSE );

    // update the chart right away
    UpdateChart();
    }

//------------------------------------------------------------------------
// redraw the chart
void CFormMain::UpdateChart()
    {
    m_pwschart_chart.DrawChart();
    UpdateData( TRUE );
    m_sz_HiValue.Format( _T("%u"), m_pwschart_chart.GetDataMax() );
    UpdateData( FALSE );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\formmain.h ===
// FormMain.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFormMain form view
//{{AFX_INCLUDES()
//#include "mschart.h"
//}}AFX_INCLUDES

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFormMain : public CPWSForm
{
protected:
    CFormMain();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(CFormMain)

// Form Data
public:
    //{{AFX_DATA(CFormMain)
    enum { IDD = IDD_PAGE_MAIN };
    CComboBox   m_ccombobox_options;
    CPWSChart   m_pwschart_chart;
    CStaticTitle    m_statictitle_title;
    CHotLink    m_hotlink_home;
    CHotLink    m_hotlink_directory;
    CStatic m_csz_start_time;
    CStatic m_cs_ac_title;
    CStatic m_cs_mc_title;
    CButton m_cs_mn_title;
    CStatic m_cs_rq_title;
    CStatic m_cs_vs_title;
    CStatic m_cs_bs_title;
    CButton m_cbutton_startstop;
    CString m_sz_active_connections;
    CString m_sz_bytes_served;
    CString m_sz_max_connections;
    CString m_sz_requests;
    CString m_sz_start_date;
    CString m_sz_start_time;
    CString m_sz_visitors;
    CString m_sz_avail;
    CString m_sz_clickstart;
    int     m_int_chartoptions;
    CString m_sz_legend;
    CString m_sz_HiValue;
    //}}AFX_DATA

// Attributes
public:
    // update the info about the server
    void UpdateServerState();         // set the state display
    virtual WORD GetContextHelpID();

// Operations
public:
    // sink updating
    void SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFormMain)
    public:
    virtual void OnInitialUpdate();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CFormMain();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
    //{{AFX_MSG(CFormMain)
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnBtnStartstop();
    afx_msg void OnSelchangeChartOptions();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // update the pws data record
    BOOL UpdatePWSData()
        {
        if ( m_pPWSData )
            return GetPwsData(m_pPWSData);
        return FALSE;
        }

    // update the info about the server
    void UpdateLocations();
    void UpdateMonitorInfo();
    void UpdateStateData();           // update thes state flag
    void UpdateChart();               // redraw the chart

    void SavePersistentSettings();
    void RestorePersistentSettings();

    // the pws data pointer
    PPWS_DATA   m_pPWSData;

    // internal flag reflecting the state of the server
    DWORD       m_state;

    BOOL        m_fIsWinNT;
    };

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\mbobjs.h ===
// metabase objects used in pws


#define     SZ_SERVER                       _T("/LM/W3SVC")
#define     MB_SERVER_KEY_UPDATE            _T("/LM/W3SVC/1/")
#define     SZ_MB_ROOT                      _T("/LM/W3SVC/1/ROOT")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE          RGB(0, 0, 0xFF)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse( FALSE ),
    m_fBrowse( FALSE ),
    m_fExplore( FALSE ),
    m_fOpen( FALSE ),
    m_fInitializedFont( FALSE )
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
    //{{AFX_MSG_MAP(CHotLink)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
    {
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
    }

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add underlining
        logfont.lfUnderline = TRUE;

        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }

    // draw the text in blue
    pdc->SetTextColor( COLOR_BLUE );

    // draw the text
    CString sz;
    GetWindowText( sz );
    pdc->DrawText( sz, &rect, DT_LEFT|DT_SINGLELINE|DT_VCENTER );

    // get the extents fo the text for later reference
    m_cpTextExtents = pdc->GetOutputTextExtent( sz );
    }

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
    {
    // get the main rect
    GetClientRect( rect );

    // reduce it by the width of the text
    rect.right = rect.left + m_cpTextExtents.cx;
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
    {
    // don't do the hotlink thing if there is no text
    CString sz;
    GetWindowText( sz );
    if ( sz.IsEmpty() )
        return;

    CRect   rect;
    GetTextRect( rect );
    if ( !m_CapturedMouse && rect.PtInRect(point) )
        {
        SetCapture( );
        m_CapturedMouse = TRUE;
        }
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
    {
    // only bother if we have the capture
    if ( m_CapturedMouse )
        {
        ReleaseCapture();
        if ( m_fBrowse )
            Browse();
        if ( m_fExplore )
            Explore();
        if ( m_fOpen )
            Open();
        }
    }

//------------------------------------------------------------------------
void CHotLink::Browse()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,   // handle to parent window
        NULL,   // pointer to string that specifies operation to perform
        sz, // pointer to filename or folder name string
        NULL,   // pointer to string that specifies executable-file parameters
        NULL,   // pointer to string that specifies default directory
        SW_SHOW     // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Explore()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,          // handle to parent window
        _T("explore"), // pointer to string that specifies operation to perform
        sz,            // pointer to filename or folder name string
        NULL,          // pointer to string that specifies executable-file parameters
        NULL,          // pointer to string that specifies default directory
        SW_SHOW        // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Open()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,       // handle to parent window
        _T("open"), // pointer to string that specifies operation to perform
        sz,         // pointer to filename or folder name string
        NULL,       // pointer to string that specifies executable-file parameters
        NULL,       // pointer to string that specifies default directory
        SW_SHOW     // whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
    {
    CRect   rect;
    GetTextRect( rect );
    // if the mouse is over the hot area, show the right cursor
    if ( rect.PtInRect(point) )
        ::SetCursor(AfxGetApp()->LoadCursor( IDC_BROWSE ));

//  CButton::OnMouseMove(nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////


// define the main window class for the pws application
#define PWS_MAIN_FRAME_CLASS_NAME   "IISPWS_MAIN_FRAME"


class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:
    CSplitterWnd m_wndSplitter;

    // public accessable pane controllers
    void GoToMain()         {OnPgeMain();}
    void GoToAdvanced()     {OnPgeAdvanced();}
    void GoToTour()         {OnPgeTour();}
//    void GoToAboutMe()      {OnPgeAboutMe();}
//    void GoToWebSite()      {OnPgeWebSite();}

// Operations
public:
    virtual void OnUpdateFrameTitle(BOOL bAddToTitle);

    static BOOL FIsW3Running();

    // Replace a specific pane view
    void ReplaceView( int nRow, int nCol, CRuntimeClass * pNewView, CSize & size );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
//  CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnPgeMain();
    afx_msg void OnPgeAdvanced();
    afx_msg void OnPgeTour();
    afx_msg void OnUpdatePgeTour(CCmdUI* pCmdUI);
    afx_msg void OnUpdatePgeMain(CCmdUI* pCmdUI);
    afx_msg void OnUpdatePgeAdvanced(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL OnPgeIE();
    void EnterShutdownMode( void );

    void CheckIfServerIsRunningAgain();
    void ProcessRemoteCommand();

    CFormIE*    m_pIEView;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include <winsvc.h>
#include "resource.h"
#include <pwsdata.hxx>
#include "Sink.h"

#include "pwsdoc.h"

#include "Title.h"
#include "HotLink.h"
#include "PWSChart.h"

#include "pwsform.h"

#include "EdDir.h"
#include "FormAdv.h"
#include "FormIE.h"
#include "FormMain.h"
#include "SelBarFm.h"

#include "MainFrm.h"

#include "ServCntr.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CMainFrame*         g_frame = NULL;
CPWSForm*           g_pCurrentForm = NULL;

extern WORD         g_InitialPane;
extern CPwsDoc*     g_p_Doc;
extern CFormMain*   g_FormMain;

// this flag indicates that we have gotten a server shutdown notification
// and we have entered shutdown mode. In this mode, the only features that
// are available anywhere include the start button, and the troubleshooting.
// I suppose the tour would be OK too since that isn't served.
BOOL            g_fShutdownMode = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_COMMAND(ID_PGE_MAIN, OnPgeMain)
    ON_COMMAND(ID_PGE_ADVANCED, OnPgeAdvanced)
    ON_COMMAND(ID_PGE_TOUR, OnPgeTour)
    ON_UPDATE_COMMAND_UI(ID_PGE_TOUR, OnUpdatePgeTour)
    ON_UPDATE_COMMAND_UI(ID_PGE_MAIN, OnUpdatePgeMain)
    ON_UPDATE_COMMAND_UI(ID_PGE_ADVANCED, OnUpdatePgeAdvanced)
    //}}AFX_MSG_MAP
    // Global help commands
    ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)
    ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

//-----------------------------------------------------------------
CMainFrame::CMainFrame():
        m_pIEView( NULL )
    {
    }

//-----------------------------------------------------------------
CMainFrame::~CMainFrame()
    {
    g_frame = NULL;
    }

//-----------------------------------------------------------------
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
    {
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

// DISABLE TOOL BAR
/*
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
        {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
        }

    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);
*/

    g_frame = this;
    return 0;
    }

//-----------------------------------------------------------------
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
    {
    cs.style = WS_OVERLAPPED | WS_CAPTION | WS_BORDER | FWS_ADDTOTITLE
        | WS_SYSMENU | WS_MINIMIZEBOX;

    cs.cx = 78;
    cs.cy = 50;

    LONG base = GetDialogBaseUnits();
    WORD baseX = LOWORD(base);
    WORD baseY = LOWORD(base);

    cs.cx *= baseX;
    cs.cy *= baseY;

    // account for user-defined window size changes
    cs.cy += GetSystemMetrics( SM_CYMENU );
    cs.cy += GetSystemMetrics( SM_CYCAPTION );

    // do the normal thing
    return CFrameWnd::PreCreateWindow(cs);
    }

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
//-----------------------------------------------------------------
void CMainFrame::AssertValid() const
    {
    CFrameWnd::AssertValid();
    }

//-----------------------------------------------------------------
void CMainFrame::Dump(CDumpContext& dc) const
    {
    CFrameWnd::Dump(dc);
    }

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
//--------------------------------------------------------------
// we just want the title of the app in the title bar
void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
    {
    CFrameWnd::OnUpdateFrameTitle(FALSE);
    }

//--------------------------------------------------------------
BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext)
    {
    // create the static splitter window    
    if ( !m_wndSplitter.CreateStatic( this, 1, 2 ) )
        {
        TRACE0("Failed to CreateStaticSplitter\n");
        return FALSE;
        }

    // calculate the width of the first splitter window
    DWORD   cpWidth = 11;
    cpWidth *= LOWORD(GetDialogBaseUnits());

    // the initial size of the first pane should be a function of the width of the view
    // add the first splitter pane - The machine tree view
    if (!m_wndSplitter.CreateView(0, 0,
    pContext->m_pNewViewClass, CSize(cpWidth, 500), pContext))
        {
        TRACE0("Failed to create machine tree pane\n");
        return FALSE;
        }

    switch( g_InitialPane )
        {
        case PANE_MAIN:
            if (!m_wndSplitter.CreateView(0, 1,
            RUNTIME_CLASS(CFormMain), CSize(0, 0), pContext))
                {
                TRACE0("Failed to create main form pane\n");
                return FALSE;
                }
            break;
        case PANE_IE:
            if (!m_wndSplitter.CreateView(0, 1,
            RUNTIME_CLASS(CFormIE), CSize(0, 0), pContext))
                {
                TRACE0("Failed to create main form pane\n");
                return FALSE;
                }
            // get the new ie view
            m_pIEView = (CFormIE *)m_wndSplitter.GetPane(0, 1);
            break;
        case PANE_ADVANCED:
            if (!m_wndSplitter.CreateView(0, 1,
            RUNTIME_CLASS(CFormAdvanced), CSize(0, 0), pContext))
                {
                TRACE0("Failed to create main form pane\n");
                return FALSE;
                }
            break;
        };

    return TRUE;
    }

//--------------------------------------------------------------
// Replace the specified pane in the splitter window, with the
// new view window
void
CMainFrame::ReplaceView(
    int nRow,
    int nCol,
    CRuntimeClass * pNewView,
    CSize & size
    )
    {
    g_pCurrentForm = NULL;
    CView * pCurrentView = (CView *)m_wndSplitter.GetPane(nRow, nCol);

    CRect rc;
    pCurrentView->GetClientRect(rc);
    size = CSize(rc.Width(), rc.Height());

    BOOL fActiveView = (pCurrentView == GetActiveView());
    CDocument * pDoc= pCurrentView->GetDocument();

    //
    // set flag so that document will not be deleted when
    // view is destroyed
    //
    pDoc->m_bAutoDelete = FALSE;
    //
    // Delete existing view
    //
    pCurrentView->DestroyWindow();
    //
    // set flag back to default
    //
    pDoc->m_bAutoDelete = TRUE;

    //
    // Create new view
    //
    CCreateContext context;
    context.m_pNewViewClass = pNewView;
    context.m_pCurrentDoc = pDoc;
    context.m_pNewDocTemplate = NULL;
    context.m_pLastView = NULL;
    context.m_pCurrentFrame = NULL;

    m_wndSplitter.CreateView(nRow, nCol, pNewView, size, &context);

    pCurrentView = (CView *)m_wndSplitter.GetPane(nRow, nCol);

    pCurrentView->OnInitialUpdate();
    m_wndSplitter.RecalcLayout();

    if (fActiveView)
        {
        SetActiveView(pCurrentView);
        }
    }

//--------------------------------------------------------------
void CMainFrame::OnPgeMain()
    {
    m_pIEView = NULL;
    ReplaceView( 0, 1, RUNTIME_CLASS(CFormMain), CSize(0, 0) );
    }

//--------------------------------------------------------------
void CMainFrame::OnPgeAdvanced()
    {
    if ( g_fShutdownMode )
        {
        AfxMessageBox( IDS_ERR_SERV_ADVANCED );
        return;
        }
    m_pIEView = NULL;
    ReplaceView( 0, 1, RUNTIME_CLASS(CFormAdvanced), CSize(0, 0) );
    }

//--------------------------------------------------------------
BOOL CMainFrame::OnPgeIE()
    {
    // if we are already on the IE page, then we don't have to do anything
    if ( m_pIEView )
        return TRUE;
    
    // we have to swap in theIE pane
    CWaitCursor    wait;
    ReplaceView( 0, 1, RUNTIME_CLASS(CFormIE), CSize(0, 0) );
    // get the new ie view
    m_pIEView = (CFormIE *)m_wndSplitter.GetPane(0, 1);
    if ( !m_pIEView ) return FALSE;

    // tell the user to sit tight
    m_pIEView->SetTitle( IDS_PLEASE_WAIT_IE_LOADING );
    m_pIEView->UpdateWindow( );
    return TRUE;
    }

//--------------------------------------------------------------
void CMainFrame::OnPgeTour()
    {
    // go to the IE page
    if ( !OnPgeIE() )
        return;

    // go to the URL
    m_pIEView->GoToTour();
    }

/*
//--------------------------------------------------------------
void CMainFrame::OnPgeAboutMe()
    {
    // first, make sure the server is running
    CW3ServerControl    serverController;
    if ( g_fShutdownMode || (serverController.GetServerState() != MD_SERVER_STATE_STARTED) )
        {
        AfxMessageBox( IDS_ERR_SERV_ABOUT );
        return;
        }

    // go to the IE page
    if ( !OnPgeIE() )
        return;

    // go to the correct URL
    m_pIEView->GoToPubWizard();
    }

//--------------------------------------------------------------
void CMainFrame::OnPgeWebSite()
    {
    // first, make sure the server is running
    CW3ServerControl    serverController;
    if ( g_fShutdownMode || (serverController.GetServerState() != MD_SERVER_STATE_STARTED) )
        {
        AfxMessageBox( IDS_ERR_SERV_WEB );
        return;
        }

    // go to the IE page
    if ( !OnPgeIE() )
        return;

    // go to the correct URL
    m_pIEView->GoToWebsite();
    }
*/

//--------------------------------------------------------------
void CMainFrame::OnUpdatePgeTour(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( TRUE );
    }

//--------------------------------------------------------------
void CMainFrame::OnUpdatePgeMain(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( TRUE );
    }

//--------------------------------------------------------------
void CMainFrame::OnUpdatePgeAdvanced(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( !g_fShutdownMode );
    }

/*
//--------------------------------------------------------------
void CMainFrame::OnUpdatePgeAboutMe(CCmdUI* pCmdUI)
    {
    BOOL    fEnable = FALSE;

    // if we are not in shutdown mode, check the state of the server
    if ( !g_fShutdownMode )
        {
        CW3ServerControl    serverController;
        DWORD   dwState = serverController.GetServerState();
        fEnable = (dwState == MD_SERVER_STATE_STARTED);
        }

    // enable the item
    pCmdUI->Enable( fEnable );
    }

//--------------------------------------------------------------
void CMainFrame::OnUpdatePgeWebSite(CCmdUI* pCmdUI)
    {
    BOOL    fEnable = FALSE;

    // if we are not in shutdown mode, check the state of the server
    if ( !g_fShutdownMode )
        {
        CW3ServerControl    serverController;
        DWORD   dwState = serverController.GetServerState();
        fEnable = (dwState == MD_SERVER_STATE_STARTED);
        }

    // enable the item
    pCmdUI->Enable( fEnable );
    }
*/

//--------------------------------------------------------------
void CMainFrame::WinHelp(DWORD dwData, UINT nCmd) 
    {
    // if this is the context help for the main frame, get the context help for the
    // appropriate sub-dialog
    if ( g_pCurrentForm )
        {
        switch( LOWORD(dwData) )
            {
            case IDR_MAINFRAME:
            case IDD_DIRECTORY:             // let the adv pane decide
                // clear out the lower word
                dwData &= 0xFFFF0000;
                // get the appropriate pane help id
                dwData |= g_pCurrentForm->GetContextHelpID();
                break;
            };
        }
    CFrameWnd::WinHelp(dwData, nCmd);
    }



//--------------------------------------------------------------
LRESULT CMainFrame::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
    {
    CFormSelectionBar*   pSelView;

    // look for the server shutdown notification message
    switch( message )
        {
        case WM_PROCESS_REMOTE_COMMAND_INFO:
            ProcessRemoteCommand();
            break;
        case WM_UPDATE_SERVER_STATE:
            pSelView = (CFormSelectionBar*)m_wndSplitter.GetPane(0, 0);
            if ( pSelView )
                pSelView->ReflectAvailability();
            break;
        case WM_MAJOR_SERVER_SHUTDOWN_ALERT:
            if ( !g_fShutdownMode )
                EnterShutdownMode();
            break;
        case WM_TIMER:      // only arrives if shutdown notify has happened
            CheckIfServerIsRunningAgain();
            break;
        };

    // do the inherited function
    return CFrameWnd::WindowProc(message, wParam, lParam);
    }

//--------------------------------------------------------------
void CMainFrame::EnterShutdownMode( void ) 
    {
    // first, shutdown the sink attached to the document
    if ( g_p_Doc )
        g_p_Doc->TerminateSink();

    // close the link to the metabase - it is going away after all
    FCloseMetabaseWrapper();

    // record that we are in shutdown mode
    g_fShutdownMode = TRUE;

    // go to the main page
    OnPgeMain();

    // reflect this in the selection bar
    CFormSelectionBar*   pSelView = (CFormSelectionBar*)m_wndSplitter.GetPane(0, 0);
    if ( pSelView )
        pSelView->ReflectAvailability();

    // start the timer mechanism
    SetTimer( PWS_TIMER_CHECKFORSERVERRESTART, TIMER_RESTART, NULL );
    }

//---------------------------------------------------------------------------
// This routine is called on a timer event. The timer events only come if we
// have received a shutdown notify callback from the metabase. So the server
// is down. We need to wait around until it comes back up, then show ourselves.
void CMainFrame::CheckIfServerIsRunningAgain()
    {
    // see if the server is running. If it is, show the icon and stop the timer.
    if ( FIsW3Running() && g_p_Doc )
        {
        // if we can't use the metabase, there is no point in this
        if ( !FInitMetabaseWrapper(NULL) )
            {
            return;
            }
 
        // if we can't use the sink, there is no point in this
        if ( !g_p_Doc->InitializeSink() )
            {
            FCloseMetabaseWrapper();
            return;
            }

        // clear the shutdown mode flag
        g_fShutdownMode = FALSE;

        // stop the timer mechanism
        KillTimer( PWS_TIMER_CHECKFORSERVERRESTART );

        // reflect this in the selection bar
        CFormSelectionBar*   pSelView = (CFormSelectionBar*)m_wndSplitter.GetPane(0, 0);
        if ( pSelView )
            pSelView->ReflectAvailability();

        // tell the main page to update itself
        if ( g_FormMain )
            g_FormMain->PostMessage( WM_UPDATE_SERVER_STATE );
        }
    }

// routine to see if w3svc is running
//--------------------------------------------------------------------
// the method we use to see if the service is running is different on
// windows NT from win95
BOOL   CMainFrame::FIsW3Running()
    {
    OSVERSIONINFO info_os;
    info_os.dwOSVersionInfoSize = sizeof(info_os);

    if ( !GetVersionEx( &info_os ) )
        return FALSE;

    // if the platform is NT, query the service control manager
    if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
        BOOL    fRunning = FALSE;

        // open the service manager
        SC_HANDLE   sch = OpenSCManager(NULL, NULL, GENERIC_READ );
        if ( sch == NULL ) return FALSE;

        // get the service
        SC_HANDLE   schW3 = OpenService(sch, _T("W3SVC"), SERVICE_QUERY_STATUS );
        if ( sch == NULL ) 
            {
            CloseServiceHandle( sch );
            return FALSE;
            }

        // query the service status
        SERVICE_STATUS  status;
        ZeroMemory( &status, sizeof(status) );
        if ( QueryServiceStatus(schW3, &status) )
            {
            fRunning = (status.dwCurrentState == SERVICE_RUNNING);
            }

        CloseServiceHandle( schW3 );
        CloseServiceHandle( sch );

        // return the answer
        return fRunning;
        }

    // if the platform is Windows95, see if the object exists
    if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
        {
        HANDLE hEvent;
        BOOL fFound = FALSE;
        hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));
        if ( hEvent != NULL )
            {
            fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
            CloseHandle(hEvent);
            }
        return(fFound);
        }

    return FALSE;
    }

//--------------------------------------------------------------
// method only gets called when another instance of the application
// as been invoked. Since we are only supposed to have one instance
// of the apoplication running at a time, and also sine that other
// instance may have been invoked with a command line, we should do
// that that command line requested. The other instance has already
// parsed the command and marshaled the parameters into a shared
// memory space object. All we have to do is get it and act on the
// commands
void CMainFrame::ProcessRemoteCommand() 
    {
    HANDLE                  hMap;
    PPWS_INSTANCE_TRANSFER  pData;
    CString                 sz;
    CView                   *pView;

    // get the shared memory space object
    hMap = OpenFileMapping(
                    FILE_MAP_READ,
                    FALSE,
                    PWS_INSTANCE_TRANSFER_SPACE_NAME
                    );
    if ( hMap == NULL )
        return;
    pData = (PPWS_INSTANCE_TRANSFER)MapViewOfFile(
            hMap,
            FILE_MAP_READ,
            0,
            0,
            0
            );
    if ( !pData )
        {
        CloseHandle(hMap);
        return;
        }


    // act on the command data we have just gotten
    switch( pData->iTargetPane )
        {
        case PANE_MAIN:
            OnPgeMain();
            // force the pane to update
            pView = (CView *)m_wndSplitter.GetPane(0, 1);
            if ( pView )
                {
                pView->PostMessage(WM_UPDATE_SERVER_STATE);
                pView->PostMessage(WM_UPDATE_LOCATIONS);
                }
            break;

        case PANE_IE:
            // go to the IE page
            if ( !OnPgeIE() )
                break;
            // go to the right IE page
            switch( pData->iTargetIELocation )
                {
                case INIT_IE_TOUR:
                    m_pIEView->GoToTour();
                    break;
                case INIT_IE_WEBSITE:
                    m_pIEView->GoToWebsite();
                    break;
                case INIT_IE_PUBWIZ:
                    sz = &pData->tchIEURL;
                    m_pIEView->GoToPubWizard( sz );
                    break;
                };
            break;

        case PANE_ADVANCED:
            OnPgeAdvanced();
            // force the pane to update
            pView = (CView *)m_wndSplitter.GetPane(0, 1);
            if ( pView )
                {
                pView->PostMessage(WM_UPDATE_BROWSEINFO);
                pView->PostMessage(WM_UPDATE_LOGINFO);
                pView->PostMessage(WM_UPDATE_TREEINFO);
                }
            break;
        };


    // clean up the shared memory space
    UnmapViewOfFile(pData);
    CloseHandle(hMap);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\hotlink.h ===
// HotLink.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
    CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHotLink)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CHotLink();

    // Generated message map functions
protected:
    //{{AFX_MSG(CHotLink)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pws.h ===
// pws.h : main header file for the PWS application
//

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#define SZ_MB_INSTANCE_OBJECT       _T("/LM/W3SVC/1")

#define SZ_REG_PWS_PREFS            _T("Software\\Microsoft\\IISPersonal")
#define SZ_REG_PWS_SHOWTIPS         _T("ShowTips")
#define SZ_REG_PWS_CHART            _T("ChartOption")

// codes to create which initial right-hand pane
enum {
    PANE_MAIN = 0,
    PANE_IE,
    PANE_ADVANCED
    };

// codes to create which initial IE pane
enum {
    INIT_IE_TOUR = 0,
    INIT_IE_WEBSITE,
    INIT_IE_PUBWIZ
    };

// internal messages
enum {
    WM_UPDATE_SERVER_STATE = WM_USER,
    WM_UPDATE_LOCATIONS,
    WM_UPDATE_BROWSEINFO,
    WM_UPDATE_LOGINFO,
    WM_UPDATE_TREEINFO,
    WM_MAJOR_SERVER_SHUTDOWN_ALERT,
    WM_PROCESS_REMOTE_COMMAND_INFO
    };

// Timers
enum {
    PWS_TIMER_CHECKFORSERVERRESTART = 0
    };

// delays
// number of milliseconds for the restart timer to wait
#define TIMER_RESTART           5000


// stucture use pass information from one instance to another
#define PWS_INSTANCE_TRANSFER_SPACE_NAME    _T("PWS_INSTANCE_TRANSFER_SPACE")
typedef struct _PWS_INSTANCE_TRANSFER
    {
    // target pane to go to
    WORD           iTargetPane;
    // target ie pane if iTargetPane is IE
    WORD           iTargetIELocation;
    // additional IE information
    TCHAR           tchIEURL;
    } PWS_INSTANCE_TRANSFER, *PPWS_INSTANCE_TRANSFER;


/////////////////////////////////////////////////////////////////////////////
// CPwsApp:
// See pws.cpp for the implementation of this class
//

class CPwsApp : public CWinApp
{
public:
    CPwsApp();
    ~CPwsApp();
    void ShowTipsAtStartup();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPwsApp)
    public:
    virtual BOOL InitInstance();
    virtual BOOL OnIdle(LONG lCount);
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
    COleTemplateServer m_server;

    //{{AFX_MSG(CPwsApp)
    afx_msg void OnAppAbout();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    protected:
    BOOL    m_fShowedStartupTips;

    BOOL    DealWithParameters();
    void    SendCommandInfo( CWnd* pWnd );
    LPCSTR  m_pSavedDocSz;
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwsctrl.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsctrl.cpp

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    Boyd Multerer       (BoydM)     29-Apr-1997

--*/
BOOL W95StartW3SVC( void );
//BOOL W95StartW3SVC( LPCSTR pszPath, LPCSTR pszPathDir, PCHAR pszParams );
BOOL W95ShutdownW3SVC( VOID );
BOOL W95ShutdownIISADMIN( VOID );
BOOL IsIISAdminRunning( VOID );
BOOL IsInetinfoRunning( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwschart.cpp ===
// PWSChart.cpp : implementation file
//

#include "stdafx.h"
#include "PWSChart.h"

#include <pwsdata.hxx>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPWSChart

CPWSChart::CPWSChart():
    m_pData( NULL ),
    m_period( PWS_CHART_HOURLY ),
    m_dataType( PWS_CHART_SESSIONS )
    {
    }

CPWSChart::~CPWSChart()
    {
    }

BEGIN_MESSAGE_MAP(CPWSChart, CStatic)
    //{{AFX_MSG_MAP(CPWSChart)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------
void CPWSChart::DrawChart()
    {
    CDC* dc = GetDC();
    DrawChart( dc );
    ReleaseDC( dc );
    }

//------------------------------------------------------------------
void CPWSChart::OnPaint()
    {
    CPaintDC dc(this); // device context for painting

    // draw the chart
    DrawChart( &dc );
    }

#define NUM_ROWS        4

//------------------------------------------------------------------
DWORD CPWSChart::GetDataValue( DWORD i )
    {
    PPWS_DATA   pData = (PPWS_DATA)m_pData;
    // get the right thing
    switch( m_period )
        {
        case PWS_CHART_HOURLY:
            switch( m_dataType )
                {
                case PWS_CHART_SESSIONS:
                    return pData->rgbHourData[i].nTotalSessions;
                case PWS_CHART_HITS:
                    return pData->rgbHourData[i].nHits;
                case PWS_CHART_KB:
                    return pData->rgbHourData[i].nBytesSent;
                case PWS_CHART_HITS_PER_USER:
                    if ( !pData->rgbHourData[i].nTotalSessions )
                        return 0;
                    else
                        return pData->rgbHourData[i].nHits / pData->rgbHourData[i].nTotalSessions;
                case PWS_CHART_KB_PER_USER:
                    if ( !pData->rgbHourData[i].nTotalSessions )
                        return 0;
                    else
                        return pData->rgbHourData[i].nBytesSent / pData->rgbHourData[i].nTotalSessions;
                default:
                    return 0;
                };
            break;
        case PWS_CHART_DAILY:
            switch( m_dataType )
                {
                case PWS_CHART_SESSIONS:
                    return pData->rgbDayData[i].nTotalSessions;
                case PWS_CHART_HITS:
                    return pData->rgbDayData[i].nHits;
                case PWS_CHART_KB:
                    return pData->rgbDayData[i].nBytesSent;
                case PWS_CHART_HITS_PER_USER:
                    if ( !pData->rgbHourData[i].nTotalSessions )
                        return 0;
                    else
                        return pData->rgbDayData[i].nHits / pData->rgbDayData[i].nTotalSessions;
                case PWS_CHART_KB_PER_USER:
                    if ( !pData->rgbHourData[i].nTotalSessions )
                        return 0;
                    else
                        return pData->rgbDayData[i].nBytesSent / pData->rgbDayData[i].nTotalSessions;
                default:
                    return 0;
                };
            break;
        default:
            return 0;
        };
    return 0;
    }

//------------------------------------------------------------------
void CPWSChart::DrawChart( CDC* dc )
    {
    CRect   rectWindow, rectChart;
    CDC*    dcDraw = dc;
    DWORD   value;

    int     cpColWidth;
    int     cpRowHeight;
    int     xErr, xLeftover;
    CRect   rect, rectInterior;

    int     nNumColumns, i;

    if ( !m_pData ) 
    {
        return;
    }

    // cache the current time
    GetLocalTime( &m_timeCurrent );

    // prepare basic stuff
    GetClientRect( &rectWindow );
    rectWindow.bottom--;
    rectWindow.right--;

    rectChart = rectWindow;
    rectChart.DeflateRect( 1, 0 );
    rectChart.top += 1;

    //============= CALCULATIONS
    // now we calculate scale factors and the like

    // first, the period-based stuff
    switch( m_period )
        {
        case PWS_CHART_HOURLY:
            nNumColumns = 24;
            break;
        case PWS_CHART_DAILY:
            nNumColumns = 7;
            break;
        default:
            return;
        };

    // generic stuff
    int cpWindowWidth = rectChart.right - rectChart.left + 1;
    cpColWidth = cpWindowWidth / nNumColumns;
    xLeftover = cpWindowWidth % nNumColumns;
    cpRowHeight = (rectChart.bottom - rectChart.top) / NUM_ROWS;

    // figure out the maximum value of the data
    m_max = 0;
    for ( i = 0; i < nNumColumns; i++ )
        {
        DWORD data = GetDataValue(i);
        if ( data > m_max )
            m_max = data;
        };

    // create a floating point scaling factor for the y value;
    float yFactor;
    if ( m_max )
        yFactor = (float)(rectChart.bottom - rectChart.top ) / m_max;

    //============= DRAWING!

    // start by blanking out the background of the chart
    dcDraw->FillSolidRect( &rectWindow, GetSysColor(COLOR_APPWORKSPACE) );

    // prepare the data rect
    rect.left = rectChart.left;
    rect.right = rect.left + cpColWidth;
    rect.bottom = rectChart.bottom;
    xErr = 0;

    // the bars
    if ( m_max )
        {
        for ( i = 0; i < nNumColumns; i++ )
            {
            // only draw something if there is a value there
            value = GetDataValue(i);
            if ( !value )
                {
                goto increment;
                }

            // build the rectangle to fill
            rect.top = (int)((float)rectWindow.bottom - 1.0 - ((float)GetDataValue(i) * yFactor));

            // draw the data bar
            dcDraw->Draw3dRect( rect, GetSysColor(COLOR_3DHILIGHT), GetSysColor(COLOR_3DSHADOW) );
            // fill in the data bar
            rectInterior = rect;
            rectInterior.DeflateRect( 1, 1 );
            dcDraw->FillSolidRect( rectInterior, GetSysColor(COLOR_3DFACE) );

            // increment stuff
    increment:
            rect.left = rect.right;
            // account for the error factor
            xErr += xLeftover;
            if ( xErr > nNumColumns )
                {
                rect.right++;
                xErr -= nNumColumns;
                }
            rect.right += cpColWidth;
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pws.cpp ===
// pws.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "pwsform.h"
#include "resource.h"

#include "Title.h"
#include "FormIE.h"
#include "MainFrm.h"
#include "pwsDoc.h"
#include "PWSChart.h"
#include "SelBarFm.h"
#include "ServCntr.h"
#include <winsock2.h>
#include "TipDlg.h"

#include "pwsctrl.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CMD_START           _T("start")
#define CMD_STOP            _T("stop")

#define CMD_OPEN            _T("open:")
#define CMD_OPEN_MAIN       _T("main")
#define CMD_OPEN_ADV        _T("advanced")
#define CMD_OPEN_TOUR       _T("tour")
//#define CMD_OPEN_WEBSITE    _T("website")
//#define CMD_OPEN_PUBWIZ     _T("pubwiz")

#define CMD_SEPS            _T("/- ")

#define FILES_QUERY_STRING  _T("?dropStr=");


// globals
//extern CPwsForm*                g_p_FormView;
extern CPwsDoc*                 g_p_Doc;
CString                         g_szHelpLocation;

WORD                            g_InitialPane = PANE_MAIN;
WORD                            g_InitialIELocation = INIT_IE_TOUR;
CString                         g_AdditionalIEURL;


/////////////////////////////////////////////////////////////////////////////
// CPwsApp

BEGIN_MESSAGE_MAP(CPwsApp, CWinApp)
    //{{AFX_MSG_MAP(CPwsApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPwsApp construction
//-----------------------------------------------------
CPwsApp::CPwsApp() :
        m_fShowedStartupTips( FALSE )
    {
    }

//-----------------------------------------------------
CPwsApp::~CPwsApp()
    {
    }

/////////////////////////////////////////////////////////////////////////////
// The one and only CPwsApp object

CPwsApp theApp;

static const CLSID clsid =
{ 0x35c43df, 0x8464, 0x11d0, { 0xa9, 0x2d, 0x8, 0x0, 0x2b, 0x2c, 0x6f, 0x32 } };

/////////////////////////////////////////////////////////////////////////////
// CPwsApp initialization

//-----------------------------------------------------
// return FALSE to continue running the application
BOOL CPwsApp::DealWithParameters()
    {
    BOOL    fAnswer = FALSE;

    // under windows NT, we always just invoke the UI, no matter what the command line
    OSVERSIONINFO info_os;
    info_os.dwOSVersionInfoSize = sizeof(info_os);

    // check what sort of operating system we are running on
    if ( !GetVersionEx( &info_os ) )
        return FALSE;

    CString sz = m_lpCmdLine;
    sz.TrimRight();
    // the first one is easy. If there is no command line, invoke the UI and leave
    if ( sz.IsEmpty() )
        return FALSE;


/* The publishing wizard has been pulled from PWS for NT5

    // The next one is also easy. If there is no '/' character, then the
    // parameters have to be file names for the publishing wizard. Also, the OS
    // gets rid of any spaces in the filenames for us. So we can just replace
    // them with ';' characters and be done with it
    if ( sz.Find(_T('/')) < 0 )
        {
        // set up to go to the publishing wizard
        g_InitialPane = PANE_IE;
        g_InitialIELocation = INIT_IE_PUBWIZ;

        // build the additional string
        g_AdditionalIEURL = FILES_QUERY_STRING;         // ?dropStr=

        // at this point it is desirous to convert the files listed in szAdditional,
        // which are in 8.3 format into long file names format. This means that they
        // will have to be put in quotes to handle spaces in the names. If a name
        // is already in quotes, then do not act on it in this way. Just add it to the
        // list as it is.
        CString szShortNames = sz;
        CString szTemp, szTemp2;
        BOOL    fFoundOneFile = FALSE;

        // trim any trailing whitespace
        szShortNames.TrimRight();

        // loop through all the files
        while( szShortNames.GetLength() )
            {
            // trim any leading whitespace characters
            szShortNames.TrimLeft();

            // if the name is already in quotes, just add it
            if ( szShortNames[0] == _T('\"') )
                {
                // find the closing quote
                szShortNames = szShortNames.Right( szShortNames.GetLength() - 1 );
                int   ichClose = szShortNames.Find(_T('\"'));

                // build the name
                szTemp = _T('\"');
                // if there was no closing quote use the whole string
                if ( ichClose < 0 )
                    {
                    szTemp += szShortNames;
                    szShortNames.Empty();
                    // close the qoutes
                    szTemp += _T('\"');
                    }
                else
                    {
                    szTemp += szShortNames.Left(ichClose+1);
                    // get this file name out of the szShortNames path so we don't do it again
                    szShortNames = szShortNames.Right(szShortNames.GetLength() - (ichClose+1));
                    }
                }
            else
                // it is an 8.3 name, convert it
                {
                // find the space (could do inline, but this is faster)
                int   ichSpace = szShortNames.Find(_T(' '));

                // get just the one file name
                if ( ichSpace > 0 )
                    szTemp = szShortNames.Left(ichSpace);
                else
                    szTemp = szShortNames;


                // prep the find file info block
                HANDLE              hFindFile;
                WIN32_FIND_DATA     findData;
                ZeroMemory( &findData, sizeof(findData) );

                // find the file
                hFindFile =  FindFirstFile(
                    (LPCTSTR)szTemp, // pointer to name of file to search for  
                    &findData       // pointer to returned information  
                    ); 


                // if it was successful, extract the long file name
                if ( hFindFile != INVALID_HANDLE_VALUE )
                    {
                    // enclose the path in quotes and go
                    szTemp = _T('\"');
                    
                    // start by adding the path portion of the original string
                    if ( ichSpace >= 0 )
                        szTemp += szShortNames.Left(ichSpace);
                    else
                        szTemp += szShortNames;

                    // chop off the file name - but leave the trailing '\' character
                    if ( szTemp.ReverseFind(_T('\\')) > 0 )
                        szTemp = szTemp.Left( szTemp.ReverseFind(_T('\\')) + 1 );

                    // copy over the full path name
                    szTemp += findData.cFileName;

                    // close the qoutes
                    szTemp += _T('\"');
                    }

                // if there are no more names, then empth the path, otherwise, just shorten it
                if ( ichSpace < 0 )
                    szShortNames.Empty();
                else
                    // get this file name out of the szShortNames path so we don't do it again
                    szShortNames = szShortNames.Right(szShortNames.GetLength() - ichSpace);

                // we aren't really finding files here, so just close the find handle
                FindClose( hFindFile );
                }

            // if we have already added a file, precede the one we are about to add with a ;
            if ( fFoundOneFile )
                g_AdditionalIEURL += _T(';');

            // add the string
            g_AdditionalIEURL += szTemp;
            fFoundOneFile = TRUE;
            }

        // prevent the tips dialog from coming up
        m_fShowedStartupTips = TRUE;

        // all done.
        return FALSE;
        }
*/

    // copy the command line into a buffer
    TCHAR   buff[MAX_PATH];
    _tcscpy( buff, sz );

    // just so we don't do it in the loop, initialize the open: string
    // length variable
    DWORD    cchOpen = _tcslen( CMD_OPEN );

    // parse out the arguments
    LPTSTR  pTok;
    pTok = _tcstok( buff, CMD_SEPS );

    while ( pTok )
        {
        // the start and stop commands are for windows 95 only
        if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
            {
            // look for the start command
            if ( _tcsicmp(pTok, CMD_START) == 0 )
                {
                W95StartW3SVC();
                fAnswer = TRUE;
                goto nextToken;
                }

            // look for the stop command
            if ( _tcsicmp(pTok, CMD_STOP) == 0 )
                {
                W95ShutdownW3SVC();
                W95ShutdownIISADMIN();
                fAnswer = TRUE;
                goto nextToken;
                }
            }

        // commands that work for all platforms

        // look for the open: command
        if ( _tcsnicmp(pTok, CMD_OPEN, cchOpen) == 0 )
            {
            // just put the open parameter in a string
            CString szOpen = pTok;
            szOpen = szOpen.Right( szOpen.GetLength() - cchOpen );

            // now test all the options
            if ( szOpen.CompareNoCase(CMD_OPEN_MAIN) == 0 )
                {
                g_InitialPane = PANE_MAIN;
                }
            else if ( szOpen.CompareNoCase(CMD_OPEN_ADV) == 0 )
                {
                g_InitialPane = PANE_ADVANCED;
                }
            else if ( szOpen.CompareNoCase(CMD_OPEN_TOUR) == 0 )
                {
                g_InitialPane = PANE_IE;
                g_InitialIELocation = INIT_IE_TOUR;
                }
/*
            else if ( szOpen.CompareNoCase(CMD_OPEN_WEBSITE) == 0 )
                {
                g_InitialPane = PANE_IE;
                g_InitialIELocation = INIT_IE_WEBSITE;
                }
            else if ( szOpen.CompareNoCase(CMD_OPEN_PUBWIZ) == 0 )
                {
                g_InitialPane = PANE_IE;
                g_InitialIELocation = INIT_IE_PUBWIZ;
                // prevent the tips dialog from coming up
                m_fShowedStartupTips = TRUE;
                }
*/
            }

        // Get next token
nextToken:
        pTok = _tcstok( NULL, CMD_SEPS );
        }

    return fAnswer;
    }

//-----------------------------------------------------
// In the event that another instance of this application is already
// running, we not only need to activate it and bring it to the foreground,
// but it should also handle the command line that was passed into this
// instance. The use may have dragged files only the publishing wizard for
// example and that should be sent to the publishing wizard.
// pWnd is the window of the other instance that we are targeting. The command
// line information has already been parsed and can be found the the globals
// declared above.
//
// In order to pass the command information from this instance to the other
// requires that we set up a shared memory structure. Then when we send the
// message to the other instance, it can get it. Upon return, we no longer
// need the shared memory, so we can clean it up.
void CPwsApp::SendCommandInfo( CWnd* pWnd )
    {
    HANDLE                      hFileMap = NULL;
    PPWS_INSTANCE_TRANSFER      pData = NULL;

    DWORD                       cbSharedSpace;

    // calculate how bit the shared space needs to be
    cbSharedSpace = sizeof(PWS_INSTANCE_TRANSFER);

    // add in enough to copy in the possibly wide character extra info string
    cbSharedSpace += (g_AdditionalIEURL.GetLength() + 1) * sizeof(WCHAR);

    // set up the shared memory space.
    hFileMap = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            cbSharedSpace,
            PWS_INSTANCE_TRANSFER_SPACE_NAME
            );
    if ( hFileMap == NULL )
        return;

    pData = (PPWS_INSTANCE_TRANSFER)MapViewOfFile(
                    hFileMap,
                    FILE_MAP_ALL_ACCESS,
                    0,
                    0,
                    cbSharedSpace
                    );

    if ( pData == NULL )
        {
        CloseHandle(hFileMap);
        return;
        }
    // blank it all out
    ZeroMemory( pData, cbSharedSpace );


    // copy in the parsed command line data
    pData->iTargetPane = g_InitialPane;
    pData->iTargetIELocation = g_InitialIELocation;
    _tcscpy( &pData->tchIEURL, (LPCTSTR)g_AdditionalIEURL );


    // send the message
    pWnd->SendMessage( WM_PROCESS_REMOTE_COMMAND_INFO );


    // clean up the shared memory
    UnmapViewOfFile( pData );
    CloseHandle(hFileMap);
    }

//-----------------------------------------------------
BOOL CPwsApp::InitInstance()
    {
    BOOL    fLeaveEarly = FALSE;

    // if there were options passed in to the command line, act on them without bringing
    // up any windows or anything
    if ( m_lpCmdLine[0] )
        {
        if ( DealWithParameters() )
            return FALSE;
        }

    // no parameters (or this is NT) - run normally
    CString sz;
    sz.LoadString( IDR_MAINFRAME );
    sz = sz.Left( sz.Find('\n') );

    // initialize the windows sockets layer
    WSADATA wsaData;
    INT err = WSAStartup(MAKEWORD(2,0), &wsaData);

    // see if another instance of this application is running
    CWnd* pPrevWind = CWnd::FindWindow( NULL, sz );
    if ( pPrevWind )
        {
        // pws is already running. Activate the previous one and quit
        pPrevWind->SetForegroundWindow();
        pPrevWind->ShowWindow(SW_RESTORE);
        // tell it to handle the command line information
        SendCommandInfo( pPrevWind );
        return FALSE;
        }

    // Initialize OLE libraries
    if (!AfxOleInit())
        {
        AfxMessageBox(IDP_OLE_INIT_FAILED);
        return FALSE;
        }

    // initialize the metabase interface
    if ( !FInitMetabaseWrapper(NULL) )
        return FALSE;

        AfxEnableControlContainer();

    // Standard initialization
    //#ifdef _AFXDLL
    Enable3dControls();             // Call this when using MFC in a shared DLL
    //#else
//      Enable3dControlsStatic();       // Call this when linking to MFC statically
    //#endif

    LoadStdProfileSettings();       // Load standard INI file options (including MRU)

    // Register document templates
    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CPwsDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CFormSelectionBar));
    AddDocTemplate(pDocTemplate);
    m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
        {
        COleTemplateServer::RegisterAll();

        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        return TRUE;
        }

    m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
    COleObjectFactory::UpdateRegistryAll();

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // finally, we need to redirect the winhelp file location to something more desirable
    sz.LoadString( IDS_HELPLOC_PWSHELP );

    // expand the path
    ExpandEnvironmentStrings(
        sz,                                         // pointer to string with environment variables
        g_szHelpLocation.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables
        MAX_PATH                                    // maximum characters in expanded string
       );
    g_szHelpLocation.ReleaseBuffer();

    // free the existing path, and copy in the new one
    free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(g_szHelpLocation);

    // set the name of the application correctly
    sz.LoadString( IDR_MAINFRAME );
    // cut it off so it is just the app name
    sz = sz.Left( sz.Find(_T('\n')) );
    // free the existing name, and copy in the new one
    free((void*)m_pszAppName);
    m_pszAppName = _tcsdup(sz);

    return TRUE;
    }

//------------------------------------------------------------------
void CPwsApp::OnFinalRelease()
    {
    FCloseMetabaseWrapper();
    WSACleanup();
    CWinApp::OnFinalRelease();
    }

//------------------------------------------------------------------
void CPwsApp::ShowTipsAtStartup()
    {
    m_fShowedStartupTips = TRUE;

    // show the tips tdialog - if requested
    CTipDlg dlg;
    if ( dlg.FShowAtStartup() )
        dlg.DoModal();
    }


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
    {
    public:
    CAboutDlg();

    // Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
    protected:
    //{{AFX_MSG(CAboutDlg)
    // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    };

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
    {
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
    }

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------
// App command to run the dialog
void CPwsApp::OnAppAbout()
    {
    // load the about strings
    CString         szAbout1;
    CString         szAbout2;
    szAbout1.LoadString(IDS_ABOUT_MAIN);
    szAbout2.LoadString(IDS_ABOUT_SECONDARY);
    // run the shell about dialog
    ShellAbout(  AfxGetMainWnd()->GetSafeHwnd(), szAbout1,szAbout2, LoadIcon(IDR_MAINFRAME) );
    }

/////////////////////////////////////////////////////////////////////////////
// CPwsApp commands

//------------------------------------------------------------------
BOOL CPwsApp::OnIdle(LONG lCount)
    {
    // if this is the startup - show the tips
    if ( !m_fShowedStartupTips )
        ShowTipsAtStartup();
    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwschart.h ===
// PWSChart.h : header file
//

enum {
    PWS_CHART_HOURLY = 0,
    PWS_CHART_DAILY
    };

enum {
    PWS_CHART_SESSIONS = 0,
    PWS_CHART_HITS,
    PWS_CHART_KB,
    PWS_CHART_HITS_PER_USER,
    PWS_CHART_KB_PER_USER,

    PWS_CHART_LAST
    };

/////////////////////////////////////////////////////////////////////////////
// CPWSChart window

class CPWSChart : public CStatic
{
// Construction
public:
    CPWSChart();
    void SetDataPointer( PVOID pData ) {m_pData = pData;}

    // controls what and how it draws
    void SetTimePeriod( WORD flag ) {m_period = flag;}
    void SetDataType( WORD flag ) {m_dataType = flag;}
    DWORD GetDataMax() {return m_max;}

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPWSChart)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CPWSChart();

    // draw the chart (public)
    void DrawChart();

    // Generated message map functions
protected:
    //{{AFX_MSG(CPWSChart)
    afx_msg void OnPaint();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    // get the appropriate, scaled data value
    DWORD GetDataValue( DWORD i );

    // draw the chart (protected)
    void DrawChart( CDC* dc );

    // the data
    PVOID       m_pData;
    WORD        m_period;
    WORD        m_dataType;
    DWORD       m_max;
    SYSTEMTIME  m_timeCurrent;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwsdoc.cpp ===
// pwsDoc.cpp : implementation of the CPwsDoc class
//

#include "stdafx.h"
#include "resource.h"
#include "pwsform.h"

#include "Title.h"
#include "HotLink.h"
#include "PWSChart.h"

#include "pwsDoc.h"
//#include "PwsForm.h"
#include "Tip.h"
#include "TipDlg.h"

#include "EdDir.h"
#include "FormMain.h"
#include "FormAdv.h"

#include <isvctrl.h>
#include "ServCntr.h"

#include "pwstray.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// location of the installation path in the registry
#define REG_INSTALL_PATH   _T("Software\\Microsoft\\InetStp")
#define REG_PATH_VAL       _T("InstallPath")

#define SZ_KEY_RUN_TRAY    _T("software\\microsoft\\windows\\currentversion\\run")
#define SZ_KEY_RUN_VALUE   _T("PWSTray")

#define SERVER_WINDOWCLASS_NAME TEXT(INET_SERVER_WINDOW_CLASS)

// globals
//extern CPwsForm*        g_p_FormView;
CPwsDoc*                g_p_Doc = NULL;

extern CFormMain*       g_FormMain;
extern IMSAdminBase*    g_pMBCom;
extern BOOL             g_fShutdownMode;


#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

/////////////////////////////////////////////////////////////////////////////
// CPwsDoc

IMPLEMENT_DYNCREATE(CPwsDoc, CDocument)

BEGIN_MESSAGE_MAP(CPwsDoc, CDocument)
    //{{AFX_MSG_MAP(CPwsDoc)
    ON_COMMAND(ID_START, OnStart)
    ON_COMMAND(ID_STOP, OnStop)
    ON_UPDATE_COMMAND_UI(ID_START, OnUpdateStart)
    ON_UPDATE_COMMAND_UI(ID_STOP, OnUpdateStop)
    ON_COMMAND(ID_PAUSE, OnPause)
    ON_UPDATE_COMMAND_UI(ID_PAUSE, OnUpdatePause)
    ON_COMMAND(ID_SHOW_TIPS, OnShowTips)
    ON_UPDATE_COMMAND_UI(ID_SHOW_TIPS, OnUpdateShowTips)
    ON_COMMAND(ID_HELP_DOCUMENTATION, OnHelpDocumentation)
    ON_COMMAND(ID_HELP_HELP_TROUBLESHOOTING, OnHelpHelpTroubleshooting)
    ON_UPDATE_COMMAND_UI(ID_CONTINUE, OnUpdateContinue)
    ON_COMMAND(ID_CONTINUE, OnContinue)
    ON_UPDATE_COMMAND_UI(ID_TRAYICON, OnUpdateTrayicon)
    ON_COMMAND(ID_TRAYICON, OnTrayicon)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CPwsDoc, CDocument)
        //{{AFX_DISPATCH_MAP(CPwsDoc)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //      DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

static const IID IID_IPws =
{ 0x35c43e1, 0x8464, 0x11d0, { 0xa9, 0x2d, 0x8, 0x0, 0x2b, 0x2c, 0x6f, 0x32 } };

BEGIN_INTERFACE_MAP(CPwsDoc, CDocument)
        INTERFACE_PART(CPwsDoc, IID_IPws, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPwsDoc construction/destruction

//------------------------------------------------------------------
CPwsDoc::CPwsDoc():
        m_ActionToDo( 0 ),
        m_ExpectedResult( 0 ),

        m_dwSinkCookie( 0 ),
        m_pEventSink( NULL ),
        m_pConnPoint( NULL ),
        m_fIsPWSTrayAvailable( FALSE )
        {
        EnableAutomation();
        AfxOleLockApp();
        g_p_Doc = this;

        OSVERSIONINFO info_os;
        info_os.dwOSVersionInfoSize = sizeof(info_os);

        // record what sort of operating system we are running on
        m_fIsWinNT = FALSE;
        if ( GetVersionEx( &info_os ) )
            {
            if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_NT )
                m_fIsWinNT = TRUE;
            }
        }

//------------------------------------------------------------------
CPwsDoc::~CPwsDoc()
    {
    TerminateSink();
    g_p_Doc = NULL;
    AfxOleUnlockApp();
    }

//------------------------------------------------------------------
// builds something akin to "http://boydm"
BOOL CPwsDoc::BuildHomePageString( CString &cs )
    {
    CHAR nameBuf[MAX_PATH+1];

    // if the server is not running, fail
    CW3ServerControl    serverController;
    if ( serverController.GetServerState() != MD_SERVER_STATE_STARTED )
        return FALSE;

    // start it off with the mandatory http header
    cs.LoadString( IDS_HTTP_HEADER );
    // get the host name of the machine
    gethostname( nameBuf, sizeof(nameBuf));
    cs += nameBuf;

    return TRUE;
    }

//------------------------------------------------------------------
BOOL CPwsDoc::InitializeSink()
    {
    IConnectionPointContainer * pConnPointContainer = NULL;
    HRESULT                     hRes;
    BOOL                        fSinkConnected = FALSE;

    // g_pMBCom is defined in wrapmb
    IUnknown*                   pmb = (IUnknown*)g_pMBCom;

    m_pEventSink = new CImpIMSAdminBaseSink();

    if ( !m_pEventSink )
        {
        return FALSE;
        }

    //
    // First query the object for its Connection Point Container. This
    // essentially asks the object in the server if it is connectable.
    //
    hRes = pmb->QueryInterface( IID_IConnectionPointContainer,
                                (PVOID *)&pConnPointContainer);
    if SUCCEEDED(hRes)
        {
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.
        hRes = pConnPointContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
                                                         &m_pConnPoint);

        if (SUCCEEDED(hRes))
            {
            hRes = m_pConnPoint->Advise( (IUnknown *)m_pEventSink,
                                  &m_dwSinkCookie);

            if (SUCCEEDED(hRes))
                {
                fSinkConnected = TRUE;
                }
            }

        if ( pConnPointContainer )
            {
            pConnPointContainer->Release();
            pConnPointContainer = NULL;
            }
        }

    if ( !fSinkConnected )
        {
        delete m_pEventSink;
        }

    return fSinkConnected;
    }


//------------------------------------------------------------------
void CPwsDoc::TerminateSink()
    {
    HRESULT hRes;

    if ( m_dwSinkCookie )
        {
        hRes = m_pConnPoint->Unadvise( m_dwSinkCookie );
        }

    // don't need to delete m_pEventSink because the Unadvise
    // above decrements is reference count and that causes it
    // to delete itself....
    }



//------------------------------------------------------------------
BOOL CPwsDoc::OnNewDocument()
        {
        if (!CDocument::OnNewDocument())
                return FALSE;

        if (!FInitServerInfo())
                return FALSE;

        // start up the sink
        InitializeSink();

        // see if the pwstray executable is available
        CString pathTray;
        if ( GetPWSTrayPath(pathTray) )
            {
            m_fIsPWSTrayAvailable = (GetFileAttributes(pathTray) != 0xFFFFFFFF);
            }

        // return success
        return TRUE;
        }

/////////////////////////////////////////////////////////////////////////////
// CPwsDoc serialization

//------------------------------------------------------------------
void CPwsDoc::Serialize(CArchive& ar)
        {
        if (ar.IsStoring())
                {
                }
        else
                {
                }
        }

/////////////////////////////////////////////////////////////////////////////
// CPwsDoc diagnostics

#ifdef _DEBUG
//------------------------------------------------------------------
void CPwsDoc::AssertValid() const
        {
        CDocument::AssertValid();
        }

//------------------------------------------------------------------
void CPwsDoc::Dump(CDumpContext& dc) const
        {
        CDocument::Dump(dc);
        }
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// Access to the server methods

//------------------------------------------------------------------
// initialize the location of the server - it is stored in the registry
BOOL CPwsDoc::FInitServerInfo()
        {
        DWORD           err;
        HKEY            hKey;

        DWORD           iType = REG_SZ;
        DWORD           cbPath = MAX_PATH+1;
        LPTSTR          pPath;

        // open the registry key, if it exists
        err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,     // handle of open key
                    REG_INSTALL_PATH,       // address of name of subkey to open
                    0,                      // reserved
                    KEY_READ,               // security access mask
                    &hKey                   // address of handle of open key
                    );

        // if we were not able to open the key, then there was an error in the installation
        if ( err != ERROR_SUCCESS )
        {
            AfxMessageBox( IDS_INSTALL_ERROR );
            return FALSE;
        }

        // set up the buffer
        pPath = m_szServerPath.GetBuffer( cbPath );

        // get the base installation path for the server executable
        err = RegQueryValueEx( hKey, REG_PATH_VAL, NULL, &iType, (PUCHAR)pPath, &cbPath );

        // release the name buffers
        m_szServerPath.ReleaseBuffer();

        // all done, close the key before leaving
        RegCloseKey( hKey );

        // check the error code and fail if necessary
        if ( err != ERROR_SUCCESS )
                AfxMessageBox( IDS_INSTALL_ERROR );

        // return success
        return (err == ERROR_SUCCESS);
        }

//------------------------------------------------------------------
// updates the state of the server. Affects both the status strings and the
// avis. Can be called from either a change notify or OnIdle.
void CPwsDoc::UpdateServerState()
    {
    }


//------------------------------------------------------------------
BOOL CPwsDoc::LauchAppIfNecessary()
        {
        BOOL                            f;
        STARTUPINFO                     startupInfo;
        PROCESS_INFORMATION processInfo;
        TCHAR    path[MAX_PATH+1];

        // if this is running under NT, skip this part
        OSVERSIONINFO   osver;
        osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx( &osver );

        if ( osver.dwPlatformId == VER_PLATFORM_WIN32_NT )
                return TRUE;

        // if the window is there, the exe is running and we don't have to do anything
        if ( FindWindow(SERVER_WINDOWCLASS_NAME, NULL) )
                return TRUE;

        CString szExeName;
        szExeName.LoadString( IDS_EXECUTABLE );

        ZeroMemory(&startupInfo,sizeof(STARTUPINFO));
        startupInfo.cb = sizeof(STARTUPINFO);

        CString szAppl;
        szAppl.LoadString( IDS_INETINFO_EXE );

        _tcscpy(path, m_szServerPath);
        _tcscat(path, _T("\\"));
        _tcscat(path, szAppl);

        //
        // the app is not running. Attempt to start the executable
        //
        f = CreateProcess( 
            (LPCTSTR)path,
            (LPTSTR)(LPCTSTR)szExeName,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,
            &startupInfo,
            &processInfo 
            );

        if ( !f )
                {
                AfxMessageBox( IDS_ERROR_START );
                // failure
                return FALSE;
                }

        // success
        return TRUE;
        }


//------------------------------------------------------------------
void CPwsDoc::PerformAction( DWORD action, DWORD expected )
    {
    }

//------------------------------------------------------------------
// if the service is running, stop it. If it is stopped, start it
void CPwsDoc::ToggleService()
    {
    }

/////////////////////////////////////////////////////////////////////////////
// CPwsDoc commands
//------------------------------------------------------------------
void CPwsDoc::OnUpdateShowTips(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( TRUE );
    }

//------------------------------------------------------------------
void CPwsDoc::OnUpdateStart(CCmdUI* pCmdUI)
    {
    CW3ServerControl    serverController;
    DWORD   dwState = serverController.GetServerState();
    pCmdUI->Enable( dwState == MD_SERVER_STATE_STOPPED );
    }

//------------------------------------------------------------------
void CPwsDoc::OnUpdateStop(CCmdUI* pCmdUI)
    {
    CW3ServerControl    serverController;
    DWORD   dwState = serverController.GetServerState();
    pCmdUI->Enable( (dwState == MD_SERVER_STATE_STARTED) ||
                (dwState == MD_SERVER_STATE_PAUSED) );
    }

//------------------------------------------------------------------
void CPwsDoc::OnUpdatePause(CCmdUI* pCmdUI)
    {
    CW3ServerControl    serverController;
    DWORD   dwState = serverController.GetServerState();
    pCmdUI->Enable( dwState == MD_SERVER_STATE_STARTED );
    }

//------------------------------------------------------------------
void CPwsDoc::OnUpdateContinue(CCmdUI* pCmdUI) 
    {
    CW3ServerControl    serverController;
    DWORD   dwState = serverController.GetServerState();
    pCmdUI->Enable( dwState == MD_SERVER_STATE_PAUSED );
    }

//------------------------------------------------------------------
void CPwsDoc::OnStart()
    {
    CW3ServerControl    serverController;
    serverController.StartServer();
    }

//------------------------------------------------------------------
void CPwsDoc::OnStop()
    {
    CW3ServerControl    serverController;
    serverController.StopServer();

    // if this is win95 and the main pane is showing, tell it to update
    if ( !m_fIsWinNT && g_FormMain )
        g_FormMain->UpdateServerState();
    }

//------------------------------------------------------------------
void CPwsDoc::OnPause()
    {
    CW3ServerControl    serverController;
    serverController.PauseServer();
    }

//------------------------------------------------------------------
void CPwsDoc::OnContinue() 
    {
    CW3ServerControl    serverController;
    serverController.ContinueServer();
    }

//------------------------------------------------------------------
void CPwsDoc::OnShowTips()
    {
    CTipDlg dlg;
    dlg.DoModal();
    }
/*
//------------------------------------------------------------------
void CPwsDoc::OnHelpFinder()
    {
    DWORD               err;

    // build the path to the help file
    CString szPath;
    szPath.LoadString( IDS_HELP_LOC );
    szPath = m_szServerPath + szPath;

    // use shellexecute to open the file
    ShellExecute( NULL, NULL, (PCHAR)(LPCSTR)szPath, NULL, NULL, SW_SHOW );
    err = GetLastError();
    if ( err )
        {
        // just re-use szPath
        szPath.LoadString(IDS_NO_HELP);
        szPath.Format( "%s\nError = %d", szPath, err );
        AfxMessageBox( szPath );
        }
    }
*/

//------------------------------------------------------------------
void CPwsDoc::OnHelpDocumentation() 
    {
    // this documentation only works if it is served. Thus, if the local
    // server is not running, we should tell that to the user.
    CW3ServerControl    serverController;
    if ( g_fShutdownMode || (serverController.GetServerState() != MD_SERVER_STATE_STARTED) )
        {
        AfxMessageBox( IDS_HELPERR_REQUIRES_SERVER );
        return;
        }

    // load the served help docs url
    CString szHelpURL;
    szHelpURL.LoadString( IDS_HELPLOC_DOCS );

    // use shellexecute to access the help via the browser
    ShellExecute(
        NULL,   // handle to parent window
        NULL,   // pointer to string that specifies operation to perform
        szHelpURL,  // pointer to filename or folder name string
        NULL,   // pointer to string that specifies executable-file parameters
        NULL,   // pointer to string that specifies default directory
        SW_SHOW     // whether file is shown when opened
       );
    }

//------------------------------------------------------------------
void CPwsDoc::OnHelpHelpTroubleshooting() 
    {
    // load the relative file path for the troublshooting
    CString szTroublePath;
    szTroublePath.LoadString( IDS_HELPLOC_README );

    // expand the path
    CString szExpandedPath;
    ExpandEnvironmentStrings(
        szTroublePath,                          // pointer to string with environment variables 
        szExpandedPath.GetBuffer(MAX_PATH + 1), // pointer to string with expanded environment variables  
        MAX_PATH                                // maximum characters in expanded string 
       );
    szExpandedPath.ReleaseBuffer();

    // use shellexecute to access the help via the browser
    ShellExecute(
        NULL,           // handle to parent window
        NULL,           // pointer to string that specifies operation to perform
        szExpandedPath, // pointer to filename or folder name string
        NULL,           // pointer to string that specifies executable-file parameters
        NULL,           // pointer to string that specifies default directory
        SW_SHOW         // whether file is shown when opened
       );
    }

//------------------------------------------------------------------
void CPwsDoc::OnUpdateTrayicon(CCmdUI* pCmdUI) 
    {
    // if the exe is available, show the right thing
    if ( m_fIsPWSTrayAvailable )
        {
        pCmdUI->Enable( TRUE );
        pCmdUI->SetCheck( (::FindWindow(PWS_TRAY_WINDOW_CLASS,NULL) != NULL) );
        }
    else
        {
        pCmdUI->Enable( FALSE );
        pCmdUI->SetCheck( FALSE );
        }
    }
//------------------------------------------------------------------
void CPwsDoc::OnTrayicon() 
    {
    HWND hwndTray = FindWindow(PWS_TRAY_WINDOW_CLASS,NULL);
    CString sz;

    // first, act directly on the application
    if ( hwndTray != NULL )
        {
        PostMessage( hwndTray, WM_CLOSE, 0, 0 );
        // make sure it doesn't start up again
        }
    // else start it up
    else
        {
        if ( GetPWSTrayPath( sz ) )
            {
            ShellExecute(
                NULL,   // handle to parent window
                NULL,   // pointer to string that specifies operation to perform
                sz,     // pointer to filename or folder name string
                NULL,   // pointer to string that specifies executable-file parameters
                NULL,   // pointer to string that specifies default directory
                0       // whether file is shown when opened
               );
            }
        // make sure it starts up again
        }

    // now write the proper value to the registry so that pwstray does, or doesn't
    // get launched the next time you log on to the system
    sz.LoadString( IDS_PWSTRAY_EXE );
    DWORD       err;
    HKEY        hKey;
    DWORD       cbdata = sizeof(TCHAR) * (sz.GetLength() + 1);

        // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key 
            SZ_KEY_RUN_TRAY,    // address of name of subkey to open 
            0,                  // reserved 
            KEY_WRITE,          // security access mask 
            &hKey               // address of handle of open key 
           );
    // if we did not open the key for any reason (say... it doesn't exist)
    // then show the icon
    if ( err != ERROR_SUCCESS )
        return;

    //do the right thing
    if ( hwndTray )
        {
        // remove it
        err = RegDeleteValue(
                hKey,                // handle of key 
                SZ_KEY_RUN_VALUE     // address of value name 
                );  
        }
    else
        {
        // add it
        err = RegSetValueEx(
                hKey,                // handle of key to query 
                SZ_KEY_RUN_VALUE,    // address of name of value to query 
                0,                   // reserved 
                REG_SZ,              // address of buffer for value type 
                (LPBYTE)(LPCTSTR)sz, // address of data buffer 
                cbdata               // address of data buffer size 
                );
        }

    // all done, close the key before leaving
    RegCloseKey( hKey );
    }

//------------------------------------------------------------------
BOOL CPwsDoc::GetPWSTrayPath( CString &sz )
    {
    if ( !GetSystemDirectory(sz.GetBuffer(MAX_PATH+1),MAX_PATH) )
        return FALSE;

    sz.ReleaseBuffer();
    // add on the executable part
    CString szExe;
    szExe.LoadString( IDS_PWSTRAY_EXE );
    sz += '\\';
    sz += szExe;
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwsform.h ===
/////////////////////////////////////////////////////////////////////////////
class CPWSForm : public CFormView
    {
    public:
    CPWSForm( UINT idd ) :
        CFormView(idd)
            {}
    virtual WORD GetContextHelpID() = 0;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwsdoc.h ===
// pwsDoc.h : interface of the CPwsDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CPwsDoc : public CDocument
{
protected: // create from serialization only
    CPwsDoc();
    DECLARE_DYNCREATE(CPwsDoc)

// Attributes
public:
    void ToggleService();

// Operations
public:
    // builds something akin to "http://boydm"
    BOOL BuildHomePageString( CString &cs );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPwsDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    //}}AFX_VIRTUAL

    // sink handlers
    BOOL InitializeSink();
    void TerminateSink();

// Implementation
public:
    virtual ~CPwsDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CPwsDoc)
    afx_msg void OnStart();
    afx_msg void OnStop();
    afx_msg void OnUpdateStart(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStop(CCmdUI* pCmdUI);
    afx_msg void OnPause();
    afx_msg void OnUpdatePause(CCmdUI* pCmdUI);
    afx_msg void OnShowTips();
    afx_msg void OnUpdateShowTips(CCmdUI* pCmdUI);
    afx_msg void OnHelpDocumentation();
    afx_msg void OnHelpHelpTroubleshooting();
    afx_msg void OnUpdateContinue(CCmdUI* pCmdUI);
    afx_msg void OnContinue();
    afx_msg void OnUpdateTrayicon(CCmdUI* pCmdUI);
    afx_msg void OnTrayicon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CPwsDoc)
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()

    BOOL FInitServerInfo();
    void UpdateServerState();

    BOOL LauchAppIfNecessary();
    void PerformAction( DWORD action, DWORD expected );

    BOOL GetPWSTrayPath( CString &sz );

    // the installation location of the server executable
    CString         m_szServerPath;

    // if an action is underway, record the action and the expected outcom
    // so that we can check for errors
    DWORD           m_ActionToDo;
    DWORD           m_ExpectedResult;


    // sink things
    DWORD                   m_dwSinkCookie;
    CImpIMSAdminBaseSink*   m_pEventSink;
    IConnectionPoint*       m_pConnPoint;

    BOOL                    m_fIsWinNT;

    BOOL                    m_fIsPWSTrayAvailable;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\pwsctrl.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pwsctrl.cpp

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    Johnson Apacible    (JohnsonA)  29-Apr-1997
    Boyd Multerer       (BoydM)     29-Apr-1997

--*/

#include "stdafx.h"

#include "resource.h"
#include <pwsdata.hxx>
#include <inetsvcs.h>

#include "pwsctrl.h"


#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

//------------------------------------------------------------------------
//BOOL W95StartW3SVC( LPCSTR pszPath, LPCSTR pszPathDir, PCHAR pszParams )
BOOL W95StartW3SVC( void )
    {
    HKEY        hKey;
    TCHAR       chPath[MAX_PATH+1];
    DWORD       cbPath;
    DWORD       err, type;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            REGKEY_STP,         // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
            );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
    return FALSE;

    cbPath = sizeof(chPath);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,               // handle of key to query
            REGKEY_INSTALLKEY,  // address of name of value to query
            NULL,               // reserved
            &type,              // address of buffer for value type
            (PUCHAR)chPath,     // address of data buffer
            &cbPath             // address of data buffer size
            );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // add on the file name
    CString sz = chPath;
    sz += _T("\\inetinfo.exe");

    // and do it to it!
    HINSTANCE res = ShellExecute(
        NULL,           // handle to parent window
        NULL,           // pointer to string that specifies operation to perform
        sz,             // pointer to filename or folder name string
        _T("-e w3svc"), // pointer to string that specifies executable-file parameters
        NULL,           // pointer to string that specifies default directory
        SW_HIDE         // whether file is shown when opened
       );

    return ( HandleToUlong(res) > 32 );

  /*

    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;

    ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
    startupInfo.cb = sizeof(STARTUPINFO);

    if ( !CreateProcess(
                pszPath,
                pszParams,
                NULL,
                NULL,
                FALSE,
                0,
                NULL,
                pszPathDir,
                &startupInfo,
                &processInfo) )
    {
        printf("Create process failed with %d\n",
            GetLastError());
        return FALSE;
    }
    return TRUE;
*/
}

//------------------------------------------------------------------------
BOOL
W95ShutdownW3SVC(
    VOID
    )
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEventA(NULL, TRUE, FALSE, PWS_SHUTDOWN_EVENT);

    if ( hEvent == NULL ) {
        return TRUE;    // not there
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);

    for (i=0; i < 25; i++) {
        if ( IsInetinfoRunning() ) {
            Sleep(500);
            continue;
        }
        break;
    }
    return TRUE;
}

//------------------------------------------------------------------------
BOOL
W95ShutdownIISADMIN(
    VOID
    )
{
    DWORD i;
    HANDLE hEvent;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IIS_AS_EXE_OBJECT_NAME));

    if ( hEvent == NULL ) {
        return(TRUE);
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {
        SetEvent( hEvent );
    }

    CloseHandle(hEvent);

    for (i=0; i < 20; i++) {

        if ( IsIISAdminRunning() ) {
            Sleep(500);
            continue;
        }

        break;
    }

    return(TRUE);
}

//------------------------------------------------------------------------
BOOL
IsIISAdminRunning(
    VOID
    )
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(IIS_AS_EXE_OBJECT_NAME));

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }

    return(fFound);
}

//------------------------------------------------------------------------
BOOL
IsInetinfoRunning(
    VOID
    )
{
    HANDLE hEvent;
    BOOL fFound = FALSE;

    hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));

    if ( hEvent != NULL ) {
        fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
        CloseHandle(hEvent);
    }
    return(fFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pws.rc
//
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define CG_IDR_POPUP_ADV_ROOT           103
#define IDR_MAINFRAME                   128
#define IDR_PWSTYPE                     129
#define CG_IDR_POPUP_ADV_VIRT           129
#define IDD_MAIN                        130
#define IDR_MAIN                        130
#define IDD_ADVANCED                    131
#define IDR_ADVANCED                    131
#define IDR_TOUR                        132
#define IDR_WEBSITE                     133
#define IDR_ABOUTME                     134
#define ID_AVI_CONT                     135
#define IDR_CONT                        135
#define IDR_START                       137
#define IDR_STOP                        138
#define IDR_STATIC                      139
#define IDB_LIST_IMAGES                 141
#define IDR_TEST                        143
#define IDD_SERV_ACTION                 144
#define IDR_ACTING                      145
#define IDD_DIRECTORY                   146
#define IDB_HOURS_LEGEND                149
#define IDB_DAYS_LEGEND                 150
#define IDB_LIGHTBULB                   151
#define IDD_TIP                         152
#define IDD_PAGE_MAIN                   153
#define IDD_PAGE_IE                     155
#define IDD_PAGE_ADV                    157
#define IDD_FORM_BAR                    158
#define IDI_PUBLISH                     160
#define IDS_RUNNING                     400
#define IDS_STOPPED                     401
#define IDC_BTN_START                   1000
#define IDC_BTN_STARTSTOP               1000
#define IDC_STATE_AVI                   1001
#define IDC_LIST                        1003
#define IDC_APPLY                       1004
#define IDC_DEFAULT_DOC                 1005
#define IDC_BROWSING_ALLOWED            1006
#define IDC_CHANGE                      1007
#define IDC_REMOVE                      1008
#define IDC_ADD                         1009
#define IDC_STATUS                      1010
#define IDC_CHART_OPTIONS               1011
#define IDC_RDO_HOUR                    1012
#define IDC_RDO_DAY                     1013
#define IDC_ANIMATE1                    1016
#define IDC_SERVICE_ACTION              1017
#define IDC_ENABLEDEFAULT               1018
#define IDC_STATIC_DEFAULT              1019
#define IDC_PATH                        1020
#define IDC_ALIAS                       1021
#define IDC_CHART                       1026
#define IDC_SESSIONS                    1027
#define IDC_Y_SCALE                     1028
#define IDC_HI_VALUE                    1028
#define IDC_LEGEND                      1029
#define IDC_REFRESH                     1030
#define IDC_NEXT                        1032
#define IDC_BACK                        1033
#define IDC_SHOWTIPS                    1034
#define IDC_TIP                         1036
#define IDC_PUB_LOC                     1038
#define IDC_HOME_LOC                    1039
#define IDC_BROWSE                      1040
#define IDC_CHART_LABEL                 1041
#define IDC_EXPLORER                    1043
#define IDC_TITLE_BAR                   1044
#define IDC_EDIT                        1048
#define IDC_TREE                        1050
#define IDC_ENABLE_DEFAULT              1051
#define IDC_DIR_BROWSE                  1053
#define IDC_SAVE_LOG                    1054
#define IDC_DEFAULT_TITLE               1055
#define IDC_START_TIME                  1058
#define IDC_START_DATE                  1059
#define IDC_ACTIVE_CONNECTIONS          1060
#define IDC_VISITORS                    1061
#define IDC_REQUESTS                    1062
#define IDC_BYTES_SERVED                1063
#define IDC_MAX_CONNECTIONS             1064
#define IDC_ON_AND_AVAILABLE            1065
#define IDC_CLICK_START                 1066
#define IDC_ACTIVE_CONNECTIONS_TITLE    1067
#define IDC_VISITORS_TITLE              1068
#define IDC_REQUESTS_TITLE              1069
#define IDC_BYTES_SERVED_TITLE          1070
#define IDC_MAX_CONNECTIONS_TITLE       1071
#define IDC_MONITORING_TITLE            1072
#define IDC_READ                        1073
#define IDC_WRITE                       1074
#define IDC_EXECUTE                     1075
#define IDC_ABOUTME                     1078
#define IDC_SCRIPTS                     1079
#define IDC_SOURCE                      1079
#define IDC_LOWVALUE                    1080
#define IDC_HOMEPAGE_LOC                1082
#define IDC_HOMEDIR_LOC                 1083
#define IDC_TIP_TEXT                    1087
#define IDC_ICON_TOUR                   1088
#define IDC_ICON_WEBSITE                1089
#define IDC_ICON_PUBWIZ                 1090
#define IDC_STATIC_PUBLISH              1091
#define IDC_STATIC_WEBSITE              1092
#define IDC_STATIC_ADVANCED             1093
#define IDC_RDO_NONE                    1096
#define IDC_RDO_SCRIPTS                 1097
#define IDC_RDO_EXECUTE                 1098
#define ID_START                        2001
#define ID_STOP                         2002
#define ID_PAUSE                        2003
#define ID_ADVANCED                     2004
#define ID_HOME_WIZARD                  2005
#define ID_PUB_WIZARD                   2006
#define ID_ABOUT                        2007
#define ID_TOUR                         2008
#define ID_SHOW_TIPS                    2011
#define ID_PGE_MAIN                     2012
#define ID_PGE_ADVANCED                 2013
#define ID_PGE_TOUR                     2014
#define ID_DELETE_VIRT                  2019
#define ID_ADD_VIRT                     2021
#define ID_PROPERTIES_VIRT              2022
#define ID_DELETE_ROOT                  2023
#define ID_EXPLORE_VIRT                 2024
#define ID_OPEN_VIRT                    2025
#define ID_BROWSE_VIRT                  2026
#define ID_PGE_WEB_SITE                 2029
#define ID_PGE_ABOUT_ME                 2030
#define ID_HELP_HELP_TROUBLESHOOTING    2031
#define ID_HELP_DOCUMENTATION           2032
#define ID_CONTINUE                     2033
#define ID_TRAYICON                     2034
#define IDS_INSTALL_ERROR               61204
#define IDS_EXECUTABLE                  61205
#define IDS_START                       61206
#define IDS_STOP                        61207
#define IDS_ERROR_START                 61208
#define IDS_ABOUT_MAIN                  61209
#define IDS_ABOUT_SECONDARY             61210
#define IDS_DIRECTORY                   61211
#define IDS_ALIAS                       61212
#define IDS_ERROR                       61213
#define IDS_FindMetaError               61214
#define IDS_MetaError                   61215
#define IDS_STARTING                    61216
#define IDS_STOPPING                    61217
#define IDS_PAUSING                     61218
#define IDS_CONTINUING                  61219
#define IDS_ACTION_ERROR                61220
#define IDS_ERR_PATH_INVALID            61221
#define IDS_CONFIRM_REMOVE              61222
#define IDS_PAUSED                      61223
#define IDS_HOME_DIRECTORY              61224
#define IDS_TIMEOUT                     61225
#define IDS_TIPS_FILE                   61226
#define IDS_TIPS_ERR                    61227
#define IDS_NO_HOME_PAGE                61228
#define IDS_NO_DEFAULT_DIR              61229
#define IDS_EMPTY_ALIAS                 61230
#define IDS_HELP_LOC                    61231
#define IDS_NO_HELP                     61232
#define IDS_INETINFO_EXE                61233
#define IDS_DISABLED                    61234
#define IDS_START_TIME                  61235
#define IDS_AM                          61236
#define IDS_PM                          61237
#define IDS_NOT_RUNNING                 61238
#define IDS_ON_AND_AVAILABLE            61239
#define IDS_OFF_AND_NAVAIL              61240
#define IDS_CLICK_STOP                  61241
#define IDS_CLICK_START                 61242
#define IDS_STARTING_WAIT               61243
#define IDS_DEF_ALIAS                   61244
#define IDS_ALIAS_IS_TAKEN              61245
#define IDS_BAD_ALIAS_CHAR              61246
#define IDS_HTTP_HEADER                 61247
#define IDS_DAYS                        61248
#define IDS_HOURS                       61249
#define IDS_HTML_TOUR                   61250
#define IDS_HTML_ABOUTME                61251
#define IDS_HTML_WEBSITE                61252
#define IDS_ADD_DIRECTORY               61253
#define IDS_EXE_PARAMETERS              61254
#define IDS_EXE_ERROR                   61255
#define IDS_EXE_QUIT_ERR                61256
#define IDS_SWITCH_START                61257
#define IDS_SWITCH_STOP                 61258
#define IDS_USAGE                       61259
#define IDS_TITLE_ABOUTME               61260
#define IDS_TITLE_WEBSITE               61261
#define IDS_TITLE_TOUR                  61262
#define IDS_ON_AND_NAVAIL               61263
#define IDS_CHOOSE_DIR                  61264
#define IDS_HELPLOC_DOCS                61265
#define IDS_HELPLOC_README              61266
#define IDS_HELPLOC_PWSHELP             61267
#define IDS_HELPERR_REQUIRES_SERVER     61268
#define IDS_HELPKEY_TOUR                61269
#define IDS_HELPKEY_ABOUTME             61270
#define IDS_HELPKEY_WEBSITE             61271
#define IDS_PAUSING_WAIT                61272
#define IDS_CONTINUING_WAIT             61273
#define IDS_PAUSED_NAVAIL               61274
#define IDS_CLICK_CONTINUE              61275
#define IDS_CONTINUE                    61276
#define IDS_PWSTRAY_PATH                61277
#define IDS_PWSTRAY_EXE                 61278
#define IDS_PLEASE_WAIT_IE_LOADING      61279
#define IDS_ERR_SERV_ABOUT              61280
#define IDS_ERR_SERV_WEB                61281
#define IDS_ERR_SERV_TOUR               61282
#define IDS_ERR_SERV_ADVANCED           61283
#define IDS_ERR_REMOVE_VIRT             61284
#define IDS_ERR_ADD_VIRT                61285
#define IDS_ILLEGAL_VIRT_DIR_CHARS      61286
#define IDS_ILLEGAL_PHYS_PATH_CHARS     61287
#define IDS_ERR_USE_VALID_DRIVE         61288
#define IDS_ERR_USE_VALID_DIR           61289
#define IDS_MAKE_DIRECTORY              61290
#define IDS_ERR_MAKE_DIRECTORY          61291
#define IDS_CHARTOPTS_RQPERDAY          61292
#define IDS_CHARTOPTS_RQPERHOUR         61293
#define IDS_CHARTOPTS_VPERDAY           61294
#define IDS_CHARTOPTS_VPERHOUR          61295
#define IDS_TITLE_FONT_NAME             61296
#define IDS_WRITEEXECUTE_WARNING        61297

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        162
#define _APS_NEXT_COMMAND_VALUE         2035
#define _APS_NEXT_CONTROL_VALUE         1100
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\selbarfm.cpp ===
// SelBarFm.cpp : implementation file
//

#include "stdafx.h"
#include "pwsform.h"

#include "Title.h"
#include "FormIE.h"
#include "MainFrm.h"
#include "ServCntr.h"

#include "SelBarFm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CMainFrame*     g_frame;
extern CPWSForm*       g_pCurrentForm;
extern BOOL            g_fShutdownMode;


/////////////////////////////////////////////////////////////////////////////
// CFormSelectionBar

IMPLEMENT_DYNCREATE(CFormSelectionBar, CFormView)

CFormSelectionBar::CFormSelectionBar()
    : CFormView(CFormSelectionBar::IDD)
{
    //{{AFX_DATA_INIT(CFormSelectionBar)
    //}}AFX_DATA_INIT
}

CFormSelectionBar::~CFormSelectionBar()
{
}

void CFormSelectionBar::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFormSelectionBar)
    DDX_Control(pDX, IDC_STATIC_ADVANCED, m_static_advanced);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFormSelectionBar, CFormView)
    //{{AFX_MSG_MAP(CFormSelectionBar)
    ON_BN_CLICKED(ID_PGE_MAIN, OnPgeMain)
    ON_BN_CLICKED(ID_PGE_ADVANCED, OnPgeAdvanced)
    ON_BN_CLICKED(ID_PGE_TOUR, OnPgeTour)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFormSelectionBar diagnostics

#ifdef _DEBUG
void CFormSelectionBar::AssertValid() const
{
    CFormView::AssertValid();
}

void CFormSelectionBar::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}
#endif //_DEBUG

// operations affecting the enable state of the selection bar
//---------------------------------------------------------------------------
// grays out the text for the pub wizard, web site, and advanced panels to
// indicate that they are not available
void CFormSelectionBar::ReflectAvailability()
    {
    BOOL    fServedSitesAreAvailable = !g_fShutdownMode;

    // test if the served sites are available
    // only bother querying the server is we are not shutdown. Doing
    // otherwise would access the metabase and thus cause it to launch
    if ( fServedSitesAreAvailable )
        {
        //get the state
        CW3ServerControl    serverControler;
        if ( serverControler.GetServerState() != MD_SERVER_STATE_STARTED )
            fServedSitesAreAvailable = FALSE;
        }

    // enable the served sites
//    m_static_publish.EnableWindow( fServedSitesAreAvailable );
//    m_static_website.EnableWindow( fServedSitesAreAvailable );

    // if we are not in shutdown mode, enable the advanced button
    m_static_advanced.EnableWindow( !g_fShutdownMode );
    }

/////////////////////////////////////////////////////////////////////////////
// CFormSelectionBar message handlers

//---------------------------------------------------------------------------
void CFormSelectionBar::OnPgeMain()
    {
    if ( g_frame )
        g_frame->GoToMain();
    }

//---------------------------------------------------------------------------
void CFormSelectionBar::OnPgeAdvanced()
    {
    if ( g_frame )
        g_frame->GoToAdvanced();
    }

//---------------------------------------------------------------------------
void CFormSelectionBar::OnPgeTour()
    {
    if ( g_frame )
        g_frame->GoToTour();
    }

/*
//---------------------------------------------------------------------------
void CFormSelectionBar::OnPgeAboutMe()
    {
    if ( g_frame )
        g_frame->GoToAboutMe();
    }

//---------------------------------------------------------------------------
void CFormSelectionBar::OnPgeWebSite()
    {
    if ( g_frame )
        g_frame->GoToWebSite();
    }
*/

//---------------------------------------------------------------------------
void CFormSelectionBar::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView) 
    {
    if ( g_pCurrentForm )
        g_frame->SetActiveView(g_pCurrentForm);
//    CFormView::OnActivateView(bActivate, pActivateView, pDeactiveView);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\selbarfm.h ===
// SelBarFm.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFormSelectionBar form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFormSelectionBar : public CFormView
{
protected:
    CFormSelectionBar();           // protected constructor used by dynamic creation
    DECLARE_DYNCREATE(CFormSelectionBar)

// Form Data
public:
    //{{AFX_DATA(CFormSelectionBar)
    enum { IDD = IDD_FORM_BAR };
    CStatic m_static_advanced;
    //}}AFX_DATA

// Attributes
public:

// Operations
public:
    
    // operations affecting the enable state of the selection bar
    void ReflectAvailability();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFormSelectionBar)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CFormSelectionBar();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
    //{{AFX_MSG(CFormSelectionBar)
    afx_msg void OnPgeMain();
    afx_msg void OnPgeAdvanced();
    afx_msg void OnPgeTour();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\sink.h ===
#ifndef _MD_SINK_
#define _MD_SINK_

#include <iadmw.h>

class CImpIMSAdminBaseSink : public IMSAdminBaseSink {

//    IMSAdminBaseSink

public:

    CImpIMSAdminBaseSink();
    ~CImpIMSAdminBaseSink();


    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE SinkNotify( 
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

private:
    ULONG m_dwRefCount;
};

#endif  //_MD_SINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\sink.cpp ===
#include "stdafx.h"
#include "pwsform.h"
#include <pwsdata.hxx>

#include "Title.h"
#include "HotLink.h"
#include "PWSChart.h"

#include "EdDir.h"
#include "FormMain.h"
#include "FormAdv.h"

extern CFormMain*           g_FormMain;
extern CFormAdvanced*       g_FormAdv;

//--------------------------------------------------------------------
CImpIMSAdminBaseSink::CImpIMSAdminBaseSink()
{
    m_dwRefCount=0;
}

//--------------------------------------------------------------------
CImpIMSAdminBaseSink::~CImpIMSAdminBaseSink()
{
}

//--------------------------------------------------------------------
HRESULT
CImpIMSAdminBaseSink::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMSAdminBaseSink) {
        *ppObject = (IMSAdminBaseSink*) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

//--------------------------------------------------------------------
ULONG
CImpIMSAdminBaseSink::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//--------------------------------------------------------------------
ULONG
CImpIMSAdminBaseSink::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CImpIMSAdminBaseSink::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
// we are not actually allowed to make any metadata calls here, so we need to notfy the
// appropriate view that it has work to do the next time there is time.

// however, we can let the views decide if they want this...
if ( g_FormMain )
    g_FormMain->SinkNotify( dwMDNumElements, pcoChangeList );
if ( g_FormAdv )
    g_FormAdv->SinkNotify( dwMDNumElements, pcoChangeList );

    // if it is a server state change, let the main app know about it
    if ( pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
        // we are only concerned with changes in the state of the server here
        // thus, we can just look for the MD_SERVER_STATE id
        for ( DWORD iElement = 0; iElement < dwMDNumElements; iElement++ )
            {
            // each change has a list of IDs...
            for ( DWORD iID = 0; iID < pcoChangeList[iElement].dwMDNumDataIDs; iID++ )
                {
                // look for the ids that we are interested in
                switch( pcoChangeList[iElement].pdwMDDataIDs[iID] )
                    {
                    case MD_SERVER_STATE:
                        PostMessage( AfxGetMainWnd()->m_hWnd, WM_UPDATE_SERVER_STATE, 0, 0 );;
                        break;
                    default:
                        // do nothing
                        break;
                    };
                }
            }
        }
    return (0);
}

//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CImpIMSAdminBaseSink::ShutdownNotify(void)
    {
    PostMessage( AfxGetMainWnd()->m_hWnd, WM_MAJOR_SERVER_SHUTDOWN_ALERT, 0, 0 );
    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\servcntr.h ===
class CW3ServerControl : public CObject
    {
    public:
    CW3ServerControl();

    #define STATE_TRY_AGAIN     (-1)

    int GetServerState();
    BOOL SetServerState( DWORD dwControlCode );

    BOOL StartServer( BOOL fOutputCommandLineInfo = FALSE );
    BOOL StopServer( BOOL fOutputCommandLineInfo = FALSE );
    BOOL PauseServer();
    BOOL ContinueServer();

    BOOL W95LaunchInetInfo();

    // get the inetinfo path
    static BOOL GetServerDirectory( CString &sz );

    private:

    BOOL m_fIsWinNT;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  pws.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

//list templates and such
#include <afxtempl.h>
#include <winsock2.h>
#include "pws.h"
#include <iiscnfg.h>
#include <pwsdata.hxx>
#include "sink.h"
#include "wrapmb.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\sources.inc ===
!include ..\..\..\..\place.inc

MAJORCOMP=pws
MINORCOMP=pws

TARGETNAME=pws
TARGETPATH=obj
TARGETTYPE=PROGLIB

UMTYPE=windows
UMENTRY=winmain
UMAPPL=pws
UMRES=$(O)\pws.res
DLLDEF=..\pws.def

SUBSYSTEM_VERSION=4.00

C_DEFINES=  /D_IISVERSION

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=stdafx.h


INCLUDES=\
        ..\..\pwstray;\
        ..\..\wrapmb;\
        ..\..\..\..\inc\chicago; \
        ..\..\..\..\inc; \
        ..\..\..\..\utils\mdtools\inc; \
        $(O)
	
USE_MIDL_FOR_MKTYPLIB=1

SOURCES=\
        ..\pws.odl      \
        ..\EdDir.cpp    \
        ..\guid.cpp     \
        ..\HotLink.cpp  \
        ..\MainFrm.cpp  \
        ..\FormAdv.cpp  \
        ..\FormIE.cpp   \
        ..\FormMain.cpp \
        ..\pws.cpp      \
        ..\PWSChart.cpp \
        ..\PWSCtrl.cpp  \
        ..\pwsDoc.cpp   \
        ..\ServCntr.cpp \
        ..\SelBarFm.cpp \
        ..\sink.cpp     \
        ..\TipDlg.cpp   \
        ..\Title.cpp    \
        ..\webbrows.cpp

UMLIBS=\
       ..\..\..\..\utils\mdtools\lib\$(O)\mdlib.lib  \
       $(PROJECT_ROOT)\iis\svcs\w3\filters\pwsdata\$(O)\pwsdata.lib \
       $(SDK_LIB_PATH)\kernel32.lib \
       $(SDK_LIB_PATH)\advapi32.lib \
       $(SDK_LIB_PATH)\comdlg32.lib \
       $(SDK_LIB_PATH)\comctl32.lib \
       $(SDK_LIB_PATH)\shell32.lib  \
       $(SDK_LIB_PATH)\gdi32.lib    \
       $(SDK_LIB_PATH)\netapi32.lib \
       $(SDK_LIB_PATH)\user32.lib   \
       $(SDK_LIB_PATH)\ole32.lib    \
       $(SDK_LIB_PATH)\oleaut32.lib \
       $(SDK_LIB_PATH)\uuid.lib     \
       $(SDK_LIB_PATH)\ws2_32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\srvactd.h ===
// SrvActD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServActionDlg dialog

class CServActionDlg : public CDialog
{
// Construction
public:
    CServActionDlg(CWnd* pParent = NULL);   // standard constructor

    virtual BOOL OnInitDialog();
//  void DoTheAction();
    // send the command to the server
    BOOL SendCommand();

    // how it knows what to do...
    DWORD   m_ActionToDo;
    DWORD   m_ExpectedResult;

// Dialog Data
    //{{AFX_DATA(CServActionDlg)
    enum { IDD = IDD_SERV_ACTION };
    CAnimateCtrl    m_canimate;
    CString m_sz_action;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CServActionDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CServActionDlg)
    afx_msg void OnTimer(UINT nIDEvent);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // check the response from the server
    void CheckResponse();

    // time the stop waiting
    DWORD   m_tmTimeout;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\servcntr.cpp ===
// a small object to query and control the state of the w3 server
// created  4/14/97     BoydM

#include "stdafx.h"
#include "resource.h"
#include "ServCntr.h"
#include "mbobjs.h"

#include "pwsctrl.h"

#include <isvctrl.h>


#define SERVER_WINDOWCLASS_NAME     INET_SERVER_WINDOW_CLASS

#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

extern BOOL            g_fShutdownMode;


//------------------------------------------------------------------------
CW3ServerControl::CW3ServerControl()
    {
    OSVERSIONINFO info_os;
    info_os.dwOSVersionInfoSize = sizeof(info_os);

    // record what sort of operating system we are running on
    m_fIsWinNT = FALSE;
    if ( GetVersionEx( &info_os ) )
        {
        if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_NT )
            m_fIsWinNT = TRUE;
        }
    }

//------------------------------------------------------------------------
int CW3ServerControl::GetServerState()
    {
    CWrapMetaBase   mb;
    DWORD           dw;

    // if the service is totally shut down, return stopped
    if ( g_fShutdownMode )
        return MD_SERVER_STATE_STOPPED;

    // see if inetinfo is running - win95 only
    if ( !m_fIsWinNT && !IsInetinfoRunning() )
        return MD_SERVER_STATE_STOPPED;
        
    // init the mb object. If it fails then the server app is probably not running
    if ( !mb.FInit() )
        {
        return MD_SERVER_STATE_STOPPED;
        }

    // open the metabase so we can get the current state
    if ( !mb.Open(MB_SERVER_KEY_UPDATE) )
        {
        return MD_SERVER_STATE_STOPPED;
        }

    // get the server status flag
    if ( !mb.GetDword( _T(""), MD_SERVER_STATE, IIS_MD_UT_SERVER, &dw ) )
        {
        DWORD err = GetLastError( );
        if ( err == RPC_E_SERVERCALL_RETRYLATER )
            {
            mb.Close();
            return STATE_TRY_AGAIN;
            }
        }
        // close the metabase object
    mb.Close();

    // return the obtained state
    return dw;
    }

//------------------------------------------------------------------------
BOOL CW3ServerControl::SetServerState( DWORD dwControlCode )
    {
    CWrapMetaBase   mb;
    BOOL            fSuccess = FALSE;
    CString         sz;
    DWORD           err;

    // if the metabase doesn't init, then the app isn't running - lauch it
    if ( !mb.FInit() )
        return FALSE;

    // open the metabase object
    if ( !mb.Open(SZ_MB_INSTANCE_OBJECT, METADATA_PERMISSION_WRITE) )
        {
        err = GetLastError();
        sz.LoadString( IDS_MetaError );
        sz.Format( _T("%s\nError = %d"), sz, err );
        AfxMessageBox( sz );
        return FALSE;
        }

    // set the verb into the metabase
    if ( !mb.SetDword( _T(""), MD_SERVER_COMMAND, IIS_MD_UT_SERVER, dwControlCode ) )
        {
        err = GetLastError();
        sz.LoadString( IDS_MetaError );
        sz.Format( _T("%s\nError = %d"), sz, err );
        AfxMessageBox( sz );
        }
    else
        fSuccess = TRUE;

    // close the object
    mb.Close();

    // return the success flag
    return fSuccess;
    }

//------------------------------------------------------------------------
BOOL CW3ServerControl::StartServer( BOOL fOutputCommandLineInfo )
    {
    // just set the state in the metabase to do our thing
    return SetServerState( MD_SERVER_COMMAND_START );
    }

//------------------------------------------------------------------------
BOOL CW3ServerControl::W95LaunchInetInfo()
    {
    // start it
    return W95StartW3SVC();
    }

//------------------------------------------------------------------------
BOOL CW3ServerControl::StopServer( BOOL fOutputCommandLineInfo )
    {
    // just set the state in the metabase to do our thing
    return SetServerState( MD_SERVER_COMMAND_STOP );
    }

//------------------------------------------------------------------------
BOOL CW3ServerControl::PauseServer()
    {
    // note that inetinfo must be running for this to work
    // in either case, we now just pause the server
    return SetServerState( MD_SERVER_COMMAND_PAUSE );
    }

//------------------------------------------------------------------------
BOOL CW3ServerControl::ContinueServer()
    {
    // note that inetinfo must be running for this to work
    // in either case, we now just pause the server
    return SetServerState( MD_SERVER_COMMAND_CONTINUE );
    }

//------------------------------------------------------------------------
// get the inetinfo path
BOOL CW3ServerControl::GetServerDirectory( CString &sz )
    {
        HKEY        hKey;
        TCHAR       chBuff[MAX_PATH+1];
        DWORD       err, type;
        DWORD       cbBuff;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key 
            REGKEY_STP,         // address of name of subkey to open 
            0,                  // reserved 
            KEY_READ,           // security access mask 
            &hKey               // address of handle of open key 
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    cbBuff = sizeof(chBuff);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,               // handle of key to query 
            REGKEY_INSTALLKEY,  // address of name of value to query 
            NULL,               // reserved 
            &type,              // address of buffer for value type 
            (PUCHAR)chBuff,             // address of data buffer 
            &cbBuff             // address of data buffer size 
           );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set the string
    sz = chBuff;

    // success
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\tipdlg.h ===
// TipDlg.h : header file
//
//{{AFX_INCLUDES()
#include "webbrows.h"
//}}AFX_INCLUDES

//-----------------------------------------------------------------------------
class CTipText : public CButton
{
// Construction
public:
// Attributes
public:

// Operations
public:
    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

// Implementation
public:

    // Generated message map functions
protected:
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CTipDlg dialog

class CTipDlg : public CDialog
{
// Construction
public:
    CTipDlg(CWnd* pParent = NULL);   // standard constructor
    virtual BOOL OnInitDialog();

    BOOL    FShowAtStartup();

// Dialog Data
    //{{AFX_DATA(CTipDlg)
    enum { IDD = IDD_TIP };
    CButton m_cbtn_back;
    CButton m_cbtn_next;
    BOOL        m_bool_showtips;
    CWebBrowser m_ie;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CTipDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CTipDlg)
    afx_msg void OnBack();
    afx_msg void OnNext();
    afx_msg void OnClose();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // record the show tips value
    void SaveShowTips();

    // get the path to the tips file
    void GetTipPath( CString &sz );

    // load a tip
    void LoadTip( int iTip );

    // data pertaining to the tips
    int nNumTips;
    int iCurTip;

    // starting tip
    int m_iStartTip;

    // the string that get pre-pended to the time file paths
    // in the tips.dat file
    CString szFileStarter;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\title.cpp ===
// Title.cpp : implementation file
//

#include "stdafx.h"
#include "Title.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_WHITE         RGB(0xFF, 0xFF, 0xFF)
#define COLOR_BLACK         RGB(0, 0, 0)

/////////////////////////////////////////////////////////////////////////////
// CStaticTitle

CStaticTitle::CStaticTitle():
    m_fInitializedFont( FALSE ),
    m_fTipText( FALSE )
    {
    }

CStaticTitle::~CStaticTitle()
    {
    }


BEGIN_MESSAGE_MAP(CStaticTitle, CButton)
    //{{AFX_MSG_MAP(CStaticTitle)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStaticTitle message handlers

//------------------------------------------------------------------------
void CStaticTitle::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add height
        logfont.lfHeight = 32;
        logfont.lfWidth = 0;
        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }

    // fill in the background of the rectangle
    pdc->FillSolidRect( &rect, GetSysColor(COLOR_3DFACE) );
    
    // draw the text
    CString sz;
    GetWindowText( sz );
    rect.left = 4;
    pdc->DrawText( sz, &rect, DT_LEFT|DT_SINGLELINE|DT_VCENTER );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\nt\stdafx.h ===
#include "..\stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\tip.h ===
// Tip.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTip window

class CTip : public CStatic
{
// Construction
public:
    CTip();
    virtual void OnDraw(CDC* pDC);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CTip)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CTip();

    // Generated message map functions
protected:
    //{{AFX_MSG(CTip)
    afx_msg void OnPaint();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\tipdlg.cpp ===
// TipDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "title.h"
#include "Tip.h"
#include "TipDlg.h"
#include "ServCntr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

#define SZ_PWS_SECTION      _T("Header")
#define SZ_NUM_TIPS         _T("TotalTips")
#define SZ_TIP_URL          _T("TipFile")

#define MAX_TIP_LENGTH      1000

/////////////////////////////////////////////////////////////////////////////
// CTipDlg dialog

//----------------------------------------------------------------
CTipDlg::CTipDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CTipDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CTipDlg)
    m_bool_showtips = FALSE;
    //}}AFX_DATA_INIT
//    m_ctitle_title.m_fTipText = TRUE;

    // get the inetsrv directory path and put it in szFileStarter
    CW3ServerControl::GetServerDirectory( szFileStarter );
    }

//----------------------------------------------------------------
void CTipDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTipDlg)
    DDX_Control(pDX, IDC_BACK, m_cbtn_back);
    DDX_Control(pDX, IDC_NEXT, m_cbtn_next);
    DDX_Check(pDX, IDC_SHOWTIPS, m_bool_showtips);
    DDX_Control(pDX, IDC_EXPLORER, m_ie);
    //}}AFX_DATA_MAP
    }

//----------------------------------------------------------------
BEGIN_MESSAGE_MAP(CTipDlg, CDialog)
    //{{AFX_MSG_MAP(CTipDlg)
    ON_BN_CLICKED(IDC_BACK, OnBack)
    ON_BN_CLICKED(IDC_NEXT, OnNext)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
BOOL CTipDlg::OnInitDialog()
{
    // initialize the show tips flag
    m_bool_showtips = FShowAtStartup();

    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // what is the name of the tips file?
    CString szTipFile;
    GetTipPath( szTipFile );

    // get the number of tip strings
    nNumTips = GetPrivateProfileInt( SZ_PWS_SECTION, SZ_NUM_TIPS, 0, szTipFile );
    // if there are no tips - or the file couldn't be found - do nothing
    if ( nNumTips > 0)
	{
		// Base the shown tip on the day. Cycle through the tips, one per day.
		SYSTEMTIME  time;
		GetLocalTime( &time );
		UINT        seed;
		seed = (time.wYear << 16) | (time.wMonth << 8) | (time.wDay);
		iCurTip = (seed % nNumTips) + 1;

		// record that starting tip
		m_iStartTip = iCurTip;

		// load the first tip
		LoadTip( iCurTip );
	}
	else
		EndDialog(0);
    // return the answer
    return f;
}

//----------------------------------------------------------------
void CTipDlg::LoadTip( int iTip )
    {
    LPTSTR  psz;
    DWORD   cbSz = MAX_TIP_LENGTH;
    
    // prepare the tips file name
    CString szTipFile;
    GetTipPath( szTipFile );

    // prepare the section name
    CString szSection;
    szSection.Format( _T("%d"), iTip );

    // lock down the tip buffer
    CString szTip;
    psz = szTip.GetBuffer( cbSz );

    // get the tip
    cbSz = GetPrivateProfileString( szSection, SZ_TIP_URL, _T(""), psz, cbSz, szTipFile );

    // release the tip buffer
    szTip.ReleaseBuffer( cbSz );

    // finish munging together the tip file path
    CString szTipeFile = _T("file://");
    szTipeFile += szFileStarter + szTip;

    // go to the tip
    CWaitCursor wait;
    m_ie.Navigate( szTipeFile, NULL, NULL, NULL,  NULL );


    // enable or disable the next/back buttons as appropriate
    // first check the next tip
    int iFutureTip;

    // figure out what the next tip would be
    iFutureTip = iTip + 1;
    if ( iFutureTip > nNumTips )
        iFutureTip = 1;
    // if it is the original tip, disable the next button
    m_cbtn_next.EnableWindow( (iFutureTip != m_iStartTip) );

    // only disable back if we are on the first tip
    m_cbtn_back.EnableWindow( (iTip != m_iStartTip) );
    }

/////////////////////////////////////////////////////////////////////////////
// CTipDlg message handlers

//----------------------------------------------------------------
void CTipDlg::OnBack()
    {
    // check for roll-over
    if ( iCurTip <= 1 )
        iCurTip = nNumTips;
    else
        iCurTip--;
    // load the tip
    LoadTip( iCurTip );
    }

//----------------------------------------------------------------
void CTipDlg::OnNext()
    {
    // increment the tip index
    iCurTip++;
    // check for roll-over
    if ( iCurTip > nNumTips )
        iCurTip = 1;
    // load the tip
    LoadTip( iCurTip );
    }

//----------------------------------------------------------------
void CTipDlg::GetTipPath( CString &sz )
    {
    HKEY        hKey;
    TCHAR       chPath[MAX_PATH+1];
    DWORD       cbPath;
    DWORD       err, type;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key 
            REGKEY_STP,         // address of name of subkey to open 
            0,                  // reserved 
            KEY_READ,           // security access mask 
            &hKey               // address of handle of open key 
            );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
    return;

    cbPath = sizeof(chPath);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,               // handle of key to query 
            REGKEY_INSTALLKEY,  // address of name of value to query 
            NULL,               // reserved 
            &type,              // address of buffer for value type 
            (PUCHAR)chPath,     // address of data buffer 
            &cbPath             // address of data buffer size 
            );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return;

    // the tips file is in the inetsrv directory
    CString szFile;
    szFile.LoadString( IDS_TIPS_FILE );
    // put it all together
    sz = chPath;
    sz += _T('\\');
    sz += szFile;
    }

//------------------------------------------------------------------------
void CTipDlg::SaveShowTips()
    {
    // save the value in the registry
    DWORD       err;
    HKEY        hKey;

    UpdateData( TRUE );

    BOOL        fShowTips = TRUE;
    DWORD       type = REG_DWORD;
    DWORD       data = m_bool_showtips;
    DWORD       cbData = sizeof(data);
    DWORD       dwDisposition;

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_CURRENT_USER,  // handle of open key
            SZ_REG_PWS_PREFS,   // address of name of subkey to open
            0,                  // reserved
            KEY_WRITE,          // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key, try creating a new one
    if ( err != ERROR_SUCCESS )
        {
        // try to make a new key
        err = RegCreateKeyEx(
            HKEY_CURRENT_USER, 
            SZ_REG_PWS_PREFS, 
            NULL, 
            _T(""), 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &hKey, 
            &dwDisposition 
            );

        // if we still didn't get the key - fail
        if ( err != ERROR_SUCCESS )
            return;
        }

    // save the value in the registry
    RegSetValueEx( hKey, SZ_REG_PWS_SHOWTIPS, NULL, type, (PUCHAR)&data, cbData );

    // all done, close the key before leaving
    RegCloseKey( hKey );
    }

//------------------------------------------------------------------------
void CTipDlg::OnOK() 
    {
    SaveShowTips(); 
    // call the default
    CDialog::OnOK();
    }

//------------------------------------------------------------------------
void CTipDlg::OnClose() 
    {
    SaveShowTips(); 
    // call the default
    CDialog::OnClose();
    }

//----------------------------------------------------------------
// returns a flag indicating if the tips should be shown at startup
BOOL CTipDlg::FShowAtStartup()
    {
    BOOL        fShowTips = TRUE;
    DWORD       err;
    HKEY        hKey;
    DWORD       type = REG_DWORD;
    DWORD       data;
    DWORD       cbData = sizeof(data);

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_CURRENT_USER,  // handle of open key
            SZ_REG_PWS_PREFS,   // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return fShowTips;

    // query the value of the registry
    err = RegQueryValueEx( hKey, SZ_REG_PWS_SHOWTIPS, NULL, &type, (PUCHAR)&data, &cbData );
    if ( err == ERROR_SUCCESS )
        fShowTips = data;

    // all done, close the key before leaving
    RegCloseKey( hKey );

    return fShowTips;
    }

//=============================================================================


#define COLOR_WHITE         RGB(0xFF, 0xFF, 0xFF)
#define COLOR_BLACK         RGB(0, 0, 0)

/////////////////////////////////////////////////////////////////////////////
// CTipText message handlers
BEGIN_MESSAGE_MAP(CTipText, CButton)
    //{{AFX_MSG_MAP(CStaticTitle)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
void CTipText::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
//    static m_fInitializedFont = FALSE;

    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    /*
    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add underlining
        logfont.lfHeight = 18;
        logfont.lfWidth = 0;
        logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_ROMAN;
        logfont.lfFaceName[0] = 0;

        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }
        */

    // fill in the background of the rectangle
    pdc->FillSolidRect( &rect, COLOR_WHITE );
    pdc->SetTextColor( COLOR_BLACK );
    
    // draw the text
    CString sz;
    GetWindowText( sz );
    pdc->DrawText( sz, &rect, DT_LEFT|DT_WORDBREAK );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\webbrows.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "webbrows.h"

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser

IMPLEMENT_DYNCREATE(CWebBrowser, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser properties

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser operations

unsigned long CWebBrowser::AddRef()
{
    unsigned long result;
    InvokeHelper(0x60000001, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
    return result;
}

unsigned long CWebBrowser::Release()
{
    unsigned long result;
    InvokeHelper(0x60000002, DISPATCH_METHOD, VT_I4, (void*)&result, NULL);
    return result;
}

void CWebBrowser::GoBack()
{
    InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoForward()
{
    InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoHome()
{
    InvokeHelper(0x66, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoSearch()
{
    InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
    static BYTE parms[] =
        VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
    InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         URL, Flags, TargetFrameName, PostData, Headers);
}

void CWebBrowser::Refresh()
{
    InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Refresh2(VARIANT* Level)
{
    static BYTE parms[] =
        VTS_PVARIANT;
    InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         Level);
}

void CWebBrowser::Stop()
{
    InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH CWebBrowser::GetApplication()
{
    LPDISPATCH result;
    InvokeHelper(0xc8, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

LPDISPATCH CWebBrowser::GetParent()
{
    LPDISPATCH result;
    InvokeHelper(0xc9, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

LPDISPATCH CWebBrowser::GetContainer()
{
    LPDISPATCH result;
    InvokeHelper(0xca, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

LPDISPATCH CWebBrowser::GetDocument()
{
    LPDISPATCH result;
    InvokeHelper(0xcb, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

BOOL CWebBrowser::GetTopLevelContainer()
{
    BOOL result;
    InvokeHelper(0xcc, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

CString CWebBrowser::GetType()
{
    CString result;
    InvokeHelper(0xcd, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
    return result;
}

long CWebBrowser::GetLeft()
{
    long result;
    InvokeHelper(0xce, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void CWebBrowser::SetLeft(long nNewValue)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0xce, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
         nNewValue);
}

long CWebBrowser::GetTop()
{
    long result;
    InvokeHelper(0xcf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void CWebBrowser::SetTop(long nNewValue)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0xcf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
         nNewValue);
}

long CWebBrowser::GetWidth()
{
    long result;
    InvokeHelper(0xd0, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void CWebBrowser::SetWidth(long nNewValue)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0xd0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
         nNewValue);
}

long CWebBrowser::GetHeight()
{
    long result;
    InvokeHelper(0xd1, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void CWebBrowser::SetHeight(long nNewValue)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0xd1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
         nNewValue);
}

CString CWebBrowser::GetLocationName()
{
    CString result;
    InvokeHelper(0xd2, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
    return result;
}

CString CWebBrowser::GetLocationURL()
{
    CString result;
    InvokeHelper(0xd3, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
    return result;
}

BOOL CWebBrowser::GetBusy()
{
    BOOL result;
    InvokeHelper(0xd4, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\webbrows.h ===
#ifndef __WEBBROWS_H__
#define __WEBBROWS_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser wrapper class

class CWebBrowser : public CWnd
{
protected:
    DECLARE_DYNCREATE(CWebBrowser)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xeab22ac3, 0x30c1, 0x11cf, { 0xa7, 0xeb, 0x0, 0x0, 0xc0, 0x5b, 0xae, 0xb } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
    // method 'QueryInterface' not emitted because of invalid return type or parameter type
    unsigned long AddRef();
    unsigned long Release();
    // method 'GetTypeInfoCount' not emitted because of invalid return type or parameter type
    // method 'GetTypeInfo' not emitted because of invalid return type or parameter type
    // method 'GetIDsOfNames' not emitted because of invalid return type or parameter type
    // method 'Invoke' not emitted because of invalid return type or parameter type
    void GoBack();
    void GoForward();
    void GoHome();
    void GoSearch();
    void Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
    void Refresh();
    void Refresh2(VARIANT* Level);
    void Stop();
    LPDISPATCH GetApplication();
    LPDISPATCH GetParent();
    LPDISPATCH GetContainer();
    LPDISPATCH GetDocument();
    BOOL GetTopLevelContainer();
    CString GetType();
    long GetLeft();
    void SetLeft(long nNewValue);
    long GetTop();
    void SetTop(long nNewValue);
    long GetWidth();
    void SetWidth(long nNewValue);
    long GetHeight();
    void SetHeight(long nNewValue);
    CString GetLocationName();
    CString GetLocationURL();
    BOOL GetBusy();
};

#endif // __WEBBROWS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\w95\stdafx.h ===
#include "..\stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pws\title.h ===
// Title.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStaticTitle window

class CStaticTitle : public CButton
{
// Construction
public:
    CStaticTitle();

// Attributes
public:

// Operations
public:
    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    BOOL    m_fTipText;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStaticTitle)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStaticTitle();

    // Generated message map functions
protected:
    //{{AFX_MSG(CStaticTitle)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)
        Boyd Multerer (boydm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//

#include "priv.h"
#include <objbase.h>
#include <initguid.h>
#include <shlguid.h>
#include <iwamreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\priv.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif

#define INC_OLE2        // WIN32, get ole2 from windows.h

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>

#include "resource.h"

// This project should be compiled MBCS
#ifndef _MBCS
#define _MBCS   // using MBCS enabling function
#endif

#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))

#define     WIDE_MAX_PATH               (MAX_PATH * sizeof(WCHAR) )

// These are the internal windows messages
enum {
    WM_UPDATE_SERVER_STATE = WM_USER + 1600,
    WM_UPDATE_ALIAS_LIST,
    WM_SHUTDOWN_NOTIFY,
    WM_INSPECT_SERVER_LIST
    };

// Timer ids
enum {
    PWS_TIMER_CHECKFORSERVERRESTART = 0
    };

// Timer times - milliseconds
#define TIMER_RESTART           5000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\eddir.cpp ===
// this is the internal content - specific stuff related to the
// CShellExt object

#include "priv.h"
#include <tchar.h>
#include <iiscnfgp.h>
//
#include <inetinfo.h>
#include <winsvc.h>
#include <iwamreg.h>
#include <shlwapi.h>

#include "wrapmb.h"
#include "Sink.h"
#include "eddir.h"
#include "shellext.h"

#include "wrapmb.h"


//the key type string for the virtual directories
#define MDSZ_W3_VDIR_TYPE                       _T("IIsWebVirtualDir")


extern HINSTANCE g_hmodThisDll;
//Handle to this DLL itself.

BOOL MakeWAMApplication (IN LPCTSTR pszPath, IN BOOL fCreate);
BOOL MyFormatString1 (IN LPTSTR pszSource, IN DWORD cchMax, LPTSTR pszReplace);

//---------------------------------------------------------------
INT_PTR CALLBACK
EditDirDlgProc (HWND hDlg,
		UINT uMessage,
		WPARAM wParam,
		LPARAM lParam)
{
  //the pointer to the object is passed in as the private lParam, store it away
  if (uMessage == WM_INITDIALOG)
  {
     SetWindowLongPtr (hDlg, DWLP_USER, lParam);
  }

  //dialog object pointer from the window
  CEditDirectory * pdlg = (CEditDirectory *) GetWindowLongPtr (hDlg, DWLP_USER);
  if (!pdlg)
     return FALSE;

  //let the object do the work
  return pdlg->OnMessage (hDlg, uMessage, wParam, lParam);
}

  //=====================================================================================


  //---------------------------------------------------------------
CEditDirectory::CEditDirectory (HWND hParent):
      m_hParent (hParent),
      m_bool_read (FALSE),
      m_bool_write (FALSE),
      m_bool_dirbrowse (FALSE),
      m_bool_source (FALSE),
      m_bool_oldSource (FALSE),
      m_int_AppPerms (APPPERM_NONE),
//      m_pMBCom (NULL),
      m_fNewItem (FALSE),
      m_hDlg (NULL)
{
}

  //---------------------------------------------------------------
CEditDirectory::~CEditDirectory ()
{
}

//---------------------------------------------------------------
INT_PTR CEditDirectory::DoModal ()
{
   return DialogBoxParam (
			    g_hmodThisDll,	//handle to application instance
			    MAKEINTRESOURCE (IDD_ALIAS),	//identifies dialog box template
			    m_hParent,	//handle to owner window
			    EditDirDlgProc,	//pointer to dialog box procedure
			    (LPARAM) this	// initialization value
    );
}

//---------------------------------------------------------------
//return FALSE if we do NOT handle the message
BOOL CEditDirectory::OnMessage (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   switch (uMsg)
	{
	case WM_INITDIALOG:
	   //return success
	   return OnInitDialog (hDlg);

	case WM_COMMAND:
	   switch (LOWORD (wParam))
	   {
	   case IDC_FULLCONTROL:
	      OnSource (hDlg);
	      return TRUE;
	   case IDC_READ:
	      OnRead (hDlg);
	      return TRUE;
      case IDC_WRITE:
	      OnWrite (hDlg);
	      return TRUE;
	   case IDOK:
	      OnOK (hDlg);
	      return TRUE;
	   case IDCANCEL:
	      EndDialog (IDCANCEL);
	      return TRUE;
	   }
	   break;
	};

   //return whether or not we handled the message
   return FALSE;
}

//----------------------------------------------------------------
//CDialog simulation routines
void CEditDirectory::UpdateData (BOOL fDialogToData)
{
   //get the data from the dialog
   if (fDialogToData)
   {
	   //get the text items first
	   GetWindowText (m_hEditAlias, m_sz_alias, MAX_PATH);
	   GetWindowText (m_hEditPath, m_sz_path, MAX_PATH);

	   //read the checkboxes
	   m_bool_read = (SendMessage (m_hChkRead, BM_GETCHECK, 0, 0) == BST_CHECKED);
	   m_bool_write = (SendMessage (m_hChkWrite, BM_GETCHECK, 0, 0) == BST_CHECKED);
	   m_bool_dirbrowse = (SendMessage (m_hChkDirBrowse, BM_GETCHECK, 0, 0) == BST_CHECKED);
	   m_bool_source = (SendMessage (m_hChkSource, BM_GETCHECK, 0, 0) == BST_CHECKED);

	   //read the AppPerm radio buttons
	   if (SendMessage (m_hRdoScripts, BM_GETCHECK, 0, 0) == BST_CHECKED)
	   {
	      m_int_AppPerms = APPPERM_SCRIPTS;
	   }
	   else if (SendMessage (m_hRdoExecute, BM_GETCHECK, 0, 0) == BST_CHECKED)
	   {
	      m_int_AppPerms = APPPERM_EXECUTE;
	   }
	   else
	   {
	      m_int_AppPerms = APPPERM_NONE;
	   }
   }
   else
   {
	   //put it back into the dialog
	   // set the text items first
	   SetWindowText (m_hEditAlias, m_sz_alias);
	   SetWindowText (m_hEditPath, m_sz_path);

	   //set the checkboxes
	   SendMessage (m_hChkRead, BM_SETCHECK, m_bool_read ? BST_CHECKED :
		     BST_UNCHECKED, 0);
	   SendMessage (m_hChkWrite, BM_SETCHECK, m_bool_write ? BST_CHECKED :
		     BST_UNCHECKED, 0);
	   SendMessage (m_hChkDirBrowse, BM_SETCHECK, m_bool_dirbrowse ?
		     BST_CHECKED : BST_UNCHECKED, 0);
	   SendMessage (m_hChkSource, BM_SETCHECK, m_bool_source ? BST_CHECKED
		     : BST_UNCHECKED, 0);

	   //set the AppPerm radio buttons
	   SendMessage (m_hRdoNone, BM_SETCHECK,
		     (m_int_AppPerms == APPPERM_NONE) ? BST_CHECKED : BST_UNCHECKED, 0);
	   SendMessage (m_hRdoScripts, BM_SETCHECK,
		     (m_int_AppPerms == APPPERM_SCRIPTS) ? BST_CHECKED : BST_UNCHECKED, 0);
	   SendMessage (m_hRdoExecute, BM_SETCHECK,
		     (m_int_AppPerms == APPPERM_EXECUTE) ? BST_CHECKED : BST_UNCHECKED, 0);
   }
}

//----------------------------------------------------------------
BOOL CEditDirectory::InitHandles (HWND hDlg)
{
   m_hDlg = hDlg;
   m_hEditAlias = GetDlgItem (hDlg, IDC_ALIAS);
   m_hEditPath = GetDlgItem (hDlg, IDC_PATH);

   m_hChkRead = GetDlgItem (hDlg, IDC_READ);
   m_hChkWrite = GetDlgItem (hDlg, IDC_WRITE);
   m_hChkDirBrowse = GetDlgItem (hDlg, IDC_DIRBROWSE);
   m_hChkSource = GetDlgItem (hDlg, IDC_FULLCONTROL);

   m_hRdoNone = GetDlgItem (hDlg, IDC_RDO_NONE);
   m_hRdoExecute = GetDlgItem (hDlg, IDC_RDO_EXECUTE);
   m_hRdoScripts = GetDlgItem (hDlg, IDC_RDO_SCRIPTS);
   return TRUE;
}

//----------------------------------------------------------------
BOOL CEditDirectory::OnInitDialog (HWND hDlg)
{
   BOOL f = FALSE;
   CWrapMetaBase mb;
   DWORD dword;
   TCHAR sz[MAX_PATH];

   InitHandles (hDlg);
   ZeroMemory (sz, MAX_PATH);
   //keep a copy of the original alias for later verification
   StrCpy (m_szOrigAlias,
	      *m_sz_alias == _T ('/') ? m_sz_alias + 1 : m_sz_alias);
   StrCpy (m_sz_alias, m_szOrigAlias);

   //open up the metabase and read in the initial values
   // first things first.init the mb object
   if (!mb.FInit (m_pMBCom))
   {
	   goto cleanup;
   }

   //build the metapath
   StrCpy (sz, m_szRoot);
   StrCat (sz, _T ("/"));
   StrCat (sz, m_sz_alias);

   //open the object - use root defaults if this is a new item
   if (m_fNewItem || !mb.Open (sz))
   {
	   //if the node doesn 't exist - get the default values of the root
	   if (!mb.Open (m_szRoot))
	   {
	      //if that doesn 't work - fail
	    goto cleanup;
	   }
   }

   //read the flags
   if (mb.GetDword (_T (""), MD_ACCESS_PERM, IIS_MD_UT_FILE, &dword, METADATA_INHERIT))
   {
	   //interpret that thing
	   m_bool_read = (dword & MD_ACCESS_READ) > 0;
	   m_bool_write = (dword & MD_ACCESS_WRITE) > 0;
	   m_bool_source = (dword & MD_ACCESS_SOURCE) > 0;

	   //choose the correct app permissions radio button
	   m_int_AppPerms = APPPERM_NONE;
	   if (dword & MD_ACCESS_EXECUTE)
	   {
	      m_int_AppPerms = APPPERM_EXECUTE;
	   }
	   else if (dword & MD_ACCESS_SCRIPT)
	   {
	      m_int_AppPerms = APPPERM_SCRIPTS;
	   }
   }

   //the dir browsing flag is stored in a different field
   if (mb.GetDword (_T (""), MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, &dword, METADATA_INHERIT))
   {
	   m_bool_dirbrowse = (dword & MD_DIRBROW_ENABLED) > 0;
   }

   //close the metabase
   mb.Close ();

   //if this is a new item, force the app perms to scripts
   if (m_fNewItem)
   {
	   m_int_AppPerms = APPPERM_SCRIPTS;
   }

   //set the data into place
   UpdateData (FALSE);

   //prep the source control button
   m_bool_oldSource = m_bool_source;
   EnableSourceControl ();

cleanup:
   return f;
}

//----------------------------------------------------------------
//we need to make sure that there is something in the alias field
// an empty alias is not OK
void CEditDirectory::OnOK (HWND hDlg)
{
   BOOL f;
   DWORD err;
   DWORD dword;
   int iPar;
   CWrapMetaBase mb;

   TCHAR szPath[MAX_PATH];
   TCHAR szParent[MAX_PATH];
   TCHAR sz[MAX_PATH];
   TCHAR szCaption[MAX_PATH];
   ZeroMemory (sz, MAX_PATH);
   ZeroMemory (szPath, MAX_PATH);
   ZeroMemory (szParent, MAX_PATH);
   ZeroMemory (szCaption, MAX_PATH);

   UpdateData (TRUE);

   //trim leading and trailing spaces
   TrimLeft (m_sz_alias);
   TrimRight (m_sz_alias);

   //first test is to see if there is anything in it
   if (*m_sz_alias == 0)
   {
	   LoadString (g_hmodThisDll, IDS_PAGE_TITLE, szCaption, MAX_PATH);
	   LoadString (g_hmodThisDll, IDS_EMPTY_ALIAS, sz, MAX_PATH);
	   MessageBox (hDlg, sz, szCaption, MB_OK);
	   goto cleanup;
   }

   //at this point we need to check if write and execute / script are set as this
   // could open a potential security hole.If they are set, then alert the user
   // and ask if they reall really want to do that
   if (  m_bool_write 
      && ((m_int_AppPerms == APPPERM_SCRIPTS) || (m_int_AppPerms == APPPERM_EXECUTE))
      )
	{
	   LoadString (g_hmodThisDll, IDS_WRITEEXECUTE_WARNING, sz, MAX_PATH);
	   LoadString (g_hmodThisDll, IDS_WARNING, szCaption, MAX_PATH);
	   if (MessageBox (hDlg, sz, szCaption, MB_YESNO |
	            MB_ICONEXCLAMATION) != IDYES)
	      goto cleanup;
	}

   //get ready
   if (!mb.FInit (m_pMBCom))
      goto cleanup;
   
   //next, if a parent has been specified, it must exist
   // the alias may not contain a '/' character
   if (NULL != StrPBrk (m_sz_alias, _T ("\\/")))
   {
	   LPTSTR pPar = StrRChr (m_sz_alias, NULL, _T ('/'));
	   if (NULL == pPar)
	      pPar = StrRChr (m_sz_alias, NULL, _T ('\\'));

	   //make the parental path
	   StrCpy (szParent, m_szRoot);
	   StrCat (szParent, _T ("/"));
	   StrCatN (szParent, m_sz_alias, m_sz_alias - pPar);

	   //make sure the parent is there
	   if (!mb.Open (szParent))
	   {
	      LoadString (g_hmodThisDll, IDS_PAGE_TITLE, szCaption, MAX_PATH);
	      LoadString (g_hmodThisDll, IDS_NO_PARENT, sz, MAX_PATH);
	      MessageBox (hDlg, sz, szCaption, MB_OK);
	      goto cleanup;
	   }
	   //close right away - we are ok
	   mb.Close ();
   }

   //Now we need to make sure that alias isn 't already taken
   _tcscpy (szPath, m_szRoot);
   _tcscat (szPath, _T ("/"));
   _tcscat (szPath, m_sz_alias);

   //try to open the object
   // however, if it is not a new object, and the alias has not changed,
   // do not see if the object is there becuase we know that it is and it is ok in this case
   if (_tcsicmp (m_sz_alias, m_szOrigAlias) || m_fNewItem)
	{
	   if (mb.Open (szPath))
	   {
	      //we did open it ! Close it right away
	      mb.Close ();
	      //tell the user to pick another name
	      LoadString (g_hmodThisDll, IDS_ALIAS_IS_TAKEN, sz, MAX_PATH);
	      LoadString (g_hmodThisDll, IDS_PAGE_TITLE, szCaption, MAX_PATH);
	      MyFormatString1 (sz, MAX_PATH, m_sz_alias);
	      MessageBox (hDlg, sz, szCaption, MB_OK);
	      goto cleanup;
	   }
	}

   SetCursor (LoadCursor (NULL, IDC_WAIT));

   //if the name has changed, delete the old one
   if (_tcscmp (m_szOrigAlias, m_sz_alias) && !m_fNewItem)
   {
	   //first we have to open the root
	   if (mb.Open (m_szRoot, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE))
	   {
	      MakeWAMApplication (m_szOrigAlias, FALSE);
	      f = mb.DeleteObject (m_szOrigAlias);
	      mb.Close ();
	   }
   }

   //if we are creating a new object - then do so
   if (_tcscmp (m_szOrigAlias, m_sz_alias) || m_fNewItem)
	{
	   //first we have to open the root
	   if (mb.Open (m_szRoot, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE))
	   {
	      f = mb.AddObject (m_sz_alias);
	      //set the key type
	      f = mb.SetString (m_sz_alias, MD_KEY_TYPE, IIS_MD_UT_SERVER,
				      MDSZ_W3_VDIR_TYPE, 0);
	      mb.Close ();

	      //create the WAM application at the new virtual directory location
	      MakeWAMApplication (szPath, TRUE);
	   }
	   else
	      err = GetLastError ();
	}

   //make sure we have the right path again
   _tcscpy (szPath, m_szRoot);
   _tcscat (szPath, _T ("/"));
   _tcscat (szPath, m_sz_alias);

   //open the target new item and write out its parameters
   if (mb.Open (szPath, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE))
   {
	   //set the path into place
	   f = mb.SetString (_T (""), MD_VR_PATH, IIS_MD_UT_FILE, m_sz_path);

	   //put the access flags into place.There are other flags than the ones that are manupulated
	   // here, so be careful to read the value first, then flip the flags, then write it back
	   dword = 0;
	   mb.GetDword (_T (""), MD_ACCESS_PERM, IIS_MD_UT_FILE, &dword, METADATA_INHERIT);
	   //read permissions
	   if (m_bool_read)
	      dword |= MD_ACCESS_READ;
	   else
	      dword &= ~MD_ACCESS_READ;

	   // write permissions
	   if (m_bool_write)
	      dword |= MD_ACCESS_WRITE;
	   else
	      dword &= ~MD_ACCESS_WRITE;

	   // source read permissions
	   if (m_bool_source)
	      dword |= MD_ACCESS_SOURCE;
	   else
	      dword &= ~MD_ACCESS_SOURCE;

	   // since the app permissions are now a set of radio buttons, use a case to discern
	   switch (m_int_AppPerms)
	   {
	   case APPPERM_NONE:
	      dword &= ~MD_ACCESS_SCRIPT;
	      dword &= ~MD_ACCESS_EXECUTE;
	      break;
	   case APPPERM_SCRIPTS:
	      dword |= MD_ACCESS_SCRIPT;
	      dword &= ~MD_ACCESS_EXECUTE;
	      break;
	   case APPPERM_EXECUTE:
	      dword |= MD_ACCESS_SCRIPT;
	      dword |= MD_ACCESS_EXECUTE;
	      break;
	   };

	   //write the dword back into the metabase
	   f = mb.SetDword (_T (""), MD_ACCESS_PERM, IIS_MD_UT_FILE, dword);

	   //------------------
	   //the dir browsing flag is stored in a different field - so do it again
	   dword = 0;
	   mb.GetDword (_T (""), MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, &dword, METADATA_INHERIT);

	   //script permissions
	   if (m_bool_dirbrowse)
	      dword |= MD_DIRBROW_ENABLED;
	   else
	      dword &= ~MD_DIRBROW_ENABLED;

	   // write the dword back into the metabase
	   f = mb.SetDword (_T (""), MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, dword);


	   //finish up
	   mb.Close ();
	}

	//make sure the string goes back
	UpdateData (FALSE);

	// do the default...
	EndDialog (IDOK);

	//cleanup the strings
cleanup:
	SetCursor (LoadCursor (NULL, IDC_ARROW));
}
	
//----------------------------------------------------------------
void CEditDirectory::EnableSourceControl ()
{
   //get the currect button values
	UpdateData (TRUE);

	//if both read and write are unchecked, then we clear and disable source control
	if (!m_bool_read && !m_bool_write)
	{
	   //save the value of source control
	   m_bool_oldSource = m_bool_source;

	   //clear the source control
	   m_bool_source = FALSE;
	   UpdateData (FALSE);

	   //disable the source control window
	   EnableWindow (m_hChkSource, FALSE);
	}
	else
	{
	   //we enable source control
	   // disable the source control window
	   EnableWindow (m_hChkSource, TRUE);

	   //and set the value back
	   m_bool_source = m_bool_oldSource;
	   UpdateData (FALSE);
   }
}

//----------------------------------------------------------------
void CEditDirectory::OnRead (HWND hDlg)
{
   EnableSourceControl ();
}

//----------------------------------------------------------------
void CEditDirectory::OnWrite (HWND hDlg)
{
   EnableSourceControl ();
}

//----------------------------------------------------------------
void CEditDirectory::OnSource (HWND hDlg)
{
   UpdateData (TRUE);
	m_bool_oldSource = m_bool_source;
}

//----------------------------------------------------------------
//return an index to the position of first ch in pszSearch in the string
// or return -1 if none are there
int CEditDirectory::FindOneOf (LPTSTR psz, LPCTSTR pszSearch)
{
   PTCHAR p = _tcspbrk (psz, pszSearch);
	if (!p)
	   return -1;
	return (int) (p - psz);
}

//----------------------------------------------------------------
//return an index to the position of ch in the string
// or return -1 if it is not there
int CEditDirectory::FindLastChr (LPTSTR psz, TCHAR ch)
{
   PTCHAR p = _tcsrchr (psz, ch);
	if (!p)
	   return -1;
	return (int) (p - psz);
}

//----------------------------------------------------------------
//trim leading whitespace
void CEditDirectory::TrimLeft (LPTSTR psz)
{
   TCHAR buf[8];
   ZeroMemory (&buf, sizeof (buf));

	  //copy over the first character
	    _tcsncpy (buf, psz, 1);
	  //and compare
	  while (_tcscmp (buf, _T (" ")) == 0)
	    {
	      _tcscpy (psz, _tcsinc (psz));
	      _tcsncpy (buf, psz, 1);
	    }
	}

//----------------------------------------------------------------
//trim trailing whitespace
void CEditDirectory::TrimRight (LPTSTR psz)
{
   TCHAR buf[8];
	DWORD len;

	ZeroMemory (&buf, sizeof (buf));

	//copy over the last character
	len = _tcslen (psz);
	_tcsncpy (buf, _tcsninc (psz, len - 1), 1);
	//and compare
	while (_tcscmp (buf, _T (" ")) == 0)
	    {
	      //truncate the string
	      *(_tcsninc (psz, len - 1)) = 0;
	      //start over
	      len = _tcslen (psz);
	      _tcsncpy (buf, _tcsninc (psz, len - 1), 1);
	    }
	}

#if 0
	 

	//----------------------------------------------------------------

	//trim trailing whitespace 

	void CEditDirectory::TrimRight (LPTSTR psz) 

	{
	  

	  TCHAR buf[8];
	  

	  DWORD len;
	  

	  

	  ZeroMemory (&buf, sizeof (buf));
	  

	  

	  //copy over the last character 

	  len = _tcslen (psz);
	  

	  _tcsncpy (buf, _tcsninc (psz, len - 1), 1);
	  

	  //and compare 

	  while (_tcscmp (buf, _T (" ")) == 0)
	    

	    {
	      

	      //truncate the string 

		*(_tcsninc (psz, len - 1)) = 0;
	      

	      //start over 

	      len = _tcslen (psz);
	      

	      _tcsncpy (buf, _tcsninc (psz, len - 1), 1);
	      

	    }
	   

	}
	 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\shellext.h ===
#define ODS(sz) OutputDebugString(sz)

#ifndef _SHELLEXT_H
#define _SHELLEXT_H

#define STR_GUID         _T("{5a61f7a0-cde1-11cf-9113-00aa00425c62}")
DEFINE_GUID(CLSID_ShellExtension, 0x5a61f7a0L, 0xcde1, 0x11cf, 0x91, 0x13, 0x00, 0xaa, 0x00, 0x42, 0x5c, 0x62 );

#define STR_NAME         _T("IIS Shell Extention")
#define STR_THREAD_MODEL _T("Apartment")


//==================================================================================
// this class factory object creates context menu handlers for Windows 95 shell
class CShellExtClassFactory : public IClassFactory
{
protected:
    ULONG   m_cRef;

public:
    CShellExtClassFactory();
    ~CShellExtClassFactory();

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    //IClassFactory members
    STDMETHODIMP        CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP        LockServer(BOOL);

};
typedef CShellExtClassFactory *LPCSHELLEXTCLASSFACTORY;


//==================================================================================
// this is the actual OLE Shell context menu handler
class CShellExt : public IShellExtInit, 
                         IShellPropSheetExt
{
public:
    TCHAR         m_szPropSheetFileUserClickedOn[MAX_PATH*2];


protected:
    ULONG        m_cRef;
    LPDATAOBJECT m_pDataObj;

public:
    CShellExt();
    ~CShellExt();

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    //IShellExtInit methods
    STDMETHODIMP            Initialize(LPCITEMIDLIST pIDFolder, 
                                       LPDATAOBJECT pDataObj, 
                                       HKEY hKeyID);

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    
    STDMETHODIMP ReplacePage(UINT uPageID, 
                             LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                             LPARAM lParam);


public:
    // From here on down it is stuff that is specifict to the internal function of the page
    // unlike the routines above, these are implemented in webpg.cpp
    BOOL OnMessage(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


    void SinkNotify(
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HWND            m_hwnd;

protected:
    void OnFinalRelease();

    BOOL OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);

    // control event handling routines
    void OnRdoNot();
    void OnRdoShare();
    void OnAdd();
    void OnEdit();
    void OnRemove();
    void OnSelchangeComboServer();

    // control notification handling routines
	BOOL OnListBoxNotify(HWND hDlg, int idCtrl, WORD code, HWND hwndControl);

    // update the state of the server
    void UpdateState();
    // enable items as appropriate
    void EnableItems();

    // initialization
    void Init();
    BOOL InitControls();
    void BuildAliasList();
    void RecurseAddVDItems( CWrapMetaBase* pmb, LPCTSTR szMB );
    void EmptyList();
    void InitSeverInfo();

    BOOL InitializeSink();
    void TerminateSink();

    void ResetListContent();

    // access to the server-based root string
    void GetRootString( LPTSTR sz, DWORD cchMax );
    void GetVirtServerString( LPTSTR sz, DWORD cchMax );

    // CDialog simulation routines
    void UpdateData( BOOL fDialogToData );

    
    // initialize and uninitialize the metabase connections
    void CleanUpConnections();
    BOOL FInitMetabase();
    BOOL FCloseMetabase();


    // support for shutdown notification
    void OnTimer( UINT nIDEvent );
    void EnterShutdownMode();
    BOOL FIsW3Running();
    void CheckIfServerIsRunningAgain();
    void InspectServerList();

    
    // test if we have proper access to the metabase
    BOOL FIsAdmin();

    
    // the property page...
    HPROPSHEETPAGE  m_hpage;

    // handles to the page's controls
    HWND    m_icon_pws;
    HWND    m_icon_iis;
    HWND    m_static_share_on_title;
    HWND    m_ccombo_server;
    HWND    m_cbtn_share;
    HWND    m_cbtn_not;
    HWND    m_cstatic_alias_title;
    HWND    m_cbtn_add;
    HWND    m_cbtn_remove;
    HWND    m_cbtn_edit;
    HWND    m_clist_list;
    HWND    m_static_status;


    // data from the controls
    int     m_int_share;
    int     m_int_server;

    // Server information
    BOOL                    m_fIsPWS;
    DWORD                   m_state;

    BOOL                    m_fInitialized;

    // sink things
    DWORD                   m_dwSinkCookie;
    CImpIMSAdminBaseSink*   m_pEventSink;
    IConnectionPoint*       m_pConnPoint;
    BOOL                    m_fInitializedSink;
    BOOL                    m_fShutdownMode;

    IMSAdminBase*           m_pMBCom;

    CEditDirectory*         m_pEditAliasDlg;
};
typedef CShellExt *LPCSHELLEXT;


#endif //_SHELLEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w3ext.rc
//
#define IDS_ERROR_NOT_ENOUGH_MEMORY     1
#define IDS_STATUS_STARTED              2
#define IDS_STATUS_STOPPED              3
#define IDS_STATUS_PAUSED               4
#define IDS_UNABLE_TO_REGISTER          5
#define IDS_UNABLE_TO_UNREGISTER        6
#define IDS_PAGE_TITLE                  7
#define IDS_STATUS_STARTING             8
#define IDS_CONFIRM_REMOVE              9
#define IDS_DEFAULT_ALIAS               10
#define IDS_EMPTY_ALIAS                 11
#define IDS_NO_PARENT                   12
#define IDS_ALIAS_IS_TAKEN              13
#define IDS_CONFIRM_SHARENOT            14
#define IDS_PWS_TITLE                   15
#define IDS_STATUS_SHUTDOWN             16
#define IDS_STATUS_IIS_STARTED          17
#define IDS_STATUS_IIS_STOPPED          18
#define IDS_STATUS_IIS_PAUSED           19
#define IDS_STATUS_IIS_SHUTDOWN         20
#define IDS_STATUS_IIS_STARTING         22
#define IDS_DEFAULT_SERVER_DESCRIPTION  23
#define IDS_ILLEGAL_VIRT_DIR_CHARS      24
#define IDS_ILLEGAL_PHYS_PATH_CHARS     25
#define IDS_WRITEEXECUTE_WARNING        26
#define IDS_WARNING                     27
#define IDD_WEB_SHARE                   129
#define IDI_PRODUCT                     130
#define IDI_ICON_PWS                    130
#define IDD_ALIAS                       131
#define IDD_WEB_SHARE1                  132
#define IDI_ICON_IIS                    133
#define IDC_STATIC_STATUS               1008
#define IDC_LIST                        1009
#define IDC_ADD                         1010
#define IDC_REMOVE                      1011
#define IDC_EDIT                        1012
#define IDC_RDO_SHARE                   1013
#define IDC_RDO_NOT                     1014
#define IDC_STATIC_ALIAS_TITLE          1015
#define IDC_COMBO_SERVER                1016
#define IDC_STATIC_SHARE_ON             1017
#define IDC_STATIC_ICON_PWS             1018
#define IDC_STATIC_ICON_IIS             1019
#define IDC_PATH                        1020
#define IDC_ALIAS                       1021
#define IDC_DIRBROWSE                   1023
#define IDC_FULLCONTROL                 1024
#define IDC_RDO_NONE                    1025
#define IDC_RDO_SCRIPTS                 1026
#define IDC_RDO_EXECUTE                 1027
#define IDC_BROWSE                      1040
#define IDC_READ                        1073
#define IDC_WRITE                       1074
#define IDC_EXECUTE                     1075
#define IDC_SCRIPTS                     1079

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1029
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\eddir.h ===
/////////////////////////////////////////////////////////////////////////////
// CEditDirectory dialog

class CEditDirectory
    {
    // Construction
    public:

    enum {
        APPPERM_NONE = 0,
        APPPERM_SCRIPTS,
        APPPERM_EXECUTE
        };

    CEditDirectory( HWND hParent = NULL );   // standard constructor
    ~CEditDirectory();                       // standard destructor

    // tell the dialog to Close
    BOOL EndDialog( INT_PTR nResult )    { return ::EndDialog(m_hDlg,nResult);}

    // the the modal dialog to do its thing
    INT_PTR DoModal();
    BOOL OnMessage(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // flag to indicate that this is a new item
    BOOL m_fNewItem;
    IMSAdminBase * m_pMBCom;

    HWND    m_hDlg;

    HWND    m_hEditAlias;
    HWND    m_hEditPath;
    HWND    m_hChkRead;
    HWND    m_hChkWrite;
    HWND    m_hChkDirBrowse;
    HWND    m_hChkSource;

    HWND    m_hRdoNone;
    HWND    m_hRdoExecute;
    HWND    m_hRdoScripts;


    TCHAR m_sz_alias[MAX_PATH];
    TCHAR m_sz_path[MAX_PATH];
    BOOL    m_bool_read;
    BOOL    m_bool_write;
    BOOL    m_bool_dirbrowse;
    BOOL    m_bool_source;
    INT     m_int_AppPerms;

    // stored values for read/write/dir browse to use when unchecking full control
    BOOL    m_bool_oldSource;

    // the root directory to use
    TCHAR  m_szRoot[MAX_PATH];


// Implementation
protected:
    BOOL InitHandles( HWND hDlg );
    BOOL OnInitDialog( HWND hDlg );
    void OnOK( HWND hDlg );

    void OnRead( HWND hDlg );
    void OnWrite( HWND hDlg );
    void OnSource( HWND hDlg );

    void EnableSourceControl();


    int FindOneOf( LPTSTR psz, LPCTSTR pszSearch );
    int FindLastChr( LPTSTR psz, TCHAR ch );
    void TrimLeft( LPTSTR psz );
    void TrimRight( LPTSTR psz );

    // CDialog simulation routines
    void UpdateData( BOOL fDialogToData );

    // keep a copy of the original alias for later verification
    TCHAR      m_szOrigAlias[MAX_PATH];

    // the parent window
    HWND        m_hParent;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\shellext.cpp ===
/* This file contains the class factory and the COM related guts of the
CShellExt class. Also the two necessary callbacks that drive the dialog.
Look in the webpg.cpp file for the methods that relate to the actual functionality
of the propery page itself.
*/


#include "priv.h"
#include <tchar.h>
//
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//
#include <shlguid.h>
#include <shellapi.h>
#include <shlwapi.h>
#include "wrapmb.h"
#include "sink.h"

#include <initguid.h>
#include "eddir.h"
#include "shellext.h"

// Global variables
//
extern UINT      g_cRefThisDll;     // Reference count of this DLL.
extern HINSTANCE g_hmodThisDll;     // Handle to this DLL itself.


//========================================= CShellExtClassFactory

//---------------------------------------------------------------
CShellExtClassFactory::CShellExtClassFactory()
    {
    ODS(TEXT("CShellExtClassFactory::CShellExtClassFactory()\r\n"));
    m_cRef = 0L;
    g_cRefThisDll++;
    }

//---------------------------------------------------------------
CShellExtClassFactory::~CShellExtClassFactory()
    {
    g_cRefThisDll--;
    }

//---------------------------------------------------------------
STDMETHODIMP CShellExtClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
    {
    ODS(TEXT("CShellExtClassFactory::QueryInterface()\r\n"));

    *ppv = NULL;

    // Any interface on this object is the object pointer
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
    }

//---------------------------------------------------------------
STDMETHODIMP_(ULONG) CShellExtClassFactory::AddRef()
    {
    return ++m_cRef;
    }

//---------------------------------------------------------------
STDMETHODIMP_(ULONG) CShellExtClassFactory::Release()
    {
    if (--m_cRef)
        return m_cRef;

    delete this;

    return 0L;
    }

//---------------------------------------------------------------
STDMETHODIMP CShellExtClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                      REFIID riid,
                                                      LPVOID *ppvObj)
    {
    ODS(TEXT("CShellExtClassFactory::CreateInstance()\r\n"));

    *ppvObj = NULL;

    // Shell extensions typically don't support aggregation (inheritance)

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the main shell extension object.  The shell will then call
    // QueryInterface with IID_IShellExtInit--this is how shell extensions are
    // initialized.

    LPCSHELLEXT pShellExt = new CShellExt();  //Create the CShellExt object

    if (NULL == pShellExt)
        return E_OUTOFMEMORY;

    return pShellExt->QueryInterface(riid, ppvObj);
    }


//---------------------------------------------------------------
STDMETHODIMP CShellExtClassFactory::LockServer(BOOL fLock)
    {
    return NOERROR;
    }


//========================================= CShellExt

//---------------------------------------------------------------
// the property page creation/deletion callback procedure
UINT CALLBACK ShellExtPageCallback(HWND hWnd,
                UINT uMessage,
                LPPROPSHEETPAGE  ppsp)
{
    switch(uMessage)
    {
        case PSPCB_CREATE:
            return TRUE;

        case PSPCB_RELEASE:
        {
            CShellExt * pExt = (CShellExt *)ppsp->lParam;
            if (pExt != NULL)
            {
               pExt->Release();
            }
            return TRUE;
        }
    }
    return TRUE;
}

//---------------------------------------------------------------
INT_PTR CALLBACK ShellExtPageDlgProc(HWND hDlg,
                             UINT uMessage,
                             WPARAM wParam,
                             LPARAM lParam)
    {
    // When the shell creates a dialog box for a property sheet page,
    // it passes the pointer to the PROPSHEETPAGE data structure as
    // lParam. The dialog procedures of extensions typically store it
    // in the DWL_USER of the dialog box window.
    //
    if ( uMessage == WM_INITDIALOG )
        {
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }

    // recover the property sheet page and the asoociated shell extension
    // object from the window handle
    LPPROPSHEETPAGE psp=(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    if ( !psp )
        return FALSE;

    // get the shell extension object
    CShellExt * pShellExt = (CShellExt *)(psp->lParam);
    if (!pShellExt)
        return FALSE;

    // let the object do the work
    return pShellExt->OnMessage( hDlg, uMessage, wParam, lParam );
    }

//---------------------------------------------------------------
//
//  FUNCTION: CShellExt::ReplacePage(UINT, LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell only for Control Panel property sheet
//           extensions
//
//  PARAMETERS:
//    uPageID         -  ID of page to be replaced
//    lpfnReplaceWith -  Pointer to the Shell's Replace function
//    lParam          -  Passed as second parameter to lpfnReplaceWith
//
//  RETURN VALUE:
//
//    E_FAIL, since we don't support this function.  It should never be
//    called.

//  COMMENTS:
//
STDMETHODIMP CShellExt::ReplacePage(UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                                    LPARAM lParam)
{
   ODS(TEXT("CShellExt::ReplacePage()\r\n"));
   return E_FAIL;
}

HRESULT ResolveShortcut(HWND hwnd, LPCTSTR lpszLinkFile, LPTSTR lpszPath) 
{
   HRESULT hres; 
   IShellLink * psl; 
   TCHAR szGotPath[MAX_PATH]; 
   TCHAR szDescription[MAX_PATH]; 
   WIN32_FIND_DATA wfd; 
 
   *lpszPath = 0; // assume failure 
 
   // Get a pointer to the IShellLink interface. 
   hres = CoCreateInstance(CLSID_ShellLink, NULL, 
        CLSCTX_INPROC_SERVER, IID_IShellLink, (LPVOID *)&psl); 
   if (SUCCEEDED(hres)) 
   { 
      IPersistFile * ppf; 
 
      // Get a pointer to the IPersistFile interface. 
      hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf); 
      if (SUCCEEDED(hres)) 
      { 
         // Load the shortcut. 
         hres = ppf->Load(lpszLinkFile, STGM_READ); 
         if (SUCCEEDED(hres)) 
         { 
            // Resolve the link. 
            hres = psl->Resolve(hwnd, SLR_NO_UI); 
            if (SUCCEEDED(hres)) 
            { 
               // Get the path to the link target. 
               hres = psl->GetPath(szGotPath, 
                        MAX_PATH, (WIN32_FIND_DATA *)&wfd, 
                        SLGP_SHORTPATH ); 
               if (SUCCEEDED(hres))
               {
                  // Get the description of the target. 
                  hres = psl->GetDescription(szDescription, MAX_PATH); 
                  if (SUCCEEDED(hres)) 
                     lstrcpy(lpszPath, szGotPath);
               }
            } 
         }
         // Release the pointer to the IPersistFile interface. 
         ppf->Release(); 
      } 
     // Release the pointer to the IShellLink interface. 
    psl->Release(); 
    } 
    return hres; 
}

//---------------------------------------------------------------
//
//  FUNCTION: CShellExt::AddPages(LPFNADDPROPSHEETPAGE, LPARAM)
//
//  PURPOSE: Called by the shell just before the property sheet is displayed.
//
//  PARAMETERS:
//    lpfnAddPage -  Pointer to the Shell's AddPage function
//    lParam      -  Passed as second parameter to lpfnAddPage
//
//  RETURN VALUE:
//
//    NOERROR in all cases.  If for some reason our pages don't get added,
//    the Shell still needs to bring up the Properties... sheet.
//
//  COMMENTS:
//

STDMETHODIMP CShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
   UINT attrib;
   PROPSHEETPAGE psp;

   // we only add the page if the user has admin priviliges in the metabase
   if ( !FIsAdmin() )
   {
      return NOERROR;
   }

   // load the title of the property page from the resources
   // note the arbitrary limit of 100 characters but enough
   // space is allocated for 100 wide characters
   TCHAR   szTitle[100 * 2];
   LoadString( g_hmodThisDll, IDS_PAGE_TITLE, szTitle, 100 );

   //
   // Create a property sheet page object from a dialog box.
   //
   // We store a pointer to our class in the psp.lParam, so we
   // can access our class members from within the GAKPageDlgProc
   //
   // If the page needs more instance data, you can append
   // arbitrary size of data at the end of this structure,
   // and pass it to the CreatePropSheetPage. In such a case,
   // the size of entire data structure (including page specific
   // data) must be stored in the dwSize field.   Note that in
   // general you should NOT need to do this, as you can simply
   // store a pointer to date in the lParam member.
   //
   ZeroMemory( &psp, sizeof(psp) );
   psp.dwSize      = sizeof(psp);  // no extra data.
   psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK;
   psp.hInstance   = g_hmodThisDll;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_WEB_SHARE);
   psp.hIcon       = 0;
   psp.pszTitle    = szTitle;
   psp.pfnDlgProc  = ShellExtPageDlgProc;
   psp.pcRefParent = &g_cRefThisDll;
   psp.pfnCallback = ShellExtPageCallback;
   psp.lParam      = (LPARAM)this;

   m_hpage = CreatePropertySheetPage(&psp);
   if (m_hpage)
   {
      // We should AddRef here because we used this class pointer
      // It will be released in ShellExtPageCallback().
      AddRef();
      if (!lpfnAddPage(m_hpage, lParam))
      {
         DestroyPropertySheetPage(m_hpage);
      }
   }
   return NOERROR;
}

//---------------------------------------------------------------
CShellExt::CShellExt():
    m_fInitializedSink( FALSE ),
    m_fInitialized( FALSE ),
    m_pMBCom( NULL ),
    m_fShutdownMode( FALSE ),
    m_pConnPoint( NULL ),
    m_pEventSink( NULL ),
    m_dwSinkCookie(0),
    m_hpage( NULL ),
    m_hwnd( NULL ),
    m_icon_pws(NULL),
    m_icon_iis(NULL),
    m_static_share_on_title(NULL),
    m_ccombo_server(NULL),
    m_cbtn_share(NULL),
    m_cbtn_not(NULL),
    m_cstatic_alias_title(NULL),
    m_cbtn_add(NULL),
    m_cbtn_remove(NULL),
    m_cbtn_edit(NULL),
    m_clist_list(NULL),
    m_static_status(NULL),
    m_int_share( 0 ),
    m_int_server(0),
    m_pEditAliasDlg(NULL)
    {
    ODS(TEXT("CShellExt::CShellExt()\r\n"));

    m_cRef = 0L;
    m_pDataObj = NULL;

    g_cRefThisDll++;
    }

//---------------------------------------------------------------
CShellExt::~CShellExt()
    {
    if (m_pDataObj)
        m_pDataObj->Release();

    g_cRefThisDll--;
    }

//---------------------------------------------------------------
STDMETHODIMP CShellExt::QueryInterface(REFIID riid, LPVOID FAR *ppv)
    {
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellExtInit) || IsEqualIID(riid, IID_IUnknown))
        {
        ODS(TEXT("CShellExt::QueryInterface()==>IID_IShellExtInit\r\n"));
        *ppv = (LPSHELLEXTINIT)this;
        }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
        {
        ODS(TEXT("CShellExt::QueryInterface()==>IShellPropSheetExt\r\n"));
        *ppv = (LPSHELLPROPSHEETEXT)this;
        }

    if (*ppv)
        {
        AddRef();
        return NOERROR;
        }

    ODS(TEXT("CShellExt::QueryInterface()==>Unknown Interface!\r\n"));

    return E_NOINTERFACE;
    }

//---------------------------------------------------------------
STDMETHODIMP_(ULONG) CShellExt::AddRef()
    {
    ODS(TEXT("CShellExt::AddRef()\r\n"));
    return ++m_cRef;
    }

//---------------------------------------------------------------
STDMETHODIMP_(ULONG) CShellExt::Release()
    {
    ODS(TEXT("CShellExt::Release()\r\n"));
    if (--m_cRef)
        return m_cRef;
    OnFinalRelease();
    delete this;
    return 0L;
    }

//---------------------------------------------------------------
//
//  FUNCTION: CShellExt::Initialize(LPCITEMIDLIST, LPDATAOBJECT, HKEY)
//
//  PURPOSE: Called by the shell when initializing a context menu or property
//           sheet extension.
//
//  PARAMETERS:
//    pIDFolder - Specifies the parent folder
//    pDataObj  - Spefifies the set of items selected in that folder.
//    hRegKey   - Specifies the type of the focused item in the selection.
//
//  RETURN VALUE:
//
//    NOERROR in all cases.
//
//  COMMENTS:   Note that at the time this function is called, we don't know
//              (or care) what type of shell extension is being initialized.
//              It could be a context menu or a property sheet.
//

STDMETHODIMP CShellExt::Initialize(LPCITEMIDLIST pIDFolder,
                                   LPDATAOBJECT pDataObj,
                                   HKEY hRegKey)
{
   BOOL bRes = FALSE;
   if (!pDataObj)
   {
      return(E_INVALIDARG);
   }
    
   FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
   STGMEDIUM medium;
   HRESULT hRes = pDataObj->GetData(&fmte, &medium);
   if (FAILED(hRes))
   {
      return(hRes);
   }

   int count;
   if (  (count = DragQueryFile((HDROP)medium.hGlobal, (UINT)(-1), NULL,0)) > 0
      && count < 2
      )
   {
      TCHAR szFileName[MAX_PATH];
      DragQueryFile((HDROP)medium.hGlobal, 0, szFileName, sizeof(szFileName) * sizeof(TCHAR));
      SHFILEINFO shfi;
      SHGetFileInfo(szFileName, 0, &shfi, sizeof(SHFILEINFO), SHGFI_ATTRIBUTES);
      if (shfi.dwAttributes & SFGAO_LINK)
         bRes = FALSE;
      else if (shfi.dwAttributes & SFGAO_FILESYSTEM)
      {
         int drive_number;
         TCHAR szRoot[4];
         int nType;
         if (  -1 != (drive_number = PathGetDriveNumber(szFileName))
               && NULL != PathBuildRoot(szRoot, drive_number)
               && DRIVE_REMOTE != (nType = GetDriveType(szRoot))
               && DRIVE_NO_ROOT_DIR != nType
               )
         {
            bRes = TRUE;
            StrCpy(m_szPropSheetFileUserClickedOn, szFileName);
         }
      }
   }
   ReleaseStgMedium(&medium);
   if (bRes)
   {
      // Initialize can be called more than once
      if (m_pDataObj)
         m_pDataObj->Release();

      // duplicate the object pointer and registry handle

      if (pDataObj)
      {
         m_pDataObj = pDataObj;
         pDataObj->AddRef();
      }

      return NOERROR;
   }
   return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\sources.inc ===
!include ..\..\..\..\place.inc

MAJORCOMP=w3ext
MINORCOMP=w3ext

TARGETNAME=w3ext
TARGETEXT=dll
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows
IDL_TYPE=OLE

DLLDEF=..\w3ext.def
DLLENTRY=_DllMainCRTStartup

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=/D_IISVERSION

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\priv.h

SUBSYSTEM_VERSION=4.00

INCLUDES=\
    ..;\
    $(IISBASEDIR)\inc;\
    $(IISBASEDIR)\inc\$(O);\
    ..\..\wrapmb;\
    $(SDK_INC_PATH)\mfc42

USE_MSVCRT=1

SOURCES=\
    ..\eddir.cpp   \
    ..\shellext.cpp\
    ..\sink.cpp    \
    ..\guid.cpp    \
    ..\w3ext.cpp   \
    ..\w3ext.rc    \
    ..\webshrpg.cpp

TARGETLIBS=\
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\comdlg32.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\shell32.lib  \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib   \
    $(SDK_LIB_PATH)\shlwapi.lib  \
    $(SDK_LIB_PATH)\uuid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  pwsext.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\sink.h ===
#ifndef _MD_SINK_
#define _MD_SINK_

#include <iadmw.h>

// forward
class CShellExt;

class CImpIMSAdminBaseSink : public IMSAdminBaseSink {

//    IMSAdminBaseSink

public:

    CImpIMSAdminBaseSink();
    ~CImpIMSAdminBaseSink();

    void SetPage( CShellExt* pPageWeb )
        {m_pPageWeb = pPageWeb;}

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE SinkNotify( 
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

private:
    ULONG m_dwRefCount;
    CShellExt*       m_pPageWeb;
};

#endif  //_MD_SINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\sink.cpp ===
#include "priv.h"
#include <iiscnfg.h>
#include "wrapmb.h"
#include "Sink.h"
#include "eddir.h"
#include "shellext.h"

//--------------------------------------------------------------------
CImpIMSAdminBaseSink::CImpIMSAdminBaseSink():
    m_pPageWeb(NULL)
{
    m_dwRefCount=1;
}

//--------------------------------------------------------------------
CImpIMSAdminBaseSink::~CImpIMSAdminBaseSink()
{
}

//--------------------------------------------------------------------
HRESULT
CImpIMSAdminBaseSink::QueryInterface(REFIID riid, void **ppObject) 
{
    if (riid==IID_IUnknown || riid==IID_IMSAdminBaseSink) 
    {
        *ppObject = (IMSAdminBaseSink*) this;
    }
    else 
    {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

//--------------------------------------------------------------------
ULONG
CImpIMSAdminBaseSink::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//--------------------------------------------------------------------
ULONG
CImpIMSAdminBaseSink::Release()
    {
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0)
        {
        delete this;
        }
    return dwRefCount;
    }

//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CImpIMSAdminBaseSink::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
// we are not actually allowed to make any metadata calls here, so we need to notfy the
// appropriate view that it has work to do the next time there is time.

// however, we can let the views decide if they want this...
if ( m_pPageWeb )
    m_pPageWeb->SinkNotify( dwMDNumElements, pcoChangeList );
return (0);
}

//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CImpIMSAdminBaseSink::ShutdownNotify(void)
    {
    if ( m_pPageWeb )
        PostMessage( m_pPageWeb->m_hwnd, WM_SHUTDOWN_NOTIFY, 0, 0 );
    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\nt\stdafx.h ===
#include "..\stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\w95\stdafx.h ===
#include "..\stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>          // MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>         // MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\webshrpg.cpp ===
// this is the internal content-specific stuff related to the
// CShellExt object

#include "priv.h"
#include <stdio.h>
#include <tchar.h>
#include <iiscnfgp.h>
//#include <inetinfo.h>
#include <winsvc.h>
#include <pwsdata.hxx>
#include <iwamreg.h>
#include <shlwapi.h>

#include "wrapmb.h"
#include "Sink.h"
#include "eddir.h"
#include "shellext.h"

#include "wrapmb.h"

extern HINSTANCE g_hmodThisDll;      // Handle to this DLL itself.

#define SZ_MB_SERVICE               _T("/LM/W3SVC/")
#define SZ_ROOT                     _T("/ROOT")
#define SZ_SERVER_KEYTYPE           _T("IIsWebServer")


#define IIS_CAP1_10_CONNECTION_LIMIT    0x00000040


BOOL MakeWAMApplication( IN LPCTSTR pszPath, IN BOOL fCreate );
BOOL MyFormatString1( IN LPTSTR pszSource, IN DWORD cchMax, LPTSTR pszReplace );


//--------------------------------------------------------------------
// test if we have proper access to the metabase
BOOL CShellExt::FIsAdmin()
{
    BOOL    fAnswer = FALSE;
    CWrapMetaBase   mb;

    FInitMetabase();

    // first things first. get the state of the server
    // init the mb object. If it fails then the server app is probably not running
    if ( mb.FInit(m_pMBCom) )
    {
        BOOL fOpen = mb.Open(_T("/LM/W3SVC"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
        if ( fOpen )
        {
            // Write some nonsense
            DWORD dwDummy = 0x1234;
            fAnswer = mb.SetDword( _T(""), MD_ISM_ACCESS_CHECK, IIS_MD_UT_FILE, dwDummy, 0 );

            // close the metabase object
            mb.Close();
        }
    }

	// Grrrrr!! Boyd, you should clean up after youself
    FCloseMetabase();

    // return the answer
    return fAnswer;
}



//---------------------------------------------------------------
// return FALSE if we do NOT handle the message
BOOL CShellExt::OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    switch (LOWORD(wParam))
        {
		case IDC_LIST:
			return OnListBoxNotify(hDlg, LOWORD(wParam), HIWORD(wParam), (HWND)lParam);

        case IDC_ADD:
            OnAdd();
            return TRUE;

        case IDC_EDIT:
            OnEdit();
            return TRUE;

        case IDC_REMOVE:
            OnRemove();
            return TRUE;

        case IDC_RDO_NOT:
            OnRdoNot();
            break;

        case IDC_RDO_SHARE:
            OnRdoShare();
            break;

        case IDC_COMBO_SERVER:
            if ( HIWORD(wParam) == CBN_SELCHANGE )
                {
                OnSelchangeComboServer();
                }
            break;
        }
    // we did not handle it
    return FALSE;
    }

//---------------------------------------------------------------
// return FALSE if we do NOT handle the message
BOOL CShellExt::OnListBoxNotify(HWND hDlg, int idCtrl, WORD code, HWND hwndControl)
{
    switch (code)
    {
    case LBN_DBLCLK:
		{
        OnEdit();
        return TRUE;
        }
	case LBN_SELCHANGE:
		{
		EnableItems();
        return TRUE;
        }
	}
    return FALSE;
}

//---------------------------------------------------------------
// return FALSE if we do NOT handle the message
BOOL CShellExt::OnMessage(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    BOOL    fHandledMessage = FALSE;

    // the BIG dialog switch statement....
    switch( uMsg )
        {
        case WM_INITDIALOG:
            m_hwnd = hDlg;
            // init the controls
            if ( !InitControls() )
                return FALSE;

            // the big init
            if ( FInitMetabase() )
                {
                Init();
                m_fInitialized = TRUE;
                }
            else
                return FALSE;

            // return success
            fHandledMessage = TRUE;
            break;

        case WM_DESTROY:
           ResetListContent();
           break;

        case WM_COMMAND:
            fHandledMessage = OnCommand(hDlg, wParam, lParam);
            break;
        case WM_UPDATE_SERVER_STATE:
            UpdateState();
            EnableItems();
            return TRUE;
        case WM_UPDATE_ALIAS_LIST:
            EmptyList();
            BuildAliasList();
            EnableItems();
            return TRUE;
        case WM_SHUTDOWN_NOTIFY:
            EnterShutdownMode();
            return TRUE;
        case WM_INSPECT_SERVER_LIST:
            InspectServerList();
            return TRUE;
        case WM_TIMER:
            if ( wParam == PWS_TIMER_CHECKFORSERVERRESTART )
                {
                OnTimer( (UINT)wParam );
                fHandledMessage = TRUE;
                }
            break;
        };

    // return whether or not we handled the message
    return fHandledMessage;
    }

//---------------------------------------------------------------
// obtain all the control handles that we will need as the dialog goes along
BOOL CShellExt::InitControls()
    {
    m_icon_pws = GetDlgItem( m_hwnd, IDC_STATIC_ICON_PWS );
    m_icon_iis = GetDlgItem( m_hwnd, IDC_STATIC_ICON_IIS );
    m_static_share_on_title = GetDlgItem( m_hwnd, IDC_STATIC_SHARE_ON );
    m_ccombo_server = GetDlgItem( m_hwnd, IDC_COMBO_SERVER );
    m_cbtn_share = GetDlgItem( m_hwnd, IDC_RDO_SHARE );
    m_cbtn_not = GetDlgItem( m_hwnd, IDC_RDO_NOT );
    m_cstatic_alias_title = GetDlgItem( m_hwnd, IDC_STATIC_ALIAS_TITLE );
    m_cbtn_add = GetDlgItem( m_hwnd, IDC_ADD );
    m_cbtn_remove = GetDlgItem( m_hwnd, IDC_REMOVE );
    m_cbtn_edit = GetDlgItem( m_hwnd, IDC_EDIT );
    m_clist_list = GetDlgItem( m_hwnd, IDC_LIST );
    m_static_status = GetDlgItem( m_hwnd, IDC_STATIC_STATUS );
    return TRUE;
    }

//--------------------------------------------------------------------
// remove all the alias items in the list
void CShellExt::EmptyList()
{
	ListBox_ResetContent( m_clist_list );
}

//---------------------------------------------------------------
// CDialog simulation routines
void CShellExt::UpdateData( BOOL fDialogToData )
    {
    // get the data
    if ( fDialogToData )
        {
        // set the data
        m_int_share = (SendMessage( m_cbtn_share, BM_GETCHECK, 0, 0 ) == BST_CHECKED);
        m_int_server = (int)SendMessage( m_ccombo_server, CB_GETCURSEL, 0, 0 );
        if ( m_int_server < 0 )
            m_int_server = 0;
        }
    else
        {
        // set the data
        SendMessage( m_ccombo_server, CB_SETCURSEL, m_int_server, 0 );
        if ( m_int_share )
            {
            SendMessage( m_cbtn_not, BM_SETCHECK, BST_UNCHECKED, 0 );
            SendMessage( m_cbtn_share, BM_SETCHECK, BST_CHECKED, 0 );
            }
        else
            {
            SendMessage( m_cbtn_share, BM_SETCHECK, BST_UNCHECKED, 0 );
            SendMessage( m_cbtn_not, BM_SETCHECK, BST_CHECKED, 0 );
            }
        }
    }

//--------------------------------------------------------------------
// This method gets called when an object in the metabase has been
// deleted. The purpose is to see if the current virtual directory in
// the metabase has been deleted or not. If it has been deleted, then
// we go to the default sever. Or the first one. Or whatever is there.
void CShellExt::InspectServerList()
    {
    BOOL    fItsGone = FALSE;
    TCHAR   szRoot[200];

    CWrapMetaBase   mb;
    if ( !mb.FInit(m_pMBCom) )
        return;

    // Attempt to open the root. If that fails, its otta here
    GetRootString( szRoot, 100 );
    if (!mb.Open(szRoot))
		return;
    mb.Close();

    // it is gone. Default to the first one
    SendMessage( m_ccombo_server, CB_SETCURSEL, 0, 0 );
    }

//------------------------------------------------------------------
// This routine builds the correct metabase path up to /LM/W3SVC/*/ROOT
// where the * is the current virtual server selected in the drop down.
// There are two versions of this routine. One where the string is passed
// in as a variable, and the other returns it
void CShellExt::GetRootString( LPTSTR sz, DWORD cchMax )
{
    // get the service part
    GetVirtServerString(sz, cchMax);

    // add on the ROOT part
    StrCatBuff(sz, SZ_ROOT, cchMax);
}

//------------------------------------------------------------------
// This routine builds the correct metabase path up to /LM/W3SVC/*
// where the * is the current virtual server selected in the drop down.
// There are two versions of this routine. One where the string is passed
// in as a variable, and the other returns it
void CShellExt::GetVirtServerString(LPTSTR sz, DWORD cchMax)
{
   *sz = 0;
   StrCatBuff(sz, SZ_MB_SERVICE, cchMax);
   UpdateData( TRUE );

   // the private string data on the item
   PTCHAR  pch = (PTCHAR)SendMessage( m_ccombo_server, CB_GETITEMDATA, m_int_server, 0 );

   // do something if it fails
   if ( !pch || (pch == (PTCHAR)CB_ERR) )
      return;

   // the virtual server is indicated by the current selection in the
   // server combo box. We get its index and retrieve the path from the
   // private data attached to the item in the list
   StrCat(sz, pch);
}


//--------------------------------------------------------------------
void CShellExt::ResetListContent()
    {
    PTCHAR psz;

    // first, get the number of strings
    DWORD   nNumStrings = (DWORD)SendMessage( m_ccombo_server, CB_GETCOUNT, 0, 0 );
    if ( nNumStrings == CB_ERR ) return;

    // delete all the hidden server path strings
    for ( DWORD i = 0; i < nNumStrings; i++ )
        {
        // get the string pointer
        psz = (PTCHAR)SendMessage( m_ccombo_server, CB_GETITEMDATA, i, 0 );
        // if it is there, delete it
        if (psz != NULL)
            LocalFree(psz);
        }

    // wipe out any items currently in the box before re-adding
    SendMessage( m_ccombo_server, CB_RESETCONTENT, 0, 0 );
    }

//--------------------------------------------------------------------
// initialize the combo box so the user can select which virtual server
// to administer from the shell extension.
void CShellExt::InitSeverInfo()
{
    DWORD err;
    CWrapMetaBase mb;
    INT i;

    if ( !mb.FInit(m_pMBCom) )
        return;

    TCHAR szKey[MAX_PATH];
    TCHAR szDescription[MAX_PATH];

    ZeroMemory( szKey, MAX_PATH );
    ZeroMemory( szDescription, MAX_PATH );

    // wipe out any items currently in the box before re-adding
    ResetListContent();

    // first open the metabase and get the server capabilities
    if ( mb.Open(_T("/LM/W3SVC/")) )
        {
        DWORD   dw;
        // test if there is a 10 connection limit and use
        // that flag as a test for IIS vs. PWS


        if ( mb.GetDword( _T("Info"), MD_SERVER_CAPABILITIES, IIS_MD_UT_SERVER, &dw ) )
            m_fIsPWS = (dw & IIS_CAP1_10_CONNECTION_LIMIT) != 0;

#ifdef DEBUG_ALWAYS_IIS
m_fIsPWS = FALSE;
#endif
        // now enumerate the children to build the drop down list. Since there could
        // be gaps in the list 1,2,4,5,6,8 etc (some may have been deleted) we need
        // to keep an additional list of path names that correspond to the positions
        // in the combo box. The list of names is stored in m_rgbszServerPaths
        TCHAR szServer[MAX_PATH];
        DWORD   index = 0;
        while (mb.EnumObjects( _T(""), szServer, MAX_PATH, index))
            {
            // before we can add this key we need to inspect its keytype to
            // make sure that it is a virtual server
            // get the type
            BOOL f =  mb.GetString( szServer, MD_KEY_TYPE, IIS_MD_UT_SERVER,
                        szDescription, MAX_PATH, 0 );

            // check the type
            if ( !f || (StrCmp(szDescription, SZ_SERVER_KEYTYPE) != 0) )
                {
                // increment to the next key
                index++;
                continue;
                }

            // now get the description of the virtual server
            f =  mb.GetString( szServer, MD_SERVER_COMMENT, IIS_MD_UT_SERVER,
                        szDescription, MAX_PATH, 0 );

            // if the description isn't there, load the default description
            if ( !f )
            {
               LoadString(g_hmodThisDll, IDS_DEFAULT_SERVER_DESCRIPTION, szDescription, MAX_PATH);
               StrCatBuff(szDescription, szServer, MAX_PATH);
            }
            // add the description to the combo box
            i = (INT)SendMessage( m_ccombo_server, CB_ADDSTRING, 0, (LPARAM)szDescription );

            // hide the server path as private data
            LRESULT err = SendMessage( m_ccombo_server, CB_SETITEMDATA, i, (LPARAM)StrDup(szServer));

            // increment to the next key
            index++;
            }

        // close the metabase
        mb.Close();

        // default to selecting the first item in the combo box
        SendMessage( m_ccombo_server, CB_SETCURSEL, 0, 0 );
        }
    else
        {
        err = GetLastError();
        }

    // show the correct icon
    if ( m_fIsPWS )
        ShowWindow( m_icon_iis, SW_HIDE );
    else
        ShowWindow( m_icon_pws, SW_HIDE );

    // if it is pws, then hide the server drop-down
    if ( m_fIsPWS )
        {
        ShowWindow( m_static_share_on_title, SW_HIDE );
        ShowWindow( m_ccombo_server, SW_HIDE );
        }

    }

//--------------------------------------------------------------------
// initialize the page's data - read in any existing info from the metabase
// - or determine that it is not in the metabase
void CShellExt::Init()
    {
    // attempt to set up the sink
    m_fInitializedSink = InitializeSink();

    // prepare to set up the data
    UpdateData( TRUE );

    // initialize the server information and combo box
    InitSeverInfo();

    // fill in the list of aliases
    BuildAliasList();

    // set the data into place
    UpdateData( FALSE );

    // update the state of the server
    UpdateState();
    EnableItems();
    }


//--------------------------------------------------------------------
// update the state of the server
void CShellExt::UpdateState()
{
    BOOL fUpdate = FALSE;
    CWrapMetaBase   mb;

    TCHAR sz[MAX_PATH];
    TCHAR szVirtServer[MAX_PATH];
    TCHAR szStatus[MAX_PATH];

    m_state = MD_SERVER_STATE_STOPPED;

    // first things first. get the state of the server
    // init the mb object. If it fails then the server app is probably not running
    if ( mb.FInit(m_pMBCom) )
        {
        GetVirtServerString( szVirtServer, MAX_PATH );
        if ( mb.Open(szVirtServer) )
            {
            if ( !mb.GetDword( _T(""), MD_SERVER_STATE, IIS_MD_UT_SERVER, &m_state ) )
                {
                DWORD err = GetLastError( );
                if ( err == RPC_E_SERVERCALL_RETRYLATER )
                    {
                    // try again later....
                    mb.Close();
                    PostMessage( m_hwnd, WM_UPDATE_SERVER_STATE, 0, 0 );
                    return;
                    }
                }
            // close the metabase object
            mb.Close();
            }
        }

    // show the appropriate items
    switch( m_state )
        {
        case MD_SERVER_STATE_STARTING:
            if ( m_fIsPWS )
                LoadString( g_hmodThisDll, IDS_STATUS_STARTING, szStatus, MAX_PATH );
            else
                LoadString( g_hmodThisDll, IDS_STATUS_IIS_STARTING, szStatus, MAX_PATH );
            break;
        case MD_SERVER_STATE_STARTED:
            if ( m_fIsPWS )
                LoadString( g_hmodThisDll, IDS_STATUS_STARTED, szStatus, MAX_PATH );
            else
                LoadString( g_hmodThisDll, IDS_STATUS_IIS_STARTED, szStatus, MAX_PATH );
            break;
        case MD_SERVER_STATE_STOPPED:
        case MD_SERVER_STATE_STOPPING:
            if ( m_fIsPWS )
                LoadString( g_hmodThisDll, IDS_STATUS_STOPPED, szStatus, MAX_PATH );
            else
                LoadString( g_hmodThisDll, IDS_STATUS_IIS_STOPPED, szStatus, MAX_PATH );
            break;
        case MD_SERVER_STATE_PAUSED:
            if ( m_fIsPWS )
                LoadString( g_hmodThisDll, IDS_STATUS_PAUSED, szStatus, MAX_PATH );
            else
                LoadString( g_hmodThisDll, IDS_STATUS_IIS_PAUSED, szStatus, MAX_PATH );
            break;
        };

    // set the string into the dialog
    SetWindowText( m_static_status, szStatus );
}

//--------------------------------------------------------------------
// enable items as appropriate
void CShellExt::EnableItems()
{
    UpdateData( TRUE );

    // if the virtual server is not running, disable most of the items
    if ( m_state != MD_SERVER_STATE_STARTED )
    {
        EnableWindow( m_cbtn_share, FALSE );
        EnableWindow( m_cbtn_not, FALSE );

        EnableWindow( m_cstatic_alias_title, FALSE );
        EnableWindow( m_cbtn_add, FALSE );
        EnableWindow( m_cbtn_remove, FALSE );
        EnableWindow( m_cbtn_edit, FALSE );
        EnableWindow( m_clist_list, FALSE );
    }
    else
    {
        EnableWindow( m_cbtn_share, TRUE );
        EnableWindow( m_cbtn_not, TRUE );
        EnableWindow( m_ccombo_server, TRUE );
        EnableWindow( m_static_share_on_title, TRUE );

        EnableWindow( m_clist_list, TRUE);
        EnableWindow( m_cbtn_add, FALSE);
        EnableWindow( m_cbtn_remove, FALSE);
        EnableWindow( m_cbtn_edit, FALSE);
        m_int_share = 0;
        // the virtual server is running. Do the normal thing.
        // first, check the overall count of the items in the list
        if ( ListBox_GetCount(m_clist_list) > 0 )
        {
            m_int_share = 1;
            // there is stuff in the list - sharing is on
            EnableWindow( m_cstatic_alias_title, TRUE );
            EnableWindow( m_cbtn_add, TRUE );
			// we shouldn't enable Remove for the root directory
			TCHAR buffer[MAX_PATH];
			int idx = ListBox_GetCurSel(m_clist_list);
			if (idx != LB_ERR)
			{
				EnableWindow( m_cbtn_edit, TRUE );
				ListBox_GetText(m_clist_list, idx, buffer);
				if (StrCmp(_T("/"), buffer) != 0)
					EnableWindow(m_cbtn_remove, TRUE );
			}
        }
    }

    UpdateData( FALSE );
}



//------------------------------------------------------------------
BOOL CShellExt::InitializeSink()
    {
    IConnectionPointContainer * pConnPointContainer = NULL;
    HRESULT hRes;
    BOOL fSinkConnected = FALSE;

    // m_pMBCom is defined in webshrpg.h
    IUnknown * pmb = (IUnknown*)m_pMBCom;

    m_pEventSink = new CImpIMSAdminBaseSink();

    if ( !m_pEventSink )
    {
        return FALSE;
    }

    //
    // First query the object for its Connection Point Container. This
    // essentially asks the object in the server if it is connectable.
    //

    hRes = pmb->QueryInterface( IID_IConnectionPointContainer,
                                (PVOID *)&pConnPointContainer);
    if SUCCEEDED(hRes)
        {
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.

        hRes = pConnPointContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
                                                         &m_pConnPoint);

        if (SUCCEEDED(hRes))
            {
            hRes = m_pConnPoint->Advise( (IUnknown *)m_pEventSink,
                                          &m_dwSinkCookie);

            if (SUCCEEDED(hRes))
                {
                fSinkConnected = TRUE;
                }
            }

        if ( pConnPointContainer )
            {
            pConnPointContainer->Release();
            pConnPointContainer = NULL;
            }
        }

    if ( !fSinkConnected )
        {
        delete m_pEventSink;
        m_pEventSink = NULL;
        }
    else
        {
        // we are connected. Tell it where to send the udpates
        m_pEventSink->SetPage( this );
        }

    return fSinkConnected;
    }


//------------------------------------------------------------------
void CShellExt::TerminateSink()
{
    if (m_dwSinkCookie)
    {
        m_pConnPoint->Unadvise( m_dwSinkCookie );
    }
    if (m_pEventSink)
    {
       delete m_pEventSink;
       m_pEventSink = NULL;
    }
}


//------------------------------------------------------------------------
// recursively add all the items to the tree
void CShellExt::RecurseAddVDItems(CWrapMetaBase * pmb, LPCTSTR szMB)
{
    DWORD index = 0;
    BOOL fAddAlias;

    TCHAR sz[MAX_PATH];
    TCHAR szMBPath[MAX_PATH];

    // now we need to see if this is already points to us
    fAddAlias = FALSE;
    if ( pmb->GetString(szMB, MD_VR_PATH, IIS_MD_UT_FILE, sz, MAX_PATH, 0) )
    {
        // do the comparison - without regard to case
        if (StrCmpI(m_szPropSheetFileUserClickedOn, sz) == 0)
        {
            ListBox_AddString(m_clist_list, *szMB == 0 ? _T("/") : (LPTSTR)szMB);
        }
    }

    // enumerate the sub-directories of the open directory and add them
    // to the tree. Recurse each to add its children as well
    // enumerate the directories, adding each to the list
    while (pmb->EnumObjects(szMB, sz, MAX_PATH, index))
    {
        // build the display name for this item
        StrCpy(szMBPath, szMB);
        PathAppend(szMBPath, sz);

        // recurse the item
        RecurseAddVDItems(pmb, szMBPath);

        // advance the index
        index++;
    }
}

//--------------------------------------------------------------------
// rebuild all the alias items in the list
// NOTE: The only way (for now) to edit the Home directory is in the pws application
void CShellExt::BuildAliasList()
{
    DWORD   err;
    TCHAR   szRoot[200];

    // create the metabase wrapper
    CWrapMetaBase   mb;
    if ( !mb.FInit(m_pMBCom) )
        return;

    // go for the root directory first
    GetRootString(szRoot, 100);
    if ( mb.Open(szRoot) )
        {
        // do the recursive adding thing
        RecurseAddVDItems( &mb, _T("") );
        // close the metabase object
        mb.Close();
        }
    else
        err = GetLastError();
}

//--------------------------------------------------------------------
void CShellExt::OnRemove()
{
    int     nItem;
    CWrapMetaBase   mb;

    TCHAR  szItem[MAX_PATH];
    TCHAR  szWAMPath[MAX_PATH];
    ZeroMemory( szItem, MAX_PATH );
    ZeroMemory( szWAMPath, MAX_PATH );

    // get the root string once
    TCHAR szRoot[200];
    GetRootString( szRoot, 100 );

    // get the string of the selected item
    nItem = ListBox_GetCurSel(m_clist_list);
    ListBox_GetText(m_clist_list, nItem, szItem);

    // create the metabase wrapper
    if ( !mb.FInit(m_pMBCom) )
        return;

    // munge the name into the confirm string - reuse the existing wampath string
    LoadString( g_hmodThisDll, IDS_CONFIRM_REMOVE, szWAMPath, MAX_PATH );
	 TCHAR szCaption[80];
	 LoadString(g_hmodThisDll, IDS_PAGE_TITLE, szCaption, 80);
    MyFormatString1( szWAMPath, MAX_PATH, szItem );

    // ask the user if the really want to do this
    if ( MessageBox( m_hwnd, szWAMPath, szCaption, MB_YESNO ) == IDYES )
        {
        // the WAM stuff can take some time, so put up the wait cursor
        SetCursor( LoadCursor(NULL, IDC_WAIT) );

        // remove the WAM application first
        StrCpy( szWAMPath, szRoot );
        StrCat( szWAMPath, szItem );
        MakeWAMApplication( szWAMPath, FALSE );

        // open the metabase at the root
        if ( mb.Open(szRoot, METADATA_PERMISSION_WRITE) )
            {
            // remove the item from the metabase
            mb.DeleteObject( szItem );

            // close the metabase object
            mb.Close();
            }

        // remove the item from the tree
        PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );
        SetCursor( LoadCursor(NULL, IDC_ARROW) );
        }
}

//--------------------------------------------------------------------
void CShellExt::OnRdoNot()
{
    DWORD   nItems;
    CWrapMetaBase   mb;

    TCHAR  szItem[MAX_PATH];
    TCHAR  szWAMPath[MAX_PATH];
    ZeroMemory( szItem, WIDE_MAX_PATH );
    ZeroMemory( szWAMPath, WIDE_MAX_PATH );

    // if there already are no aliases - don't bother
    nItems = ListBox_GetCount(m_clist_list);
    if ( nItems <= 0 )
        return;

    // create the metabase wrapper
    if ( !mb.FInit(m_pMBCom) )
        return;

	TCHAR szCaption[80];
	LoadString(g_hmodThisDll, IDS_PAGE_TITLE, szCaption, 80);
    // reuse the szWAMPath
    LoadString( g_hmodThisDll, IDS_CONFIRM_SHARENOT, szWAMPath, MAX_PATH );

    // make sure the user wants to do this
    if ( MessageBox( m_hwnd, szWAMPath, szCaption, MB_YESNO ) == IDYES )
        {
        // the WAM stuff can take some time, so put up the wait cursor
        SetCursor( LoadCursor(NULL, IDC_WAIT) );

        // open the metabase at the root
        TCHAR szRoot[200];
        GetRootString(szRoot, 100);
        if ( mb.Open(szRoot, METADATA_PERMISSION_WRITE) )
            {
            // loop through the list, deleting each item
            for ( DWORD iItem = 0; iItem < nItems; iItem++ )
                {
                // get the relative path
                ListBox_GetText(m_clist_list, iItem, szItem);

                // remove the WAM application first
                StrCpy( szWAMPath, szRoot );
                StrCat( szWAMPath, szItem );
                MakeWAMApplication( szWAMPath, FALSE );

                // blast it out of existence
                mb.DeleteObject( szItem );
                }

            // close the metabase
            mb.Close();
            }

        // update the display
        PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );
        SetCursor( LoadCursor(NULL, IDC_ARROW) );
        }
    else
        EnableItems();
}

//--------------------------------------------------------------------
void CShellExt::OnAdd()
{
    CEditDirectory  dlgEdit(m_hwnd);
    CWrapMetaBase   mb;
    DWORD           i;

    PTCHAR  psz, psz2 = NULL;

    TCHAR  szRoot[MAX_PATH];
    TCHAR  szFolder[MAX_PATH];
    TCHAR  szTestName[MAX_PATH];

    ZeroMemory(szRoot, MAX_PATH);
    ZeroMemory(szFolder, MAX_PATH);
    ZeroMemory(szTestName, MAX_PATH);

    // get the root string once
    GetRootString(dlgEdit.m_szRoot, MAX_PATH);

    // get ready //m_sz_alias
    dlgEdit.m_fNewItem = TRUE;
    dlgEdit.m_pMBCom = m_pMBCom;
    StrCpy(dlgEdit.m_sz_path, m_szPropSheetFileUserClickedOn);

    // the initial name for the new alias should be the name of the directory itself.
    // if there already is a virtual directory with that name, then we append a 2 to
    // it. if that exists, increment until we get a valid name.

    // find the part after the last '\\' character in the path
    psz = PathFindFileName(m_szPropSheetFileUserClickedOn);

    // put the short file name into place temporarily
    StrCpy(szFolder, psz);
    PathMakePretty(szFolder);

    // prepare the metabase - as that is where we have to check to see if it is there
    // create the metabase wrapper
    if ( !mb.FInit(m_pMBCom) )
        return;

    // prep the test name
    StrCpy(dlgEdit.m_sz_alias, szFolder);
    wsprintf(szTestName, _T("%s/%s"), dlgEdit.m_szRoot, dlgEdit.m_sz_alias);

    // increment the name of the directory until it is valid
    i = 1;
    while ( mb.Open(szTestName) )
        {
        // close it right away
        mb.Close();

        // increment the counter
        i++;

        // prep the test name
        wsprintf(dlgEdit.m_sz_alias, _T("%s%d"), szFolder, i);
        wsprintf(szTestName, _T("%s/%s"), dlgEdit.m_szRoot, dlgEdit.m_sz_alias);
        }

    // record the pointer to alias dlg in case a shutdown event happens
    m_pEditAliasDlg = &dlgEdit;

    // run it - the dialog handles writing to the metabase
    if ( dlgEdit.DoModal() == IDOK )
        PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );

    m_pEditAliasDlg = NULL;
    SetCursor( LoadCursor(NULL, IDC_ARROW) );
    }

//--------------------------------------------------------------------
void CShellExt::OnEdit()
    {
    CEditDirectory  dlg( m_hwnd );
    TCHAR  szItem[MAX_PATH];
    ZeroMemory( szItem, MAX_PATH );
    int     nItem;

    // get the string of the selected item
    nItem = ListBox_GetCurSel(m_clist_list);
    ListBox_GetText(m_clist_list, nItem, szItem);

    // get ready
    dlg.m_pMBCom = m_pMBCom;
    StrCpy( dlg.m_sz_alias, szItem );
    StrCpy( dlg.m_sz_path, m_szPropSheetFileUserClickedOn );
    GetRootString( dlg.m_szRoot, 100 );

    // record the pointer to alias dlg in case a shutdown event happens
    m_pEditAliasDlg = &dlg;

    // run it - the dialog handles writing to the metabase
    if ( dlg.DoModal() == IDOK )
        PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );
    m_pEditAliasDlg = NULL;
    }

//--------------------------------------------------------------------
// to share an item - all we really have to do is add an alias
void CShellExt::OnRdoShare()
    {
    if ( ListBox_GetCount(m_clist_list) <= 0 )
        OnAdd();
    EnableItems();
    }

//--------------------------------------------------------------------
// the selection in the server combo box has just changed. This means
// we need to rebuild the alias lsit based on this new server
void CShellExt::OnSelchangeComboServer()
    {
    PostMessage( m_hwnd, WM_UPDATE_SERVER_STATE, 0, 0 );
    PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );
    }

//------------------------------------------------------------------------
void CShellExt::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
    {
    BOOL    fPostedState = FALSE;

    // if a key has been deleted, make sure it wasn't our virtual server
    if ( pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT )
        {
        PostMessage( m_hwnd, WM_INSPECT_SERVER_LIST, 0, 0 );
        }

    // do the appropriate action based on the type of change
    if ( (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT) ||
        (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT) ||
        (pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_RENAME_OBJECT) )
        {
        PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );
        }
    else if ( pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
        for ( DWORD iElement = 0; iElement < dwMDNumElements; iElement++ )
            {
            // each change has a list of IDs...
            for ( DWORD iID = 0; iID < pcoChangeList[iElement].dwMDNumDataIDs; iID++ )
                {
                // look for the ids that we are interested in
                switch( pcoChangeList[iElement].pdwMDDataIDs[iID] )
                    {
                    case MD_SERVER_STATE:
                        if ( !fPostedState )
                            PostMessage( m_hwnd, WM_UPDATE_SERVER_STATE, 0, 0 );
                        fPostedState = TRUE;
                        break;
                    default:
                        // do nothing
                        break;
                    };
                }
            }
        }
    }


//--------------------------------------------------------------------
// only arrives if shutdown notify has happened
void CShellExt::OnTimer( UINT nIDEvent )
    {
    CheckIfServerIsRunningAgain();
    }

//--------------------------------------------------------------------
// This routine is called called when we process the shutdown notify
// windows message that we posted to our queue when we got the shutdown
// notification event from the metabase. We cant just do this when we
// get the shutdown notify because that could leave the metabse in
// a funky state, and that would be bad.
void CShellExt::EnterShutdownMode()
    {
    TCHAR   szStatus[400];

    // if the edit alias dialog is open, start by closing it
    if ( m_pEditAliasDlg )
        {
        m_pEditAliasDlg->EndDialog(IDCANCEL);
        m_pEditAliasDlg = NULL;
        }

    // shutdown the sink attached to the document
    TerminateSink();
    m_fInitializedSink = FALSE;

    // close the link to the metabase - it is going away after all
    FCloseMetabase();

    // record that we are in shutdown mode
    m_fShutdownMode = TRUE;

    // start up the timer mechanism
    SetTimer( m_hwnd, PWS_TIMER_CHECKFORSERVERRESTART, TIMER_RESTART, NULL );

    // empty all the items in the list
    EmptyList();

    // set the current status string
    if ( m_fIsPWS )
        LoadString( g_hmodThisDll, IDS_STATUS_SHUTDOWN, szStatus, 200 );
    else
        LoadString( g_hmodThisDll, IDS_STATUS_IIS_SHUTDOWN, szStatus, 200 );

    // disable everything
    EnableWindow( m_cbtn_share, FALSE );
    EnableWindow( m_cbtn_not, FALSE );
    EnableWindow( m_cstatic_alias_title, FALSE );
    EnableWindow( m_cbtn_add, FALSE );
    EnableWindow( m_cbtn_remove, FALSE );
    EnableWindow( m_cbtn_edit, FALSE );
    EnableWindow( m_clist_list, FALSE );
    EnableWindow( m_static_share_on_title, FALSE );
    EnableWindow( m_ccombo_server, FALSE );
    }

//---------------------------------------------------------------------------
// This routine is called on a timer event. The timer events only come if we
// have received a shutdown notify callback from the metabase. So the server
// is down. We need to wait around until it comes back up, then show ourselves.
void CShellExt::CheckIfServerIsRunningAgain()
    {
    // see if the server is running. If it is, show the icon and stop the timer.
    if ( FIsW3Running() )
        {
        // if we can't use the metabase, there is no point in this
        if ( !FInitMetabase() )
            return;

        // attempt to set up the sink
        m_fInitializedSink = InitializeSink();

        // clear the shutdown mode flag
        m_fShutdownMode = FALSE;

        // stop the timer mechanism
        KillTimer( m_hwnd, PWS_TIMER_CHECKFORSERVERRESTART );

        // enable any items that need it
        EnableWindow( m_cbtn_share, TRUE );
        EnableWindow( m_cbtn_not, TRUE );
        EnableWindow( m_static_share_on_title, TRUE );
        EnableWindow( m_ccombo_server, TRUE );

        // tell the main page to update itself
        PostMessage( m_hwnd, WM_UPDATE_SERVER_STATE, 0, 0 );
        PostMessage( m_hwnd, WM_UPDATE_ALIAS_LIST, 0, 0 );
        }
    }

// routine to see if w3svc is running
//--------------------------------------------------------------------
// the method we use to see if the service is running is different on
// windows NT from win95
BOOL   CShellExt::FIsW3Running()
    {
    OSVERSIONINFO info_os;
    info_os.dwOSVersionInfoSize = sizeof(info_os);

    if ( !GetVersionEx( &info_os ) )
        return FALSE;

    // if the platform is NT, query the service control manager
    if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
        BOOL    fRunning = FALSE;

        // open the service manager
        SC_HANDLE   sch = OpenSCManager(NULL, NULL, GENERIC_READ );
        if ( sch == NULL ) return FALSE;

        // get the service
        SC_HANDLE   schW3 = OpenService(sch, _T("W3SVC"), SERVICE_QUERY_STATUS );
        if ( sch == NULL )
            {
            CloseServiceHandle( sch );
            return FALSE;
            }

        // query the service status
        SERVICE_STATUS  status;
        ZeroMemory( &status, sizeof(status) );
        if ( QueryServiceStatus(schW3, &status) )
            {
            fRunning = (status.dwCurrentState == SERVICE_RUNNING);
            }

        CloseServiceHandle( schW3 );
        CloseServiceHandle( sch );

        // return the answer
        return fRunning;
        }

    // if the platform is Windows95, see if the object exists
    if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
        {
        HANDLE hEvent;
        BOOL fFound = FALSE;
        hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));
        if ( hEvent != NULL )
            {
            fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
            CloseHandle(hEvent);
            }
        return(fFound);
        }

    return FALSE;
    }


//--------------------------------------------------------------------
void CShellExt::OnFinalRelease()
{
   CleanUpConnections();
}

//--------------------------------------------------------------------
void CShellExt::CleanUpConnections()
    {
    // if we have the metabase, release it
    if ( m_fInitializedSink )
        {
        TerminateSink();
        m_fInitializedSink = FALSE;
        }
    if ( m_fInitialized )
        {
        FCloseMetabase();
        m_fInitialized = FALSE;
        }
    }


//--------------------------------------------------------------------
BOOL CShellExt::FInitMetabase()
    {
    BOOL f = TRUE;
    HRESULT hres;

    if ( !m_pMBCom )
        {
        hres = CoInitialize(NULL);
        if ( SUCCEEDED(hres) )
            {
            f = FInitMetabaseWrapperEx( NULL, &m_pMBCom );
            }
        }

    return f;
    }

//--------------------------------------------------------------------
BOOL CShellExt::FCloseMetabase()
    {
    BOOL f = TRUE;

    if ( m_pMBCom )
        {
        f = FCloseMetabaseWrapperEx( &m_pMBCom );
        m_pMBCom = NULL;
        CoUninitialize();
        }

    return f;
    }

//------------------------------------------------------------------------
// This routine takes a path to a virutal directory in the metabase and creates
// a WAM application there. Most of the code is actually obtaining and maintaining
// the interface to the WAM ole object
// szPath       The path to the metabase
// fCreate      True if creating an application, FALSE if deleting an existing app
BOOL MakeWAMApplication( IN LPCTSTR pszPath, IN BOOL fCreate )
    {
    IClassFactory*      pcsfFactory = NULL;
    IWamAdmin2*         pWAM;
    HRESULT             hresError;
    BOOL                fAnswer = FALSE;

    hresError = CoGetClassObject( CLSID_WamAdmin, CLSCTX_SERVER, NULL,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
        return FALSE;

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin2, (void **)&pWAM);
    if (FAILED(hresError))
        return FALSE;

    // release the factory
    pcsfFactory->Release();

    // calc the string length just once
    DWORD   szLen = _tcslen(pszPath);

    // this part will be nicer after it is converted to unicode
    WCHAR* pwch;
    // allocate the name buffer
    pwch = new WCHAR[szLen + 2];
    if ( !pwch )
        {
        pWAM->Release();
        return FALSE;
        }
    ZeroMemory( pwch, (szLen + 2)*sizeof(WCHAR) );

    // unicodize the name into the buffer
    if ( pwch )
        {

#ifdef _UNICODE

        //
        // UNICODE conversion by RonaldM
        //
        // This is actually probably not needed.
        //
        lstrcpy(pwch, pszPath);

#else

        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszPath, -1,
                            pwch, szLen );

#endif // _UNICODE

        // create the in-proc application, if requested
        if ( fCreate )
            {
            hresError = pWAM->AppCreate2( pwch, eAppRunOutProcInDefaultPool );
            }
        else
            {
            // delete the application. Because the whole virtual dir is going away,
            // delete any applications lower down in the tree as well
            hresError = pWAM->AppDelete( pwch, TRUE );
            }

        // check the error code
        fAnswer = SUCCEEDED( hresError );

        // clean up
        delete pwch;
        }

    // release the logging ui
    pWAM->Release();

    // return the answer
    return fAnswer;
    }

//------------------------------------------------------------------------
BOOL MyFormatString1( IN LPTSTR pszSource, IN DWORD cchMax, LPTSTR pszReplace )
    {
    return FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
        pszSource,
        NULL,
        NULL,
        pszSource,
        cchMax,
        (va_list*)&pszReplace
        ) > 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\w3ext.cpp ===
//
// Copyright (C) 1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   w3ext.cpp
//
// Purpose:  main file for the w3 shell extension

#include "priv.h"
#include <pudebug.h>

// guids and com stuff
#include <shlguid.h>
//#include <shlwapi.h>
#include "wrapmb.h"
#include "sink.h"
#include "eddir.h"
#include "shellext.h"

#include "tchar.h"

//
// Global variables
//
UINT                g_cRefThisDll = 0;    // Reference count of this DLL.
HINSTANCE           g_hmodThisDll = NULL;   // Handle to this DLL itself.


//---------------------------------------------------------------------------
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
    {
    if (dwReason == DLL_PROCESS_ATTACH)
        {
        ODS(TEXT("In DLLMain, DLL_PROCESS_ATTACH\r\n"));

        g_hmodThisDll = hInstance;

        }
    else if (dwReason == DLL_PROCESS_DETACH)
        {
        ODS(TEXT("In DLLMain, DLL_PROCESS_DETACH\r\n"));
        }

    return 1;   // ok
    }

//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    ODS(TEXT("In DLLCanUnloadNow\r\n"));

    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

//---------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
    ODS(TEXT("In DllGetClassObject\r\n"));

    *ppvOut = NULL;

    if (IsEqualIID(rclsid, CLSID_ShellExtension))
    {
        CShellExtClassFactory *pcf = new CShellExtClassFactory;

        return pcf->QueryInterface(riid, ppvOut);
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}





//
// Registry Values Definitions
//
typedef struct tagVALUE_PAIR
{
    HKEY    hKeyBase;       
    BOOL    fOwnKey;        
    BOOL    fOwnValue;
    LPCTSTR lpstrKey;       
    LPCTSTR lpstrValueName; 
    LPCTSTR lpstrValue;     // Blank is replaced with module path
} VALUE_PAIR;

//
// Registry Entries
//
// NOTE: The table must be constructed so that sub keys are listed
//       after their parents, because we delete keys in the same
//       order in which they are declared here.
//
VALUE_PAIR g_aValues[] = 
{
    //
    // Base Key            DelKey  DelVal   Key Name                                                                       Value Name            Value
    // ============================================================================================================================================================
    { HKEY_CLASSES_ROOT,   TRUE,   FALSE,   _T("CLSID\\") STR_GUID _T("\\InProcServer32"),                                 _T(""),               _T("")           },
    { HKEY_CLASSES_ROOT,   FALSE,  FALSE,   _T("CLSID\\") STR_GUID _T("\\InProcServer32"),                                 _T("ThreadingModel"), STR_THREAD_MODEL },
    { HKEY_CLASSES_ROOT,   TRUE,   FALSE,   _T("CLSID\\") STR_GUID,                                                        _T(""),               STR_NAME         },

    { HKEY_CLASSES_ROOT,   TRUE,   FALSE,   _T("Folder\\shellex\\PropertySheetHandlers\\PWS Sharing"),                     _T(""),               STR_GUID         },
    { HKEY_CLASSES_ROOT,   FALSE,  TRUE,    _T("Folder\\shellex\\PropertySheetHandlers"),                                  _T(""),               _T("IISSEPage")  },

    { HKEY_LOCAL_MACHINE,  FALSE,  TRUE,    _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),STR_GUID,             STR_NAME         },
};

#define NUM_ENTRIES (sizeof(g_aValues) / sizeof(g_aValues[0]))

//--------------------------------------------------------------------
// Auto-(un) registration Entry Point
//
STDAPI 
DllUnregisterServer(void)
{
   HKEY hKey;
   DWORD dw;
   DWORD err = ERROR_SUCCESS;

   do
   {
      //
      // Loop through the entries
      //
      for (int i = 0; i < NUM_ENTRIES; ++i)
      {
         //
         // Do we own this key? If so delete the whole thing, including
         // its values. 
         //
         if (g_aValues[i].fOwnKey)
         {
            err = RegDeleteKey(g_aValues[i].hKeyBase, g_aValues[i].lpstrKey);
         }
         //
         // Otherwise, do we own the value? Only delete it then
         //
         else if (g_aValues[i].fOwnValue)
         {
            // create / open the key
            err = RegCreateKeyEx(
                        g_aValues[i].hKeyBase,  // handle of an open key 
                        g_aValues[i].lpstrKey,  // address of subkey name 
                        0,                      // reserved 
                        _T(""),                 // address of class string
                        REG_OPTION_NON_VOLATILE,// special options flag 
                        KEY_ALL_ACCESS,         // desired security access 
                        NULL,                   // address of key security structure 
                        &hKey,                  // address of buffer for opened handle  
                        &dw                     // address of disposition value buffer 
                       );

            // if we opened the key, delete the value
            if ( err == ERROR_SUCCESS )
            {
               RegDeleteValue( hKey, g_aValues[i].lpstrValueName );
               // close the registry key
               RegCloseKey( hKey );
            }
         }

         //
         // If the key or value is already gone, that's ok
         //
         if (err == ERROR_FILE_NOT_FOUND || err == ERROR_PATH_NOT_FOUND)
         {
            err = ERROR_SUCCESS;
         }
         else
         {
            break;
         }
      }
   }
   while(FALSE);
   return HRESULT_FROM_WIN32(err);
}

//--------------------------------------------------------------------
// Auto-registration Entry Point
//
STDAPI 
DllRegisterServer(void)
{
   DWORD err = ERROR_SUCCESS;
   TCHAR strModulePath[MAX_PATH];
   HKEY hKey;
   DWORD dw;

   do
   {
      //
      // Build current module path
      //
      HINSTANCE hCurrent = g_hmodThisDll;
      if (hCurrent == NULL)
      {
         err = ERROR_INVALID_HANDLE;
         break;          
      }

      if (GetModuleFileName(hCurrent, strModulePath, MAX_PATH) == 0)
      {
         err = GetLastError();
         break;
      }

      //
      // Loop through the entries.
      // If the reg value is blank, use the module path
      //
      for (int i = 0; i < NUM_ENTRIES; ++i)
      {
         // create / open the key
         if (ERROR_SUCCESS != (err = RegCreateKeyEx(
                g_aValues[i].hKeyBase,
                g_aValues[i].lpstrKey,             // address of subkey name 
                0,                                 // reserved 
                _T(""),                            // address of class string
                REG_OPTION_NON_VOLATILE,           // special options flag 
                KEY_ALL_ACCESS,                    // desired security access 
                NULL,                              // address of key security structure 
                &hKey,                             // address of buffer for opened handle  
                &dw                                // address of disposition value buffer 
                )))
         {
            break;
         }

         LPCTSTR pValue;
         int len;
         if (g_aValues[i].lpstrValue[0] != 0)
            pValue = g_aValues[i].lpstrValue;
         else
            pValue = strModulePath;
         len = _tcslen(pValue) * sizeof(TCHAR);
         // set the value
         if (ERROR_SUCCESS != (err = RegSetValueEx(hKey, 
                  g_aValues[i].lpstrValueName,
                  0,
                  REG_SZ,
                  (const unsigned char *)pValue,
                  len)))
         {
            break;
         }
         // close the registry key
         RegCloseKey( hKey );
      }
   }
   while(FALSE);
   return HRESULT_FROM_WIN32(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\sink.h ===
#ifndef _MD_SINK_
#define _MD_SINK_

#include <iadmw.h>

class CImpIMSAdminBaseSink : public IMSAdminBaseSink {

//    IMSAdminBaseSink

public:

    CImpIMSAdminBaseSink();
    ~CImpIMSAdminBaseSink();


    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    HRESULT STDMETHODCALLTYPE SinkNotify( 
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    HRESULT STDMETHODCALLTYPE ShutdownNotify(void);

private:
    ULONG m_dwRefCount;
};

#endif  //_MD_SINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\nt\stdafx.h ===
#include "..\stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\w95\stdafx.h ===
#include "..\stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\pwstray.h ===
// define the application class name
#define     PWS_TRAY_WINDOW_CLASS       _T("PWS_TRAY_WINDOW")

// special window messages
enum {
    WM_PWS_TRAY_UPDATE_STATE = WM_USER,
    WM_PWS_TRAY_SHELL_NOTIFY,
    WM_PWS_TRAY_SHUTDOWN_NOTIFY
    };

// timer messages
enum {
    PWS_TRAY_CHECKFORSERVERRESTART = 0,
    PWS_TRAY_CHECKTOSEEIFINETINFODIED
    };

// number of milliseconds for the restart timer to wait
#define TIMER_RESTART           5000
#define TIMER_SERVERDIED        5000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwsext\webshrpg.h ===
// WebShrPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWebSharePage dialog

// forward
class CImpIMSAdminBaseSink;

class CWebSharePage : public CPropertyPage
{
    DECLARE_DYNCREATE(CWebSharePage)

// Construction
public:
    CWebSharePage();
    ~CWebSharePage();

    // the target directory path
    CString     m_szDirPath;

    // so that a sink object can update the status in real-time
    void SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ]);

    virtual void OnTimer( UINT nIDEvent );

// Dialog Data
    //{{AFX_DATA(CWebSharePage)
    enum { IDD = IDD_WEB_SHARE };
    CStatic m_icon_pws;
    CStatic m_icon_iis;
    CStatic m_static_share_on_title;
    CComboBox m_ccombo_server;
    CButton m_cbtn_share;
    CButton m_cbtn_not;
    CStatic m_cstatic_alias_title;
    CButton m_cbtn_add;
    CButton m_cbtn_remove;
    CButton m_cbtn_edit;
    CListBox m_clist_list;
    CString m_sz_status;
    int     m_int_share;
    int     m_int_server;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWebSharePage)
    public:
    virtual BOOL OnSetActive();
    virtual void OnFinalRelease();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWebSharePage)
    afx_msg void OnAdd();
    afx_msg void OnEdit();
    afx_msg void OnRemove();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRdoNot();
    afx_msg void OnRdoShare();
    afx_msg void OnDestroy();
    afx_msg void OnSelchangeComboServer();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    // update the state of the server
    void UpdateState();
    // enable items as appropriate
    void EnableItems();

    // initialize the page's data
    void Init();
    void BuildAliasList();
    void RecurseAddVDItems( CWrapMetaBase* pmb, LPCTSTR szMB );
    void EmptyList();
    void InitSeverInfo();

    BOOL InitializeSink();
    void TerminateSink();

    void CleanUpConnections();

    // support for shutdown notification
    void EnterShutdownMode();
    BOOL FIsW3Running();
    void CheckIfServerIsRunningAgain();
    void InspectServerList();

    BOOL ActOnMessage( UINT message, WPARAM wParam );

    BOOL                    m_fInitialized;

    // access to the server-based root string
    void GetRootString( CString &sz );
    void GetVirtServerString( CString &sz );

    // initialize and uninitialize the metabase connections
    BOOL    FInitMetabase();
    BOOL    FCloseMetabase();

    // Server information
    BOOL                    m_fIsPWS;
    CStringArray            m_rgbszServerPaths;
    DWORD                   m_state;

    // sink things
    DWORD                   m_dwSinkCookie;
    CImpIMSAdminBaseSink*   m_pEventSink;
    IConnectionPoint*       m_pConnPoint;
    BOOL                    m_fInitializedSink;
    BOOL                    m_fShutdownMode;

    IMSAdminBase*           m_pMBCom;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\pwstray.cpp ===
#define INITGUID

#include <windows.h>
#include <tchar.h>
#include <shellapi.h>

#include <ole2.h>
#include <coguid.h>
#include <iadmw.h>

#include <iiscnfg.h>

#include "pwstray.h"
#include "resource.h"
#include "sink.h"

#include <pwsdata.hxx>


#define MB_TIMEOUT           5000

// not a string!
#define DW_TRAY_ICON_ID     'PWSt'

#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

//USE_MFC=1


//========================================================= globals
HINSTANCE               g_hInstance = NULL;
HWND                    g_hwnd = NULL;
HMENU                   g_hMenuMain = NULL;

UINT                    g_dwNewTaskbarMessage = 0;

DWORD                   g_dwSinkCookie = 0;
CImpIMSAdminBaseSink*   g_pEventSink = NULL;
IConnectionPoint*       g_pConnPoint = NULL;

IMSAdminBase*           g_pMBCom = NULL;

DWORD                   g_dwServerState = 0;

//========================================================= forwards
DWORD   DWGetServerState();
BOOL FUpdateTrayIcon( DWORD dwMessage );

BOOL InitializeMetabase( OLECHAR* pocMachineName );
void TerminateMetabase();
BOOL InitializeSink();
void TerminateSink();

BOOL GetAdminPath( TCHAR* pch, WORD cch );
BOOL SetServerState( DWORD dwControlCode );
BOOL LaunchAdminUI();
void RunContextMenu();

BOOL FIsW3Running();
void CheckIfServerIsRunningAgain();
void CheckIfServerUpAndDied();


// routine to see if w3svc is running
//--------------------------------------------------------------------
// the method we use to see if the service is running is different on
// windows NT from win95
BOOL   FIsW3Running()
    {
    OSVERSIONINFO info_os;
    info_os.dwOSVersionInfoSize = sizeof(info_os);

    if ( !GetVersionEx( &info_os ) )
        return FALSE;

    // if the platform is NT, query the service control manager
    if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
        BOOL    fRunning = FALSE;

        // open the service manager
        SC_HANDLE   sch = OpenSCManager(NULL, NULL, GENERIC_READ );
        if ( sch == NULL ) return FALSE;

        // get the service
        SC_HANDLE   schW3 = OpenService(sch, _T("W3SVC"), SERVICE_QUERY_STATUS );
        if ( sch == NULL )
            {
            CloseServiceHandle( sch );
            return FALSE;
            }

        // query the service status
        SERVICE_STATUS  status;
        ZeroMemory( &status, sizeof(status) );
        if ( QueryServiceStatus(schW3, &status) )
            {
            fRunning = (status.dwCurrentState == SERVICE_RUNNING);
            }

        CloseServiceHandle( schW3 );
        CloseServiceHandle( sch );

        // return the answer
        return fRunning;
        }

    // if the platform is Windows95, see if the object exists
    if ( info_os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
        {
        HANDLE hEvent;
        BOOL fFound = FALSE;
        hEvent = CreateEvent(NULL, TRUE, FALSE, _T(PWS_SHUTDOWN_EVENT));
        if ( hEvent != NULL )
            {
            fFound = (GetLastError() == ERROR_ALREADY_EXISTS);
            CloseHandle(hEvent);
            }
        return(fFound);
        }

    return FALSE;
    }


//---------------------------------------------------------------------------
// This routine is called on a timer event. The timer events only come if we
// have received a shutdown notify callback from the metabase. So the server
// is down. We need to wait around until it comes back up, then show ourselves.
void CheckIfServerIsRunningAgain()
    {
    // see if the server is running. If it is, show the icon and stop the timer.
    if ( FIsW3Running() && g_hwnd )
        {
        // if we can't use the metabase, there is no point in this
        if ( !g_pMBCom && !InitializeMetabase(NULL) )
            {
            return;
            }

        // if we can't use the sink, there is no point in this
        if ( !g_pEventSink && !InitializeSink() )
            {
            TerminateMetabase();
            return;
            }

        // stop the life timer mechanism
        KillTimer( g_hwnd, PWS_TRAY_CHECKFORSERVERRESTART );

        // start the unexpected server death test timer
        SetTimer( g_hwnd,  PWS_TRAY_CHECKTOSEEIFINETINFODIED, TIMER_SERVERDIED, NULL );

        // show the tray icon
        g_dwServerState = DWGetServerState();
        FUpdateTrayIcon( NIM_ADD );
        }
    }


//---------------------------------------------------------------------------
// This routine is called on a timer event. The timer events only come if we know
// the server is running. To avoid wasting too many extra cycles it is called rather
// infrequently. What we are doing here is attempting to see if the server died
// without sending us proper notification. If it did, we should clean up the
// icon and start waiting for it to come back.
void CheckIfServerUpAndDied()
    {
    if ( !FIsW3Running() )
        {
        // hide the tray icon
        FUpdateTrayIcon( NIM_DELETE );
        // disconnect the sink mechanism
        TerminateSink();
        // disconnect from the metabase
        TerminateMetabase();
        // stop the death timer
        KillTimer( g_hwnd, PWS_TRAY_CHECKTOSEEIFINETINFODIED );
        // start the life timer
        SetTimer( g_hwnd,  PWS_TRAY_CHECKFORSERVERRESTART, TIMER_RESTART, NULL );
        }
    }

//---------------------------------------------------------------------------
BOOL FUpdateTrayIcon( DWORD dwMessage )
    {
    NOTIFYICONDATA  dataIcon;

    // prepare the common parts of the icon data structure
    dataIcon.cbSize = sizeof( dataIcon );
    dataIcon.hWnd = g_hwnd;
    dataIcon.uID = DW_TRAY_ICON_ID;
    dataIcon.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    dataIcon.uCallbackMessage = WM_PWS_TRAY_SHELL_NOTIFY;

    // prepare the state-dependant icon handle
    switch( g_dwServerState )
        {
        case MD_SERVER_STATE_PAUSED:
        case MD_SERVER_STATE_PAUSING:
            dataIcon.hIcon = LoadIcon( g_hInstance, MAKEINTRESOURCE(IDI_PAUSED) );
            break;
        case MD_SERVER_STATE_STARTED:
        case MD_SERVER_STATE_STARTING:
            dataIcon.hIcon = LoadIcon( g_hInstance, MAKEINTRESOURCE(IDI_RUNNING) );
            break;
        case MD_SERVER_STATE_STOPPED:
        case MD_SERVER_STATE_STOPPING:
            dataIcon.hIcon = LoadIcon( g_hInstance, MAKEINTRESOURCE(IDI_STOPPED) );
            break;
        };

    // prepare the state-dependant tip strings
    switch( g_dwServerState )
        {
        case MD_SERVER_STATE_PAUSED:
            LoadString( g_hInstance, IDS_PAUSED, dataIcon.szTip, 63 );
            break;
        case MD_SERVER_STATE_PAUSING:
            LoadString( g_hInstance, IDS_PAUSING, dataIcon.szTip, 63 );
            break;
        case MD_SERVER_STATE_STARTED:
            LoadString( g_hInstance, IDS_STARTED, dataIcon.szTip, 63 );
            break;
        case MD_SERVER_STATE_STARTING:
            LoadString( g_hInstance, IDS_STARTING, dataIcon.szTip, 63 );
            break;
        case MD_SERVER_STATE_STOPPED:
            LoadString( g_hInstance, IDS_STOPPED, dataIcon.szTip, 63 );
            break;
        case MD_SERVER_STATE_STOPPING:
            LoadString( g_hInstance, IDS_STOPPING, dataIcon.szTip, 63 );
            break;
        };
    DWORD err = GetLastError();

    // make the shell call
    return Shell_NotifyIcon( dwMessage, &dataIcon );
    }

//---------------------------------------------------------------------------
DWORD   DWGetServerState()
    {
    HRESULT         hErr;
    METADATA_HANDLE hMeta;
    METADATA_RECORD mdRecord;
    DWORD           state = 1000;
    DWORD           dwRequiredLen;

    // open the w3svc key so we can get its state
    // since this is a pws thing, we only care about the first
    // server instance
    hErr = g_pMBCom->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/LM/W3SVC/1/",
            METADATA_PERMISSION_READ,
            MB_TIMEOUT,
            &hMeta);
    if ( FAILED(hErr) )
        return state;

    // prepare the metadata record
    mdRecord.dwMDIdentifier  = MD_SERVER_STATE;
    mdRecord.dwMDAttributes  = METADATA_INHERIT;
    mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
    mdRecord.dwMDDataType    = DWORD_METADATA;
    mdRecord.dwMDDataLen     = sizeof(DWORD);
    mdRecord.pbMDData        = (PBYTE)&state;

    // get the data
    hErr = g_pMBCom->GetData(
        hMeta,
        L"",
        &mdRecord,
        &dwRequiredLen );

    // close the key
    hErr = g_pMBCom->CloseKey( hMeta );

    // return the answer
    return state;
    }

//---------------------------------------------------------------------------
// deal with mouse messages that occur on the tray icon
void On_WM_PWS_TRAY_SHELL_NOTIFY(UINT uID, UINT uMouseMsg)
    {
    if ( uID != DW_TRAY_ICON_ID )
        return;

    // act on the mouse message
    switch( uMouseMsg )
        {
        case WM_LBUTTONDBLCLK:
            LaunchAdminUI();
            break;
        case WM_RBUTTONDOWN:
            RunContextMenu();
            break;
        }
    }


//---------------------------------------------------------------------------
// the window proc callback procedure
LRESULT CALLBACK WndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
    switch( message )
        {
        case WM_CREATE:
            // get the registered windows message signifying that there is a new
            // taskbar. When this message is triggered, we need to re-insert the icon
            // into the taskbar. This is usually done when the shell restarts.
            // see http://www.microsoft.com/msdn/sdk/inetsdk/help/itt/shell/taskbar.htm
            // also see the default case for processing of the message
            g_dwNewTaskbarMessage = RegisterWindowMessage(TEXT("TaskbarCreated"));
            break;

        case WM_PWS_TRAY_SHUTDOWN_NOTIFY:
            // hide the tray icon
            FUpdateTrayIcon( NIM_DELETE );
            // disconnect the sink mechanism
            TerminateSink();
            // disconnect from the metabase
            TerminateMetabase();
            // start the time mechanism
            SetTimer( g_hwnd,  PWS_TRAY_CHECKFORSERVERRESTART, TIMER_RESTART, NULL );
            break;

        case WM_TIMER:
            switch ( wParam )
                {
                case PWS_TRAY_CHECKFORSERVERRESTART:
                    CheckIfServerIsRunningAgain();
                    break;
                case PWS_TRAY_CHECKTOSEEIFINETINFODIED:
                    CheckIfServerUpAndDied();
                    break;
                };
            break;

        case WM_PWS_TRAY_SHELL_NOTIFY:
            On_WM_PWS_TRAY_SHELL_NOTIFY( (UINT)wParam, (UINT)lParam );
            break;
        case WM_PWS_TRAY_UPDATE_STATE:
            g_dwServerState = DWGetServerState();
            FUpdateTrayIcon( NIM_MODIFY );
            break;
        case WM_DESTROY:
            FUpdateTrayIcon( NIM_DELETE );
            PostQuitMessage(0);
            break;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
                {
                case ID_START:
                    SetServerState( MD_SERVER_COMMAND_START );
                    break;
                case ID_STOP:
                    SetServerState( MD_SERVER_COMMAND_STOP );
                    break;
                case ID_PAUSE:
                    SetServerState( MD_SERVER_COMMAND_PAUSE );
                    break;
                case ID_CONTINUE:
                    SetServerState( MD_SERVER_COMMAND_CONTINUE );
                    break;
                case ID_PROPERTIES:
                    LaunchAdminUI();
                    break;
                };
            break;

        default:
            // cannot case directly on g_dwNewTaskbarMessage because it is not a constant
            if ( message == g_dwNewTaskbarMessage )
                {
                // Just go straight into waitin' for the server mode. If the server is
                // running it will catch the first time throught the timer. If it is not,
                // then we just sit around and wait for it
                // start the time mechanism
                SetTimer( g_hwnd,  PWS_TRAY_CHECKFORSERVERRESTART, TIMER_RESTART, NULL );
                }
            break;

        }
    return(DefWindowProc(hWnd, message, wParam, lParam ));
    }

//---------------------------------------------------------------------------
// main routine
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow )
    {
    WNDCLASS    wndclass;
    MSG         msg;

    // record the instance handle
    g_hInstance = hInstance;

    // do nothing if this app is already running
    if ( hPrevInstance )
        return 0;

    // one more test of previous instances
    if ( FindWindow(PWS_TRAY_WINDOW_CLASS,NULL) )
        return 0;

    // start ole
    if ( FAILED(CoInitialize( NULL )) )
        return 0;

    // get the menu handle
    g_hMenuMain = LoadMenu( g_hInstance, MAKEINTRESOURCE(IDR_POPUP) );

    // prepare and register the window class
    wndclass.style  =   0;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance  = hInstance;
    wndclass.hIcon      = NULL;
    wndclass.hCursor    = NULL;
    wndclass.hbrBackground = NULL;
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = PWS_TRAY_WINDOW_CLASS;
    RegisterClass( &wndclass );

    // create the window
    g_hwnd = CreateWindow(
        PWS_TRAY_WINDOW_CLASS,  // pointer to registered class name
        _T(""),                 // pointer to window name
        0,   // window style
        0,                     // horizontal position of window
        0,                     // vertical position of window
        0,                    // window width
        0,                    // window height
        NULL,                   // handle to parent or owner window
        NULL,                   // handle to menu or child-window identifier
        hInstance,              // handle to application instance
        NULL                    // pointer to window-creation data
       );

    // Just go straight into waitin' for the server mode. If the server is
    // running it will catch the first time throught the timer. If it is not,
    // then we just sit around and wait for it
    // start the time mechanism
    SetTimer( g_hwnd,  PWS_TRAY_CHECKFORSERVERRESTART, TIMER_RESTART, NULL );

    // run the message loop
    while (GetMessage(&msg, NULL, 0, 0))
        {
        TranslateMessage(&msg);
        DispatchMessage( &msg);
        }

    // clean up the sink and the metabase
    DestroyMenu( g_hMenuMain );
    TerminateSink();
    TerminateMetabase();
    CoUninitialize();

    return((int)msg.wParam);
    }

//------------------------------------------------------------------
BOOL InitializeSink()
    {
    IConnectionPointContainer * pConnPointContainer = NULL;
    HRESULT                     hRes;
    BOOL                        fSinkConnected = FALSE;

    // g_pMBCom is defined in wrapmb
    IUnknown*                   pmb = (IUnknown*)g_pMBCom;

    g_pEventSink = new CImpIMSAdminBaseSink();

    if ( !g_pEventSink )
        {
        return FALSE;
        }

    //
    // First query the object for its Connection Point Container. This
    // essentially asks the object in the server if it is connectable.
    //
    hRes = pmb->QueryInterface( IID_IConnectionPointContainer,
    (PVOID *)&pConnPointContainer);
    if SUCCEEDED(hRes)
        {
        // Find the requested Connection Point. This AddRef's the
        // returned pointer.

        hRes = pConnPointContainer->FindConnectionPoint( IID_IMSAdminBaseSink,
        &g_pConnPoint);

        if (SUCCEEDED(hRes))
            {
            hRes = g_pConnPoint->Advise( (IUnknown *)g_pEventSink,
            &g_dwSinkCookie);

            if (SUCCEEDED(hRes))
                {
                fSinkConnected = TRUE;
                }
            }

        if ( pConnPointContainer )
            {
            pConnPointContainer->Release();
            pConnPointContainer = NULL;
            }
        }

    if ( !fSinkConnected )
        {
        delete g_pEventSink;
        g_pEventSink = NULL;
        }

    return fSinkConnected;
    }

//------------------------------------------------------------------
void TerminateSink()
    {
    HRESULT hRes;
    if ( g_dwSinkCookie && g_pConnPoint )
        hRes = g_pConnPoint->Unadvise( g_dwSinkCookie );
    }

//------------------------------------------------------------------
BOOL InitializeMetabase( OLECHAR* pocMachineName )
    {
    IClassFactory*  pcsfFactory = NULL;
    COSERVERINFO        csiMachineName;
    COSERVERINFO*       pcsiParam = NULL;

    HRESULT                 hresError;

    //release previous interface if needed
    if( g_pMBCom != NULL )
        {
        g_pMBCom->Release();
        g_pMBCom = NULL;
        }

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
        return FALSE;

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)&g_pMBCom);
    if (FAILED(hresError))
        {
        g_pMBCom = FALSE;
        return FALSE;
        }

    // release the factory
    pcsfFactory->Release();

    // success
    return TRUE;
    }

//------------------------------------------------------------------
void TerminateMetabase()
    {
    if ( g_pMBCom )
        {
        g_pMBCom->Release();
        g_pMBCom = NULL;
        }
    }


//======================================== control actions
//------------------------------------------------------------------------
// get the inetinfo path
BOOL LaunchAdminUI()
    {
    TCHAR   chPath[MAX_PATH+1];

    // get the path to the admin UI
    if ( !GetAdminPath( chPath, MAX_PATH ) )
        {
        LoadString( g_hInstance, IDS_ADMINUI_ERR, chPath, MAX_PATH );
        MessageBox( g_hwnd, chPath, NULL, MB_OK|MB_ICONERROR );
        return FALSE;
        }

    // do it
    ShellExecute(
        NULL,   // handle to parent window
        NULL,   // pointer to string that specifies operation to perform
        chPath, // pointer to filename or folder name string
        NULL,   // pointer to string that specifies executable-file parameters
        NULL,   // pointer to string that specifies default directory
        SW_SHOW     // whether file is shown when opened
       );
    return TRUE;
    }

//------------------------------------------------------------------------
// get the inetinfo path
BOOL GetAdminPath( TCHAR* pch, WORD cch )
    {
        HKEY        hKey;
        DWORD       err, type;
        DWORD       cbBuff = cch * sizeof(TCHAR);

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            REGKEY_STP,         // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,               // handle of key to query
            REGKEY_INSTALLKEY,  // address of name of value to query
            NULL,               // reserved
            &type,              // address of buffer for value type
            (PUCHAR)pch,        // address of data buffer
            &cbBuff             // address of data buffer size
           );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // tack on the file name itself
    TCHAR   chFile[64];

    if ( LoadString( g_hInstance, IDS_ADMIN_UI, chFile, 63 ) == 0 )
        return FALSE;

    _tcscat( pch, chFile );

    // success
    return TRUE;
    }

//------------------------------------------------------------------------
BOOL SetServerState( DWORD dwControlCode )
    {
    HRESULT         hErr;
    METADATA_HANDLE hMeta;
    METADATA_RECORD mdRecord;

    // open the w3svc key so we can get its state
    // since this is a pws thing, we only care about the first
    // server instance
    hErr = g_pMBCom->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/LM/W3SVC/1/",
            METADATA_PERMISSION_WRITE,
            MB_TIMEOUT,
            &hMeta);
    if ( FAILED(hErr) )
        return FALSE;

    // prepare the metadata record
    mdRecord.dwMDIdentifier  = MD_SERVER_COMMAND;
    mdRecord.dwMDAttributes  = 0;
    mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
    mdRecord.dwMDDataType    = DWORD_METADATA;
    mdRecord.dwMDDataLen     = sizeof(DWORD);
    mdRecord.pbMDData        = (PBYTE)&dwControlCode;

    // get the data
    hErr = g_pMBCom->SetData(
        hMeta,
        L"",
        &mdRecord );

    // close the key
    hErr = g_pMBCom->CloseKey( hMeta );

    // return the answer
    return TRUE;
    }

//---------------------------------------------------------------------------
void RunContextMenu()
    {
    POINT   pos;
    HMENU   hMenuSub;
    RECT    rect = {0,0,1,1};
    BOOL    f;

    static BOOL fTracking = FALSE;

    if ( fTracking ) return;
    fTracking = TRUE;

    // where is the mouse? This tells us where to put the menu
    if ( !g_hMenuMain || !GetCursorPos(&pos) )
        return;

    // get the menu handle
    hMenuSub = GetSubMenu( g_hMenuMain, 0 );

    // easiest to start by disabling all the state based items
    f = EnableMenuItem( hMenuSub, ID_START, MF_BYCOMMAND|MF_GRAYED );
    f = EnableMenuItem( hMenuSub, ID_STOP, MF_BYCOMMAND|MF_GRAYED );
    f = EnableMenuItem( hMenuSub, ID_PAUSE, MF_BYCOMMAND|MF_GRAYED );
    f = EnableMenuItem( hMenuSub, ID_CONTINUE, MF_BYCOMMAND|MF_GRAYED );

    // prepare the state based menu items
    switch( g_dwServerState )
        {
        case MD_SERVER_STATE_PAUSED:
        case MD_SERVER_STATE_PAUSING:
            EnableMenuItem( hMenuSub, ID_STOP, MF_BYCOMMAND|MF_ENABLED );
            EnableMenuItem( hMenuSub, ID_CONTINUE, MF_BYCOMMAND|MF_ENABLED );
            break;
        case MD_SERVER_STATE_STARTED:
        case MD_SERVER_STATE_STARTING:
            EnableMenuItem( hMenuSub, ID_STOP, MF_BYCOMMAND|MF_ENABLED );
            EnableMenuItem( hMenuSub, ID_PAUSE, MF_BYCOMMAND|MF_ENABLED );
            break;
        case MD_SERVER_STATE_STOPPED:
        case MD_SERVER_STATE_STOPPING:
            EnableMenuItem( hMenuSub, ID_START, MF_BYCOMMAND|MF_ENABLED );
            break;
        };

    // this is necessary, because we need to get a lose focus message for the menu
    // to go down when the user click on some other process outside the up menu
    SetForegroundWindow(g_hwnd);

    // run the menu
    TrackPopupMenu(hMenuSub, TPM_LEFTALIGN|TPM_RIGHTBUTTON, pos.x, pos.y, 0, g_hwnd, NULL);

    fTracking = FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\sources.inc ===
!include ..\..\..\..\place.inc

MAJORCOMP=pwstray
MINORCOMP=pwstray

TARGETNAME=pwstray
TARGETPATH=obj
TARGETTYPE=PROGLIB

DLLDEF=..\pwstray.def
UMTYPE=windows
UMENTRY=winmain
UMAPPL=pwstray

SUBSYSTEM_VERSION=4.00

C_DEFINES=  /D_IISVERSION

INCLUDES=\
        ..;\
        ..\..\..\..\inc\chicago; \
        ..\..\..\..\inc; \
        ..\..\..\..\utils\mdtools\inc; \
        $(SDK_INC_PATH)\mfc42;\
        $O


SOURCES=\
        ..\pwstray.rc  \
        ..\pwstray.cpp \
        ..\sink.cpp

UMLIBS=\
       $(SDK_LIB_PATH)\kernel32.lib \
       $(SDK_LIB_PATH)\advapi32.lib \
       $(SDK_LIB_PATH)\comdlg32.lib \
       $(SDK_LIB_PATH)\comctl32.lib \
       $(SDK_LIB_PATH)\shell32.lib  \
       $(SDK_LIB_PATH)\gdi32.lib    \
       $(SDK_LIB_PATH)\netapi32.lib \
       $(SDK_LIB_PATH)\user32.lib   \
       $(SDK_LIB_PATH)\ole32.lib    \
       $(SDK_LIB_PATH)\oleaut32.lib \
       $(SDK_LIB_PATH)\uuid.lib     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by pwstray.rc
//
#define IDS_PAUSED                      1
#define IDS_PAUSING                     2
#define IDS_STARTED                     3
#define IDS_STARTING                    4
#define IDS_STOPPED                     5
#define IDS_STOPPING                    6
#define IDS_ADMIN_UI                    7
#define IDS_ADMINUI_ERR                 8
#define IDI_RUNNING                     101
#define IDI_PAUSED                      102
#define IDI_STOPPED                     103
#define IDR_POPUP                       104
#define ID_START                        40001
#define ID_STOP                         40002
#define ID_PAUSE                        40003
#define ID_CONTINUE                     40004
#define ID_PROPERTIES                   40005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\pwstray\sink.cpp ===
#include <windows.h>

#include <iiscnfg.h>
#include "Sink.h"

#include "pwstray.h"

extern HWND        g_hwnd;

BOOL FUpdateTrayIcon( DWORD dwMessage );

//--------------------------------------------------------------------
CImpIMSAdminBaseSink::CImpIMSAdminBaseSink()
{
    m_dwRefCount=0;
}

//--------------------------------------------------------------------
CImpIMSAdminBaseSink::~CImpIMSAdminBaseSink()
{
}

//--------------------------------------------------------------------
HRESULT
CImpIMSAdminBaseSink::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMSAdminBaseSink) {
        *ppObject = (IMSAdminBaseSink*) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

//--------------------------------------------------------------------
ULONG
CImpIMSAdminBaseSink::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//--------------------------------------------------------------------
ULONG
CImpIMSAdminBaseSink::Release()
    {
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0)
        {
        delete this;
        }
    return dwRefCount;
    }

//--------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CImpIMSAdminBaseSink::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
// we are not actually allowed to make any metadata calls here
if ( pcoChangeList->dwMDChangeType & MD_CHANGE_TYPE_SET_DATA )
        {
        for ( DWORD iElement = 0; iElement < dwMDNumElements; iElement++ )
            {
            // each change has a list of IDs...
            for ( DWORD iID = 0; iID < pcoChangeList[iElement].dwMDNumDataIDs; iID++ )
                {
                // look for the ids that we are interested in
                switch( pcoChangeList[iElement].pdwMDDataIDs[iID] )
                    {
                    case MD_SERVER_STATE:
                        if ( g_hwnd )
                            PostMessage( g_hwnd, WM_PWS_TRAY_UPDATE_STATE, 0, 0 );
                        return (0);
                    default:
                        // do nothing
                        break;
                    };
                }
            }
        }
return (0);
}

//--------------------------------------------------------------------
// if the service is going away, then we need to go away too
HRESULT STDMETHODCALLTYPE
CImpIMSAdminBaseSink::ShutdownNotify(void)
    {
    if ( g_hwnd )
        {
        // tell the app to do its thing
            PostMessage( g_hwnd, WM_PWS_TRAY_SHUTDOWN_NOTIFY, 0, 0 );
        }
    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by tmscfg.rc
//
#define IDB_TEMPLATE                    1000
#define IDS_TEMPLATE                    1000
#define IDS_CAPTION                     1001
#define IDS_CAPTION_MULTIPLE            1002
#define IDD_SERVICE                     2000
#define IDD_SESSIONS                    2001
#define IDC_EDIT_EMAIL                  3017
#define IDC_EDIT_NAME                   3027
#define IDC_EDIT_TCP_PORT               3033
#define IDC_EDIT_CONNECTION_TIMEOUT     3034
#define IDC_SPIN_CONNECTION_TIMEOUT     3035
#define IDC_EDIT_MAX_CONNECTIONS        3036
#define IDC_SPIN_MAX_CONNECTIONS        3037

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2002
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3045
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\stdafx.h ===
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxcmn.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\tmscfg.h ===
//
// tmscfg.h
//
#include <lmcons.h>
#include <lmapibuf.h>

#include "resource.h"
#include "svrinfo.h"

class CConfigDll : public CWinApp
/*++

Class Description:

    USRDLL CWinApp module

Public Interface:

    CConfigDll : Constructor

    InitInstance : Perform initialization of this module
    ExitInstance : Perform termination and cleanup

--*/
{
public:
    CConfigDll(
        IN LPCTSTR pszAppName = NULL
        );

    virtual BOOL InitInstance();
    virtual int ExitInstance();

protected:
    //{{AFX_MSG(CConfigDll)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\tmservic.cpp ===
#include "stdafx.h"

#include "TMscfg.h"
#include "TMservic.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// CTMServicePage property page
//
IMPLEMENT_DYNCREATE(CTMServicePage, CPropertyPage)

CTMServicePage::CTMServicePage()
    : CPropertyPage(CTMServicePage::IDD)
{
    //{{AFX_DATA_INIT(CTMServicePage)
    m_strEmail = _T("johnd");
    m_strName = _T("John Doe");
    //}}AFX_DATA_INIT
}

CTMServicePage::~CTMServicePage()
{
}

void
CTMServicePage::DoDataExchange(
    CDataExchange * pDX
    )
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTMServicePage)
    DDX_Text(pDX, IDC_EDIT_EMAIL, m_strEmail);
    DDX_Text(pDX, IDC_EDIT_NAME, m_strName);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTMServicePage, CPropertyPage)
    //{{AFX_MSG_MAP(CTMServicePage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
    ON_EN_CHANGE(IDC_EDIT_EMAIL, OnChangeEditEmail)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// CTMServicePage message handlers
//
BOOL 
CTMServicePage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//
// Called for ApplyNow as well as OK.  Save stuff
// here
//
void
CTMServicePage::OnOK()
{
    SetModified(FALSE);
}

void 
CTMServicePage::OnChangeEditName()
{
    SetModified(TRUE);
}


void
CTMServicePage::OnChangeEditEmail()
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\stdafx.h ===
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxcmn.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\tmscfg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    tmscfg.cpp
// Purpose: API Entry points for service ui version 2.0
//

#include "stdafx.h"

#define DLL_BASED __declspec(dllexport)

#include "tmscfg.h"
#include "tmservic.h"
#include "tmsessio.h"

// ===========================================================================
//
// Standard configuration Information
//
// ===========================================================================

//
// Is this server discoverable by INETSLOC?
//
#define INETSLOC_DISCOVERY          FALSE

#if (INETSLOC_DISCOVERY) && !defined(_SVCLOC_)
    #error You must include svcloc.h.
#endif

//
// If INETSLOC_DISCOVERY == TRUE, define the discovery MASK here.
//
#if (INETSLOC_DISCOVERY) 
    #define INETSLOC_MASK               
#else  // (!INETSLOC_DISCOVERY) 
    #define INETSLOC_MASK           (ULONGLONG)(0x00000000)
#endif // (INETSLOC_DISCOVERY) 

//
// Do we use the service control manager to control
// the service we administer?
//
#define USE_SC_MANAGER              FALSE

//
// Can we change the service state (start/pause/continue)?
//
#define CAN_CHANGE_SERVICE_STATE    FALSE

//
// Can we pause this service?
//
#define CAN_PAUSE_SERVICE           FALSE

#if (USE_SC_MANAGER)
    //
    // Name used for this service by the service controller manager.
    //
    #define SERVICE_SC_NAME         _T("TEMPLATE")
#endif // USE_SC_MANAGER

//
// Short descriptive name of the service.  This
// is what will show up as the name of the service
// in the internet manager tool.
//
// Issue: I'm assuming here that this name does NOT
//        require localisation.
//
#define SERVICE_SHORT_NAME      _T("Template v2.0")

//
// Longer name.  This is the text that shows up in
// the tooltips text on the internet manager
// tool.  This probably should be localised.
//

#define SERVICE_LONG_NAME      _T("Template Service")

//
// Use normal colour mapping.
//
#define NORMAL_TB_MAPPING          TRUE

//
// Toolbar button background mask. This is
// the colour that gets masked out in
// the bitmap file and replaced with the
// actual button background.  This setting
// is automatically assumed to be lt. gray
// if NORMAL_TB_MAPPING (above) is TRUE
//
#define BUTTON_BMP_BACKGROUND       RGB(192, 192, 192)      // Lt. Gray

//
// Resource ID of the toolbar button bitmap.
//
// The bitmap must be 17x17
//
#define BUTTON_BMP_ID               IDB_TEMPLATE

//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the service ID
//
#define SERVICE_BMP_BACKGROUND      BUTTON_BMP_BACKGROUND

//
// Bitmap id which is used in the service view
// of the service manager.  
//
// The bitmap must be 17x17, and can be the
// same as BUTTON_BMP_ID bitmap.
//
#define SERVICE_BMP_ID              BUTTON_BMP_ID

// ===========================================================================
//
// End Of Standard configuration Information
//
// ===========================================================================

//
// Helper Macros
//
#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))
//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)
 
//
// Global DLL instance
//
HINSTANCE hInstance;

// ============================================================================
//
// ISM API Functions
//
// ============================================================================

///////////////////////////////////////////////////////////////////////////////
//
// Return service-specific information back to
// to the application.  This function is called
// by the service manager immediately after
// LoadLibary();  The size element must be
// set prior to calling this API.
//
DLL_BASED DWORD  APIENTRY
ISMQueryServiceInfo(
    ISMSERVICEINFO * psi        // Service information returned.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    if ( psi == NULL
      || psi->dwSize < ISMSERVICEINFO_SIZE
       )
    {
        TRACE(_T("ISMQueryServiceInfo: ISMSERVICEINFO invalid\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

#ifdef _DEBUG

    if (psi->dwSize != ISMSERVICEINFO_SIZE)
    {
        TRACE(_T("Warning: internet manager is newer than DLL\n"));
    }

#endif // _DEBUG

    psi->dwSize = ISMSERVICEINFO_SIZE;
    psi->dwVersion = ISM_VERSION;

    psi->flServiceInfoFlags = 0
#if (INETSLOC_DISCOVERY)
        | ISMI_INETSLOCDISCOVER
#endif 
#if (CAN_CHANGE_SERVICE_STATE)
        | ISMI_CANCONTROLSERVICE   
#endif 
#if (CAN_PAUSE_SERVICE)
        | ISMI_CANPAUSESERVICE
#endif 
#if (NORMAL_TB_MAPPING)
        | ISMI_NORMALTBMAPPING
#endif
        ; /**/

    ASSERT(::lstrlen(SERVICE_LONG_NAME) <= MAX_LNLEN);
    ASSERT(::lstrlen(SERVICE_SHORT_NAME) <= MAX_SNLEN);

    psi->ullDiscoveryMask = INETSLOC_MASK;
    psi->rgbButtonBkMask = BUTTON_BMP_BACKGROUND;
    psi->nButtonBitmapID = BUTTON_BMP_ID;
    psi->rgbServiceBkMask = SERVICE_BMP_BACKGROUND;
    psi->nServiceBitmapID = SERVICE_BMP_ID;
    ::lstrcpy(psi->atchShortName, SERVICE_SHORT_NAME);
    ::lstrcpy(psi->atchLongName, SERVICE_LONG_NAME);

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// Discover machines running this service.  This is
// only necessary for services not discovered with
// inetscloc (which don't give a mask)
//
DLL_BASED DWORD APIENTRY
ISMDiscoverServers(
    ISMSERVERINFO * psi,        // Server info buffer.
    DWORD * pdwBufferSize,      // Size required/available.  
    int * cServers              // Number of servers in buffer.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

#if (INETSLOC_DISCOVERY)

    #error You do not need to provide a discovery method.

#else
    //
    // Dummy example, which discovers 2 servers running our service
    //
    int cServersFound = 2;
    DWORD dwRequiredSize = sizeof(ISMSERVERINFO) * cServersFound;

    if (*pdwBufferSize < dwRequiredSize || psi == NULL)
    {
        *pdwBufferSize = dwRequiredSize;
        *cServers = cServersFound;

        return ERROR_MORE_DATA;
    }

    psi[0].dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi[0].atchServerName, _T("\\FOO"));
    ::lstrcpy(psi[0].atchComment, _T("Dummy Entry 1"));
    psi[0].nState = INetServiceUnknown;

    psi[1].dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi[1].atchServerName, _T("\\BAR"));
    ::lstrcpy(psi[1].atchComment, _T("Dummy Entry 2"));
    psi[1].nState = INetServiceUnknown;

    return ERROR_SUCCESS;

#endif // (INETSLOC_DISCOVERY)
}

///////////////////////////////////////////////////////////////////////////////
//
// Get information about a specific server with
// regards to this service.  Usually this uses
// the service control manager
//
DLL_BASED DWORD APIENTRY
ISMQueryServerInfo(
    LPCTSTR lpstrServerName,    // Name of server.
    ISMSERVERINFO * psi         // Server information returned.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    if ( psi == NULL
      || psi->dwSize < ISMSERVERINFO_SIZE
      || ::lstrlen(lpstrServerName) > MAX_SERVERNAME_LEN
       )
    {
        TRACE(_T("ISMQueryServerInfo: bad parameters\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

#ifdef _DEBUG

    if (psi->dwSize != ISMSERVERINFO_SIZE)
    {
        TRACE(_T("Warning internet manager is newer than DLL\n"));
    }

#endif // _DEBUG

    psi->dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi->atchServerName, lpstrServerName);

#if (USE_SC_MANAGER)
    //
    // Provide simple SC management. This is probably
    // inadequate for real-world use.
    //
    SC_HANDLE hScManager;

    hScManager = ::OpenSCManager(lpstrServerName, NULL, SC_MANAGER_ENUMERATE_SERVICE);

    if (hScManager == NULL)
    {
        return ::GetLastError();
    }

    DWORD err = ERROR_SUCCESS;

    SC_HANDLE hService = ::OpenService(hScManager, 
        SERVICE_SC_NAME, SERVICE_QUERY_STATUS);

    if (hService == NULL)
    {
        err = ::GetLastError();
    }
    else
    {
        SERVICE_STATUS ss;

        VERIFY(::QueryServiceStatus(hService, &ss));
        switch(ss.dwCurrentState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            psi->nState = INetServiceStopped;
            break;

        case SERVICE_RUNNING:
        case SERVICE_START_PENDING:
        case SERVICE_CONTINUE_PENDING:
            psi->nState = INetServiceRunning;
            break;

        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            psi->nState = INetServicePaused;
            break;

        default:
            psi->nState = INetServiceUnknown;
        }

        ::CloseServiceHandle(hService);
    }

    ::CloseServiceHandle(hScManager);

    return err;

#else

    ::lstrcpy(psi->atchComment, _T("Dummy Entry"));
    psi->nState = INetServiceUnknown;

    return ERROR_SUCCESS;

#endif // USE_SC_MANAGER
}

///////////////////////////////////////////////////////////////////////////////
//
// Change the service state of the servers (to paused/continue, started,
// stopped, etc)
//
DLL_BASED DWORD APIENTRY
ISMChangeServiceState(
    int nNewState,              // INetService* definition.
    int * pnCurrentState,       // Ptr to current state (will be changed
    DWORD dwReserved,           // Reserved: must be 0
    LPCTSTR lpstrServers        // Double NULL terminated list of servers.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    if ( dwReserved != 0L
      || nNewState < INetServiceStopped 
      || nNewState > INetServicePaused
       )
    {
        TRACE(_T("ISMChangeServiceState: Invalid information passed\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

#if (USE_SC_MANAGER)
    //
    // Provide simple SC management.  This is probably
    // inadequate for real-world use.
    //
    SC_HANDLE hService;
    SC_HANDLE hScManager;
    hScManager = ::OpenSCManager(lpstrServers, NULL, SC_MANAGER_ALL_ACCESS);
                        
    if (hScManager == NULL)
    {
        return ::GetLastError();
    }
    hService = OpenService(hScManager, SERVICE_SC_NAME, SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
        return ::GetLastError();
    }

    SERVICE_STATUS ss;
    BOOL fSuccess;

    switch(nNewState)
    {
    case INetServiceStopped:
        fSuccess = ::ControlService(hService, SERVICE_CONTROL_STOP, &ss);
        break;

    case INetServiceRunning:
        if (*pnCurrentState == INetServicePaused)
        {
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_CONTINUE, &ss);
        }
        else
        {
            fSuccess = ::StartService(hService, 0, NULL);
        }
        break;

    case INetServicePaused:
        fSuccess = ::ControlService(hService, SERVICE_CONTROL_PAUSE, &ss);
        break;
    }

    //
    // Update state information
    //    
    VERIFY(::QueryServiceStatus(hService, &ss));
    switch(ss.dwCurrentState)
    {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        *pnCurrentState = INetServiceStopped;
        break;

    case SERVICE_RUNNING:
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
        *pnCurrentState = INetServiceRunning;
        break;

    case SERVICE_PAUSE_PENDING:
    case SERVICE_PAUSED:
        *pnCurrentState = INetServicePaused;
        break;

    default:
        *pnCurrentState = INetServiceUnknown;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hScManager);

    if (!fSuccess)
    {
        return ::GetLastError();
    }
     
    return ERROR_SUCCESS;

#else

    return ERROR_INVALID_FUNCTION;

#endif // USE_SC_MANAGER
}

///////////////////////////////////////////////////////////////////////////////
//
// Display configuration property sheet.
//
DLL_BASED DWORD APIENTRY
ISMConfigureServers(
    HWND hWnd,                  // Main app window handle
    DWORD dwReserved,           // Reserved: must be 0
    LPCTSTR lpstrServers        // Double NULL terminated list of servers
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    DWORD err;

    if (dwReserved != 0L)
    {
        TRACE(_T("ISMConfigureServers: Invalid information passed\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the list of servers to a 
    // more manageable CStringList.
    //
    LPCTSTR pBuf = lpstrServers;
    CStringList strlServers;
    while (*pBuf != TCHAR('\0'))
    {
        CString strTmp = pBuf;
        strlServers.AddTail( strTmp );
        pBuf += strTmp.GetLength() + 1;
    }

    if (strlServers.GetCount() == 0)
    {
        TRACE(_T("Error: strlServers Count == 0.\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    CString strCaption;

    if (strlServers.GetCount() == 1)
    {
        CString str;

        VERIFY(str.LoadString(IDS_CAPTION));
        strCaption.Format(str, PURE_COMPUTER_NAME(lpstrServers));
    }
    else // Multiple server caption
    {
        VERIFY(strCaption.LoadString(IDS_CAPTION_MULTIPLE));
    }

    //
    // Show property sheet with some dummy pages on it.
    //
    CPropertySheet sheet(strCaption, CWnd::FromHandle(hWnd));
    CTMServicePage page1;
    CTMSessionsPage page2;

    sheet.AddPage(&page1);
    sheet.AddPage(&page2);

    sheet.DoModal();

    //
    // Didn't do anything, but what we did, we did
    // perfectly.
    //
    err = ERROR_SUCCESS;

    return err;
}

// ============================================================================
//
// End of ISM API Functions
//
// ============================================================================

//
// Perform additional initialisation as necessary
//
void
InitializeDLL()
{
#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
#endif // _DEBUG
}

//
// Declare the one and only dll object
//
CConfigDll NEAR theApp;

CConfigDll::CConfigDll(
    IN LPCTSTR pszAppName OPTIONAL
    )
/*++

Routine Description:

    Constructor for USRDLL

Arguments:

    LPCTSTR pszAppName : Name of the app or NULL to load from resources

Return Value:

    N/A

--*/
    : CWinApp(pszAppName)
{
}

BOOL
CConfigDll::InitInstance()
/*++

Routine Description:

    Initialise current instance of the DLL

Arguments:

    None

Return Value:

    TRUE for successful initialisation, FALSE otherwise

--*/
{
    BOOL bInit = CWinApp::InitInstance();

    hInstance = ::AfxGetInstanceHandle();
    ASSERT(hInstance);
    InitializeDLL();

    return bInit;
}

int
CConfigDll::ExitInstance()
/*++

Routine Description:

    Clean up current instance

Arguments:

    None

Return Value:

    The applications exit code; 0 indicates no errors, and values greater
    than 0 indicate an error.

--*/
{
    return CWinApp::ExitInstance();
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CConfigDll, CWinApp)
    //{{AFX_MSG_MAP(CConfigDll)
    //}}AFX_MSG_MAP
    //
    // Global help commands (must be present)
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\tmscfg.h ===
//
// tmscfg.h
//
#include <lmcons.h>
#include <lmapibuf.h>

#include "resource.h"
#include "svrinfo.h"

class CConfigDll : public CWinApp
/*++

Class Description:

    USRDLL CWinApp module

Public Interface:

    CConfigDll : Constructor

    InitInstance : Perform initialization of this module
    ExitInstance : Perform termination and cleanup

--*/
{
public:
    CConfigDll(
        IN LPCTSTR pszAppName = NULL
        );

    virtual BOOL InitInstance();
    virtual int ExitInstance();

protected:
    //{{AFX_MSG(CConfigDll)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tmscfg.rc
//
#define IDB_TEMPLATE                    1000
#define IDS_TEMPLATE                    1000
#define IDS_CAPTION                     1001
#define IDB_TEMPLATE_VIEW               1001
#define IDS_CAPTION_MULTIPLE            1002
#define IDB_TEMPLATE_DIR                1002
#define IDD_SERVICE                     2000
#define IDD_SESSIONS                    2001
#define IDC_EDIT_EMAIL                  3017
#define IDC_EDIT_NAME                   3027
#define IDC_EDIT_TCP_PORT               3033
#define IDC_EDIT_CONNECTION_TIMEOUT     3034
#define IDC_SPIN_CONNECTION_TIMEOUT     3035
#define IDC_EDIT_MAX_CONNECTIONS        3036
#define IDC_SPIN_MAX_CONNECTIONS        3037
#define IDC_EDIT_COMMENT                3045

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2002
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3046
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\tmsessio.h ===
//////////////////////////////////////////////////////////////////////////////
//
// TMsessio.h : Header file for the "sessions" page
//              of the service control ui
//

// CTMSessionsPage dialog
//
class CTMSessionsPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CTMSessionsPage)

//
// Construction
//
public:
    CTMSessionsPage();   // standard constructor

    virtual void OnOK();

//
// Dialog Data
//
    //{{AFX_DATA(CTMSessionsPage)
    enum { IDD = IDD_SESSIONS };
    CSpinButtonCtrl m_spin_MaxConnections;
    CSpinButtonCtrl m_spin_ConnectionTimeOut;
    long    m_lTCPPort;
    //}}AFX_DATA

//
// Overrides
//
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CTMSessionsPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CTMSessionsPage)
    afx_msg void OnChangeEditConnectionTimeout();
    afx_msg void OnChangeEditMaxConnections();
    afx_msg void OnChangeEditTcpPort();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\tmsessio.cpp ===
//
// TMsessio.cpp : implementation file
//

#include "stdafx.h"

#include "TMscfg.h"
#include "TMsessio.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// CTMSessionsPage dialog
//
IMPLEMENT_DYNCREATE(CTMSessionsPage, CPropertyPage)

CTMSessionsPage::CTMSessionsPage()
    : CPropertyPage(CTMSessionsPage::IDD)
{
    //{{AFX_DATA_INIT(CTMSessionsPage)
    m_lTCPPort = 70;
    //}}AFX_DATA_INIT
}

void 
CTMSessionsPage::DoDataExchange(
    CDataExchange * pDX
    )
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTMSessionsPage)
    DDX_Control(pDX, IDC_SPIN_MAX_CONNECTIONS, m_spin_MaxConnections);
    DDX_Control(pDX, IDC_SPIN_CONNECTION_TIMEOUT, m_spin_ConnectionTimeOut);
    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_lTCPPort);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTMSessionsPage, CPropertyPage)
    //{{AFX_MSG_MAP(CTMSessionsPage)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnChangeEditConnectionTimeout)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnChangeEditMaxConnections)
    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnChangeEditTcpPort)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//
// CTMSessionsPage message handlers
//
BOOL 
CTMSessionsPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    
    m_spin_MaxConnections.SetRange(0, UD_MAXVAL);
    m_spin_ConnectionTimeOut.SetRange(0, UD_MAXVAL);

    m_spin_MaxConnections.SetPos(50);
    m_spin_ConnectionTimeOut.SetPos(600);
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//
// Called for both OnOK and ApplyNow()
// Save settings here...
//
void
CTMSessionsPage::OnOK()
{
    SetModified(FALSE);
}

void 
CTMSessionsPage::OnChangeEditConnectionTimeout()
{
    SetModified(TRUE);  
}

void 
CTMSessionsPage::OnChangeEditMaxConnections()
{
    SetModified(TRUE);      
}

void 
CTMSessionsPage::OnChangeEditTcpPort()
{
    SetModified(TRUE);              
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\tmsessio.cpp ===
//
// TMsessio.cpp : implementation file
//

#include "stdafx.h"

#include "TMscfg.h"
#include "TMsessio.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// CTMSessionsPage dialog
//
IMPLEMENT_DYNCREATE(CTMSessionsPage, CPropertyPage)

CTMSessionsPage::CTMSessionsPage()
    : CPropertyPage(CTMSessionsPage::IDD)
{
    //{{AFX_DATA_INIT(CTMSessionsPage)
    m_lTCPPort = 70;
    //}}AFX_DATA_INIT
}

void 
CTMSessionsPage::DoDataExchange(
    CDataExchange * pDX
    )
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTMSessionsPage)
    DDX_Control(pDX, IDC_SPIN_MAX_CONNECTIONS, m_spin_MaxConnections);
    DDX_Control(pDX, IDC_SPIN_CONNECTION_TIMEOUT, m_spin_ConnectionTimeOut);
    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_lTCPPort);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTMSessionsPage, CPropertyPage)
    //{{AFX_MSG_MAP(CTMSessionsPage)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnChangeEditConnectionTimeout)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnChangeEditMaxConnections)
    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnChangeEditTcpPort)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//
// CTMSessionsPage message handlers
//
BOOL 
CTMSessionsPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    
    m_spin_MaxConnections.SetRange(0, UD_MAXVAL);
    m_spin_ConnectionTimeOut.SetRange(0, UD_MAXVAL);

    m_spin_MaxConnections.SetPos(50);
    m_spin_ConnectionTimeOut.SetPos(600);
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//
// Called for both OnOK and ApplyNow()
// Save settings here...
//
void
CTMSessionsPage::OnOK()
{
    SetModified(FALSE);
}

void 
CTMSessionsPage::OnChangeEditConnectionTimeout()
{
    SetModified(TRUE);  
}

void 
CTMSessionsPage::OnChangeEditMaxConnections()
{
    SetModified(TRUE);      
}

void 
CTMSessionsPage::OnChangeEditTcpPort()
{
    SetModified(TRUE);              
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\tmsessio.h ===
//////////////////////////////////////////////////////////////////////////////
//
// TMsessio.h : Header file for the "sessions" page
//              of the service control ui
//

// CTMSessionsPage dialog
//
class CTMSessionsPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CTMSessionsPage)

//
// Construction
//
public:
    CTMSessionsPage();   // standard constructor

    virtual void OnOK();

//
// Dialog Data
//
    //{{AFX_DATA(CTMSessionsPage)
    enum { IDD = IDD_SESSIONS };
    CSpinButtonCtrl m_spin_MaxConnections;
    CSpinButtonCtrl m_spin_ConnectionTimeOut;
    long    m_lTCPPort;
    //}}AFX_DATA

//
// Overrides
//
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CTMSessionsPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CTMSessionsPage)
    afx_msg void OnChangeEditConnectionTimeout();
    afx_msg void OnChangeEditMaxConnections();
    afx_msg void OnChangeEditTcpPort();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\tmscfg.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// File:    tmscfg.cpp
// Purpose: API Entry points for service ui version 2.0
//

#include "stdafx.h"

#define DLL_BASED __declspec(dllexport)

#include "tmscfg.h"
#include "tmservic.h"
#include "tmsessio.h"

// ===========================================================================
//
// Standard configuration Information
//
// ===========================================================================

//
// Is this server discoverable by INETSLOC?
//
#define INETSLOC_DISCOVERY          FALSE

#if (INETSLOC_DISCOVERY) && !defined(_SVCLOC_)
    #error You must include svcloc.h.
#endif

//
// If INETSLOC_DISCOVERY == TRUE, define the discovery MASK here.
//
#if (INETSLOC_DISCOVERY) 
    #define INETSLOC_MASK               
#else  // (!INETSLOC_DISCOVERY) 
    #define INETSLOC_MASK           (ULONGLONG)(0x00000000)
#endif // (INETSLOC_DISCOVERY) 

//
// Do we use the service control manager to control
// the service we administer?
//
#define USE_SC_MANAGER              FALSE

//
// Can we change the service state (start/pause/continue)?
//
#define CAN_CHANGE_SERVICE_STATE    TRUE

//
// Can we pause this service?
//
#define CAN_PAUSE_SERVICE           FALSE

//
// Short descriptive name of the service.  This
// is what will show up as the name of the service
// in the internet manager tool.
//
// Issue: I'm assuming here that this name does NOT
//        require localisation.
//
#define SERVICE_SHORT_NAME      _T("Template K2")

//
// Longer name.  This is the text that shows up in
// the tooltips text on the internet manager
// tool.  This probably should be localised.
//

#define SERVICE_LONG_NAME      _T("Template K2 Service")

//
// Use normal colour mapping.
//
#define NORMAL_TB_MAPPING          TRUE

//
// Toolbar button background mask. This is
// the colour that gets masked out in
// the bitmap file and replaced with the
// actual button background.  This setting
// is automatically assumed to be lt. gray
// if NORMAL_TB_MAPPING (above) is TRUE
//
#define BUTTON_BMP_BACKGROUND       RGB(192, 192, 192)      // Lt. Gray

//
// Resource ID of the toolbar button bitmap.
//
// The bitmap must be 17x17
//
#define BUTTON_BMP_ID               IDB_TEMPLATE

//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the service ID
//
#define SERVICE_BMP_BACKGROUND      RGB(192, 192, 192)      // Lt. Gray

//
// Bitmap id which is used in the service view
// of the service manager.  
//
// The bitmap must be 17x17, and can be the
// same as BUTTON_BMP_ID bitmap.
//
#define SERVICE_BMP_ID              IDB_TEMPLATE_VIEW

//
// /* K2 */
//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the vdir bitmap
//
#define VDIR_BMP_BACKGROUND         RGB(192, 192, 192)      // Lt. Gray

//
// /* K2 */
//
// Bitmap id which is used virtual directory
//
// The bitmap must be 17x17.
//
#define VDIR_BMP_ID                 IDB_TEMPLATE_DIR


// ===========================================================================
//
// End Of Standard configuration Information
//
// ===========================================================================

//
// Helper Macros
//
#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))
//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)
 
//
// Global DLL instance
//
HINSTANCE hInstance;

TCHAR g_szComment[ MAX_COMMENT_LEN + 1 ] = _T("Test Entry");

// ============================================================================
//
// ISM API Functions
//
// ============================================================================

///////////////////////////////////////////////////////////////////////////////
//
// Return service-specific information back to
// to the application.  This function is called
// by the service manager immediately after
// LoadLibary();  The size element must be
// set prior to calling this API.
//
DLL_BASED DWORD  APIENTRY
ISMQueryServiceInfo(
    ISMSERVICEINFO * psi        // Service information returned.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    if ( psi == NULL
      || psi->dwSize < ISMSERVICEINFO_SIZE
       )
    {
        TRACE(_T("ISMQueryServiceInfo: ISMSERVICEINFO invalid\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

#ifdef _DEBUG

    if (psi->dwSize != ISMSERVICEINFO_SIZE)
    {
        TRACE(_T("Warning: internet manager is newer than DLL\n"));
    }

#endif // _DEBUG

    psi->dwSize = ISMSERVICEINFO_SIZE;
    psi->dwVersion = ISM_VERSION;

    psi->flServiceInfoFlags = 0

        | ISMI_VIRTUALROOTS

#if (INETSLOC_DISCOVERY)
        | ISMI_INETSLOCDISCOVER
#endif 
#if (CAN_CHANGE_SERVICE_STATE)
        | ISMI_CANCONTROLSERVICE   
#endif 
#if (CAN_PAUSE_SERVICE)
        | ISMI_CANPAUSESERVICE
#endif 
#if (NORMAL_TB_MAPPING)
        | ISMI_NORMALTBMAPPING
#endif
        ; /**/

    ASSERT(::lstrlen(SERVICE_LONG_NAME) <= MAX_LNLEN);
    ASSERT(::lstrlen(SERVICE_SHORT_NAME) <= MAX_SNLEN);

    psi->ullDiscoveryMask = INETSLOC_MASK;
    psi->rgbButtonBkMask = BUTTON_BMP_BACKGROUND;
    psi->nButtonBitmapID = BUTTON_BMP_ID;
    psi->rgbServiceBkMask = SERVICE_BMP_BACKGROUND;
    psi->nServiceBitmapID = SERVICE_BMP_ID;
    ::lstrcpy(psi->atchShortName, SERVICE_SHORT_NAME);
    ::lstrcpy(psi->atchLongName, SERVICE_LONG_NAME);

    //
    // /* K2 */
    //
    psi->rgbVDirBkMask = VDIR_BMP_BACKGROUND;
    psi->nVDirBitmapID = VDIR_BMP_ID ;

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// Discover machines running this service.  This is
// only necessary for services not discovered with
// inetscloc (which don't give a mask)
//
DLL_BASED DWORD APIENTRY
ISMDiscoverServers(
    ISMSERVERINFO * psi,        // Server info buffer.
    DWORD * pdwBufferSize,      // Size required/available.  
    int * cServers              // Number of servers in buffer.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

#if (INETSLOC_DISCOVERY)

    #error You do not need to provide a discovery method.

#else
    //
    // Dummy example, which discovers 2 servers running our service
    //
    int cServersFound = 2;
    DWORD dwRequiredSize = sizeof(ISMSERVERINFO) * cServersFound;

    if (*pdwBufferSize < dwRequiredSize || psi == NULL)
    {
        *pdwBufferSize = dwRequiredSize;
        *cServers = cServersFound;

        return ERROR_MORE_DATA;
    }

    psi[0].dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi[0].atchServerName, _T("\\FOO"));
    ::lstrcpy(psi[0].atchComment, _T("Dummy Discovery 1"));
    psi[0].nState = INetServiceUnknown;

    psi[1].dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi[1].atchServerName, _T("\\BAR"));
    ::lstrcpy(psi[1].atchComment, _T("Dummy Discovery 2"));
    psi[1].nState = INetServiceUnknown;

    return ERROR_SUCCESS;

#endif // (INETSLOC_DISCOVERY)
}

///////////////////////////////////////////////////////////////////////////////
//
// Get information about a specific server with
// regards to this service.  Usually this uses
// the service control manager
//
DLL_BASED DWORD APIENTRY
ISMQueryServerInfo(
    LPCTSTR lpstrServerName,    // Name of server.
    ISMSERVERINFO * psi         // Server information returned.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    if ( psi == NULL
      || psi->dwSize < ISMSERVERINFO_SIZE
      || ::lstrlen(lpstrServerName) > MAX_SERVERNAME_LEN
       )
    {
        TRACE(_T("ISMQueryServerInfo: bad parameters\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

#ifdef _DEBUG

    if (psi->dwSize != ISMSERVERINFO_SIZE)
    {
        TRACE(_T("Warning internet manager is newer than DLL\n"));
    }

#endif // _DEBUG

    psi->dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi->atchServerName, lpstrServerName);
    ::lstrcpy(psi->atchComment, _T("Test Entry"));
    psi->nState = INetServiceRunning;

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// Change the service state of the servers (to paused/continue, started,
// stopped, etc)
//
DLL_BASED DWORD APIENTRY
ISMChangeServiceState(
    int nNewState,              // INetService* definition.
    int * pnCurrentState,       // Ptr to current state (will be changed
    DWORD dwReserved,           // Reserved: must be 0
    LPCTSTR lpstrServers        // Double NULL terminated list of servers.
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    if ( dwReserved != 0L
      || nNewState < INetServiceStopped 
      || nNewState > INetServicePaused
       )
    {
        TRACE(_T("ISMChangeServiceState: Invalid information passed\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    ::Sleep(1000L);
    *pnCurrentState = nNewState;

    return ERROR_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// Display configuration property sheet.
//
DLL_BASED DWORD APIENTRY
ISMConfigureServers(
    HWND hWnd,                  // Main app window handle
    DWORD dwReserved,           // Reserved: must be 0
    LPCTSTR lpstrServers        // Double NULL terminated list of servers
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    DWORD err;

    if (dwReserved != 0L)
    {
        TRACE(_T("ISMConfigureServers: Invalid information passed\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the list of servers to a 
    // more manageable CStringList.
    //
    LPCTSTR pBuf = lpstrServers;
    CStringList strlServers;
    while (*pBuf != TCHAR('\0'))
    {
        CString strTmp = pBuf;
        strlServers.AddTail( strTmp );
        pBuf += strTmp.GetLength() + 1;
    }

    if (strlServers.GetCount() == 0)
    {
        TRACE(_T("Error: strlServers Count == 0.\n"));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    CString strCaption;

    if (strlServers.GetCount() == 1)
    {
        CString str;

        VERIFY(str.LoadString(IDS_CAPTION));
        strCaption.Format(str, PURE_COMPUTER_NAME(lpstrServers));
    }
    else // Multiple server caption
    {
        VERIFY(strCaption.LoadString(IDS_CAPTION_MULTIPLE));
    }

    //
    // Show property sheet with some dummy pages on it.
    //
    CPropertySheet sheet(strCaption, CWnd::FromHandle(hWnd));
    CTMServicePage page1;
    CTMSessionsPage page2;

    sheet.AddPage(&page1);
    sheet.AddPage(&page2);

    sheet.DoModal();

    //
    // Didn't do anything, but what we did, we did
    // perfectly.
    //
    err = ERROR_SUCCESS;

    return err;
}

ISMVROOTINFO vd[] = 
{
    { ISMVROOTINFO_SIZE, _T("/"),       _T("C:\\INETPUB") },
    { ISMVROOTINFO_SIZE, _T("Scripts"), _T("C:\\INETPUB\\SCRIPTS") },
};

//
// /* K2 */
//
// Enumerate vroots.  This API should first be called with a buffer
// size of 0, which will return the required number of bytes
//
DLL_BASED DWORD APIENTRY
ISMEnumerateVirtualRoots(
    ISMVROOTINFO * pii,         // VRoot info buffer
    DWORD * pdwBufferSize,      // Size required/available.  
    int * pcVRoots,             // Number of vroots in buffer.
    DWORD dwReserved,           // Reserved: must be 0
    LPCTSTR lpstrServer         // A single server
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

    DWORD err = ERROR_SUCCESS;

    if(pii == NULL)
    {
        *pcVRoots = sizeof(vd) / sizeof(vd[0]);
        *pdwBufferSize = *pcVRoots * sizeof(ISMVROOTINFO);

        return err;
    }

    //
    // Closing call to IISEnumerateInstances
    //

    //
    // Re-compute vroot count, since it's not guaranteed
    // to be correct
    //
    *pcVRoots = *pdwBufferSize / ISMVROOTINFO_SIZE;
    if (*pcVRoots <= 0)
    {
        //
        // VRoot count is invalid
        //
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    for(int i = 0; i < *pcVRoots; ++i)
    {
        pii[i].dwSize = ISMVROOTINFO_SIZE;

        ::lstrcpy(pii[i].atchAlias, vd[i].atchAlias);
        ::lstrcpy(pii[i].atchPath, vd[i].atchPath);
    }

    return ERROR_SUCCESS;
}


// ============================================================================
//
// End of ISM API Functions
//
// ============================================================================

//
// Perform additional initialisation as necessary
//
void
InitializeDLL()
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG
}

//
// Declare the one and only dll object
//
CConfigDll NEAR theApp;

CConfigDll::CConfigDll(
    IN LPCTSTR pszAppName OPTIONAL
    )
/*++

Routine Description:

    Constructor for USRDLL

Arguments:

    LPCTSTR pszAppName : Name of the app or NULL to load from resources

Return Value:

    N/A

--*/
    : CWinApp(pszAppName)
{
}

BOOL
CConfigDll::InitInstance()
/*++

Routine Description:

    Initialise current instance of the DLL

Arguments:

    None

Return Value:

    TRUE for successful initialisation, FALSE otherwise

--*/
{
    BOOL bInit = CWinApp::InitInstance();

    hInstance = ::AfxGetInstanceHandle();
    ASSERT(hInstance);
    InitializeDLL();

    return bInit;
}

int
CConfigDll::ExitInstance()
/*++

Routine Description:

    Clean up current instance

Arguments:

    None

Return Value:

    The applications exit code; 0 indicates no errors, and values greater
    than 0 indicate an error.

--*/
{
    return CWinApp::ExitInstance();
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CConfigDll, CWinApp)
    //{{AFX_MSG_MAP(CConfigDll)
    //}}AFX_MSG_MAP
    //
    // Global help commands (must be present)
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfg\tmservic.h ===
//
// CTMServicePage dialog
//
class CTMServicePage : public CPropertyPage
{
    DECLARE_DYNCREATE(CTMServicePage)

//
// Construction
//
public:
    CTMServicePage();
    ~CTMServicePage();

    virtual void OnOK();

//
// Dialog Data
//
    //{{AFX_DATA(CTMServicePage)
    enum { IDD = IDD_SERVICE };
    CString m_strEmail;
    CString m_strName;
    //}}AFX_DATA

//
// Overrides
//
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CTMServicePage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CTMServicePage)
    afx_msg void OnChangeEditName();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditEmail();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\macprop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ismmsmpl.rc
//
#define IDD_SAMPLE1                     101
#define IDD_SAMPLE2                     102
#define IDC_EDIT_NAME                   1000
#define IDC_EDIT2                       1001
#define IDC_EDIT3                       1002
#define IDC_STATIC                      -1
#define IDC_EDIT_MIN                    65535
#define IDC_EDIT_MAX                    65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\macprop\ismmsmpl.cpp ===
//
// ISM Machine Page Sample DLL
//
#include <windows.h>
#include "resource.h"

HINSTANCE g_hInstance = NULL;

//
// Main Entry Point
//
extern "C" int APIENTRY
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
    }

    //
    // Ok
    //
    return 1;   
}

//
// Property Page Dialog Procedure
//
BOOL
APIENTRY PageProc(
    HWND hDlg,
    UINT msg,
    UINT wParam,
    LONG lParam
    )
{
    static PROPSHEETPAGE * ps;

    switch (msg)
    {
    case WM_INITDIALOG: 
        //
        // Save the PROPSHEETPAGE information.
        //
        ps = (PROPSHEETPAGE *)lParam;
        return TRUE;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) 
        {
        case PSN_SETACTIVE:
            //
            // Initialize the controls.
            //
            break;

        case PSN_APPLY:
            SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
            break;

        case PSN_KILLACTIVE:
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
            return 1;

        case PSN_RESET:
            //
            // Reset to the original values.
            //
            SetWindowLong(hDlg, DWL_MSGRESULT, FALSE);
            break;
        }
    }
    return (FALSE);   

}

//
// Exported Function to Add 2 pages to the machine
// menu.
//
DWORD
ISMAddMachinePages(
    IN LPCTSTR lpstrMachineName,
    IN LPFNADDPROPSHEETPAGE lpfnAddPage,
    IN LPARAM lParam
    )
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage = NULL;

    DWORD err = ERROR_SUCCESS;

    //
    // Add Page 1
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_SAMPLE1);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = (DLGPROC)PageProc;
    psp.pszTitle = TEXT("Sample 1");
    psp.lParam = 0;

    hpage = ::CreatePropertySheetPage(&psp);
    if (hpage != NULL)
    {
        if (!lpfnAddPage(hpage, lParam))
        {
            err = ::GetLastError();
            ::DestroyPropertySheetPage(hpage);
        }
    }

    if (err != ERROR_SUCCESS)
    {
        return err;
    }

    //
    // Add Page 2
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_SAMPLE2);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = (DLGPROC)PageProc;
    psp.pszTitle = TEXT("Sample 2");
    psp.lParam = 0;

    hpage = ::CreatePropertySheetPage(&psp);
    if (hpage != NULL)
    {
        if (!lpfnAddPage(hpage, lParam))
        {
            err = ::GetLastError();
            ::DestroyPropertySheetPage(hpage);
        }
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\tmservic.cpp ===
#include "stdafx.h"

#include "TMscfg.h"
#include "TMservic.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern TCHAR g_szComment[];

//
// CTMServicePage property page
//
IMPLEMENT_DYNCREATE(CTMServicePage, CPropertyPage)

CTMServicePage::CTMServicePage()
    : CPropertyPage(CTMServicePage::IDD)
{
    //{{AFX_DATA_INIT(CTMServicePage)
    m_strEmail = _T("johnd");
    m_strName = _T("John Doe");
	m_strComment = g_szComment;
	//}}AFX_DATA_INIT
}

CTMServicePage::~CTMServicePage()
{
}

void
CTMServicePage::DoDataExchange(
    CDataExchange * pDX
    )
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTMServicePage)
    DDX_Text(pDX, IDC_EDIT_EMAIL, m_strEmail);
    DDX_Text(pDX, IDC_EDIT_NAME, m_strName);
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
	DDV_MaxChars(pDX, m_strComment, MAX_COMMENT_LEN);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTMServicePage, CPropertyPage)
    //{{AFX_MSG_MAP(CTMServicePage)
    ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
    ON_EN_CHANGE(IDC_EDIT_EMAIL, OnChangeEditEmail)
	ON_EN_CHANGE(IDC_EDIT_COMMENT, OnChangeEditComment)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// CTMServicePage message handlers
//
BOOL 
CTMServicePage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//
// Called for ApplyNow as well as OK.  Save stuff
// here
//
void
CTMServicePage::OnOK()
{
    ::lstrcpy(g_szComment, m_strComment);

    SetModified(FALSE);
}

void 
CTMServicePage::OnChangeEditName()
{
    SetModified(TRUE);
}

void
CTMServicePage::OnChangeEditEmail()
{
    SetModified(TRUE);
}

void 
CTMServicePage::OnChangeEditComment() 
{
    SetModified(TRUE);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "w3ext_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\template\cfgk2\tmservic.h ===
//
// CTMServicePage dialog
//
class CTMServicePage : public CPropertyPage
{
    DECLARE_DYNCREATE(CTMServicePage)

//
// Construction
//
public:
    CTMServicePage();
    ~CTMServicePage();

    virtual void OnOK();

//
// Dialog Data
//
    //{{AFX_DATA(CTMServicePage)
	enum { IDD = IDD_SERVICE };
    CString m_strEmail;
    CString m_strName;
	CString	m_strComment;
	//}}AFX_DATA

//
// Overrides
//
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CTMServicePage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CTMServicePage)
    afx_msg void OnChangeEditName();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditEmail();
	afx_msg void OnChangeEditComment();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_)
#define AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\editalias.h ===
// EditAlias.h : Declaration of the CEditAlias

#ifndef __EDITALIAS_H_
#define __EDITALIAS_H_

#include "resource.h"       // main symbols
#include "common.h"

// These constants depend on dialog layout
#define APP_PERM_NONE      0
#define APP_PERM_EXECUTE   1
#define APP_PERM_SCRIPTS   2

/////////////////////////////////////////////////////////////////////////////
// CEditAlias
class CEditAlias : 
	public CDialogImpl<CEditAlias>,
   public CWinDataExchange<CEditAlias>
{
public:
   CEditAlias() :
      m_read(FALSE),
      m_write(FALSE),
      m_source(FALSE),
      m_browse(FALSE),
      m_appcontrol(APP_PERM_NONE),
      m_pRootKey(NULL)
	{
	}

	~CEditAlias()
	{
	}

	enum { IDD = IDD_EDIT_ALIAS };

BEGIN_MSG_MAP_EX(CEditAlias)
	MSG_WM_INITDIALOG(OnInitDialog)
	COMMAND_ID_HANDLER_EX(IDOK, OnOK)
	COMMAND_ID_HANDLER_EX(IDCANCEL, OnCancel)
//   COMMAND_ID_HANDLER_EX(IDC_READ, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_WRITE, OnPermissions)
//   COMMAND_ID_HANDLER_EX(IDC_FULLCONTROL, OnPermissions)
//   COMMAND_ID_HANDLER_EX(IDC_DIRBROWSE, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_SCRIPTS_PERMS, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_EXECUTE_PERMS, OnPermissions)
   COMMAND_HANDLER_EX(IDC_ALIAS, EN_CHANGE, OnAliasChange)
END_MSG_MAP()

	LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
	void OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl);
	void OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnPermissions(WORD wNotifyCode, WORD wID, HWND hWndCtrl);
   void OnAccess(WORD wNotifyCode, WORD wID, HWND hWndCtrl);
   void OnAliasChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);

   BEGIN_DDX_MAP(CEditAlias)
      DDX_TEXT(IDC_PATH, m_path)
      DDX_TEXT(IDC_ALIAS, m_alias)
      DDX_CHECK(IDC_READ, m_read)
      DDX_CHECK(IDC_WRITE, m_write)
      DDX_CHECK(IDC_FULLCONTROL, m_source)
      DDX_CHECK(IDC_DIRBROWSE, m_browse)
      DDX_RADIO(IDC_NONE_PERMS, m_appcontrol)
   END_DDX_MAP()

   TCHAR m_path[MAX_PATH], m_alias[MAX_PATH];
   CString m_prev_alias;
//   CMetabasePath m_root;
   CString m_instance;
   BOOL  m_read, 
         m_write, 
         m_source,
         m_browse, 
         m_appcontrol, 
         m_new;
   BOOL  m_in_init;
//   CToolTipCtrl m_tool_tip;
   CMetaKey * m_pRootKey;
};

#endif //__EDITALIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\editalias.cpp ===
// EditAlias.cpp : Implementation of CEditAlias
#include "stdafx.h"
#include "W3PropPage.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "EditAlias.h"

/////////////////////////////////////////////////////////////////////////////
// CEditAlias

#define TOOLTIP_READ_PERMISSIONS      1000

LRESULT 
CEditAlias::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   CMetabasePath path(TRUE, SZ_MBN_WEB, m_instance, SZ_MBN_ROOT, m_new ? NULL : m_alias);
   CMetaKey mk(LOCAL_KEY, path);
   DWORD flags;
   m_prev_alias = m_alias;
   if (SUCCEEDED(mk.QueryValue(MD_ACCESS_PERM, flags)))
   {
      m_read = ((flags & MD_ACCESS_READ) != 0);
      m_write = ((flags & MD_ACCESS_WRITE) != 0);
      m_source = ((flags & MD_ACCESS_SOURCE) != 0);

      if (!m_new)
      {
         if ((flags & MD_ACCESS_EXECUTE) != 0)
            m_appcontrol = APP_PERM_EXECUTE;
         else if ((flags & MD_ACCESS_SOURCE) != 0)
            m_appcontrol = APP_PERM_SCRIPTS;
      }
      else
         m_appcontrol = APP_PERM_SCRIPTS;
   }
   else
   {
      EndDialog(0);
   }
   if (SUCCEEDED(mk.QueryValue(MD_DIRECTORY_BROWSING, flags)))
   {
      m_browse = ((flags & MD_DIRBROW_ENABLED) != 0);
   }
   else
   {
      EndDialog(0);
   }
   ::EnableWindow(GetDlgItem(IDOK), m_alias[0] != 0);
   m_in_init = TRUE;
   DoDataExchange();
   m_in_init = FALSE;

//   if (NULL != m_tool_tip.Create(hDlg))
//   {
//      RECT rc;
//      ::GetWindowRect(GetDlgItem(IDC_READ), &rc);
//      ScreenToClient(&rc);
//      m_tool_tip.AddTool(hDlg, 
//         _T("Users could read this directory"),
//         &rc, TOOLTIP_READ_PERMISSIONS
//         );
//   }
   return 1;
}

void 
CEditAlias::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CError err;
   DWORD app_state = 0;
   DoDataExchange(TRUE);
   CMetabasePath alias(FALSE, m_alias);
   CMetabasePath::CleanMetaPath(alias);
   if (alias.QueryMetaPath()[0] == 0)
   {
      CString cap, msg;
      cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
      msg.Format(_Module.GetResourceInstance(), IDS_BAD_ALIAS, m_alias);
      MessageBox(msg, cap);
      ::SetFocus(GetDlgItem(IDC_ALIAS));
      SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
      return;
   }
   CMetabasePath path(TRUE, SZ_MBN_WEB, m_instance, 
      SZ_MBN_ROOT, alias.QueryMetaPath());
   CMetabasePath::CleanMetaPath(path);
   CMetabasePath parent(path);
   CString sub_alias;
   CMetabasePath::GetLastNodeName(path, sub_alias);
   CMetabasePath::ConvertToParentPath(parent);
   CWaitCursor wait;
   do 
   {
      if (!m_new)
      {
         if (m_prev_alias.Compare(m_alias) != 0)
         {
            CMetabasePath prev_path(TRUE, SZ_MBN_WEB, m_instance, SZ_MBN_ROOT, m_prev_alias);
            CIISApplication app(NULL, prev_path);
            err = app.QueryResult();
            BREAK_ON_ERR_FAILURE(err)
            app_state = app.QueryAppState();
            err = app.Delete();
            BREAK_ON_ERR_FAILURE(err)
            CString str;
            CMetabasePath::GetLastNodeName(prev_path, str);
            CMetabasePath::ConvertToParentPath(prev_path);
            CMetaKey mk_prev(LOCAL_KEY, prev_path, METADATA_PERMISSION_WRITE);
            err = mk_prev.DeleteKey(str);
            BREAK_ON_ERR_FAILURE(err)
         }
      }
      //make sure the parent is there
      CMetaKey mk(LOCAL_KEY, parent, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
      err = mk.QueryResult();
      if (err.Failed())
	   {
         if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
         {
            CString caption, msg;
            caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
            msg.LoadString(_Module.GetResourceInstance(), IDS_NO_PARENT);
	         MessageBox (msg, caption, MB_OK);
            ::SetFocus(GetDlgItem(IDC_ALIAS));
            SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
            break;
         }
         err.MessageBox();
         break;
	   }
      // if we are editing, delete previous vdir and application
      if (m_new)
      {
         // check if this alias is already available
         err = mk.DoesPathExist(sub_alias);
         if (err.Succeeded())
         {
            CString caption, fmt, msg;
            caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
            fmt.LoadString(_Module.GetResourceInstance(), IDS_ALIAS_IS_TAKEN);
            msg.Format(fmt, path.QueryMetaPath());
            MessageBox (msg, caption, MB_OK);
            ::SetFocus(GetDlgItem(IDC_ALIAS));
            SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
            err = E_FAIL;
            break;
         }
         err = S_OK;
      }
      if (err.Succeeded())
      {
         err = mk.AddKey(sub_alias);
         BREAK_ON_ERR_FAILURE(err)
         err = mk.SetValue(MD_KEY_TYPE, CString(_T("IIsWebVirtualDir")), NULL, sub_alias);
         BREAK_ON_ERR_FAILURE(err)
         err = mk.SetValue(MD_VR_PATH, CString(m_path), NULL, sub_alias);
         BREAK_ON_ERR_FAILURE(err)
      }
      // apply permissions
      DWORD flags;
      mk.QueryValue(MD_ACCESS_PERM, flags, NULL, sub_alias);
      flags &= ~(MD_ACCESS_READ|MD_ACCESS_WRITE|MD_ACCESS_SOURCE|MD_ACCESS_SCRIPT|MD_ACCESS_EXECUTE);
      flags |= m_read ? MD_ACCESS_READ : 0;
      flags |= m_write ? MD_ACCESS_WRITE : 0;
      flags |= m_source ? MD_ACCESS_SOURCE : 0;
      if (m_appcontrol == APP_PERM_SCRIPTS)
         flags |= MD_ACCESS_SCRIPT;
      else if (m_appcontrol == APP_PERM_EXECUTE)
         flags |= MD_ACCESS_SCRIPT|MD_ACCESS_EXECUTE;
      mk.SetValue(MD_ACCESS_PERM, flags, NULL, sub_alias);
      
      mk.QueryValue(MD_DIRECTORY_BROWSING, flags, NULL, sub_alias);
      flags &= ~MD_DIRBROW_ENABLED;
      flags |= m_browse ? MD_DIRBROW_ENABLED : 0;
      err = mk.SetValue(MD_DIRECTORY_BROWSING, flags, NULL, sub_alias);
   } while (FALSE);
   if (err.Succeeded())
   {
      CIISApplication app(NULL, path);
      err = app.QueryResult();
      if (err.Succeeded())
      {
         err = app.Create(NULL, 
            app_state ? app_state : CWamInterface::APP_POOLEDPROC);
      }
      if (err.Succeeded())
         EndDialog(wID);
   }
}

void 
CEditAlias::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   EndDialog(wID);
}

void 
CEditAlias::OnPermissions(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   if (!m_in_init)
   {
      DoDataExchange(TRUE);
      if (m_write && m_appcontrol > 0)
      {
         CString caption, msg;
         VERIFY(caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE));
         VERIFY(msg.LoadString(_Module.GetResourceInstance(), IDS_WRITEEXECUTE_DANGER));
	      if (IDNO == MessageBox(msg, caption, MB_YESNO | MB_ICONEXCLAMATION))
         {
            CheckDlgButton(wID, 0);
            if (wID != IDC_WRITE)
            {
               CheckDlgButton(IDC_NONE_PERMS, 1);
            }
         }
      }
   }
}

void 
CEditAlias::OnAliasChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   if (!m_in_init)
   {
      DoDataExchange(TRUE);
      ::EnableWindow(GetDlgItem(IDOK), m_alias[0] != 0);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w3ext.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPSHELLEXT_DESC           101
#define IDR_PROP_SHELL_EXT              102
#define IDS_SERVICE_NAME                102
#define IDD_W3PROPERTY_PAGE             103
#define IDS_PAGE_TITLE                  103
#define IDS_DEFAULT_SERVER_COMMENT      104
#define IDS_NO_PARENT                   105
#define IDS_WRITEEXECUTE_DANGER         106
#define IDS_ALIAS_IS_TAKEN              107
#define IDS_CONFIRM_REMOVE              108
#define IDS_CONFIRM_REMOVE_ALL          109
#define IDI_ICON_WEB_SERVICE            110
#define IDS_BAD_ALIAS                   110
#define IDI_ICON_IIS                    111
#define IDC_ICON_WEB_SERVICE            201
#define IDC_STATIC_STATUS               202
#define IDD_EDIT_ALIAS                  202
#define IDC_STATIC_SHARE_ON             203
#define IDC_COMBO_SERVER                204
#define IDC_SHARE_OFF                   205
#define IDC_SHARE_ON                    206
#define IDC_STATIC_ALIAS_TITLE          207
#define IDC_LIST                        208
#define IDC_ADD                         209
#define IDC_EDIT                        210
#define IDC_REMOVE                      211
#define IDC_STATIC_ICON_IIS             212
#define IDC_ALIAS                       213
#define IDC_READ                        214
#define IDC_WRITE                       215
#define IDC_FULLCONTROL                 216
#define IDC_DIRBROWSE                   217
#define IDC_NONE_PERMS                  218
#define IDC_SCRIPTS_PERMS               219
#define IDC_EXECUTE_PERMS               220
#define IDC_PATH                        221

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED_)
#define AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define _WTL_NO_CSTRING

#include <shellapi.h>
#include <shlobj.h>
#include <shlguid.h>
#include <shlwapi.h>

#include <comdef.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlctrlx.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <set>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\anondlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        anondlg.h

   Abstract:

        WWW Anonymous account dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _ANONDLG_H_
#define _ANONDLG_H_




class CAnonymousDlg : public CDialog
/*++

Class Description:

    Anonymous authentication dialog

Public Interface:

    CAnonymousDlg       : Constructor

    GetUserName         : Get user name entered
    GetPassword         : Get password entered
    GetPasswordSync     : Get password sync entered

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CAnonymousDlg(
        IN CString & strServerName,
        IN CString & strUserName,
        IN CString & strPassword,
        IN BOOL & fPasswordSync,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    CString & GetUserName()  { return m_strUserName; }
    CString & GetPassword()  { return m_strPassword; }
    BOOL & GetPasswordSync() { return m_fPasswordSync; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAnonymousDlg)
    enum { IDD = IDD_ANONYMOUS };
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CStatic m_static_Username;
    CStatic m_static_Password;
    CButton m_button_CheckPassword;
    CButton m_group_AnonymousLogon;
    CButton m_chk_PasswordSync;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAnonymousDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAnonymousDlg)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnChangeEditUsername();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    void SetControlStates();

private:
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fUserNameChanged;
    BOOL m_fPasswordSync;
    CString m_strUserName;
    CString m_strPassword;
    CString & m_strServerName;
};



#endif // _ANONDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\propshellext.cpp ===
// PropShellExt.cpp : Implementation of CW3extApp and DLL registration.

#include "stdafx.h"
#include "w3ext.h"
#include "PropShellExt.h"

/////////////////////////////////////////////////////////////////////////////
//
// IShellExtInit Implementation.

STDMETHODIMP 
CPropShellExt::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID)
{
   if (pDataObj == NULL)
   {
      ATLASSERT(FALSE);
      return (E_INVALIDARG);
   }
   FORMATETC f = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
   STGMEDIUM m;
   HRESULT hr = pDataObj->GetData(&f, &m);
   if (FAILED(hr))
   {
      return(hr);
   }
   if (1 == DragQueryFile((HDROP)m.hGlobal, (UINT)(-1), NULL,0))
   {
      TCHAR szFileName[MAX_PATH];
      DragQueryFile((HDROP)m.hGlobal, 0, szFileName, sizeof(szFileName));
      SHFILEINFO shfi;
      SHGetFileInfo(szFileName, 0, &shfi, sizeof(SHFILEINFO), SHGFI_ATTRIBUTES);
      if (  (shfi.dwAttributes & (SFGAO_LINK | SFGAO_REMOVABLE)) == 0
         && (shfi.dwAttributes & SFGAO_FILESYSTEM) != 0
         )
      {
         int drive_number, drive_type;
         TCHAR szRoot[4];
         if (  -1 != (drive_number = PathGetDriveNumber(szFileName))
            && NULL != PathBuildRoot(szRoot, drive_number)
            && DRIVE_REMOTE != (drive_type = GetDriveType(szRoot))
            && DRIVE_NO_ROOT_DIR != drive_type
            )
         {
            StrCpy(m_szFileName, szFileName);
         }
      }
   }
   ReleaseStgMedium(&m);
   return hr;
}


STDMETHODIMP 
CPropShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
   // We only add the page if the user has admin priviliges in the metabase.
   // The only way to check it now is to try to write something.
   // Test key is /LM/W3SVC.
   CMetabasePath path(SZ_MBN_WEB);
   CMetaKey key(LOCAL_KEY, path,
      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
      );
   if (key.Succeeded() && SUCCEEDED(key.SetValue(MD_ISM_ACCESS_CHECK, 0x0000FFFF)))
   {
      m_psW3ShellExtProp.SetParentExt(this);
      HPROPSHEETPAGE hpage = m_psW3ShellExtProp.Create();
      ASSERT(hpage != NULL);
      if (NULL != hpage)
      {
         AddRef();
         if (!lpfnAddPage(hpage, lParam))
         {
            DestroyPropertySheetPage(hpage);
         }
      }
   }
   return key.QueryResult();
}


STDMETHODIMP 
CPropShellExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
   return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\w3ext.cpp ===
// w3ext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for w3ext.idl by adding the following 
//      files to the Outputs.
//          w3ext_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f w3extps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "w3ext.h"
#include "dlldatax.h"

#include "w3ext_i.c"
#include "PropShellExt.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(CLSID_PropShellExt, CPropShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_W3EXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\propshellext.h ===
// PropShellExt.h: Definition of the CPropShellExt class
//
//////////////////////////////////////////////////////////////////////

#if !defined(_PROPSHELLEXT_H)
#define _PROPSHELLEXT_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "common.h"
#include "mdkeys.h"
#include "W3PropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CPropShellExt

class CPropShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropShellExt,&CLSID_PropShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt
{
public:
   CPropShellExt()
   {
   }

BEGIN_COM_MAP(CPropShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPropShellExt) 

DECLARE_REGISTRY_RESOURCEID(IDR_PROP_SHELL_EXT)

public:
   // IShellExtInit Methods
   STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID );

   //IShellPropSheetExt methods
   STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
   STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

//   const CComAuthInfo * GetAuthentication() const
//   {
//      return &m_auth;
//   }
   LPCTSTR GetPath()
   {
      return m_szFileName;
   }

private:
   TCHAR m_szFileName[MAX_PATH];
//   CComAuthInfo m_auth;
	CW3PropPage m_psW3ShellExtProp;
};

#endif // !defined(_PROPSHELLEXT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\w3proppage.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        W3PropPage.h

   Abstract:
        IIS Shell extension PropertyPage class definition

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef __W3PROPPAGE_H_
#define __W3PROPPAGE_H_

#include "resource.h"       // main symbols

class CPropShellExt;
class CMetaEnumerator;

#define LOCAL_KEY    ((CComAuthInfo *)NULL)

template <class T, bool bAutoDelete = true>
class CShellExtPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CShellExtPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK | PSP_USEREFPARENT | PSP_DEFAULT;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
      m_psp.pcRefParent = reinterpret_cast<UINT *>(&_Module.m_nLockCnt);
      m_psp.lParam = reinterpret_cast<LPARAM>(this);

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE || uMsg == PSPCB_ADDREF)
		{
			CDialogImplBase * pPage = (CDialogImplBase *)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T * pPage = (T *)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}
};

class CComboBoxExch : public CWindowImpl<CComboBoxExch, CComboBox>
{
public:
   BEGIN_MSG_MAP_EX(CComboBoxExch)
   END_MSG_MAP()
};

class CListBoxExch : public CWindowImpl<CListBoxExch, CListBox>
{
public:
   BEGIN_MSG_MAP_EX(CListBoxExch)
   END_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CW3PropPage

// We cannot make this class autodelete -- we are storing instance of this page 
// inside of shell extension module
//
class CW3PropPage : 
   public CShellExtPropertyPageImpl<CW3PropPage, false>,
   public CWinDataExchange<CW3PropPage>
{
public:
   CW3PropPage() :
      CShellExtPropertyPageImpl<CW3PropPage, false>(MAKEINTRESOURCE(IDS_PAGE_TITLE)),
      m_pParentExt(NULL)
	{
	}

	~CW3PropPage()
	{
	}

	enum { IDD = IDD_W3PROPERTY_PAGE };

BEGIN_MSG_MAP_EX(CW3PropPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   MSG_WM_DESTROY(OnDestroy)
	COMMAND_ID_HANDLER_EX(IDC_ADD, OnAdd)
	COMMAND_ID_HANDLER_EX(IDC_REMOVE, OnRemove)
	COMMAND_ID_HANDLER_EX(IDC_EDIT, OnEdit)
   COMMAND_HANDLER_EX(IDC_COMBO_SERVER, CBN_SELCHANGE, OnServerChange)
   COMMAND_HANDLER_EX(IDC_SHARE_OFF, BN_CLICKED, OnShareYesNo)
   COMMAND_HANDLER_EX(IDC_SHARE_ON, BN_CLICKED, OnShareYesNo)
   COMMAND_HANDLER_EX(IDC_LIST, LBN_SELCHANGE, OnVDirChange)
   COMMAND_HANDLER_EX(IDC_LIST, LBN_DBLCLK, OnEdit)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnDestroy();
	void OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl);
	void OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl);
	void OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnServerChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnShareYesNo(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnVDirChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);

   BEGIN_DDX_MAP(CW3PropPage)
      DDX_CONTROL(IDC_COMBO_SERVER, m_servers_list)
      DDX_CONTROL(IDC_LIST, m_share_list)
   END_DDX_MAP()

   void SetParentExt(CPropShellExt * pExt)
   {
      m_pParentExt = pExt;
   }

protected:
   void RecurseVDirs(CMetaEnumerator& en, LPCTSTR path);
   void EnableOnShare();

protected:
   CComboBoxExch m_servers_list;
   CListBoxExch m_share_list;
   BOOL m_ShareThis;
   CPropShellExt * m_pParentExt;
};

#endif //__W3PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3ext\w3proppage.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        W3PropPage.cpp

   Abstract:
        IIS Shell extension PropertyPage class implementation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "W3PropPage.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "EditAlias.h"

#define SZ_SERVER_KEYTYPE     _T("IIsWebServer")

/////////////////////////////////////////////////////////////////////////////
// CW3PropPage

LRESULT 
CW3PropPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   // subclass dialog controls
   DoDataExchange();

   ASSERT(m_pParentExt != NULL);
   CMetaEnumerator en(LOCAL_KEY, CMetabasePath(SZ_MBN_WEB));
   ASSERT(en.Succeeded());
   if (en.Succeeded())
   {
      DWORD di;
      int i = -1;
      CString inst;
      HRESULT hr = S_OK;
      while (SUCCEEDED(hr))
      {
         if (SUCCEEDED(hr = en.Next(di, inst)))
         {
            CString cmt;
            if (SUCCEEDED(hr = en.QueryValue(MD_SERVER_COMMENT, cmt, NULL, inst)))
            {
               if (cmt.IsEmpty())
               {
                  cmt.Format(_Module.GetResourceInstance(), 
                     IDS_DEFAULT_SERVER_COMMENT, di);
               }
               if (CB_ERR != (i = m_servers_list.AddString(cmt)))
               {
                  m_servers_list.SetItemDataPtr(i, StrDup(inst));
               }
            }
         }
      }
      if (i >= 0)
         m_servers_list.SetCurSel(0);

      m_ShareThis = 0;

      // Fill shares list box for selected server
      OnServerChange(0, 0, NULL);
   }
   return 1;
}

void 
CW3PropPage::OnDestroy()
{
   ATLTRACE("In OnDestroy handler\n");
//   DebugBreak();
}

HRESULT GetKeyNames(CMetaEnumerator& en, std::set<CString>& keys)
{
   CString key;
   HRESULT hr;
   if (SUCCEEDED(hr = en.Next(key)))
   {
      keys.insert(key);
   }
   return hr;
}

void 
CW3PropPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CEditAlias dlg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   dlg.m_instance = p;
   p = m_pParentExt->GetPath();
   ::StrCpy(dlg.m_path, p);
   dlg.m_new = TRUE;
   if (p == PathFindFileName(p))
   {
      /* No file name -- could be root directory like c:\ */
      dlg.m_alias[0] = 0;
   }
   else
   {
      TCHAR buf[MAX_PATH];

      StrCpy(buf, PathFindFileName(p));
      PathMakePretty(buf);
      StrCpy(dlg.m_alias, buf);
      // Now we need to generate unique prompt for this new alias
      CMetaEnumerator en(LOCAL_KEY, 
         CMetabasePath(TRUE, SZ_MBN_WEB, dlg.m_instance, SZ_MBN_ROOT));
      ASSERT(en.Succeeded());
      if (en.Succeeded())
      {
         std::set<CString> keys;
         if (SUCCEEDED(GetKeyNames(en, keys)) && !keys.empty())
         {
            int i = 0;
            while (keys.find(buf) != keys.end())
            {
               wsprintf(buf, _T("%s%d"), dlg.m_alias, ++i);
            }
            StrCpy(dlg.m_alias, buf);
         }
      }
   }
   if (IDOK == dlg.DoModal())
   {
      OnServerChange(0, 0, NULL);
   }
}

void 
CW3PropPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CString cap, msg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
   index = m_share_list.GetCurSel();
   TCHAR buf[MAX_PATH];
   m_share_list.GetText(index, buf);
   msg.Format(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE, buf);
   CError err;
   if (IDYES == MessageBox(msg, cap, MB_YESNO))
   {
      CWaitCursor wait;

      do 
      {
         CIISApplication app(NULL, CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT, buf));
         err = app.QueryResult();
         BREAK_ON_ERR_FAILURE(err)
         err = app.Delete(TRUE);
      } while (FALSE);
      if (err.Succeeded())
      {
         CMetaKey mk(LOCAL_KEY, 
            CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT),
            METADATA_PERMISSION_WRITE);
         err = mk.DeleteKey(buf);
      }
   }
   if (err.Failed())
   {
      err.MessageBox();
   }
   else
   {
      m_share_list.DeleteString(index);
      int count = m_share_list.GetCount();
      m_ShareThis = count > 0 ? 1 : 0;
      if (m_ShareThis)
      {
         m_share_list.SetCurSel(index >= count ? count - 1 : index);
      }
      EnableOnShare();
      CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
      CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
   }
}

void 
CW3PropPage::OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CEditAlias dlg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   dlg.m_instance = p;
   p = m_pParentExt->GetPath();
   ::StrCpy(dlg.m_path, p);
   index = m_share_list.GetCurSel();
   TCHAR buf[MAX_PATH];
   m_share_list.GetText(index, buf);
   ::StrCpy(dlg.m_alias, buf);
   dlg.m_new = FALSE;
   if (IDOK == dlg.DoModal())
   {
      OnServerChange(0, 0, NULL);
   }
}

void 
CW3PropPage::OnServerChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   // get selected server instance number
   int index = m_servers_list.GetCurSel();
   if (LB_ERR != index)
   {
      LPTSTR p = (LPTSTR)m_servers_list.GetItemDataPtr(index);
      CMetabasePath path(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT);
      CMetaEnumerator en(LOCAL_KEY, path);
      ASSERT(en.Succeeded());
      m_share_list.ResetContent();
      if (en.Succeeded())
      {
         RecurseVDirs(en, NULL);
      }
      m_ShareThis = m_share_list.GetCount() > 0 ? 1 : 0;
   }
   if (m_ShareThis)
   {
      m_share_list.SetCurSel(0);
   }
   EnableOnShare();
   CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
   CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
}

void
CW3PropPage::RecurseVDirs(CMetaEnumerator& en, LPCTSTR path)
{
   CString vrpath;
   BOOL bInheritOverride = FALSE;
   if (SUCCEEDED(en.QueryValue(MD_VR_PATH, vrpath, &bInheritOverride, path)))
   {
      if (vrpath.CompareNoCase(m_pParentExt->GetPath()) == 0)
      {
         CMetabasePath mpath(FALSE, path);
         CMetabasePath::CleanMetaPath(mpath);
         m_share_list.AddString(path == NULL ? 
            SZ_MBN_SEP_STR : mpath.QueryMetaPath());
      }
   }
   CString vdir;
   while (SUCCEEDED(en.Next(vdir, path)))
   {
      CString next_vdir;
      if (path != NULL)
         next_vdir += path;
      next_vdir += vdir;
      next_vdir += SZ_MBN_SEP_STR;
      en.Push();
      en.Reset();
      RecurseVDirs(en, next_vdir);
      en.Pop();
   }
}

void 
CW3PropPage::OnShareYesNo(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   int count = m_share_list.GetCount();
   m_ShareThis = IsDlgButtonChecked(IDC_SHARE_ON);
   if (m_ShareThis)
   {
      if (count <= 0)
      {
         OnAdd(0, 0, NULL);
         if (!(m_ShareThis = (m_share_list.GetCount() > 0)))
         {
            CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
            CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
         }
      }
   }
   else
   {
      if (count > 0)
      {
         CString cap, msg;
         int index = m_servers_list.GetCurSel();
         LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
         cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
         msg.LoadString(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE_ALL);
         CError err;
         if (IDYES == MessageBox(msg, cap, MB_YESNO))
         {
            CWaitCursor wait;
            TCHAR alias[MAX_PATH];
            for (index = 0; err.Succeeded() && index < count; index++)
            {
               m_share_list.GetText(0, alias);
               do 
               {
                  CIISApplication app(NULL, CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT, alias));
                  err = app.QueryResult();
                  BREAK_ON_ERR_FAILURE(err)
                  err = app.Delete(TRUE);
                  BREAK_ON_ERR_FAILURE(err)
                  CMetaKey mk(LOCAL_KEY, 
                     CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT),
                     METADATA_PERMISSION_WRITE);
                  err = mk.DeleteKey(alias);
                  BREAK_ON_ERR_FAILURE(err)
               } while (FALSE);
               BREAK_ON_ERR_FAILURE(err)
               m_share_list.DeleteString(0);
            }
            if (err.Failed())
            {
// BUGBUG: we have AV when preparing message box text here
//               err.MessageBox();
               m_ShareThis = TRUE;
               CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
               CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
            }
         }
         else
         {
            m_ShareThis = TRUE;
            CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
            CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
         }
      }
   }
   EnableOnShare();
}

void
CW3PropPage::EnableOnShare()
{
   m_share_list.EnableWindow(m_ShareThis);
   ::EnableWindow(GetDlgItem(IDC_ADD), m_ShareThis);
   ::EnableWindow(GetDlgItem(IDC_EDIT), m_ShareThis 
      && m_share_list.GetCurSel() != LB_ERR);
   ::EnableWindow(GetDlgItem(IDC_REMOVE), m_ShareThis
      && m_share_list.GetCurSel() != LB_ERR);
}

void 
CW3PropPage::OnVDirChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   BOOL bSel = m_share_list.GetCurSel() != LB_ERR;
   ::EnableWindow(GetDlgItem(IDC_EDIT), bSel);
   ::EnableWindow(GetDlgItem(IDC_REMOVE), bSel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\apps.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "apps.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CApps

IMPLEMENT_DYNCREATE(CApps, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CApps properties

short CApps::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CApps::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

CString CApps::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CApps::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

BOOL CApps::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CApps::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

COleFont CApps::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CApps::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CApps operations

void CApps::DeleteParameters()
{
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CApps::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget, BOOL fLocalMachine)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR VTS_BOOL;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget, fLocalMachine);
}

void CApps::SetShowProcOptions(BOOL fShowProcOptions)
{
    static BYTE parms[] =
        VTS_BOOL;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         fShowProcOptions);
}

void CApps::DeleteProcParameters()
{
    InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CApps::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\apps.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CApps wrapper class

class CApps : public CWnd
{
protected:
    DECLARE_DYNCREATE(CApps)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba63460b, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    short GetBorderStyle();
    void SetBorderStyle(short);
    CString GetCaption();
    void SetCaption(LPCTSTR);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    COleFont GetFont();
    void SetFont(LPDISPATCH);

// Operations
public:
    void DeleteParameters();
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget, BOOL fLocalMachine);
    void SetShowProcOptions(BOOL fShowProcOptions);
    void DeleteProcParameters();
    void DoClick();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\anondlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        anondlg.cpp

   Abstract:

        WWW Anonymous account dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "anondlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CAnonymousDlg::CAnonymousDlg(
    IN CString & strServerName,
    IN CString & strUserName,
    IN CString & strPassword,
    IN BOOL & fPasswordSync,
    IN CWnd * pParent  OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    CString & strUserName       : User name
    CString & strPassword       : Password
    BOOL & fPasswordSync        : TRUE for password sync
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CAnonymousDlg::IDD, pParent),
      m_strServerName(strServerName),
      m_strUserName(strUserName),
      m_strPassword(strPassword),
      m_fPasswordSync(fPasswordSync),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CAnonymousDlg)
    m_strUserName = _T("");
    m_fPasswordSync = FALSE;
    //}}AFX_DATA_INIT

    m_strPassword = _T("");

#endif // 0

}


void 
CAnonymousDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAnonymousDlg)
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_STATIC_USERNAME, m_static_Username);
    DDX_Control(pDX, IDC_STATIC_PASSWORD, m_static_Password);
    DDX_Control(pDX, IDC_STATIC_ANONYMOUS_LOGON, m_group_AnonymousLogon);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Control(pDX, IDC_BUTTON_CHECK_PASSWORD, m_button_CheckPassword);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_strUserName.TrimLeft();
    while (*m_strUserName == '\\')
    {
        m_strUserName = m_strUserName.Mid(2);
    }

    //
    // Display the remote password sync message if
    // password sync is on, the account is not local,
    // password sync has changed or username has changed
    // and the message hasn't already be shown.
    //
    if (pDX->m_bSaveAndValidate && m_fPasswordSync 
        && !IsLocalAccount(m_strUserName)
        && (m_fPasswordSyncChanged || m_fUserNameChanged)
        && !m_fPasswordSyncMsgShown
        )
    {
        if (::AfxMessageBox(
            IDS_WRN_PWSYNC, 
            MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION
            ) != IDYES)
        {
            pDX->Fail();
        }

        //
        // Don't show it again
        //
        m_fPasswordSyncMsgShown = TRUE;
    }

    if (!m_fPasswordSync || !pDX->m_bSaveAndValidate)
    {
        DDX_Password(
            pDX, 
            IDC_EDIT_PASSWORD, 
            m_strPassword, 
            g_lpszDummyPassword
            );
    }

    if (!m_fPasswordSync)
    {
        DDV_MaxChars(pDX, m_strPassword, PWLEN);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CAnonymousDlg, CDialog)
    //{{AFX_MSG_MAP(CAnonymousDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_BASIC_DOMAIN, OnItemChanged)

END_MESSAGE_MAP()



void
CAnonymousDlg::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_Password.EnableWindow(!m_fPasswordSync);
    m_edit_Password.EnableWindow(!m_fPasswordSync);
    m_button_CheckPassword.EnableWindow(!m_fPasswordSync);
}


//
// Message Handlers
// 
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL 
CAnonymousDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    SetControlStates();
    
    return TRUE;  
}


void
CAnonymousDlg::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CAnonymousDlg::OnButtonBrowseUsers()
/*++

Routine Description:

    User browse dialog pressed, bring up
    the user browser

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_strServerName, this, str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
        if (!(m_fPasswordSync = IsLocalAccount(str)))
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }

        m_chk_PasswordSync.SetCheck(m_fPasswordSync);
        OnItemChanged();
    }
}


void 
CAnonymousDlg::OnButtonCheckPassword() 
/*++

Routine Description:

    Check password button has been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(VerifyUserPassword(m_strUserName, m_strPassword));
    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}



void
CAnonymousDlg::OnCheckEnablePwSynchronization()
/*++

Routine Description:

    Handler for 'enable password synchronization' checkbox press

Arguments:

    None

Return Value:

    None

--*/
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates();
    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}




void 
CAnonymousDlg::OnChangeEditUsername() 
/*++

Routine description:

    Handler for 'username' edit box change messages

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\basdom.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        basdom.cpp

   Abstract:

        Basic Domain Dialog 

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "basdom.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CBasDomainDlg::CBasDomainDlg(
    IN LPCTSTR lpstrDomainName,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    LPCTSTR lpstrDomainName : Initialial domain name
    CWnd * pParent          : Parent window or NULL

Return Value:

    N/A

--*/
    : CDialog(CBasDomainDlg::IDD, pParent),
      m_strBasDomain(lpstrDomainName)
{
#if 0 // Keep class wizard happy
    //{{AFX_DATA_INIT(CBasDomainDlg)
    m_strBasDomain = lpstrDomainName;
    //}}AFX_DATA_INIT
#endif // 0

}



void 
CBasDomainDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBasDomainDlg)
    DDX_Control(pDX, IDC_EDIT_DOMAIN_NAME, m_edit_BasicDomain);
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strBasDomain);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CBasDomainDlg, CDialog)
    //{{AFX_MSG_MAP(CBasDomainDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_DEFAULT, OnButtonDefault)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CBasDomainDlg::OnButtonBrowse() 
/*++

Routine Description:

    Browse for domains.  Bring up browse dialog, and write the
    selection to the edit box.

Arguments:

    None

Return Value:

    None

--*/
{
    CBrowseDomainDlg dlgBrowse(this, m_strBasDomain);
    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_BasicDomain.SetWindowText(
            dlgBrowse.GetSelectedDomain(m_strBasDomain)
            );
    }
}



void 
CBasDomainDlg::OnButtonDefault() 
/*++

Routine Description:

    Default button is pressed.  Revert to using the default
    button, i.e. clear the selected domain name.
    
Arguments:

    None

Return Value:

    None

--*/
{
    m_edit_BasicDomain.SetWindowText(_T(""));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\certauth.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certauth.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CCertAuth

IMPLEMENT_DYNCREATE(CCertAuth, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertAuth properties

COleFont CCertAuth::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CCertAuth::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

short CCertAuth::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CCertAuth::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

BOOL CCertAuth::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CCertAuth::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

CString CCertAuth::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CCertAuth::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CCertAuth operations

void CCertAuth::SetMachineName(LPCTSTR szMachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName);
}

void CCertAuth::SetServerInstance(LPCTSTR szServerInstance)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szServerInstance);
}

void CCertAuth::DoClick(long dwButtonNumber)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         dwButtonNumber);
}

void CCertAuth::AboutBox()
{
    InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\certmap.h ===
#ifndef __CERTMAP_H__
#define __CERTMAP_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCertmap wrapper class

class CCertmap : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertmap)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xbbd8f29b, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0x0, 0x2b, 0x2c, 0x6f, 0x32 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetServerInstance(LPCTSTR szServerInstance);
    void SetMachineName(LPCTSTR szMachineName);
};

#endif // __CERTMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\authent.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "certmap.h"
#include "basdom.h"
#include "anondlg.h"
#include "authent.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CAuthenticationDlg::CAuthenticationDlg(
    IN LPCTSTR lpstrServerName, 
    IN DWORD   dwInstance,      
    IN CString & strBasicDomain,
    IN DWORD & dwAuthFlags,
    IN DWORD & dwAccessPermissions,
    IN CString & strUserName,
    IN CString & strPassword,
    IN BOOL & fPasswordSync,
    IN BOOL fAdminAccess,
    IN BOOL fHasDigest,
    IN CWnd * pParent           OPTIONAL
    )
/*++

Routine Description:

    Authentication dialog constructor

Arguments:

    LPCTSTR lpstrServerName     : Server name
    DWORD   dwInstance          : Instance number
    CString & strBasicDomain    : Basic domain name
    DWORD & dwAuthFlags         : Authorization flags
    DWORD & dwAccessPermissions : Access permissions
    CString & strUserName       : Anonymous user name
    CString & strPassword       : Anonymous user pwd
    BOOL & fPasswordSync        : Password sync setting
    BOOL fAdminAccess           : TRUE if user has admin access
    BOOL fHasDigest             : TRUE if machine supports digest auth.
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CAuthenticationDlg::IDD, pParent),
      m_strServerName(lpstrServerName),
      m_strBasicDomain(strBasicDomain),
      m_strUserName(strUserName),
      m_strPassword(strPassword),
      m_dwInstance(dwInstance),
      m_dwAuthFlags(dwAuthFlags),
      m_dwAccessPermissions(dwAccessPermissions),
      m_fAdminAccess(fAdminAccess),
      m_fHasDigest(fHasDigest),
      m_fPasswordSync(fPasswordSync)
{
#if 0 // Class Wizard happy

    //{{AFX_DATA_INIT(CAuthenticationDlg)
    m_fClearText = FALSE;
    m_fDigest = FALSE;
    m_fChallengeResponse = FALSE;
    m_fUUEncoded = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

    m_fClearText = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_BASIC);
    m_fDigest = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_MD5);
    m_fChallengeResponse = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_NT);
    m_fUUEncoded = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_ANONYMOUS);
}


void 
CAuthenticationDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAuthenticationDlg)
    DDX_Check(pDX, IDC_CHECK_CLEAR_TEXT, m_fClearText);
    DDX_Check(pDX, IDC_CHECK_DIGEST, m_fDigest);
    DDX_Check(pDX, IDC_CHECK_NT_CHALLENGE_RESPONSE, m_fChallengeResponse);
    DDX_Check(pDX, IDC_CHECK_UUENCODED, m_fUUEncoded);
    DDX_Control(pDX, IDC_CHECK_UUENCODED, m_check_UUEncoded);
    DDX_Control(pDX, IDC_CHECK_NT_CHALLENGE_RESPONSE, m_check_ChallengeResponse);
    DDX_Control(pDX, IDC_CHECK_DIGEST, m_check_Digest);
    DDX_Control(pDX, IDC_CHECK_CLEAR_TEXT, m_check_ClearText);
    DDX_Control(pDX, IDC_BUTTON_EDIT_ANONYMOUS, m_button_EditAnonymous);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CAuthenticationDlg, CDialog)
    //{{AFX_MSG_MAP(CAuthenticationDlg)
    ON_BN_CLICKED(IDC_CHECK_CLEAR_TEXT, OnCheckClearText)
    ON_BN_CLICKED(IDC_CHECK_UUENCODED, OnCheckUuencoded)
    ON_BN_CLICKED(IDC_CHECK_DIGEST, OnCheckDigest)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_ANONYMOUS, OnButtonEditAnonymous)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CAuthenticationDlg::SetControlStates()
/*++

Routine Description:

    Set control states depending on current data in the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Edit.EnableWindow(m_fClearText);
    m_button_EditAnonymous.EnableWindow(m_fUUEncoded && m_fAdminAccess);
}



BOOL 
CAuthenticationDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();
    
    SetControlStates();  

    //
    // Ensure compatibility with downlevel
    //
    m_check_Digest.EnableWindow(m_fHasDigest);

    return TRUE;  
}



void 
CAuthenticationDlg::OnCheckClearText() 
/*++

Routine Description:

    Clear text checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_check_ClearText.GetCheck() == 1)
    {
        CClearTxtDlg dlg;
        if (dlg.DoModal() != IDOK)
        {
            m_check_ClearText.SetCheck(0);
            return;
        }
    }

    m_fClearText = !m_fClearText;
    SetControlStates();
}



void 
CAuthenticationDlg::OnCheckDigest() 
/*++

Routine Description:

    'Digest' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fHasDigest);

    if (m_check_Digest.GetCheck() == 1)
    {
        if (!NoYesMessageBox(IDS_WRN_DIGEST))
        {
            m_check_Digest.SetCheck(0);
            return;
        }
    }

    m_fDigest = !m_fDigest;
    SetControlStates();
}



void 
CAuthenticationDlg::OnCheckUuencoded() 
/*++

Routine Description:

    UU Encoding checkbox been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUUEncoded = !m_fUUEncoded;
    SetControlStates();
}



void 
CAuthenticationDlg::OnButtonEditAnonymous() 
/*++

Routine Description:

    'Edit anonymous' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CAnonymousDlg dlg(
        m_strServerName,
        m_strUserName,
        m_strPassword,
        m_fPasswordSync,
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.GetUserName();
        m_strPassword = dlg.GetPassword();
        m_fPasswordSync = dlg.GetPasswordSync();
    }
}



void 
CAuthenticationDlg::OnButtonEdit() 
/*++

Routine Description:

    'Edit default basic domain dialog' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBasDomainDlg dlg(m_strBasicDomain);
    if (dlg.DoModal() == IDOK)
    {
        m_strBasicDomain = dlg.GetBasicDomain();
    }
}



void 
CAuthenticationDlg::OnOK() 
/*++

Routine Description:

    OK button handler, save information

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fClearText, m_dwAuthFlags, MD_AUTH_BASIC);
        SET_FLAG_IF(m_fChallengeResponse, m_dwAuthFlags, MD_AUTH_NT);
        SET_FLAG_IF(m_fUUEncoded, m_dwAuthFlags, MD_AUTH_ANONYMOUS);
        SET_FLAG_IF(m_fDigest, m_dwAuthFlags, MD_AUTH_MD5);

        //
        // Provide warning if no authentication is selected
        //
        if (!m_dwAuthFlags 
         && !m_dwAccessPermissions 
         && !NoYesMessageBox(IDS_WRN_NO_AUTH)
           )
        {
            //
            // Don't dismiss the dialog
            //
            return;
        }

        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\authent.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class CAuthenticationDlg : public CDialog
/*++

Class Description:

    Authentication dialog

Public Interface:

    CAuthenticationDlg  : Constructor

--*/
{
//
// Construction
//
public:
    CAuthenticationDlg(
        IN LPCTSTR lpstrServerName, // For API name only
        IN DWORD   dwInstance,      // For use in ocx only
        IN CString & strBasicDomain,
        IN DWORD & dwAuthFlags,
        IN DWORD & dwAccessPermissions,
        IN CString & strUserName,
        IN CString & strPassword,
        IN BOOL & fPasswordSync,
        IN BOOL fAdminAccess,
        IN BOOL fHasDigest,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAuthenticationDlg)
    enum { IDD = IDD_AUTHENTICATION };
    BOOL    m_fClearText;
    BOOL    m_fDigest;
    BOOL    m_fChallengeResponse;
    BOOL    m_fUUEncoded;
    CButton m_check_UUEncoded;
    CButton m_check_ChallengeResponse;
    CButton m_check_ClearText;
    CButton m_check_Digest;
    CButton m_button_EditAnonymous;
    CButton m_button_Edit;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAuthenticationDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CAuthenticationDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnCheckClearText();
    afx_msg void OnCheckUuencoded();
    afx_msg void OnCheckDigest();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonEditAnonymous();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL & m_fPasswordSync;
    BOOL m_fAdminAccess;
    BOOL m_fHasDigest;
    DWORD & m_dwAuthFlags;
    DWORD & m_dwAccessPermissions;
    DWORD m_dwInstance;
    CString & m_strBasicDomain;
    CString & m_strUserName;
    CString & m_strPassword;
    CString m_strServerName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\basdom.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        basdom.h

   Abstract:

        Basic Domain Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class CBasDomainDlg : public CDialog
/*++

Class Description:

    Basic authentication domain dialog

Public Interface:

    CBasDomainDlg       : Constructor
    GetBasicDomain      : Get the domain entered

--*/
{
//
// Construction
//
public:
    CBasDomainDlg(
        IN LPCTSTR lpstrDomainName,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    CString & GetBasicDomain() { return m_strBasDomain; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBasDomainDlg)
    enum { IDD = IDD_BASIC_DOMAIN };
    CEdit   m_edit_BasicDomain;
    CString m_strBasDomain;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBasDomainDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CBasDomainDlg)
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonDefault();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\certwiz.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certwiz.h"

/////////////////////////////////////////////////////////////////////////////
// CCertWiz

IMPLEMENT_DYNCREATE(CCertWiz, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertWiz properties

/////////////////////////////////////////////////////////////////////////////
// CCertWiz operations

void CCertWiz::SetMachineName(LPCTSTR MachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         MachineName);
}

void CCertWiz::SetServerInstance(LPCTSTR InstanceName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         InstanceName);
}

void CCertWiz::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\certauth.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

#ifndef __CERTAUTH_H_
#define __CERTAUTH_H_

// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCertAuth wrapper class

class CCertAuth : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertAuth)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0x996ff6f, 0xb6a1, 0x11d0, { 0x92, 0x92, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    short GetBorderStyle();
    void SetBorderStyle(short);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetMachineName(LPCTSTR szMachineName);
    void SetServerInstance(LPCTSTR szServerInstance);
    void DoClick(long dwButtonNumber);
    void AboutBox();
};

#endif // __CERTAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\certmap.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certmap.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"

/////////////////////////////////////////////////////////////////////////////
// CCertmap

IMPLEMENT_DYNCREATE(CCertmap, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertmap properties

COleFont CCertmap::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CCertmap::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CCertmap::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CCertmap::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CCertmap::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CCertmap::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

CString CCertmap::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CCertmap::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CCertmap operations

void CCertmap::SetServerInstance(LPCTSTR szServerInstance)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szServerInstance);
}

void CCertmap::SetMachineName(LPCTSTR szMachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\certwiz.h ===
#if !defined(AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_)
#define AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CCertWiz wrapper class

class CCertWiz : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertWiz)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xd4be8632, 0xc85, 0x11d2, { 0x91, 0xb1, 0x0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
    void SetMachineName(LPCTSTR MachineName);
    void SetServerInstance(LPCTSTR InstanceName);
    void DoClick();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\defws.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        defws.cpp

   Abstract:

        Default Web Site Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "defws.h"
#include "dirbrows.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Directory Size Units
//
#define DS_UNITS MEGABYTE



//
// Default Web Site Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

IMPLEMENT_DYNCREATE(CDefWebSitePage, CInetPropertyPage)



CDefWebSitePage::CDefWebSitePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW Default Web Site page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CDefWebSitePage::IDD, pSheet),
      m_ppropCompression(NULL),
      m_fFilterPathFound(FALSE),
      m_fCompressionDirectoryChanged(FALSE)
{
#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CDefWebSitePage)
    m_fEnableDynamic = FALSE;
    m_fEnableStatic = FALSE;
    m_strDirectory = _T("");
    m_nUnlimited = -1;
    m_ilSize = 0L;
    //}}AFX_DATA_INIT

#endif // 0

}



CDefWebSitePage::~CDefWebSitePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CDefWebSitePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDefWebSitePage)
    DDX_Control(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_edit_Directory);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_STATIC_COMPRESS_MB, m_static_MB);
    DDX_Control(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, m_edit_DirectorySize);
    DDX_Check(pDX, IDC_CHECK_DYNAMIC_COMPRESSION, m_fEnableDynamic);
    DDX_Check(pDX, IDC_CHECK_STATIC_COMPRESSION, m_fEnableStatic);
    DDX_Radio(pDX, IDC_RADIO_COMPRESS_UNLIMITED, m_nUnlimited);
    //}}AFX_DATA_MAP

    if (HasCompression())
    {
        if (!pDX->m_bSaveAndValidate || m_fEnableStatic)
        {
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_strDirectory);
            DDV_MaxChars(pDX, m_strDirectory, _MAX_PATH);
        }

        if (pDX->m_bSaveAndValidate && m_fEnableStatic)
        {
            if (!IsFullyQualifiedPath(m_strDirectory))
            {
                ::AfxMessageBox(IDS_ERR_INVALID_PATH);
                pDX->Fail();
            }

            //
            // Perform some additional smart checking on the compression
            // directory if the current machine is local, and the 
            // directory has changed
            //
            if (IsLocal() && m_fCompressionDirectoryChanged)
            {
                //
                // Should exist on the local machine.
                //
                DWORD dwAttr = GetFileAttributes(m_strDirectory);
                if (dwAttr == 0xffffffff 
                    || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0
                    || IsNetworkPath(m_strDirectory)
                    )
                {
                    ::AfxMessageBox(IDS_ERR_COMPRESS_DIRECTORY);
                    pDX->Fail();
                }

                //
                // Now check to make sure the volume is of the correct
                // type.
                //
                DWORD dwFileSystemFlags;

                if (::GetVolumeInformationSystemFlags(
                    m_strDirectory,
                    &dwFileSystemFlags
                    ))
                {
                    if (!(dwFileSystemFlags & FS_PERSISTENT_ACLS))
                    {
                        //
                        // No ACLS
                        //
                        if (!NoYesMessageBox(IDS_NO_ACL_WARNING))
                        {
                            pDX->Fail();
                        }
                    }

                    if (dwFileSystemFlags & FS_VOL_IS_COMPRESSED
                        || dwAttr & FILE_ATTRIBUTE_COMPRESSED)
                    {
                        //
                        // Compression cache directory is itself compressed
                        //
                        if (!NoYesMessageBox(IDS_COMPRESS_WARNING))
                        {
                            pDX->Fail();
                        }
                    }
                }
            }
        }

        if (!pDX->m_bSaveAndValidate || (m_fEnableLimiting && m_fEnableStatic))
        {
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, m_ilSize);
            DDV_MinMaxLong(pDX, m_ilSize, 1, 1024L);
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDefWebSitePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CDefWebSitePage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_RADIO_COMPRESS_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_COMPRESS_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_CHECK_DYNAMIC_COMPRESSION, OnCheckDynamicCompression)
    ON_BN_CLICKED(IDC_CHECK_STATIC_COMPRESSION, OnCheckStaticCompression)
    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY, OnChangeEditCompressDirectory)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY_SIZE, OnItemChanged)

END_MESSAGE_MAP()



void 
CDefWebSitePage::SetControlStates()
/*++

Routine Description:

    Enable/disable control states depending on the state of
    the dialog.

Arguments:

    None

Return Value:

    None

--*/
{
    GetDlgItem(IDC_STATIC_COMPRESS_DIRECTORY)->EnableWindow(m_fEnableStatic);
    m_edit_Directory.EnableWindow(m_fEnableStatic);
    m_edit_DirectorySize.EnableWindow(m_fEnableStatic && m_fEnableLimiting);
    m_static_MB.EnableWindow(m_fEnableStatic&& m_fEnableLimiting);
    GetDlgItem(IDC_RADIO_COMPRESS_LIMITED)->EnableWindow(m_fEnableStatic);
    GetDlgItem(IDC_RADIO_COMPRESS_UNLIMITED)->EnableWindow(m_fEnableStatic);
    GetDlgItem(IDC_STATIC_MAX_COMPRESS_SIZE)->EnableWindow(m_fEnableStatic);

    //
    // Browse on the local machine only
    //
    m_button_Browse.EnableWindow(IsLocal() && m_fEnableStatic);
}



/* virtual */
HRESULT
CDefWebSitePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    ASSERT(m_ppropCompression == NULL);

    m_ppropCompression = new CIISCompressionProps(GetServerName());
    
    if (m_ppropCompression)
    {
        err = m_ppropCompression->LoadData();
        m_fFilterPathFound = err.Succeeded();
        
        if (err.Succeeded())
        {
            m_fEnableDynamic = m_ppropCompression->m_fEnableDynamicCompression;
            m_fEnableStatic = m_ppropCompression->m_fEnableStaticCompression;
            m_fEnableLimiting = m_ppropCompression->m_fLimitDirectorySize;
            m_strDirectory = m_ppropCompression->m_strDirectory;
            m_nUnlimited = m_fEnableLimiting ? RADIO_LIMITED : RADIO_UNLIMITED;

            if (m_ppropCompression->m_dwDirectorySize == 0xffffffff)
            {
                m_ilSize = DEF_MAX_COMPDIR_SIZE / DS_UNITS;
            }
            else
            {
                m_ilSize = m_ppropCompression->m_dwDirectorySize / DS_UNITS;
            }
        }
        else if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Fail quietly
            //
            TRACEEOLID("No compression filters installed");
            err.Reset();    
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



HRESULT
CDefWebSitePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 default web site page now...");

    CError err;

    BeginWaitCursor();

    //
    // Write Compression parms as well.
    //
    if (err.Succeeded() && HasCompression())
    {
        ASSERT(m_ppropCompression);
        DWORD dwSize = m_ilSize * DS_UNITS;

        m_ppropCompression->m_fEnableDynamicCompression = m_fEnableDynamic;
        m_ppropCompression->m_fEnableStaticCompression  = m_fEnableStatic;
        m_ppropCompression->m_fLimitDirectorySize       = m_fEnableLimiting;
        m_ppropCompression->m_strDirectory              = m_strDirectory;
        m_ppropCompression->m_dwDirectorySize           = dwSize;
        err = m_ppropCompression->WriteDirtyProps();
    }
    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fCompressionDirectoryChanged = FALSE;
    }

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            



BOOL
CDefWebSitePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Check to make sure compression is supported
    //
    for (UINT n = IDC_COMPRESS_FLAGS_FIRST; n <= IDC_COMPRESS_FLAGS_LAST; ++n)
    {
        GetDlgItem(n)->EnableWindow(HasCompression());
    }

    SetControlStates();

    return TRUE;
}



void 
CDefWebSitePage::OnItemChanged()
/*++

Routine Description:
    
    Handle change in control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
    SetControlStates();
}



void 
CDefWebSitePage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(IsLocal());
    CString str;
    m_edit_Directory.GetWindowText(str);

    CDirBrowseDlg dlgBrowse(this, str);
    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_Directory.SetWindowText(dlgBrowse.GetFullPath(str));
        OnItemChanged();
    }
}



void 
CDefWebSitePage::OnChangeEditCompressDirectory() 
/*++

Routine Description:

    Handle change in compression directory edit box.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fCompressionDirectoryChanged = TRUE;
    OnItemChanged();
}



void 
CDefWebSitePage::OnRadioLimited() 
/*++

Routine Description:

    'Limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fEnableLimiting)
    {
        m_nUnlimited = RADIO_LIMITED;
        m_fEnableLimiting = TRUE;
        OnItemChanged();

        m_edit_DirectorySize.SetSel(0, -1);
        m_edit_DirectorySize.SetFocus();
    }
}



void 
CDefWebSitePage::OnRadioUnlimited() 
/*++

Routine Description:

    'Unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fEnableLimiting)
    {
        m_nUnlimited = RADIO_UNLIMITED;
        m_fEnableLimiting = FALSE;
        OnItemChanged();
    }
}



void 
CDefWebSitePage::OnCheckDynamicCompression() 
/*++

Routine Description:

    "Enable Dynamic Compression' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableDynamic = !m_fEnableDynamic;
    OnItemChanged();
}



void 
CDefWebSitePage::OnCheckStaticCompression() 
/*++

Routine Description:

    "Enable Dynamic Compression' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableStatic = !m_fEnableStatic;
    OnItemChanged();
    if (m_fEnableStatic)
    {
        m_edit_Directory.SetSel(0, -1);
        m_edit_Directory.SetFocus();
    }
}



void 
CDefWebSitePage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    SAFE_DELETE(m_ppropCompression);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\docum.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        docum.h

   Abstract:

        WWW Documents Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __DOCUM_H__
#define __DOCUM_H__

class CAddDefDocDlg : public CDialog
/*++

Class Description:

    Add default document dialog

Public Interface:
    
    CAddDefDocDlg       : Constructor

    GetDefDocument      : Get the default document entered

--*/
{
//
// Construction
//
public:
    CAddDefDocDlg(IN CWnd * pParent = NULL);

//
// Access:
//
public:                                                   
    CString & GetDefDocument() { return m_strDefDocument; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAddDefDocDlg)
    enum { IDD = IDD_DEFAULT_DOCUMENT };
    CString m_strDefDocument;
    CButton m_button_Ok;
    CEdit   m_edit_DefDocument;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddDefDocDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddDefDocDlg)
    afx_msg void OnChangeEditDefDocument();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


class CW3DocumentsPage : public CInetPropertyPage
/*++

Class Description:

    Documents property page

Public Interface:

    CW3DocumentsPage      : Constructor
    ~CW3DocumentsPage     : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3DocumentsPage)

//
// Construction
//
public:
    CW3DocumentsPage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3DocumentsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3DocumentsPage)
    enum { IDD = IDD_DIRECTORY_DOCUMENTS };
    BOOL     m_fEnableDefaultDocument;
    BOOL     m_fEnableFooter;
    CString  m_strFooter;
    CEdit    m_edit_Footer;
    CButton  m_check_EnableDefaultDocument;
    CButton  m_check_EnableFooter;
    CButton  m_button_Add;
    CButton  m_button_Remove;
    CButton  m_button_Browse;
    CListBox m_list_DefDocuments;
    //}}AFX_DATA

    DWORD       m_dwDirBrowsing;
    DWORD       m_dwBitRangeDirBrowsing;
    CString     m_strDefaultDocument;

    CUpButton   m_button_Up;
    CDownButton m_button_Down;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3DocumentsPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3DocumentsPage)
    afx_msg void OnCheckEnableDefaultDocument();
    afx_msg void OnCheckEnableDocumentFooter();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonUp();
    afx_msg void OnButtonDown();
    afx_msg void OnSelchangeListDefaultDocument();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    BOOL SetDefDocumentState(BOOL fEnabled);
    BOOL SetDocFooterState(BOOL fEnabled);
    BOOL SetRemoveState();
    BOOL StringFromListBox();
    BOOL DocExistsInList(LPCTSTR lpDoc);
    void SetUpDownStates();
    void ExchangeDocuments(int nLow, int nHigh);
    void MakeFooterCommand(CString & strFooter);
    void ParseFooterCommand(CString & strFooter);
    void StringToListBox();

protected:
    static const LPCTSTR s_lpstrSep;
    static const LPCTSTR s_lpstrFILE;
    static const LPCTSTR s_lpstrSTRING;
    static const LPCTSTR s_lpstrURL;
};


#endif // __DOCUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\docum.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        docum.cpp

   Abstract:

        WWW Documents Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "docum.h"

#include <lmcons.h>



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CAddDefDocDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CAddDefDocDlg::CAddDefDocDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Add default document dialog constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CDialog(CAddDefDocDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddDefDocDlg)
    m_strDefDocument = _T("");
    //}}AFX_DATA_INIT
}



void 
CAddDefDocDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddDefDocDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_DEF_DOCUMENT, m_edit_DefDocument);
    DDX_Text(pDX, IDC_EDIT_DEF_DOCUMENT, m_strDefDocument);
    DDV_MaxChars(pDX, m_strDefDocument, MAX_PATH);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (m_strDefDocument.Find(_T(':')) != -1
         || m_strDefDocument.Find(_T('\\')) != -1)
        {
            ::AfxMessageBox(IDS_ERR_NO_COMPLETE_PATH);
            pDX->Fail();
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CAddDefDocDlg, CDialog)
    //{{AFX_MSG_MAP(CAddDefDocDlg)
    ON_EN_CHANGE(IDC_EDIT_DEF_DOCUMENT, OnChangeEditDefDocument)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CAddDefDocDlg::OnChangeEditDefDocument() 
/*++

Routine Description:

    Respond to a change in the default document edit box

Arguments:

    None./

--*/
{
    m_button_Ok.EnableWindow(m_edit_DefDocument.GetWindowTextLength() > 0);
}



//
// WWW Documents Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3DocumentsPage, CInetPropertyPage)



//
// Static Initialization
//
const LPCTSTR CW3DocumentsPage::s_lpstrSep = _T(",");
const LPCTSTR CW3DocumentsPage::s_lpstrFILE = _T("FILE:");
const LPCTSTR CW3DocumentsPage::s_lpstrSTRING = _T("STRING:");
const LPCTSTR CW3DocumentsPage::s_lpstrURL = _T("URL:");



CW3DocumentsPage::CW3DocumentsPage(
    IN CInetPropertySheet * pSheet
    ) 
/*++

Routine Description:

    Documents page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet object
    BOOL fLocal                 : TRUE if admining the local server

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3DocumentsPage::IDD, pSheet),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_LOADDEFAULT)
{

#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CW3DocumentsPage)
    m_strFooter = _T("");
    m_fEnableDefaultDocument = FALSE;
    m_fEnableFooter = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

}



CW3DocumentsPage::~CW3DocumentsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3DocumentsPage::MakeFooterCommand(
    IN OUT CString & strFooter
    )
/*++

Routine Description:

    Convert the footer document to a full footer string.

Arguments:

    CString & strFooter : On input this is the footer document,
                          at output this will be a full footer command

Return Value:

    None.

Notes:

    Only support FILE: for now

--*/
{
    strFooter.TrimLeft();
    strFooter.TrimRight();

    ASSERT(::IsFullyQualifiedPath(strFooter));
    strFooter = s_lpstrFILE + strFooter;
}



void
CW3DocumentsPage::ParseFooterCommand(
    IN OUT CString & strFooter
    )
/*++

Routine Description:

    Trim the command from the rest of this command 

Arguments:

    CString & strFooter : On input this is a footer command
                          at output this will be just the footer document

Return Value:

    None.

--*/
{
    LPCTSTR lp = strFooter.GetBuffer(0);
    if (!_tcsnccmp(lp, s_lpstrFILE, 5))
    {
        lp += lstrlen(s_lpstrFILE);
    }
    else if (!_tcsnccmp(lp, s_lpstrSTRING, 7))
    {
        lp += lstrlen(s_lpstrSTRING);
    }
    else if (!::_tcsnccmp(lp, s_lpstrURL, 4))
    {
        lp += lstrlen(s_lpstrURL);
    }
    if (lp != strFooter.GetBuffer(0))
    {
        strFooter = lp;
    }
    strFooter.TrimLeft();
}



void
CW3DocumentsPage::StringToListBox()
/*++

Routine Description:

    Parse the default document string, and add each doc
    to the listbox

Arguments:

    None

Return Value:

    None

--*/
{
    CString strSrc(m_strDefaultDocument);
    LPTSTR lp = strSrc.GetBuffer(0);
    lp = StringTok(lp, s_lpstrSep);

    while (lp)
    {
        CString str(lp);
        str.TrimLeft();
        str.TrimRight();

        m_list_DefDocuments.AddString(str);
        lp = StringTok(NULL, s_lpstrSep);
    }
}



BOOL
CW3DocumentsPage::StringFromListBox()
/*++

Routine Description:

    Build up list of default documents from the contents of 
    the listbox.

Arguments:

    None

Return Value:

    TRUE if at least one document was added.

--*/
{
    m_strDefaultDocument.Empty();

    int i;
    for (i = 0; i < m_list_DefDocuments.GetCount(); ++i)
    {
        CString str;
        m_list_DefDocuments.GetText(i, str);
        if (i)
        {
            m_strDefaultDocument += s_lpstrSep;
        }

        m_strDefaultDocument += str;
    }

    return i > 0;
}



void 
CW3DocumentsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3DocumentsPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_DEFAULT_DOCUMENT, m_fEnableDefaultDocument);
    DDX_Check(pDX, IDC_CHECK_ENABLE_DOCUMENT_FOOTER, m_fEnableFooter);
    DDX_Control(pDX, IDC_LIST_DEFAULT_DOCUMENT, m_list_DefDocuments);
    DDX_Control(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_edit_Footer);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DOCUMENT_FOOTER, m_check_EnableFooter);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_BUTTON_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTTON_DOWN, m_button_Down);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (m_fEnableDefaultDocument)
        {
            if (!StringFromListBox())
            {
                ::AfxMessageBox(IDS_ERR_DOCUMENTS);
                pDX->Fail();
            }
        }

        if (m_fEnableFooter)
        {
            BeginWaitCursor();
            DDX_Text(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_strFooter);
            DDV_MinMaxChars(pDX, m_strFooter, 1, MAX_PATH);
            if (!IsFullyQualifiedPath(m_strFooter))
            {
                //
                // Footer doc must be a complete path
                //
                ::AfxMessageBox(IDS_ERR_COMPLETE_PATH);
                pDX->Fail();
            }
            else if (IsLocal() && IsNetworkPath(m_strFooter))
            {
                //
                // Footer doc must be on local machine.
                //
                ::AfxMessageBox(IDS_NOT_LOCAL_FOOTER);
                pDX->Fail();
            }
            else if (IsLocal() && 
                (::GetFileAttributes(m_strFooter) & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // And lastly, but not leastly, the footer document should exist
                //
                ::AfxMessageBox(IDS_ERR_FILE_NOT_FOUND);
                pDX->Fail();
            }
            else
            {
                MakeFooterCommand(m_strFooter);
            }
            EndWaitCursor();
        }
        else
        {
            m_strFooter.Empty();
        }
    }
    else
    {
        ParseFooterCommand(m_strFooter);
        DDX_Text(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_strFooter);
        DDV_MinMaxChars(pDX, m_strFooter, 1, MAX_PATH);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DocumentsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DocumentsPage)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DEFAULT_DOCUMENT, OnCheckEnableDefaultDocument)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DOCUMENT_FOOTER, OnCheckEnableDocumentFooter)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
    ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
    ON_LBN_SELCHANGE(IDC_LIST_DEFAULT_DOCUMENT, OnSelchangeListDefaultDocument)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_DEFAULT_DOCUMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOCUMENT_FOOTER, OnItemChanged)

END_MESSAGE_MAP()



void 
CW3DocumentsPage::SetUpDownStates()
/*++

Routine Description:

    Set up and down button enable status

Arguments:

    None

Return Value:

    None

--*/
{
    int nLast = m_list_DefDocuments.GetCount() - 1;
    int nSel = m_list_DefDocuments.GetCurSel();

    m_button_Up.EnableWindow(nSel > 0);
    m_button_Down.EnableWindow(nSel >= 0 && nSel < nLast);
}



BOOL
CW3DocumentsPage::SetRemoveState()
/*++

Routine Description:

    Set the enabled state of the remove button state depending
    on the state of the selection in the def doc listbox

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled, FALSE otherwise

--*/
{
    BOOL fEnabled = m_fEnableDefaultDocument
        && (m_list_DefDocuments.GetCurSel() != LB_ERR);

    m_button_Remove.EnableWindow(fEnabled);

    return fEnabled;
}



BOOL 
CW3DocumentsPage::SetDefDocumentState(
    IN BOOL fEnabled
    )
/*++

Routine Description:

    Set the enabled states of the Default Documents state

Arguments:

    BOOL fEnabled       : TRUE if default document is on

Return Value:

    TRUE if default document is on

--*/
{
    m_button_Add.EnableWindow(fEnabled);
    m_button_Up.EnableWindow(fEnabled);
    m_button_Down.EnableWindow(fEnabled);
    m_list_DefDocuments.EnableWindow(fEnabled);
    SetRemoveState();

    return fEnabled;
}



BOOL 
CW3DocumentsPage::SetDocFooterState(
    IN BOOL fEnabled
    )
/*++

Routine Description:

    Set the enabled state of the footer documents

Arguments:

    BOOL fEnabled       : TRUE if footers are on

Return Value:

    TRUE if footers are on

--*/
{
    m_edit_Footer.EnableWindow(fEnabled);
    m_button_Browse.EnableWindow(IsLocal() && fEnabled);

    return fEnabled;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DocumentsPage::OnItemChanged()
/*++

Routine Description:

    Handle change in the value of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}



void 
CW3DocumentsPage::OnCheckEnableDefaultDocument()
/*++

Routine Description:

    Handle 'enable default document' checkbox toggle

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableDefaultDocument = !m_fEnableDefaultDocument;
    SetDefDocumentState(m_fEnableDefaultDocument);
    OnItemChanged();
}



void 
CW3DocumentsPage::OnCheckEnableDocumentFooter()
/*++

Routine Description:

    Handle 'enable document footer' checkbox toggle

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableFooter = !m_fEnableFooter;
    if (SetDocFooterState(m_fEnableFooter))
    {
        m_edit_Footer.SetSel(0,-1);
        m_edit_Footer.SetFocus();        
    }

    OnItemChanged();
}



BOOL 
CW3DocumentsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Make sure the up/down buttons show up correctly
    //
    m_button_Up.SizeToContent();
    m_button_Down.SizeToContent();

    StringToListBox();

    SetDefDocumentState(m_fEnableDefaultDocument);
    SetDocFooterState(m_fEnableFooter);
    SetUpDownStates();
    SetRemoveState();

    return TRUE;  
}



/* virtual */
HRESULT
CW3DocumentsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_strDefaultDocument);
        FETCH_DIR_DATA_FROM_SHEET(m_fEnableFooter);
        FETCH_DIR_DATA_FROM_SHEET(m_strFooter);
        m_fEnableDefaultDocument = IS_FLAG_SET(
            m_dwDirBrowsing, 
            MD_DIRBROW_LOADDEFAULT
            );
    END_META_DIR_READ(err)

    return err;
}



HRESULT
CW3DocumentsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 documents page now...");

    CError err;

    SET_FLAG_IF(m_fEnableDefaultDocument, m_dwDirBrowsing, MD_DIRBROW_LOADDEFAULT);

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_strDefaultDocument)
        //STORE_DIR_DATA_ON_SHEET_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_fEnableFooter)
        STORE_DIR_DATA_ON_SHEET(m_strFooter)
    END_META_DIR_WRITE(err)

    EndWaitCursor();

    return err;
}



int
CW3DocumentsPage::DocExistsInList(
    IN LPCTSTR lpDoc
    )
/*++

Routine Description:

    Check to see if the given document exists in the list

Arguments:

    LPCTSTR lpDoc   : Document to check

Return Value:

    The index where the item exists or LB_ERR if it doesn't exist.

--*/
{
    CString str;
    for (int n = 0; n < m_list_DefDocuments.GetCount(); ++n)
    {
        m_list_DefDocuments.GetText(n, str);
        if (!str.CompareNoCase(lpDoc))
        {
            return n;
        }
    }

    return LB_ERR;
}


void 
CW3DocumentsPage::OnButtonAdd() 
/*++

Routine Description:

    Add new default document to the list

Arguments:

    None

Return Value:

    None

--*/
{
    CAddDefDocDlg dlg;
    if (dlg.DoModal() == IDOK)
    {
        //
        // Check to see if it existed already
        //
        try
        {
            int nSel;
            CString strNewDoc(dlg.GetDefDocument());
            
            if ((nSel = DocExistsInList(strNewDoc)) != LB_ERR)
            {
                m_list_DefDocuments.SetCurSel(nSel);
                ::AfxMessageBox(IDS_DUPLICATE_DOC);
                return;
            }

            nSel = m_list_DefDocuments.AddString(strNewDoc);
            if (nSel >= 0)
            {
                m_list_DefDocuments.SetCurSel(nSel);
                SetUpDownStates();
                SetRemoveState();
                OnItemChanged();
            }
        }
        catch(CMemoryException * e)
        {
            e->ReportError();
            e->Delete();
        }
    }
}



void 
CW3DocumentsPage::OnButtonRemove() 
/*++

Routine Description:

    Remove currently selected def document in the list

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = m_list_DefDocuments.GetCurSel();
    if (nSel >= 0)
    {
        m_list_DefDocuments.DeleteString(nSel);
        if (nSel >= m_list_DefDocuments.GetCount())
        {
           --nSel;
        }
        m_list_DefDocuments.SetCurSel(nSel);
        SetUpDownStates();
        OnItemChanged();

        if (!SetRemoveState())
        {
            //
            // Make sure we don't focus on a disabled button
            //
            m_button_Add.SetFocus();
        }
    }
}



void 
CW3DocumentsPage::OnButtonBrowse() 
/*++

Routine Description:

    Browse for an html footer document

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(IsLocal());

    //
    // Pop up the file dialog and let the user select the footer htm file.
    //
    CString str;
    str.LoadString(IDS_HTML_MASK);
    CFileDialog dlgBrowse(TRUE, NULL, NULL, OFN_HIDEREADONLY, str, this);

    //
    // If the new style of file-open dialog is requested, comment
    // out the DoModal, and remove the other two comments.
    //
    //dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);

    if (dlgBrowse.DoModal() == IDOK)
    //if (GetOpenFileName(&dlgBrowse.m_ofn))
    {
        m_edit_Footer.SetWindowText(dlgBrowse.GetPathName());
    }
}



void
CW3DocumentsPage::ExchangeDocuments(
    IN int nLow,
    IN int nHigh
    )
/*++

Routine Description:

    Exchange two documents in the listbox

Arguments:

    int nLow   : Low item
    int nHigh  : High item

Return Value:

    None.

--*/
{
    ASSERT(nLow < nHigh);
    CString str;
    m_list_DefDocuments.GetText(nLow, str);
    m_list_DefDocuments.DeleteString(nLow);
    m_list_DefDocuments.InsertString(nHigh, str);
    OnItemChanged();
}



void 
CW3DocumentsPage::OnButtonUp() 
/*++

Routine Description:

    Move the currently selected doc up

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_DefDocuments.GetCurSel();
    ExchangeDocuments(nCurSel - 1, nCurSel);
    m_list_DefDocuments.SetCurSel(nCurSel - 1);
    m_list_DefDocuments.SetFocus();
    SetUpDownStates();
}



void 
CW3DocumentsPage::OnButtonDown() 
/*++

Routine Description:

    Move the currently selected doc down

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_DefDocuments.GetCurSel();
    ExchangeDocuments(nCurSel, nCurSel + 1);
    m_list_DefDocuments.SetCurSel(nCurSel + 1);
    m_list_DefDocuments.SetFocus();
    SetUpDownStates();
}



void 
CW3DocumentsPage::OnSelchangeListDefaultDocument() 
/*++

Routine Description:

    Respond to change in listbox selection    

Arguments:

    None.

Return Value:

    None.

--*/
{
    SetUpDownStates();
    SetRemoveState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\errordlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errordlg.h

   Abstract:

        Error dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __ERRORDLG_H__
#define __ERRORDLG_H__



class CCustomError : public CObjectPlus
/*++

Class Description:

    Error definitions

Public Interface:

    CCustomError        : Constructors

    IsURL               : TRUE if the custom error is an URL
    IsFILE              : TRUE if the custom error is a file
    IsDefault           : TRUE if the custom error is a default error
    URLSupported        : TRUE if URLS are supported for this error type
    SetValue            : Set the value on the custom error
    MakeDefault         : Make the error a default error

--*/
{
//
// Error types
//
public:
    enum ERT
    {
        ERT_DEFAULT,
        ERT_FILE,
        ERT_URL,
    };

//
// Constructor
//
public:
    //
    // Construct error definition from metabase error
    // error description string.
    //
    CCustomError(LPCTSTR lpstrErrorString);

//
// Access
//
public:
    BOOL IsURL() const;
    BOOL IsFile() const;
    BOOL IsDefault() const;
    BOOL URLSupported() const { return m_fURLSupported; }
    void MakeDefault();
    void SetValue(
        IN ERT nType,
        IN LPCTSTR lpText
        );

//
// Helper Functions
//
public:
    //
    // Build error string
    //
    void BuildErrorString(
        OUT CString & str
        );

    //
    // Parse the error string into component parts
    //  
    static BOOL CrackErrorString(
        IN  LPCTSTR lpstrErrorString, 
        OUT UINT & nError, 
        OUT UINT & nSubError,
        OUT ERT & nType, 
        OUT CString & str
        ); 

protected:
    //
    // Parse error description string into component parts
    //
    static void CrackErrorDescription(
        IN  LPCTSTR lpstrErrorString, 
        OUT UINT & nError, 
        OUT UINT & nSubError,
        OUT BOOL & fURLSupported,
        OUT CString & str
        ); 

//
// Metabase values
//
protected:
    static LPCTSTR s_szSep;
    static LPCTSTR s_szFile;
    static LPCTSTR s_szURL;
    static LPCTSTR s_szNoSubError;

public:
    ERT m_nType;
    UINT m_nError;
    UINT m_nSubError;
    BOOL m_fURLSupported;
    CString m_str;
    CString m_strDefault;
};



class CCustomErrorDlg : public CDialog
/*++

Class Description:

    HTTP Error dialog

Public Interface:

    CCustomErrorDlg       : Constructor

--*/
{
//
// Construction
//
public:
    CCustomErrorDlg(
        IN CCustomError * pErr,
        IN BOOL fLocal,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CCustomErrorDlg)
    enum { IDD = IDD_ERROR_MAPPING };
    int     m_nMessageType;
    CString m_strTextFile;
    CEdit   m_edit_TextFile;
    CStatic m_static_SubErrorPrompt;
    CStatic m_static_SubError;
    CStatic m_static_TextFilePrompt;
    CButton m_button_Browse;
    CButton m_button_OK;
    CComboBox m_combo_MessageType;
    CString m_strDefText;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCustomErrorDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CCustomErrorDlg)
    afx_msg void OnSelchangeComboMessageType();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnChangeEditTextFile();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();

private:
    BOOL m_fLocal;
    CString m_strFile;
    CString m_strURL;
    CCustomError * m_pErr;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CCustomError::IsURL() const
{
    return m_nType == ERT_URL;
}

inline BOOL CCustomError::IsFile() const
{
    return m_nType == ERT_FILE;
}

inline BOOL CCustomError::IsDefault() const
{
    return m_nType == ERT_DEFAULT;
}

inline void CCustomError::SetValue(
    IN ERT nType,
    IN LPCTSTR lpText
    )
{
    m_str = lpText;
    m_nType = nType;
}

inline void CCustomError::MakeDefault()
{
    m_nType = ERT_DEFAULT;
}

#endif // __ERRORDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\errors.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errors.cpp

   Abstract:

        HTTP errors property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "errors.h"
#include "errordlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CCustomErrorsListBox : a listbox of CCustomError objects
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Column width relative weights
//
#define WT_HTTP_ERROR     3
#define WT_OUTPUT_TYPE    2
#define WT_CONTENTS       8

//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Errors");

//
// Key under w3svc where the error descriptions live
//
const TCHAR g_cszErrorLocation[] = _T("Info");



IMPLEMENT_DYNAMIC(CCustomErrorsListBox, CHeaderListBox);



const int CCustomErrorsListBox::nBitmaps = 3;



CCustomErrorsListBox::CCustomErrorsListBox(
    IN UINT nIDDefault,
    IN UINT nIDFile,
    IN UINT nIDURL
    )
/*++

Routine Description:

    Error listbox constructor

Arguments:

    UINT nIDDefault : String ID for 'default'
    UINT nIDFile    : String ID for 'file'
    UINT nIDURL     : String ID for 'URL'

--*/
     : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    VERIFY(m_str[CCustomError::ERT_DEFAULT].LoadString(nIDDefault));
    VERIFY(m_str[CCustomError::ERT_FILE].LoadString(nIDFile));
    VERIFY(m_str[CCustomError::ERT_URL].LoadString(nIDURL));
}


void
CCustomErrorsListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CCustomError * p = (CCustomError *)ds.m_ItemData;
    ASSERT(p != NULL);

    DrawBitmap(ds, 0, p->m_nType);

    CString strError, strText;

    if (p->m_nSubError > 0)
    {
        strError.Format(_T("%d;%d"), p->m_nError, p->m_nSubError);
    }
    else
    {
        strError.Format(_T("%d"), p->m_nError);
    }

    ColumnText(ds, 0, TRUE, strError);
    ColumnText(ds, 1, FALSE, m_str[p->m_nType] );

    if (p->IsDefault())
    {
        strText.Format(_T("\"%s\""), p->m_strDefault);
    }
    else
    {
        strText = p->m_str;
    }

    ColumnText(ds, 2, FALSE, strText);
}



/* virtual */
BOOL
CCustomErrorsListBox::Initialize()
/*++

Routine Description:

    initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE if initialized successfully, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    InsertColumn(0, WT_HTTP_ERROR, IDS_HTTP_ERROR);
    InsertColumn(1, WT_OUTPUT_TYPE, IDS_OUTPUT_TYPE);
    InsertColumn(2, WT_CONTENTS, IDS_CONTENTS);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
    if (!SetWidthsFromReg())
    {
        DistributeColumns();
    }

    SetRedraw(TRUE);

    return TRUE;
}



CHTTPErrorDescriptions::CHTTPErrorDescriptions(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Constructor for default errors object.  This fetches the default
    error definitions

Arguments:

    LPCTSTR lpServerName : Server name

Return Value:

    None

--*/
    : CMetaProperties(
        lpszServer, 
        g_cszSvc, 
        MASTER_INSTANCE, 
        g_cszErrorLocation
        )
{       
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = MULTISZ_METADATA;
}



/* virtual */
void
CHTTPErrorDescriptions::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_CUSTOM_ERROR_DESC, m_strlErrorDescriptions)
    END_PARSE_META_RECORDS
}



//
// Errors property page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3ErrorsPage, CInetPropertyPage)



CW3ErrorsPage::CW3ErrorsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW error property page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CW3ErrorsPage::IDD, pSheet),
      m_list_Errors(IDS_DEFAULT_ERROR, IDS_FILE, IDS_URL),
      m_ListBoxRes(IDB_ERRORS, m_list_Errors.nBitmaps),
      m_strlCustomErrors(),
      m_strlErrorDescriptions(),
      m_oblErrors()
{
    //{{AFX_DATA_INIT(CW3ErrorsPage)
    //}}AFX_DATA_INIT

    m_list_Errors.AttachResources(&m_ListBoxRes);
}



CW3ErrorsPage::~CW3ErrorsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}

void
CW3ErrorsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3ErrorsPage)
    DDX_Control(pDX, IDC_BUTTON_SET_TO_DEFAULT, m_button_SetDefault);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_ERRORS, m_list_Errors);

    if (pDX->m_bSaveAndValidate)
    {
        CError err(StoreErrors());
        if (err.MessageBoxOnFailure())
        {
            pDX->Fail();
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3ErrorsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3ErrorsPage)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_SET_TO_DEFAULT, OnButtonSetToDefault)
    ON_LBN_DBLCLK(IDC_LIST_ERRORS, OnDblclkListErrors)
    ON_LBN_SELCHANGE(IDC_LIST_ERRORS, OnSelchangeListErrors)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CW3ErrorsPage::FillListBox()
/*++

Routine Description:

    Populate the listbox with the directory entries

Arguments:

    None

Return Value:

    None

--*/
{
    CObListIter obli(m_oblErrors);
    CCustomError * pError;

    //
    // Remember the selection.
    //
    int nCurSel = m_list_Errors.GetCurSel();

    m_list_Errors.SetRedraw(FALSE);
    m_list_Errors.ResetContent();
    int cItems = 0;

    for (/**/; pError = (CCustomError *)obli.Next(); ++cItems)
    {
        m_list_Errors.AddItem(pError);
    }

    m_list_Errors.SetRedraw(TRUE);
    m_list_Errors.SetCurSel(nCurSel);
}



HRESULT
CW3ErrorsPage::StoreErrors()
/*++

Routine Description:

    Build errors stringlist from the error oblist built up.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    try
    {
        m_strlCustomErrors.RemoveAll();
        POSITION pos = m_oblErrors.GetHeadPosition();

        while(pos)
        {
            CCustomError * pErr = (CCustomError *)m_oblErrors.GetNext(pos);
            if (!pErr->IsDefault())
            {
                CString str;
                pErr->BuildErrorString(str);
                m_strlCustomErrors.AddTail(str);
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}



CCustomError *
CW3ErrorsPage::FindError(
    IN UINT nError,
    IN UINT nSubError
    )
/*++

Routine Description:

    Find error in the list with the given error code and suberror code

Arguments:

    UINT nError     : Error code
    UINT nSubError  : Sub error code

Return Value:

    Pointer to the error or NULL if not found.

--*/
{
    CCustomError * pErr = NULL;

    POSITION pos = m_oblErrors.GetHeadPosition();
    while(pos)
    {
        pErr = (CCustomError *)m_oblErrors.GetNext(pos);
        ASSERT(pErr != NULL);
        if (pErr->m_nError == nError && pErr->m_nSubError == nSubError)
        {
            //
            // Found it!
            //
            return pErr;
        }
    }

    //
    // Not found!
    //
    return NULL;
}



HRESULT
CW3ErrorsPage::FetchErrors()
/*++

Routine Description:

    Build up the errors list

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    CWaitCursor wait;

    do
    {
        try
        {
            //
            // First get the default descriptions
            //
            CHTTPErrorDescriptions ed(QueryServerName());
            err = ed.LoadData();
            if (err.Failed())
            {
                break;
            }

            if (!ed.GetErrorDescriptions().IsEmpty())
            {
                POSITION pos = ed.GetErrorDescriptions().GetHeadPosition();

                while(pos)
                {
                    CString & str = ed.GetErrorDescriptions().GetNext(pos);
                    m_oblErrors.AddTail(new CCustomError(str));
                }
            }
            else
            {
                ::AfxMessageBox(IDS_NO_DEF_ERRORS);
                break;
            }

            //
            // Now match up the overrides if any
            //
            POSITION pos = m_strlCustomErrors.GetHeadPosition();
            while(pos)
            {
                CString & strError = m_strlCustomErrors.GetNext(pos);

                TRACEEOLID(strError);

                UINT nError;
                UINT nSubError;
                CCustomError::ERT nType;
                CString str;
                CCustomError * pErr = NULL;

                if (CCustomError::CrackErrorString(
                    strError, 
                    nError, 
                    nSubError, 
                    nType, 
                    str
                    ))
                {
                    pErr = FindError(nError, nSubError);
                }

                if (pErr != NULL)
                {
                    pErr->SetValue(nType, str);
                }
                else
                {
                    CString strFmt, str;
                    strFmt.LoadString(IDS_BAD_ERROR);

                    str.Format(strFmt, nError, nSubError);
                    ::AfxMessageBox(str);
                    break;
                }
            }

            FillListBox();
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }
    while(FALSE);

    return err;
}



void
CW3ErrorsPage::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on the state of
    the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    CCustomError * pErr = GetSelectedListItem();

    m_button_Edit.EnableWindow(pErr != NULL);
    m_button_SetDefault.EnableWindow(m_list_Errors.GetSelCount() > 0);
}


INT_PTR
CW3ErrorsPage::ShowPropertyDialog()
/*++

Routine Description:

    Display the add/edit dialog.  The return
    value is the value returned by the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel;
    CCustomError * pErr = GetSelectedListItem(&nCurSel);

    if (pErr == NULL)
    {
        //
        // Must be from a double click on extended selection
        //
        return IDCANCEL;
    }
    
    CCustomErrorDlg dlgError(pErr, IsLocal(), this);
    INT_PTR nReturn = dlgError.DoModal();

    if (nReturn == IDOK)
    {
        //
        // Re-display the text
        //
        m_list_Errors.InvalidateSelection(nCurSel);
        SetModified(TRUE);
    }

    return nReturn;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3ErrorsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Errors.Initialize();

    //
    // Build filters oblist
    //
    CError err(FetchErrors());
    err.MessageBoxOnFailure();
    SetControlStates();

    return TRUE;
}



void
CW3ErrorsPage::OnButtonEdit()
/*++

Routine Description:

    'edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertyDialog() == IDOK)
    {
        SetControlStates();
        SetModified(TRUE);
    }
}



void
CW3ErrorsPage::OnButtonSetToDefault()
/*++

Routine Description:

    'set to default' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Apply to each selected item
    //
    m_list_Errors.SetRedraw(FALSE);

    int nSel = 0;
    int cChanges = 0;
    CCustomError * pErr;
    while ((pErr = GetNextSelectedItem(&nSel)) != NULL)
    {
        if (!pErr->IsDefault())
        {
            //
            // Force a redraw of the current item
            //
            pErr->MakeDefault();
            m_list_Errors.InvalidateSelection(nSel);
            ++cChanges;
        }

        ++nSel;
    }

    if (cChanges)
    {    
        SetModified(TRUE);
    }

    m_list_Errors.SetRedraw(TRUE);
    SetControlStates();
}



void
CW3ErrorsPage::OnDblclkListErrors()
/*++

Routine Description:

    error list 'double click' handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CW3ErrorsPage::OnSelchangeListErrors()
/*++

Routine Description:

    error list selection change handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



/* virtual */
HRESULT
CW3ErrorsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_strlCustomErrors);
    END_META_DIR_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3ErrorsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 errors page now...");

    CError err;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_strlCustomErrors)
    END_META_DIR_WRITE(err)

    EndWaitCursor();

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\defws.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        defws.h

   Abstract:

        Default Web Site Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __DEFWS_H__
#define __DEFWS_H__



class CDefWebSitePage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CDefWebSitePage       : Constructor
    CDefWebSitePage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CDefWebSitePage)

//
// Construction
//
public:
    CDefWebSitePage(CInetPropertySheet * pSheet = NULL);
    ~CDefWebSitePage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CDefWebSitePage)
    enum { IDD = IDD_DEFAULT_SITE };
    int     m_nUnlimited;
    BOOL    m_fEnableDynamic;
    BOOL    m_fEnableStatic;
    CString m_strDirectory;
    CEdit   m_edit_DirectorySize;
    CEdit   m_edit_Directory;
    CStatic m_static_MB;
    CButton m_button_Browse;
    //}}AFX_DATA

    BOOL   m_fEnableLimiting;
    BOOL   m_fCompressionDirectoryChanged;
    CILong m_ilSize;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefWebSitePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CDefWebSitePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowse();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnCheckDynamicCompression();
    afx_msg void OnCheckStaticCompression();
    afx_msg void OnChangeEditCompressDirectory();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

//    HRESULT BuildInstanceList();
//    DWORD FetchInstanceSelected();
    void SetControlStates();
    BOOL HasCompression() const;

private:
    CIISCompressionProps * m_ppropCompression;
//    CDWordArray m_rgdwInstances;
    BOOL m_fFilterPathFound;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CDefWebSitePage::HasCompression() const
{
    return m_fFilterPathFound 
		&& !CInetPropertyPage::Has10ConnectionLimit() // i.e. is workstation
		&& CInetPropertyPage::HasCompression();
}


#endif // __DEFWS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\errordlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errordlg.cpp

   Abstract:

        Error dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "errordlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// HTTP Custom Error Definition
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Static Initialization
//
LPCTSTR CCustomError::s_szSep = _T(",");
LPCTSTR CCustomError::s_szURL = _T("URL");
LPCTSTR CCustomError::s_szFile = _T("FILE");
LPCTSTR CCustomError::s_szNoSubError = _T("*");



/* static */
BOOL
CCustomError::CrackErrorString(
    IN  LPCTSTR lpstrErrorString, 
    OUT UINT & nError, 
    OUT UINT & nSubError,
    OUT ERT & nType, 
    OUT CString & str
    )
/*++

Routine Description

    Helper function to parse error string into component parts

Arguments:

    LPCTSTR lpstrErrorString    : Error input string
    UINT & nError               : Error 
    UINT & nSubError            : Sub Error
    int & nType                 : Error type
    CString & str               : Text parameter
    
Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        do
        {
            CString strError(lpstrErrorString);
            TRACEEOLID(strError);

            LPTSTR lp = strError.GetBuffer(0);
            LPTSTR lpField = StringTok(lp, s_szSep);

            if (!lpField) break;
            nError = _ttoi(lpField);
            ASSERT(nError > 0);
        
            lpField = StringTok(NULL, s_szSep);
            if (!lpField) break;

            nSubError = _ttoi(lpField);
            lpField = StringTok(NULL, s_szSep);
            if (!lpField) break;
            nType = (lstrcmpi(lpField, s_szURL) == 0) ? ERT_URL : ERT_FILE;
            lpField = StringTok(NULL, s_szSep);
            if (!lpField) break;
            str = lpField;
            fSuccess = TRUE;
        }
        while(FALSE);
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



/* static */
void 
CCustomError::CrackErrorDescription(
    IN  LPCTSTR lpstrErrorString, 
    OUT UINT & nError, 
    OUT UINT & nSubError,
    OUT BOOL & fURLSupported,
    OUT CString & str
    )
/*++

Routine Description

    Helper function to parse error description into component parts

Arguments:

    LPCTSTR lpstrErrorString    : Error input string
    UINT & nError               : Error 
    UINT & nSubError            : Sub Error
    BOOL & fURLSupported        : Return TRUE if urls are allowed
    CString & str               : Text parameter
    
Return Value:

    None.

--*/
{
    try
    {
        CString strError(lpstrErrorString);
        TRACEEOLID(strError);

        LPTSTR lp = strError.GetBuffer(0);
        LPTSTR lpField = StringTok(lp, s_szSep);
        nError = _ttoi(lpField);
        ASSERT(nError > 0);
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        nSubError = lpField != NULL ? _ttoi(lpField) : 0;
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        str = lpField;
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        if (nSubError > 0)
        {
            //
            // Add sub error text
            //
            ASSERT(nSubError > 0);
            str += _T(" - ");
            str += lpField;
            lpField = StringTok(NULL, s_szSep);
        }

        ASSERT(lpField != NULL);
        fURLSupported = lpField != NULL ? (_ttoi(lpField) == 0) : FALSE;
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }
}




CCustomError::CCustomError(
    IN LPCTSTR lpstrErrorString
    )
/*++

Routine Description:

   Construct error definition from metabase string
  
Arguments:

    LPCTSTR lpstrErrorString : Error string
    
Return Value:

    N/A 

--*/
    : m_nType(ERT_DEFAULT)
{
    CrackErrorDescription(
        lpstrErrorString,
        m_nError,
        m_nSubError,
        m_fURLSupported,
        m_strDefault
        );
}



void 
CCustomError::BuildErrorString(
    OUT CString & str
    )
/*++

Routine Description:

    Build metabase-ready error string out of the current values

Arguments:

    CString & str : String

Return Value:

    None

--*/
{
    ASSERT(!IsDefault());

    try
    {
        if (m_nSubError > 0)
        {
            str.Format(_T("%d,%d,%s,%s"),
                m_nError,
                m_nSubError,
                IsFile() ? s_szFile : s_szURL,
                (LPCTSTR)m_str
                );
        }
        else
        {
            str.Format(
                _T("%d,%s,%s,%s"),
                m_nError,
                s_szNoSubError,
                IsFile() ? s_szFile : s_szURL,
                (LPCTSTR)m_str
                );
        }
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}



//
// Custom Errors property page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CCustomErrorDlg::CCustomErrorDlg(
    IN OUT CCustomError * pErr,
    IN BOOL fLocal,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Error editing dialog

Arguments:

    CCustomError * pErr   : Error definition to be edited
    BOOL fLocal     : TRUE if the current computer is local
    CWnd * pParent  : Optional parent window or NULL

Return Value:

    N/A

--*/
    : CDialog(CCustomErrorDlg::IDD, pParent),
      m_fLocal(fLocal),
      m_pErr(pErr),
      m_nMessageType(pErr->m_nType),
      m_strTextFile(pErr->m_str),
      m_strDefText(pErr->m_strDefault)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CCustomErrorDlg)
    m_nMessageType = -1;
    m_strTextFile = _T("");
    m_strDefText = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    VERIFY(m_strFile.LoadString(IDS_FILE_PROMPT));
    VERIFY(m_strURL.LoadString(IDS_URL_PROMPT));
}



void 
CCustomErrorDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustomErrorDlg)
    DDX_CBIndex(pDX, IDC_COMBO_MESSAGE_TYPE, m_nMessageType);
    DDX_Text(pDX, IDC_STATIC_DEF_TEXT, m_strDefText);
    DDX_Control(pDX, IDC_EDIT_TEXT_FILE, m_edit_TextFile);
    DDX_Control(pDX, IDC_STATIC_SUB_PROMPT, m_static_SubErrorPrompt);
    DDX_Control(pDX, IDC_STATIC_SUB_ERROR_CODE, m_static_SubError);
    DDX_Control(pDX, IDC_STATIC_TEXT_FILE_PROMT, m_static_TextFilePrompt);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_COMBO_MESSAGE_TYPE, m_combo_MessageType);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_STATIC_ERROR_CODE, m_pErr->m_nError);
    DDX_Text(pDX, IDC_STATIC_SUB_ERROR_CODE, m_pErr->m_nSubError);

    DDX_Text(pDX, IDC_EDIT_TEXT_FILE, m_strTextFile);
    m_strTextFile.TrimLeft();
    m_strTextFile.TrimRight();
    if (pDX->m_bSaveAndValidate)
    {
        if (m_nMessageType == CCustomError::ERT_FILE)
        {
            if (!::IsFullyQualifiedPath(m_strTextFile) 
              || (m_fLocal && ::IsNetworkPath(m_strTextFile))
               )
            {
                ::AfxMessageBox(IDS_ERR_BAD_PATH);
                pDX->Fail();
            }
            
            if (m_fLocal && 
                (::GetFileAttributes(m_strTextFile) & FILE_ATTRIBUTE_DIRECTORY))
            {
                ::AfxMessageBox(IDS_ERR_FILE_NOT_FOUND);
                pDX->Fail();
            }
        }
        else if (m_nMessageType == CCustomError::ERT_URL)
        {
            if (!IsRelURLPath(m_strTextFile))
            {
                ::AfxMessageBox(IDS_NOT_REL_URL);
                pDX->Fail();
            }
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CCustomErrorDlg, CDialog)
    //{{AFX_MSG_MAP(CCustomErrorDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_MESSAGE_TYPE, OnSelchangeComboMessageType)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EDIT_TEXT_FILE, OnChangeEditTextFile)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
CCustomErrorDlg::SetControlStates()
/*++

Routine Description:

    Set the enabled states of the dialog controls depending on the current
    state of the dialog

Arguments:

    None

Return Value:

    TRUE if file/url is selected, FALSE otherwise

--*/
{
    int nCurSel = m_combo_MessageType.GetCurSel();
    BOOL fFile = nCurSel == CCustomError::ERT_FILE;
    BOOL fDefault = nCurSel == CCustomError::ERT_DEFAULT;
    
    ActivateControl(m_button_Browse, m_fLocal && fFile);

    ActivateControl(m_edit_TextFile,         !fDefault);
    ActivateControl(m_static_TextFilePrompt, !fDefault);
    m_static_TextFilePrompt.SetWindowText(fFile ? m_strFile : m_strURL);

    m_button_OK.EnableWindow(fDefault
        || m_edit_TextFile.GetWindowTextLength() > 0);

    return !fDefault;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CCustomErrorDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Browsing available locally only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    CString str;
    VERIFY(str.LoadString(IDS_DEFAULT_ERROR));
    m_combo_MessageType.AddString(str);
    VERIFY(str.LoadString(IDS_FILE));
    m_combo_MessageType.AddString(str);

    if (m_pErr->URLSupported() || m_nMessageType == CCustomError::ERT_URL)
    {
        VERIFY(str.LoadString(IDS_URL));
        m_combo_MessageType.AddString(str);
    }

    m_combo_MessageType.SetCurSel(m_nMessageType);

    if (m_pErr->m_nSubError == 0)
    {
        DeActivateControl(m_static_SubErrorPrompt);
        DeActivateControl(m_static_SubError);
    }

    SetControlStates();
    
    return TRUE;
}



void 
CCustomErrorDlg::OnSelchangeComboMessageType()
/*++

Routine Description:

    Handle change in message type combo box

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = m_combo_MessageType.GetCurSel();
    if (m_nMessageType == nSel)
    {
        //
        // Selection didn't change
        //
        return;
    }

    m_nMessageType = nSel;

    if (SetControlStates())
    {
        m_edit_TextFile.SetWindowText(_T(""));
        m_edit_TextFile.SetFocus();
    }
}



void 
CCustomErrorDlg::OnChangeEditTextFile()
/*++

Routine Description:

    Handle change in text/file edit box

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CCustomErrorDlg::OnOK()
/*++

Routine Description:

    Handle the OK button being pressed

Arguments:
    
    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        m_pErr->m_nType = (CCustomError::ERT)m_nMessageType;
        m_pErr->m_str = m_strTextFile;
    
        CDialog::OnOK();
    }
}

void 
CCustomErrorDlg::OnButtonBrowse()
/*++

Routine Description:

    Browse for HTML File
    
Arguments:

    None
    
Return Value:

    None 

--*/
{
    ASSERT(m_fLocal);

    //
    // popup the file dialog and let the user select the error htm file
    //
    CString str;
    str.LoadString(IDS_HTML_MASK);
    CFileDialog dlgBrowse(TRUE, NULL, NULL, OFN_HIDEREADONLY, str, this);

    if (dlgBrowse.DoModal() == IDOK)
    {
        m_pErr->m_str = dlgBrowse.GetPathName();
        m_edit_TextFile.SetWindowText(m_pErr->m_str);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\errors.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errors.h

   Abstract:

        HTTP errors property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Forward definitions
//
class CCustomError;



class CCustomErrorsListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of CCustomError objects

Public Interface:

    CCustomErrorsListBox    : Constructor

    GetItem                 : Get error object at index
    AddItem                 : Add item to listbox
    InsertItem              : Insert item into the listbox
    Initialize              : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CCustomErrorsListBox);

public:
    static const nBitmaps;  // Number of bitmaps

public:
    CCustomErrorsListBox(UINT nIDDefault, UINT nIDFile, UINT nIDURL);

public:
    CCustomError * GetItem(UINT nIndex);
    int AddItem(CCustomError * pItem);
    int InsertItem(int nPos, CCustomError * pItem);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    CString m_str[3];
};



class CHTTPErrorDescriptions : public CMetaProperties
/*++

Class Description:

    List of HTTP error descriptions

Public Interface:

    CHTTPErrorDescriptions  : Constructor

--*/
{
//
// Constructor
//
public:
    CHTTPErrorDescriptions(LPCTSTR lpServerName);

//
// Access
//
public:
    CStringList & GetErrorDescriptions() { return m_strlErrorDescriptions; }

protected:
    virtual void ParseFields();

//
// Data
//
private:
    MP_CStringListEx m_strlErrorDescriptions;
};



class CW3ErrorsPage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CW3ErrorsPage       : Constructor
    CW3ErrorsPage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3ErrorsPage)

//
// Construction
//
public:
    CW3ErrorsPage(CInetPropertySheet * pSheet = NULL);
    ~CW3ErrorsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3ErrorsPage)
    enum { IDD = IDD_DIRECTORY_ERRORS };
    CButton m_button_SetDefault;
    CButton m_button_Edit;
    //}}AFX_DATA

    CCustomErrorsListBox  m_list_Errors;
    CStringListEx         m_strlCustomErrors;
    CStringListEx         m_strlErrorDescriptions;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3ErrorsPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3ErrorsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDblclkListErrors();
    afx_msg void OnSelchangeListErrors();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonSetToDefault();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    void FillListBox();
    INT_PTR ShowPropertyDialog();
    CCustomError * GetSelectedListItem(int * pnSel = NULL);
    CCustomError * GetNextSelectedItem(int * pnStartingIndex);
    CCustomError * FindError(UINT nError, UINT nSubError);
    HRESULT FetchErrors();
    HRESULT StoreErrors();

private:
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus m_oblErrors;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CCustomError * CCustomErrorsListBox::GetItem(UINT nIndex)
{
    return (CCustomError *)GetItemDataPtr(nIndex);
}

inline int CCustomErrorsListBox::AddItem(CCustomError * pItem)
{
    return AddString((LPCTSTR)pItem);
}

inline int CCustomErrorsListBox::InsertItem(int nPos, CCustomError * pItem)
{
    return InsertString(nPos, (LPCTSTR)pItem);
}

inline CCustomError * CW3ErrorsPage ::GetSelectedListItem(
    OUT int * pnSel OPTIONAL
    )
{
    return (CCustomError *)m_list_Errors.GetSelectedListItem(pnSel);
}

inline CCustomError * CW3ErrorsPage::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CCustomError *)m_list_Errors.GetNextSelectedItem(pnStartingIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\filters.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        filters.h

   Abstract:

        WWW Filters Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Forward Definitions
//
class CIISFilter;



class CFiltersListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of filter items

Public Interface:

    CFiltersListBox     : Constructor

    GetItem             : Get filter at specified location
    GetNextSelectedItem : Get next selected filter item
    AddItem             : Add filter to listbox
    InsertItem          : Insert filter into the listbox
    Initialize          : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CFiltersListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;  

public:
    //
    // Constructor
    //
    CFiltersListBox(
        IN UINT nIdLow,
        IN UINT nIdMedium,
        IN UINT nIdHigh,
        IN UINT nIdUnknown
        );

public:
    //
    // Initialize the listbox control
    //
    virtual BOOL Initialize();

    CIISFilter * GetItem(UINT nIndex);
    int AddItem(CIISFilter * pItem);

    int InsertItem(
        IN int nPos,
        IN CIISFilter * pItem
        );

    CIISFilter * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    CString m_str[FLT_PR_NUM]; 
};




class CW3FiltersPage : public CInetPropertyPage
/*++

Class Description:

    Filter page

Public Interface:

    CW3FiltersPage      : Constructor

--*/
{
    DECLARE_DYNCREATE(CW3FiltersPage)

//
// Construction
//
public:
    CW3FiltersPage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CW3FiltersPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3FiltersPage)
    enum { IDD = IDD_FILTERS };
    CString m_strFiltersPrompt;
    CStatic m_static_NamePrompt;
    CStatic m_static_Name;
    CStatic m_static_StatusPrompt;
    CStatic m_static_Status;
    CStatic m_static_ExecutablePrompt;
    CStatic m_static_Executable;
    CStatic m_static_Priority;
    CStatic m_static_PriorityPrompt;
    CButton m_static_Details;
    CButton m_button_Disable;
    CButton m_button_Edit;
    CButton m_button_Add;
    CButton m_button_Remove;
    //}}AFX_DATA

    CUpButton   m_button_Up;
    CDownButton m_button_Down;
    CFiltersListBox m_list_Filters;
    CStringList m_strlScriptMaps;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CW3FiltersPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3FiltersPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonDisable();
    afx_msg void OnButtonEdit();
    afx_msg void OnDblclkListFilters();
    afx_msg void OnSelchangeListFilters();
    afx_msg void OnButtonDown();
    afx_msg void OnButtonUp();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void    ExchangeFilterPositions(int nSel1, int nSel2);
    void    SetControlStates();
    void    FillFiltersListBox(CIISFilter * pSelection = NULL);
    void    SetDetailsText();
    void    ShowProperties(BOOL fAdd = FALSE);
    INT_PTR ShowFiltersPropertyDialog(BOOL fAdd = FALSE);
    LPCTSTR BuildFilterOrderString(CString & strFilterOrder);

private:
    CString m_strYes;
    CString m_strNo;
    CString m_strStatus[5];
    CString m_strPriority[FLT_PR_NUM];
    CString m_strEnable;
    CString m_strDisable;
    CIISFilterList * m_pfltrs;
    CRMCListBoxResources m_ListBoxResFilters;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CIISFilter * CFiltersListBox::GetItem(UINT nIndex)
{
    return (CIISFilter *)GetItemDataPtr(nIndex);
}

inline CIISFilter * CFiltersListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CIISFilter *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline int CFiltersListBox::AddItem(CIISFilter * pItem)
{
    return AddString ((LPCTSTR)pItem);
}

inline int CFiltersListBox::InsertItem(
    IN int nPos,
    IN CIISFilter * pItem
    )
{
    return InsertString(nPos, (LPCTSTR)pItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
    CString result;
    GetProperty(0x0, VT_BSTR, (void*)&result);
    return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
    SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
    CY result;
    GetProperty(0x2, VT_CY, (void*)&result);
    return result;
}

void COleFont::SetSize(const CY& propVal)
{
    SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
    BOOL result;
    GetProperty(0x3, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetBold(BOOL propVal)
{
    SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
    BOOL result;
    GetProperty(0x4, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetItalic(BOOL propVal)
{
    SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
    BOOL result;
    GetProperty(0x5, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
    SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
    BOOL result;
    GetProperty(0x6, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
    SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
    short result;
    GetProperty(0x7, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetWeight(short propVal)
{
    SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
    short result;
    GetProperty(0x8, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetCharset(short propVal)
{
    SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
    COleFont() {}       // Calls COleDispatchDriver default constructor
    COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    CString GetName();
    void SetName(LPCTSTR);
    CY GetSize();
    void SetSize(const CY&);
    BOOL GetBold();
    void SetBold(BOOL);
    BOOL GetItalic();
    void SetItalic(BOOL);
    BOOL GetUnderline();
    void SetUnderline(BOOL);
    BOOL GetStrikethrough();
    void SetStrikethrough(BOOL);
    short GetWeight();
    void SetWeight(short);
    short GetCharset();
    void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\fltdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fltdlg.h

   Abstract:

        WWW Filters Property Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FLTDLG_H__
#define __FLTDLG_H__

enum
{
    FLTR_DISABLED,
    FLTR_LOADED,
    FLTR_UNLOADED,
    FLTR_DIRTY,
    /**/
    FLTR_UNKNOWN
};

enum
{
    FLTR_PR_INVALID,
    FLTR_PR_LOW,
    FLTR_PR_MEDIUM,
    FLTR_PR_HIGH,
};



//
// Num priority levels
//
#define FLT_PR_NUM  (FLTR_PR_HIGH + 1)



//
// CFilterDlg dialog
//
class CFilterDlg : public CDialog
/*++

Class Description:

    Filter property dialog

Public Interface:

    CFilterDlg    : Constructor
    GetFilter     : Get the filter object being edited

--*/
{
//
// Construction
//
public:
    CFilterDlg(
        IN CIISFilter &flt,
        IN CIISFilterList *& pFilters,
        IN BOOL fLocal,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFilterDlg)
    enum { IDD = IDD_FILTER };
    CString m_strExecutable;
    CString m_strFilterName;
    CString m_strPriority;
    CEdit   m_edit_FilterName;
    CEdit   m_edit_Executable;
    CStatic m_static_Priority;
    CStatic m_static_PriorityPrompt;
    CButton m_button_Browse;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFilterDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Access
//
public:
    CIISFilter & GetFilter() { return m_flt; }

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CFilterDlg)
    afx_msg void OnButtonBrowse();
    afx_msg void OnExecutableChanged();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    BOOL FilterNameExists(LPCTSTR lpName);

private:
    BOOL m_fLocal;
    BOOL m_fEditMode;
    CIISFilter m_flt;
    CIISFilterList *& m_pFilters;
};

#endif // __FLTDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\filters.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        filters.cpp

   Abstract:

        WWW Filters Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "fltdlg.h"
#include "filters.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Column width relative weights
//
#define WT_STATUS             (7)
#define WT_FILTER            (12)
#define WT_PRIORITY           (8)



//
// Bitmap indices
//
enum
{
    BMPID_DISABLED,
    BMPID_LOADED,
    BMPID_UNLOADED,
    BMPID_NOT_COMMITTED,
    /**/
    BMPID_TOTAL
};



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Filters");



IMPLEMENT_DYNAMIC(CFiltersListBox, CHeaderListBox);



const int CFiltersListBox::nBitmaps = BMPID_TOTAL;



CFiltersListBox::CFiltersListBox(
    IN UINT nIdLow,
    IN UINT nIdMedium,
    IN UINT nIdHigh,
    IN UINT nIdUnknown
    )
/*++

Routine Description:

    Constructor for filters listbox

Arguments:

    UINT nIdLow     : Resource ID for text string "Low"
    UINT nIdMedium  : Resource ID for text string "Medium"
    UINT nIdHigh    : Resource ID for text string "High"

Return Value:

    N/A

--*/
    : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    VERIFY(m_str[FLTR_PR_INVALID].LoadString(nIdUnknown));
    VERIFY(m_str[FLTR_PR_LOW].LoadString(nIdLow));
    VERIFY(m_str[FLTR_PR_MEDIUM].LoadString(nIdMedium));
    VERIFY(m_str[FLTR_PR_HIGH].LoadString(nIdHigh));
}



void
CFiltersListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Draw structure

Return Value:

    None

--*/
{
    CIISFilter * p = (CIISFilter *)ds.m_ItemData;
    ASSERT(p != NULL);

    int n;

    if (p->IsDirty())
    {
        n = BMPID_NOT_COMMITTED;
    }
    else if (!p->IsEnabled())
    {   
        n = BMPID_DISABLED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_LOADED)
    {
        n = BMPID_LOADED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_UNLOADED)
    {
        n = BMPID_UNLOADED;
    }
    else
    {
        n = BMPID_DISABLED;
    }

    DrawBitmap(ds, 0, n);
    ColumnText(ds, 1, FALSE, p->m_strName);

    if (p->IsDirty())
    {
        ColumnText(ds, 2, FALSE, m_str[FLTR_PR_INVALID]);
    }
    else
    {
        ASSERT(p->m_nPriority >= FLTR_PR_INVALID && p->m_nPriority <= FLTR_PR_HIGH);

        if (p->m_nPriority >= FLTR_PR_INVALID && p->m_nPriority <= FLTR_PR_HIGH)
        {
            ColumnText(ds, 2, FALSE, m_str[p->m_nPriority]);
        }
        else
        {
            //
            // Just in case
            //
            ColumnText(ds, 2, FALSE, m_str[FLTR_PR_INVALID]);
        }
    }
}



/* virtual */
BOOL 
CFiltersListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    InsertColumn(0, WT_STATUS, IDS_STATUS);
    InsertColumn(1, WT_FILTER, IDS_FILTER_NAME);
    InsertColumn(2, WT_PRIORITY, IDS_PRIORITY);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
    if (!SetWidthsFromReg())
    {
        DistributeColumns();
    }

    return TRUE;
}



IMPLEMENT_DYNCREATE(CW3FiltersPage, CInetPropertyPage)



CW3FiltersPage::CW3FiltersPage(
    IN CInetPropertySheet * pSheet
    ) 
/*++

Routine Description:

    Filters/application property page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3FiltersPage::IDD, pSheet),
      m_list_Filters(IDS_LOW, IDS_MEDIUM, IDS_HIGH, IDS_UNKNOWN_PRIORITY),
      m_ListBoxResFilters(IDB_FILTERS, m_list_Filters.nBitmaps),
      m_pfltrs(NULL)
{

#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

    m_list_Filters.AttachResources(&m_ListBoxResFilters);

    VERIFY(m_strYes.LoadString(IDS_YES));
    VERIFY(m_strNo.LoadString(IDS_NO));
    VERIFY(m_strStatus[FLTR_DISABLED].LoadString(IDS_DISABLED));
    VERIFY(m_strStatus[FLTR_LOADED].LoadString(IDS_LOADED));
    VERIFY(m_strStatus[FLTR_UNLOADED].LoadString(IDS_UNLOADED));
    VERIFY(m_strStatus[FLTR_UNKNOWN].LoadString(IDS_UNKNOWN));
    VERIFY(m_strStatus[FLTR_DIRTY].LoadString(IDS_NOT_COMMITTED));
    VERIFY(m_strPriority[FLTR_PR_INVALID].LoadString(IDS_UNKNOWN_PRIORITY));
    VERIFY(m_strPriority[FLTR_PR_LOW].LoadString(IDS_LOW));
    VERIFY(m_strPriority[FLTR_PR_MEDIUM].LoadString(IDS_MEDIUM));
    VERIFY(m_strPriority[FLTR_PR_HIGH].LoadString(IDS_HIGH));
    VERIFY(m_strEnable.LoadString(IDS_ENABLE));
    VERIFY(m_strDisable.LoadString(IDS_DISABLED));

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3FiltersPage)
    m_strFiltersPrompt = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    //
    // Change filters prompt on the master
    //
    VERIFY(m_strFiltersPrompt.LoadString(IsMasterInstance()
        ? IDS_MASTER_FILTERS
        : IDS_INSTANCE_FILTERS));
}



CW3FiltersPage::~CW3FiltersPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CW3FiltersPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX     : Pointer to data exchange object

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3FiltersPage)
    DDX_Control(pDX,  IDC_STATIC_FILTER_NAME_PROMPT, m_static_NamePrompt);
    DDX_Control(pDX,  IDC_STATIC_FILTER_NAME, m_static_Name);
    DDX_Control(pDX, IDC_STATIC_STATUS_PROMPT, m_static_StatusPrompt);
    DDX_Control(pDX, IDC_STATIC_STATUS, m_static_Status);
    DDX_Control(pDX, IDC_STATIC_EXECUTABLE_PROMPT, m_static_ExecutablePrompt);
    DDX_Control(pDX, IDC_STATIC_EXECUTABLE, m_static_Executable);
    DDX_Control(pDX, IDC_STATIC_PRIORITY, m_static_Priority);
    DDX_Control(pDX, IDC_STATIC_PRIORITY_PROMPT, m_static_PriorityPrompt);
    DDX_Control(pDX, IDC_STATIC_DETAILS, m_static_Details);
    DDX_Control(pDX, IDC_BUTTON_DISABLE, m_button_Disable);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Text(pDX, IDC_STATIC_FILTERS, m_strFiltersPrompt);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_FILTERS, m_list_Filters);
    DDX_Control(pDX, IDC_BUTTON_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTTON_DOWN, m_button_Down);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3FiltersPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3FiltersPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_DISABLE, OnButtonDisable)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_LBN_DBLCLK(IDC_LIST_FILTERS, OnDblclkListFilters)
    ON_LBN_SELCHANGE(IDC_LIST_FILTERS, OnSelchangeListFilters)
    ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
    ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()



void
CW3FiltersPage::FillFiltersListBox(
    IN CIISFilter * pSelection OPTIONAL
    )
/*++

Routine Description:

    Populate the listbox with the filter entries.

Arguments:

    CIISFilter * pSelection : Item to be selected

Return Value:

    None.

--*/
{
    ASSERT(m_pfltrs != NULL);

    m_pfltrs->ResetEnumerator();

    m_list_Filters.SetRedraw(FALSE);
    m_list_Filters.ResetContent();
    int cItems = 0;

    while(m_pfltrs->MoreFilters())
    {
        CIISFilter * pFilter = m_pfltrs->GetNextFilter();

        if (!pFilter->IsFlaggedForDeletion())
        {
            m_list_Filters.AddItem(pFilter);
            ++cItems;
        }
    }

    m_list_Filters.SetRedraw(TRUE);

    if (pSelection)
    {
        //
        // Select the desired entry
        //
        m_list_Filters.SelectItem(pSelection);
    }
}



void
CW3FiltersPage::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    SetDetailsText();

    CIISFilter * pFilter = NULL;

    BOOL fCanGoUp = FALSE;
    BOOL fCanGoDown = FALSE;
    int nCurSel = m_list_Filters.GetCurSel();

    if (nCurSel != LB_ERR)
    {
        //
        // Can only sort within the same priority
        //
        pFilter = m_list_Filters.GetItem(nCurSel);

        m_button_Disable.SetWindowText(pFilter->m_fEnabled
            ? m_strEnable 
            : m_strDisable
            );

        if (nCurSel > 0)
        {
            CIISFilter * pPrev = m_list_Filters.GetItem(nCurSel - 1);

            if (pFilter->m_nPriority == pPrev->m_nPriority)
            {
                fCanGoUp = TRUE;
            }
        }

        if (nCurSel < m_list_Filters.GetCount() - 1)
        {
            CIISFilter * pNext = m_list_Filters.GetItem(nCurSel + 1);

            if (pFilter->m_nPriority == pNext->m_nPriority)
            {
                fCanGoDown = TRUE;
            }
        }
    }

    m_button_Disable.EnableWindow(FALSE);
    m_button_Edit.EnableWindow(pFilter != NULL);
    m_button_Remove.EnableWindow(m_list_Filters.GetSelCount() > 0);
    m_button_Up.EnableWindow(fCanGoUp);
    m_button_Down.EnableWindow(fCanGoDown);
}



/* virtual */
HRESULT
CW3FiltersPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    m_pfltrs = new CIISFilterList(QueryServerName(), g_cszSvc, QueryInstance());
    err = m_pfltrs ? m_pfltrs->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

    return err;
}




/* virtual */
HRESULT
CW3FiltersPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 filters page now...");

    if (m_pfltrs)
    {
        BeginWaitCursor();
        CError err(m_pfltrs->WriteIfDirty());
        EndWaitCursor();

        if (err.Failed())
        {
            return err;
        }    
    }
    
    SetModified(FALSE);                                             

    return S_OK;
}



INT_PTR
CW3FiltersPage::ShowFiltersPropertyDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:
    
    Display the add/edit dialog.  The return
    value is the value returned by the dialog

Arguments:

    BOOL fAdd       : TRUE if we're adding a new filter

Return Value:

    Dialog return value; ID_OK or ID_CANCEL

--*/
{
    CIISFilter flt;
    CIISFilter * pFlt = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        nCurSel = m_list_Filters.GetCurSel();
        ASSERT(nCurSel >= 0);

        if (nCurSel != LB_ERR)
        {
            //
            // Get filter properties
            //
            pFlt = m_list_Filters.GetItem(nCurSel);
        }
    }
    else
    {
        //
        // Point to the empty filter
        //
        pFlt = &flt;
    }

    ASSERT(pFlt != NULL);
    CFilterDlg dlgFilter(*pFlt, m_pfltrs, IsLocal(), this);
    INT_PTR nReturn = dlgFilter.DoModal();

    if (nReturn == IDOK)
    {
        try
        {
            //
            // When editing, delete and re-add (to make sure the
            // list is properly sorted)
            //
            pFlt = new CIISFilter(dlgFilter.GetFilter());

            if (!fAdd)
            {
                ASSERT(m_pfltrs);
                m_pfltrs->RemoveFilter(nCurSel);
                m_list_Filters.DeleteString(nCurSel);
            }

            ASSERT(pFlt->IsInitialized());

            //
            // Add to list and listbox
            //
            m_pfltrs->AddFilter(pFlt);
            m_list_Filters.SetCurSel(m_list_Filters.AddItem(pFlt));

            //
            // Remember to store this one later
            //
            pFlt->Dirty();
            OnItemChanged();
        }
        catch(CMemoryException * e)
        {
            e->Delete();
        }
    }

    return nReturn;
}



void 
CW3FiltersPage::ShowProperties(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Edit/add filter
    
Arguments:

    BOOL fAdd    : TRUE if we're adding a filter

Return Value:

    None

--*/
{
    INT_PTR nResult = ShowFiltersPropertyDialog(fAdd);

    if (nResult == IDOK)
    {
        SetControlStates();
        SetModified(TRUE);
    }
}



void 
CW3FiltersPage::SetDetailsText()
/*++

Routine Description:

    Set the details text based on the currently selected filter

Arguments:

    None

Return Value:

    None

--*/
{
    int  nSel = m_list_Filters.GetCurSel();
    BOOL fShow = nSel != LB_ERR;

    ActivateControl(m_static_NamePrompt,        fShow);
    ActivateControl(m_static_Name,              fShow);
    ActivateControl(m_static_Priority,          fShow);
    ActivateControl(m_static_PriorityPrompt,    fShow);
    ActivateControl(m_static_Executable,        fShow);
    ActivateControl(m_static_ExecutablePrompt,  fShow);
    ActivateControl(m_static_Status,            fShow);
    ActivateControl(m_static_StatusPrompt,      fShow);
    ActivateControl(m_static_Details,           fShow);

    if (nSel != LB_ERR)
    {
        CIISFilter * pFilter = m_list_Filters.GetItem(nSel);
        ASSERT(pFilter != NULL);

        //
        // Display path in truncated form
        //    
        FitPathToControl(m_static_Executable, pFilter->m_strExecutable);

        int i;

        if (pFilter->IsDirty())
        {
            i = FLTR_DIRTY;
        }
        else if (!pFilter->IsEnabled())
        {
            i = FLTR_DISABLED;
        }
        else if (pFilter->IsLoaded())
        {
            i = FLTR_LOADED;
        }
        else if (pFilter->IsUnloaded())
        {
            i = FLTR_UNLOADED;
        }
        else
        {
            i = FLTR_UNKNOWN;
        }

        m_static_Name.SetWindowText(pFilter->QueryName());
        m_static_Status.SetWindowText(m_strStatus[i]);

        if (pFilter->IsDirty())
        {
            m_static_Priority.SetWindowText(m_strPriority[FLTR_PR_INVALID]);
        }
        else
        {
            m_static_Priority.SetWindowText(m_strPriority[pFilter->m_nPriority]);
        }
    }
}



void
CW3FiltersPage::ExchangeFilterPositions(
    IN int nSel1,
    IN int nSel2
    )
/*++

Routine Description:

    Exchange 2 filter objects, as indicated by their
    indices.  Selection will take place both in the
    listbox and in the oblist.

Arguments:

    int nSel1           : Index of item 1
    int nSel2           : Index of item 2

Return Value:

    None

--*/
{
    CIISFilter * p1, * p2;

    if (!m_pfltrs->ExchangePositions(nSel1, nSel2, p1, p2))
    {
        ASSERT(FALSE);

        return;
    }
    
    m_list_Filters.SetItemDataPtr(nSel1, p1);
    m_list_Filters.SetItemDataPtr(nSel2, p2); 

    CRect rc1, rc2;
    m_list_Filters.GetItemRect(nSel1, &rc1);
    m_list_Filters.GetItemRect(nSel2, &rc2); 
    m_list_Filters.InvalidateRect(&rc1, TRUE);
    m_list_Filters.InvalidateRect(&rc2, TRUE);

    SetModified(TRUE);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3FiltersPage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}




void 
CW3FiltersPage::OnButtonAdd()
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ShowProperties(TRUE);
}



void 
CW3FiltersPage::OnButtonEdit()
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ShowProperties(FALSE);
}



void 
CW3FiltersPage::OnButtonDisable()
/*++

Routine Description:

    'Disable' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Filters.GetCurSel();
    CIISFilter * pFilter = m_list_Filters.GetItem(nCurSel);
    ASSERT(pFilter);

/*
    pFilter->m_fEnabled = !pFilter->m_fEnabled;
    m_list_Filters.InvalidateSelection(nCurSel);
    SetControlStates();
*/
}



void 
CW3FiltersPage::OnButtonRemove()
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/

{
    int nSel = 0;
    int cChanges = 0;
    int nCurSel = m_list_Filters.GetCurSel();

    CIISFilter * pFilter = NULL;

    while ((pFilter = m_list_Filters.GetNextSelectedItem(&nSel)) != NULL)
    {
        pFilter->FlagForDeletion();
        m_list_Filters.DeleteString(nSel);
        ++cChanges;
    }

    if (cChanges)
    {
        m_list_Filters.SetCurSel(nCurSel);

        SetControlStates();
        OnItemChanged();
    }
}



void 
CW3FiltersPage::OnDblclkListFilters()
/*++

Routine Description:

    Filter listbox double click handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void 
CW3FiltersPage::OnSelchangeListFilters()
/*++

Routine Description:

    'Selection Change' handler in the filters listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CW3FiltersPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CError err;

    CInetPropertyPage::OnInitDialog();

    m_list_Filters.Initialize();

    //
    // Add filters to the listbox
    //
    if (err.Succeeded())
    {
        err = m_pfltrs->LoadAllFilters();
    }

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // Filters path not yet created, this is ok 
        //
        ASSERT(m_pfltrs && m_pfltrs->GetCount() == 0);
        err.Reset();
    }

    //
    // Make sure the up/down buttons show up correctly
    //
    m_button_Up.SizeToContent();
    m_button_Down.SizeToContent();

    if (!err.MessageBoxOnFailure())
    {
        FillFiltersListBox();    
    }

    SetControlStates();
    
    return TRUE; 
}



void 
CW3FiltersPage::OnButtonDown() 
/*++

Routine Description:

    Down button handler.  Exchange positions of the current item
    with the next lower item

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // First get current selection 
    //
    int nCurSel = m_list_Filters.GetCurSel();

    ExchangeFilterPositions(nCurSel, nCurSel + 1);
    m_list_Filters.SetCurSel(nCurSel + 1);
    SetControlStates();
}



void 
CW3FiltersPage::OnButtonUp() 
/*++

Routine Description:

    Up button handler.  Exchange positions of the current item
    with the next higher item

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_Filters.GetCurSel();

    ExchangeFilterPositions(nCurSel - 1, nCurSel);
    m_list_Filters.SetCurSel(nCurSel - 1);
    SetControlStates();
}



void 
CW3FiltersPage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    //
    // Filters and extensions lists will clean themself up
    //
    SAFE_DELETE(m_pfltrs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\logui.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "logui.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CLogUI

IMPLEMENT_DYNCREATE(CLogUI, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CLogUI properties

CString CLogUI::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CLogUI::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

COleFont CLogUI::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CLogUI::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CLogUI::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CLogUI::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CLogUI::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CLogUI::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CLogUI operations

void CLogUI::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CLogUI::ApplyLogSelection()
{
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::SetComboBox(HWND hComboBox)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         hComboBox);
}

void CLogUI::Terminate()
{
    InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\fltdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fltdlg.cpp

   Abstract:

        WWW Filters Property Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "fltdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CFilterDlg::CFilterDlg(
    IN OUT CIISFilter & flt,
    IN CIISFilterList * & pFilters,
    IN BOOL fLocal,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Filter properties dialog constructor

Arguments:

    CIISFilter & flt          : Filter being edited
    CFilters * & pFilters     : List of filters that exist
    BOOL fLocal               : TRUE on the local system
    CWnd * pParent OPTIONAL   : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CFilterDlg::IDD, pParent),
      m_fLocal(fLocal),
      m_pFilters(pFilters),
      m_fEditMode(FALSE),
      m_flt(flt)
{
    //{{AFX_DATA_INIT(CFilterDlg)
    m_strExecutable = m_flt.m_strExecutable;
    m_strFilterName = m_flt.m_strName;
    //}}AFX_DATA_INIT

    //
    // Map priority to string ID
    //
    m_strPriority.LoadString(IDS_HIGH + 3 - m_flt.m_nPriority);
}



void 
CFilterDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFilterDlg)
    DDX_Control(pDX, IDC_STATIC_PRIORITY_VALUE, m_static_Priority);
    DDX_Control(pDX, IDC_STATIC_PRIORITY, m_static_PriorityPrompt);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_FILTERNAME, m_edit_FilterName);
    DDX_Control(pDX, IDC_EDIT_EXECUTABLE, m_edit_Executable);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Text(pDX, IDC_EDIT_FILTERNAME, m_strFilterName);
    DDX_Text(pDX, IDC_STATIC_PRIORITY_VALUE, m_strPriority);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_EXECUTABLE, m_strExecutable);
    DDV_MaxChars(pDX, m_strExecutable, 255);

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Validate executable
        //
        if (!::IsFullyQualifiedPath(m_strExecutable))
        {
            ::AfxMessageBox(IDS_ERR_BAD_PATH);
            pDX->Fail();
        }

        if (m_fLocal && 
            (::GetFileAttributes(m_strExecutable) & FILE_ATTRIBUTE_DIRECTORY))
        {
            ::AfxMessageBox(IDS_ERR_FILE_NOT_FOUND);
            pDX->Fail();
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFilterDlg, CDialog)
    //{{AFX_MSG_MAP(CFilterDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EDIT_EXECUTABLE, OnExecutableChanged)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_FILTERNAME, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CFilterDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Available on local connections only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    if ((m_fEditMode = m_edit_FilterName.GetWindowTextLength() > 0))
    {
        m_edit_FilterName.SetReadOnly();
    }

    SetControlStates();
    
    return TRUE;
}



void 
CFilterDlg::OnButtonBrowse() 
/*++

Routine Description:

    Browse button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fLocal);

    CString strFilterMask((LPCTSTR)IDS_FILTER_MASK);

    //
    // CODEWORK: Derive a class from CFileDialog that allows
    // the setting of the initial path
    //

    //CString strPath;
    //m_edit_Executable.GetWindowText(strPath);

    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        strFilterMask, 
        this
        );

    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_Executable.SetWindowText(dlgBrowse.GetPathName());
    }

    OnItemChanged();
}



void 
CFilterDlg::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    BOOL fAllowAnonymous : If TRUE, 'allow anonymous' is on.

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(
        m_edit_FilterName.GetWindowTextLength() > 0
     && m_edit_Executable.GetWindowTextLength() > 0);

    ActivateControl(m_static_PriorityPrompt, m_flt.m_nPriority != FLTR_PR_INVALID);
    ActivateControl(m_static_Priority,       m_flt.m_nPriority != FLTR_PR_INVALID);
}



void
CFilterDlg::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFilterDlg::OnExecutableChanged()
/*++

Routine Description:

    Handle change in executable edit box.  Remove priority as this
    is no longer valid

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Priority no longer makes sense.
    // 
    m_flt.m_nPriority = FLTR_PR_INVALID;
    OnItemChanged();
}



BOOL
CFilterDlg::FilterNameExists(
    IN LPCTSTR lpName
    )
/*++

Routine Description:

    Look for a given filter name in the list

Arguments:

    LPCTSTR lpName  : Filter name to look for

Return Value:

    TRUE if the name already existed in the list

--*/
{
    m_pFilters->ResetEnumerator();

    while(m_pFilters->MoreFilters())
    {
        CIISFilter * pFilter = m_pFilters->GetNextFilter();
        ASSERT(pFilter != NULL);

        if (!pFilter->IsFlaggedForDeletion())
        {
            if (!pFilter->m_strName.CompareNoCase(lpName))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}



void 
CFilterDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Save data

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        //
        // Make sure the filter name is unique
        //
        if (!m_fEditMode && FilterNameExists(m_strFilterName))
        {
            ::AfxMessageBox(IDS_ERR_DUP_FILTER);
            return;
        }

        m_flt.m_strExecutable = m_strExecutable;
        m_flt.m_strName = m_strFilterName;
        //
        // Anyway to load this from the DLL?
        //
        //m_flt.m_nPriority = FLTR_PR_MEDIUM;
        CDialog::OnOK();
    }

    //
    // Don't dismiss the dialog
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\logui.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CLogUI wrapper class

class CLogUI : public CWnd
{
protected:
    DECLARE_DYNCREATE(CLogUI)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634603, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    CString GetCaption();
    void SetCaption(LPCTSTR);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
    void ApplyLogSelection();
    void SetComboBox(HWND hComboBox);
    void Terminate();
    void DoClick();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\hdrdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        hdrdlg.h

   Abstract:

        HTTP Headers dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __HDRDLG_H__
#define __HDRDLG_H__



class CHeaderDlg : public CDialog
/*++

Class Description:

    HTTP Header dialog

Public Interface:

    CHeaderDlg          : Constructor
    GetHeader           : Get header name
    GetValue            : Get header value

--*/
{
//
// Construction
//
public:
    CHeaderDlg(
        IN LPCTSTR lpstrHeader = NULL,
        IN LPCTSTR lpstrValue  = NULL,
        IN CWnd * pParent      = NULL
        );

//
// Access
//
public:
    CString & GetHeader() { return m_strHeader; }
    CString & GetValue()  { return m_strValue; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CHeaderDlg)
    enum { IDD = IDD_CUSTOM_HEADER };
    CString m_strHeader;
    CString m_strValue;
    CEdit   m_edit_Header;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHeaderDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CHeaderDlg)
    afx_msg void OnChangeEditHeader();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // __HDRDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\hdrdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        hdrdlg.cpp

   Abstract:

        HTTP Headers dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "hdrdlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CHeaderDlg::CHeaderDlg(
    IN LPCTSTR lpstrHeader,
    IN LPCTSTR lpstrValue,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for HTTP heade dialog

Arguments:

    LPCTSTR lpstrHeader     : Header string
    LPCTSTR lpstrValue      : Value string
    CWnd * pParent          : Parent window
    
Return Value:

    None    

--*/
    : CDialog(CHeaderDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CHeaderDlg)
    m_strHeader = lpstrHeader ? lpstrHeader : _T("");
    m_strValue = lpstrValue ? lpstrValue : _T("");
    //}}AFX_DATA_INIT
}



void 
CHeaderDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CHeaderDlg)
    DDX_Control(pDX, IDC_EDIT_HEADER, m_edit_Header);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Text(pDX, IDC_EDIT_HEADER, m_strHeader);
    DDX_Text(pDX, IDC_EDIT_VALUE, m_strValue);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CHeaderDlg, CDialog)
    //{{AFX_MSG_MAP(CHeaderDlg)
    ON_EN_CHANGE(IDC_EDIT_HEADER, OnChangeEditHeader)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CHeaderDlg::OnChangeEditHeader()
/*++

Routine Description:

    change edit handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(m_edit_Header.GetWindowTextLength() > 0);
}



BOOL 
CHeaderDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    OnChangeEditHeader();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\ipdomdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipdomdlg.cpp

   Abstract:

        IP and domain security restrictions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "accessdl.h"
#include "ipdomdlg.h"


//
// Needed for granted/denied icons
//
#include "..\comprop\resource.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ILIST_DENY      0
#define ILIST_GRANT     1

#define ITYPE_DNS       0
#define ITYPE_IP        1



CIPDomainDlg::CIPDomainDlg(
    IN BOOL & fIpDirty,
    IN BOOL & fDefaultGranted,
    IN BOOL & fOldDefaultGranted,
    IN CObListPlus & oblAccessList,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    IP/Domain access restrictions dialog constructor

Argumentss:

    CWnd * pParent       : Parent window

Return Value:

    N/A

--*/
    : CEmphasizedDialog(CIPDomainDlg::IDD, pParent),
      m_ListBoxRes(
        IDB_ACCESS,
        m_list_IpAddresses.nBitmaps
        ),
      m_oblAccessList(),
      m_list_IpAddresses(TRUE),
      m_fIpDirty(fIpDirty),
      m_fOldDefaultGranted(fOldDefaultGranted),
      m_fDefaultGranted(fDefaultGranted)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CIPDomainDlg)
    m_nGrantedDenied = 0;
    //}}AFX_DATA_INIT

#endif // 0

    //
    // Keep a temporary copy of these
    //
    m_oblAccessList.SetOwnership(FALSE);
    m_oblAccessList.AddTail(&oblAccessList);

    m_list_IpAddresses.AttachResources(&m_ListBoxRes);

    m_nGrantedDenied = m_fDefaultGranted ? DEFAULT_GRANTED : DEFAULT_DENIED;
}



void 
CIPDomainDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CEmphasizedDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CIPDomainDlg)
    DDX_Control(pDX, IDC_RADIO_GRANTED, m_radio_Granted);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_ICON_GRANTED, m_icon_Granted);
    DDX_Control(pDX, IDC_ICON_DENIED, m_icon_Denied);
    DDX_Radio(pDX, IDC_RADIO_GRANTED, m_nGrantedDenied);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_RADIO_DENIED, m_radio_Denied);
    DDX_Control(pDX, IDC_LIST_IP_ADDRESSES, m_list_IpAddresses);
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CIPDomainDlg, CEmphasizedDialog)
    //{{AFX_MSG_MAP(CIPDomainDlg)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_LBN_DBLCLK(IDC_LIST_IP_ADDRESSES, OnDblclkListIpAddresses)
    ON_LBN_ERRSPACE(IDC_LIST_IP_ADDRESSES, OnErrspaceListIpAddresses)
    ON_BN_CLICKED(IDC_RADIO_GRANTED, OnRadioGranted)
    ON_BN_CLICKED(IDC_RADIO_DENIED, OnRadioDenied)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRESSES, OnSelchangeListIpAddresses)
    ON_WM_VKEYTOITEM()
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CIPDomainDlg::OnButtonAdd() 
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        m_fIpDirty = TRUE;
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnButtonEdit() 
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        m_fIpDirty = TRUE;
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnButtonRemove() 
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = 0;
    int nCurSel = m_list_IpAddresses.GetCurSel();
    while (m_list_IpAddresses.GetNextSelectedItem(&nSel))
    {
        m_oblAccessList.RemoveIndex(nSel);
        m_list_IpAddresses.DeleteString(nSel);
    }

    m_fIpDirty = TRUE;

    if (nCurSel > 0)
    {
        --nCurSel;
    }

    m_list_IpAddresses.SetCurSel(nCurSel);

    if (!SetControlStates())
    {
        m_button_Add.SetFocus();
    }
}



BOOL
CIPDomainDlg::SetControlStates()
/*++

Routine Description:

    Set button states depending on content of the listbox and the controls
    
Arguments:

    None

Return Value:

    TRUE if at least one item is currently selected in the listbox.

--*/
{
    BOOL fSomeSelection = m_list_IpAddresses.GetSelCount() > 0;

    m_button_Edit.EnableWindow(m_list_IpAddresses.GetSelCount() == 1);
    m_button_Remove.EnableWindow(m_list_IpAddresses.GetSelCount() > 0);

    return fSomeSelection;
}



void
CIPDomainDlg::FillListBox(
    IN CIPAccessDescriptor * pSelection OPTIONAL
    )
/*++

Routine Description:

    Fill the ip address listbox from the oblist of access entries

Arguments:

    CIPAccessDescriptor * pSelection : Item to be selected or NULL.

Return Value:

    None

--*/
{
    CObListIter obli(m_oblAccessList);
    const CIPAccessDescriptor * pAccess;

    m_list_IpAddresses.SetRedraw(FALSE);
    m_list_IpAddresses.ResetContent();

    int cItems = 0 ;
    int nSel = LB_ERR, nItem;
    for ( /**/; pAccess = (CIPAccessDescriptor *)obli.Next(); ++cItems)
    {
        //
        // We only list those not adhering to the default
        //
        if (pAccess->HasAccess() != m_fDefaultGranted)
        {
            nItem = m_list_IpAddresses.AddItem(pAccess);
            if (pAccess == pSelection)
            {
                //
                // Found item to be selected
                //
                nSel = nItem;
            }
        }
    }

    m_list_IpAddresses.SetCurSel(nSel);
    m_list_IpAddresses.SetRedraw(TRUE);
}



DWORD
CIPDomainDlg::SortAccessList()
/*++

Routine Description:

    Sorting the access list by grant denied and ip address
    FillListBox() should be called after this because
    the listbox will no longer reflect the true status
    of the list of directories.

Arguments:

    None

Return Value:

    Error Return code

--*/
{
    BeginWaitCursor();
    DWORD dw =  m_oblAccessList.Sort((CObjectPlus::PCOBJPLUS_ORDER_FUNC) 
        &CIPAccessDescriptor::OrderByAddress);
    EndWaitCursor();

    return dw;
}


INT_PTR
CIPDomainDlg::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit. Return the value returned 
    by the dialog

Arguments:

    BOOL fAdd : If TRUE, create new item.  Otherwise, edit existing item

Return Value:

    Dialog return code (IDOK/IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CIPAccessDescriptor * pAccess = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        //
        // Edit existing entry -- there better be only one...
        //
        pAccess = m_list_IpAddresses.GetSelectedItem();
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            //
            // Double click?
            //
            return IDCANCEL;
        }
    }

    CIPAccessDlg dlgAccess(
        m_fDefaultGranted, 
        pAccess, 
        &m_oblAccessList, 
        this, 
        TRUE
        );

    INT_PTR nReturn = dlgAccess.DoModal();

    if (nReturn == IDOK)
    {
        CError err;
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            try
            {
                if (fAdd)
                {
                    m_oblAccessList.AddTail(pAccess);
                }

                SortAccessList();
                FillListBox(pAccess);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;    
                e->Delete();
            }
        }

        err.MessageBoxOnFailure();
    }

    return nReturn;
}



void
CIPDomainDlg::OnDblclkListIpAddresses()
/*++

Routine Description:

    Double click handler for IP listbox

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CIPDomainDlg::OnErrspaceListIpAddresses()
/*++

Routine Description:

    Error -- out of memory error for IP listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CIPDomainDlg::OnSelchangeListIpAddresses()
/*++

Routine Description:

    ip address 'selection change' notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CIPDomainDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CEmphasizedDialog::OnInitDialog();

    m_icon_Granted.SetIcon(::AfxGetApp()->LoadIcon(IDI_GRANTED));
    m_icon_Denied.SetIcon(::AfxGetApp()->LoadIcon(IDI_DENIED));

    m_list_IpAddresses.Initialize();

    FillListBox();
    SetControlStates();
 
    return TRUE;  
}



void 
CIPDomainDlg::OnRadioGranted()
/*++

Routine Description:

    'Granted' radio button handler.

    Granted by default has been selected.  Refill the listbox with 
    items that have been explicitly denied.  Although we can
    only have a deny list or a grant list, we keep both of them 
    around until it comes time to saving the information.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fDefaultGranted)
    {
        m_fDefaultGranted = TRUE;
        FillListBox();
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnRadioDenied()
/*++

Routine Description:

    'Denied' radio button handler.  Same as above, with reverse granted 
    and denied.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fDefaultGranted)
    {
        m_fDefaultGranted = FALSE;
        FillListBox();
        SetControlStates();
    }
}



int 
CIPDomainDlg::OnVKeyToItem(
    IN UINT nKey, 
    IN CListBox * pListBox, 
    IN UINT nIndex
    ) 
/*++

Routine Description:

    Map virtual keys to commands for ip listbox

Arguments:

    UINT nKey           Specifies the virtual-key code of the key 
                        that the user pressed.
    CListBox * pListBox Specifies a pointer to the list box. The 
                        pointer may be temporary and should not be stored for later use.

    UINT nIndex         Specifies the current caret position.

Return Value:

    -2  : No further action necessary
    -1  : Perform default action for the keystroke
    >=0 : Indicates the default action should be performed on the index
          specified.   

--*/
{
    switch(nKey)
    {
    case VK_DELETE:
        OnButtonRemove();
        break;

    case VK_INSERT:
        OnButtonAdd();
        break;

    default:
        //
        // Not completely handled by this function, let
        // windows handle the remaining default action.
        //
        return -1;
    }

    //
    // No further action is neccesary.
    //
    return -2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\httppage.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        httppage.cpp

   Abstract:

        HTTP Headers property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "hdrdlg.h"
#include "HTTPPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/* static */
void
CHeader::CrackDisplayString(
    IN  LPCTSTR lpstrDisplayString,
    OUT CString & strHeader,
    OUT CString & strValue
    )
/*++

Routine Description:

    Crack the display string into component formats

Arguments:

    LPCTSTR lpstrDisplayString  : Input display string
    CString & strHeader         : Header
    CString & strValue          : Value

Return Value:

    N/A

--*/
{
    strHeader = lpstrDisplayString;
    strHeader.TrimLeft();
    strHeader.TrimRight();
    int nColon = strHeader.Find(_T(':'));
    if (nColon >= 0)
    {
        strValue = (lpstrDisplayString + nColon + 1);
        strHeader.ReleaseBuffer(nColon);
    }

    strValue.TrimLeft();
    strValue.TrimRight();
}



//
// HTTP Custom Header Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


#define MINUTE              (60L)
#define HOUR                (60L * MINUTE)
#define DAY                 (24L * HOUR)
#define YEAR                (365 * DAY)

#define EXPIRE_IMMEDIATELY  ((LONG)(0L))
#define EXPIRE_INFINITE     ((LONG)(0xffffffff))
#define EXPIRE_DEFAULT      ((LONG)(1L * DAY)) // 1 day
#define DEFAULT_DYN_EXPIRE  (10L * DAY)
#define EXPIRE_MIN_NUMBER   (1)
#define EXPIRE_MAX_NUMBER   (32767)



IMPLEMENT_DYNCREATE(CW3HTTPPage, CInetPropertyPage)



CW3HTTPPage::CW3HTTPPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Property page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet data

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3HTTPPage::IDD, pSheet),
      m_fValuesAdjusted(FALSE),
      m_ppropMimeTypes(NULL),
      m_tmNow(CTime::GetCurrentTime())
{

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CW3HTTPPage)
    m_nTimeSelector = -1;
    m_nImmediateTemporary = -1;
    m_fEnableExpiration = FALSE;
    m_nExpiration = 0L;
    m_strlCustomHeaders = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



CW3HTTPPage::~CW3HTTPPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3HTTPPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3HTTPPage)
    DDX_Control(pDX, IDC_BUTTON_FILE_TYPES, m_button_FileTypes);
    DDX_Radio(pDX, IDC_RADIO_IMMEDIATELY, m_nImmediateTemporary);
    DDX_Check(pDX, IDC_CHECK_EXPIRATION, m_fEnableExpiration);
    DDX_Control(pDX, IDC_EDIT_EXPIRE, m_edit_Expire);
    DDX_Control(pDX, IDC_RADIO_IMMEDIATELY, m_radio_Immediately);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_Delete);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_STATIC_CONTENT_SHOULD, m_static_Contents);
    DDX_Control(pDX, IDC_COMBO_TIME, m_combo_Time);
    //}}AFX_DATA_MAP

    //
    // Only store and validate immediate expiration date if immediate
    // is selected.
    //
    if (!pDX->m_bSaveAndValidate || m_nImmediateTemporary == RADIO_EXPIRE)
    {
        DDX_CBIndex(pDX, IDC_COMBO_TIME, m_nTimeSelector);
        DDX_Text(pDX, IDC_EDIT_EXPIRE, m_nExpiration);
        DDV_MinMaxLong(pDX, m_nExpiration, EXPIRE_MIN_NUMBER, EXPIRE_MAX_NUMBER);
    }

    DDX_Control(pDX, IDC_RADIO_TIME, m_radio_Time);
    DDX_Control(pDX, IDC_RADIO_ABS_TIME, m_radio_AbsTime);
    DDX_Control(pDX, IDC_DTP_ABS_DATE, m_dtpDate);
    DDX_Control(pDX, IDC_DTP_ABS_TIME, m_dtpTime);
    DDX_Control(pDX, IDC_LIST_HEADERS, m_list_Headers);

    if (pDX->m_bSaveAndValidate)
    {
        StoreTime();
        StoreHeaders();
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CW3HTTPPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3HTTPPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_FILE_TYPES, OnButtonFileTypes)
    ON_BN_CLICKED(IDC_BUTTON_RATINGS_TEMPLATE, OnButtonRatingsTemplate)
    ON_BN_CLICKED(IDC_CHECK_EXPIRATION, OnCheckExpiration)
    ON_CBN_SELCHANGE(IDC_COMBO_TIME, OnSelchangeComboTime)
    ON_LBN_SELCHANGE(IDC_LIST_HEADERS, OnSelchangeListHeaders)
    ON_LBN_DBLCLK(IDC_LIST_HEADERS, OnDblclkListHeaders)
    ON_BN_CLICKED(IDC_RADIO_IMMEDIATELY, OnRadioImmediately)
    ON_BN_CLICKED(IDC_RADIO_TIME, OnRadioTime)
    ON_BN_CLICKED(IDC_RADIO_ABS_TIME, OnRadioAbsTime)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_EXPIRE, OnItemChanged)

END_MESSAGE_MAP()



BOOL
AdjustIfEvenMultiple(
    IN OUT CILong & ilValue,
    IN LONG lMultiple
    )
/*++

Routine Description:

    Check to see if ilValue is an even multiple of lMultiple.
    If so, divide ilValue by lMultiple

Arguments:

    CILong & ilValue      : Value
    LONG lMultiple        : Multiple

Return Value:

    TRUE if ilValue is an even multiple of lMultiple.

--*/
{
    DWORD dw = (DWORD)(LONG)ilValue / (DWORD)lMultiple;
    if (dw * (DWORD)lMultiple == (DWORD)(LONG)ilValue)
    {
        ilValue = (LONG)dw;
        return TRUE;
    }

    return FALSE;
}



BOOL
CW3HTTPPage::CrackExpirationString(
    IN CString & strExpiration
    )
/*++

Routine Description:

    Crack the expiration string into component parts.  Using either N or a blank
    string to signify "No expiration"

Arguments:

    None

Return Value:

    return TRUE if the values had to be adjusted because they were out of
    range.

--*/
{
    strExpiration.TrimLeft();
    strExpiration.TrimRight();
    BOOL fValueAdjusted = FALSE;

    m_fEnableExpiration = !strExpiration.IsEmpty();
    LPCTSTR lp = strExpiration;
    BOOL fAbs = FALSE;
    if (m_fEnableExpiration)
    {
        switch(*lp)
        {
        case _T('D'):
        case _T('d'):
            lp += 2;
            while (_istspace(*lp)) ++lp;
            CvtStringToLong(lp, &m_dwRelTime);
            break;

        case _T('S'):
        case _T('s'):
            lp += 2;
            while (_istspace(*lp)) ++lp;
            m_dwRelTime = EXPIRE_DEFAULT;

            time_t tm;
            if (!CvtGMTStringToInternal(lp, &tm))
            {
                ::AfxMessageBox(IDS_ERR_EXPIRE_RANGE, MB_ICONINFORMATION | MB_OK);
                fValueAdjusted = TRUE;
            }

            m_tm = tm;
            fAbs = TRUE;
            break;

        case _T('N'):
        case _T('n'):
            m_fEnableExpiration = FALSE;
            break;

        default:
            TRACEEOLID("Expiration string in bogus format");
            m_fEnableExpiration = FALSE;
        }
    }

    //
    // Set Values:
    //
    m_nExpiration = (LONG)m_dwRelTime;

    m_nImmediateTemporary = fAbs
        ? RADIO_EXPIRE_ABS
        : (m_nExpiration == EXPIRE_IMMEDIATELY)
            ? RADIO_IMMEDIATELY
            : RADIO_EXPIRE;

    //
    // Adjust time
    //
    if (m_nExpiration == EXPIRE_INFINITE
     || m_nExpiration == EXPIRE_IMMEDIATELY)
    {
        m_nExpiration = EXPIRE_DEFAULT;
    }

    if (AdjustIfEvenMultiple(m_nExpiration, DAY))
    {
        m_nTimeSelector = COMBO_DAYS;
    }
    else if (AdjustIfEvenMultiple(m_nExpiration, HOUR))
    {
        m_nTimeSelector = COMBO_HOURS;
    }
    else
    {
        m_nExpiration /= MINUTE;
        m_nExpiration = __max((DWORD)(LONG)m_nExpiration, 1L);
        if (m_nExpiration < EXPIRE_MIN_NUMBER ||
            m_nExpiration > EXPIRE_MAX_NUMBER)
        {
            m_nExpiration = (EXPIRE_DEFAULT / MINUTE);
            ::AfxMessageBox(IDS_ERR_EXPIRE_RANGE, MB_ICONINFORMATION | MB_OK);
        }

        m_nTimeSelector = COMBO_MINUTES;
    }

    return fValueAdjusted;
}



void
CW3HTTPPage::MakeExpirationString(
    OUT CString & strExpiration
    )
/*++

Routine Description:

    Make the expiration string from component parts

Arguments:

    None

Return Value:

    None

--*/
{
    strExpiration.Empty();

    DWORD dwExpiration = m_nExpiration;

    if (m_fEnableExpiration)
    {
        switch(m_nImmediateTemporary)
        {
        case RADIO_IMMEDIATELY:
            strExpiration = _T("D, 0");
            break;

        case RADIO_EXPIRE:
            switch(m_nTimeSelector)
            {
            case COMBO_MINUTES:
                dwExpiration *= MINUTE;
                break;

            case COMBO_HOURS:
                dwExpiration *= HOUR;
                break;

            case COMBO_DAYS:
                dwExpiration *= DAY;
                break;

            default:
                ASSERT(FALSE);
            }

            strExpiration.Format(_T("D, 0x%0x"), dwExpiration);
            break;

        case RADIO_EXPIRE_ABS:
            CvtInternalToGMTString(m_tm.GetTime(), strExpiration);
            strExpiration = _T("S, ") + strExpiration;
            break;

        default:
            TRACEEOLID("Unknown expiration format");
            ASSERT(FALSE);

            return;
        }
    }
}



/* virtual */
HRESULT
CW3HTTPPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BEGIN_META_DIR_READ(CW3Sheet)
        CString m_strExpiration;

        FETCH_DIR_DATA_FROM_SHEET(m_strExpiration);
        FETCH_DIR_DATA_FROM_SHEET(m_strlCustomHeaders);

        //
        // Set up some defaults.
        //
        m_dwRelTime = EXPIRE_DEFAULT;

        m_tm = CTime(
            m_tmNow.GetYear(),
            m_tmNow.GetMonth(),
            m_tmNow.GetDay(),
            0, 0, 0          // Midnight
            );
        m_tm += DEFAULT_DYN_EXPIRE;

        m_fValuesAdjusted = CrackExpirationString(m_strExpiration);
    END_META_DIR_READ(err)

    //
    // Fetch the properties from the metabase
    //
    ASSERT(m_ppropMimeTypes == NULL);

    CError err;

    m_ppropMimeTypes = new CMimeTypes(
        GetServerName(), 
        g_cszSvc, 
        QueryInstance(), 
        QueryParent(), 
        QueryAlias()
        );

    if (m_ppropMimeTypes)
    {
        err = m_ppropMimeTypes->LoadData();
        if (err.Succeeded())
        {
            m_strlMimeTypes = m_ppropMimeTypes->m_strlMimeTypes;
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



void
CW3HTTPPage::StoreTime()
/*++

Routine Description:

    Built datetime by combining current date with the time from the time
    controls.

Arguments:

    None

Return Value:

    None

--*/
{
    SYSTEMTIME tmDate, tmTime;

    m_dtpDate.GetSystemTime(&tmDate);
    m_dtpTime.GetSystemTime(&tmTime);

    m_tm = CTime(
        tmDate.wYear,
        tmDate.wMonth,
        tmDate.wDay,
        tmTime.wHour,
        tmTime.wMinute,
        tmTime.wSecond
        );
}



void
CW3HTTPPage::SetTimeFields()
/*++

Routine Description:

    Set time fields from CTime structure

Arguments:

    None

Return Value:

    None

--*/
{
    SYSTEMTIME stm =
    {
        (WORD)m_tm.GetYear(),
        (WORD)m_tm.GetMonth(),
        (WORD)m_tm.GetDayOfWeek(),
        (WORD)m_tm.GetDay(),
        (WORD)m_tm.GetHour(),
        (WORD)m_tm.GetMinute(),
        (WORD)m_tm.GetSecond(),
        0   // Milliseconds
    };

    m_dtpDate.SetSystemTime(&stm);
    m_dtpTime.SetSystemTime(&stm);
}



void
CW3HTTPPage::FillListBox()
/*++

Routine Description:

    Fill the custom headers listbox with the custom headers entries

Arguments:

    None

Return Value:

    None

--*/
{
    CObListIter obli(m_oblHeaders);
    CHeader * pHeader;

    //
    // Remember the selection.
    //
    int nCurSel = m_list_Headers.GetCurSel();

    m_list_Headers.SetRedraw(FALSE);
    m_list_Headers.ResetContent();
    int cItems = 0 ;

    CString strCustom;
    for ( /**/ ; pHeader = (CHeader *)obli.Next() ; cItems++ )
    {
        m_list_Headers.AddString(pHeader->DisplayString(strCustom));
    }

    m_list_Headers.SetRedraw(TRUE);
    m_list_Headers.SetCurSel(nCurSel);
}



BOOL
CW3HTTPPage::SetControlStates()
/*++

Routine Description:

    Set the control enabled/disabled states depending on the state of the
    dialog

Arguments:

    None

Return Value:

    TRUE if an item was selected in the headers listbox, FALSE otherwise.

--*/
{
    BOOL fSingleSelection = m_list_Headers.GetSelCount() == 1;

    m_button_Edit.EnableWindow(fSingleSelection);
    m_button_Delete.EnableWindow(m_list_Headers.GetSelCount() > 0);

    BOOL fExpire = (m_nImmediateTemporary == RADIO_EXPIRE);
    BOOL fExpireAbs = (m_nImmediateTemporary == RADIO_EXPIRE_ABS);

    m_static_Contents.EnableWindow(m_fEnableExpiration);

    m_radio_Immediately.EnableWindow(m_fEnableExpiration);
    m_radio_Time.EnableWindow(m_fEnableExpiration);
    m_radio_AbsTime.EnableWindow(m_fEnableExpiration);

    m_edit_Expire.EnableWindow(m_fEnableExpiration && fExpire);
    m_combo_Time.EnableWindow(m_fEnableExpiration && fExpire);

    m_dtpDate.EnableWindow(m_fEnableExpiration && fExpireAbs);
    m_dtpTime.EnableWindow(m_fEnableExpiration && fExpireAbs);

    return fSingleSelection;
}



void
CW3HTTPPage::FetchHeaders()
/*++

Routine Description:

    Build custom headers oblist

Arguments:

    None

Return Value:

    None

--*/
{
    POSITION pos = m_strlCustomHeaders.GetHeadPosition();

    while(pos)
    {
        CString & str = m_strlCustomHeaders.GetNext(pos);
        m_oblHeaders.AddTail(new CHeader(str));
    }
}



BOOL
CW3HTTPPage::HeaderExists(
    IN LPCTSTR lpHeader
    )
/*++

Routine Description:

    Check to see if a given header exists in the list

Arguments:

    LPCTSTR strHeader   : Header name

Return Value:

    TRUE if the entry exists, FALSE otherwise.

--*/
{
    POSITION pos = m_oblHeaders.GetHeadPosition();
    while(pos)
    {
        CHeader * pHeader = (CHeader *)m_oblHeaders.GetNext(pos);
        ASSERT(pHeader);
        if (!pHeader->GetHeader().CompareNoCase(lpHeader))
        {
            return TRUE;
        }
    }

    return FALSE;
}



void
CW3HTTPPage::StoreHeaders()
/*++

Routine Description:

    Convert the headers oblist to a stringlist

Arguments:

    None

Return Value:

    None

--*/
{
    m_strlCustomHeaders.RemoveAll();

    POSITION pos = m_oblHeaders.GetHeadPosition();
    while(pos)
    {
        CHeader * pHdr = (CHeader *)m_oblHeaders.GetNext(pos);
        ASSERT(pHdr != NULL);

        CString str;
        pHdr->DisplayString(str);
        m_strlCustomHeaders.AddTail(str);
    }
}



INT_PTR
CW3HTTPPage::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit.
    return the value returned by the dialog

Arguments:

    None

Return Value:

    Return value of the dialog (IDOK or IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CHeader * pHeader = NULL;
    LPCTSTR lpstrHeader = NULL;
    LPCTSTR lpstrValue = NULL;
    int nCurSel = LB_ERR;
    INT_PTR nReturn;

    if (!fAdd)
    {
        nCurSel = m_list_Headers.GetCurSel();
        ASSERT(nCurSel != LB_ERR);
        pHeader = (CHeader *)m_oblHeaders.GetAt(m_oblHeaders.FindIndex(nCurSel));
        ASSERT(pHeader != NULL);
        lpstrHeader = pHeader->QueryHeader();
        lpstrValue = pHeader->QueryValue();
    }

    CHeaderDlg dlg(lpstrHeader, lpstrValue, this);
    nReturn = dlg.DoModal();

    if (nReturn == IDOK)
    {
        CString strEntry;

        if (fAdd)
        {
            if (HeaderExists(dlg.GetHeader()))
            {
                ::AfxMessageBox(IDS_ERR_DUP_HEADER);
                return IDCANCEL;
            }

            pHeader = new CHeader(dlg.GetHeader(), dlg.GetValue());
            m_oblHeaders.AddTail(pHeader);
            m_list_Headers.SetCurSel(m_list_Headers.AddString(
                pHeader->DisplayString(strEntry))
                );
        }
        else
        {
            pHeader->SetHeader(dlg.GetHeader());
            pHeader->SetValue(dlg.GetValue());
            m_list_Headers.DeleteString(nCurSel);
            m_list_Headers.InsertString(
                nCurSel, 
                pHeader->DisplayString(strEntry)
                );
            m_list_Headers.SetCurSel(nCurSel);
        }
    }

    return nReturn;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


void
CW3HTTPPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}



void
CW3HTTPPage::OnButtonAdd()
/*++

Routine Description:

    'add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        SetControlStates();
        OnItemChanged();
    }
}



void
CW3HTTPPage::OnButtonDelete()
/*++

Routine Description:

    'delete' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Headers.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_Headers.GetCount())
    {
        if (m_list_Headers.GetSel(nSel))
        {
            m_oblHeaders.RemoveIndex(nSel);
            m_list_Headers.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_Headers.SetCurSel(nCurSel);
        if (!SetControlStates())
        {
            //
            // Delete button will be disabled, move focus elsewhere
            //
            GetDlgItem(IDC_BUTTON_ADD)->SetFocus();
        }

        OnItemChanged();
    }
}



void
CW3HTTPPage::OnButtonEdit()
/*++

Routine Description:

    'edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        SetControlStates();
        OnItemChanged();
    }
}



void
CW3HTTPPage::OnCheckExpiration()
/*++

Routine Description:

    'expiration' checkbox

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableExpiration = !m_fEnableExpiration;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnSelchangeComboTime()
/*++

Routine Description:

    'selection change' in time combobox handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    OnItemChanged();
}



void 
CW3HTTPPage::OnSelchangeListHeaders()
/*++

Routine Description:

    'selection change' in headers listbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CW3HTTPPage::OnDblclkListHeaders()
/*++

Routine Description:

    'double click' in headers listbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CW3HTTPPage::OnRadioImmediately()
/*++

Routine Description:

    'immediate' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_IMMEDIATELY;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnRadioTime()
/*++

Routine Description:

    'expire' radio button

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_EXPIRE;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnRadioAbsTime()
/*++

Routine Description:

    'absolute expire' radio button

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_EXPIRE_ABS;
    SetControlStates();
    OnItemChanged();
}



BOOL
CW3HTTPPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_button_FileTypes.EnableWindow(m_ppropMimeTypes != NULL);
    m_list_Headers.Initialize();

    //
    // Fill combo box with (Minutes, hours, days)
    //
    for (UINT n = IDS_MINUTES; n <= IDS_DAYS; ++n)
    {
        CString str;
        VERIFY(str.LoadString(n));
        m_combo_Time.AddString(str);
    }

    m_combo_Time.SetCurSel(m_nTimeSelector);

    //
    // Set the minimum of the date picker to today
    // and the maximum to Dec 31, 2035.
    //
    SYSTEMTIME stmRange[2] =
    {
        {
            (WORD)m_tmNow.GetYear(),
            (WORD)m_tmNow.GetMonth(),
            (WORD)m_tmNow.GetDayOfWeek(),
            (WORD)m_tmNow.GetDay(),
            (WORD)m_tmNow.GetHour(),
            (WORD)m_tmNow.GetMinute(),
            (WORD)m_tmNow.GetSecond(),
            0
        },
        {
            2035,
            12,
            1,      // A Monday as it turns out
            31,
            23,
            59,
            59,
        }
    };

    m_dtpDate.SetRange(GDTR_MIN | GDTR_MAX, stmRange);

    //
    // Create a hidden ratings OCX, which is activated by a press
    // on the ratings button.  We never did get our problems with
    // mnemonics straightened out so that we could use the ocx
    // directly.
    //
    m_ocx_Ratings.Create(
        _T("Rat"),
        WS_BORDER,
        CRect(0, 0, 0, 0),
        this,
        IDC_BUTTON_RATINGS
        );

    SetTimeFields();
    FetchHeaders();
    FillListBox();
    SetControlStates();
    m_ocx_Ratings.SetAdminTarget(GetServerName(), QueryMetaPath());

    if (m_fValuesAdjusted)
    {
        //
        // One or more input values was adjusted
        //
        OnItemChanged();
        m_fValuesAdjusted = FALSE;
    }

    return TRUE;
}



HRESULT
CW3HTTPPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 HTTP directory page now...");

    CError err;

    CString m_strExpiration;
    MakeExpirationString(m_strExpiration);

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_strExpiration)
        STORE_DIR_DATA_ON_SHEET(m_strlCustomHeaders)
    END_META_DIR_WRITE(err)

    if (err.Succeeded() && m_ppropMimeTypes)
    {
        m_ppropMimeTypes->m_strlMimeTypes = m_strlMimeTypes;
        err = m_ppropMimeTypes->WriteDirtyProps();
    }
    EndWaitCursor();

    return err;
}


void
CW3HTTPPage::OnButtonFileTypes()
/*++

Routine Description:

    'file types' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CMimeDlg dlg(m_strlMimeTypes, this);
    if (dlg.DoModal() == IDOK)
    {
        OnItemChanged();
    }
}


void
CW3HTTPPage::OnButtonRatingsTemplate()
/*++

Routine Description:

    Pass on "ratings" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    m_ocx_Ratings.DoClick();
}




void 
CW3HTTPPage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();

    SAFE_DELETE(m_ppropMimeTypes);
}



BOOL 
CW3HTTPPage::OnNotify(
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT * pResult
    ) 
/*++

Routine Description:

    Handle notification changes

Arguments:

    WPARAM wParam           : Control ID
    LPARAM lParam           : NMHDR *
    LRESULT * pResult       : Result pointer

Return Value:

    TRUE if handled, FALSE if not

--*/
{
    //
    // Message cracker crashes - so checking this here instead
    //
    if (wParam == IDC_DTP_ABS_DATE || wParam == IDC_DTP_ABS_TIME)
    {
        NMHDR * pHdr = (NMHDR *)lParam;
        if (pHdr->code == DTN_DATETIMECHANGE)
        {
            OnItemChanged();
        }
    }
    
    //
    // Default behaviour -- go to the message map
    //
    return CInetPropertyPage::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\httppage.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        httppage.h

   Abstract:

        HTTP Headers property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __HTTPPAGE_H__
#define __HTTPPAGE_H__



//{{AFX_INCLUDES()
#include "rat.h"
//}}AFX_INCLUDES



class CHeader : public CObjectPlus
/*++

Class Description:

    HTTP Header definition

Public Interface:

    CHeader               : Constructor
    DisplayString         : Build display string
    CrackDisplayString    : Convert from crack display string

--*/
{
//
// Constructor
//
public:
    CHeader(
        IN LPCTSTR lpstrHeader, 
        IN LPCTSTR lpstrValue
        );

    //
    // Parse header info from name:value string
    //
    CHeader(LPCTSTR lpstrDisplayString);

//
// Access
//
public:
    LPCTSTR QueryHeader() const { return m_strHeader; }
    LPCTSTR QueryValue() const { return m_strValue; }
    CString & GetHeader() { return m_strHeader;}
    CString & GetValue() { return m_strValue; }
    void SetHeader(LPCTSTR lpszHeader);
    void SetValue(LPCTSTR lpszValue);

//
// Interface:
public:
    //
    // Build output display string
    //
    LPCTSTR DisplayString(OUT CString & str);

protected:
    //
    // Parse the display string into fields
    //
    static void CrackDisplayString(
        IN  LPCTSTR lpstrDisplayString,
        OUT CString & strHeader,
        OUT CString & strValue
        );

private:
    CString m_strHeader;
    CString m_strValue;
};



class CW3HTTPPage : public CInetPropertyPage
/*++

Class Description:

    HTTP Custom Headers property page

Public Interface:

    CW3HTTPPage     : Constructor

--*/
{
    DECLARE_DYNCREATE(CW3HTTPPage)

//
// Construction
//
public:
    CW3HTTPPage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3HTTPPage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_IMMEDIATELY,
        RADIO_EXPIRE,
        RADIO_EXPIRE_ABS,
    };

    enum
    {
        COMBO_MINUTES,
        COMBO_HOURS,
        COMBO_DAYS,
    };

    //{{AFX_DATA(CW3HTTPPage)
    enum { IDD = IDD_DIRECTORY_HTTP };
    int         m_nTimeSelector;
    int         m_nImmediateTemporary;
    BOOL        m_fEnableExpiration;
    CEdit       m_edit_Expire;
    CButton     m_radio_Immediately;
    CButton     m_button_Delete;
    CButton     m_button_Edit;
    CButton     m_button_PickDate;
    CButton     m_button_FileTypes;
    CStatic     m_static_Contents;
    CComboBox   m_combo_Time;
    //}}AFX_DATA

    DWORD           m_dwRelTime;
    CILong          m_nExpiration;
    CTime           m_tm;
    CTime           m_tmNow;
    CRat            m_ocx_Ratings;
    CButton         m_radio_Time;
    CButton         m_radio_AbsTime;
    CDateTimePicker m_dtpDate;
    CDateTimePicker m_dtpTime;
    CRMCListBox     m_list_Headers;
    CStringListEx   m_strlCustomHeaders;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3HTTPPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3HTTPPage)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonFileTypes();
    afx_msg void OnButtonRatingsTemplate();
    afx_msg void OnCheckExpiration();
    afx_msg void OnSelchangeComboTime();
    afx_msg void OnSelchangeListHeaders();
    afx_msg void OnDblclkListHeaders();
    afx_msg void OnRadioImmediately();
    afx_msg void OnRadioTime();
    afx_msg void OnRadioAbsTime();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void    SetTimeFields();
    void    FillListBox();
    void    FetchHeaders();
    void    StoreTime();
    void    StoreHeaders();
    void    MakeExpirationString(CString & strExpiration);
    BOOL    SetControlStates();
    BOOL    CrackExpirationString(CString & strExpiration);
    BOOL    HeaderExists(LPCTSTR lpHeader);
    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    LPCTSTR QueryMetaPath();

private:
    BOOL          m_fValuesAdjusted;
    CStringListEx m_strlMimeTypes;
    CObListPlus   m_oblHeaders;
    CMimeTypes *  m_ppropMimeTypes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CHeader::CHeader(
    IN LPCTSTR lpstrHeader, 
    IN LPCTSTR lpstrValue
    )
    : m_strHeader(lpstrHeader),
      m_strValue(lpstrValue)
{
}

inline CHeader::CHeader(
    IN LPCTSTR lpstrDisplayString
    )
{
    CrackDisplayString(lpstrDisplayString, m_strHeader, m_strValue);
}

inline LPCTSTR CHeader::DisplayString(
    OUT CString & str
    )
{
    str.Format(_T("%s: %s"), (LPCTSTR)m_strHeader, (LPCTSTR)m_strValue);
    return str;
}

inline void CHeader::SetHeader(
    IN LPCTSTR lpszHeader
    )
{
    m_strHeader = lpszHeader;
}

inline void CHeader::SetValue(
    IN LPCTSTR lpszValue
    )
{
    m_strValue = lpszValue;
}

inline LPCTSTR CW3HTTPPage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().QueryMetaRoot();
}

#endif // __HTTPPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\msacal70.h ===
#ifndef __MSACAL70_H__
#define __MSACAL70_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CMsacal70 wrapper class

class CMsacal70 : public CWnd
{
protected:
    DECLARE_DYNCREATE(CMsacal70)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0x8e27c92b, 0x1264, 0x101c, { 0x8a, 0x2f, 0x4, 0x2, 0x24, 0x0, 0x9c, 0x2 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    OLE_COLOR GetBackColor();
    void SetBackColor(OLE_COLOR);
    short GetDay();
    void SetDay(short);
    COleFont GetDayFont();
    void SetDayFont(LPDISPATCH);
    unsigned long GetDayFontColor();
    void SetDayFontColor(unsigned long);
    short GetDayLength();
    void SetDayLength(short);
    short GetFirstDay();
    void SetFirstDay(short);
    long GetGridCellEffect();
    void SetGridCellEffect(long);
    COleFont GetGridFont();
    void SetGridFont(LPDISPATCH);
    unsigned long GetGridFontColor();
    void SetGridFontColor(unsigned long);
    unsigned long GetGridLinesColor();
    void SetGridLinesColor(unsigned long);
    short GetMonth();
    void SetMonth(short);
    short GetMonthLength();
    void SetMonthLength(short);
    BOOL GetShowDateSelectors();
    void SetShowDateSelectors(BOOL);
    BOOL GetShowDays();
    void SetShowDays(BOOL);
    BOOL GetShowHorizontalGrid();
    void SetShowHorizontalGrid(BOOL);
    BOOL GetShowTitle();
    void SetShowTitle(BOOL);
    BOOL GetShowVerticalGrid();
    void SetShowVerticalGrid(BOOL);
    COleFont GetTitleFont();
    void SetTitleFont(LPDISPATCH);
    unsigned long GetTitleFontColor();
    void SetTitleFontColor(unsigned long);
    VARIANT GetValue();
    void SetValue(const VARIANT&);
    VARIANT Get_Value();
    void Set_Value(const VARIANT&);
    BOOL GetValueIsNull();
    void SetValueIsNull(BOOL);
    short GetYear();
    void SetYear(short);

// Operations
public:
    void NextDay();
    void NextMonth();
    void NextWeek();
    void NextYear();
    void PreviousDay();
    void PreviousMonth();
    void PreviousWeek();
    void PreviousYear();
    void Refresh();
    void Today();
    void AboutBox();
};

#endif // __MSACAL70_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\mmmdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mmmdlg.cpp

   Abstract:

        Multi-multi-multi dialog editor

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "mmmdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Registry key name for this dialog
//
const TCHAR g_szRegKeyIP[] = _T("MMMIpBindings");
const TCHAR g_szRegKeySSL[] = _T("MMMSSLBindings");

//
// IP Bindings Listbox Column Definitions
//
static const ODL_COLUMN_DEF g_aIPColumns[] =
{
// ===============================================
// Weight   Label
// ===============================================
    {  6,   IDS_MMM_IP_ADDRESS,         },
    {  3,   IDS_MMM_TCP_PORT,           },
    { 10,   IDS_MMM_DOMAIN_NAME,        },
};

//
// SSL Bindings Listbox Column Definitions
//
static const ODL_COLUMN_DEF g_aSSLColumns[] =
{
// ===============================================
// Weight   Label
// ===============================================
    {  2,   IDS_MMM_IP_ADDRESS,         },
    {  1,   IDS_MMM_SSL_PORT,           },
};

#define NUM_COLUMNS(cols) (sizeof(cols) / sizeof(cols[0]))

IMPLEMENT_DYNAMIC(CMMMListBox, CRMCListBox);

//
// Bitmap indices
//
enum
{
    BMPID_BINDING,

    //
    // Don't move this one
    //
    BMPID_TOTAL
};


const int CMMMListBox::nBitmaps = BMPID_TOTAL;


CMMMListBox::CMMMListBox(
    IN LPCTSTR lpszRegKey,
    IN int cColumns,
    IN const ODL_COLUMN_DEF * pColumns
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CHeaderListBox(HLS_STRETCH, lpszRegKey),
      m_cColumns(cColumns),
      m_pColumns(pColumns)
{
    VERIFY(m_strDefaultIP.LoadString(IDS_DEFAULT));
    VERIFY(m_strNoPort.LoadString(IDS_MMM_NA));
}



void
CMMMListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds : Draw item structure

Return Value:

    None

--*/
{
    CString & strBinding = *(CString *)ds.m_ItemData;

    TRACEEOLID(strBinding);

    UINT nPort;
    LPCTSTR lp;
    CString strHostHeader;
    CString strPort;
    CString strIP;
    CIPAddress iaIpAddress;

    CInstanceProps::CrackBinding(
        strBinding, 
        iaIpAddress, 
        nPort, 
        strHostHeader
        );

    //
    // Display Granted/Denied with appropriate bitmap
    //
    DrawBitmap(ds, 0, BMPID_BINDING);

    if (iaIpAddress.IsZeroValue())
    {
        lp = m_strDefaultIP;
    }
    else
    {
        lp = iaIpAddress.QueryIPAddress(strIP);
    }

    ColumnText(ds, 0, TRUE, lp);

    if (nPort > 0)
    {
        strPort.Format(_T("%u"), nPort);
        lp = strPort;
    }
    else
    {
        lp = m_strNoPort;
    }

    ColumnText(ds, 1, FALSE, lp);
    ColumnText(ds, 2, FALSE, strHostHeader);
}



/* virtual */
BOOL
CMMMListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    for (int nCol = 0; nCol < m_cColumns; ++nCol)
    {
        InsertColumn(nCol, m_pColumns[nCol].nWeight, m_pColumns[nCol].nLabelID);
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
    if (!SetWidthsFromReg())
    {
        DistributeColumns();
    }

    return TRUE;
}



void AFXAPI
DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg  OPTIONAL
    )
/*++

Routine Description:

    DDX/DDV Function that uses a space to denote a 0 value

Arguments:

    CDataExchange * pDX     : Data exchange object
    UINT nID                : Resource ID
    OUT UINT & uValue       : Value
    UINT uMin               : Minimum value
    UINT uMax               : Maximum value
    UINT nEmptyErrorMsg     : Error message ID for empty unit, or 0 if empty OK

Return Value:

    None.

--*/
{
    ASSERT(uMin <= uMax);

    CWnd * pWnd = CWnd::FromHandle(pDX->PrepareEditCtrl(nID));
    ASSERT(pWnd != NULL);

    if (pDX->m_bSaveAndValidate)
    {
        if (pWnd->GetWindowTextLength() > 0)
        {
            DDX_Text(pDX, nID, uValue);
            DDV_MinMaxUInt(pDX, uValue, uMin, uMax);
        }
        else
        {
            uValue = 0;
            if (nEmptyErrorMsg)
            {
                ::AfxMessageBox(nEmptyErrorMsg);
                pDX->Fail();
            }
        }
    }
    else
    {
        if (uValue != 0)
        {
            DDX_Text(pDX, nID, uValue);
        }    
        else
        {
            pWnd->SetWindowText(_T(""));
        }
    }
}



BOOL
IsBindingUnique(
    IN CString & strBinding,
    IN CStringList & strlBindings,
    IN int iCurrent                 OPTIONAL
    )
/*++

Routine Description:

    Helper function to determine if a binding is unique.

Arguments:

    CString & strBinding            : Binding string
    CStringList & strlBindings      : List of bindings
    int iCurrent                    : Index of "current" item.  
                                      Not used for uniqueness checking.

Return Value:

    TRUE if the binding is unique, FALSE otherwise.

--*/
{
    int iItem = 0;
        
    for(POSITION pos = strlBindings.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlBindings.GetNext(pos);
        if (iItem != iCurrent && &str != &strBinding && str == strBinding)
        {
            //
            // Not unique!
            //
            return FALSE;
        }

        ++iItem;
    }

    //
    // Unique
    //
    return TRUE;
}


//
// Multi-multi-multi editing dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMMMEditDlg::CMMMEditDlg(
    IN CString & strServerName,
    IN CStringList & strlBindings,
    IN CStringList & strlOtherBindings,
    IN OUT CString & entry,
    IN BOOL fIPBinding,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName          : Server name
    CStringList & strlBindings       : bindings
    CStringList & strlOtherBindings  : "other" bindings list
    CString & entry                  : Entry being edited
    BOOL fIPBinding                  : TRUE for IP, FALSE for SSL
    CWnd * pParent                   : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CMMMEditDlg::IDD, pParent),
      m_strServerName(strServerName),
      m_strlBindings(strlBindings),
      m_strlOtherBindings(strlOtherBindings),
      m_entry(entry),
      m_fIPBinding(fIPBinding),
      m_nIpAddressSel(-1)
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CMMMEditDlg)
    m_nIpAddressSel = -1;
    //}}AFX_DATA_INIT

#endif // 0

    CInstanceProps::CrackBinding(
        m_entry, 
        m_iaIpAddress, 
        m_nPort, 
        m_strDomainName
        );
}



void 
CMMMEditDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMMMEditDlg)
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strDomainName);
    DDV_MaxChars(pDX, m_strDomainName, MAX_PATH);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Control(pDX, IDC_STATIC_PORT, m_static_Port);
    //}}AFX_DATA_MAP

    DDXV_UINT(pDX, IDC_EDIT_PORT, m_nPort, 1, 65535);

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        pDX->Fail();
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CMMMEditDlg, CDialog)
    //{{AFX_MSG_MAP(CMMMEditDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CMMMEditDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    //
    // Configure dialog for either SSL or IP binding editing
    //
    CString str;
    VERIFY(str.LoadString(m_fIPBinding 
        ? IDS_EDIT_MMM_TITLE
        : IDS_EDIT_SSL_MMM_TITLE));
    SetWindowText(str);

    VERIFY(str.LoadString(m_fIPBinding 
        ? IDS_TCP_PORT
        : IDS_SSL_PORT));
    m_static_Port.SetWindowText(str);

    ActivateControl(*GetDlgItem(IDC_STATIC_HEADER_NAME), m_fIPBinding);
    ActivateControl(*GetDlgItem(IDC_EDIT_DOMAIN_NAME),   m_fIPBinding);

    return TRUE;  
}



void 
CMMMEditDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Verify values are acceptable, and change

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    if (m_nPort == 0)
    {
        ::AfxMessageBox(IDS_NO_PORT);
        return;
    }

    CString strOldBinding(m_entry);
    CInstanceProps::BuildBinding(m_entry, m_iaIpAddress, m_nPort, m_strDomainName);

    //
    // Ensure the ip/address doesn't exist in the "other" binding list
    //
    if (CInstanceProps::IsPortInUse(m_strlOtherBindings, m_iaIpAddress, m_nPort))
    {
        //
        // Restore the old binding
        //
        m_entry = strOldBinding;
        ::AfxMessageBox(m_fIPBinding 
            ? IDS_ERR_PORT_IN_USE_SSL 
            : IDS_ERR_PORT_IN_USE_TCP);
        return; 
    }
    

    if (!IsBindingUnique(m_entry, m_strlBindings))
    {
        //
        // Restore the old binding
        //
        m_entry = strOldBinding;
        ::AfxMessageBox(IDS_ERR_BINDING);
        return; 
    }

    CDialog::OnOK();
}

//
// Multi-multi-multi list dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMMMDlg::CMMMDlg(
    IN LPCTSTR lpServerName,
    IN DWORD   dwInstance,
    IN OUT CStringList & strlBindings,
    IN OUT CStringList & strlSecureBindings,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CStringList & strlBindings          : Service bindings
    CStringList & strlSecureBindings    : SSL port bindings
    CWnd * pParent                      : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CMMMDlg::IDD, pParent),
      m_ListBoxRes(
        IDB_BINDINGS,
        CMMMListBox::nBitmaps
        ),
      m_list_Bindings(g_szRegKeyIP, NUM_COLUMNS(g_aIPColumns), g_aIPColumns),
      m_list_SSLBindings(g_szRegKeySSL, NUM_COLUMNS(g_aSSLColumns), g_aSSLColumns),
      m_strlBindings(),
      m_strlSecureBindings(),
      m_strServerName(lpServerName),
      m_fCertInstalled(IsCertInstalledOnServer(lpServerName, dwInstance)),
      m_fDirty(FALSE)
{
    //{{AFX_DATA_INIT(CMMMDlg)
    //}}AFX_DATA_INIT
    
    m_strlBindings.AddTail(&strlBindings);
    m_strlSecureBindings.AddTail(&strlSecureBindings);
    m_list_Bindings.AttachResources(&m_ListBoxRes);
    m_list_SSLBindings.AttachResources(&m_ListBoxRes);
}


void 
CMMMDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMMMDlg)
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_ADD_SSL, m_button_AddSSL);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_SSL, m_button_RemoveSSL);
    DDX_Control(pDX, IDC_BUTTON_EDIT_SSL, m_button_EditSSL);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_MMM, m_list_Bindings);
    DDX_Control(pDX, IDC_LIST_SSL_MMM, m_list_SSLBindings);
}



BOOL
CMMMDlg::OnItemChanged()
/*++

Routine Description:

    Mark that the dialog as dirty

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    m_fDirty = TRUE;

    return SetControlStates();
}



BOOL
CMMMDlg::SetControlStates()
/*++

Routine Description:

    Set the enabled state of the controls depending on the current
    values in the dialog

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    BOOL fSel = m_list_Bindings.GetSelCount() > 0;

    m_button_Remove.EnableWindow(fSel);
    m_button_Edit.EnableWindow(m_list_Bindings.GetSelCount() == 1);
    m_button_RemoveSSL.EnableWindow(m_list_SSLBindings.GetSelCount() > 0);
    m_button_EditSSL.EnableWindow(m_list_SSLBindings.GetSelCount() == 1);

    m_button_OK.EnableWindow(m_fDirty && m_list_Bindings.GetCount() > 0);

    return fSel;
}



void
CMMMDlg::AddBindings(
    IN CMMMListBox & list, 
    IN CStringList & strlBindings
    )
/*++

Routine Description:

    Add bindings information to the specified listbox

Arguments:

    CMMMListBox & list              : MMM Listbox (SSL or IP)
    CStringList & strlBindings      : SSL or IP bindings

Return Value:

    None

--*/
{
    for (POSITION pos = strlBindings.GetHeadPosition(); pos != NULL; /**/)
    {
        CString & strBinding = strlBindings.GetNext(pos);
        list.AddItem(strBinding);
    }
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CMMMDlg, CDialog)
    //{{AFX_MSG_MAP(CMMMDlg)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_ADD_SSL, OnButtonAddSsl)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_SSL, OnButtonEditSsl)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_SSL, OnButtonRemoveSsl)
    ON_LBN_DBLCLK(IDC_LIST_MMM, OnDblclkListMmm)
    ON_LBN_DBLCLK(IDC_LIST_SSL_MMM, OnDblclkListSslMmm)
    ON_LBN_SELCHANGE(IDC_LIST_MMM, OnSelchangeListMmm)
    ON_LBN_SELCHANGE(IDC_LIST_SSL_MMM, OnSelchangeListSslMmm)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void 
CMMMDlg::OnButtonAdd() 
/*++

Routine Description:

    Add button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Add entry
    //
    CString strEntry;

    CMMMEditDlg dlg(
        m_strServerName, 
        m_strlBindings,
        m_strlSecureBindings,
        strEntry, 
        TRUE, /* IP binding */
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        POSITION pos = m_strlBindings.AddTail(strEntry);
        int nSel = m_list_Bindings.AddItem(m_strlBindings.GetAt(pos));
        m_list_Bindings.SetCurSel(nSel);
        OnItemChanged();
    }
}

void 
CMMMDlg::OnButtonEdit() 
/*++

Routine Description:

    Edit button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Edit entry
    //
    int nCurSel = m_list_Bindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        CString & strEntry = m_list_Bindings.GetItem(nCurSel);
        CMMMEditDlg dlg(
            m_strServerName, 
            m_strlBindings,
            m_strlSecureBindings,
            strEntry, 
            TRUE, /* IP binding */
            this
            );

        if (dlg.DoModal() == IDOK)
        {
            m_list_Bindings.InvalidateSelection(nCurSel);
            OnItemChanged();
        }
    }
}

void 
CMMMDlg::OnButtonRemove() 
/*++

Routine Description:

    Remove button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Bindings.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_Bindings.GetCount())
    {
        //
        // Remove Selected entry
        //
        if (m_list_Bindings.GetSel(nSel))
        {
            m_strlBindings.RemoveAt(m_strlBindings.FindIndex(nSel));
            m_list_Bindings.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_Bindings.SetCurSel(nCurSel);
        if (!OnItemChanged())
        {
            m_button_Add.SetFocus();
        }
    }
/*
    //
    // Remove Selected entry
    //
    int nCurSel = m_list_Bindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        m_strlBindings.RemoveAt(m_strlBindings.FindIndex(nCurSel));
        m_list_Bindings.DeleteString(nCurSel);
        if (nCurSel >= m_list_Bindings.GetCount())
        {
            --nCurSel;
        }
        m_list_Bindings.SetCurSel(nCurSel);

        if (!OnItemChanged())
        {
            m_button_Add.SetFocus();
        }
    }
*/
}


void 
CMMMDlg::OnDblclkListMmm() 
/*++

Routine Description:

    Double click notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}


void 
CMMMDlg::OnSelchangeListMmm() 
/*++

Routine Description:

    selection change notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CMMMDlg::OnButtonAddSsl() 
/*++

Routine Description:

    'Add SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Add entry
    //
    CString strEntry;

    CMMMEditDlg dlg(
        m_strServerName, 
        m_strlSecureBindings,
        m_strlBindings,
        strEntry, 
        FALSE, /* SSL binding */
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        POSITION pos = m_strlSecureBindings.AddTail(strEntry);
        int nSel = m_list_SSLBindings.AddItem(m_strlSecureBindings.GetAt(pos));
        m_list_SSLBindings.SetCurSel(nSel);
        OnItemChanged();
    }
}



void 
CMMMDlg::OnButtonEditSsl() 
/*++

Routine Description:

    'Edit SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Edit entry
    //
    int nCurSel = m_list_SSLBindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        CString & strEntry = m_list_SSLBindings.GetItem(nCurSel);
        CMMMEditDlg dlg(
            m_strServerName, 
            m_strlSecureBindings,
            m_strlBindings,
            strEntry, 
            FALSE, /* SSL binding */
            this
            );

        if (dlg.DoModal() == IDOK)
        {
            m_list_SSLBindings.InvalidateSelection(nCurSel);
            OnItemChanged();
        }
    }
}



void 
CMMMDlg::OnButtonRemoveSsl() 
/*++

Routine Description:

    'Remove SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_SSLBindings.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_SSLBindings.GetCount())
    {
        //
        // Remove Selected entry
        //
        if (m_list_SSLBindings.GetSel(nSel))
        {
            m_strlSecureBindings.RemoveAt(m_strlSecureBindings.FindIndex(nSel));
            m_list_SSLBindings.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_SSLBindings.SetCurSel(nCurSel);
        OnItemChanged();
        if (m_list_SSLBindings.GetSelCount() == 0)
        {
            //
            // Remove will be disabled
            //
            m_button_AddSSL.SetFocus();
        }
    }

/*
    //
    // Remove Selected entry
    //
    int nCurSel = m_list_SSLBindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        m_strlSecureBindings.RemoveAt(m_strlSecureBindings.FindIndex(nCurSel));
        m_list_SSLBindings.DeleteString(nCurSel);
        if (nCurSel >= m_list_SSLBindings.GetCount())
        {
            --nCurSel;
        }
        m_list_SSLBindings.SetCurSel(nCurSel);

        OnItemChanged();
        if (m_list_SSLBindings.GetCurSel() == LB_ERR)
        {
            //
            // Remove will be disabled
            //
            m_button_AddSSL.SetFocus();
        }
    }
*/
}



void 
CMMMDlg::OnDblclkListSslMmm() 
/*++

Routine Description:

    SSL List 'double click' handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEditSsl();
}



void 
CMMMDlg::OnSelchangeListSslMmm() 
/*++

Routine Description:

    SSL List 'selection change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CMMMDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_list_Bindings.Initialize();
    m_list_SSLBindings.Initialize();

    AddBindings(m_list_Bindings, m_strlBindings);
    AddBindings(m_list_SSLBindings, m_strlSecureBindings);

    //
    // No certificates, no SSL
    //
    GetDlgItem(IDC_GROUP_SSL)->EnableWindow(m_fCertInstalled);
    m_list_SSLBindings.EnableWindow(m_fCertInstalled);
    m_button_AddSSL.EnableWindow(m_fCertInstalled);
    m_button_RemoveSSL.EnableWindow(m_fCertInstalled);
    m_button_EditSSL.EnableWindow(m_fCertInstalled);

    SetControlStates();
    
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\perform.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        perform.cpp

   Abstract:

        WWW Performance Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "perform.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// WWW Performance Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3PerfPage, CInetPropertyPage)



/* static */
void
CW3PerfPage::ParseMaxNetworkUse(
    IN  CILong & nMaxNetworkUse,
    OUT CILong & nVisibleMaxNetworkUse,
    OUT BOOL & fLimitNetworkUse
    )
/*++

Routine Description:

    Break out max network use function

Arguments:

    CILong & nMaxNetworkUse        : Maximum network value from metabase
    CILong & nVisibleMaxNetworkUse : Max network use to go in the edit box.
    BOOL & fLimitMaxNetworkUse     : TRUE if max network is not infinite

Return Value

    None

--*/
{
    //
    // Special case: If nMaxNetworkUse is 0(an invalid value), the 
    // value likely could not be inherited from the root (the user
    // is an operator and can't see the properties there).  Adjust
    // the value to a possibly misleading value.
    //
    if (nMaxNetworkUse == 0L)
    {
        TRACEEOLID("Adjusting invalid bandwidth throttling value -- "
                   "are you an operator?");
        nMaxNetworkUse = INFINITE_BANDWIDTH;
    }

    fLimitNetworkUse = (nMaxNetworkUse != INFINITE_BANDWIDTH);
    nVisibleMaxNetworkUse = fLimitNetworkUse
                ? (nMaxNetworkUse / KILOBYTE)
                : (DEF_BANDWIDTH / KILOBYTE);
}



CW3PerfPage::CW3PerfPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor

Arguments:

    CInetPropertySheet * pSheet     : Sheet object

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3PerfPage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

    //
    // Default value
    //

#if 0 // Keep ClassWizard Happy

    //{{AFX_DATA_INIT(CW3PerfPage)
    m_dwCPUPercentage = 0;
    m_fEnableCPUAccounting = FALSE;
    m_fEnforceLimits = TRUE;
    //}}AFX_DATA_INIT

    m_nServerSize = 0L;
    m_nMaxNetworkUse = INFINITE_BANDWIDTH;
    m_nVisibleMaxNetworkUse = DEF_BANDWIDTH;

#endif // 0

}



CW3PerfPage::~CW3PerfPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3PerfPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3PerfPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_CPU_ACCOUNTING, m_fEnableCPUAccounting);
    DDX_Check(pDX, IDC_CHECK_ENFORCE_LIMITS, m_fEnforceLimits);
    DDX_Check(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_fLimitNetworkUse);
    DDX_Control(pDX, IDC_EDIT_MAX_NETWORK_USE, m_edit_MaxNetworkUse);
    DDX_Control(pDX, IDC_EDIT_CPU, m_edit_CPUPercentage);
    DDX_Control(pDX, IDC_CHECK_LOG_EVENT_ONLY, m_check_LogEventOnly);
    DDX_Control(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_check_LimitNetworkUse);
    DDX_Control(pDX, IDC_CHECK_ENABLE_CPU_ACCOUNTING, m_check_EnableCPUAccounting);
    DDX_Control(pDX, IDC_STATIC_MAX_NETWORK_USE, m_static_MaxNetworkUse);
    DDX_Control(pDX, IDC_STATIC_KBS, m_static_KBS);
    DDX_Control(pDX, IDC_STATIC_THROTTLING, m_static_Throttling);
    DDX_Control(pDX, IDC_STATIC_PERCENT, m_static_Percent);
    DDX_Control(pDX, IDC_STATIC_CPU_PROMPT, m_static_CPU_Prompt);
    DDX_Control(pDX, IDC_SLIDER_PERFORMANCE_TUNING, m_sld_PerformanceTuner);
    //}}AFX_DATA_MAP

    if (m_edit_CPUPercentage.IsWindowEnabled() && HasCPUThrottling())
    {
        DDX_Text(pDX, IDC_EDIT_CPU, m_dwCPUPercentage);
        DDV_MinMaxDWord(pDX, m_dwCPUPercentage, 0, 100);
    }

    if (!pDX->m_bSaveAndValidate || m_fLimitNetworkUse)
    {
        DDX_Text(pDX, IDC_EDIT_MAX_NETWORK_USE, m_nVisibleMaxNetworkUse);
        DDV_MinMaxLong(pDX, m_nVisibleMaxNetworkUse, 1, UD_MAXVAL);
    }

    if (pDX->m_bSaveAndValidate)
    {
        m_nServerSize = m_sld_PerformanceTuner.GetPos();
    }
    else
    {
        m_sld_PerformanceTuner.SetRange(MD_SERVER_SIZE_SMALL, MD_SERVER_SIZE_LARGE);
        m_sld_PerformanceTuner.SetPos(m_nServerSize);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3PerfPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3PerfPage)
    ON_WM_HSCROLL()
    ON_WM_VSCROLL()
    ON_BN_CLICKED(IDC_CHECK_ENABLE_CPU_ACCOUNTING, OnCheckEnableCpuAccounting)
    ON_BN_CLICKED(IDC_CHECK_LIMIT_NETWORK_USE, OnCheckLimitNetworkUse)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_MAX_NETWORK_USE, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CPU, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_EVENT_ONLY, OnItemChanged)

END_MESSAGE_MAP()



BOOL
CW3PerfPage::SetControlStates()
/*++

Routine Description:

    Set control states depending on contents of the dialog

Arguments:

    None

Return Value:

    TRUE if the 'limit network use' is on.

--*/
{
    BOOL fLimitOn = m_check_LimitNetworkUse.GetCheck() > 0
        && HasBwThrottling()
        && HasAdminAccess();

    m_static_MaxNetworkUse.EnableWindow(fLimitOn);
    m_edit_MaxNetworkUse.EnableWindow(fLimitOn);
    m_static_KBS.EnableWindow(fLimitOn);
    m_static_Throttling.EnableWindow(fLimitOn);

    BOOL fCPULimitOn = m_fEnableCPUAccounting
        && HasAdminAccess() 
        && HasCPUThrottling();

    m_edit_CPUPercentage.EnableWindow(fCPULimitOn);
    m_check_LogEventOnly.EnableWindow(fCPULimitOn);
    m_static_Percent.EnableWindow(fCPULimitOn);
    m_static_CPU_Prompt.EnableWindow(fCPULimitOn);

    return fLimitOn;
}



/* virtual */
HRESULT
CW3PerfPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_nServerSize);
        FETCH_INST_DATA_FROM_SHEET(m_nMaxNetworkUse);
        FETCH_INST_DATA_FROM_SHEET(m_fEnableCPUAccounting);
        FETCH_INST_DATA_FROM_SHEET(m_dwCPULimitLogEventRaw);
        FETCH_INST_DATA_FROM_SHEET(m_dwCPULimitPriorityRaw);
        FETCH_INST_DATA_FROM_SHEET(m_dwCPULimitPauseRaw);
        FETCH_INST_DATA_FROM_SHEET(m_dwCPULimitProcStopRaw);

        ParseMaxNetworkUse(
            m_nMaxNetworkUse, 
            m_nVisibleMaxNetworkUse, 
            m_fLimitNetworkUse
            );

        if (m_dwCPULimitLogEventRaw == INFINITE_CPU_RAW)
        {
            //
            // Set default value
            //
            m_dwCPUPercentage = DEFAULT_CPU_PERCENTAGE;
        }
        else
        {
            m_dwCPUPercentage = m_dwCPULimitLogEventRaw / CPU_THROTTLING_FACTOR;
        }

        m_fEnforceLimits = m_dwCPULimitPriorityRaw != 0L
            || m_dwCPULimitPauseRaw != 0L
            || m_dwCPULimitProcStopRaw != 0L;
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3PerfPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 performance page now...");

    CError err;

    BuildMaxNetworkUse(
        m_nMaxNetworkUse, 
        m_nVisibleMaxNetworkUse, 
        m_fLimitNetworkUse
        );

    m_dwCPULimitLogEventRaw = m_fEnableCPUAccounting
        ? m_dwCPUPercentage * CPU_THROTTLING_FACTOR
        : INFINITE_CPU_RAW;

    if (m_fEnforceLimits)
    {
        m_dwCPULimitPauseRaw    = 0L;
        m_dwCPULimitPriorityRaw = m_dwCPULimitLogEventRaw * 3L / 2L;
        m_dwCPULimitProcStopRaw = m_dwCPULimitLogEventRaw * 2L;
    }
    else
    {   
        m_dwCPULimitPriorityRaw = m_dwCPULimitPauseRaw
            = m_dwCPULimitProcStopRaw = 0L;
    }

    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        STORE_INST_DATA_ON_SHEET(m_nServerSize);
        STORE_INST_DATA_ON_SHEET(m_nMaxNetworkUse);
        STORE_INST_DATA_ON_SHEET(m_fEnableCPUAccounting);
        STORE_INST_DATA_ON_SHEET(m_dwCPULimitLogEventRaw);
        STORE_INST_DATA_ON_SHEET(m_dwCPULimitPriorityRaw);
        STORE_INST_DATA_ON_SHEET(m_dwCPULimitPauseRaw);
        STORE_INST_DATA_ON_SHEET(m_dwCPULimitProcStopRaw);
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CW3PerfPage::OnSetActive() 
/*++

Routine Description:

    Handle page activation

Arguments:

    None

Return Value:

    TRUE if the page activation was successful,
    FALSE otherwise.

--*/
{
    return CInetPropertyPage::OnSetActive();
}



void
CW3PerfPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}


void
CW3PerfPage::OnCheckLimitNetworkUse()
/*++

Routine Description:

    The "limit network use" checkbox has been clicked
    Enable/disable the "max network use" controls.

Arguments:

    None

Return Value:

    None

--*/
{
    if (SetControlStates())
    {
        m_edit_MaxNetworkUse.SetSel(0, -1);
        m_edit_MaxNetworkUse.SetFocus();
    }

    OnItemChanged();
}



void 
CW3PerfPage::OnCheckEnableCpuAccounting() 
/*++

Routine Description:

    'Enable CPU Accounting' checkbox hander.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableCPUAccounting = !m_fEnableCPUAccounting;
    OnItemChanged();

    if (m_fEnableCPUAccounting)
    {
        m_edit_CPUPercentage.SetSel(0, -1);
        m_edit_CPUPercentage.SetFocus();
    }
}



BOOL
CW3PerfPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Disable some settings based on what's possible
    //
    m_check_LimitNetworkUse.EnableWindow(
        !IsMasterInstance()
     && HasBwThrottling()
     && HasAdminAccess()
        );

    m_check_EnableCPUAccounting.EnableWindow(
        HasCPUThrottling()
     && HasAdminAccess()
        );

    SetControlStates();

    return TRUE;
}



void
CW3PerfPage::OnHScroll(
    IN UINT nSBCode, 
    IN UINT nPos, 
    IN CScrollBar * pScrollBar
    ) 
/*++

Routine Description:

    Respond to horizontal scroll message

Arguments
    UINT nSBCode    Specifies a scroll-bar code that indicates the users 
                    scrolling request.
    UINT nPos       Specifies the scroll-box position if the scroll-bar code 
                    is SB_THUMBPOSITION or SB_THUMBTRACK; otherwise, not used. 
                    Depending on the initial scroll range, nPos may be negative 
                    and should be cast to an int if necessary.
    pScrollBar      If the scroll message came from a scroll-bar control, 
                    contains a pointer to the control. If the user clicked a 
                    windows scroll bar, this parameter is NULL. The pointer 
                    may be temporary and should not be stored for later use.

Return Value:

    None

--*/
{
    //
    // Track slider notifications
    //
    CInetPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
    OnItemChanged();
}



void 
CW3PerfPage::OnVScroll(
    IN UINT nSBCode, 
    IN UINT nPos, 
    IN CScrollBar * pScrollBar
    ) 
/*++

Routine Description:

    Respond to vertical scroll message

Arguments
    UINT nSBCode    Specifies a scroll-bar code that indicates the users 
                    scrolling request.
    UINT nPos       Specifies the scroll-box position if the scroll-bar code 
                    is SB_THUMBPOSITION or SB_THUMBTRACK; otherwise, not used. 
                    Depending on the initial scroll range, nPos may be negative 
                    and should be cast to an int if necessary.
    pScrollBar      If the scroll message came from a scroll-bar control, 
                    contains a pointer to the control. If the user clicked a 
                    windows scroll bar, this parameter is NULL. The pointer 
                    may be temporary and should not be stored for later use.

Return Value:

    None

--*/
{
    //
    // Track slider notifications
    //
    CInetPropertyPage::OnVScroll(nSBCode, nPos, pScrollBar);
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\mmmdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mmmdlg.h

   Abstract:

        Multi-multi-multi dialog editor definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __MMMDLG_H__
#define __MMMDLG_H__

//
// UINT DDX/DDV helper function that uses a blank string to denote 0
//
void AFXAPI DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg = 0
    );

//
// Helper function to check to see if binding is unique
//
BOOL
IsBindingUnique(
    IN CString & strBinding,
    IN CStringList & strlBindings,
    IN int iCurrent = -1
    );

/*
//
// Helper function to build and verify binding strings.
//
BOOL
VerifyBindingInfo(
    OUT CString & strBinding,
    OUT CString & strSecureBinding,
    IN  CStringList & strlBindings,
    IN  CStringList & strlSecureBindings,
    IN  int iBindings,
    IN  int iSSLBindings,
    IN  CIPAddress & iaIpAddress,
    IN  UINT nTCPPort,
    IN  UINT nSSLPort,
    IN  CString & strDomainName
    );
*/


class CMMMListBox : public CHeaderListBox
{
/*++

Class Description:

    Multi-multi-multi listbox.

Public Interface:

    CMMMListBox    : Constructor

    GetItem        : Get item at specified position
                     in the listbox
    AddItem        : Add new item to the listbox
    Initialize     : Initialize the listbox

--*/
    DECLARE_DYNAMIC(CMMMListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;

public:
    CMMMListBox(
        IN LPCTSTR lpszRegKey,
        IN int cColumns,
        IN const ODL_COLUMN_DEF * pColumns
        );

public:
    CString & GetItem(UINT nIndex);
    int AddItem(CString & item);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & ds);

protected:
    int m_cColumns;
    const ODL_COLUMN_DEF * m_pColumns;
    CString m_strDefaultIP;
    CString m_strNoPort;
};



class CMMMEditDlg : public CDialog
/*++

Class Description:

    Multi-Multi-Multi edit entry dialog

Public Interface:

    CMMMEditDlg     : Constructor

--*/
{
//
// Construction
//
public:
    CMMMEditDlg(
        IN CString & strServerName,
        IN OUT CStringList & strlBindings,
        IN CStringList & strlOtherBindings,
        IN OUT CString & strEntry,
        IN BOOL fIPBinding = TRUE,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CMMMEditDlg)
    enum { IDD = IDD_DIALOG_EDIT_MMM };
    int         m_nIpAddressSel;
    UINT        m_nPort;
    CString     m_strDomainName;
    CStatic     m_static_Port;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    CIPAddress m_iaIpAddress;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMMEditDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMMMEditDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fIPBinding;
    CString & m_strServerName;
    CString & m_entry;
    CObListPlus m_oblIpAddresses;
    CStringList & m_strlBindings;
    CStringList & m_strlOtherBindings;
};



class CMMMDlg : public CDialog
/*++

Class Description:

    Mutlti-multi-multi dialog

Public Interface:

    CMMMDlg     : Constructor

--*/
{
//
// Construction
//
public:
    CMMMDlg(
        IN LPCTSTR lpServerName,
        IN DWORD   dwInstance,
        IN CStringList & strlBindings,
        IN CStringList & strlSecureBindings,
        IN CWnd * pParent = NULL
        );

//
// Access
//
public:
    CStringList & GetBindings() { return m_strlBindings; }
    CStringList & GetSecureBindings() { return m_strlSecureBindings; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CMMMDlg)
    enum { IDD = IDD_DIALOG_MMM };
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    CButton m_button_AddSSL;
    CButton m_button_RemoveSSL;
    CButton m_button_EditSSL;
    CButton m_button_OK;
    //}}AFX_DATA

    CMMMListBox m_list_Bindings;
    CMMMListBox m_list_SSLBindings;

    CStringList m_strlBindings;
    CStringList m_strlSecureBindings;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMMDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMMMDlg)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonAddSsl();
    afx_msg void OnButtonEditSsl();
    afx_msg void OnButtonRemoveSsl();
    afx_msg void OnDblclkListMmm();
    afx_msg void OnDblclkListSslMmm();
    afx_msg void OnSelchangeListMmm();
    afx_msg void OnSelchangeListSslMmm();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL OnItemChanged();
    BOOL SetControlStates();
    void AddBindings(CMMMListBox & list, CStringList & strl);

private:
    BOOL m_fDirty;
    BOOL m_fCertInstalled;
    CString m_strServerName;
    CRMCListBoxResources m_ListBoxRes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CString & CMMMListBox::GetItem(UINT nIndex)
{
    return *(CString *)GetItemDataPtr(nIndex);
}

inline int CMMMListBox::AddItem(CString & item)
{
    return AddString((LPCTSTR)&item);
}

#endif // __MMMDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\ipdomdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipdomdlg.h

   Abstract:

        IP and domain security restrictions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPDOMDLG_H_
#define _IPDOMDLG_H_



class CIPDomainDlg : public CEmphasizedDialog
/*++

Class Description:

    IP address and domain name restrictions dialog

Public Interface:

    CIPDomainDlg        : Constructor
    GetAccessList       : Get the list of granted/denied objects

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CIPDomainDlg(
        IN OUT BOOL & fIpDirty,
        IN OUT BOOL & fDefaultGranted,
        IN OUT BOOL & fOldDefaultGranted,
        IN CObListPlus & oblAccessList,
        IN CWnd * pParent = NULL
        );

//
// Access
//
public:
    CObListPlus & GetAccessList() { return m_oblAccessList; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIPDomainDlg)
    enum { IDD = IDD_IP_SECURITY };
    int     m_nGrantedDenied;
    CStatic m_icon_Granted;
    CStatic m_icon_Denied;
    CButton m_radio_Granted;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    CButton m_radio_Denied;
    CIPAccessDescriptorListBox m_list_IpAddresses;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIPDomainDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CIPDomainDlg)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListIpAddresses();
    afx_msg void OnErrspaceListIpAddresses();
    afx_msg void OnRadioGranted();
    afx_msg void OnRadioDenied();
    afx_msg void OnSelchangeListIpAddresses();
    afx_msg int  OnVKeyToItem(UINT nKey, CListBox * pListBox, UINT nIndex);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    void    FillListBox(CIPAccessDescriptor * pSelection = NULL);
    BOOL    SetControlStates();
    DWORD   SortAccessList();

private:
    BOOL & m_fDefaultGranted;
    BOOL & m_fOldDefaultGranted;
    BOOL & m_fIpDirty;
    CObListPlus m_oblAccessList;
    CRMCListBoxResources m_ListBoxRes;
};

#endif // _IPDOMDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\perform.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        perform.h

   Abstract:

        WWW Performance Property Page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __PERFORM_H__
#define __PERFORM_H__



class CW3PerfPage : public CInetPropertyPage
/*++

Class Description:

    WWW Performance tab

Public Interface:

    CW3PerfPage         : Constructor

--*/
{
    DECLARE_DYNCREATE(CW3PerfPage)

//
// Construction
//
public:
    CW3PerfPage(CInetPropertySheet * pSheet = NULL);
    ~CW3PerfPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3PerfPage)
    enum { IDD = IDD_PERFORMANCE };
    BOOL        m_fEnableCPUAccounting;
    BOOL        m_fEnforceLimits;
    BOOL        m_fLimitNetworkUse;
    DWORD       m_dwCPUPercentage;
    CEdit       m_edit_MaxNetworkUse;
    CEdit       m_edit_CPUPercentage;
    CButton     m_check_LogEventOnly;
    CButton     m_check_LimitNetworkUse;
    CButton     m_check_EnableCPUAccounting;
    CStatic     m_static_MaxNetworkUse;
    CStatic     m_static_KBS;
    CStatic     m_static_Throttling;
    CStatic     m_static_Percent;
    CStatic     m_static_CPU_Prompt;
    CSliderCtrl m_sld_PerformanceTuner;
    //}}AFX_DATA

    int         m_nServerSize;
    DWORD       m_dwCPULimitLogEventRaw;
    DWORD       m_dwCPULimitPriorityRaw;
    DWORD       m_dwCPULimitPauseRaw;
    DWORD       m_dwCPULimitProcStopRaw;
    CILong      m_nMaxNetworkUse;
    CILong      m_nVisibleMaxNetworkUse;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3PerfPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

protected:
    static void ParseMaxNetworkUse(
        IN  CILong & nMaxNetworkUse,
        OUT CILong & nVisibleMaxNetworkUse,
        OUT BOOL & fLimitNetworkUse
        );

    static void
    BuildMaxNetworkUse(
        OUT CILong & nMaxNetworkUse,
        IN  CILong & nVisibleMaxNetworkUse,
        IN  IN BOOL & fLimitNetworkUse
        );

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3PerfPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckEnableCpuAccounting();
    afx_msg void OnCheckLimitNetworkUse();
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar * pScrollBar);
    afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar * pScrollBar);
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


inline /* static */ void CW3PerfPage::BuildMaxNetworkUse(
    OUT CILong & nMaxNetworkUse,
    IN  CILong & nVisibleMaxNetworkUse,
    IN  IN BOOL & fLimitNetworkUse
    )
{
    nMaxNetworkUse = fLimitNetworkUse
        ? nVisibleMaxNetworkUse * KILOBYTE
        : INFINITE_BANDWIDTH;
}

#endif // __PERFORM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\msacal70.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "msacal70.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CMsacal70

IMPLEMENT_DYNCREATE(CMsacal70, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMsacal70 properties

OLE_COLOR CMsacal70::GetBackColor()
{
    OLE_COLOR result;
    GetProperty(DISPID_BACKCOLOR, VT_I4, (void*)&result);
    return result;
}

void CMsacal70::SetBackColor(OLE_COLOR propVal)
{
    SetProperty(DISPID_BACKCOLOR, VT_I4, propVal);
}

short CMsacal70::GetDay()
{
    short result;
    GetProperty(0x11, VT_I2, (void*)&result);
    return result;
}

void CMsacal70::SetDay(short propVal)
{
    SetProperty(0x11, VT_I2, propVal);
}

COleFont CMsacal70::GetDayFont()
{
    LPDISPATCH pDispatch;
    GetProperty(0x1, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CMsacal70::SetDayFont(LPDISPATCH propVal)
{
    SetProperty(0x1, VT_DISPATCH, propVal);
}

unsigned long CMsacal70::GetDayFontColor()
{
    unsigned long result;
    GetProperty(0x2, VT_I4, (void*)&result);
    return result;
}

void CMsacal70::SetDayFontColor(unsigned long propVal)
{
    SetProperty(0x2, VT_I4, propVal);
}

short CMsacal70::GetDayLength()
{
    short result;
    GetProperty(0x12, VT_I2, (void*)&result);
    return result;
}

void CMsacal70::SetDayLength(short propVal)
{
    SetProperty(0x12, VT_I2, propVal);
}

short CMsacal70::GetFirstDay()
{
    short result;
    GetProperty(0x13, VT_I2, (void*)&result);
    return result;
}

void CMsacal70::SetFirstDay(short propVal)
{
    SetProperty(0x13, VT_I2, propVal);
}

long CMsacal70::GetGridCellEffect()
{
    long result;
    GetProperty(0x14, VT_I4, (void*)&result);
    return result;
}

void CMsacal70::SetGridCellEffect(long propVal)
{
    SetProperty(0x14, VT_I4, propVal);
}

COleFont CMsacal70::GetGridFont()
{
    LPDISPATCH pDispatch;
    GetProperty(0x3, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CMsacal70::SetGridFont(LPDISPATCH propVal)
{
    SetProperty(0x3, VT_DISPATCH, propVal);
}

unsigned long CMsacal70::GetGridFontColor()
{
    unsigned long result;
    GetProperty(0x4, VT_I4, (void*)&result);
    return result;
}

void CMsacal70::SetGridFontColor(unsigned long propVal)
{
    SetProperty(0x4, VT_I4, propVal);
}

unsigned long CMsacal70::GetGridLinesColor()
{
    unsigned long result;
    GetProperty(0xd, VT_I4, (void*)&result);
    return result;
}

void CMsacal70::SetGridLinesColor(unsigned long propVal)
{
    SetProperty(0xd, VT_I4, propVal);
}

short CMsacal70::GetMonth()
{
    short result;
    GetProperty(0x10, VT_I2, (void*)&result);
    return result;
}

void CMsacal70::SetMonth(short propVal)
{
    SetProperty(0x10, VT_I2, propVal);
}

short CMsacal70::GetMonthLength()
{
    short result;
    GetProperty(0x15, VT_I2, (void*)&result);
    return result;
}

void CMsacal70::SetMonthLength(short propVal)
{
    SetProperty(0x15, VT_I2, propVal);
}

BOOL CMsacal70::GetShowDateSelectors()
{
    BOOL result;
    GetProperty(0x5, VT_BOOL, (void*)&result);
    return result;
}

void CMsacal70::SetShowDateSelectors(BOOL propVal)
{
    SetProperty(0x5, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowDays()
{
    BOOL result;
    GetProperty(0x6, VT_BOOL, (void*)&result);
    return result;
}

void CMsacal70::SetShowDays(BOOL propVal)
{
    SetProperty(0x6, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowHorizontalGrid()
{
    BOOL result;
    GetProperty(0x7, VT_BOOL, (void*)&result);
    return result;
}

void CMsacal70::SetShowHorizontalGrid(BOOL propVal)
{
    SetProperty(0x7, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowTitle()
{
    BOOL result;
    GetProperty(0x8, VT_BOOL, (void*)&result);
    return result;
}

void CMsacal70::SetShowTitle(BOOL propVal)
{
    SetProperty(0x8, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowVerticalGrid()
{
    BOOL result;
    GetProperty(0x9, VT_BOOL, (void*)&result);
    return result;
}

void CMsacal70::SetShowVerticalGrid(BOOL propVal)
{
    SetProperty(0x9, VT_BOOL, propVal);
}

COleFont CMsacal70::GetTitleFont()
{
    LPDISPATCH pDispatch;
    GetProperty(0xa, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CMsacal70::SetTitleFont(LPDISPATCH propVal)
{
    SetProperty(0xa, VT_DISPATCH, propVal);
}

unsigned long CMsacal70::GetTitleFontColor()
{
    unsigned long result;
    GetProperty(0xb, VT_I4, (void*)&result);
    return result;
}

void CMsacal70::SetTitleFontColor(unsigned long propVal)
{
    SetProperty(0xb, VT_I4, propVal);
}

VARIANT CMsacal70::GetValue()
{
    VARIANT result;
    GetProperty(0xc, VT_VARIANT, (void*)&result);
    return result;
}

void CMsacal70::SetValue(const VARIANT& propVal)
{
    SetProperty(0xc, VT_VARIANT, &propVal);
}

VARIANT CMsacal70::Get_Value()
{
    VARIANT result;
    GetProperty(0x0, VT_VARIANT, (void*)&result);
    return result;
}

void CMsacal70::Set_Value(const VARIANT& propVal)
{
    SetProperty(0x0, VT_VARIANT, &propVal);
}

BOOL CMsacal70::GetValueIsNull()
{
    BOOL result;
    GetProperty(0xe, VT_BOOL, (void*)&result);
    return result;
}

void CMsacal70::SetValueIsNull(BOOL propVal)
{
    SetProperty(0xe, VT_BOOL, propVal);
}

short CMsacal70::GetYear()
{
    short result;
    GetProperty(0xf, VT_I2, (void*)&result);
    return result;
}

void CMsacal70::SetYear(short propVal)
{
    SetProperty(0xf, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CMsacal70 operations

void CMsacal70::NextDay()
{
    InvokeHelper(0x16, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::NextMonth()
{
    InvokeHelper(0x17, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::NextWeek()
{
    InvokeHelper(0x18, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::NextYear()
{
    InvokeHelper(0x19, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousDay()
{
    InvokeHelper(0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousMonth()
{
    InvokeHelper(0x1b, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousWeek()
{
    InvokeHelper(0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousYear()
{
    InvokeHelper(0x1d, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::Refresh()
{
    InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::Today()
{
    InvokeHelper(0x1e, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::AboutBox()
{
    InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\rat.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "rat.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CRat

IMPLEMENT_DYNCREATE(CRat, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CRat properties

short CRat::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CRat::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

BOOL CRat::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CRat::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

COleFont CRat::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CRat::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

CString CRat::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CRat::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CRat operations

void CRat::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CRat::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\seccom.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SECCOM_H__
#define __SECCOM_H__


//{{AFX_INCLUDES()
#include "certmap.h"
#include "certauth.h"
#include "certwiz.h"
//}}AFX_INCLUDES



class CSecCommDlg : public CDialog
/*++

Class Description:

    Authantication dialog

Public Interface:

    CSecCommDlg  : Constructor

--*/
{
//
// Construction
//
public:
    CSecCommDlg(
        IN LPCTSTR lpstrServerName,         // For API name only
        IN LPCTSTR lpstrMetaPath,           // For use in ocx only
        IN CString & strBasicDomain,
        IN DWORD & dwAuthFlags,
        IN DWORD & dwAccessPermissions,
        IN BOOL    fIsMasterInstance,
        IN BOOL    fSSLSupported,
        IN BOOL    fSSL128Supported,
        IN BOOL    fU2Installed,
        IN CString & strCTLIdentifier,
        IN CString & strCTLStoreName,
        IN BOOL    fEditCTLs,
        IN BOOL    fIsLocal,
        IN CWnd *  pParent = NULL            OPTIONAL
        );

    ~CSecCommDlg();

//
// Dialog Data
//
public:
    CString m_strCTLIdentifier;
    CString m_strCTLStoreName;
    BOOL    m_bCTLDirty;

protected:
    //
    // Radio button values
    //
    enum
    {
        RADIO_NO_CERT,
        RADIO_ACCEPT_CERT,
        RADIO_REQ_CERT,
    };

    //{{AFX_DATA(CSecCommDlg)
    enum { IDD = IDD_SECURE_COMMUNICATIONS };
    int         m_nRadioNoCert;
    BOOL        m_fAccountMapping;
    BOOL        m_fRequireSSL;
    BOOL        m_fRequire128BitSSL;
    BOOL        m_fEnableCtl;
    CString     m_strCtl;
    CStatic     m_static_CTLPrompt;
    CStatic     m_static_CTLSeparator;
    CButton     m_check_AccountMapping;
    CButton     m_check_RequireSSL;
    CButton     m_check_Require128BitSSL;
    CButton     m_check_EnableDS;
    CButton     m_check_EnableCtl;
    CButton     m_button_EditCtl;
    CButton     m_button_NewCtl;
    CCertmap    m_ocx_ClientMappings;
    CComboBox   m_combo_ctl;
    //}}AFX_DATA

    CButton     m_radio_RequireCert;
    CButton     m_radio_AcceptCert;
    CCertWiz    m_ocx_CertificateAuthorities;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CSecCommDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CSecCommDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnCheckSslAccountMapping();
    afx_msg void OnCheckRequireSsl();
    afx_msg void OnRadioAcceptCert();
    afx_msg void OnRadioNoCert();
    afx_msg void OnRadioRequireCert();
    afx_msg void OnButtonEditCtl();
    afx_msg void OnCheckEnableCtl();
    afx_msg void OnButtonNewCtl();
    afx_msg void OnSelchangeComboCtl();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL AddCTLToList(PCCTL_CONTEXT pCTL, BOOL fSelect);
    PCCTL_CONTEXT CallCTLWizard(PCCTL_CONTEXT pCTLSrc);

    void InitializeCTLList();
    void CleanUpCTLList();

    HCERTSTORE  m_hCTLStore;

    INT m_iLastUsedCert;
    DWORD & m_dwAuthFlags;
    DWORD & m_dwAccessPermissions;
    DWORD m_dwInstance;
    BOOL m_fEditCTLs;
    BOOL m_fSSLEnabledOnServer;
    BOOL m_fSSLInstalledOnServer;
    BOOL m_fSSL128Supported;
    BOOL m_fU2Installed;
    BOOL m_fIsLocal;
    BOOL m_fIsMasterInstance;
    CString m_strServerName;
    CString m_strMetaPath;
};


#endif // __SECCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\seccom.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

#include "w3scfg.h"
#include "wincrypt.h"
#include "cryptui.h"
#include "certmap.h"
#include "basdom.h"
#include "anondlg.h"
#include "seccom.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const   LPCTSTR     SZ_CTL_DEFAULT_STORE_NAME = _T("CA");
const   LPCSTR      szOID_IIS_VIRTUAL_SERVER =  "1.3.6.1.4.1.311.30.1";



//
// Needed for GetModuleFileName() below:
//
extern HINSTANCE hInstance;


   
CSecCommDlg::CSecCommDlg(
    IN LPCTSTR lpstrServerName, 
    IN LPCTSTR lpstrMetaPath,
    IN CString & strBasicDomain,
    IN DWORD & dwAuthFlags,
    IN DWORD & dwAccessPermissions,
    IN BOOL    fIsMasterInstance,
    IN BOOL    fSSLSupported,
    IN BOOL    fSSL128Supported,
    IN BOOL    fU2Installed,
    IN CString & strCTLIdentifier,
    IN CString & strCTLStoreName,
    IN BOOL    fEditCTLs,
    IN BOOL    fIsLocal,
    IN CWnd *  pParent                       OPTIONAL
    )
/*++

Routine Description:

    Authentication dialog constructor

Arguments:

    LPCTSTR lpstrServerName             : Server name
    LPCTSTR lpstrMetaPath               : Metabase path
    CString & strBasicDomain            : Basic domain name
    DWORD & dwAuthFlags                 : Authorization flags
    DWORD & dwAccessPermissions         : Access permissions
    BOOL    fIsMasterInstance           : Master instance
    BOOL    fSSLSupported               : TRUE if SSL is supported
    BOOL    fSSL128Supported            : TRUE if 128 bit SSL is supported
    CString & strCTLIdentifier
    CString & strCTLStoreName
    BOOL    fEditCTLs
    BOOL    fIsLocal
    CWnd *  pParent                     : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CSecCommDlg::IDD, pParent),
      m_strServerName(lpstrServerName),
      m_strMetaPath(lpstrMetaPath),
      m_dwAuthFlags(dwAuthFlags),
      m_dwAccessPermissions(dwAccessPermissions),
      m_fIsMasterInstance(fIsMasterInstance),
      m_fSSLEnabledOnServer(FALSE),
      m_fSSLInstalledOnServer(FALSE),
      m_fSSL128Supported(fSSL128Supported),
      m_fU2Installed(fU2Installed),
      m_hCTLStore(NULL),
      m_bCTLDirty(FALSE),
      m_iLastUsedCert(-1),
      m_fIsLocal(fIsLocal),
      m_fEditCTLs(fEditCTLs)
{
#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CSecCommDlg)
    m_nRadioNoCert = -1;
    m_fAccountMapping = FALSE;
    //m_fEnableDS = FALSE;
    m_fRequireSSL = FALSE;
    m_fEnableCtl = FALSE;
    m_strCtl = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    if (fSSLSupported)
    {
        ::IsSSLEnabledOnServer(
            m_strServerName, 
            m_fSSLInstalledOnServer, 
            m_fSSLEnabledOnServer
            );
    }
    else
    {
        m_fSSLInstalledOnServer = m_fSSLEnabledOnServer = FALSE;
    }

    if (IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_REQUIRE_CERT))
    {
        m_nRadioNoCert = RADIO_REQ_CERT;
    }
    else if (IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_NEGO_CERT))
    {
        m_nRadioNoCert = RADIO_ACCEPT_CERT;
    }
    else
    {
        m_nRadioNoCert = RADIO_NO_CERT;
    }

    m_fRequireSSL = m_fSSLInstalledOnServer
         && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL);

    m_fRequire128BitSSL = m_fSSLInstalledOnServer
        && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL128);

    m_fAccountMapping = m_fSSLInstalledOnServer
        && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_MAP_CERT);

    //
    // CTL information.
    //
    if (fEditCTLs)
    {
        m_strCTLIdentifier = strCTLIdentifier;
        m_strCTLStoreName = strCTLStoreName;

        if (m_strCTLStoreName.IsEmpty())
        {
            m_strCTLStoreName = SZ_CTL_DEFAULT_STORE_NAME;
        }

        m_strCtl.Empty();
        m_fEnableCtl = !m_strCTLIdentifier.IsEmpty()
            && !strCTLStoreName.IsEmpty();

        //
        // For now, we only allow enabling when editing the local machine
        //
        m_fEnableCtl &= m_fIsLocal;
    }
    else
    {
        m_fEnableCtl = FALSE;
        m_check_EnableCtl.EnableWindow(FALSE);
    }
}



CSecCommDlg::~CSecCommDlg()
/*++

Routine Description:

    custom destructor for CSecCommDlg

Arguments:

    None
Return Value:

    None

--*/
{
    // dereference the CTL context pointers in the combo box
    //CleanUpCTLList();
}



void 
CSecCommDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecCommDlg)
    
    DDX_Radio(pDX, IDC_RADIO_NO_CERT, m_nRadioNoCert);
    DDX_Check(pDX, IDC_CHECK_SSL_ACCOUNT_MAPPING, m_fAccountMapping);
    DDX_Check(pDX, IDC_CHECK_REQUIRE_SSL, m_fRequireSSL);
    DDX_Check(pDX, IDC_CHECK_REQUIRE_128BIT, m_fRequire128BitSSL);
    DDX_Check(pDX, IDC_CHECK_ENABLE_CTL, m_fEnableCtl);
    DDX_CBString(pDX, IDC_COMBO_CTL, m_strCtl);
    DDX_Control(pDX, IDC_CTL_SEPERATOR, m_static_CTLSeparator);
    DDX_Control(pDX, IDC_STATIC_CURRENT_CTL, m_static_CTLPrompt);
    DDX_Control(pDX, IDC_CHECK_SSL_ACCOUNT_MAPPING, m_check_AccountMapping);
    DDX_Control(pDX, IDC_CHECK_REQUIRE_SSL, m_check_RequireSSL);
    DDX_Control(pDX, IDC_CHECK_REQUIRE_128BIT, m_check_Require128BitSSL);
    DDX_Control(pDX, IDC_CHECK_ENABLE_CTL, m_check_EnableCtl);
    DDX_Control(pDX, IDC_BUTTON_EDIT_CTL, m_button_EditCtl);
    DDX_Control(pDX, IDC_BUTTON_NEW_CTL, m_button_NewCtl);
    DDX_Control(pDX, IDC_CERTMAPCTRL1, m_ocx_ClientMappings);
    DDX_Control(pDX, IDC_COMBO_CTL, m_combo_ctl);
    //}}AFX_DATA_MAP

    //
    // Private DDX Controls
    //
    DDX_Control(pDX, IDC_RADIO_REQUIRE_CERT, m_radio_RequireCert);
    DDX_Control(pDX, IDC_RADIO_ACCEPT_CERT, m_radio_AcceptCert);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CSecCommDlg, CDialog)
    //{{AFX_MSG_MAP(CSecCommDlg)
    ON_BN_CLICKED(IDC_CHECK_SSL_ACCOUNT_MAPPING, OnCheckSslAccountMapping)
    ON_BN_CLICKED(IDC_CHECK_REQUIRE_SSL, OnCheckRequireSsl)
    ON_BN_CLICKED(IDC_RADIO_ACCEPT_CERT, OnRadioAcceptCert)
    ON_BN_CLICKED(IDC_RADIO_NO_CERT, OnRadioNoCert)
    ON_BN_CLICKED(IDC_RADIO_REQUIRE_CERT, OnRadioRequireCert)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_CTL, OnButtonEditCtl)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_CTL, OnCheckEnableCtl)
    ON_BN_CLICKED(IDC_BUTTON_NEW_CTL, OnButtonNewCtl)
    ON_CBN_SELCHANGE(IDC_COMBO_CTL, OnSelchangeComboCtl)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CSecCommDlg::SetControlStates()
/*++

Routine Description:

    Set control states depending on current data in the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_check_RequireSSL.EnableWindow(m_fSSLEnabledOnServer);
    m_check_Require128BitSSL.EnableWindow(
        m_fSSLEnabledOnServer 
     && m_fSSL128Supported 
     && m_fRequireSSL
        );

    m_ocx_ClientMappings.EnableWindow(
        m_fAccountMapping 
     && !m_fU2Installed
     && !m_fIsMasterInstance
        );

    m_radio_RequireCert.EnableWindow(m_fRequireSSL);

    //
    // Special case: if "require SSL" is off, but "require 
    // client certificates" is on, change the latter to "accept 
    // client certificates"
    //
    if (m_radio_RequireCert.GetCheck() > 0 && !m_fRequireSSL)
    {
        m_radio_RequireCert.SetCheck(0);
        m_radio_AcceptCert.SetCheck(1);
        m_nRadioNoCert = RADIO_ACCEPT_CERT;
    }

    if (m_fEditCTLs)
    {
        m_static_CTLPrompt.EnableWindow(m_fEnableCtl);
        m_combo_ctl.EnableWindow(m_fEnableCtl);
        m_button_EditCtl.EnableWindow(m_fEnableCtl);
        m_button_NewCtl.EnableWindow(m_fEnableCtl);
        m_ocx_CertificateAuthorities.EnableWindow(m_fEnableCtl);

        //
        // If enable Ctl is on, but nothing is selected, disable Edit
        //
        if (m_fEnableCtl)
        {
            if (m_combo_ctl.GetCurSel() == CB_ERR)
            {
                m_button_EditCtl.EnableWindow(FALSE);
            }
        }
    }
    else
    {
        m_fEnableCtl = FALSE;

        //
        // Hide the controls
        //
        DeActivateControl(m_static_CTLPrompt);
        DeActivateControl(m_combo_ctl);
        DeActivateControl(m_button_EditCtl);
        DeActivateControl(m_button_NewCtl);
        DeActivateControl(m_ocx_CertificateAuthorities);
        DeActivateControl(m_check_EnableCtl);
        DeActivateControl(m_static_CTLSeparator);
    }

}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CSecCommDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Initialize certificate authorities ocx
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_CertificateAuthorities.Create(
        _T("CertWiz"),
        WS_BORDER,
        rc,
        this,
        IDC_APPSCTRL
        );

    CString strCaption;
    VERIFY(strCaption.LoadString(IDS_OCX_CERTMAP));

    m_ocx_ClientMappings.SetCaption(strCaption);
    m_ocx_ClientMappings.SetServerInstance(m_strMetaPath);
    m_ocx_ClientMappings.SetMachineName(m_strServerName);

    //
    // Initialize the CTL list data
    //
    InitializeCTLList();

    SetControlStates();

    return TRUE;  
}



void 
CSecCommDlg::OnCheckSslAccountMapping()
/*++

Routine Description:

    SSL Account mapping checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fAccountMapping = !m_fAccountMapping;
    SetControlStates();
}



void 
CSecCommDlg::OnOK()
/*++

Routine Description:

    OK button handler, save information

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fAccountMapping, m_dwAccessPermissions, MD_ACCESS_MAP_CERT);
        SET_FLAG_IF(m_fRequireSSL, m_dwAccessPermissions, MD_ACCESS_SSL);
        SET_FLAG_IF(m_fRequire128BitSSL, m_dwAccessPermissions, MD_ACCESS_SSL128);
        RESET_FLAG(m_dwAccessPermissions, 
            (MD_ACCESS_REQUIRE_CERT | MD_ACCESS_NEGO_CERT));

        switch(m_nRadioNoCert)
        {
        case RADIO_REQ_CERT:
            SET_FLAG(m_dwAccessPermissions, 
                (MD_ACCESS_REQUIRE_CERT | MD_ACCESS_NEGO_CERT));
            break;

        case RADIO_ACCEPT_CERT:
            SET_FLAG(m_dwAccessPermissions, MD_ACCESS_NEGO_CERT);
            break;
        }

        //
        // Provide warning if no authentication is selected
        //
        if (!m_dwAuthFlags && !m_dwAccessPermissions 
         && !NoYesMessageBox(IDS_WRN_NO_AUTH))
        {
            //
            // Don't dismiss the dialog
            //
            return;
        }

        //
        // If CTL stuff has changed, update the strings
        //
        if (m_bCTLDirty)
        {
            //
            // Get the index of the selected item
            //
            INT iSel = m_combo_ctl.GetCurSel();

            //
            // If nothing is selected, then clear out the strings
            //
            if (!m_fEnableCtl || (iSel == CB_ERR))
            {
                m_strCTLIdentifier.Empty();
                m_strCTLStoreName.Empty();
            }
            else
            {
                //
                // There is one selected. Update the Identifier string
                // first get the context itself
                //
                PCCTL_CONTEXT pCTL =
                    (PCCTL_CONTEXT)m_combo_ctl.GetItemData(iSel);

                if (pCTL != NULL)
                {
                    //
                    // Now get the list identifier for it and put it in
                    // the string the list identifier is a inherint value
                    // of the context and doesn't need to be read in seperately.
                    // We can just reference it.
                    //
                    m_strCTLIdentifier.Empty();

                    if (pCTL->pCtlInfo
                     && pCTL->pCtlInfo->ListIdentifier.cbData >= 2
                     && pCTL->pCtlInfo->ListIdentifier.cbData)
                    {
                        //
                        // If the identifiers are the same, then this is
                        // our default CTL
                        //
//                      m_strCTLIdentifier =
//                          (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData;

                        wcsncpy(m_strCTLIdentifier.GetBuffer(
                                pCTL->pCtlInfo->ListIdentifier.cbData + 2),
                                (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData,
                                pCTL->pCtlInfo->ListIdentifier.cbData
                                );

                        m_strCTLIdentifier.ReleaseBuffer();
                    }
                }
                else
                {
                    m_strCTLIdentifier.Empty();
                    m_strCTLStoreName.Empty();
                }
            }
        }

        CDialog::OnOK();
    }
}



void 
CSecCommDlg::OnCheckRequireSsl() 
/*++

Routine Description:

    'require ssl' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fRequireSSL = !m_fRequireSSL;
    // Uncheck 128bit stuff if more generic is unchecked
    if (m_check_RequireSSL.GetCheck() == 0)
      m_check_Require128BitSSL.SetCheck(0);
    SetControlStates();
}



void 
CSecCommDlg::OnRadioNoCert() 
/*++

Routine Description:

    'Do not accept certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_NO_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnRadioAcceptCert() 
/*++

Routine Description:

    'accept certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_ACCEPT_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnRadioRequireCert() 
/*++

Routine Description:

    'require certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_REQ_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnCheckEnableCtl() 
/*++

Routine Description:

    'Enable CTL' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Since this is local only, if we are remote and the user checks the
    // box, then we should alert them to the situation and then do nothing.
    //
    if (!m_fIsLocal)
    {
        AfxMessageBox(IDS_CTL_LOCAL_ONLY);

        return;
    }


    m_fEnableCtl = !m_fEnableCtl;

    //
    // If we are now disabling, record the current cert and then blank it
    //
    if (!m_fEnableCtl)
    {
        m_iLastUsedCert = m_combo_ctl.GetCurSel();
        m_combo_ctl.SetCurSel(-1);
    }
    else
    {
        //
        // We are enabling, use the last recorded cert
        //
        m_combo_ctl.SetCurSel(m_iLastUsedCert);
    }

    m_bCTLDirty = TRUE;
    SetControlStates();
}



void 
CSecCommDlg::OnButtonEditCtl() 
/*++

Routine Description:

    "Edit CTL" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Get the index of the selected item
    //
    INT iSel = m_combo_ctl.GetCurSel();
    ASSERT( iSel != CB_ERR );

    //
    // Get the selected CTL context
    //
    PCCTL_CONTEXT   pCTL = (PCCTL_CONTEXT)m_combo_ctl.GetItemData(iSel);

    //
    // Pass in the selected CTL context to edit it
    //
    PCCTL_CONTEXT pCTLNew = CallCTLWizard( pCTL );

    //
    // If the CTL on the item has changed, then update the private data item
    //
    if (pCTLNew && pCTLNew != pCTL)
    {
        //
        // start be deleting the current item from the list
        //
        m_combo_ctl.DeleteString(iSel);

        //
        // free the old context
        //
        CertFreeCTLContext(pCTL);

        //
        // now add the new one and select it.
        //
        AddCTLToList(pCTLNew, TRUE);
        SetControlStates();

        //
        // set the dirty flag
        //
        m_bCTLDirty = TRUE;
    }
}



void
CSecCommDlg::OnButtonNewCtl() 
/*++

Routine Description:

    "New CTL" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Pass in NULL to create a new CTL
    //
    PCCTL_CONTEXT   pCTL = CallCTLWizard(NULL);

    //
    // If a CTL was created, add it to the list and select it.
    //
    if (pCTL != NULL)
    {
        AddCTLToList(pCTL, TRUE);
        SetControlStates();
        m_bCTLDirty = TRUE;
    }
}



PCCTL_CONTEXT
CSecCommDlg::CallCTLWizard( 
    IN PCCTL_CONTEXT pCTLSrc 
    )
/*++

Routine Description:

    Adds a CTL to the drop down CTL list. Note that the context pointers are
    set as the private data on the list items. This means that they will need
    to be de-referenced when this object is destroyed. See the 
    routine CleanUpCTLList.

    This routine by boydm

Arguments:

    PCCTL_CONTEXT pctl ctl context pointer of the ctl being added
    BOOL fSelect       flag specifying if this ctl should be selected after it
                       is added

Return Value:

    returns TRUE if successful

--*/
{
    PCCTL_CONTEXT       pCTLOut = NULL;

    CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO   newInfo;
    CTL_USAGE           useInfo;
    CString             szFriendly;
    CString             szDescription;
    CString             szListIdentifier;
    LPOLESTR            pszListIdentifier = NULL;
    LPCSTR              rgbpszUsageArray[2];

    //
    // Prepare the main src structure
    //
    CRYPTUI_WIZ_BUILDCTL_SRC_INFO   srcInfo;
    ZeroMemory( &srcInfo, sizeof(srcInfo) );
    srcInfo.dwSize = sizeof(srcInfo);

    //
    // If we are editing an existing CTL then we do one thing
    //
    if ( pCTLSrc )
    {
        srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL;
        srcInfo.pCTLContext = pCTLSrc;
    }
    else
    {
        //
        // Prepare the usage arrays
        //
        ZeroMemory( &rgbpszUsageArray, sizeof(rgbpszUsageArray) );
        rgbpszUsageArray[0] = szOID_IIS_VIRTUAL_SERVER;

        //
        // Must also have client auth - or else no certs show up in the list!
        //
        rgbpszUsageArray[1] = szOID_PKIX_KP_CLIENT_AUTH;
        ZeroMemory( &useInfo, sizeof(useInfo) );
        useInfo.cUsageIdentifier = 2;
        useInfo.rgpszUsageIdentifier = (PCHAR*)&rgbpszUsageArray;

        //
        // Prep the new ctl structure, which may or may not get used
        //
        ZeroMemory( &newInfo, sizeof(newInfo) );

        //
        // We making a new CTL, fill in the rest of the stuff
        //
        srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL;
        srcInfo.pNewCTLInfo = &newInfo;

        //
        // Load the friendly name and the description
        //
        szFriendly.LoadString(IDS_CTL_NEW);
        szDescription.LoadString(IDS_CTL_DESCRIPTION);

        //
        // Create a guid string for the identifier
        //
        GUID        id;
        HRESULT     hres;
        hres = CoCreateGuid(&id);
        hres = StringFromGUID2(id, szListIdentifier.GetBuffer(1000), 1000);
        szListIdentifier.ReleaseBuffer();

        //
        // Fill in the newInfo structure
        //
        newInfo.dwSize = sizeof(newInfo);

        //
        // For now - don't set the usage
        //
        newInfo.pSubjectUsage = &useInfo;

        //
        // Put the generated list identifier into place
        //
        newInfo.pwszListIdentifier = (LPTSTR)(LPCTSTR)szListIdentifier;

        //
        // Fill in the friendly strings that were loaded from the resources
        //
        newInfo.pwszFriendlyName = (LPTSTR)(LPCTSTR)szFriendly;
        newInfo.pwszDescription = (LPTSTR)(LPCTSTR)szDescription;
    }

    //
    // Make the call to the CTL wizard
    //
    if (!CryptUIWizBuildCTL(
            CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING |
            CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE |
            CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
            m_hWnd,         
            NULL,    
            &srcInfo,
            NULL,     
            &pCTLOut
            ))
    {
        //
        // The user canceled the CTL wizard or it failed in general.
        // the CTL wizard puts up its own error dialogs
        //
        return NULL;
    }

/*
    // get the friendly name from the CTL that comes out of the wizard.
    // the process of signing this CTL does not transfer the friendly
    // name to the resulting new CTL. Oh well.
    DWORD       cbProperty;
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_FRIENDLY_NAME_PROP_ID,
        OUT NULL,
        IN OUT &cbProperty
        );
    // increase buffer just to cover any nulls just to be safe
    cbProperty += 2;
    // get the friendly name
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_FRIENDLY_NAME_PROP_ID,
        OUT szFriendly.GetBuffer(cbProperty),
        IN OUT &cbProperty
        );
    szFriendly.ReleaseBuffer();

    // get the description from the CTL that comes out of the wizard.
    // the process of signing this CTL does not transfer the friendly
    // name to the resulting new CTL. Oh well.
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_DESCRIPTION_PROP_ID,
        OUT NULL,
        IN OUT &cbProperty
        );
    // increase buffer just to cover any nulls just to be safe
    cbProperty += 2;
    // get the friendly name
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_DESCRIPTION_PROP_ID,
        OUT szDescription.GetBuffer(cbProperty),
        IN OUT &cbProperty
        );
    szDescription.ReleaseBuffer();


    // prepare the signer information
    CMSG_SIGNER_ENCODE_INFO     infoSigner;
    ZeroMemory( &infoSigner, sizeof(infoSigner) );
    infoSigner.cbSize = sizeof(infoSigner);
    infoSigner.pCertInfo = m_pServerCert->pCertInfo;

    
//    infoSigner.HashAlgorithm.pszObjId = szOID_RSA_SHA1RSA;


//CERT_CONTEXT

    // prepare the signing cert information
    CERT_BLOB                   infoSigningCert;
    infoSigningCert.cbData = m_pServerCert->cbCertEncoded;
    infoSigningCert.pbData = m_pServerCert->pbCertEncoded;

    // prepare the signed information
    CMSG_SIGNED_ENCODE_INFO     infoSigned;
    ZeroMemory( &infoSigned, sizeof(infoSigned) );
    infoSigned.cbSize = sizeof(infoSigned);
//    infoSigned.cSigners = 1;
//    infoSigned.rgSigners = &infoSigner;
    infoSigned.cCertEncoded = 1;
    infoSigned.rgCertEncoded = &infoSigningCert;

    // find out how much space we need for the encoded signed message
    DWORD       cbEncodedCTLMessage;
    PBYTE       pbyteEncodedMessage = NULL;
    // make the call to get the space requirement
    
    BOOL f = CryptMsgSignCTL(
        IN CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        IN pCTLOut->pbCtlContent,
        IN pCTLOut->cbCtlContent,
        IN &infoSigned,
        IN 0,
        OUT NULL,
        IN OUT &cbEncodedCTLMessage
        );

    if ( f )
        {
        // allocate the buffer for the message
        pbyteEncodedMessage = (PBYTE)GlobalAlloc( GPTR, cbEncodedCTLMessage );
        if ( !pbyteEncodedMessage )
            {
            f = FALSE;
            }
        else
            {
            // make the real call and get the message
            f = CryptMsgSignCTL(
                IN CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                IN pCTLOut->pbCtlContent,
                IN pCTLOut->cbCtlContent,
                IN &infoSigned,
                IN 0,
                OUT pbyteEncodedMessage,
                IN OUT &cbEncodedCTLMessage
                );
            }
        }
    
    // at this point we are done with the CTL returned by the wizard
    CertFreeCTLContext( pCTLOut );
    pCTLOut = NULL;

    // If the signing failed, ask the user if that want to proceed anyway
    if ( !f && AfxMessageBox( IDS_CTL_SIGN_FAIL, MB_YESNO ) == IDNO )
        {
        CertFreeCTLContext( pCTLOut );
        if ( pbyteEncodedMessage )
            {
            GlobalFree( pbyteEncodedMessage );
            }
        return NULL;
        }

    // add the encoded and signed CTL to the Cert store.
    if ( CertAddEncodedCTLToStore(
            IN m_hCTLStore,
            IN CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            IN pbyteEncodedMessage,
            IN cbEncodedCTLMessage,
            IN CERT_STORE_ADD_REPLACE_EXISTING,
            OUT &pCTLOut
            ) )
        {
*/
  /*
        // replace the friendly name and description that just got lost
        CertSetCTLContextProperty(
            IN pCTLOut,
            IN CERT_FRIENDLY_NAME_PROP_ID,
            IN 0,
            IN (LPCTSTR)szFriendly
            );
        CertSetCTLContextProperty(
            IN pCTLOut,
            IN CERT_DESCRIPTION_PROP_ID,
            IN 0,
            IN (LPCTSTR)szDescription
            );
*/
/*
        }
    else
        {
        // we failed to write it out to the store.
        AfxMessageBox( IDS_CTL_WRITE_FAIL );
        }


    // cleanup
    if ( pbyteEncodedMessage )
        {
        GlobalFree( pbyteEncodedMessage );
        }
*/
    
    //
    // Add the certificate context to the store
    //
    if (pCTLOut != NULL)
    {
        PCCTL_CONTEXT pCTLAdded = NULL;

        if (CertAddCTLContextToStore(
            m_hCTLStore,
            pCTLOut,
            CERT_STORE_ADD_REPLACE_EXISTING,
            &pCTLAdded
            ))
        {
            CertFreeCTLContext( pCTLOut );
            pCTLOut = pCTLAdded;
        }
        else
        {
            CertFreeCTLContext( pCTLOut );
            pCTLOut = NULL;
        }
    }

    return pCTLOut;
}



BOOL
CSecCommDlg::AddCTLToList(
    IN PCCTL_CONTEXT pCTL,
    IN BOOL fSelect
    )
/*++

Routine Description:

    Adds a CTL to the drop down CTL list. Note that the context pointers are
    set as the private data on the list items. This means that they will need
    to be de-referenced when this object is destroyed. See the 
    routine CleanUpCTLList.

    This routine by boydm

Arguments:

    PCCTL_CONTEXT pctl ctl context pointer of the ctl being added
    BOOL fSelect -     flag specifying if this ctl should be selected after it 
                       is added

Return Value:

    returns TRUE if successful

--*/
{
    BOOL fSuccess;

    ASSERT(pCTL != NULL);

    if (!pCTL)
    {
        return FALSE;
    }

    //
    // First, we extract the friendly name from the CTL.
    //
    CString     szFriendlyName;     // the friendly name
    DWORD       cbName = 0;         // count of BYTES for the name, not chars

    //
    // Find out how much space we need
    //
    fSuccess = CertGetCTLContextProperty(
        pCTL,
        CERT_FRIENDLY_NAME_PROP_ID,
        NULL,
        &cbName
        );

    //
    // Increase buffer just to cover any nulls just to be safe
    //
    cbName += 2;

    //
    // Get the friendly name
    //
    fSuccess = CertGetCTLContextProperty(
        pCTL,
        CERT_FRIENDLY_NAME_PROP_ID,
        szFriendlyName.GetBuffer(cbName),
        &cbName
        );

    szFriendlyName.ReleaseBuffer();

    //
    // If we did not get the name, then load the default name.
    // The friendly name is an optional parameter in the CTL so it
    // is OK if it is not there.
    //
    if (!fSuccess)
    {
        szFriendlyName.LoadString(IDS_CTL_UNNAMED);
    }

    //
    // Add the friendly name string to the drop down CTL list and record
    // the index of the newly created item
    //
    INT iCTLPosition = m_combo_ctl.AddString(szFriendlyName);

    //
    // If it worked, then add the context pointer to the item as private data
    //
    if (iCTLPosition >=0)
    {
        m_combo_ctl.SetItemData(iCTLPosition, (ULONG_PTR)pCTL);

        //
        // if we have been told to select the CTL, do so at this point
        //
        if (fSelect)
        {
            m_combo_ctl.SetCurSel(iCTLPosition);
        }
    }
    
    //
    // Return TRUE if we successfully added the CTL
    //
    return (iCTLPosition >=0);
}



void
CSecCommDlg::InitializeCTLList() 
/*++

Routine Description:

    Initializes the CTL drop down box by opening the CTL store pointer
    to the target store and filling in the CTL list box with the enumerated
    values.

    This routine by boydm

Arguments:

    None

Return Value:
    None

--*/
{
    //
    // For now this is Local ONLY
    //
    if (!m_fIsLocal)
    {
        return;
    }

    //
    // Build the remote name for the store.
    // It takes the form of "\\MACHINE_NAME\STORENAME"
    // The store name is always "MY" and is define above. The machine
    // name is the name of the machine being edited. The leading \\ in the
    // machine name is optional so we will skip it in this case
    //
    CString szStore;
    
    //
    // Start by adding the machine name that we are targeting
    //
    szStore = m_strServerName;

    //
    // Add the specific store name
    //
    //szStore += _T('\\');
    //szStore += m_strCTLStoreName;

    szStore = m_strCTLStoreName;

    //
    // Open the store
    //
    m_hCTLStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
        0,
        NULL,
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        szStore 
        );

    //
    // If we failed to open the store, then we will be unable to do anything
    // with CTLs on this machine at all. Disable everything having to do
    // with the CTL controls.
    //
    if (!m_hCTLStore)
    {
        m_fEnableCtl = FALSE;

        //
        // Return early as we have no need to enumerate the CTLs
        //
        return;
    }

    //
    // Enumerate all the CTLs in the store and add them to the drop-down list
    //
    PCCTL_CONTEXT   pCTLEnum = NULL;

    //
    // Enumerate undil NULL is returned. Note that CertEnumCTLsInStore
    // free the context passed into pCTLEnum if it is non NULL. Thus we
    // need to create a duplicate of it to add to the drop-list
    //
    while (pCTLEnum = CertEnumCTLsInStore(m_hCTLStore, pCTLEnum))
    {
        //
        // Make a duplicate of the CTL context for storing in thte list
        //
        PCCTL_CONTEXT pCTL = CertDuplicateCTLContext(pCTLEnum);

        if (!pCTL)
        {
            //
            // Duplication Failed
            //
            continue;
        }

        //
        // The list identifier is a inherint value of the context and doesn't
        // need to be read in separately. We can just referenece it
        //
        BOOL fIsCurrentCTL = FALSE;

        if (pCTL->pCtlInfo
         && pCTL->pCtlInfo->ListIdentifier.cbData >= 2 
         && pCTL->pCtlInfo->ListIdentifier.cbData)
        {
            //
            // If the identifiers are the same, then this is our default CTL
            //
            fIsCurrentCTL = (wcsncmp( 
                (LPCTSTR)m_strCTLIdentifier,
                (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData,
                pCTL->pCtlInfo->ListIdentifier.cbData 
                ) == 0);
                
            // fIsCurrentCTL = ( m_strCTLIdentifier == (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData );
        }

        //
        // Add the CTL to the list
        //
        AddCTLToList(pCTL, fIsCurrentCTL);
    }
}



void
CSecCommDlg::CleanUpCTLList() 
/*++

Routine Description:

    Dereferences all the CTL context pointers in the private data of
    the items in the CTL combo box.
    Then it closes the CTL store handle

    This routine by boydm

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD cItems = m_combo_ctl.GetCount();

    //
    // Loop through each item and free its reference to the CTL pointer
    //
    for (DWORD i = 0; i < cItems; ++i)
    {
        //
        // Get the CTL context pointer from the item's private data
        //
        PCCTL_CONTEXT pCTL = (PCCTL_CONTEXT)m_combo_ctl.GetItemData(i);

        if (pCTL)
        {
            CertFreeCTLContext(pCTL);
        }
    }

    //
    // Close the handle to the store that contains the CTLs
    //
    if (m_hCTLStore)
    {
        CertCloseStore( m_hCTLStore, CERT_CLOSE_STORE_FORCE_FLAG );
        m_hCTLStore = NULL;
    }
}



void
CSecCommDlg::OnSelchangeComboCtl() 
/*++

Routine Description:

    The selection in the drop-down list changed

    This routine by boydm

  Arguments:

    None

Return Value:
    None

--*/
{
    SetControlStates();
    m_bCTLDirty = TRUE;
}



void 
CSecCommDlg::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CDialog::OnDestroy();
    
    CleanUpCTLList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w3scfg.rc
//
#define IDS_IP_ADDRESS_SUBNET_MASK      44
#define IDS_RECONNECT_WARNING           90
#define IDI_FILE_TYPES                  129
#define IDC_EDIT_EXTENSION              802
#define IDC_STATIC_EXTENSION            832
#define IDB_WWW                         1000
#define IDS_WWW                         1000
#define IDS_CAPTION                     1001
#define IDS_PORT_CHANGE                 1002
#define IDS_CAPTION_MULTIPLE            1003
#define IDS_BUTTON_REMOVE               1004
#define IDC_DIRECTORY                   1005
#define IDS_STATUS                      1005
#define IDS_FILTER_NAME                 1006
#define IDS_FILTER_EXECUTABLE           1007
#define IDC_BROWSE                      1008
#define IDS_PRIORITY                    1008
#define IDS_HIGH                        1009
#define IDS_MEDIUM                      1010
#define IDS_LOW                         1011
#define IDC_TO_FILE                     1012
#define IDS_APPLICATION                 1012
#define IDC_MONTHLY                     1013
#define IDS_EXTENSION                   1013
#define IDC_TO_SQL                      1014
#define IDS_EXECUTABLE                  1014
#define IDC_EDIT_DIRECTORY              1015
#define IDS_HTTP_ERROR                  1015
#define IDC_EDIT_PATH                   1015
#define IDC_EDIT_REDIRECT               1016
#define IDC_BUTTON_ADD                  1016
#define IDS_OUTPUT_TYPE                 1016
#define IDC_EDIT_USER_NAME              1017
#define IDC_DATASOURCE                  1017
#define IDS_TEXT_OR_FILE                1017
#define IDC_EDIT_MAX_NETWORK_USE        1017
#define IDS_BUTTON_CREATE               1017
#define IDC_BUTTON_ADD_SSL              1017
#define IDS_FILE                        1018
#define IDS_TEXT                        1019
#define IDS_BUTTON_ENABLE               1019
#define IDS_FILE_PROMPT                 1020
#define IDS_TEXT_PROMPT                 1021
#define IDS_BUTTON_DISABLE              1021
#define IDS_HTML_MASK                   1022
#define IDS_UNC_MASK                    1023
#define IDC_LIST_DIRECTORIES            1024
#define IDC_LIST_ERRORS                 1024
#define IDS_REDIRECT_MASK               1024
#define IDS_DIRECTORY_MASK              1025
#define IDC_STATIC_DIRECTORY            1026
#define IDS_BAD_PORT                    1026
#define IDS_DIR_TITLE                   1026
#define IDS_BAD_ALIAS                   1027
#define IDS_NO_PATH                     1028
#define IDS_CAPTION_DEFAULT             1029
#define IDC_STATIC_FILE                 1030
#define IDS_WRN_WRITE_EXEC              1030
#define IDC_LOG                         1031
#define IDS_CHECK_TEXT_SSL_INSTALLED    1031
#define IDS_CHECK_TEXT_SSL_NOT_INSTALLED 1032
#define IDS_CHECK_TEXT_SSL_NOT_ENABLED  1033
#define IDS_CHECK_REQUIRE_SSL_INSTALLED 1034
#define IDS_CHECK_REQUIRE_SSL_NOT_INSTALLED 1035
#define IDS_CHECK_REQUIRE_SSL_NOT_ENABLED 1036
#define IDS_WRN_NO_AUTH                 1037
#define IDS_TCP_SSL_PART                1038
#define IDS_ERR_DOCUMENTS               1039
#define IDS_YES                         1040
#define IDS_NO                          1041
#define IDS_LOADED                      1042
#define IDS_UNLOADED                    1043
#define IDC_NEW_LOG                     1044
#define IDS_DISABLED                    1044
#define IDC_DAILY                       1045
#define IDS_NOT_COMMITTED               1045
#define IDC_WEEKLY                      1046
#define IDS_NEW_VROOT                   1046
#define IDS_ERR_COMPLETE_PATH           1047
#define IDC_FILE_SIZE                   1048
#define IDS_UNKNOWN_PRIORITY            1048
#define IDC_TABLE                       1049
#define IDS_TAB_HOME_DIRECTORY          1049
#define IDC_USER_NAME                   1050
#define IDS_TAB_VIRTUAL_DIRECTORY       1050
#define IDS_TAB_FILE                    1051
#define IDS_TAB_DIR                     1052
#define IDC_PASSWORD                    1053
#define IDS_DUP_MAPPING                 1053
#define IDS_ERR_NO_COMPLETE_PATH        1053
#define IDC_STATIC_DATASOURCE           1054
#define IDS_ERR_VROOT_OVERRIDE          1054
#define IDC_STATIC_TABLE                1055
#define IDS_ENABLE                      1055
#define IDC_STATIC_USER_NAME            1056
#define IDS_DISABLE                     1056
#define IDC_STATIC_PASSWORD             1057
#define IDS_UNKNOWN                     1057
#define IDC_EDIT_FILE_SIZE              1058
#define IDS_MMM_IP_ADDRESS              1058
#define IDS_MMM_TCP_PORT                1059
#define IDS_MMM_SSL_PORT                1060
#define IDS_MMM_DOMAIN_NAME             1061
#define IDS_MMM_NA                      1062
#define IDS_ERR_BINDING                 1063
#define IDS_ERR_NO_PORTS                1064
#define IDS_ERR_SSL_BINDING             1065
#define IDS_DUPLICATE_DOC               1066
#define IDC_BUTTON_EDIT                 1067
#define IDS_NOT_LOCAL_FOOTER            1067
#define IDC_BUTTON_REMOVE               1068
#define IDS_TAB_FILE_SECURITY           1068
#define IDC_BUTTON_EDIT_ANONYMOUS       1068
#define IDC_LIST_IP_ADDRESSES           1069
#define IDS_TAB_DIR_SECURITY            1069
#define IDC_BUTTON_REMOVE_SSL           1069
#define IDS_ERR_DUP_HEADER              1070
#define IDS_ERR_DUP_FILTER              1071
#define IDS_RADIO_VDIR                  1072
#define IDC_CHECK_LIMIT_NETWORK_USE     1073
#define IDS_RADIO_DIR                   1073
#define IDC_STATIC_MAX_NETWORK_USE      1074
#define IDS_RADIO_FILE                  1074
#define IDS_NOT_REL_URL                 1075
#define IDC_STATIC_KBS                  1076
#define IDS_EDIT_MMM_TITLE              1076
#define IDC_BUTTON_BROWSE               1077
#define IDS_EDIT_SSL_MMM_TITLE          1077
#define IDS_TCP_PORT                    1078
#define IDC_EDIT_ALIAS                  1079
#define IDS_SSL_PORT                    1079
#define IDS_ERR_PORT_IN_USE_SSL         1080
#define IDS_ERR_PORT_IN_USE_TCP         1081
#define IDC_SPIN_FILESIZE               1082
#define IDS_DEF_APP                     1082
#define IDS_FILTER_MASK                 1083
#define IDS_ERR_COMPRESS_DIRECTORY      1084
#define IDS_NEW_VDIR_WIZARD             1085
#define IDS_NEW_SITE_WIZARD             1086
#define IDS_SITE_PERMS_TITLE            1087
#define IDS_SITE_PERMS_SUBTITLE         1088
#define IDS_SITE_SECURITY_TITLE         1089
#define IDS_SITE_SECURITY_SUBTITLE      1090
#define IDS_WRN_UNLOAD_POOP             1091
#define IDC_RADIO_GRANTED               1094
#define IDC_RADIO_DENIED                1095
#define IDC_STATIC_ACCESS               1104
#define IDC_STATIC_IP_ADDRESS           1105
#define IDC_IPA_IPADDRESS               1107
#define IDC_STATIC_LOG                  1111
#define IDC_STATIC_IP_GROUP             1120
#define IDC_CHECK_USE_IP                1121
#define IDC_STATIC_IP_PROMPT            1122
#define IDC_STATIC_ALIAS                1125
#define IDC_STATIC_LOGFILENAME          1126
#define IDC_RADIO_HOME                  1136
#define IDC_RADIO_ALIAS                 1137
#define IDC_CHECK_EXECUTE               1138
#define IDC_GROUP_ACCOUNT               1139
#define IDC_GROUP_ACCESS                1140
#define IDC_CHECK_SSL                   1141
#define IDC_STATIC_EXCEPT               1145
#define IDC_ICON_GRANTED                1146
#define IDC_ICON_DENIED                 1147
#define IDC_LOG_FORMAT                  1148
#define IDC_BUTTON_FILE_TYPES           1151
#define IDS_CONTENTS                    1152
#define IDS_URL_PROMPT                  1153
#define IDS_URL                         1154
#define IDS_DEFAULT_ERROR               1155
#define IDS_BAD_ERROR                   1156
#define IDS_NO_DEF_ERRORS               1157
#define IDS_INST_WIZARD                 1158
#define IDS_ERR_FILE_NOT_FOUND          1158
#define IDS_PROMPT_DIR                  1159
#define IDS_PROMPT_UNC                  1160
#define IDS_PROMPT_REDIRECT             1161
#define IDS_BAD_UNC_PATH                1162
#define IDS_BAD_URL_PATH                1163
#define IDS_NO_DATE                     1166
#define IDS_BAD_DATE                    1167
#define IDS_ERR_EXPIRE_RANGE            1169
#define IDS_NO_HEADER_PORT              1170
#define IDS_NO_PORT                     1170
#define IDS_ILLEGAL_ALIAS_CHARS         1171
#define IDS_ERR_APP                     1172
#define IDS_MINUTES                     1173
#define IDS_HOURS                       1174
#define IDS_DAYS                        1175
#define IDS_OCX_CERTMAP                 1176
#define IDS_WEB_MASTER                  1177
#define IDS_APPROOT_FMT                 1178
#define IDS_APPROOT_UNKNOWN             1179
#define IDS_BUTTON_CONFIGURATION        1180
#define IDS_NO_ACL_WARNING              1180
#define IDS_BUTTON_LOG_PROPERTIES       1181
#define IDS_COMPRESS_WARNING            1181
#define IDS_BUTTON_RATINGS              1182
#define IDC_RADIO_UNLIMITED             1182
#define IDS_WRN_DIGEST                  1182
#define IDC_RADIO_LIMITED               1183
#define IDS_MASTER_FILTERS              1183
#define IDS_INSTANCE_FILTERS            1184
#define IDS_PERMISSIONS_NONE            1185
#define IDS_PERMISSIONS_SCRIPT          1186
#define IDS_PERMISSIONS_EXECUTE         1187
#define IDS_CTL_UNNAMED                 1188
#define IDS_CTL_NEW                     1189
#define IDS_CTL_DESCRIPTION             1190
#define IDS_CTL_WRITE_FAIL              1191
#define IDS_CTL_SIGN_FAIL               1192
#define IDS_CTL_LOCAL_ONLY              1193
#define IDS_SITE_WELCOME                1194
#define IDS_SITE_BODY                   1195
#define IDS_SITE_SUCCESS                1196
#define IDS_SITE_FAILURE                1197
#define IDS_VDIR_WELCOME                1198
#define IDS_VDIR_BODY                   1199
#define IDS_VDIR_SUCCESS                1200
#define IDS_VDIR_FAILURE                1201
#define IDS_COMBO_INPROC                1202
#define IDS_COMBO_OUTPROC               1203
#define IDS_COMBO_POOLEDPROC            1204
#define IDS_EXECUTE_AND_WRITE_WARNING   1205
#define IDD_SERVICE                     2000
#define IDD_SESSIONS                    2001
#define IDB_WWWVIEW                     2004
#define IDD_DIRECTORY_SECURITY          2005
#define IDD_DIRECTORY_HTTP              2006
#define IDI_RATINGS                     2006
#define IDD_DIRECTORY_ERRORS            2007
#define IDD_ENHANCED_LOGGING            2008
#define IDD_DIRECTORY_FILTERS           2009
#define IDB_WWWVDIR                     2009
#define IDD_FILTERS                     2009
#define IDD_ADVANCED                    2010
#define IDD_DIRECTORY_PROPERTIES        2011
#define IDB_FILTERS                     2012
#define IDD_FILTER                      2013
#define IDD_EXTENSION                   2014
#define IDB_ERRORS                      2014
#define IDD_ERROR_MAPPING               2015
#define IDD_ACCOUNTS                    2016
#define IDD_AUTHENTICATION              2019
#define IDB_WIZ_LEFT                    2019
#define IDD_DIALOG_SSL                  2020
#define IDB_WIZ_HEAD                    2020
#define IDB_WIZ_LEFT_DIR                2021
#define IDB_WIZ_HEAD_DIR                2022
#define IDD_CUSTOM_HEADER               2022
#define IDI_SSL                         2023
#define IDI_SECURE                      2024
#define IDB_WIZ_LEFT_SEC                2024
#define IDI_AUTHENTICATION              2025
#define IDB_WIZ_HEAD_SEC                2025
#define IDD_USER_ACCOUNT                2029
#define IDD_REDIRECT                    2030
#define IDD_PERFORMANCE                 2031
#define IDD_DIRECTORY_DOCUMENTS         2032
#define IDD_DEFAULT_DOCUMENT            2033
#define IDD_DIALOG_PICK_DATE            2034
#define IDD_DIALOG_MMM                  2037
#define IDD_BASIC_DOMAIN                2038
#define IDB_WWW32                       2039
#define IDB_BINDINGS                    2040
#define IDD_DIALOG_EDIT_MMM             2040
#define IDD_NEW_INST_DESCRIPTION        2041
#define IDB_NEW_INSTANCE                2041
#define IDD_NEW_INST_BINDINGS           2042
#define IDB_NEW_VROOT                   2042
#define IDD_NEW_INST_HOME               2043
#define IDB_WWWVDIR32                   2043
#define IDD_NEW_DIR_ALIAS               2044
#define IDD_NEW_DIR_PATH                2045
#define IDD_NEW_DIR_PERMS               2046
#define IDD_NEW_PERMS                   2046
#define IDD_NEW_DIR_USER_PASSWORD       2047
#define IDD_NEW_USER_PASSWORD           2047
#define IDD_NEW_INST_PERMS              2048
#define IDD_NEW_INST_USER_PASSWORD      2049
#define IDD_ANONYMOUS                   2050
#define IDD_IP_SECURITY                 2051
#define IDI_IP_SECURITY                 2052
#define IDD_DEFAULT_SITE                2052
#define IDD_SECURE_COMMUNICATIONS       2053
#define IDD_NEW_DIR_COMPLETION_PAGE     2057
#define IDD_NEW_INST_COMPLETION_PAGE    2058
#define IDC_EDIT_COMMENT                3015
#define IDC_EDIT_EMAIL                  3017
#define IDC_EDIT_NAME                   3027
#define IDC_CHECK_ENABLE_DEFAULT_DOCUMENT 3031
#define IDC_EDIT_DEFAULT_DOCUMENT       3032
#define IDC_EDIT_TCP_PORT               3033
#define IDC_CHECK_ENABLE_DOCUMENT_FOOTER 3033
#define IDC_EDIT_CONNECTION_TIMEOUT     3034
#define IDC_EDIT_DOCUMENT_FOOTER        3035
#define IDC_EDIT_SSL_PORT               3036
#define IDC_SPIN_CONNECTION_TIMEOUT     3037
#define IDC_EDIT_CONNECTION_TIMEOUT2    3038
#define IDC_EDIT_MAX_CONNECTIONS        3039
#define IDC_SPIN_CONNECTION_TIMEOUT2    3040
#define IDC_SPIN_MAX_CONNECTIONS        3041
#define IDC_EDIT_CGI_TIMEOUT            3042
#define IDC_EDIT_MAX_CONNECTIONS2       3043
#define IDC_SPIN_CGI_TIMEOUT            3045
#define IDC_EDIT_ODBC_TIMEOUT           3047
#define IDC_EDIT_BASIC_DOMAIN           3048
#define IDC_SPIN_ODBC_TIMEOUT           3049
#define IDC_STATIC_DEFAULT_DOCUMENT     3050
#define IDC_EDIT_USERNAME               3050
#define IDC_CHECK_CLEAR_TEXT            3051
#define IDC_EDIT_PASSWORD               3051
#define IDC_STATIC_DOCUMENT_FOOTER      3052
#define IDC_CHECK_NT_CHALLENGE_RESPONSE 3053
#define IDC_STATIC_USERNAME             3053
#define IDC_CHECK_UUENCODED             3054
#define IDC_STATIC_ANONYMOUS_LOGON      3056
#define IDC_CHECK_SSL_CLIENT_AUTHENTICATION 3057
#define IDC_BUTTON_EDIT_SSL             3058
#define IDC_CHECK_REQUIRE_ENCRYPTION    3059
#define IDC_CHECK_SSL20                 3060
#define IDC_CHECK_SSL30                 3061
#define IDC_CHECK_PCT                   3062
#define IDC_EDIT_EXPIRE                 3063
#define IDC_SPIN_EXPIRATION             3064
#define IDC_COMBO_CUSTOM_NAME           3065
#define IDC_BUTTON_ADD_HEADER           3066
#define IDC_BUTTON_DELETE_HEADER        3067
#define IDC_COMBO_CONTENT_NEGOTIATION   3068
#define IDC_BUTTON_ADD_CONTENT          3069
#define IDC_BUTTON_DELETE_CONTENT       3070
#define IDC_BUTTON_CHECK_PASSWORD       3070
#define IDC_BUTTON_EDIT_RATINGS         3071
#define IDC_CHECK_ENABLE_LOGGING        3071
#define IDC_BUTTON_SETTINGS             3072
#define IDC_COMBO_LOG_FORMATS           3072
#define IDC_LIST_FILTERS                3073
#define IDC_EDIT_DOMAIN_NAME            3074
#define IDC_CHECK_ENABLE_PW_SYNCHRONIZATION 3074
#define IDC_EDIT_VALUE                  3075
#define IDC_EDIT_IP_ADDRESS             3076
#define IDC_RADIO_DIR                   3076
#define IDC_EDIT_EXECUTABLE             3077
#define IDC_RADIO_UNC                   3077
#define IDC_CHECK_IPX                   3078
#define IDC_COMBO_ADMINISTRATORS        3079
#define IDC_BUTTON_DELETE               3080
#define IDC_BUTTON_BROWSE_DOMAIN        3081
#define IDC_BUTTON_BROWSE_USERS         3082
#define IDC_CHECK_ODBC_TIMEOUT          3083
#define IDC_CHECK_CACHE_ISAPI           3084
#define IDC_CHECK_USE_KEEPALIVE         3085
#define IDC_CHECK_PROCESS_RANGE_HEADERS 3086
#define IDC_LIST_ISAPI_MAPPINGS         3087
#define IDC_BUTTON_LOAD                 3088
#define IDC_BUTTON_UNLOAD               3089
#define IDC_BUTTON_DISABLE              3090
#define IDC_STATIC_SECONDS              3091
#define IDC_EDIT_FILTERNAME             3092
#define IDC_RADIO_HIGH                  3093
#define IDC_RADIO_MEDIUM                3094
#define IDC_RADIO_LOW                   3095
#define IDC_STATIC_PRIORITY_VALUE       3098
#define IDC_STATIC_PRIORITY             3099
#define IDC_BUTTON_UP                   3100
#define IDC_BUTTON_DOWN                 3101
#define IDC_STATIC_ERROR_CODE           3102
#define IDC_COMBO_MESSAGE_TYPE          3103
#define IDC_STATIC_TEXT_FILE_PROMT      3104
#define IDC_EDIT_TEXT_FILE              3105
#define IDC_LIST_ADMINISTRATORS         3106
#define IDC_BUTTON_CLEAR                3107
#define IDC_COMBO_IP_ADDRESS            3108
#define IDC_STATIC_CONNECTIONS          3111
#define IDC_STATIC_SSL_PORT             3112
#define IDC_COMBO_MAPPING_TYPE          3114
#define IDC_STATIC_FILTERS              3115
#define IDC_BUTTON_SET_TO_DEFAULT       3116
#define IDC_BUTTON_ADVANCED             3116
#define IDC_COMBO_PATH_TYPE             3117
#define IDC_BUTTON_CLIENT_MAPPINGS      3119
#define IDC_BUTTON_CERTIFICATE          3120
#define IDC_BUTTON_AUTHENTICATION       3121
#define IDC_BUTTON_COMMUNICATIONS       3122
#define IDC_CHECK_SSL2                  3122
#define IDC_CHECK_SSL2_128Bit           3123
#define IDC_BUTTON_IP_SECURITY          3123
#define IDC_CHECK_SSL2_DIGEST           3124
#define IDC_CHECK_SSL3                  3125
#define IDC_CHECK_SSL3_128Bit           3126
#define IDC_CHECK_SSL3_DIGEST           3127
#define IDC_BUTTON_KEY_MANAGER          3128
#define IDC_STATIC_AUTHENTICATION       3129
#define IDC_STATIC_SSL2                 3130
#define IDC_CHECK_EXPIRATION            3131
#define IDC_RADIO_IMMEDIATELY           3132
#define IDC_RADIO_TIME                  3133
#define IDC_COMBO_TIME                  3134
#define IDC_STATIC_CONTENT_SHOULD       3135
#define IDC_LIST_HEADERS                3137
#define IDC_EDIT_HEADER                 3138
#define IDC_MAPR2CTRL1                  3139
#define IDC_MAPNTACTRL1                 3140
#define IDC_CHECK_SSL_REQUIRED          3141
#define IDC_CHECK_SSL_ACCOUNT_MAPPING   3143
#define IDC_CHECK_REQUIRE_SSL           3148
#define IDC_STATIC_SSL                  3149
#define IDC_CHECK_REQUIRE_128BIT        3150
#define IDC_BUTTON_MAPPINGS             3151
#define IDC_GROUP_SECURE_CHANNEL        3153
#define IDC_STATIC_SECURE_CHANNEL       3154
#define IDC_SLIDER_PERFORMANCE_TUNING   3156
#define IDC_STATIC_STATUS               3157
#define IDC_STATIC_EXECUTABLE           3158
#define IDC_STATIC_TRUSTED              3161
#define IDC_STATIC_TRUSTED_PROMPT       3162
#define IDC_CHECK_TRUSTED               3163
#define IDC_CHECK_LOAD_AT_START         3164
#define IDC_STATIC_DETAILS              3165
#define IDC_STATIC_STATUS_PROMPT        3166
#define IDC_STATIC_EXECUTABLE_PROMPT    3167
#define IDC_STATIC_EXTENSION_PROMPT     3168
#define IDC_STATIC_PRIORITY_PROMPT      3169
#define IDC_BUTTON_EDIT_PATH_TYPE       3171
#define IDC_BUTTON_CONNECT_AS           3171
#define IDC_CHECK_SCRIPT                3172
#define IDC_CERTMAPCTRL1                3174
#define IDC_STATIC_DOC_OPTIONS          3179
#define IDC_STATIC_PATH_TYPE            3180
#define IDC_STATIC_ALIAS_PROMPT         3181
#define IDC_STATIC_PATH_PROMPT          3182
#define IDC_STATIC_PATH                 3183
#define IDC_STATIC_THROTTLING           3184
#define IDC_CHECK_APP                   3185
#define IDC_EDIT_DEF_DOCUMENT           3192
#define IDC_RADIO_ABS_TIME              3193
#define IDC_BUTTON_RATINGS              3195
#define IDC_BUTTON_PICK_DATE            3197
#define IDC_EDITABS_TIME                3198
#define IDC_EDIT_ABS_TIME               3198
#define IDC_MSACALCTRL                  3199
#define IDC_CHECK_DIRBROWS              3200
#define IDC_LOGUICTRL                   3201
#define IDC_STATIC_LOG_PROMPT           3202
#define IDC_LIST_DEFAULT_DOCUMENT       3203
#define IDC_STATIC_FILTER_NAME          3204
#define IDC_STATIC_FILTER_NAME_PROMPT   3205
#define IDC_LIST_MMM                    3206
#define IDC_STATIC_WEB_SITE             3207
#define IDC_LIST_SSL_MMM                3207
#define IDC_STATIC_DESCRIPTION          3208
#define IDC_STATIC_TCP_PORT             3209
#define IDC_BUTTON_DEFAULT              3210
#define IDC_STATIC_SUB_PROMPT           3212
#define IDC_COMBO_IP_ADDRESSES          3213
#define IDC_STATIC_SUB_ERROR_CODE       3214
#define IDC_STATIC_DEF_TEXT             3215
#define IDC_EDIT_DESCRIPTION            3216
#define IDC_EDIT_HOME_PATH              3219
#define IDC_CHECK_ALLOW_ANONYMOUS       3220
#define IDC_RADIO_REDIRECT              3229
#define IDC_DIR_FLAGS_FIRST             3303
#define IDC_CHECK_READ                  3303
#define IDC_CHECK_WRITE                 3304
#define IDC_CHECK_LOG_ACCESS            3305
#define IDC_CHECK_DIRECTORY_BROWSING_ALLOWED 3306
#define IDC_CHECK_INDEX                 3307
#define IDC_CHECK_AUTHOR                3308
#define IDC_DIR_FLAGS_LAST              3308
#define IDC_STATIC_DIRFLAGS_LARGE       3320
#define IDC_STATIC_DIRFLAGS_SMALL       3321
#define IDC_REDIRECT_FLAGS_FIRST        3400
#define IDC_CHECK_EXACT                 3400
#define IDC_CHECK_CHILD                 3401
#define IDC_CHECK_PERMANENT             3402
#define IDC_STATIC_REDIRECT_PROMPT      3403
#define IDC_STATIC_REDIRFLAGS           3404
#define IDC_REDIRECT_FLAGS_LAST         3404
#define IDC_APPLICATIONS_FIRST          3503
#define IDC_STATIC_APPLICATIONS         3503
#define IDC_STATIC_APP_PROMPT           3504
#define IDC_EDIT_APPLICATION            3505
#define IDC_STATIC_STARTING_POINT       3506
#define IDC_STATIC_SP_PROMPT            3507
#define IDC_COMBO_PROCESS               3508
#define IDC_STATIC_PERMISSIONS          3509
#define IDC_BUTTON_CREATE_REMOVE_APP    3510
#define IDC_BUTTON_UNLOAD_APP           3511
#define IDC_DUMMY_CONFIGURATION         3512
#define IDC_STATIC_APPLICATION_SETTINGS 3513
#define IDC_COMBO_PERMISSIONS           3514
#define IDC_STATIC_PROTECTIOn           3515
#define IDC_APPLICATIONS_LAST           3515
#define IDC_APPSCTRL					3516
#define IDC_EDIT_HOURS                  3802
#define IDC_SPIN_HOURS                  3803
#define IDC_EDIT_MINUTES                3804
#define IDC_SPIN_MINUTES                3805
#define IDC_BUTTON_PROPERTIES           3806
#define IDC_BUTTON_RATINGS_TEMPLATE     3807
#define IDC_EDIT_PORT                   3809
#define IDC_STATIC_PORT                 3810
#define IDC_STATIC_HEADER_NAME          3811
#define IDC_GROUP_IP                    3813
#define IDC_STATIC_IP                   3814
#define IDC_CHECK_CERT_INSTALLED        3815
#define IDC_ICON_IP                     3816
#define IDC_COMBO_WEBSITES              3817
#define IDC_BUTTON_ENCRYPTION_SETTINGS  3818
#define IDC_STATIC_KEY_MANAGER_PROMPT   3819
#define IDC_STATIC_SSL_PROMPT           3820
#define IDC_RADIO_NO_CERT               3821
#define IDC_RADIO_ACCEPT_CERT           3822
#define IDC_RADIO_REQUIRE_CERT          3823
#define IDC_GROUP_SSL                   3824
#define IDC_DTP                         3825
#define IDC_DTP_ABS_DATE                3826
#define IDC_DTP_ABS_TIME                3827
#define IDC_CHECK_ENABLE_CPU_ACCOUNTING 3829
#define IDC_STATIC_CPU_PROMPT           3830
#define IDC_EDIT_CPU                    3831
#define IDC_STATIC_PERCENT              3832
#define IDC_CHECK_LOG_EVENT_ONLY        3833
#define IDC_CHECK_ENFORCE_LIMITS        3833
#define IDC_COMPRESS_FLAGS_FIRST        3835
#define IDC_STATIC_COMPRESS_GROUP       3835
#define IDC_CHECK_DYNAMIC_COMPRESSION   3836
#define IDC_CHECK_STATIC_COMPRESSION    3837
#define IDC_RADIO_COMPRESS_UNLIMITED    3838
#define IDC_RADIO_COMPRESS_LIMITED      3839
#define IDC_EDIT_COMPRESS_DIRECTORY     3840
#define IDC_STATIC_MAX_COMPRESS_SIZE    3841
#define IDC_STATIC_COMPRESS_DIRECTORY   3842
#define IDC_STATIC_COMPRESS_MB          3843
#define IDC_EDIT_COMPRESS_DIRECTORY_SIZE 3844
#define IDC_COMPRESS_FLAGS_LAST         3844
#define IDC_BUTTON_GET_CERTIFICATES     3848
#define IDC_CHECK_DIGEST                3849
#define IDC_BUTTON_ROOT_CERTIFICATES    3850
#define IDC_BUTTON_NEW_CTL              3850
#define IDC_CHECK_ENABLE_DS             3851
#define IDC_CHECK_ENABLE_CTL            3853
#define IDC_EDIT_CTL                    3854
#define IDC_BUTTON_EDIT_CTL             3855
#define IDC_BUTTON_SELECT               3856
#define IDC_STATIC_CURRENT_CTL          3857
#define IDC_COMBO_CTL                   3858
#define IDC_RADIO_INHERIT               3859
#define IDC_RADIO_TEMPLATE              3860
#define IDC_LIST_TEMPLATES              3861
#define IDC_RADIO_ACL_MAXIMUM           3863
#define IDC_RADIO_ACL_MINIMUM           3864
#define IDC_RADIO_NO_ACL                3865
#define IDC_LIST_SUMMARY                3867
#define IDC_CTL_SEPERATOR               3868
#define IDC_GROUP_SECURE                3869
#define IDC_ICON_SECURE                 3873
#define IDC_VIEW_CERTIFICATE            3874
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2053
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3875
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\security.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.h

   Abstract:

        WWW Security Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//{{AFX_INCLUDES()
#include "certauth.h"
#include "certmap.h"
#include "certwiz.h"
//}}AFX_INCLUDES



#ifndef __SECURITY_H__
#define __SECURITY_H__



class CW3SecurityPage : public CInetPropertyPage
/*++

Class Description:

    WWW Security property page

Public Interface:

    CW3SecurityPage     : Constructor
    ~CW3SecurityPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3SecurityPage)

//
// Construction
//
public:
    CW3SecurityPage(
        IN CInetPropertySheet * pSheet = NULL,
        IN BOOL  fHome                 = FALSE,
        IN DWORD dwAttributes          = 0L
        );

    ~CW3SecurityPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3SecurityPage)
    enum { IDD = IDD_DIRECTORY_SECURITY };
    BOOL    m_fUseNTMapper;
    CStatic m_icon_Secure;
    CStatic m_static_SSLPrompt;
    CButton m_check_EnableDS;
    CButton m_button_GetCertificates;
    CButton m_button_ViewCertificates;
    CButton m_button_Communications;
    //}}AFX_DATA

    CCertWiz    m_ocx_CertificateAuthorities;

    DWORD       m_dwAuthFlags;
    DWORD       m_dwSSLAccessPermissions;
    CString     m_strBasicDomain;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3SecurityPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3SecurityPage)
    afx_msg void OnButtonAuthentication();
    afx_msg void OnButtonCommunications();
    afx_msg void OnButtonIpSecurity();
    afx_msg void OnButtonGetCertificates();
    afx_msg void OnButtonViewCertificates();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    BOOL FetchSSLState();
    void SetSSLControlState();

    LPCTSTR QueryInstanceMetaPath();

//
// Sheet Access
//
protected:
    CBlob & GetIPL() { return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().m_ipl; }

private:
    BOOL        m_fIpDirty;
    BOOL        m_fDefaultGranted;
    BOOL        m_fOldDefaultGranted;
    BOOL        m_fPasswordSync;
    BOOL        m_fCertInstalled;
    BOOL        m_fU2Installed;
    BOOL        m_fHome;
    CString     m_strAnonUserName;
    CString     m_strAnonPassword;
    CObListPlus m_oblAccessList;
    //
    // Certificate and CTL information
    //
    CBlob       m_CertHash;
    CString     m_strCertStoreName;
    CString     m_strCTLIdentifier;
    CString     m_strCTLStoreName;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CW3SecurityPage::QueryInstanceMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}

#endif // __SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\rat.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CRat wrapper class

class CRat : public CWnd
{
protected:
    DECLARE_DYNCREATE(CRat)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634607, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    short GetBorderStyle();
    void SetBorderStyle(short);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
    void DoClick();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\seldate.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        seldate.cpp

   Abstract:

        Date selector dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "seldate.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CSelDate::CSelDate(
    IN CTime tm,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Date selector dialog constructor

Arguments:

    CTime tm,
    CWnd * pParent OPTIONAL

Return Value:

    None

--*/
    : m_tm(tm),
      CDialog(CSelDate::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSelDate)
    //}}AFX_DATA_INIT
}

void
CSelDate::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store Control Data

Arguments:

    CDataExchange * pDX : Data exchange object

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSelDate)
    DDX_Control(pDX, IDC_MSACALCTRL, m_cal);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CSelDate, CDialog)
    //{{AFX_MSG_MAP(CSelDate)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL
IsSystemDBCS()
/*++

Routine Description:

    Helper function to determine if we're running on a DBCS function

Arguments:

    None

Return Value:

    TRUE if we're on a DBCS system, FALSE otherwise.

--*/
{
    WORD wPrimaryLangID = PRIMARYLANGID(GetSystemDefaultLangID());

    return wPrimaryLangID == LANG_JAPANESE
        || wPrimaryLangID == LANG_CHINESE
        || wPrimaryLangID == LANG_KOREAN;
}

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CSelDate::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Note: SetMonth before SetDay, otherwise the 31 is not
    // considered a valid date.
    //
    m_cal.SetBackColor(GetSysColor(COLOR_BTNFACE));
    m_cal.SetYear((SHORT)m_tm.GetYear());
    m_cal.SetMonth((SHORT)m_tm.GetMonth());
    m_cal.SetDay((SHORT)m_tm.GetDay());

    if (IsSystemDBCS())
    {
        //
        // Set localisation defaults (override dlginit settings,
        // inserted by the msdev dialog editor)  This is necessary
        // to override a problem in DBCS version of calendar OCX.
        //
        m_cal.SetDayLength(0);
        m_cal.SetMonthLength(0);
        m_cal.SetDayFont(NULL);
        m_cal.SetGridFont(NULL);
        m_cal.SetTitleFont(NULL);
    }

    return TRUE;
}

void
CSelDate::OnOK()
/*++

Routine Description:

    'OK' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int year = m_cal.GetYear();
    int month = m_cal.GetMonth();
    int day = m_cal.GetDay();
    int hour = m_tm.GetHour();
    int minute = m_tm.GetMinute();
    int sec = m_tm.GetSecond();

    if (!year || !month || !day)
    {
        ::AfxMessageBox(IDS_NO_DATE);
        return;
    }

    if (year > 2037 || year < 1970)
    {
        ::AfxMessageBox(IDS_BAD_DATE);
        return;
    }

    m_tm = CTime(year, month, day, hour, minute, sec);

    if (m_tm <= CTime::GetCurrentTime())
    {
        if (::AfxMessageBox(IDS_WRN_OLD_DATE, MB_YESNO) != IDYES)
        {
            return;
        }
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\security.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.cpp

   Abstract:

        WWW Security Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "wincrypt.h"

#include "w3scfg.h"
#include "security.h"
#include "authent.h"
#include "seccom.h"
#include "ipdomdlg.h"

#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CW3SecurityPage property page
//
IMPLEMENT_DYNCREATE(CW3SecurityPage, CInetPropertyPage)



CW3SecurityPage::CW3SecurityPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL  fHome,
    IN DWORD dwAttributes
    )
/*++

Routine Description:

    Constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet object
    BOOL fHome                  : TRUE if this is a home directory
    DWORD dwAttributes          : Attributes

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3SecurityPage::IDD, pSheet,
        IS_FILE(dwAttributes)
            ? IDS_TAB_FILE_SECURITY
            : IDS_TAB_DIR_SECURITY
            ),
      m_oblAccessList(),
      m_fU2Installed(FALSE),
      m_fIpDirty(FALSE),
      m_fHome(fHome),
      //
      // By default, we grant access
      //
      m_fOldDefaultGranted(TRUE),
      m_fDefaultGranted(TRUE)   
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3SecurityPage)
    m_fUseNTMapper = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

}


CW3SecurityPage::~CW3SecurityPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CW3SecurityPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3SecurityPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_DS, m_fUseNTMapper);
    DDX_Control(pDX, IDC_ICON_SECURE, m_icon_Secure);
    DDX_Control(pDX, IDC_STATIC_SSL_PROMPT, m_static_SSLPrompt);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DS, m_check_EnableDS);
    DDX_Control(pDX, IDC_BUTTON_GET_CERTIFICATES, m_button_GetCertificates);
    DDX_Control(pDX, IDC_VIEW_CERTIFICATE, m_button_ViewCertificates);
    DDX_Control(pDX, IDC_BUTTON_COMMUNICATIONS, m_button_Communications);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3SecurityPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3SecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_AUTHENTICATION, OnButtonAuthentication)
    ON_BN_CLICKED(IDC_BUTTON_COMMUNICATIONS, OnButtonCommunications)
    ON_BN_CLICKED(IDC_BUTTON_IP_SECURITY, OnButtonIpSecurity)
    ON_BN_CLICKED(IDC_BUTTON_GET_CERTIFICATES, OnButtonGetCertificates)
    ON_BN_CLICKED(IDC_VIEW_CERTIFICATE, OnButtonViewCertificates)
    //}}AFX_MSG_MAP

    ON_BN_CLICKED(IDC_CHECK_ENABLE_DS, OnItemChanged)

END_MESSAGE_MAP()



/* virtual */
HRESULT
CW3SecurityPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_dwAuthFlags);
        FETCH_DIR_DATA_FROM_SHEET(m_dwSSLAccessPermissions);
        FETCH_DIR_DATA_FROM_SHEET(m_strBasicDomain);
        FETCH_DIR_DATA_FROM_SHEET(m_strAnonUserName);
        FETCH_DIR_DATA_FROM_SHEET(m_strAnonPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_fPasswordSync);
        FETCH_DIR_DATA_FROM_SHEET(m_fU2Installed);        
        FETCH_DIR_DATA_FROM_SHEET(m_fUseNTMapper);
    END_META_DIR_READ(err)

    //
    // First we need to read in the hash and the name of the store. If either
    // is not there then there is no certificate.
    //
    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_strCertStoreName);
        FETCH_INST_DATA_FROM_SHEET(m_strCTLIdentifier);
        FETCH_INST_DATA_FROM_SHEET(m_strCTLStoreName);
    END_META_INST_READ(err) 

    //
    // Build the IPL list
    //
    err = BuildIplOblistFromBlob(
        GetIPL(),
        m_oblAccessList,
        m_fDefaultGranted
        );

    m_fOldDefaultGranted = m_fDefaultGranted;


    return err;
}



/* virtual */
HR