ize,
	IN	PVOID					LkBuf,
	IN	UINT					LkBufSize,
	IN	UINT					PktSize
);

ATALK_ERROR
ArapAdapterInit(
	IN OUT PPORT_DESCRIPTOR	pPortDesc
);

VOID
AtalkSendComplete(
	IN	NDIS_HANDLE				ProtoBindCtx,
	IN	PNDIS_PACKET			NdisPkt,
	IN	NDIS_STATUS				NdisStatus
);


VOID
AtalkBindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE	 BindContext,
	IN	PNDIS_STRING DeviceName,
	IN	PVOID		 SystemSpecific1,
	IN	PVOID		 SystemSpecific2
);

VOID
AtalkUnbindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE	UnbindContext
	);

NDIS_STATUS
AtalkPnPHandler(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT NetPnPEvent
);


NDIS_STATUS
AtalkPnPReconfigure(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT NetPnPEvent
);


NTSTATUS
AtalkPnPDisableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
);


NTSTATUS
AtalkPnPEnableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
);


PPORT_DESCRIPTOR
AtalkFindDefaultPort(
    IN  VOID
);

//	Receive indication copy macro. This accomodates shared memory copies.
#define	ATALK_RECV_INDICATION_COPY(_pPortDesc, _pDest, _pSrc, _Len)		\
	{																	\
		TdiCopyLookaheadData(_pDest,									\
							 _pSrc,										\
							 _Len,										\
							 ((_pPortDesc)->pd_MacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) ? \
									TDI_RECEIVE_COPY_LOOKAHEAD : 0);	\
	}

LOCAL NDIS_STATUS
atalkNdisInitInitializeResources(
	VOID
);


#endif	// _ATKNDIS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkstat.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkstat.h

Abstract:

	This file defines the statistics structure used whene PROFILING is turned on

Author:

	Jameel Hyder (microsoft!jameelh)
	Nikhil Kamkolkar (microsoft!nikhilk)


Revision History:
	10 Mar 1993             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _ATKSTAT_
#define _ATKSTAT_

#define	MAX_PORTNAME_LEN	        32
#define MAX_INTERNAL_PORTNAME_LEN   64

extern	ATALK_SPIN_LOCK		AtalkStatsLock;
#if	DBG
extern	LONG				AtalkMemLimit;
#endif

// NOTE: This structure should be sized 8*N so that the array of them have all
//		 LARGE_INTEGERs aligned
typedef	struct _AtalkPortStatistics
{
	LARGE_INTEGER		prtst_DataIn;
	LARGE_INTEGER		prtst_DataOut;
	LARGE_INTEGER		prtst_DdpPacketInProcessTime;
	LARGE_INTEGER		prtst_AarpPacketInProcessTime;
	LARGE_INTEGER		prtst_NbpPacketInProcessTime;
	LARGE_INTEGER		prtst_ZipPacketInProcessTime;
	LARGE_INTEGER		prtst_RtmpPacketInProcessTime;

#ifdef	PROFILING
	LARGE_INTEGER		prtst_RcvIndProcessTime;
	LARGE_INTEGER		prtst_RcvCompProcessTime;
	ULONG				prtst_RcvIndCount;
	ULONG				prtst_RcvCompCount;
	ULONG				prtst_CurReceiveQueue;
	ULONG				prtst_CurSendsOutstanding;
#endif

	ULONG				prtst_NumPacketsIn;
	ULONG				prtst_NumPacketsOut;
	ULONG				prtst_NumDdpPacketsIn;
	ULONG				prtst_NumAarpProbesOut;
	ULONG				prtst_NumAarpPacketsIn;
	ULONG				prtst_NumNbpPacketsIn;
	ULONG				prtst_NumZipPacketsIn;
	ULONG				prtst_NumRtmpPacketsIn;

	//	Routing information
	ULONG				prtst_NumPktRoutedIn;
	ULONG				prtst_NumPktRoutedOut;

	//	Keep track of how many packets were dropped.
	ULONG				prtst_NumPktDropped;
	ULONG				prtst_Dummy;				// Keep the size 8*N for alignment

	// Port name for use by perfmon
	WCHAR				prtst_PortName[MAX_INTERNAL_PORTNAME_LEN];
} ATALK_PORT_STATS, *PATALK_PORT_STATS;

typedef struct _AtalkStatistics
{
	LARGE_INTEGER		stat_PerfFreq;
	LARGE_INTEGER		stat_AtpPacketInProcessTime;
#ifdef	PROFILING
	LARGE_INTEGER		stat_AtpIndicationProcessTime;
	LARGE_INTEGER		stat_AtpReqHndlrProcessTime;
	LARGE_INTEGER		stat_AtpReqTimerProcessTime;
	LARGE_INTEGER		stat_AtpRelTimerProcessTime;
	LARGE_INTEGER		stat_AspSmtProcessTime;
	LARGE_INTEGER		stat_ExAllocPoolTime;
	LARGE_INTEGER		stat_ExFreePoolTime;
	LARGE_INTEGER		stat_BPAllocTime;
	LARGE_INTEGER		stat_BPFreeTime;
	ULONG				stat_AtpNumIndications;
	ULONG				stat_AtpNumRequests;
	ULONG				stat_AtpNumReqTimer;
	ULONG				stat_AtpNumRelTimer;
	ULONG				stat_AtpNumReqHndlr;
	ULONG				stat_TotalAspSessions;
	ULONG				stat_AspSessionsDropped;
	ULONG				stat_AspSessionsClosed;
	ULONG				stat_AspSmtCount;
	ULONG				stat_MaxAspSessions;
	ULONG				stat_CurAspSessions;
	ULONG				stat_LastAspRTT;
	ULONG				stat_MaxAspRTT;
	ULONG				stat_LastPapRTT;
	ULONG				stat_MaxPapRTT;
	ULONG				stat_CurAllocCount;
	ULONG				stat_CurMdlCount;
	ULONG				stat_ExAllocPoolCount;
	ULONG				stat_ExFreePoolCount;
	ULONG				stat_BPAllocCount;
	ULONG				stat_BPFreeCount;
	ULONG				stat_NumBPHits;
	ULONG				stat_NumBPMisses;
	ULONG				stat_NumBPAge;
	ULONG				stat_ElapsedTime;
#endif
	ULONG				stat_AtpNumPackets;
	ULONG				stat_AtpNumLocalRetries;
	ULONG				stat_AtpNumRemoteRetries;
	ULONG				stat_AtpNumXoResponse;
	ULONG				stat_AtpNumAloResponse;
	ULONG				stat_AtpNumRecdRelease;
	ULONG				stat_AtpNumRespTimeout;
	ULONG				stat_CurAllocSize;
	ULONG				stat_NumActivePorts;
	ULONG				stat_Dummy;				// Keep the size 8*N for alignment
} ATALK_STATS, *PATALK_STATS;

extern	ATALK_STATS			AtalkStatistics;

#endif	// _ATKSTAT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkquery.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkquery.h

Abstract:

	TDI Query/Statistics header file

Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	10 Jul 1992	 Initial Version

--*/

#ifndef	_ATKQUERY_
#define	_ATKQUERY_

#define ATALK_TDI_PROVIDERINFO_VERSION		0x0001

#define ATALK_DDP_PINFODGRAMSIZE			586
#define ATALK_DDP_PINFOSERVICEFLAGS			(TDI_SERVICE_CONNECTIONLESS_MODE	| \
											 TDI_SERVICE_BROADCAST_SUPPORTED	| \
											 TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ATP_PINFOSENDSIZE				0
#define ATALK_ATP_PINFOSERVICEFLAGS			(TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ADSP_PINFOSENDSIZE			0
#define ATALK_ADSP_PINFOSERVICEFLAGS		(TDI_SERVICE_CONNECTION_MODE		| \
											 TDI_SERVICE_ERROR_FREE_DELIVERY	| \
											 TDI_SERVICE_EXPEDITED_DATA			| \
											 TDI_SERVICE_INTERNAL_BUFFERING		| \
											 TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ASP_PINFOSENDSIZE				0
#define ATALK_ASP_PINFOSERVICEFLAGS			(TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_PAP_PINFOSENDSIZE				0
#define ATALK_PAP_PINFOSERVICEFLAGS			(TDI_SERVICE_CONNECTION_MODE		| \
											 TDI_SERVICE_ERROR_FREE_DELIVERY	| \
											 TDI_SERVICE_EXPEDITED_DATA			| \
											 TDI_SERVICE_INTERNAL_BUFFERING		| \
											 TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ARAP_PINFOSENDSIZE			0
#define ATALK_ARAP_PINFOSERVICEFLAGS		(TDI_SERVICE_FORCE_ACCESS_CHECK)

//
//	ROUTINE PROTOTYPES
//

VOID
AtalkQueryInitProviderInfo(
	IN		ATALK_DEV_TYPE		DeviceType,
	IN OUT	PTDI_PROVIDER_INFO  ProviderInfo
);

#endif	// _ATKQUERY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atktdi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktdi.c

Abstract:

	This module contains the code providing the tdi interface.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKTDI

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkLockInit)
#pragma alloc_text(PAGE, AtalkTdiOpenAddress)
#pragma alloc_text(PAGE, AtalkTdiOpenConnection)
//#pragma alloc_text(PAGE, AtalkTdiOpenControlChannel)
#pragma alloc_text(PAGE, AtalkTdiAction)
#pragma alloc_text(PAGE, atalkQueuedLockUnlock)
#pragma alloc_text(PAGE_TDI, AtalkTdiCleanupAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiCleanupConnection)
#pragma alloc_text(PAGE_TDI, AtalkTdiCloseAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiCloseConnection)
#pragma alloc_text(PAGE_TDI, AtalkTdiCloseControlChannel)
#pragma alloc_text(PAGE_TDI, AtalkTdiAssociateAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiDisassociateAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiConnect)
#pragma alloc_text(PAGE_TDI, AtalkTdiDisconnect)
#pragma alloc_text(PAGE_TDI, AtalkTdiAccept)
#pragma alloc_text(PAGE_TDI, AtalkTdiListen)
#pragma alloc_text(PAGE_TDI, AtalkTdiSend)
#pragma alloc_text(PAGE_TDI, AtalkTdiSendDgram)
#pragma alloc_text(PAGE_TDI, AtalkTdiReceive)
#pragma alloc_text(PAGE_TDI, AtalkTdiReceiveDgram)
#pragma alloc_text(PAGE_TDI, AtalkTdiQueryInformation)
#pragma alloc_text(PAGE_TDI, AtalkTdiSetInformation)
#pragma alloc_text(PAGE_TDI, AtalkTdiSetEventHandler)
#pragma alloc_text(PAGE_TDI, AtalkTdiCancel)
#pragma alloc_text(PAGE_TDI, AtalkQueryInitProviderInfo)
#pragma alloc_text(PAGE_TDI, atalkTdiActionComplete)
#pragma alloc_text(PAGE_TDI, atalkTdiGenericComplete)
#pragma alloc_text(PAGE_TDI, atalkTdiGenericReadComplete)
#pragma alloc_text(PAGE_TDI, atalkTdiGenericWriteComplete)
#endif

// Primary TDI Functions for appletalk stack

NTSTATUS
AtalkTdiOpenAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN		PTA_APPLETALK_ADDRESS	pTdiAddr,
	IN		BYTE					ProtoType,
	IN		BYTE					SocketType,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is used to create an address object. It will also the
	create the appropriate socket with the portable stack.

Arguments:


Return Value:

	STATUS_SUCCESS if address was successfully opened
	Error otherwise.

--*/
{
	PVOID			FsContext;
	ATALK_ADDR		atalkAddr;
	ATALK_ERROR		error;

	do
	{
		atalkWaitDefaultPort();
		// We honor only if count/type and length are as we expect. And only if the
		// default port is valid.
		if ((AtalkDefaultPort == NULL)												||
            (AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE)                       ||
			(pTdiAddr->TAAddressCount != 1)											||
			(pTdiAddr->Address[0].AddressLength < sizeof(TDI_ADDRESS_APPLETALK))	||
			(pTdiAddr->Address[0].AddressType != TDI_ADDRESS_TYPE_APPLETALK))
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiOpenAddress: returning STATUS_INVALID_ADDRESS (%lx)\n",AtalkDefaultPort));

			error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
			break;
		}

		TDI_TO_ATALKADDR(&atalkAddr, pTdiAddr);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			error = AtalkDdpOpenAddress(AtalkDefaultPort,
										atalkAddr.ata_Socket,
										NULL,					// Desired node (any node)
										NULL,					// NULL Socket Handler
										NULL,					// Context for handler
										ProtoType,
										pCtx,
										(PDDP_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ASPC:
			AtalkLockAspCIfNecessary();
			error = AtalkAspCCreateAddress(pCtx, (PASPC_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ASP:
			AtalkLockAspIfNecessary();
			error = AtalkAspCreateAddress((PASP_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_PAP:
			AtalkLockPapIfNecessary();
			error = AtalkPapCreateAddress(pCtx, (PPAP_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ADSP:
			AtalkLockAdspIfNecessary();
			error = AtalkAdspCreateAddress(pCtx,
										   SocketType,
										   (PADSP_ADDROBJ *)(&FsContext));
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
            error = ATALK_INVALID_REQUEST;
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiOpenAddress: Invalid device type\n"));
			break;
		}

		if (ATALK_SUCCESS(error))
		{
			pIrpSp->FileObject->FsContext2 =
				(PVOID)((ULONG_PTR)(TDI_TRANSPORT_ADDRESS_FILE + (pCtx->adc_DevType << 16)));

			pIrpSp->FileObject->FsContext = FsContext;
			AtalkLockTdiIfNecessary();
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiOpenConnection(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN		CONNECTION_CONTEXT		ConnCtx,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is used to create a connection object and associate the
	passed ConnectionContext with it.

Arguments:

	ConnectionContext - The TDI ConnectionContext to be associated with object
	Context - The DeviceContext of the device on which open is happening

Return Value:

	STATUS_SUCCESS if connection was successfully opened
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		atalkWaitDefaultPort();
		// Only if the default port is valid.
		if (AtalkDefaultPort == NULL)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiOpenConnection: returning STATUS_INVALID_ADDRESS\n"));

			error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
			break;
		}

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			AtalkLockPapIfNecessary();
			error = AtalkPapCreateConnection(ConnCtx,
											 pCtx,
											 (PPAP_CONNOBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ADSP:
			AtalkLockAdspIfNecessary();
			error = AtalkAdspCreateConnection(ConnCtx,
											  pCtx,
											  (PADSP_CONNOBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ASPC:
			AtalkLockAspCIfNecessary();
			error = AtalkAspCCreateConnection(ConnCtx,
											  pCtx,
											  (PASPC_CONNOBJ *)(&FsContext));
			break;
		}

		if (ATALK_SUCCESS(error))
		{
			pIrpSp->FileObject->FsContext2 = (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE +
													 (pCtx->adc_DevType << 16)));
			pIrpSp->FileObject->FsContext = FsContext;
			AtalkLockTdiIfNecessary();
		}
		
		ASSERT(error == ATALK_NO_ERROR);

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiOpenControlChannel(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is used to create a control channel

Arguments:

	Context - The DeviceContext of the device on which open is happening

Return Value:

	STATUS_SUCCESS if controlchannel was successfully opened
	Error otherwise.

--*/
{
	PDDP_ADDROBJ	pDdpAddr;
	ATALK_ERROR		error = ATALK_INVALID_REQUEST;
    KIRQL           OldIrql;

	do
	{
		if (pCtx->adc_DevType != ATALK_DEV_ARAP)
		{
			atalkWaitDefaultPort();
			// Only if the default port is valid.
			if (AtalkDefaultPort == NULL)
			{
				DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
						("AtalkTdiOpenControlChannel: NOT ATALK_DEV_ARAP: returning STATUS_INVALID_ADDRESS\n"));
				if (!AtalkNoDefPortPrinted)
				{
					LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, 0, NULL, 0);
					AtalkNoDefPortPrinted = TRUE;
				}

				error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
				break;
			}
        }

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
		  case ATALK_DEV_ASP:
		  case ATALK_DEV_PAP:
		  case ATALK_DEV_ADSP:
          case ATALK_DEV_ASPC:

			error = AtalkDdpOpenAddress(AtalkDefaultPort,
										UNKNOWN_SOCKET,
										NULL,
										NULL,
										NULL,
										0,
										pCtx,
										&pDdpAddr);
			break;

          case ATALK_DEV_ARAP:

            if (AtalkDefaultPort == NULL)
            {
			    DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				    ("AtalkTdiOpenControlChannel: device is ATALK_DEV_ARAP: returning STATUS_INVALID_ADDRESS\n"));
				if (!AtalkNoDefPortPrinted)
				{
					LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, 0, NULL, 0);
					AtalkNoDefPortPrinted = TRUE;
				}
                error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
                break;
            }

			DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,("RAS device opened\n"));

#if DBG
            KeQuerySystemTime(&ArapDbgLastTraceTime);
#endif
            error = ATALK_NO_ERROR;
            break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiOpenControlChannel: Invalid device type\n"));
			break;
		}

		if (ATALK_SUCCESS(error))
		{
			pIrpSp->FileObject->FsContext2 =
					(PVOID)((ULONG_PTR)(TDI_CONTROL_CHANNEL_FILE + (pCtx->adc_DevType << 16)));
			pIrpSp->FileObject->FsContext = pDdpAddr;
			AtalkLockTdiIfNecessary();
		}
		else
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiOpenControlChannel: Failed %ld\n", error));
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCleanupAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR	error;
	PVOID		pAddrObj = pIrpSp->FileObject->FsContext;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			if (!(VALID_DDP_ADDROBJ(((PDDP_ADDROBJ)pAddrObj))))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkDdpReferenceByPtr(((PDDP_ADDROBJ)pAddrObj), &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkDdpCleanupAddress((PDDP_ADDROBJ)pAddrObj);
				AtalkDdpDereference(((PDDP_ADDROBJ)pAddrObj));
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCAO((PASPC_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAspCIfNecessary();
			AtalkAspCAddrReference((PASPC_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkAspCCleanupAddress((PASPC_ADDROBJ)pAddrObj);
				AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;

		  case ATALK_DEV_ASP:
			error = ATALK_NO_ERROR;
			break;

		  case ATALK_DEV_PAP:
			if (!(VALID_PAPAO((PPAP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapAddrReference((PPAP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkPapCleanupAddress((PPAP_ADDROBJ)pAddrObj);
				AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPAO((PADSP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspAddrReference((PADSP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkAdspCleanupAddress((PADSP_ADDROBJ)pAddrObj);
				AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiCleanupAddress: Invalid device type\n"));
			error = ATALK_INVALID_REQUEST;
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCleanupConnection(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR	error;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:

			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				//	No need to have lock as we have a reference.
				((PPAP_CONNOBJ)pConnObj)->papco_CleanupComp = atalkTdiGenericComplete;
				((PPAP_CONNOBJ)pConnObj)->papco_CleanupCtx  = pIrp;

				DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
						("AtalkTdiCleanupConnection: Cleanup %lx.%lx\n",
						pConnObj, pIrp));

				AtalkPapCleanupConnection((PPAP_CONNOBJ)pConnObj);
				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			    error = ATALK_PENDING;
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				//	No need to have lock as we have a reference.
				((PADSP_CONNOBJ)pConnObj)->adspco_CleanupComp = atalkTdiGenericComplete;
				((PADSP_CONNOBJ)pConnObj)->adspco_CleanupCtx  = pIrp;
				AtalkAdspCleanupConnection((PADSP_CONNOBJ)pConnObj);
				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			    error = ATALK_PENDING;
			}
            AtalkUnlockAdspIfNecessary();
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAspCIfNecessary();
			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				//	No need to have lock as we have a reference.
				((PASPC_CONNOBJ)pConnObj)->aspcco_CleanupComp = atalkTdiGenericComplete;
				((PASPC_CONNOBJ)pConnObj)->aspcco_CleanupCtx  = pIrp;
				AtalkAspCCleanupConnection((PASPC_CONNOBJ)pConnObj);
				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			    error = ATALK_PENDING;
			}
            AtalkUnlockAspCIfNecessary();
			break;

		  case ATALK_DEV_DDP:
		  default:

			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiCleanupConnection: Invalid device type\n"));
			error = ATALK_INVALID_REQUEST;
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}



NTSTATUS
AtalkTdiCloseAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR	error;
	PVOID		pAddrObj = pIrpSp->FileObject->FsContext;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			if (!(VALID_DDP_ADDROBJ(((PDDP_ADDROBJ)pAddrObj))))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkDdpReferenceByPtr(((PDDP_ADDROBJ)pAddrObj), &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkDdpCloseAddress((PDDP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkDdpDereference(((PDDP_ADDROBJ)pAddrObj));
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCAO((PASPC_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkAspCAddrReference((PASPC_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCCloseAddress((PASPC_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
			}
			break;

		  case ATALK_DEV_ASP:
			if (!(VALID_ASPAO((PASP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			if (AtalkAspReferenceAddr((PASP_ADDROBJ)pAddrObj) != NULL)
			{
				error = AtalkAspCloseAddress((PASP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);
				AtalkAspDereferenceAddr((PASP_ADDROBJ)pAddrObj);
			}
			break;

		  case ATALK_DEV_PAP:
			if (!(VALID_PAPAO((PPAP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkPapAddrReference((PPAP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapCloseAddress((PPAP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPAO((PADSP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkAdspAddrReference((PADSP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspCloseAddress((PADSP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
			}
			break;

		  default:

			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			error = ATALK_INVALID_REQUEST;
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiCloseAddress: Invalid device type\n"));
			break;
		}

	} while (FALSE);

	if (error == ATALK_NO_ERROR)
		error = ATALK_PENDING;

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCloseConnection(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR		error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapCloseConnection((PPAP_CONNOBJ)pConnObj,
												atalkTdiCloseAddressComplete,
												pIrp);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspCloseConnection((PADSP_CONNOBJ)pConnObj,
												 atalkTdiCloseAddressComplete,
												 pIrp);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

          case ATALK_DEV_ASPC:

			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAspCIfNecessary();
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                AtalkUnlockAspCIfNecessary();
                break;
            }

			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCCloseConnection((PASPC_CONNOBJ)pConnObj,
												 atalkTdiCloseAddressComplete,
												 pIrp);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;
		}

	} while (FALSE);

	if (error == ATALK_NO_ERROR)
		error = ATALK_PENDING;

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCloseControlChannel(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR		error;
	PVOID			pCtrlChnl = pIrpSp->FileObject->FsContext;
    KIRQL           OldIrql;


    if (pCtx->adc_DevType == ATALK_DEV_ARAP)
    {
        ArapReleaseResources();

		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("AtalkTdiCloseAddress: RAS device closed\n"));

        // flip the state, so if engine restarts, we tell the engine
        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        if (ArapStackState == ARAP_STATE_ACTIVE)
        {
            ArapStackState = ARAP_STATE_ACTIVE_WAITING;
        }
        else if (ArapStackState == ARAP_STATE_INACTIVE)
        {
            ArapStackState = ARAP_STATE_INACTIVE_WAITING;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

        AtalkUnlockTdiIfNecessary();

        return(STATUS_SUCCESS);
    }


	if (!(VALID_DDP_ADDROBJ((PDDP_ADDROBJ)pCtrlChnl)))
    {
        ASSERT(0);
        error = ATALK_INVALID_ADDRESS;
	    return AtalkErrorToNtStatus(error);
    }

	AtalkDdpReferenceByPtr(((PDDP_ADDROBJ)pCtrlChnl), &error);
	if (ATALK_SUCCESS(error))
	{
		error = AtalkDdpCloseAddress(((PDDP_ADDROBJ)pCtrlChnl),
									  atalkTdiCloseAddressComplete,
									  pIrp);
		AtalkDdpDereference(((PDDP_ADDROBJ)pCtrlChnl));
	}

	return AtalkErrorToNtStatus(error);
}



NTSTATUS
AtalkTdiAssociateAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will associate the connection object with the specified
	address object.

	This routine is pretty much provider independent. All we check for is
	that the address object and the provider object belong to the same device.
	Also, this routine will complete synchronously.

Arguments:


Return Value:

	STATUS_SUCCESS if successfully completed
	Error otherwise.

--*/
{
	ATALK_ERROR		error = ATALK_INVALID_REQUEST;
	PVOID			pAddrObj;
	PVOID			pConnObj = pIrpSp->FileObject->FsContext;
	PFILE_OBJECT	pFileObj = NULL;
	HANDLE			AddrObjHandle =
			((PTDI_REQUEST_KERNEL_ASSOCIATE)(&pIrpSp->Parameters))->AddressHandle;
    PDEVICE_OBJECT  pDeviceObject;
	NTSTATUS		status;
    DWORD           i;


	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		// Get the handle to the address object from the irp and map it to
		// the corres. file object.
		{
			status = ObReferenceObjectByHandle(AddrObjHandle,
											   0,
											   *IoFileObjectType,
											   pIrp->RequestorMode,
											   (PVOID *)&pFileObj,
										       NULL);
			ASSERT (NT_SUCCESS(status));

            if (!NT_SUCCESS(status))
            {
                return(status);
            }
		}


        pDeviceObject = IoGetRelatedDeviceObject(pFileObj);

        status = STATUS_OBJECT_NAME_INVALID;

        for (i=0; i < ATALK_NO_DEVICES; i++ )
        {
            if (pDeviceObject == (PDEVICE_OBJECT)AtalkDeviceObject[i])
            {
                status = STATUS_SUCCESS;
                break;
            }
        }

        if (!NT_SUCCESS(status))
        {
	        DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			    ("AtalkTdiAssociateAddress: wrong devObject %lx\n",pDeviceObject));
            ASSERT(0);
            return(status);
        }

		pAddrObj = pFileObj->FsContext;

		ASSERT(((LONG_PTR)pFileObj->FsContext2 >> 16) == pCtx->adc_DevType);

		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:

			if (!(VALID_PAPAO((PPAP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapAddrReference((PPAP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_CONNECTION;
                    AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
                    break;
                }
				AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
				if (ATALK_SUCCESS(error))
				{
					error = AtalkPapAssociateAddress((PPAP_ADDROBJ)pAddrObj,
													 (PPAP_CONNOBJ)pConnObj);
					AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
				}

				AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPAO((PADSP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspAddrReference((PADSP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_CONNECTION;
                    AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
                    break;
                }
				AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
				if (ATALK_SUCCESS(error))
				{
					error = AtalkAdspAssociateAddress((PADSP_ADDROBJ)pAddrObj,
													  (PADSP_CONNOBJ)pConnObj);
					AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
				}

				AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCAO((PASPC_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAspCIfNecessary();
			AtalkAspCAddrReference((PASPC_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_CONNECTION;
                    AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
                    break;
                }
				AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
				if (ATALK_SUCCESS(error))
				{
					error = AtalkAspCAssociateAddress((PASPC_ADDROBJ)pAddrObj,
													  (PASPC_CONNOBJ)pConnObj);
					AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
				}

				AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;
		}

		// Dereference the file object corres. to the address object
		ObDereferenceObject(pFileObj);

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiDisassociateAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine performs a disassociate. This request is only valid when
	the connection is in a purely ASSOCIATED state.

Arguments:


Return Value:

	STATUS_SUCCESS if successfully completed
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			// Reference the connection object
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapDissociateAddress(pConnObj);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			// Reference the connection object
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspDissociateAddress(pConnObj);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

        case ATALK_DEV_ASPC:

			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAspCIfNecessary();
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                AtalkUnlockAspCIfNecessary();
                break;
            }

			// Reference the connection object
			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCDissociateAddress(pConnObj);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiConnect(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will post a connect request with the portable stack.

Arguments:

Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PTDI_REQUEST_KERNEL_CONNECT	parameters;
	PTA_APPLETALK_ADDRESS		remoteTdiAddr;
	ATALK_ADDR					remoteAddr;
	ATALK_ERROR					error = ATALK_INVALID_REQUEST;
	PVOID						pConnObj = pIrpSp->FileObject->FsContext;

	parameters 		= (PTDI_REQUEST_KERNEL_CONNECT)&pIrpSp->Parameters;
	remoteTdiAddr  	= (PTA_APPLETALK_ADDRESS)
						parameters->RequestConnectionInformation->RemoteAddress;

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("AtalkTdiConnect: Net %x Node %x Socket %x\n",
			remoteTdiAddr->Address[0].Address[0].Network,
			remoteTdiAddr->Address[0].Address[0].Node,
			remoteTdiAddr->Address[0].Address[0].Socket));

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("AtalkConnPostConnect: Cnt %x\n", remoteTdiAddr->TAAddressCount));

	TDI_TO_ATALKADDR(&remoteAddr, remoteTdiAddr);

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("AtalkTdiConnect: Portable Net %x Node %x Socket %x\n",
			remoteAddr.ata_Network, remoteAddr.ata_Node, remoteAddr.ata_Socket));

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapPostConnect((PPAP_CONNOBJ)pConnObj,
											&remoteAddr,
											pIrp,
											atalkTdiGenericComplete);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspPostConnect((PADSP_CONNOBJ)pConnObj,
											 &remoteAddr,
											 pIrp,
											 atalkTdiGenericComplete);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                break;
            }

			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCPostConnect((PASPC_CONNOBJ)pConnObj,
											 &remoteAddr,
											 pIrp,
											 atalkTdiGenericComplete);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
			break;
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiDisconnect(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will disconnect an active connection or cancel a posted
	listen/connect

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapDisconnect((PPAP_CONNOBJ)pConnObj,
											ATALK_LOCAL_DISCONNECT,
											pIrp,
											atalkTdiGenericComplete);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspDisconnect((PADSP_CONNOBJ)pConnObj,
											ATALK_LOCAL_DISCONNECT,
											pIrp,
											atalkTdiGenericComplete);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ASPC:

            if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                break;
            }

			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCDisconnect((PASPC_CONNOBJ)pConnObj,
											ATALK_LOCAL_DISCONNECT,
											pIrp,
											atalkTdiGenericComplete);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
			break;
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiAccept(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS	status = STATUS_SUCCESS;

	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_ADSP:
		  case ATALK_DEV_PAP:
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiAccept: Invalid device type\n"));
		  case ATALK_DEV_DDP:
		  case ATALK_DEV_ASPC:
		  case ATALK_DEV_ASP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiListen(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:

				
Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapPostListen((PPAP_CONNOBJ)pConnObj,
											pIrp,
											atalkTdiGenericComplete);
				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspPostListen((PADSP_CONNOBJ)pConnObj,
											pIrp,
											atalkTdiGenericComplete);
				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
			break;
		}

	} while (FALSE);

	if (error == ATALK_NO_ERROR)
		error = ATALK_PENDING;

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiSendDgram(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine sends a datagram.

Arguments:

				
Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS		status = STATUS_SUCCESS;
	SEND_COMPL_INFO	SendInfo;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			{
				PTDI_REQUEST_KERNEL_SENDDG	pParam;
				PBUFFER_DESC				pBufDesc;
				ATALK_ERROR					error;
				PTA_APPLETALK_ADDRESS		pTaDest;
				ATALK_ADDR					AtalkAddr;
				PDDP_ADDROBJ				pDdpAddr;

				pDdpAddr  = (PDDP_ADDROBJ)pIrpSp->FileObject->FsContext;
				if (!(VALID_DDP_ADDROBJ(pDdpAddr)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_ADDRESS;
                    break;
                }
				
				pParam = (PTDI_REQUEST_KERNEL_SENDDG)&pIrpSp->Parameters;
				pTaDest = (PTA_APPLETALK_ADDRESS)
								pParam->SendDatagramInformation->RemoteAddress;
			
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
						("DDP: SendDatagram - Net %x Node %x Socket %x\n",
							pTaDest->Address[0].Address[0].Network,
							pTaDest->Address[0].Address[0].Node,
							pTaDest->Address[0].Address[0].Socket));
			
				if ((pTaDest->Address[0].AddressType != TDI_ADDRESS_TYPE_APPLETALK) ||
					(pTaDest->Address[0].AddressLength < sizeof(TDI_ADDRESS_APPLETALK)))
				{
			        DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				        ("AtalkTdiSendDgram: returning STATUS_INVALID_ADDRESS (Type %x Len %d)\n",
                        pTaDest->Address[0].AddressType,pTaDest->Address[0].AddressLength));

					status = STATUS_INVALID_ADDRESS;
				}
				else
				{
					ULONG	sendLength;
			
					AtalkAddr.ata_Network = pTaDest->Address[0].Address[0].Network;
					AtalkAddr.ata_Node = pTaDest->Address[0].Address[0].Node;
					AtalkAddr.ata_Socket = pTaDest->Address[0].Address[0].Socket;
			
					// Get the length of the send mdl
					sendLength = AtalkSizeMdlChain(pIrp->MdlAddress);

					//	Check destination address
					if (INVALID_ADDRESS(&AtalkAddr))
					{
						error = ATALK_DDP_INVALID_ADDR;
					}
				
					if (sendLength > MAX_DGRAM_SIZE)
					{
						error = ATALK_BUFFER_TOO_BIG;
					}

					else if ((pBufDesc = AtalkAllocBuffDesc(pIrp->MdlAddress,
															(USHORT)sendLength,
															0)) != NULL)
					{
						SendInfo.sc_TransmitCompletion = atalkTdiSendDgramComplete;
						SendInfo.sc_Ctx1 = pDdpAddr;
						SendInfo.sc_Ctx2 = pBufDesc;
						SendInfo.sc_Ctx3 = pIrp;
						error = AtalkDdpSend(pDdpAddr,
											 &AtalkAddr,
											 pDdpAddr->ddpao_Protocol,
											 FALSE,
											 pBufDesc,
											 NULL,	// OptHdr
											 0,		// OptHdrLen
											 NULL,	// ZoneMcastAddr
											 &SendInfo);

						if (!ATALK_SUCCESS(error))
						{
							atalkTdiSendDgramComplete(NDIS_STATUS_FAILURE,
													  &SendInfo);

							error = ATALK_PENDING;
						}
					}

					else error	= ATALK_RESR_MEM;
								
					status = AtalkErrorToNtStatus(error);
				}
			}
			break;

		  case ATALK_DEV_ASPC:
		  case ATALK_DEV_ADSP:
		  case ATALK_DEV_ASP:
		  case ATALK_DEV_PAP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiSendDatagram: Invalid device type\n"));
			break;
		}

	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiReceiveDgram(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine receives a datagram.

Arguments:

				
Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;

	if (pCtx->adc_DevType == ATALK_DEV_DDP)
	{
		PDDP_ADDROBJ					pDdpAddr;
		PTDI_REQUEST_KERNEL_RECEIVEDG	parameters =
										(PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;

		pDdpAddr  = (PDDP_ADDROBJ)pIrpSp->FileObject->FsContext;
		if (!(VALID_DDP_ADDROBJ(pDdpAddr)))
        {
            ASSERT(0);
            error = ATALK_INVALID_ADDRESS;
            return(AtalkErrorToNtStatus(error));
        }

		error = AtalkDdpReceive(pDdpAddr,
								pIrp->MdlAddress,
								(USHORT)AtalkSizeMdlChain(pIrp->MdlAddress),
								parameters->ReceiveFlags,
								atalkTdiRecvDgramComplete,
								pIrp);

	}

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiSend(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine sends the data specified. (used by PAP/ADSP only)

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PTDI_REQUEST_KERNEL_SEND	parameters;
	ATALK_ERROR					error = ATALK_INVALID_REQUEST;
	PVOID						pConnObj= pIrpSp->FileObject->FsContext;

	parameters = (PTDI_REQUEST_KERNEL_SEND)&pIrpSp->Parameters;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP))
	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkAdspWrite(pConnObj,
								   pIrp->MdlAddress,
								   (USHORT)parameters->SendLength,
								   parameters->SendFlags,
								   pIrp,
								   atalkTdiGenericWriteComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("AtalkAdspWrite: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PADSP_CONNOBJ)pConnObj)->adspco_Flags, error));
			}
			break;

		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkPapWrite(pConnObj,
								pIrp->MdlAddress,
								(USHORT)parameters->SendLength,
								parameters->SendFlags,
								pIrp,
								atalkTdiGenericWriteComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("AtalkPapWrite: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PPAP_CONNOBJ)pConnObj)->papco_Flags, error));
			}
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiReceive(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine receives data. (used by PAP/ADSP only)

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR					error = ATALK_INVALID_REQUEST;
	PVOID						pConnObj= pIrpSp->FileObject->FsContext;
	PTDI_REQUEST_KERNEL_RECEIVE	parameters =
									(PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ASPC)||
		(pCtx->adc_DevType == ATALK_DEV_ADSP))
	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkPapRead(pConnObj,
								 pIrp->MdlAddress,
								 (USHORT)parameters->ReceiveLength,
								 parameters->ReceiveFlags,
								 pIrp,
								 atalkTdiGenericReadComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("AtalkPapRead: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PPAP_CONNOBJ)pConnObj)->papco_Flags, error));
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			AtalkLockAdspIfNecessary();

			error = AtalkAdspRead(pConnObj,
								  pIrp->MdlAddress,
								  (USHORT)parameters->ReceiveLength,
								  parameters->ReceiveFlags,
								  pIrp,
								  atalkTdiGenericReadComplete);

            AtalkUnlockAdspIfNecessary();

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("AtalkAdspRead: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PADSP_CONNOBJ)pConnObj)->adspco_Flags, error));
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkAspCGetAttn(pConnObj,
									 pIrp->MdlAddress,
									 (USHORT)parameters->ReceiveLength,
									 parameters->ReceiveFlags,
									 pIrp,
									 atalkTdiGenericReadComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("AtalkAspCGetAttn: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PASPC_CONNOBJ)pConnObj)->aspcco_Flags, error));
			}
			break;
		}
	
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}



NTSTATUS
AtalkTdiAction(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is the dispatch routine for all the TdiAction primitives
	for all the providers

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS			status = STATUS_SUCCESS;
	ATALK_ERROR			error  = ATALK_NO_ERROR;
	USHORT				bufLen;
	USHORT				actionCode, Flags;
	PTDI_ACTION_HEADER	pActionHdr;
	PMDL				pMdl = pIrp->MdlAddress;
	PVOID				pObject;
	USHORT				ObjectType;
	USHORT				DevType;
	BOOLEAN				freeHdr = FALSE;

	do
	{
		if (pMdl == NULL)
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}
	
		bufLen = (USHORT)AtalkSizeMdlChain(pIrp->MdlAddress);
	
		// If we atleast do not have the action header, return
		if (bufLen < sizeof(TDI_ACTION_HEADER))
		{
			status = STATUS_INVALID_PARAMETER;
            ASSERT(0);
			break;
		}
	
		if (AtalkIsMdlFragmented(pMdl))
		{
			ULONG	bytesCopied;

			if ((pActionHdr = AtalkAllocMemory(sizeof(TDI_ACTION_HEADER))) == NULL)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			freeHdr = TRUE;

			//	Copy the header to this buffer
			status = TdiCopyMdlToBuffer(pMdl,
										0,							// SrcOff
										pActionHdr,
										0,							// Dest Off
										sizeof(TDI_ACTION_HEADER),
										&bytesCopied);

			ASSERT(NT_SUCCESS(status) && (bytesCopied == sizeof(TDI_ACTION_HEADER)));

			if (!NT_SUCCESS(status))
				break;
		}
		else
		{
			pActionHdr = (PTDI_ACTION_HEADER)MmGetSystemAddressForMdlSafe(
					pMdl, NormalPagePriority);

			if (pActionHdr == NULL) {
                ASSERT(0);
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

		}
	
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_INFO,
				("AtalkTdiAction - code %lx BufLen %d SysAddress %lx\n",
				pActionHdr->ActionCode, bufLen, pActionHdr));
	
		// If the MATK identifier is not present, we return
		if (pActionHdr->TransportId != MATK)
		{
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
	
		actionCode = pActionHdr->ActionCode;
		if ((actionCode < MIN_COMMON_ACTIONCODE) ||
			(actionCode > MAX_ALLACTIONCODES))
		{
			DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("AtalkTdiAction - Invalid action code %d\n", actionCode));
	
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		if (bufLen < AtalkActionDispatch[actionCode]._MinBufLen)
		{
			DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("AtalkTdiAction - Minbuflen %d Expected %d\n",
					bufLen, AtalkActionDispatch[actionCode]._MinBufLen));

			status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

        // if someone is trying to open ASP via usermode, reject it!
        if ((AtalkActionDispatch[actionCode]._OpCode == ACTION_ASP_BIND) &&
            (pIrp->RequestorMode != KernelMode))
        {
			status = STATUS_INVALID_PARAMETER;
            ASSERT(0);
			break;
        }

		Flags = AtalkActionDispatch[actionCode]._Flags;

		pObject = (PVOID)pIrpSp->FileObject->FsContext;
		ObjectType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF);
		DevType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) >> 16);
		// Convert control channel operations to Ddp
		if (ObjectType == TDI_CONTROL_CHANNEL_FILE)
			DevType = ATALK_DEV_DDP;

		// Verify the device type is that expected. Either the request
		// should be valid for any device or the type of device for the
		// request should match the type of device expected.
		if ((AtalkActionDispatch[actionCode]._DeviceType != ATALK_DEV_ANY) &&
			((pCtx->adc_DevType != AtalkActionDispatch[actionCode]._DeviceType) ||
			 (DevType != AtalkActionDispatch[actionCode]._DeviceType)))
		{
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}

		// Verify the object - it has to be one of those specified as valid
		// in the dispatch table for this action call.
		ASSERT(ObjectType & (DFLAG_ADDR | DFLAG_CNTR | DFLAG_CONN));

		switch (ObjectType)
		{
		  case TDI_TRANSPORT_ADDRESS_FILE:
			if (!(Flags & DFLAG_ADDR))
				status = STATUS_INVALID_HANDLE;
			break;

		  case TDI_CONNECTION_FILE:
			if (!(Flags & DFLAG_CONN))
				status = STATUS_INVALID_HANDLE;
			break;

		  case TDI_CONTROL_CHANNEL_FILE:
			if (!(Flags & DFLAG_CNTR))
				status = STATUS_INVALID_HANDLE;
			break;

		  default:
			status = STATUS_INVALID_HANDLE;
			break;
		}

	} while (FALSE);

	if (!NT_SUCCESS(status))
	{
		if (freeHdr)
		{
			AtalkFreeMemory(pActionHdr);
		}
		return status;
	}


	// Handle the requests based on the action code.
	// Use the table to call the appropriate routine

	do
	{
		PACTREQ				pActReq;
		USHORT				offset = AtalkActionDispatch[actionCode]._ActionBufSize;
		USHORT				size = bufLen - offset;

		// If DFLAG_MDL is set, then we know we have to create the mdl.
		//
		// NOTE:	User can pass in invalid sizes...
		//			Also, it is assumed that BuildMdl will not change
		//			value of the mdl unless it can successfully build
		//			all of it. Therefore, error cases must preserve
		//			value of NULL.
		//

		// First allocate an action request structure.
		// !!!This memory should be zeroed out as we depend on extra mdl pointer to
		//	be NULL!!!
		if ((pActReq = AtalkAllocZeroedMemory(sizeof(ACTREQ))) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
#if	DBG
		pActReq->ar_Signature = ACTREQ_SIGNATURE;
#endif
		pActReq->ar_pIrp = pIrp;
		pActReq->ar_DevType = DevType;
		pActReq->ar_pParms = (PBYTE)pActionHdr + sizeof(TDI_ACTION_HEADER);
		pActReq->ar_Completion = atalkTdiActionComplete;
		pActReq->ar_ActionCode = actionCode;
		pActReq->ar_pAMdl =	NULL;
		pActReq->ar_MdlSize = 0;

		if (Flags & DFLAG_MDL)
		{
			ASSERT((size >= 0) && ((offset+size) <= bufLen));
			pActReq->ar_MdlSize = size;

			if ((size < 0) || ((offset+size) > bufLen))
			{
				AtalkFreeMemory(pActReq);
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			// If size is zero, we go on to the next mdl.
			// IoAllocateMdl will fail for a 0-length mdl
			// If size < 0, we will hit the error later.
			if (size != 0)
			{
				DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_INFO,
						("AtalkTdiAction - Size of mdl %lx\n", size));
		
				pActReq->ar_pAMdl =	AtalkSubsetAmdl(pMdl,	// MasterMdl
													offset,	// ByteOffset,
													size);	// SubsetMdlSize,
		
				if (pActReq->ar_pAMdl == NULL)
				{
					AtalkFreeMemory(pActReq);
					status = STATUS_INSUFFICIENT_RESOURCES;
					break;
				}
			}
		}

		//	Now call the dispatch routine
		error = (*AtalkActionDispatch[actionCode]._Dispatch)(pObject, pActReq);
		if (!ATALK_SUCCESS(error))
		{
			//	Call the generic completion routine and then return
			//	pending. That will free up the mdl's and the actreq.
			atalkTdiActionComplete(error, pActReq);
		}
		status = STATUS_PENDING;
	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiQueryInformation(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will satisfy the query for the object indicated in the Request. It
	supports the following query types-

	TDI_QUERY_PROVIDER_INFO
		The provider information structure for the provider that the object belongs to.

	TDI_QUERY_ADDRESS_INFO
		The address information for the address object passed in.

	TDI_QUERY_CONNECTION_INFO			**NOT SUPPORTED**
		The connection information for the connection object passed in.

	TDI_QUERY_PROVIDER_STATISTICS		**NOT SUPPORTED**
		The provider statistics - per provider statistics. All actions on a particular
		file object corresponds to activity on the provider of that file object. So each
		provider context structure will have the provider statistics structure which will
		be returned in this call.

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PVOID				pObject;
	USHORT				ObjectType;
	USHORT				DevType;
	USHORT				bufLen;
    ULONG               BytesWritten;
	NTSTATUS			status = STATUS_SUCCESS;

	PTDI_REQUEST_KERNEL_QUERY_INFORMATION	pQuery;

	pObject = (PVOID)pIrpSp->FileObject->FsContext;
	ObjectType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF);
	DevType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) >> 16);

	pQuery = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&pIrpSp->Parameters;
    BytesWritten = 0;
	pIrp->IoStatus.Information	= 0;

	bufLen = (USHORT)AtalkSizeMdlChain(pIrp->MdlAddress);
	
	switch (pQuery->QueryType)
	{

	case TDI_QUERY_ADDRESS_INFO:
		if (bufLen < sizeof(TDI_ADDRESS_INFO))
		{
			status	= STATUS_BUFFER_TOO_SMALL;
			break;
		}

		switch (DevType)
		{
		  case ATALK_DEV_DDP:
			ASSERT(ObjectType == TDI_TRANSPORT_ADDRESS_FILE);
			AtalkDdpQuery(pObject,
						  pIrp->MdlAddress,
						  &BytesWritten);

			break;

		  case ATALK_DEV_PAP:
			AtalkPapQuery(pObject,
						  ObjectType,
						  pIrp->MdlAddress,
						  &BytesWritten);
			break;

		  case ATALK_DEV_ADSP:
			AtalkAdspQuery(pObject,
						   ObjectType,
						   pIrp->MdlAddress,
						   &BytesWritten);
			break;

		  case ATALK_DEV_ASPC:
		  case ATALK_DEV_ASP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiQueryInformation: Invalid device type\n"));

			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
		break;

	  case TDI_QUERY_CONNECTION_INFO:
		//	Statistics on a connection. Not supported.
		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("AtalkTdiQueryInformation: TDI_QUERY_CONNECTION_INFO not supported\n"));
        ASSERT(0);

		status = STATUS_NOT_IMPLEMENTED;
		break;

	  case TDI_QUERY_PROVIDER_INFO:

		if (bufLen < sizeof(TDI_PROVIDER_INFO))
		{
			status	= STATUS_BUFFER_TOO_SMALL;
			break;
		}

		status = TdiCopyBufferToMdl(&pCtx->adc_ProvInfo,
									0,
									sizeof (TDI_PROVIDER_INFO),
									pIrp->MdlAddress,
									0,
									&BytesWritten);
		break;

      case TDI_QUERY_PROVIDER_STATISTICS:

		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("AtalkTdiQueryInformation: TDI_QUERY_PROVIDER_STATISTICS not supported\n"));
        ASSERT(0);

		status = STATUS_NOT_IMPLEMENTED;
		break;

	  default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}

    pIrp->IoStatus.Information = BytesWritten;
	
	return status;
}




NTSTATUS
AtalkTdiSetInformation(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS	status;


	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
		  case ATALK_DEV_PAP:
		  case ATALK_DEV_ADSP:
		  case ATALK_DEV_ASPC:
	        status = STATUS_SUCCESS;
			break;

		  case ATALK_DEV_ASP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			status = STATUS_INVALID_DEVICE_REQUEST;
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiSetInformation: Invalid device type\n"));
			break;
		}

	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiSetEventHandler(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:


Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PVOID				pObject;
	PDDP_ADDROBJ		pDdpAddr;
	PADSP_ADDROBJ		pAdspAddr;
	PPAP_ADDROBJ		pPapAddr;
	PASPC_ADDROBJ		pAspAddr;
	USHORT				objectType;
	USHORT				devType;
	KIRQL				OldIrql;
	NTSTATUS			status = STATUS_SUCCESS;

	do
	{
		PTDI_REQUEST_KERNEL_SET_EVENT parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)&pIrpSp->Parameters;
	
		pObject 	= (PVOID)pIrpSp->FileObject->FsContext;
		objectType 	= (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF);
		devType 	= (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) >> 16);

		if (objectType != TDI_TRANSPORT_ADDRESS_FILE)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiSetEventHandler: returning STATUS_INVALID_ADDRESS\n"));

			status = STATUS_INVALID_ADDRESS;
			break;
		}

		switch (parameters->EventType)
		{
		  case TDI_EVENT_RECEIVE_DATAGRAM:
			if (devType != ATALK_DEV_DDP)
			{
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			pDdpAddr = (PDDP_ADDROBJ)pObject;
			if (!(VALID_DDP_ADDROBJ(pDdpAddr)))
            {
                ASSERT(0);
                status = STATUS_INVALID_ADDRESS;
                break;
            }

			ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

			//	Allocate event info if null.
			if (pDdpAddr->ddpao_EventInfo == NULL)
			{
				pDdpAddr->ddpao_EventInfo =
					AtalkAllocZeroedMemory(sizeof(DDPEVENT_INFO));
			}

			if (pDdpAddr->ddpao_EventInfo != NULL)
			{
				pDdpAddr->ddpao_Flags |= DDPAO_DGRAM_EVENT;
				if ((pDdpAddr->ddpao_EventInfo->ev_RcvDgramHandler =
							(PTDI_IND_RECEIVE_DATAGRAM)parameters->EventHandler) == NULL)
				{
					pDdpAddr->ddpao_Flags	&= ~DDPAO_DGRAM_EVENT;
				}

				pDdpAddr->ddpao_EventInfo->ev_RcvDgramCtx = parameters->EventContext;
			}
			else
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
			}
			RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
			break;

		  case TDI_EVENT_ERROR:
			break;

		  case TDI_EVENT_CONNECT:
			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				if (pAdspAddr->adspao_Flags & ADSPAO_CONNECT)
				{
					status = STATUS_INVALID_ADDRESS;
				}
				else
				{
					pAdspAddr->adspao_ConnHandler = (PTDI_IND_CONNECT)parameters->EventHandler;
					pAdspAddr->adspao_ConnHandlerCtx = parameters->EventContext;
					pAdspAddr->adspao_Flags	|= ADSPAO_LISTENER;
				}
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				if (pPapAddr->papao_Flags & PAPAO_CONNECT)
				{
					status = STATUS_INVALID_ADDRESS;
				}
				else
				{
					pPapAddr->papao_Flags	|= (PAPAO_LISTENER | PAPAO_UNBLOCKED);

					//	If we are setting a null handler, set it to blocked.
					if ((pPapAddr->papao_ConnHandler = (PTDI_IND_CONNECT)parameters->EventHandler) == NULL)
					{
						//	Oops. block. Dont care about listens being posted here.
						pPapAddr->papao_Flags &= ~PAPAO_UNBLOCKED;
					}

					pPapAddr->papao_ConnHandlerCtx = parameters->EventContext;
				}
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

				if (NT_SUCCESS(status))
				{
					//	Prime the listener.
					if (!ATALK_SUCCESS(AtalkPapPrimeListener(pPapAddr)))
					{
						TMPLOGERR();
					}
				}
				break;

			  case ATALK_DEV_ASPC:
				// No listens here. Client side only.
				status = STATUS_INVALID_ADDRESS;
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;

			}
			break;

		  case TDI_EVENT_RECEIVE:

			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_RecvHandler = (PTDI_IND_RECEIVE)parameters->EventHandler;
				pAdspAddr->adspao_RecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				pPapAddr->papao_RecvHandler = (PTDI_IND_RECEIVE)parameters->EventHandler;
				pPapAddr->papao_RecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
		  		// No receives in asp client
				status	= STATUS_SUCCESS;
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
			break;

		  case TDI_EVENT_RECEIVE_EXPEDITED:
			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }
	
				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_ExpRecvHandler = (PTDI_IND_RECEIVE_EXPEDITED)parameters->EventHandler;
				pAdspAddr->adspao_ExpRecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
				pAspAddr = (PASPC_ADDROBJ)pObject;
				if (!(VALID_ASPCAO(pAspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }
	
				ACQUIRE_SPIN_LOCK(&pAspAddr->aspcao_Lock, &OldIrql);
				pAspAddr->aspcao_ExpRecvHandler = (PTDI_IND_RECEIVE_EXPEDITED)parameters->EventHandler;
				pAspAddr->aspcao_ExpRecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAspAddr->aspcao_Lock, OldIrql);
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
			break;

		  case TDI_EVENT_DISCONNECT:

			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_DisconnectHandler = (PTDI_IND_DISCONNECT)parameters->EventHandler;
				pAdspAddr->adspao_DisconnectHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				pPapAddr->papao_DisconnectHandler = (PTDI_IND_DISCONNECT)parameters->EventHandler;
				pPapAddr->papao_DisconnectHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
				pAspAddr = (PASPC_ADDROBJ)pObject;
				if (!(VALID_ASPCAO(pAspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAspAddr->aspcao_Lock, &OldIrql);
				pAspAddr->aspcao_DisconnectHandler = (PTDI_IND_DISCONNECT)parameters->EventHandler;
				pAspAddr->aspcao_DisconnectHandlerCtx= parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAspAddr->aspcao_Lock, OldIrql);
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
			break;

		  case TDI_EVENT_SEND_POSSIBLE:

			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_SendPossibleHandler = (PTDI_IND_SEND_POSSIBLE)parameters->EventHandler;
				pAdspAddr->adspao_SendPossibleHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				pPapAddr->papao_SendPossibleHandler	= (PTDI_IND_SEND_POSSIBLE)parameters->EventHandler;
				pPapAddr->papao_SendPossibleHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
		  		// No sends in asp client
				status	= STATUS_SUCCESS;
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;

			}
			break;

		  default:
			status = STATUS_INVALID_PARAMETER;
		}
	
#if DBG
		//	Avoid assertions in AFD.
		status	= STATUS_SUCCESS;
#endif

	} while (FALSE);

	return status;
}




VOID
AtalkTdiCancel(
	IN OUT	PATALK_DEV_OBJ			pDevObj,
	IN		PIRP					pIrp
	)
/*++

Routine Description:

	This routine handles cancellation of IO requests

Arguments:


Return Value:
--*/
{
	PIO_STACK_LOCATION		pIrpSp;
	PVOID					pObject;
	PATALK_DEV_CTX			pCtx;
    PVOID                   FsContext2;

	pIrpSp 	= IoGetCurrentIrpStackLocation(pIrp);
	pObject = pIrpSp->FileObject->FsContext;
    FsContext2 = pIrpSp->FileObject->FsContext2;
	pCtx	= &pDevObj->Ctx;

	ASSERT(((LONG_PTR)FsContext2 >> 16) == pCtx->adc_DevType);

	IoReleaseCancelSpinLock (pIrp->CancelIrql);

	switch (pCtx->adc_DevType)
	{
        case ATALK_DEV_DDP:
		break;

	  case ATALK_DEV_ASPC:
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
        {
			 AtalkAspCCleanupConnection((PASPC_CONNOBJ)pObject);
        }

		else
        {
            AtalkAspCCleanupAddress((PASPC_ADDROBJ)pObject);
        }
		break;

	  case ATALK_DEV_ASP:
		// We only handle cancellation of IO requests on connection objects.
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
			AtalkAspCleanupConnection((PASP_CONNOBJ)pObject);
		break;

	  case ATALK_DEV_PAP:
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
        {
			 AtalkPapCleanupConnection((PPAP_CONNOBJ)pObject);
        }
		else
        {
            AtalkPapCleanupAddress((PPAP_ADDROBJ)pObject);
        }
		break;

	  case ATALK_DEV_ADSP:
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
			 AtalkAdspCleanupConnection((PADSP_CONNOBJ)pObject);
		else AtalkAdspCleanupAddress((PADSP_ADDROBJ)pObject);
		break;

      case ATALK_DEV_ARAP:
        ArapCancelIrp(pIrp);
        break;

	  default:
		// The device type in the Ctx field can never be anything
		// other than the above! Internal protocol error.
		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiCancel: Invalid device type\n"));
		break;
	}

}




VOID
AtalkQueryInitProviderInfo(
	IN		ATALK_DEV_TYPE		DeviceType,
	IN OUT	PTDI_PROVIDER_INFO  ProviderInfo
	)
{
	//
	//  Initialize to defaults first
	//

	RtlZeroMemory((PVOID)ProviderInfo, sizeof(TDI_PROVIDER_INFO));

	ProviderInfo->Version = ATALK_TDI_PROVIDERINFO_VERSION;
	KeQuerySystemTime (&ProviderInfo->StartTime);

	switch (DeviceType)
	{
	  case ATALK_DEV_DDP:
		ProviderInfo->MaxDatagramSize = ATALK_DDP_PINFODGRAMSIZE;
		ProviderInfo->ServiceFlags = ATALK_DDP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_PAP:
		ProviderInfo->MaxSendSize =  ATALK_PAP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_PAP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ADSP:
		ProviderInfo->MaxSendSize =  ATALK_ADSP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ADSP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ASP:
		ProviderInfo->MaxSendSize =  ATALK_ASP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ASP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ARAP:
		ProviderInfo->MaxSendSize =  ATALK_ARAP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ARAP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ASPC:
		ProviderInfo->MaxSendSize =  ATALK_ASP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ASP_PINFOSERVICEFLAGS;
		break;


	  default:
		KeBugCheck(0);
	}
}


LOCAL VOID FASTCALL
atalkTdiSendDgramComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
{
	PDDP_ADDROBJ	pAddr = (PDDP_ADDROBJ)(pSendInfo->sc_Ctx1);
	PBUFFER_DESC	pBufDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx2);
	PIRP			pIrp = (PIRP)(pSendInfo->sc_Ctx3);

	ASSERT(VALID_DDP_ADDROBJ(pAddr));

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("atalkTdiSendDgramComplete: Status %lx, addr %lx\n", Status, pAddr));

	AtalkFreeBuffDesc(pBufDesc);
	pIrp->CancelRoutine = NULL;
	TdiCompleteRequest(pIrp,
					   ((Status == NDIS_STATUS_SUCCESS) ?
						STATUS_SUCCESS: STATUS_UNSUCCESSFUL));
}




LOCAL VOID
atalkTdiRecvDgramComplete(
	IN	ATALK_ERROR		ErrorCode,
	IN	PAMDL			pReadBuf,
	IN	USHORT			ReadLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	PIRP			pIrp
	)
{
	PIO_STACK_LOCATION 				pIrpSp;
	PTDI_REQUEST_KERNEL_RECEIVEDG	parameters;
	PTDI_CONNECTION_INFORMATION		returnInfo;
	PTA_APPLETALK_ADDRESS			remoteAddress;


	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("atalkTdiRecvDgramComplete: %lx\n", ErrorCode));

	pIrpSp 		= IoGetCurrentIrpStackLocation(pIrp);
	parameters 	= (PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;

	//	Set length in the info field and call the completion routine.
	pIrp->CancelRoutine = NULL;
	pIrp->IoStatus.Information	= (ULONG)ReadLen;

	if (ATALK_SUCCESS(ErrorCode))
	{
		ASSERT(parameters != NULL);

		if (parameters != NULL)
		{
			parameters->ReceiveLength = (ULONG)ReadLen;

            try {
			    returnInfo =
				    (PTDI_CONNECTION_INFORMATION)parameters->ReturnDatagramInformation;

			    ASSERT(returnInfo != NULL);
			    if (returnInfo != NULL)
			    {
				    if (returnInfo->RemoteAddressLength >= sizeof(TA_APPLETALK_ADDRESS))
				    {
					    //  Fill in the remote address
					    remoteAddress = (PTA_APPLETALK_ADDRESS)returnInfo->RemoteAddress;

					    ASSERT(remoteAddress != NULL);
					    if (remoteAddress != NULL)
					    {
						    //	Copy the remote address from where the datagram was received
						    ATALKADDR_TO_TDI(
							    remoteAddress,
							    pSrcAddr);

						    DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
								("AtalkAddrRecvDgComp - Net %x Node %x Socket %x\n",
									remoteAddress->Address[0].Address[0].Network,
									remoteAddress->Address[0].Address[0].Node,
									remoteAddress->Address[0].Address[0].Socket));
					    }
				    }
			    }
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                ErrorCode = GetExceptionCode();

	            DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			        ("atalkTdiRecvDgramComplete: exception occured %lx\n", ErrorCode));
            }
		}
	}

	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




LOCAL VOID
atalkTdiActionComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PACTREQ		pActReq
	)
{
	PIRP	pIrp = pActReq->ar_pIrp;

	ASSERT (VALID_ACTREQ(pActReq));

	if (pActReq->ar_pAMdl != NULL)
		AtalkFreeAMdl(pActReq->ar_pAMdl);
	AtalkFreeMemory(pActReq);

	pIrp->CancelRoutine = NULL;
	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




LOCAL VOID
atalkTdiGenericComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PIRP		pIrp
	)
{
	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericComplete: Completing %lx with %lx\n",
				pIrp, AtalkErrorToNtStatus(ErrorCode)));

	pIrp->CancelRoutine = NULL;
	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}



LOCAL VOID
atalkTdiCloseAddressComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PIRP		pIrp
	)
{
	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiCloseAddressComplete: Completing %lx with %lx\n",
			pIrp, AtalkErrorToNtStatus(ErrorCode)));

	pIrp->CancelRoutine = NULL;
	ASSERT (ErrorCode != ATALK_PENDING);
	AtalkUnlockTdiIfNecessary();

	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}



LOCAL VOID
atalkTdiGenericReadComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN 	PAMDL		ReadBuf,
	IN 	USHORT		ReadLen,
	IN 	ULONG		ReadFlags,
	IN 	PIRP		pIrp
	)
{
	ASSERT(pIrp->IoStatus.Status != STATUS_UNSUCCESSFUL);

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericReadComplete: Irp %lx Status %lx Info %lx\n",
				pIrp, pIrp->IoStatus.Status, ReadLen));

	pIrp->CancelRoutine = NULL;
	pIrp->IoStatus.Information	= (ULONG)ReadLen;
	ASSERT (ErrorCode != ATALK_PENDING);

	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




VOID
atalkTdiGenericWriteComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN 	PAMDL		WriteBuf,
	IN 	USHORT		WriteLen,
	IN	PIRP		pIrp
	)
{
	ASSERT(pIrp->IoStatus.Status != STATUS_UNSUCCESSFUL);

	if (pIrp->IoStatus.Status == STATUS_UNSUCCESSFUL)
	{
		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("atalkTdiGenericWriteComplete: Irp %lx Status %lx Info %lx\n",
				pIrp, pIrp->IoStatus.Status, WriteLen));
	}

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericWriteComplete: Irp %lx Status %lx Info %lx\n",
				pIrp, pIrp->IoStatus.Status, WriteLen));

	pIrp->CancelRoutine = NULL;
	pIrp->IoStatus.Information	= (ULONG)WriteLen;
	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}


LOCAL VOID
atalkQueuedLockUnlock(
	IN	PQLU		pQLU
)
{
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	AtalkLockUnlock(FALSE,
					pQLU->qlu_pLockSection);
	AtalkPortDereference(pQLU->qlu_pPortDesc);
	AtalkFreeMemory(pQLU);
}


VOID
AtalkLockInit(
	IN	PLOCK_SECTION	pLs,
	IN	PVOID			Address
)
{
	pLs->ls_LockHandle = MmLockPagableCodeSection(Address);
	MmUnlockPagableImageSection(pLs->ls_LockHandle);
}


VOID
AtalkLockUnlock(
	IN	BOOLEAN			Lock,
	IN	PLOCK_SECTION	pLs
	)
{
	KIRQL	OldIrql;
	BOOLEAN	DoForReal;

	// We cannot call the MmLock/MmUnlock routines at Dpc. So if we are called at
	// DISPATCH, just queue ourselves. Also we only get unlock requests at DISPATCH,
	// Lock requests are only at LOW_LEVEL. So failure to allocate memory can be
	// IGNORED since that will only have the effect of failure to unlock.
	if (KeGetCurrentIrql() == DISPATCH_LEVEL)
	{
		PQLU		pQLU;
		ATALK_ERROR	Error;

		ASSERT (!Lock || (pLs->ls_LockCount > 0));

		if (Lock)
		{
			ASSERT (pLs->ls_LockCount > 0);
			ACQUIRE_SPIN_LOCK_DPC(&AtalkPgLkLock);
			pLs->ls_LockCount ++;
			RELEASE_SPIN_LOCK_DPC(&AtalkPgLkLock);
		}
		else
		{
			if ((pQLU = AtalkAllocMemory(sizeof(QLU))) != NULL)
			{
				pQLU->qlu_pPortDesc = AtalkPortList;
				AtalkPortReferenceByPtrDpc(pQLU->qlu_pPortDesc, &Error);
				if (ATALK_SUCCESS(Error))
				{
					pQLU->qlu_pLockSection = pLs;
		
					ExInitializeWorkItem(&pQLU->qlu_WQI, atalkQueuedLockUnlock, pQLU);
					ExQueueWorkItem(&pQLU->qlu_WQI, CriticalWorkQueue);
				}
				else
				{
					AtalkFreeMemory(pQLU);
				}
			}
		}
		return;									
	}

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	// We need to serialize the operations here. Note that a spin-lock will not do the
	// job since the MmLock/MmUnlock routines cannot be called with the spin-lock held
	KeWaitForSingleObject(&AtalkPgLkMutex,
						  Executive,
						  KernelMode,
						  TRUE,
						  (PLARGE_INTEGER)NULL);

	ASSERT (pLs->ls_LockHandle != NULL);

	DoForReal = FALSE;
	ACQUIRE_SPIN_LOCK(&AtalkPgLkLock, &OldIrql);

	if (Lock)
	{
		if (pLs->ls_LockCount == 0)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_WARN,
					("AtalkLockUnlock: Locking %d\n", pLs - AtalkPgLkSection));
			DoForReal = TRUE;
		}
		pLs->ls_LockCount ++;
	}
	else
	{
		ASSERT (pLs->ls_LockCount > 0);

		pLs->ls_LockCount --;
		if (pLs->ls_LockCount == 0)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_WARN,
					("AtalkLockUnlock: Unlocking %d\n", pLs - AtalkPgLkSection));
			DoForReal = TRUE;
		}
	}

	RELEASE_SPIN_LOCK(&AtalkPgLkLock, OldIrql);

	if (DoForReal)
	{
		if (Lock)
		{
			MmLockPagableSectionByHandle(pLs->ls_LockHandle);
		}
		else
		{
			MmUnlockPagableImageSection(pLs->ls_LockHandle);
		}
	}

	// LeaveCriticalSection
	KeReleaseMutex(&AtalkPgLkMutex, FALSE);
}


VOID
atalkWaitDefaultPort(
	VOID
)
{
	TIME		Time;
#define	ONE_SEC_IN_100ns		-10000000L		// 1sec in 100ns units

	if ((AtalkDefaultPort == NULL) ||
		((AtalkDefaultPort->pd_Flags & (PD_USER_NODE_1 | PD_USER_NODE_2)) == 0))
	{
		// Make sure we can indeed wait
		ASSERT (KeGetCurrentIrql() == LOW_LEVEL);
	
		Time.QuadPart = Int32x32To64((LONG)20, ONE_SEC_IN_100ns);
		KeWaitForSingleObject(&AtalkDefaultPortEvent, Executive, KernelMode, FALSE, &Time);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atktypes.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktypes.h

Abstract:

	This module contains the type definitions for the Appletalk protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKTYPES_
#define	_ATKTYPES_

#ifndef PBYTE
typedef	UCHAR	BYTE, *PBYTE;
#endif

#ifndef	DWORD
typedef	ULONG	DWORD, *PDWORD;
#endif

//	Define our opaque type. On NT, this will just be an MDL.
typedef		MDL		AMDL, *PAMDL;

//	Logical protocol types - #defines for compiler warnings...
typedef	BYTE				LOGICAL_PROTOCOL, *PLOGICAL_PROTOCOL;
#define	UNKNOWN_PROTOCOL	0
#define	APPLETALK_PROTOCOL	1
#define	AARP_PROTOCOL		2


//	Appletalk Node address: Includes the network number
typedef	struct _ATALK_NODEADDR
{
	USHORT			atn_Network;
	BYTE			atn_Node;
} ATALK_NODEADDR, *PATALK_NODEADDR;

#define	NODEADDR_EQUAL(NodeAddr1, NodeAddr2)	\
				(((NodeAddr1)->atn_Network == (NodeAddr2)->atn_Network) &&	\
				 ((NodeAddr1)->atn_Node == (NodeAddr2)->atn_Node))

//	Appletalk internet address: This is similar to what is in the
//	TDI Appletalk address definition. We do not use that directly
//	because of the naming convention differences. We will instead
//	have macros to convert from one to the other.
typedef	union _ATALK_ADDR
{
	struct
	{
		USHORT		ata_Network;
		BYTE		ata_Node;
		BYTE		ata_Socket;
	};
	ULONG			ata_Address;
} ATALK_ADDR, *PATALK_ADDR;

//	Appletalk Network range structure
typedef struct _ATALK_NETWORKRANGE
{
	USHORT	anr_FirstNetwork;
	USHORT	anr_LastNetwork;
} ATALK_NETWORKRANGE, *PATALK_NETWORKRANGE;

#define	NW_RANGE_EQUAL(Range1, Range2)	(*(PULONG)(Range1) == *(PULONG)(Range2))

#endif	// _ATKTYPES_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atktdi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktdi.h

Abstract:

	This module contains tdi related definitions.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKTDI_
#define	_ATKTDI_

#define DFLAG_ADDR		0x0001
#define DFLAG_CONN		0x0002
#define DFLAG_CNTR		0x0004
#define DFLAG_MDL		0x0008

struct _ActionReq;

// Typedef for the worker routine used in the dispatch tables
typedef VOID		(*GENERIC_COMPLETION)(IN ATALK_ERROR	ErrorCode,
										  IN PIRP			pIrp);
typedef VOID		(*ACTION_COMPLETION)(IN ATALK_ERROR		ErrorCode,
										 IN struct _ActionReq *pActReq);
typedef ATALK_ERROR	(*DISPATCH_ROUTINE)(IN PVOID			pObject,
										IN struct _ActionReq *pActReq);

typedef VOID		(*GENERIC_WRITE_COMPLETION)(
									IN ATALK_ERROR	ErrorCode,
									IN PAMDL		WriteBuf,
									IN USHORT		WriteLen,
									IN PIRP			pIrp);

typedef VOID		(*GENERIC_READ_COMPLETION)(
									IN ATALK_ERROR	ErrorCode,
									IN PAMDL		ReadBuf,
									IN USHORT		ReadLen,
									IN ULONG		ReadFlags,
									IN PIRP			pIrp);

// Define the Action dispatch table here.
//
// *IMPORTANT*
// This table is tightly integrated with the action codes defined in
// ATALKTDI.H.
//
// Order is NBP/ZIP/ADSP/ATP/ASP/PAP
//
// Each element of the array contains:
// _MinBufLen - The minimum length of the MdlAddress buffer for the request
// _OpCode - The action code of the request (sanity check)
// _OpInfo - Bit flags give more information about the request
//		DFLAG_ADDR - Object for request must be an address object
//		DFLAG_CONN - Object for request must be connection object
//		DFLAG_CNTR - Object for request must be control channel
//		DFLAG_MDL1 - Request uses an mdl (submdl of MdlAddress)
//		DFLAG_MDL2 - Request uses a second mdl (submdl of MdlAddress)
// _ActionBufSize  - The size of the action header buffer for request
//					 (beginning of the buffer described by MdlAddress)
// _DeviceType	   - Valid device types for the request
//					 ATALK_DEV_ANY => Any device
// _MdlSizeOffset  - Offset in action buffer where the size for the first
//					 mdl can be found. Non-zero only when DFLAG_MDL2 is set.
// _Dispatch	   - The dispatch routine for the request
//
typedef struct _ActionDispatch {
	USHORT				_MinBufLen;
	USHORT				_OpCode;
	USHORT				_Flags;
	USHORT				_ActionBufSize;
	ATALK_DEV_TYPE		_DeviceType;
	DISPATCH_ROUTINE	_Dispatch;
} ACTION_DISPATCH, *PACTION_DISPATCH;


extern POBJECT_TYPE *IoFileObjectType;

extern	ACTION_DISPATCH	AtalkActionDispatch[];

#define	ACTREQ_SIGNATURE	(*(PULONG)"ACRQ")
#if	DBG
#define	VALID_ACTREQ(pActReq)	(((pActReq) != NULL) &&	\
								 ((pActReq)->ar_Signature == ACTREQ_SIGNATURE))
#else
#define	VALID_ACTREQ(pActReq)	((pActReq) != NULL)
#endif
typedef	struct _ActionReq
{
#if	DBG
	ULONG				ar_Signature;
#endif
	PIRP				ar_pIrp;					// Irp for the request
	PVOID				ar_pParms;					// Action parameter block
	PAMDL				ar_pAMdl;					// Mdl (OPTIONAL)
	SHORT				ar_MdlSize;					// And its size
	ULONG				ar_ActionCode;				// TDI Action code
	SHORT				ar_DevType;					// Which device ?
	ACTION_COMPLETION	ar_Completion;				// Tdi Completion routine
    PKEVENT             ar_CmplEvent;               // zone-list acquiring done
    PVOID               ar_pZci;                    // ptr to zoneinfo struct
    ULONG               ar_StatusCode;
} ACTREQ, *PACTREQ;

typedef	enum {
	ATALK_INDICATE_DISCONNECT,
	ATALK_TIMER_DISCONNECT,
	ATALK_REMOTE_DISCONNECT,
	ATALK_LOCAL_DISCONNECT
} ATALK_DISCONNECT_TYPE;
#define DISCONN_STATUS(DiscType)												\
			(((DiscType == ATALK_TIMER_DISCONNECT) ? ATALK_CONNECTION_TIMEOUT : \
			(DiscType == ATALK_REMOTE_DISCONNECT)) ? ATALK_REMOTE_CLOSE :   	\
			ATALK_NO_ERROR)

extern
NTSTATUS
AtalkTdiOpenAddress(
	IN 		PIRP					Irp,
	IN 		PIO_STACK_LOCATION		IrpSp,
	IN 		PTA_APPLETALK_ADDRESS	TdiAddress,
	IN 		UCHAR					ProtocolType,
	IN 		UCHAR					SocketType,
	IN OUT 	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiOpenConnection(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN 		CONNECTION_CONTEXT		ConnectionContext,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiOpenControlChannel(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCleanupAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCleanupConnection(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCloseAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCloseConnection(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCloseControlChannel(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
VOID
AtalkTdiCancel(
	IN OUT	PATALK_DEV_OBJ			pDevObj,
	IN		PIRP					Irp
);

extern
NTSTATUS
AtalkTdiAssociateAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiDisassociateAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiConnect(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiDisconnect(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiAccept(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiListen(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSendDgram(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiReceiveDgram(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSend(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiReceive(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiAction(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiQueryInformation(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSetInformation(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSetEventHandler(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);


extern
ATALK_ERROR
AtalkStatTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkNbpTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkZipTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkAdspTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkAspCTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkPapTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkAspTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
VOID
atalkTdiGenericWriteComplete(
	IN	ATALK_ERROR					ErrorCode,
	IN 	PAMDL						WriteBuf,
	IN 	USHORT						WriteLen,
	IN	PIRP						pIrp
);

typedef	struct
{
	LONG	ls_LockCount;
	PVOID	ls_LockHandle;
} LOCK_SECTION, *PLOCK_SECTION;

#define	AtalkLockAdspIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ADSP_SECTION])
#define	AtalkUnlockAdspIfNecessary()	AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[ADSP_SECTION])

#define	AtalkLockPapIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[PAP_SECTION])
#define	AtalkUnlockPapIfNecessary()		AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[PAP_SECTION])

#define	AtalkLockNbpIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[NBP_SECTION])
#define	AtalkUnlockNbpIfNecessary()		AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[NBP_SECTION])

#define	AtalkLockZipIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ZIP_SECTION])
#define	AtalkUnlockZipIfNecessary()		AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[ZIP_SECTION])

#define	AtalkLockRouterIfNecessary()	AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ROUTER_SECTION])
#define	AtalkUnlockRouterIfNecessary()	AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[ROUTER_SECTION])

#define	AtalkLockTdiIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[TDI_SECTION])
#define	AtalkUnlockTdiIfNecessary()		AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[TDI_SECTION])

#define	AtalkLockAspIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ASP_SECTION])
#define	AtalkUnlockAspIfNecessary()		AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[ASP_SECTION])

#define	AtalkLockAspCIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ASPC_SECTION])
#define	AtalkUnlockAspCIfNecessary()	AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[ASPC_SECTION])

#define	AtalkLockAtpIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ATP_SECTION])
#define	AtalkUnlockAtpIfNecessary()		AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[ATP_SECTION])

#define	AtalkLockInitIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[INIT_SECTION])
#define	AtalkUnlockInitIfNecessary()		AtalkLockUnlock(FALSE,		            		\
														&AtalkPgLkSection[INIT_SECTION])
#define	AtalkLockArapIfNecessary()		AtalkLockUnlock(TRUE,		            		\
														&AtalkPgLkSection[ARAP_SECTION])
#define	AtalkUnlockArapIfNecessary()		AtalkLockUnlock(FALSE,		            		\
														&AtalkPgLkSection[ARAP_SECTION])
#define	AtalkLockPPPIfNecessary()		AtalkLockUnlock(TRUE,		            		\
														&AtalkPgLkSection[PPP_SECTION])
#define	AtalkUnlockPPPIfNecessary()		AtalkLockUnlock(FALSE,		            		\
														&AtalkPgLkSection[PPP_SECTION])

extern
VOID
AtalkLockInit(
	IN	PLOCK_SECTION	pLs,
	IN	PVOID			Address
);

extern
VOID
AtalkLockUnlock(
	IN		BOOLEAN						Lock,
	IN		PLOCK_SECTION				pLs
);

#define	ROUTER_SECTION					0
#define	NBP_SECTION						1	// NBP & ZIP share the sections
#define	ZIP_SECTION						1
#define	TDI_SECTION						2
#define	ATP_SECTION						3
#define	ASP_SECTION						4
#define	PAP_SECTION						5
#define	ADSP_SECTION					6
#define	ASPC_SECTION					7
#define	INIT_SECTION					8
#define ARAP_SECTION                    9
#define PPP_SECTION                     10
#define	LOCKABLE_SECTIONS				11

extern	KMUTEX							AtalkPgLkMutex;
extern	ATALK_SPIN_LOCK					AtalkPgLkLock;
extern	LOCK_SECTION					AtalkPgLkSection[LOCKABLE_SECTIONS];

// Used by AtalkLockUnlock & atalkQueuedLockUnlock to communicate. The latter is queued
// up by the former whenever it is called at DISPACTH to unlock
typedef	struct
{
	WORK_QUEUE_ITEM		qlu_WQI;
	PLOCK_SECTION		qlu_pLockSection;
	PPORT_DESCRIPTOR	qlu_pPortDesc;
} QLU, *PQLU;

LOCAL VOID FASTCALL
atalkTdiSendDgramComplete(
	IN	NDIS_STATUS						Status,
	IN	struct _SEND_COMPL_INFO	*		pSendInfo
);

LOCAL VOID
atalkTdiRecvDgramComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PAMDL							pReadBuf,
	IN	USHORT							ReadLen,
	IN	PATALK_ADDR						pSrcAddr,
	IN	PIRP							pIrp);

LOCAL VOID
atalkTdiActionComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PACTREQ							pActReq
);

LOCAL VOID
atalkTdiGenericComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PIRP							pIrp
);

LOCAL VOID
atalkTdiCloseAddressComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PIRP							pIrp
);

LOCAL VOID
atalkTdiGenericReadComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN 	PAMDL							ReadBuf,
	IN 	USHORT							ReadLen,
	IN 	ULONG							ReadFlags,
	IN 	PIRP							pIrp
);

LOCAL VOID
atalkQueuedLockUnlock(
	IN	PQLU		pQLU
);

VOID
atalkWaitDefaultPort(
	VOID
);

#endif	// _ATKTDI_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atktimer.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktimer.c

Abstract:

	This file implements the timer routines used by the stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)


Revision History:
	23 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKTIMER


//  Discardable code after Init time
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkTimerInit)
#pragma alloc_text(PAGEINIT, AtalkTimerFlushAndStop)
#endif

/***	AtalkTimerInit
 *
 *	Initialize the timer component for the appletalk stack.
 */
NTSTATUS
AtalkTimerInit(
	VOID
)
{
	BOOLEAN	TimerStarted;

	// Initialize the timer and its associated Dpc and kick it off
	KeInitializeEvent(&atalkTimerStopEvent, NotificationEvent, FALSE);
	KeInitializeTimer(&atalkTimer);
	INITIALIZE_SPIN_LOCK(&atalkTimerLock);
	KeInitializeDpc(&atalkTimerDpc, atalkTimerDpcRoutine, NULL);
	atalkTimerTick.QuadPart = ATALK_TIMER_TICK;
	TimerStarted = KeSetTimer(&atalkTimer,
							  atalkTimerTick,
							  &atalkTimerDpc);
	ASSERT(!TimerStarted);

	return STATUS_SUCCESS;
}


/***	AtalkTimerScheduleEvent
 *
 *	Insert an event in the timer event list. If the list is empty, then
 *	fire off a timer. The time is specified in ticks. Each tick is currently
 *	100ms. It may not be zero or negative. The internal timer also fires at
 *	100ms granularity.
 */
VOID FASTCALL
AtalkTimerScheduleEvent(
	IN	PTIMERLIST			pList			// TimerList to use for queuing
)
{
	KIRQL	OldIrql;

	DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
			("AtalkTimerScheduleEvent: pList %lx\n", pList));

	ASSERT(VALID_TMR(pList));
	ASSERT (pList->tmr_Routine != NULL);
	ASSERT (pList->tmr_AbsTime != 0);

	if (!atalkTimerStopped)
	{
		ACQUIRE_SPIN_LOCK(&atalkTimerLock, &OldIrql);
		
		// Enqueue this handler
		atalkTimerEnqueue(pList);

		RELEASE_SPIN_LOCK(&atalkTimerLock, OldIrql);
	}
	else
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_FATAL,
				("AtalkTimerScheduleEvent: Called after Flush !!\n"));
	}
}



/***	atalkTimerDpcRoutine
 *
 *	This is called in at DISPATCH_LEVEL when the timer expires. The entry at
 *	the head of the list is decremented and if ZERO unlinked and dispatched.
 *	If the list is non-empty, the timer is fired again.
 */
LOCAL VOID
atalkTimerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2
)
{
	PTIMERLIST	pList;
	BOOLEAN		TimerStarted;
	LONG		ReQueue;

	pKDpc; pContext; SystemArgument1; SystemArgument2;

	if (atalkTimerStopped)
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				("atalkTimerDpc: Enetered after Flush !!!\n"));
		return;
	}

	ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

	AtalkTimerCurrentTick ++;	// Update our relative time

	// We should never be here if we have no work to do
	if ((atalkTimerList != NULL))
	{
		// Careful here. If two guys wanna go off together - let them !!
		if (atalkTimerList->tmr_RelDelta != 0)
			(atalkTimerList->tmr_RelDelta)--;
	
		// Dispatch the entry if it is ready to go
		pList = atalkTimerList;
		if (pList->tmr_RelDelta == 0)
		{
			ASSERT(VALID_TMR(pList));

			// Unlink from the list
			// AtalkUnlinkDouble(pList, tmr_Next, tmr_Prev);
			atalkTimerList = pList->tmr_Next;
			if (atalkTimerList != NULL)
				atalkTimerList->tmr_Prev = &atalkTimerList;

			pList->tmr_Queued = FALSE;
			pList->tmr_Running = TRUE;
			atalkTimerRunning = TRUE;

			DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
					("atalkTimerDpcRoutine: Dispatching %lx\n", pList->tmr_Routine));

			RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

			ReQueue = (*pList->tmr_Routine)(pList, FALSE);

			ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

			atalkTimerRunning = FALSE;

			if (ReQueue != ATALK_TIMER_NO_REQUEUE)
			{
				ASSERT(VALID_TMR(pList));

				pList->tmr_Running = FALSE;
				if (pList->tmr_CancelIt)
				{
					DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
							("atalkTimerDpcRoutine: Delayed cancel for %lx\n", pList));

					RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

					ReQueue = (*pList->tmr_Routine)(pList, TRUE);

					ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

					ASSERT(ReQueue == ATALK_TIMER_NO_REQUEUE);
				}
				else
				{
					if (ReQueue != ATALK_TIMER_REQUEUE)
						pList->tmr_AbsTime = (USHORT)ReQueue;
					atalkTimerEnqueue(pList);
				}
			}
		}
	}

	RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

	if (!atalkTimerStopped)
	{
		TimerStarted = KeSetTimer(&atalkTimer,
								  atalkTimerTick,
								  &atalkTimerDpc);
		ASSERT(!TimerStarted);
	}
	else
	{
		KeSetEvent(&atalkTimerStopEvent, IO_NETWORK_INCREMENT, FALSE);
	}
}


/***	atalkTimerEnqueue
 *
 *	Here is a thesis on the code that follows.
 *
 *	The timer events are maintained as a list which the timer dpc routine
 *	looks at every timer tick. The list is maintained in such a way that only
 *	the head of the list needs to be updated every tick i.e. the entire list
 *	is never scanned. The way this is achieved is by keeping delta times
 *	relative to the previous entry.
 *
 *	Every timer tick, the relative time at the head of the list is decremented.
 *	When that goes to ZERO, the head of the list is unlinked and dispatched.
 *
 *	To give an example, we have the following events queued at time slots
 *	X			Schedule A after 10 ticks.
 *	X+3			Schedule B after 5  ticks.
 *	X+5			Schedule C after 4  ticks.
 *	X+8			Schedule D after 6  ticks.
 *
 *	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
 *	D at X+14 (X+8+6).
 *
 *	The above example covers all the situations.
 *
 *	- NULL List.
 *	- Inserting at head of list.
 *	- Inserting in the middle of the list.
 *	- Appending to the list tail.
 *
 *	The list will look as follows.
 *
 *		    BEFORE                          AFTER
 *		    ------                          -----
 *
 *    X   Head -->|                  Head -> A(10) ->|
 *    A(10)
 *
 *    X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
 *    B(5)
 *
 *    X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
 *    C(4)
 *
 *    X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
 *    D(6)
 *
 *	The granularity is one tick. THIS MUST BE CALLED WITH THE TIMER LOCK HELD.
 */
VOID FASTCALL
atalkTimerEnqueue(
	IN	PTIMERLIST	pListNew
)
{
	PTIMERLIST	pList, *ppList;
	USHORT		DeltaTime = pListNew->tmr_AbsTime;

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &atalkTimerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->tmr_Next)
	{
		ASSERT(VALID_TMR(pList));
		if (DeltaTime <= pList->tmr_RelDelta)
		{
			pList->tmr_RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->tmr_RelDelta;
	}
	

	// Link this in the chain
	pListNew->tmr_RelDelta = DeltaTime;
	pListNew->tmr_Next = pList;
	pListNew->tmr_Prev = ppList;
	*ppList = pListNew;
	if (pList != NULL)
	{
		pList->tmr_Prev = &pListNew->tmr_Next;
	}

	pListNew->tmr_Queued = TRUE;
	pListNew->tmr_Cancelled = FALSE;
	pListNew->tmr_CancelIt = FALSE;
}


/***	AtalkTimerFlushAndStop
 *
 *	Force all entries in the timer queue to be dispatched immediately. No
 *	more queue'ing of timer routines is permitted after this. The timer
 *	essentially shuts down.
 */
VOID
AtalkTimerFlushAndStop(
	VOID
)
{
	PTIMERLIST	pList;
	LONG		ReQueue;
	KIRQL		OldIrql;
	BOOLEAN		Wait;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
			("AtalkTimerFlushAndStop: Entered\n"));

	KeCancelTimer(&atalkTimer);

	// The timer routines assume they are being called at DISPATCH level.
	// Raise our Irql for this routine.
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

	atalkTimerStopped = TRUE;
	Wait = atalkTimerRunning;

	// Dispatch all entries right away
	while (atalkTimerList != NULL)
	{
		pList = atalkTimerList;
		ASSERT(VALID_TMR(pList));
		atalkTimerList = pList->tmr_Next;

		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
				("atalkTimerFlushAndStop: Dispatching %lx\n",
				pList->tmr_Routine));

		pList->tmr_Queued = FALSE;
		pList->tmr_Running = TRUE;

		RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

		ReQueue = (*pList->tmr_Routine)(pList, TRUE);

		ASSERT (ReQueue == ATALK_TIMER_NO_REQUEUE);

		pList->tmr_Running = FALSE;
		ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);
	}

	RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

	KeLowerIrql(OldIrql);

	if (Wait)
	{
		// Wait for any timer events that are currently running. Only an MP issue
		KeWaitForSingleObject(&atalkTimerStopEvent,
							  Executive,
							  KernelMode,
							  TRUE,
							  NULL);
	}
}


/***	AtalkTimerCancelEvent
 *
 *	Cancel a previously scheduled timer event, if it hasn't fired already.
 */
BOOLEAN FASTCALL
AtalkTimerCancelEvent(
	IN	PTIMERLIST			pList,
	IN	PDWORD              pdwOldState
)
{
	KIRQL	OldIrql;
	BOOLEAN	Cancelled = FALSE;
    DWORD   OldState=ATALK_TIMER_QUEUED;


	ACQUIRE_SPIN_LOCK(&atalkTimerLock, &OldIrql);

	// If this is not running, unlink it from the list
	// adjusting relative deltas carefully
	if (pList->tmr_Queued)
	{
		ASSERT (!(pList->tmr_Running));

        OldState = ATALK_TIMER_QUEUED;

		if (pList->tmr_Next != NULL)
		{
			pList->tmr_Next->tmr_RelDelta += pList->tmr_RelDelta;
			pList->tmr_Next->tmr_Prev = pList->tmr_Prev;
		}

		*(pList->tmr_Prev) = pList->tmr_Next;

		// pointing to timer being removed? fix it!
		if (atalkTimerList == pList)
		{
			atalkTimerList = pList->tmr_Next;
		}

		Cancelled = pList->tmr_Cancelled = TRUE;

		pList->tmr_Queued = FALSE;

	}
	else if (pList->tmr_Running)
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				("AtalkTimerCancelEvent: %lx Running, cancel set\n",
				pList->tmr_Routine));
		pList->tmr_CancelIt = TRUE;		// Set to cancel after handler returns.

        OldState = ATALK_TIMER_RUNNING;
	}

	RELEASE_SPIN_LOCK(&atalkTimerLock, OldIrql);

    if (pdwOldState)
    {
        *pdwOldState = OldState;
    }

	return Cancelled;
}


#if	DBG

VOID
AtalkTimerDumpList(
	VOID
)
{
	PTIMERLIST	pList;
	ULONG		CumTime = 0;

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
			("TIMER LIST: (Times are in 100ms units)\n"));
	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
			("\tTime(Abs)  Time(Rel)  Routine Address  TimerList\n"));

	ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

	for (pList = atalkTimerList;
		 pList != NULL;
		 pList = pList->tmr_Next)
	{
		CumTime += pList->tmr_RelDelta;
		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("\t    %5d      %5ld          %lx   %lx\n",
				pList->tmr_AbsTime, CumTime,
				pList->tmr_Routine, pList));
	}

	RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atktimer.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktimer.h

Abstract:

	This module contains routines to schedule timer events.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKTIMER_
#define	_ATKTIMER_

struct _TimerList;

typedef	LONG (FASTCALL * TIMER_ROUTINE)(IN struct _TimerList *pTimer, IN BOOLEAN TimerShuttingDown);

#define	TMR_SIGNATURE		*(PULONG)"ATMR"
#if	DBG
#define	VALID_TMR(pTmr)		(((pTmr) != NULL) && \
							 ((pTmr)->tmr_Signature == TMR_SIGNATURE))
#else
#define	VALID_TMR(pTmr)		((pTmr) != NULL)
#endif
typedef	struct _TimerList
{
#if	DBG
	ULONG					tmr_Signature;
#endif
	struct _TimerList *		tmr_Next;		// Link to next
	struct _TimerList **	tmr_Prev;		// Link to prev
	TIMER_ROUTINE			tmr_Routine;	// Timer routine
	SHORT					tmr_AbsTime;	// Absolute time, for re-enqueue
	SHORT					tmr_RelDelta;	// Relative to the previous entry
	union
	{
		struct
		{
			BOOLEAN			tmr_Queued;		// TRUE, if currently queued
			BOOLEAN			tmr_Cancelled;	// TRUE, if cancelled
			BOOLEAN			tmr_Running;	// TRUE, if currently running
			BOOLEAN			tmr_CancelIt;	// TRUE, if cancel called while active
		};
		DWORD				tmr_Bools;		// For clearing all
	};
} TIMERLIST, *PTIMERLIST;

extern
NTSTATUS
AtalkTimerInit(
	VOID
);

/***	AtalkTimerInitialize
 *
 *	Initialize the timer list structure.
extern
VOID
AtalkTimerInitialize(
 IN	PTIMERLIST			pList,			// TimerList to use for queuing
 IN	TIMER_ROUTINE		TimerRoutine,	// TimerRoutine
 IN	SHORT				DeltaTime		// Schedule after this much time
);
 */

#if DBG
#define	AtalkTimerInitialize(pList, TimerRoutine, DeltaTime)	\
	{															\
		(pList)->tmr_Signature = TMR_SIGNATURE;					\
		(pList)->tmr_Routine = TimerRoutine;					\
		(pList)->tmr_AbsTime = DeltaTime;						\
		(pList)->tmr_Bools = 0;									\
	}
#else
#define	AtalkTimerInitialize(pList, TimerRoutine, DeltaTime)	\
	{															\
		(pList)->tmr_Routine = TimerRoutine;					\
		(pList)->tmr_AbsTime = DeltaTime;						\
		(pList)->tmr_Bools = 0;									\
	}
#endif

extern
VOID FASTCALL
AtalkTimerScheduleEvent(
	IN	PTIMERLIST			pTimerList		// TimerList to use for queuing
);

extern
VOID
AtalkTimerFlushAndStop(
	VOID
);

extern
BOOLEAN FASTCALL
AtalkTimerCancelEvent(
	IN	PTIMERLIST			pTimerList,		// TimerList used for queuing
	IN	PDWORD              pdwOldState     // return old state
);

#define	AtalkTimerSetAbsTime(pTimerList, AbsTime)	\
	{												\
		ASSERT(!(pTimerList)->tmr_Queued);			\
		(pTimerList)->tmr_AbsTime = AbsTime;		\
	}

extern	LONG					AtalkTimerCurrentTick;

#define	AtalkGetCurrentTick()	AtalkTimerCurrentTick

// Keep this at 100ms unit
#define	ATALK_TIMER_FACTOR		10			// i.e. 10 ticks per second
#define	ATALK_TIMER_TICK		-1000000L	// 100ms in 100ns units
#define	ATALK_TIMER_NO_REQUEUE	0			// Do not re-enqueue
#define	ATALK_TIMER_REQUEUE		-1			// Re-enqueue at current count

#define ATALK_TIMER_QUEUED      1
#define ATALK_TIMER_RUNNING     2
#define ATALK_TIMER_CANCELLED   3


extern	PTIMERLIST			atalkTimerList;
extern	ATALK_SPIN_LOCK		atalkTimerLock;
extern	LARGE_INTEGER		atalkTimerTick;
extern	KTIMER				atalkTimer;
extern	KDPC				atalkTimerDpc;
extern	KEVENT				atalkTimerStopEvent;
extern	BOOLEAN				atalkTimerStopped;	// Set to TRUE if timer system stopped
extern	BOOLEAN				atalkTimerRunning;	// Set to TRUE when timer Dpc is running

LOCAL VOID
atalkTimerDpcRoutine(
	IN	PKDPC				pKDpc,
	IN	PVOID				pContext,
	IN	PVOID				SystemArgument1,
	IN	PVOID				SystemArgument2
);

LOCAL VOID FASTCALL
atalkTimerEnqueue(
	IN	PTIMERLIST	pList
);

#endif	// _ATKTIMER_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkutils.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkutils.h

Abstract:

	This module contains miscellaneous support routines.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKUTILS_
#define	_ATKUTILS_

//	SpinLock Macros
#if	DBG
#define INITIALIZE_SPIN_LOCK(_pLock)											\
	{																			\
		KeInitializeSpinLock(&(_pLock)->SpinLock);								\
		(_pLock)->FileLineLock = 0;												\
	}
#else	// DBG
#define INITIALIZE_SPIN_LOCK(_pLock)											\
	{																			\
		KeInitializeSpinLock(&(_pLock)->SpinLock);								\
	}
#endif

#if	DBG
#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)									\
	{																			\
		KeAcquireSpinLock(&(_pLock)->SpinLock,									\
						  _pOldIrql);											\
		(_pLock)->FileLineLock = (FILENUM | __LINE__);							\
	}

#define ACQUIRE_SPIN_LOCK_DPC(_pLock)											\
	{																			\
		ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);							\
		KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);						\
		(_pLock)->FileLineLock = (FILENUM | __LINE__ | 0x80000000);				\
	}

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)										\
	{																			\
		ASSERT ((_pLock)->FileLineLock != 0);									\
		ASSERT (((_pLock)->FileLineLock & 0x80000000) == 0);					\
		(_pLock)->FileLineLock = 0;												\
		(_pLock)->FileLineUnlock = (FILENUM | __LINE__);						\
		KeReleaseSpinLock(&(_pLock)->SpinLock,									\
						  _OldIrql);											\
	}

#define RELEASE_SPIN_LOCK_DPC(_pLock)											\
	{																			\
		ASSERT ((_pLock)->FileLineLock != 0);									\
		ASSERT ((_pLock)->FileLineLock & 0x80000000);							\
		(_pLock)->FileLineLock = 0;												\
		(_pLock)->FileLineUnlock = (FILENUM | __LINE__ | 0x80000000);			\
		KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);						\
		ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);							\
	}

#else	// DBG

#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)									\
	{																			\
		KeAcquireSpinLock(&(_pLock)->SpinLock,									\
						  _pOldIrql);											\
	}

#define ACQUIRE_SPIN_LOCK_DPC(_pLock)											\
	{																			\
		KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);						\
	}

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)										\
	{																			\
		KeReleaseSpinLock(&(_pLock)->SpinLock,									\
						  (_OldIrql));											\
	}

#define RELEASE_SPIN_LOCK_DPC(_pLock) 											\
	{																			\
		KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);						\
	}																			\

#endif	// DBG

// Macros for ExInterlocked calls
#define INTERLOCKED_INCREMENT_LONG(p, l)			InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG(p, l)			InterlockedDecrement(p)
#define INTERLOCKED_INCREMENT_LONG_DPC(p, l)		InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG_DPC(p, l)		InterlockedDecrement(p)
#define	INTERLOCKED_ADD_STATISTICS(p, v, l)			ExInterlockedAddLargeStatistic(p, v)
#define INTERLOCKED_ADD_ULONG(p, v, l)				ExInterlockedAddUlong(p, v, l)
#define INTERLOCKED_ADD_LARGE_INTGR(p, v, l)		ExInterlockedAddLargeInteger(p, v, l)

#define INTERLOCKED_ADD_ULONG_DPC(p, v, l)			ExInterlockedAddUlong(p, v, l)
#define INTERLOCKED_ADD_LARGE_INTGR_DPC(p, v, l)	ExInterlockedAddLargeInteger(p, v, l)

#define	ATALK_NODES_EQUAL(N1, N2)												\
				((((N1)->atn_Network == (N2)->atn_Network) ||					\
				  ((N1)->atn_Network == 0) ||									\
				  ((N2)->atn_Network == 0)) &&									\
				 ((N1)->atn_Node == (N2)->atn_Node))


#define	ATALK_ADDRS_EQUAL(A1, A2)												\
				((((A1)->ata_Network == (A2)->ata_Network) ||					\
				  ((A1)->ata_Network == 0) ||									\
				  ((A2)->ata_Network == 0)) &&									\
				 ((A1)->ata_Node == (A2)->ata_Node) &&							\
				 ((A1)->ata_Socket == (A2)->ata_Socket))
				

#define	INVALID_ADDRESS(pAddr)													\
				(((pAddr)->ata_Network > LAST_VALID_NETWORK)	||				\
				(((pAddr)->ata_Node > MAX_USABLE_ATALKNODE)	&&					\
				 ((pAddr)->ata_Node != ATALK_BROADCAST_NODE))	||				\
				((pAddr)->ata_Socket < FIRST_VALID_SOCKET)		||				\
				((pAddr)->ata_Socket > LAST_VALID_SOCKET))

#define	ATALKADDR_TO_TDI(pTdiAddr, pAtalkAddr)									\
	{																			\
		(pTdiAddr)->TAAddressCount = 1;											\
		(pTdiAddr)->Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);	\
		(pTdiAddr)->Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;		\
		(pTdiAddr)->Address[0].Address[0].Network = (pAtalkAddr)->ata_Network;	\
		(pTdiAddr)->Address[0].Address[0].Node = (pAtalkAddr)->ata_Node;		\
		(pTdiAddr)->Address[0].Address[0].Socket = (pAtalkAddr)->ata_Socket;	\
	}

#define	TDI_TO_ATALKADDR(pAtalkAddr, pTdiAddr)									\
	{																		\
		ASSERTMSG("TdiAddrCount is not 1\n",								\
			((pTdiAddr)->TAAddressCount == 1));								\
																			\
		ASSERTMSG("TdiAddrLen invalid\n",									\
			((pTdiAddr)->Address[0].AddressLength >=						\
			sizeof(TDI_ADDRESS_APPLETALK)));								\
																			\
		ASSERTMSG("TdiAddrType invalid\n",									\
			((pTdiAddr)->Address[0].AddressType ==							\
			TDI_ADDRESS_TYPE_APPLETALK));									\
																			\
		(pAtalkAddr)->ata_Network = (pTdiAddr)->Address[0].Address[0].Network;\
		(pAtalkAddr)->ata_Node = (pTdiAddr)->Address[0].Address[0].Node;	\
		(pAtalkAddr)->ata_Socket = (pTdiAddr)->Address[0].Address[0].Socket;\
	}																		

#define	IN_NETWORK_RANGE(NetworkNumber, pRte)									\
			(((pRte)->rte_NwRange.anr_FirstNetwork == NetworkNumber)   ||		\
			  ((NetworkNumber >= (pRte)->rte_NwRange.anr_FirstNetwork) &&		\
			   (NetworkNumber <= (pRte)->rte_NwRange.anr_LastNetwork)))

#define	WITHIN_NETWORK_RANGE(NetworkNumber, pRange)								\
			 (((pRange)->anr_FirstNetwork == NetworkNumber) ||					\
			  ((NetworkNumber >= (pRange)->anr_FirstNetwork) &&					\
			   (NetworkNumber <= (pRange)->anr_LastNetwork)))

#define	COPY_NETWORK_ADDR(_Dst, _Src)											\
	{																			\
		*((ULONG UNALIGNED *)(_Dst)) = *((ULONG UNALIGNED *)(_Src));			\
		*((USHORT UNALIGNED *)((UCHAR *)(_Dst)+4)) =							\
							*((USHORT UNALIGNED *)((UCHAR *)(_Src)+4));			\
	}

//	Hash functions
//	Make sure we're positive [thus the shift by 7 rather than 8].
//	Only hash node and  socket; due to the "zero matches all" for
//	non-extended network numbers.

#define HASH_ATALK_ADDR(address)												\
	((USHORT)(((address)->ata_Node << 7) +					  					\
			  ((address)->ata_Socket & 0x7F)))

#define HASH_ATALK_NODE(address)						   						\
	((USHORT)((((address)->atn_Network & 0x3C) >> 2) +			   				\
			  (address)->atn_Node & 0x04))

#define	HASH_ID_SRCADDR(id, pSrcAddr)											\
	((id) + (((pSrcAddr)->ata_Node >> 2) + ((pSrcAddr)->ata_Network & 0xFF)))


/*
 * The following macros deal with on-the-wire integer and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04. Similarly an int value of 0x0102 is
 * represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2SHORT(DstPtr, SrcPtr)											\
		*(PUSHORT)(DstPtr) = (USHORT) (*(PBYTE)(SrcPtr))

// Get a byte from on-the-wire format to a dword in the host format
#define GETBYTE2DWORD(DstPtr, SrcPtr)											\
		*(PDWORD)(DstPtr) = (DWORD) (*(PBYTE)(SrcPtr))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2DWORD(DstPtr, SrcPtr)											\
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +						\
							  (*((PBYTE)(SrcPtr)+1)))

// Get a short from on-the-wire format to a short in the host format
#define GETSHORT2SHORT(DstPtr, SrcPtr)											\
		*(PUSHORT)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +						\
							  (*((PBYTE)(SrcPtr)+1)))

// Get a dword from on-the-wire format to a dword in the host format
#define GETDWORD2DWORD(DstPtr, SrcPtr)											\
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 24) +						\
							  (*((PBYTE)(SrcPtr)+1) << 16) +					\
							  (*((PBYTE)(SrcPtr)+2) << 8)  +					\
							  (*((PBYTE)(SrcPtr)+3)))

// Put a dword from the host format to a short to on-the-wire format
#define PUTBYTE2BYTE(DstPtr, Src)												\
		*((PBYTE)(DstPtr)) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2BYTE(DstPtr, Src)												\
		*((PBYTE)(DstPtr)) = ((USHORT)(Src) % 256)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2SHORT(DstPtr, Src)												\
		*((PBYTE)(DstPtr)+0) = (BYTE) ((USHORT)(Src) >> 8),						\
		*((PBYTE)(DstPtr)+1) = (BYTE)(Src)

// Put a dword from the host format to a byte to on-the-wire format
#define PUTDWORD2BYTE(DstPtr, Src)												\
		*(PBYTE)(DstPtr) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTDWORD2SHORT(DstPtr, Src)												\
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 8),						\
		*((PBYTE)(DstPtr)+1) = (BYTE) (Src)

// Put a dword from the host format to a dword to on-the-wire format
#define PUTDWORD2DWORD(DstPtr, Src)												\
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 24),						\
		*((PBYTE)(DstPtr)+1) = (BYTE) ((DWORD)(Src) >> 16),						\
		*((PBYTE)(DstPtr)+2) = (BYTE) ((DWORD)(Src) >>  8),						\
		*((PBYTE)(DstPtr)+3) = (BYTE) (Src)

//	MIN/MAX macros
#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))

extern	BYTE AtalkUpCaseTable[];

extern
VOID
AtalkUpCase(
	IN	PBYTE	pSrc,
	IN	BYTE	SrcLen,
	OUT	PBYTE	pDst
);

extern
BOOLEAN
AtalkCompareCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
);

extern
int
AtalkOrderCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
);

#define	AtalkFixedCompareCaseInsensitive(s1, l1, s2, l2)						\
		(((l1) == (l2)) && AtalkCompareFixedCaseInsensitive(s1, s2, l1))

extern
BOOLEAN
AtalkCompareFixedCaseInsensitive(
	IN	PBYTE		s1,
	IN	PBYTE		s2,
	IN	int			len
);

#define	AtalkFixedCompareCaseSensitive(s1, l1, s2, l2)							\
			((l1 == l2) && !memcmp(s1, s2, l1))

extern
PBYTE
AtalkSearchBuf(
	IN	PBYTE	pBuf,
	IN	BYTE	BufLen,
	IN	BYTE	SearchChar
);


int
GetTokenLen(
        IN PBYTE pTokStr,
        IN int   WildStringLen,
        IN BYTE  NBP_WILD_CHARACTER
        );

BOOLEAN
SubStringMatch(
        IN PBYTE pTarget,
        IN PBYTE pTokStr,
        IN int   StringLen,
        IN int   TokStrLen
        );
extern
BOOLEAN
AtalkCheckNetworkRange(
	IN	PATALK_NETWORKRANGE	NetworkRange
);

#define	AtalkRangesOverlap(pRange1, pRange2)									\
		(((pRange1)->anr_LastNetwork >= (pRange2)->anr_FirstNetwork) &&			\
		 ((pRange1)->anr_FirstNetwork <= (pRange2)->anr_LastNetwork))

extern
BOOLEAN
AtalkIsPrime(
	long Step
);

extern
LONG
AtalkRandomNumber(
	VOID
);


extern
VOID
AtalkDbgIncCount(
    IN DWORD    *Value
);

extern
VOID
AtalkDbgDecCount(
    IN DWORD    *Value
);

// Used for calculating round trip times using Van Jacobson algorithm
typedef struct
{
	ULONG	rt_New;
	SHORT	rt_Min;
	SHORT	rt_Max;
	SHORT	rt_Ave;
	SHORT	rt_Dev;
	SHORT	rt_Base;
} RT, *PRT;

#define	AtalkInitializeRT(pRT, Initial, Min, Max)								\
	{																			\
		(pRT)->rt_Min = Min;													\
		(pRT)->rt_Max = Max;													\
		(pRT)->rt_Base = Initial;												\
		(pRT)->rt_Ave = Min;													\
		(pRT)->rt_Dev = 0;														\
	}

#define	AtalkCalculateNewRT(pRT)												\
	{																			\
		SHORT	baseT, error;													\
																				\
		/* VAN JACOBSEN Algorithm.  From Internetworking with Tcp/ip (Comer). */\
																				\
		if ((pRT)->rt_New == 0)													\
			(pRT)->rt_New = 1;		/* Do not let this go to zero */			\
																				\
		error = (SHORT)((pRT)->rt_New) - ((pRT)->rt_Ave >> 3);					\
		(pRT)->rt_Ave	+= error;												\
		/* Make sure not too small */											\
		if ((pRT)->rt_Ave <= 0)	 												\
		{																		\
			(pRT)->rt_Ave = (pRT)->rt_Min;										\
		}																		\
																				\
		if (error < 0)															\
			error = -error;														\
																				\
		error -= ((pRT)->rt_Dev >> 2);											\
		(pRT)->rt_Dev	+= error;												\
		if ((pRT)->rt_Dev <= 0)													\
			(pRT)->rt_Dev = 1;													\
																				\
		baseT = ((((pRT)->rt_Ave >> 2) + (pRT)->rt_Dev) >> 1);					\
																				\
		/*	If less then min - set it */										\
		if (baseT < (pRT)->rt_Min)												\
			baseT = (pRT)->rt_Min;												\
																				\
		/*	If greater than max - set it */										\
		if (baseT > (pRT)->rt_Max)												\
			baseT = (pRT)->rt_Max;												\
																				\
		/*	Set the new value */												\
		(pRT)->rt_Base = baseT;													\
	}

extern
BOOLEAN
AtalkWaitTE(
	IN	PKEVENT	pEvent,
	IN	ULONG	TimeInMs
);

extern
VOID
AtalkSleep(
	IN	ULONG	TimeInMs
);

NTSTATUS
AtalkGetProtocolSocketType(
	PATALK_DEV_CTX   	Context,
	PUNICODE_STRING 	RemainingFileName,
	PBYTE  				ProtocolType,
	PBYTE  				SocketType
);

INT
AtalkIrpGetEaCreateType(
	IN PIRP Irp);

LOCAL LONG
atalkStringHash(
	IN	PBYTE	String,
	IN	BYTE	StrLen
);

#endif	// _ATKUTILS_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkutils.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	AtkUtils.c

Abstract:

	This module contains miscellaneous support routines

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	25 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKUTILS

#define	ONE_MS_IN_100ns		-10000L		// 1ms in 100ns units

extern	BYTE AtalkUpCaseTable[256];

VOID
AtalkUpCase(
	IN	PBYTE	pSrc,
	IN	BYTE	SrcLen,
	OUT	PBYTE	pDst
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	while (SrcLen --)
	{
		*pDst++ = AtalkUpCaseTable[*pSrc++];
	}
}




BOOLEAN
AtalkCompareCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE	c1, c2;

	while (((c1 = *s1++) != 0) && ((c2 = *s2++) != 0))
	{
		if (AtalkUpCaseTable[c1] != AtalkUpCaseTable[c2])
			return(FALSE);
	}

	return (c2 == 0);
}




int
AtalkOrderCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE	c1, c2;

	while (((c1 = *s1++) != 0) && ((c2 = *s2++) != 0))
	{
		c1 = AtalkUpCaseTable[c1];
		c2 = AtalkUpCaseTable[c2];
		if (c1 != c2)
			return (c1 - c2);
	}

	if (c2 == 0)
		return 0;

	return (-1);
}




BOOLEAN
AtalkCompareFixedCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2,
	IN	int		len
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	while(len--)
	{
		if (AtalkUpCaseTable[*s1++] != AtalkUpCaseTable[*s2++])
			return(FALSE);
	}

	return(TRUE);
}




PBYTE
AtalkSearchBuf(
	IN	PBYTE	pBuf,
	IN	BYTE	BufLen,
	IN	BYTE	SearchChar
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	for (NOTHING;
		 (BufLen != 0);
		 BufLen--, pBuf++)
	{
		if (*pBuf == SearchChar)
		{
			break;
		}
	}

	return ((BufLen == 0) ? NULL : pBuf);
}


int
GetTokenLen(
        IN PBYTE pTokStr,
        IN int   WildStringLen,
        IN BYTE  SearchChar
        )
/*++

Routine Description:

       Find the substring between start of the given string and the first
       wildchar after that, and return the length of the substring
--*/

{
        int    len;


        len = 0;

        while (len < WildStringLen)
        {
            if (pTokStr[len] == SearchChar)
            {
                break;
            }
            len++;
        }

        return (len);

}

BOOLEAN
SubStringMatch(
        IN PBYTE pTarget,
        IN PBYTE pTokStr,
        IN int   StringLen,
        IN int   TokStrLen
        )
/*++

Routine Description:

        Search pTarget string to see if the substring pTokStr can be
        found in it.
--*/
{
        int     i;

        if (TokStrLen > StringLen)
        {
            return (FALSE);
        }

        // if the pTarget string is "FooBarString" and if the substring is
        // BarStr
        for (i=(StringLen-TokStrLen); i>=0; i--)
        {
            if ( AtalkFixedCompareCaseInsensitive( pTarget+i,
                                                   TokStrLen,
                                                   pTokStr,
                                                   TokStrLen) )
            {
                return( TRUE );
            }
        }

        return (FALSE);
}

BOOLEAN
AtalkCheckNetworkRange(
	IN	PATALK_NETWORKRANGE	Range
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if ((Range->anr_FirstNetwork < FIRST_VALID_NETWORK) 		||
		(Range->anr_FirstNetwork > LAST_VALID_NETWORK)  		||
		(Range->anr_LastNetwork < FIRST_VALID_NETWORK)  		||
		(Range->anr_LastNetwork > LAST_VALID_NETWORK)			||
		(Range->anr_LastNetwork < Range->anr_FirstNetwork) 		||
		(Range->anr_FirstNetwork >= FIRST_STARTUP_NETWORK))
	{
		return(FALSE);
	}

	return(TRUE);
}




BOOLEAN
AtalkIsPrime(
	long Step
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	// We assume "step" is odd.
	long i, j;
	
	// All odds, seven and below, are prime.
	if (Step <= 7)
		return (TRUE);
	
	//	Do a little divisibility checking. The "/3" is a reasonably good
	// shot at sqrt() because the smallest odd to come through here will be
	// 9.
	j = Step/3;
	for (i = 3; i <= j; i++)
		if (Step % i == 0)
			return(FALSE);
	
	return(TRUE);
	
}




LONG
AtalkRandomNumber(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LARGE_INTEGER	Li;
	static LONG		seed = 0;

	// Return a positive pseudo-random number; simple linear congruential
	// algorithm. ANSI C "rand()" function.

	if (seed == 0)
	{
		KeQuerySystemTime(&Li);
		seed = Li.LowPart;
	}

	seed *= (0x41C64E6D + 0x3039);

	return (seed & 0x7FFFFFFF);
}


BOOLEAN
AtalkWaitTE(
	IN	PKEVENT	pEvent,
	IN	ULONG	TimeInMs
	)
/*++

Routine Description:

	Wait for an event to get signalled or a time to elapse

Arguments:


Return Value:


--*/
{
	TIME		Time;
	NTSTATUS	Status;

	// Make sure we can indeed wait
	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	// Initialize the event
	KeInitializeEvent(pEvent, NotificationEvent, FALSE);

	Time.QuadPart = Int32x32To64((LONG)TimeInMs, ONE_MS_IN_100ns);
	Status = KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, &Time);

	return (Status != STATUS_TIMEOUT);
}




VOID
AtalkSleep(
	IN	ULONG	TimeInMs
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KTIMER			SleepTimer;
	LARGE_INTEGER	TimerValue;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	KeInitializeTimer(&SleepTimer);

	TimerValue.QuadPart = Int32x32To64(TimeInMs, ONE_MS_IN_100ns);
	KeSetTimer(&SleepTimer,
			   TimerValue,
			   NULL);

	KeWaitForSingleObject(&SleepTimer, UserRequest, KernelMode, FALSE, NULL);
}




NTSTATUS
AtalkGetProtocolSocketType(
	PATALK_DEV_CTX		Context,
	PUNICODE_STRING 	RemainingFileName,
	PBYTE				ProtocolType,
	PBYTE				SocketType
)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS			status = STATUS_SUCCESS;
	ULONG				protocolType;
	UNICODE_STRING		typeString;

	*ProtocolType = PROTOCOL_TYPE_UNDEFINED;
	*SocketType	= SOCKET_TYPE_UNDEFINED;

	switch (Context->adc_DevType)
	{
	  case ATALK_DEV_DDP :

		if ((UINT)RemainingFileName->Length <= (sizeof(PROTOCOLTYPE_PREFIX) - sizeof(WCHAR)))
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		RtlInitUnicodeString(&typeString,
							(PWCHAR)((PCHAR)RemainingFileName->Buffer +
									 sizeof(PROTOCOLTYPE_PREFIX) - sizeof(WCHAR)));

		status = RtlUnicodeStringToInteger(&typeString,
										   DECIMAL_BASE,
										   &protocolType);

		if (NT_SUCCESS(status))
		{

			DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
					("AtalkGetProtocolType: protocol type is %lx\n", protocolType));

			if ((protocolType > DDPPROTO_DDP) && (protocolType <= DDPPROTO_MAX))
			{
				*ProtocolType = (BYTE)protocolType;
			}
			else
			{
				status = STATUS_NO_SUCH_DEVICE;
			}
		}
		break;

	  case ATALK_DEV_ADSP :

		// Check for the socket type
		if (RemainingFileName->Length == 0)
		{
			*SocketType = SOCKET_TYPE_RDM;
			break;
		}

		if ((UINT)RemainingFileName->Length != (sizeof(SOCKETSTREAM_SUFFIX) - sizeof(WCHAR)))
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		RtlInitUnicodeString(&typeString, SOCKETSTREAM_SUFFIX);

		//  Case insensitive compare
		if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
		{
			*SocketType = SOCKET_TYPE_STREAM;
			break;
		}
		else
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

	  case ATALK_DEV_ASPC:
	  case ATALK_DEV_ASP :
	  case ATALK_DEV_PAP :
		break;

	  default:
		status = STATUS_NO_SUCH_DEVICE;
		break;
	}

	return(status);
}



INT
AtalkIrpGetEaCreateType(
	IN PIRP Irp
	)
/*++

Routine Description:

 	Checks the EA name and returns the appropriate open type.

Arguments:

 	Irp - the irp for the create request, the EA value is stored in the
 		  SystemBuffer

Return Value:

 	TDI_TRANSPORT_ADDRESS_FILE: Create irp was for a transport address
 	TDI_CONNECTION_FILE: Create irp was for a connection object
 	ATALK_FILE_TYPE_CONTROL: Create irp was for a control channel (ea = NULL)

--*/
{
	PFILE_FULL_EA_INFORMATION 	openType;
	BOOLEAN 					found;
	INT 						returnType=0;   // not a valid type
	USHORT 						i;

	openType = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	if (openType != NULL)
	{
		do
		{
			found = TRUE;

			for (i=0;
                 (i<(USHORT)openType->EaNameLength) && (i < sizeof(TdiTransportAddress));
                 i++)
			{
				if (openType->EaName[i] == TdiTransportAddress[i])
				{
					continue;
				}
				else
				{
					found = FALSE;
					break;
				}
			}

			if (found)
			{
				returnType = TDI_TRANSPORT_ADDRESS_FILE;
				break;
			}

			//
			// Is this a connection object?
			//

			found = TRUE;

			for (i=0;
                 (i<(USHORT)openType->EaNameLength) && (i < sizeof(TdiConnectionContext));
                 i++)
			{
				if (openType->EaName[i] == TdiConnectionContext[i])
				{
					 continue;
				}
				else
				{
					found = FALSE;
					break;
				}
			}

			if (found)
			{
				returnType = TDI_CONNECTION_FILE;
				break;
			}

		} while ( FALSE );

	}
	else
	{
		returnType = TDI_CONTROL_CHANNEL_FILE;
	}

	return(returnType);
}

#if DBG
VOID
AtalkDbgIncCount(
    IN DWORD    *Value
)
{
    KIRQL       OldIrql;

    ACQUIRE_SPIN_LOCK(&AtalkDebugSpinLock, &OldIrql);
    (*Value)++;
    RELEASE_SPIN_LOCK(&AtalkDebugSpinLock, OldIrql);
}

VOID
AtalkDbgDecCount(
    IN DWORD    *Value
)
{
    KIRQL       OldIrql;

    ACQUIRE_SPIN_LOCK(&AtalkDebugSpinLock, &OldIrql);
    ASSERT((*Value) > 0);
    (*Value)--;
    RELEASE_SPIN_LOCK(&AtalkDebugSpinLock, OldIrql);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atp.c

Abstract:

	This module contains the Appletalk Transaction Protocol code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4

	25 Mar 1994		JH - Changed the request response paradigm. It now works as follows:
					When a request comes in, a response structure is allocated, initialized
					and linked into the address object either in the hash table if it is a
					XO request or the ALO linear list if it an ALO.
					The GetReq handler is passed a pointer to the response structure. This
					is referenced for the GetReq handler. The GetReq handler must Dereference
					it explicity either in its release handler if a response was posted or
					after a CancelResp is called.

					The respDeref notifies the release handler when the reference goes to 1
					and frees it up when it goes to zero.

					The GetReq structure is now re-used if the handler so specifies. This
					avoids the free-ing and re-allocing of these structures as well as
					the need to call AtalkAtpGetReq() from within the handler.

					Retry and release timers are per-atp-address now instead of one per
					request and one per response. The release handler is not 'started'
					till a response is posted.
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	  	ATP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_PAP, AtalkAtpOpenAddress)	// Since PAP is the only one which calls
													// at DISPATCH_LEVEL
#pragma alloc_text(PAGE_ATP, AtalkAtpCleanupAddress)
#pragma alloc_text(PAGE_ATP, AtalkAtpCloseAddress)
#pragma alloc_text(PAGE_ATP, AtalkAtpPostReq)
#pragma alloc_text(PAGE_ATP, AtalkAtpSetReqHandler)
#pragma alloc_text(PAGE_ATP, AtalkAtpPostResp)
#pragma alloc_text(PAGE_ATP, AtalkAtpCancelReq)
#pragma alloc_text(PAGE_ATP, AtalkAtpIsReqComplete)
#pragma alloc_text(PAGE_ATP, AtalkAtpCancelResp)
#pragma alloc_text(PAGE_ATP, AtalkAtpCancelRespByTid)
#pragma alloc_text(PAGE_ATP, AtalkAtpPacketIn)
#pragma alloc_text(PAGE_ATP, atalkAtpTransmitReq)
#pragma alloc_text(PAGE_ATP, atalkAtpSendReqComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpTransmitResp)
#pragma alloc_text(PAGE_ATP, atalkAtpSendRespComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpTransmitRel)
#pragma alloc_text(PAGE_ATP, atalkAtpSendRelComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpRespComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpReqComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpGetNextTidForAddr)
#pragma alloc_text(PAGE_ATP, atalkAtpReqRefNextNc)
#pragma alloc_text(PAGE_ATP, atalkAtpReqDeref)
#pragma alloc_text(PAGE_ATP, atalkAtpRespRefNextNc)
#pragma alloc_text(PAGE_ATP, AtalkAtpRespDeref)
#pragma alloc_text(PAGE_ATP, atalkAtpReqTimer)
#pragma alloc_text(PAGE_ATP, atalkAtpRelTimer)
#pragma alloc_text(PAGE_ATP, AtalkAtpGenericRespComplete)

#endif

ATALK_ERROR
AtalkAtpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPort,
	IN		BYTE					Socket,
	IN OUT	PATALK_NODEADDR			pDesiredNode		OPTIONAL,
	IN		USHORT					MaxSinglePktSize,
	IN		BOOLEAN					SendUserBytesAll,
	IN		PATALK_DEV_CTX			pDevCtx				OPTIONAL,
	IN		BOOLEAN					CacheSocket,
	OUT		PATP_ADDROBJ	*		ppAtpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	ATALK_ERROR		error;

	do
	{
		if ((pAtpAddr = AtalkAllocZeroedMemory(sizeof(ATP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		//	Initialize this structure. Note that packet handler could
		//	entered with this context even before secondary initialization
		//	completes. So we make sure, that it will not touch anything
		//	until then by using the OPEN flag.

#if DBG
		pAtpAddr->atpao_Signature = ATPAO_SIGNATURE;
#endif

		//	Set creation reference count, include one each for release and retry timers
		pAtpAddr->atpao_RefCount 			= (CacheSocket ? 4 : 3);
		pAtpAddr->atpao_NextTid				= 1;
		pAtpAddr->atpao_MaxSinglePktSize 	= MaxSinglePktSize;
		pAtpAddr->atpao_DevCtx 				= pDevCtx;

		if (SendUserBytesAll)
		{
			pAtpAddr->atpao_Flags |= ATPAO_SENDUSERBYTESALL;
		}

		InitializeListHead(&pAtpAddr->atpao_ReqList);
		AtalkTimerInitialize(&pAtpAddr->atpao_RelTimer,
							 atalkAtpRelTimer,
							 ATP_RELEASE_TIMER_INTERVAL);

		InitializeListHead(&pAtpAddr->atpao_RespList);
		AtalkTimerInitialize(&pAtpAddr->atpao_RetryTimer,
							 atalkAtpReqTimer,
							 ATP_RETRY_TIMER_INTERVAL);

		//	Open the ddp socket
		error = AtalkDdpOpenAddress(pPort,
									Socket,
									pDesiredNode,
									AtalkAtpPacketIn,
									pAtpAddr,
									DDPPROTO_ANY,
									pDevCtx,
									&pAtpAddr->atpao_DdpAddr);

		if (!ATALK_SUCCESS(error))
		{
			//	Socket open error will be logged at the ddp level.
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpOpenAddress: AtalkDdpOpenAddress failed %ld\n", error));

			AtalkFreeMemory(pAtpAddr);
			break;
		}

		//	Activate the atp socket. Cache the socket if desired.
		//	This takes port lock on default port.
		if (CacheSocket)
		{
			if (!ATALK_SUCCESS(AtalkIndAtpCacheSocket(pAtpAddr, pPort)))
			{
				pAtpAddr->atpao_RefCount--;
				CacheSocket = FALSE;
			}
		}
		pAtpAddr->atpao_Flags |= (ATPAO_OPEN | ATPAO_TIMERS | (CacheSocket ? ATPAO_CACHED : 0));

		AtalkLockAtpIfNecessary();

		// Start the release timer for responses on this address
		AtalkTimerScheduleEvent(&pAtpAddr->atpao_RelTimer);

		// Start the retry timer for requests on this address
		AtalkTimerScheduleEvent(&pAtpAddr->atpao_RetryTimer);

		*ppAtpAddr = pAtpAddr;
	} while (FALSE);

	return error;
}




ATALK_ERROR
AtalkAtpCleanupAddress(
	IN	PATP_ADDROBJ			pAtpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_REQ		pAtpReq, pAtpReqNext;
	PATP_RESP		pAtpResp, pAtpRespNext;
	ATP_REQ_HANDLER	ReqHandler;
	ATALK_ERROR		error = ATALK_PENDING;
	KIRQL			OldIrql;
	USHORT			i;
	BOOLEAN			cached, CancelTimers, done, ReEnqueue;

	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);

	CancelTimers = FALSE;
	done = FALSE;
	if (pAtpAddr->atpao_Flags & ATPAO_TIMERS)
	{
		pAtpAddr->atpao_Flags &= ~ATPAO_TIMERS;
		CancelTimers = TRUE;
	}

	if (pAtpAddr->atpao_Flags & ATPAO_CLEANUP)
	{
		done = TRUE;
	}
    else
    {
        // put a Cleanup refcount for this routine, since we are going to cleanup
        pAtpAddr->atpao_RefCount++;
    }
	pAtpAddr->atpao_Flags |= ATPAO_CLEANUP;

	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	if (done)
	{
		return error;
	}

	if (CancelTimers)
	{
		//	Cancel the release timer
		if (AtalkTimerCancelEvent(&pAtpAddr->atpao_RelTimer, NULL))
		{
			AtalkAtpAddrDereference(pAtpAddr);
		}
        else
        {
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkAtpCleanupAddress: couldn't cancel release timer\n"));
        }

		//	And also the retry timer
		if (AtalkTimerCancelEvent(&pAtpAddr->atpao_RetryTimer, NULL))
		{
			AtalkAtpAddrDereference(pAtpAddr);
		}
        else
        {
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkAtpCleanupAddress: couldn't cancel retry timer\n"));
        }
	}

	ASSERT (pAtpAddr->atpao_RefCount >= 1);	// creation ref

	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);

	//	Call requests handler if set
	if ((ReqHandler = pAtpAddr->atpao_ReqHandler) != NULL)
	{
		pAtpAddr->atpao_ReqHandler = NULL;

		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

		(*ReqHandler)(ATALK_ATP_CLOSING,
					  pAtpAddr->atpao_ReqCtx,
					  NULL,
					  NULL,
					  0,
					  NULL,
					  NULL);

		//	Dereference address object.
		AtalkAtpAddrDereference(pAtpAddr);

		ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	}

	//	Cancel all the requests.
	for (i = 0; i < ATP_REQ_HASH_SIZE; i++)
	{
		if ((pAtpReq = pAtpAddr->atpao_ReqHash[i]) == NULL)
		{
			//	If empty, go on to the next index in hash table.
			continue;
		}

		//	Includes the one we are starting with.
		atalkAtpReqRefNextNc(pAtpReq, &pAtpReqNext, &error);
		if (!ATALK_SUCCESS(error))
		{
			//	No requests left on this index. Go to the next one.
			continue;
		}

		while (TRUE)
		{
			if ((pAtpReq = pAtpReqNext) == NULL)
			{
				break;
			}

			if ((pAtpReqNext = pAtpReq->req_Next) != NULL)
			{
				atalkAtpReqRefNextNc(pAtpReq->req_Next, &pAtpReqNext, &error);
				if (!ATALK_SUCCESS(error))
				{
					//	No requests left on this index. Go to the next one.
					pAtpReqNext = NULL;
				}
			}

			//	Cancel this request.
			RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

			AtalkAtpCancelReq(pAtpAddr,
							  pAtpReq->req_Tid,
							  &pAtpReq->req_Dest);

			ASSERTMSG("RefCount incorrect\n", (pAtpReq->req_RefCount >= 1));

            // remove the refcount added in the beginning of the loop
			AtalkAtpReqDereference(pAtpReq);
			ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
		}
	}

	//	Cancel all pending responses.
	for (i = 0; i < ATP_RESP_HASH_SIZE; i++)
	{
		if ((pAtpResp = pAtpAddr->atpao_RespHash[i]) == NULL)
		{
			//	If empty, go on to the next index in hash table.
			continue;
		}

		//	Includes the one we are starting with.
		atalkAtpRespRefNextNc(pAtpResp, &pAtpRespNext, &error);
		if (!ATALK_SUCCESS(error))
		{
			//	No requests left on this index. Go to the next one.
			continue;
		}

		while (TRUE)
		{
			if ((pAtpResp = pAtpRespNext) == NULL)
			{
				break;
			}

			if ((pAtpRespNext = pAtpResp->resp_Next) != NULL)
			{
				atalkAtpRespRefNextNc(pAtpResp->resp_Next, &pAtpRespNext, &error);
				if (!ATALK_SUCCESS(error))
				{
					//	No requests left on this index. Go to the next one.
					pAtpRespNext = NULL;
				}
			}

			//	Cancel this response
			RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

			AtalkAtpCancelResp(pAtpResp);

            // remove the refcount added in the beginning of the loop
            AtalkAtpRespDereference(pAtpResp);

			ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
		}
	}

	//	if the socket was cached, uncache it, remove reference.
	cached = FALSE;
	if (pAtpAddr->atpao_Flags & ATPAO_CACHED)
	{
		cached = TRUE;
		pAtpAddr->atpao_Flags &= ~ATPAO_CACHED;
	}

	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	if (cached)
	{
		AtalkIndAtpUnCacheSocket(pAtpAddr);
		AtalkAtpAddrDereference(pAtpAddr);
	}

    // remove the Cleanup refcount we put at the beginning of this routine
	AtalkAtpAddrDereference(pAtpAddr);

	return error;
}




ATALK_ERROR
AtalkAtpCloseAddress(
	IN	PATP_ADDROBJ			pAtpAddr,
	IN	ATPAO_CLOSECOMPLETION	pCloseCmp	OPTIONAL,
	IN	PVOID					pCloseCtx	OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			cleanup;

	//	Cancel all the pending get requests.
	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	if ((pAtpAddr->atpao_Flags & ATPAO_CLOSING) == 0)
	{
		cleanup = TRUE;
		if (pAtpAddr->atpao_Flags & ATPAO_CLEANUP)
			cleanup = FALSE;

		pAtpAddr->atpao_Flags |= ATPAO_CLOSING;
		pAtpAddr->atpao_CloseComp = pCloseCmp;
		pAtpAddr->atpao_CloseCtx = pCloseCtx;
		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

		if (cleanup)
			AtalkAtpCleanupAddress(pAtpAddr);

		//	Remove the creation reference
		AtalkAtpAddrDereference(pAtpAddr);
	}
	else
	{
		//	We are already closing! this should never happen!
		ASSERT ((pAtpAddr->atpao_Flags & ATPAO_CLOSING) != 0);
		KeBugCheck(0);
	}

	return ATALK_PENDING;
}




ATALK_ERROR
AtalkAtpPostReq(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		PATALK_ADDR				pDest,
	OUT		PUSHORT					pTid,
	IN		USHORT					Flags,
	IN		PAMDL					pReq,
	IN		USHORT					ReqLen,
	IN		PBYTE					pUserBytes		OPTIONAL,
	IN OUT	PAMDL					pResp			OPTIONAL,
	IN  	USHORT					RespLen			OPTIONAL,
	IN		SHORT					RetryCnt,
	IN		LONG					RetryInterval	OPTIONAL,	// In timer ticks
	IN		RELEASE_TIMERVALUE		RelTimerVal,
	IN		ATP_RESP_HANDLER		pCmpRoutine		OPTIONAL,
	IN		PVOID					pCtx			OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_REQ		pAtpReq;
	KIRQL			OldIrql;
	ULONG			index;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	//	Verify relevant parameters.
	do
	{
#ifdef	ATP_STRICT
		// NOTE: These checks need to be added to the TDI interface if/when ATP is
		//		 opened upto user mode.
		if ((ReqLen < 0)									||
			(ReqLen > pAtpAddr->atpao_MaxSinglePktSize)		||
			(RespLen < 0)									||
			(RespLen > (pAtpAddr->atpao_MaxSinglePktSize * ATP_MAX_RESP_PKTS)))
		{
			error = ATALK_BUFFER_TOO_BIG;
			break;
		}

		if ((RetryCnt < 0) && (RetryCnt != ATP_INFINITE_RETRIES))
		{
			error = ATALK_ATP_INVALID_RETRYCNT;
			break;
		}

		if ((RelTimerVal < FIRSTVALID_TIMER) || (RelTimerVal > LAST_VALID_TIMER))
		{
			error = ATALK_ATP_INVALID_TIMERVAL;
			break;
		}

		if (RetryInterval < 0)
		{
			error = ATALK_ATP_INVALID_RELINT;
			break;
		}
#endif
		// The only valid values for Flags are ATP_REQ_EXACTLY_ONCE and ATP_REQ_REMOTE
		ASSERT ((Flags & ~(ATP_REQ_EXACTLY_ONCE | ATP_REQ_REMOTE)) == 0);

		if (RetryInterval == 0)
		{
			RetryInterval = ATP_DEF_RETRY_INTERVAL;
		}

		//	Reference the address object.
		AtalkAtpAddrReference(pAtpAddr, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		if ((pAtpReq = (PATP_REQ)AtalkBPAllocBlock(BLKID_ATPREQ)) == NULL)
		{
			AtalkAtpAddrDereference(pAtpAddr);
			error = ATALK_RESR_MEM;
			break;
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
		return error;

	//	We have memory allocated and the address object referenced at this
	//	point. Initialize the request structure.
#if DBG
	RtlZeroMemory(pAtpReq, sizeof(ATP_REQ));
	pAtpReq->req_Signature = ATP_REQ_SIGNATURE;
#endif

	//	Initial reference count - for creation.
	//	Also another ref for this routine itself. Ran into a situation
	//	where a thread posting the request was preempted and a close called.
	//	So at the point where the first thread is doing the transmit call,
	//	the request structure is already freed.
	pAtpReq->req_RefCount		= 2;
	pAtpReq->req_pAtpAddr		= pAtpAddr;

	pAtpReq->req_RetryInterval	= RetryInterval;
	pAtpReq->req_RetryCnt		= RetryCnt;
	pAtpReq->req_RelTimerValue	= RelTimerVal;

	pAtpReq->req_Dest 	  		= *pDest;
	pAtpReq->req_Buf			= pReq;
	pAtpReq->req_BufLen			= ReqLen;

	if (RetryCnt != 0)
		Flags |= ATP_REQ_RETRY_TIMER;
	pAtpReq->req_Flags = Flags;

	if (pUserBytes != NULL)
	{
		RtlCopyMemory(pAtpReq->req_UserBytes,
					  pUserBytes,
					  ATP_USERBYTES_SIZE);
	}
	else
	{
		pAtpReq->req_dwUserBytes = 0;
	}

	pAtpReq->req_RespBuf 	= pResp;
	pAtpReq->req_RespBufLen = RespLen;
	atalkAtpBufferSizeToBitmap( pAtpReq->req_Bitmap,
								RespLen,
								pAtpAddr->atpao_MaxSinglePktSize);
	pAtpReq->req_RespRecdLen = 0;
	pAtpReq->req_RecdBitmap = 0;

	//	Setup the ndis buffer descriptors for the response buffer
	AtalkIndAtpSetupNdisBuffer(pAtpReq, pAtpAddr->atpao_MaxSinglePktSize);

	pAtpReq->req_Comp = pCmpRoutine;
	pAtpReq->req_Ctx = pCtx;

	INITIALIZE_SPIN_LOCK(&pAtpReq->req_Lock);

	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	atalkAtpGetNextTidForAddr(pAtpAddr,
							  pDest,
							  &pAtpReq->req_Tid,
							  &index);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpPostReq: Tid %lx for %lx.%lx.%lx\n",
			pAtpReq->req_Tid, pDest->ata_Network,
			pDest->ata_Node, pDest->ata_Socket));

	//	Get the index where this request is supposed to go.
	//	Need to know the tid.
	index = ATP_HASH_TID_DESTADDR(pAtpReq->req_Tid, pDest, ATP_REQ_HASH_SIZE);

	//	Put this in the request queue
	AtalkLinkDoubleAtHead(pAtpAddr->atpao_ReqHash[index],
						  pAtpReq,
						  req_Next,
						  req_Prev);

	if (RetryCnt != 0)
	{
		// Set the time stamp when this should be retried
		pAtpReq->req_RetryTimeStamp = AtalkGetCurrentTick() + RetryInterval;

		InsertTailList(&pAtpAddr->atpao_ReqList, &pAtpReq->req_List);
	}

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRequests,
								   &AtalkStatsLock.SpinLock);
#endif
	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	//	Return the tid
	*pTid = pAtpReq->req_Tid;

	//	Now send the request
	atalkAtpTransmitReq(pAtpReq);

	//	Remove the ref added at the beginning of this routine.
	AtalkAtpReqDereference(pAtpReq);

	return ATALK_NO_ERROR;
}



VOID
AtalkAtpSetReqHandler(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		ATP_REQ_HANDLER			ReqHandler,
	IN		PVOID					ReqCtx		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	ASSERT (ReqHandler != NULL);

	//	Set the request handler in the address object
	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);

	ASSERT((pAtpAddr->atpao_Flags & ATPAO_CLOSING) == 0);
	pAtpAddr->atpao_RefCount++;
	pAtpAddr->atpao_ReqHandler = ReqHandler;
	pAtpAddr->atpao_ReqCtx = ReqCtx;

	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);
}




ATALK_ERROR
AtalkAtpPostResp(
	IN		PATP_RESP				pAtpResp,
	IN		PATALK_ADDR				pDest,
	IN OUT	PAMDL					pResp,
	IN  	USHORT					RespLen,
	IN		PBYTE					pUserBytes	OPTIONAL,
	IN		ATP_REL_HANDLER			pCmpRoutine,
	IN		PVOID					pCtx		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	BOOLEAN			addrlocked = FALSE, resplocked = FALSE;
	BOOLEAN			DerefAddr = FALSE, DerefResp = FALSE;
	SHORT			ResponseLen;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	ASSERT(VALID_ATPRS(pAtpResp));
	ASSERT ((pAtpResp->resp_Flags & (ATP_RESP_VALID_RESP		|
									 ATP_RESP_REL_TIMER			|
									 ATP_RESP_HANDLER_NOTIFIED)) == 0);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpPostResp: Posting response for Resp %lx, Tid %x %s\n",
			pAtpResp, pAtpResp->resp_Tid,
			(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

	pAtpAddr = pAtpResp->resp_pAtpAddr;
	ASSERT(VALID_ATPAO(pAtpAddr));

	do
	{
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

		if ((RespLen < 0) ||
			(RespLen > (pAtpAddr->atpao_MaxSinglePktSize * ATP_MAX_RESP_PKTS)))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: Invalid buffer size %ld", RespLen));
			error = ATALK_BUFFER_INVALID_SIZE;
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		addrlocked = TRUE;

		atalkAtpAddrRefNonInterlock(pAtpAddr, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}
		DerefAddr = TRUE;

		atalkAtpBitmapToBufferSize( ResponseLen,
									pAtpResp->resp_Bitmap,
									pAtpAddr->atpao_MaxSinglePktSize);
		if (ResponseLen < RespLen)
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: bitmap resplen (%d) < specified (%d)\n",
					ResponseLen, RespLen));
			error = ATALK_BUFFER_TOO_BIG;
			break;
		}


		AtalkAtpRespReferenceByPtrDpc(pAtpResp, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}
		DerefResp = TRUE;

		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		resplocked = TRUE;

		if (pAtpResp->resp_Flags & (ATP_RESP_CLOSING | ATP_RESP_CANCELLED))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: Closing/Cancelled %x", pAtpResp->resp_Flags));
			error = ATALK_ATP_RESP_CLOSING;
			break;
		}

		if (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP)
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: Already posted !\n"));
			error = ATALK_ATP_RESP_TOOMANY;
			break;
		}

		//	No response was previously posted. OK to proceed.
		pAtpResp->resp_Flags |= ATP_RESP_VALID_RESP;

		pAtpResp->resp_Buf 		= pResp;
		pAtpResp->resp_BufLen	= RespLen;
		pAtpResp->resp_Comp 	= pCmpRoutine;

		ASSERT(pCmpRoutine != NULL);

		pAtpResp->resp_Ctx		= pCtx;
		pAtpResp->resp_Dest		= *pDest;
		pAtpResp->resp_UserBytesOnly = (pAtpResp->resp_Bitmap == 0) ? TRUE : FALSE;

		if (ARGUMENT_PRESENT(pUserBytes))
		{
			pAtpResp->resp_dwUserBytes = *(UNALIGNED ULONG *)pUserBytes;
		}
		else
		{
			pAtpResp->resp_dwUserBytes = 0;
		}

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpPostResp: Posting response for %s request id %x\n",
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO",
				pAtpResp->resp_Tid));

		//	Now setup to start the release timer, but only for XO
		if (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE)
		{
			pAtpResp->resp_Flags |= ATP_RESP_REL_TIMER;
			InsertTailList(&pAtpAddr->atpao_RespList, &pAtpResp->resp_List);
		}

		// For ALO set the comp status right here.
		pAtpResp->resp_CompStatus = error = ATALK_NO_ERROR;
	} while (FALSE);

	if (addrlocked)
	{
		if (resplocked)
			RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	}

	if (ATALK_SUCCESS(error))
	{
		//	Send the response.
		ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
				("AtalkAtpPostResp: Transmitting response %lx\n", pAtpResp));
		atalkAtpTransmitResp(pAtpResp);
	}

	//	Dereference the address object.
	if (DerefAddr)
		AtalkAtpAddrDereferenceDpc(pAtpAddr);

	if (DerefResp)
		AtalkAtpRespDereferenceDpc(pAtpResp);

	// for ALO transactions, we are done so take away the creation reference
	if ((pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) == 0)
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpPostResp: Removing creation reference for ALO request %lx Tid %x\n",
				pAtpResp, pAtpResp->resp_Tid));
		AtalkAtpRespDereferenceDpc(pAtpResp);
	}

	if (OldIrql != DISPATCH_LEVEL)
		KeLowerIrql(OldIrql);

	return error;
}



ATALK_ERROR
AtalkAtpCancelReq(
	IN		PATP_ADDROBJ		pAtpAddr,
	IN		USHORT				Tid,
	IN		PATALK_ADDR			pDest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	PATP_REQ		pAtpReq;

	//	Find the request.
	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	atalkAtpReqReferenceByAddrTidDpc(pAtpAddr,
									 pDest,
									 Tid,
									 &pAtpReq,
									 &error);

	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
				("AtalkAtpCancelReq: Cancelling req tid %x\n", Tid));

		//	Request is referenced for us. Remove the creation reference.
		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		// Do not cancel a request that has just about been satisfied anyway !!!
		if (pAtpReq->req_Flags & ATP_REQ_RESPONSE_COMPLETE)
		{
			error = ATALK_ATP_REQ_CLOSING;
		}

		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

		if (ATALK_SUCCESS(error))
		{
			//	Try to remove the creation reference
			atalkAtpReqComplete(pAtpReq, ATALK_ATP_REQ_CANCELLED);
		}

		//	Remove the reference added at the beginning.
		AtalkAtpReqDereference(pAtpReq);
	}
	else RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	return error;
}




BOOLEAN
AtalkAtpIsReqComplete(
	IN		PATP_ADDROBJ		pAtpAddr,
	IN		USHORT				Tid,
	IN		PATALK_ADDR			pDest
	)
/*++

Routine Description:

	This is always called at DISPATCH_LEVEL - only by PAP.

Arguments:

Return Value:


--*/
{
	PATP_REQ		pAtpReq;
	ATALK_ERROR		error;
	BOOLEAN			rc = FALSE;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	Find the request.
	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	atalkAtpReqReferenceByAddrTidDpc(pAtpAddr,
									 pDest,
									 Tid,
									 &pAtpReq,
									 &error);

	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		// Do not cancel a request that has just about been satisfied anyway !!!
		if (pAtpReq->req_Flags & ATP_REQ_RESPONSE_COMPLETE)
		{
			rc = TRUE;
		}

		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
		AtalkAtpReqDereferenceDpc(pAtpReq);
	}

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	return rc;
}


ATALK_ERROR
AtalkAtpCancelResp(
	IN		PATP_RESP			pAtpResp
	)
/*++

Routine Description:

	NOTE: A Response can be cancelled in two states:
		- *before* a response is posted
			In this case no release handler is there so an extra dereference needs to be done
		- *after* a response is posted
			In this case a release handler is associated which will do the final dereference.

Arguments:


Return Value:


--*/
{
	BOOLEAN			extraDeref = FALSE, CompleteResp = FALSE;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpCancelResp: Cancelling response for tid %x %s\n",
			pAtpResp->resp_Tid,
			(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

	AtalkAtpRespReferenceByPtr(pAtpResp, &error);

	if (ATALK_SUCCESS(error))
	{
		//	Remove the creation reference for it.
		//	Only XO responses can be cancelled, if a repsonse has been posted.
		ACQUIRE_SPIN_LOCK(&pAtpResp->resp_Lock, &OldIrql);

		if ((pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) == 0)
			extraDeref  = TRUE;

		pAtpResp->resp_Flags |= ATP_RESP_CANCELLED;

		if (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE)
		{
			if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
			{
				ASSERT (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);
			}
			CompleteResp = TRUE;
		}
		else if ((pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) == 0)
			CompleteResp = TRUE;

		RELEASE_SPIN_LOCK(&pAtpResp->resp_Lock, OldIrql);

		if (extraDeref)
			AtalkAtpRespDereference(pAtpResp);

		if (CompleteResp)
		{
			//	Try to remove the creation reference
			atalkAtpRespComplete(pAtpResp, ATALK_ATP_RESP_CANCELLED);
		}

		// Remove the reference added at the beginning.
		AtalkAtpRespDereference(pAtpResp);
	}
	else
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkAtpCancelResp: Failed to reference resp %lx, flags %x, tid %x\n",
				pAtpResp, pAtpResp->resp_Flags, pAtpResp->resp_Tid));
	}

	return error;
}




ATALK_ERROR
AtalkAtpCancelRespByTid(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		USHORT					Tid
/*++

Routine Description:


Arguments:


Return Value:


--*/
	)
{
	ATALK_ERROR	error;
	PATP_RESP	pAtpResp;

	ASSERT (VALID_ATPAO(pAtpAddr));

	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	atalkAtpRespReferenceByAddrTidDpc(pAtpAddr, pSrcAddr, Tid, &pAtpResp, &error);

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	if (ATALK_SUCCESS(error))
	{
		error = AtalkAtpCancelResp(pAtpResp);
		AtalkAtpRespDereferenceDpc(pAtpResp);
	}

	return error;
}


VOID
AtalkAtpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PATP_ADDROBJ		pAtpAddr,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	NTSTATUS		ntStatus;
	USHORT			atpDataSize;
	ULONG			index;
	BYTE			controlInfo, function, relTimer, bitmap;
	USHORT			seqNum, tid, startOffset;
	SHORT			expectedRespSize;
	ULONG			bytesCopied;
	BOOLEAN			sendSts, eomFlag, xoFlag;
	BOOLEAN			RetransmitResp = FALSE;

	PATP_REQ		pAtpReq;
	ATP_REQ_HANDLER	ReqHandler;
	PATP_RESP		pAtpResp;

	BOOLEAN			UnlockAddr = FALSE, DerefAddr = FALSE;
	PBYTE			pDgram 	= pPkt;
	TIME			TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);

	ASSERT(VALID_ATPAO(pAtpAddr));

	do
	{
		//	Check for incoming errors
		if ((!ATALK_SUCCESS(ErrorCode) &&
			 (ErrorCode != ATALK_SOCKET_CLOSED))	||
			(DdpType != DDPPROTO_ATP))
		{
			//	Drop the packet. Invalid packet error log.
			TMPLOGERR();
			error = ATALK_ATP_INVALID_PKT;
			break;
		}

		if (ErrorCode == ATALK_SOCKET_CLOSED)
		{
			//	Our ddp address pointer is no longer valid. It will be potentially
			//	be freed after return from this call! Only valid request on this
			//	ATP request will now be AtpCloseAddress(). Also, we should never
			//	be called with this address object by DDP.
			ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
			pAtpAddr->atpao_DdpAddr = NULL;
			pAtpAddr->atpao_Flags  &= ~ATPAO_OPEN;
			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

			// If we are coming in via the optimized path and socket closed
			// deref the address object since it was referenced within the
			// indication code.
			if (OptimizedPath)
			{
				AtalkAtpAddrDereferenceDpc(pAtpAddr);
			}
			error = ErrorCode;
			break;
		}

		//	Make sure that we are not called after the ddp socket is closed.
		ASSERT(pAtpAddr->atpao_Flags & ATPAO_OPEN);

		if (PktLen < ATP_HEADER_SIZE)
		{
			error = ATALK_ATP_INVALID_PKT;
			break;
		}

		//	This must fail if OPEN is not set/initialization.
		error = ATALK_NO_ERROR;
		if (!OptimizedPath)
		{
			AtalkAtpAddrReferenceDpc(pAtpAddr, &error);
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
		return;
	}

	//	Dereference address at the end,unless we want to keep it for some reason.
	DerefAddr = TRUE;

	//	Get the static fields from the ATP header.
	controlInfo = *pDgram++;


	function = (controlInfo & ATP_FUNC_MASK);
	relTimer = (controlInfo & ATP_REL_TIMER_MASK);
	xoFlag   = ((controlInfo & ATP_XO_MASK) != 0);
	eomFlag  = ((controlInfo & ATP_EOM_MASK) != 0);
	sendSts	 = ((controlInfo & ATP_STS_MASK) != 0);

	//	Get the bitmap/sequence number
	bitmap = *pDgram++;
	seqNum = (USHORT)bitmap;

	//	Get the transaction id
	GETSHORT2SHORT(&tid, pDgram);
	pDgram += sizeof(USHORT);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpPacketIn: Packet tid %lx fu %lx ci %lx\n",
			tid, function, controlInfo));

	//	pDgram now points to the user bytes.
	do
	{
		//	Check all the values
		if (relTimer > LAST_VALID_TIMER)
		{
			//	Use a thirty second timer value.
			relTimer = THIRTY_SEC_TIMER;
		}

		atpDataSize = PktLen - ATP_HEADER_SIZE;
		if (atpDataSize > pAtpAddr->atpao_MaxSinglePktSize)
		{
			error = ATALK_ATP_INVALID_PKT;
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		UnlockAddr = TRUE;

		switch (function)
		{
		  case ATP_REQUEST:
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Received REQUEST from %lx.%lx.%lx (%d.%d.%d)\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket,
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));

			if (xoFlag)
			{
				//	ExactlyOnce Transaction
				//	Check for a queued response. If available use it.
				atalkAtpRespReferenceByAddrTidDpc(pAtpAddr,
												  pSrcAddr,
												  tid,
												  &pAtpResp,
												  &error);

				if (ATALK_SUCCESS(error))
				{
					ASSERT (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE);

					//	Found a response corresponding to this request. It
					//	is referenced for us. Retransmit it, if there is a
					//	response posted on it.

					//	Check to see if this response has a valid response
					//	posted by the atp client yet. If so reset the release timer.
					ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

					if (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP)
					{
						if ((pAtpResp->resp_Flags & (ATP_RESP_TRANSMITTING | ATP_RESP_SENT)) == ATP_RESP_SENT)
						{

							RetransmitResp = TRUE;
							if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
							{
								DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
										("AtalkAtpPacketIn: Retransmitting request %lx, tid %x (%x)\n",
										pAtpResp, pAtpResp->resp_Tid, pAtpResp->resp_Flags));

								pAtpResp->resp_RelTimeStamp = AtalkGetCurrentTick() +
																pAtpResp->resp_RelTimerTicks;
								DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
										("AtalkAtpPacketIn: Restarted reltimer %lx\n", pAtpResp->resp_Tid));

								//	Set the latest bitmap for the request! We
								//	shouldn't touch this if no valid response is yet
								//	posted, so that we use the one in the first request
								//	packet received.
								pAtpResp->resp_Bitmap	= bitmap;
							}
							else
							{
								error = ATALK_ATP_RESP_CLOSING;

								//	Timer already fired. Drop the request.
								DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
										("AtalkAtpPacketIn: Req recv after Reltimer fired ? Flags %lx\n",
										pAtpResp->resp_Flags));

								ASSERT (pAtpResp->resp_Flags & ATP_RESP_CLOSING);
							}
						}
					}
					else
					{
						error = ATALK_ATP_NO_VALID_RESP;
					}

					RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
					RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
					UnlockAddr = FALSE;

					if (ATALK_SUCCESS(error))
					{
						ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);
						if (RetransmitResp)
						{
							DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
									("AtalkAtpPacketIn: Retransmitting response %lx\n", pAtpResp));

							INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRemoteRetries,
														   &AtalkStatsLock.SpinLock);
							atalkAtpTransmitResp(pAtpResp);
						}
					}

					//	Remove the refererence on this response structure.
					AtalkAtpRespDereferenceDpc(pAtpResp);
					break;
				}
			}

            // make sure the 4 bytes (pAtpResp->resp_dwUserBytes) exist
            if (PktLen < (ATP_USERBYTES_SIZE + sizeof(ULONG)))
            {
				error = ATALK_ATP_INVALID_PKT;
                ASSERT(0);
				break;
            }

			// Its either an ALO request or an XO request which we have not seen it before
			//	Decode the response bitmap. We're still holding the address spinlock
			atalkAtpBitmapToBufferSize( expectedRespSize,
										bitmap,
										pAtpAddr->atpao_MaxSinglePktSize);
			if (expectedRespSize < 0)
			{
				error = ATALK_ATP_INVALID_PKT;
				break;
			}

			if (xoFlag)
			{
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumXoResponse,
											   &AtalkStatsLock.SpinLock);
			}
			else
			{
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumAloResponse,
											   &AtalkStatsLock.SpinLock);
			}

			//	New request. Check for request handler set
			if ((ReqHandler = pAtpAddr->atpao_ReqHandler) == NULL)
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("AtalkAtpPacketIn: No GetRequests for request\n"));

				error = ATALK_ATP_NO_GET_REQ;
				break;
			}

			//	Allocate memory for a send response structure.
			if ((pAtpResp =(PATP_RESP)AtalkBPAllocBlock(BLKID_ATPRESP)) == NULL)
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("AtalkAtpPacketIn: Could not alloc mem for resp\n"));

				error = ATALK_RESR_MEM;
				break;
			}

#if DBG
			RtlZeroMemory(pAtpResp, sizeof(ATP_RESP));
			pAtpResp->resp_Signature = ATP_RESP_SIGNATURE;
#endif
			//	Initialize the send response structure. Note that we do
			//	not have a posted response yet for XO or this is an ALO

			//	Initialize spinlock/list
			INITIALIZE_SPIN_LOCK(&pAtpResp->resp_Lock);

			//  Reference for Creation and indication
			pAtpResp->resp_RefCount = 2;

			//	Remember the destination of this response.
			pAtpResp->resp_Dest = *pSrcAddr;
			pAtpResp->resp_Tid	= tid;
			pAtpResp->resp_Bitmap = bitmap;

			//	Backpointer to the address object
			pAtpResp->resp_pAtpAddr = pAtpAddr;

			//	Remember a response needs to be posted by the atp client.
			pAtpResp->resp_Flags = (OptimizedPath ? ATP_RESP_REMOTE : 0);
			pAtpResp->resp_UserBytesOnly = (bitmap == 0) ? TRUE : FALSE;
			pAtpResp->resp_Comp = NULL;
			pAtpResp->resp_Ctx = NULL;
			pAtpResp->resp_dwUserBytes = *(UNALIGNED ULONG *)(pDgram + ATP_USERBYTES_SIZE);

			if (xoFlag)
			{
				//	Get the index into the hash response array where this
				//	response would be.
				index = ATP_HASH_TID_DESTADDR(tid, pSrcAddr, ATP_RESP_HASH_SIZE);

				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkAtpPacketIn: XO Req Index %lx resp for %lx-%lx.%lx.%lx %d\n",
							index, tid, pSrcAddr->ata_Network, pSrcAddr->ata_Node,
							pSrcAddr->ata_Socket, AtalkAtpRelTimerTicks[relTimer]));

				//	Put this in the XO response queue - LOCK Should be acquired!
				AtalkLinkDoubleAtHead(pAtpAddr->atpao_RespHash[index],
									  pAtpResp,
									  resp_Next,
									  resp_Prev);

				pAtpResp->resp_Flags |= ATP_RESP_EXACTLY_ONCE;
				pAtpResp->resp_RelTimerTicks = (LONG)AtalkAtpRelTimerTicks[relTimer];
				pAtpResp->resp_RelTimeStamp = AtalkGetCurrentTick() + pAtpResp->resp_RelTimerTicks;
			}
			else
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkAtpPacketIn: ALO Req resp for %lx-%lx.%lx %d\n",
							tid, pSrcAddr->ata_Network, pSrcAddr->ata_Node,
							pSrcAddr->ata_Socket));

				//	Put this in the ALO response queue - LOCK Should be acquired!
				AtalkLinkDoubleAtHead(pAtpAddr->atpao_AloRespLinkage,
									  pAtpResp,
									  resp_Next,
									  resp_Prev);
			}

			//	We dont want to have the initial ref go away, as we have
			//	inserted a resp into the addr resp list.
			DerefAddr = FALSE;

			error = ATALK_NO_ERROR;

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
			UnlockAddr = FALSE;

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Indicating request %lx, tid %x %s\n",
					pAtpResp, tid,
					(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

#ifdef	PROFILING
			TimeD = KeQueryPerformanceCounter(NULL);
#endif
			(*ReqHandler)(ATALK_NO_ERROR,
						  pAtpAddr->atpao_ReqCtx,
						  pAtpResp,
						  pSrcAddr,
						  atpDataSize,
						  pDgram + ATP_USERBYTES_SIZE,
						  pDgram);

#ifdef	PROFILING
			TimeE = KeQueryPerformanceCounter(NULL);
			TimeE.QuadPart -= TimeD.QuadPart;

			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumReqHndlr,
										   &AtalkStatsLock.SpinLock);
			INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_AtpReqHndlrProcessTime,
										 TimeE,
										 &AtalkStatsLock.SpinLock);
#endif
			break;

		  case ATP_RESPONSE:
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Received RESPONSE from %lx.%lx.%lx, SeqNum %d tid %lx ss %lx\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket,
					seqNum, tid, sendSts));

			if (seqNum > (ATP_MAX_RESP_PKTS-1))
			{
				//	Drop the packet. Invalid packet error log.
				TMPLOGERR();
				break;
			}

			//	See if we have a request for this tid and remote address.
			if (OptimizedPath)
			{
				pAtpReq	= (PATP_REQ)OptimizeCtx;
				ASSERT (VALID_ATPRQ(pAtpReq));
				ASSERT (pAtpReq->req_Bitmap == 0);
			}
			else
			{
				atalkAtpReqReferenceByAddrTidDpc(pAtpAddr,
												 pSrcAddr,
												 tid,
												 &pAtpReq,
												 &error);
			}

			if (!ATALK_SUCCESS(error))
			{
				//	We dont have a corresponding pending request. Ignore.
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
						("AtalkAtpPacketIn: No pending request for tid %lx\n", tid));
				break;
			}

			do
			{
				if (!OptimizedPath)
				{
					//	Check the request bitmap, which could be zero if the user only
					//	wanted the user bytes and passed in a null response buffer.
					ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

					//	If we are the first packet, copy the response user bytes.
					if (seqNum == 0)
					{
						RtlCopyMemory(pAtpReq->req_RespUserBytes,
									  pDgram,
									  ATP_USERBYTES_SIZE);
					}

					//	Now skip over the user bytes
					pDgram += ATP_USERBYTES_SIZE;

					//	Do we want to keep this response? Check the corresponding
					//	bit in our current bitmap set.
					if (((pAtpReq->req_RecdBitmap & AtpBitmapForSeqNum[seqNum]) != 0) ||
						((pAtpReq->req_Bitmap & AtpBitmapForSeqNum[seqNum]) == 0))
					{
						RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
						//	We dont care about this packet. We already received it or weren't
						//	expecting it.
						break;
					}

					//	We want this response. Set bit in the recd bitmap. And
					//	Clear it in the expected packets req_Bitmap.

					//	!!!NOTE!!! 	We can release the spinlock even though the copy
					//				is not done. We have a ref to the req, and it wont
					//				get completed before that is done.
					pAtpReq->req_Bitmap 			&= ~AtpBitmapForSeqNum[seqNum];
					pAtpReq->req_RecdBitmap 		|= AtpBitmapForSeqNum[seqNum];
					pAtpReq->req_RespRecdLen	 	+= atpDataSize;

					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkAtpPacketIn: req_Bitmap %x, req_RecdBitmap %x\n",
							pAtpReq->req_Bitmap, pAtpReq->req_RecdBitmap));


					//	Now if eom is set, we need to reset all high order bits
					//	of the req_Bitmap. req_RecdBitmap should now indicate all
					//	the buffers we received. The two should be mutually exclusive
					//	at this point.
					if (eomFlag)
					{
						pAtpReq->req_Bitmap &= AtpEomBitmapForSeqNum[seqNum];
						ASSERT((pAtpReq->req_Bitmap & pAtpReq->req_RecdBitmap) == 0);
					}

					if (sendSts)
					{
						//	Reset timer since we are going to retransmit the request
						pAtpReq->req_RetryTimeStamp = AtalkGetCurrentTick() +
															pAtpReq->req_RetryInterval;
					}

					RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

					//	Copy the data into the users buffer. Check if there's room.
					startOffset = (USHORT)seqNum * pAtpAddr->atpao_MaxSinglePktSize;
					if (pAtpReq->req_RespBufLen < (startOffset + atpDataSize))
					{
						//	This should be a rare case; packet was in bitmap limits,
						//	but still wouldn't fit into user space.The other way this
						//	could occure is if the responder is sending less than full
						//	responses -- we don't "synch" up the user buffer until all
						//	packets have been received.

						//	We want to give up now, call the comp rotuine signaling
						//	the error -- unthread and free the request control block
						//	cancel the retry timer.

						ASSERT(0);
                        error = ATALK_RESR_MEM;
				        atalkAtpReqComplete(pAtpReq, error);
                        break;
					}

					if ((atpDataSize > 0) && (pAtpReq->req_RespBuf != NULL))
					{
						//	We have room to copy the data into the users buffer.
						ntStatus = TdiCopyBufferToMdl(pDgram,
													  0,
													  atpDataSize,
													  pAtpReq->req_RespBuf,
													  startOffset,
													  &bytesCopied);

						ASSERT(bytesCopied == atpDataSize);
						ASSERT(NT_SUCCESS(ntStatus));
					}

					if (sendSts)
					{
						// We have reset the retry timer above
						atalkAtpTransmitReq(pAtpReq);
					}

					//	If the bitmap is non-zero, we are still awaiting more responses.
					if (pAtpReq->req_Bitmap != 0)
					{
						break;
					}
				}
				else
				{
					ASSERT (pAtpReq->req_Bitmap == 0);
				}

				//	Ok, we have the entire response !
				//	If an XO request send a release, synch up the user buffer,
				//	Deref the request to have it complete.

				RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
				UnlockAddr = FALSE;

				if (pAtpReq->req_Flags & ATP_REQ_EXACTLY_ONCE)
				{
					atalkAtpTransmitRel(pAtpReq);
				}

				//	Do the synch up! USE RECD_BITMAP!!

				//	Set the response length, the user bytes in the request buffer.

				//	See if we can grab ownership of this request to remove
				//	the creation reference and complete it.
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkAtpPacketIn: Completing req %lx tid %x\n",
						pAtpReq, pAtpReq->req_Tid));

				atalkAtpReqComplete(pAtpReq, error);
			} while (FALSE);

			//	Remove reference on the request added at the beginning.
			AtalkAtpReqDereferenceDpc(pAtpReq);
			break;

		  case ATP_RELEASE:
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Received release for tid %lx!\n", tid));

			atalkAtpRespReferenceByAddrTidDpc(pAtpAddr,
											  pSrcAddr,
											  tid,
											  &pAtpResp,
											  &error);
			if (ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkAtpPacketIn: Found resp for release for tid %lx!\n",
						pAtpResp->resp_Tid));

				//	We received a release for this response. Cleanup and
				//	complete.
				ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

				pAtpResp->resp_Flags |= ATP_RESP_RELEASE_RECD;
				if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
				{
					ASSERT (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE);
				}

				RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
			}
			else
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("AtalkAtpPacketIn: resp not found - release for tid %lx!\n", tid));
			}

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
			UnlockAddr = FALSE;

			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRecdRelease,
										   &AtalkStatsLock.SpinLock);

			if (ATALK_SUCCESS(error))
			{
                ATALK_ERROR     ErrorCode = ATALK_NO_ERROR;

                // if client (mac) cancelled the request (possibly because session
                // went away), make sure our completion routine gets called
                if ((pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) == 0)
                {
                    ErrorCode = ATALK_ATP_RESP_CANCELLED;
                    pAtpResp->resp_Flags |= ATP_RESP_VALID_RESP;
                }

				//	Try to have the creation reference removed
				atalkAtpRespComplete(pAtpResp, ErrorCode);

				//	Remove the reference we added at the beginning.
				AtalkAtpRespDereferenceDpc(pAtpResp);
			}
			break;

		  default:
			break;
		}
		if (UnlockAddr)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		}
	} while (FALSE);

	//	Deref addr added at the beginning of this routine.
	if (DerefAddr)
	{
		AtalkAtpAddrDereferenceDpc(pAtpAddr);
	}

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpPacketInProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumPackets,
								   &AtalkStatsLock.SpinLock);
}




VOID FASTCALL
atalkAtpTransmitReq(
	IN		PATP_REQ	pAtpReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	ATP_HEADER		atpHeader;
	BOOLEAN			remote;
	BOOLEAN			DerefReq = FALSE;
	PBUFFER_DESC	pBufDesc = NULL;
	SEND_COMPL_INFO	SendInfo;

	//	Reference the request. This goes away in request send completion.
	AtalkAtpReqReferenceByPtr(pAtpReq, &error);
	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpTransmitReq: Transmitting req %lx tid %x\n",
					pAtpReq, pAtpReq->req_Tid));

		//	Build the atp header.
		atpHeader.atph_CmdCtrl = ATP_REQUEST | (UCHAR)(ATP_REL_TIMER_MASK & pAtpReq->req_RelTimerValue);
		if (pAtpReq->req_Flags & ATP_REQ_EXACTLY_ONCE)
			atpHeader.atph_CmdCtrl |= ATP_XO_MASK;

		//	Put in the expected packets bitmap.
		atpHeader.atph_Bitmap = pAtpReq->req_Bitmap;

		//	Put in the tid.
		PUTSHORT2SHORT(&atpHeader.atph_Tid, pAtpReq->req_Tid);

		//	Copy the user bytes.
		atpHeader.atph_dwUserBytes = pAtpReq->req_dwUserBytes;

		//	Build a buffer descriptor, this should hold the above mdl.
		if (pAtpReq->req_BufLen > 0)
		{
			if ((pBufDesc = AtalkAllocBuffDesc(pAtpReq->req_Buf,
											   pAtpReq->req_BufLen,
											   0)) == NULL)
			{
				DerefReq 	= TRUE;
				error 		= ATALK_RESR_MEM;
			}
		}

		remote = (pAtpReq->req_Flags & ATP_REQ_REMOTE) ? TRUE : FALSE;
		//	Call ddp to send the packet. Dont touch request after this call,
		//	as the send completion could potentially lead to it being freed.
		SendInfo.sc_TransmitCompletion = atalkAtpSendReqComplete;
		SendInfo.sc_Ctx1 = pAtpReq;
		SendInfo.sc_Ctx2 = pBufDesc;
		// SendInfo.sc_Ctx3 = NULL;
		if (ATALK_SUCCESS(error) &&
			!ATALK_SUCCESS(error = AtalkDdpSend(pAtpReq->req_pAtpAddr->atpao_DdpAddr,
												&pAtpReq->req_Dest,
												(BYTE)DDPPROTO_ATP,
												remote,
												pBufDesc,
												(PBYTE)&atpHeader,
												ATP_HEADER_SIZE,
												NULL,
												&SendInfo)))
		{
			DerefReq = TRUE;
			if (pBufDesc != NULL)
			{
				//	The flags will indicate that the data buffer is not to be
				//	freed.
				AtalkFreeBuffDesc(pBufDesc);
			}
		}

		if (DerefReq)
		{
			pAtpReq->req_CompStatus = error;
			AtalkAtpReqDereference(pAtpReq);
		}
	}
}




VOID FASTCALL
atalkAtpSendReqComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	AtalkAtpReqDereference((PATP_REQ)(pSendInfo->sc_Ctx1));
}




VOID FASTCALL
atalkAtpTransmitResp(
	IN		PATP_RESP		pAtpResp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	BYTE			i, bitmap, currentBit, seqNum, pktstosend;
	BOOLEAN			RemoteAddr;
	USHORT			bytesSent, bytesToSend, maxSinglePktSize;
	SHORT			remainingBytes;
	PATP_ADDROBJ	pAtpAddr;
	PAMDL			pAmdl[ATP_MAX_RESP_PKTS];
	PBUFFER_DESC	pBufDesc[ATP_MAX_RESP_PKTS];
	ATP_HEADER		atpHeader;
	SEND_COMPL_INFO	SendInfo;

	//	Verify we have a response posted
	ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);

	pAtpAddr = pAtpResp->resp_pAtpAddr;
	ASSERT(VALID_ATPAO(pAtpAddr));

	RemoteAddr = ((pAtpResp->resp_Flags & ATP_RESP_REMOTE) == 0) ? FALSE : TRUE;

	//	send each response packet that is needed.
	seqNum			= 0;
	pktstosend		= 0;
	currentBit		= 1;

	//	Get the max packet size for this atp object
	maxSinglePktSize	= pAtpAddr->atpao_MaxSinglePktSize;

	bitmap			= pAtpResp->resp_Bitmap;
	remainingBytes 	= pAtpResp->resp_BufLen;
	bytesSent		= 0;

	//	Indicate response type.
	atpHeader.atph_CmdCtrl = ATP_RESPONSE;

	//	Put in the tid.
	PUTSHORT2SHORT(&atpHeader.atph_Tid, pAtpResp->resp_Tid);

	ASSERTMSG("atalkAtpTransmitResp: resp len is negative\n", (remainingBytes >= 0));

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	do
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		pAtpResp->resp_Flags |= ATP_RESP_TRANSMITTING;
		RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

		do
		{
			pAmdl[seqNum] = NULL;
			pBufDesc[seqNum]  = NULL;

			if (((bitmap & currentBit) != 0) ||
				((seqNum == 0) && pAtpResp->resp_UserBytesOnly))
			{
				ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);

				bytesToSend = MIN(remainingBytes, maxSinglePktSize);

				if (bytesToSend != 0)
				{
					ASSERT (pAtpResp->resp_Buf != NULL);
					//	Make an mdl for the proper subsection of the response mdl.
					//	Make a buffer descriptor for the mdl.
					if (((pAmdl[seqNum] = AtalkSubsetAmdl(pAtpResp->resp_Buf,
														  bytesSent,
														  bytesToSend)) == NULL) ||
						((pBufDesc[seqNum] = AtalkAllocBuffDesc(pAmdl[seqNum],
																bytesToSend,
																0)) == NULL))
					{
						ASSERTMSG("atalkAtpTransmitResp: Create mdl or BD failed\n", 0);
						if (pAmdl[seqNum] != NULL)
						{
							AtalkFreeAMdl(pAmdl[seqNum]);
							pAmdl[seqNum] = NULL;
						}
						if (seqNum > 0)
							seqNum --;		// Adjust this.

						break;
					}
				}

				pktstosend ++;

			}
			else
			{
				//	We are omitting this. Let us mark it appropriately
				pBufDesc[seqNum]  = (PBUFFER_DESC)-1;
			}

			seqNum 			++;
			currentBit 		<<= 1;
			remainingBytes 	-= maxSinglePktSize;
			bytesSent 		+= maxSinglePktSize;
		} while (remainingBytes > 0);

		ASSERT (seqNum <= ATP_MAX_RESP_PKTS);

		//	Attempt to reference the response structure. If we fail, we abort.
		//	This will go away in the completion routine.
		atalkAtpRespReferenceNDpc(pAtpResp, pktstosend, &error);
		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("atalkAtpTransmitResp: response %lx ref (%d) failed\n",
					pAtpResp, seqNum, error));

			// Need to free up the Mdls/Buffdescs
			for (i = 0; i < seqNum; i++)
			{
				if (pAmdl[i] != NULL)
					AtalkFreeAMdl(pAmdl[i]);

				if ((pBufDesc[i] != NULL) && (pBufDesc[i] != (PBUFFER_DESC)-1))
					AtalkFreeBuffDesc(pBufDesc[i]);
			}
			break;
		}

		// Now blast off all the packets
		SendInfo.sc_TransmitCompletion = atalkAtpSendRespComplete;
		SendInfo.sc_Ctx1 = pAtpResp;
		// SendInfo.sc_Ctx3 = pAmdl[i];
		for (i = 0; i < seqNum; i++)
		{
			if (pBufDesc[i] == (PBUFFER_DESC)-1)
				continue;

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpTransmitResp: Sending seq #%d for tid %lx\n",
					i, pAtpResp->resp_Tid));

			//	Indicate if this is the last packet of the response.
			if (i == (seqNum-1))
			{
				atpHeader.atph_CmdCtrl |= ATP_EOM_MASK;
			}

			//	Put in the sequence number
			atpHeader.atph_SeqNum = i;

			//	User bytes only go in the first packet of the response
			//	unless otherwise indicated for this atp object.
			if ((i == 0)	||
				(pAtpAddr->atpao_Flags & ATPAO_SENDUSERBYTESALL))
			{
				atpHeader.atph_dwUserBytes = pAtpResp->resp_dwUserBytes;
			}
			else
			{
				//	Zero the user bytes
				atpHeader.atph_dwUserBytes = 0;
			}

			ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpTransmitResp: Sending seq #%d, BufDesc %lx, Resp %lx\n",
					i, pBufDesc[i], pAtpResp));

			ASSERT ((pBufDesc[i] == NULL) ||
					VALID_BUFFDESC(pBufDesc[i]));
			SendInfo.sc_Ctx2 = pBufDesc[i];
			error = AtalkDdpSend(pAtpAddr->atpao_DdpAddr,
								 &pAtpResp->resp_Dest,
								 (BYTE)DDPPROTO_ATP,
								 RemoteAddr,
								 pBufDesc[i],
								 (PBYTE)&atpHeader,
								 ATP_HEADER_SIZE,
								 NULL,
								 &SendInfo);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("atalkAtpTransmitResp: AtalkDdpSend Failed %ld\n", error));
				//	Call completion so the buffer/mdl can get freed up,
				//	and the reference is removed.
				atalkAtpSendRespComplete(error,
										 &SendInfo);
			}
		}
	} while (FALSE);

	ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
	pAtpResp->resp_Flags |= ATP_RESP_SENT;
	pAtpResp->resp_Flags &= ~ATP_RESP_TRANSMITTING;
	RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

	if (OldIrql != DISPATCH_LEVEL)
		KeLowerIrql(OldIrql);
}




VOID FASTCALL
atalkAtpSendRespComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		PAMDL	pMdl;

		if ((pMdl = ((PBUFFER_DESC)(pSendInfo->sc_Ctx2))->bd_OpaqueBuffer) != NULL)
			AtalkFreeAMdl(pMdl);
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));

	}

	AtalkAtpRespDereference((PATP_RESP)(pSendInfo->sc_Ctx1));
}



//	This is used to perform a retry when a release send fails in completion.
#define		ATP_TID_RETRY_MASK	0xF0000000
#define		ATP_TID_MASK		0xFFFF

VOID FASTCALL
atalkAtpTransmitRel(
	IN		PATP_REQ	pAtpReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	ATP_HEADER		atpHeader;
	BOOLEAN			remote;
	SEND_COMPL_INFO	SendInfo;

	AtalkAtpAddrReferenceDpc(pAtpReq->req_pAtpAddr, &error);

	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpTransmitRel: Sending release for %lx\n", pAtpReq->req_Tid));

		//	Build header for this packet.
		atpHeader.atph_dwUserBytes = 0;

		//	Indicate response type.
		atpHeader.atph_CmdCtrl = ATP_RELEASE;

		//	Put in the bitmap
		atpHeader.atph_Bitmap = pAtpReq->req_RecdBitmap;

		//	Put in the tid.
		PUTSHORT2SHORT(&atpHeader.atph_Tid, pAtpReq->req_Tid);

		remote = (pAtpReq->req_Flags & ATP_REQ_REMOTE) ? TRUE : FALSE;
		SendInfo.sc_TransmitCompletion = atalkAtpSendRelComplete;
		SendInfo.sc_Ctx1 = pAtpReq->req_pAtpAddr;
		SendInfo.sc_Ctx2 = (PVOID)((ULONG_PTR)(ATP_TID_RETRY_MASK | pAtpReq->req_Tid));
		SendInfo.sc_Ctx3 = (PVOID)((ULONG_PTR)(pAtpReq->req_Dest.ata_Address));
		error = AtalkDdpSend(pAtpReq->req_pAtpAddr->atpao_DdpAddr,
							 &pAtpReq->req_Dest,
							 (BYTE)DDPPROTO_ATP,
							 remote,
							 NULL,
							 (PBYTE)&atpHeader,
							 ATP_HEADER_SIZE,
							 NULL,
							 &SendInfo);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpTransmitRel: Send release failed %lx\n", error));

			AtalkAtpAddrDereferenceDpc(pAtpReq->req_pAtpAddr);
		}
	}
}




VOID FASTCALL
atalkAtpSendRelComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	ATP_HEADER		atpHeader;
#define	pAtpAddr	((PATP_ADDROBJ)(pSendInfo->sc_Ctx1))
#define	TidAndRetry	(ULONG_PTR)(pSendInfo->sc_Ctx2)
#define	DestAddr	(ULONG_PTR)(pSendInfo->sc_Ctx3)

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpSendRelComplete: Send status %lx\n", Status));

	if ((Status == NDIS_STATUS_SUCCESS) ||
		((TidAndRetry & ATP_TID_RETRY_MASK) == 0))
	{
		//	Either successful, or we have already retried.
		AtalkAtpAddrDereference(pAtpAddr);
		return;
	}

	//	Go ahead and retry!
	//	Build header for this packet.
	atpHeader.atph_dwUserBytes = 0;

	//	Indicate response type.
	atpHeader.atph_CmdCtrl = ATP_RELEASE;

	//	Put in the tid.
	PUTSHORT2SHORT(&atpHeader.atph_Tid, (TidAndRetry & ATP_TID_MASK));

	pSendInfo->sc_Ctx2 = NULL;
	pSendInfo->sc_Ctx3 = NULL;
	error = AtalkDdpSend(pAtpAddr->atpao_DdpAddr,
						(PATALK_ADDR)&DestAddr,
						(BYTE)DDPPROTO_ATP,
						FALSE,
						NULL,
						(PBYTE)&atpHeader,
						ATP_HEADER_SIZE,
						NULL,
						pSendInfo);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpSendRelComplete: Send release failed %lx\n", error));

		AtalkAtpAddrDereference(pAtpAddr);
	}
#undef	pAtpAddr
#undef	TidAndRetry
#undef	DestAddr
}




VOID  FASTCALL
atalkAtpRespComplete(
	IN	OUT	PATP_RESP	pAtpResp,
	IN		ATALK_ERROR	CompletionStatus
	)
{
	KIRQL	OldIrql;
	BOOLEAN	ownResp = TRUE;

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpRespComplete: Completing %lx.%lx\n",
				pAtpResp->resp_Tid, CompletionStatus));

	//	See if we can grab ownership of this response to remove
	//	the creation reference and complete it.
	ACQUIRE_SPIN_LOCK(&pAtpResp->resp_Lock, &OldIrql);
	if (pAtpResp->resp_Flags & ATP_RESP_CLOSING)
	{
		ownResp = FALSE;
	}
	pAtpResp->resp_Flags |= ATP_RESP_CLOSING;
	pAtpResp->resp_CompStatus = CompletionStatus;
	RELEASE_SPIN_LOCK(&pAtpResp->resp_Lock, OldIrql);

	//	If we managed to get ownership of the request, call the
	//	Deref for creation.
	if (ownResp)
	{
		AtalkAtpRespDereference(pAtpResp);
	}
}




VOID FASTCALL
atalkAtpReqComplete(
	IN	OUT	PATP_REQ	pAtpReq,
	IN		ATALK_ERROR	CompletionStatus
	)
{
	KIRQL	OldIrql;
	BOOLEAN	ownReq = TRUE;

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpReqComplete: Completing %lx\n", pAtpReq->req_Tid));

	//	See if we can grab ownership of this resquest to remove
	//	the creation reference and complete it.
	ACQUIRE_SPIN_LOCK(&pAtpReq->req_Lock, &OldIrql);
	if (pAtpReq->req_Flags & ATP_REQ_CLOSING)
	{
		ownReq = FALSE;
	}
	pAtpReq->req_CompStatus = CompletionStatus;
	pAtpReq->req_Flags |= ATP_REQ_CLOSING;
	RELEASE_SPIN_LOCK(&pAtpReq->req_Lock, OldIrql);

	//	If we managed to get ownership of the request, call the deref for creation.
	if (ownReq)
	{
		AtalkAtpReqDereference(pAtpReq);
	}
}




VOID
atalkAtpGetNextTidForAddr(
	IN		PATP_ADDROBJ	pAtpAddr,
	IN		PATALK_ADDR		pRemoteAddr,
	OUT		PUSHORT			pTid,
	OUT		PULONG			pIndex
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT		TentativeTid;
	ULONG		index;
	PATP_REQ	pAtpReq;

	do
	{
		TentativeTid = pAtpAddr->atpao_NextTid++;
		if (pAtpAddr->atpao_NextTid == 0)
			pAtpAddr->atpao_NextTid = 1;

		//	Check to see if this tid is in use for this address.

		//	!!!NOTE!!!
		//	This will be true even if the tid is in use for a closing
		//	request or a response.

		//	Calculate the hash value of the destination address of this request
		//	and the tid.
		index = ATP_HASH_TID_DESTADDR(TentativeTid, pRemoteAddr, ATP_REQ_HASH_SIZE);

		for (pAtpReq = pAtpAddr->atpao_ReqHash[index];
			 pAtpReq != NULL;
			 pAtpReq = pAtpReq->req_Next)
		{
			if ((ATALK_ADDRS_EQUAL(&pAtpReq->req_Dest, pRemoteAddr)) &&
				(pAtpReq->req_Tid == TentativeTid))
			{
				break;
			}
		}
	} while (pAtpReq != NULL);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpGetNextTidForAddr: Tid %lx for %lx.%lx.%lx\n",
				TentativeTid, pRemoteAddr->ata_Network, pRemoteAddr->ata_Node,
				pRemoteAddr->ata_Socket));

	*pTid = TentativeTid;
	*pIndex = index;
}


VOID
atalkAtpReqRefNextNc(
	IN		PATP_REQ		pAtpReq,
	OUT		PATP_REQ	*	ppNextNcReq,
	OUT		PATALK_ERROR	pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	for (NOTHING; pAtpReq != NULL; pAtpReq = pAtpReq->req_Next)
	{
		AtalkAtpReqReferenceByPtrDpc(pAtpReq, pError);
		if (ATALK_SUCCESS(*pError))
		{
			//	Ok, this request is referenced!
			*ppNextNcReq = pAtpReq;
			break;
		}
	}
}




VOID FASTCALL
atalkAtpReqDeref(
	IN		PATP_REQ	pAtpReq,
	IN		BOOLEAN		AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	BOOLEAN		done = FALSE;

	//	This will call the completion routine and remove it from the
	//	list when ref count goes to 0.
	ASSERT(VALID_ATPRQ(pAtpReq));

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pAtpReq->req_Lock, &OldIrql);
	}

	if ((--pAtpReq->req_RefCount) == 0)
	{
		ASSERT(pAtpReq->req_Flags & ATP_REQ_CLOSING);
		done = TRUE;
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pAtpReq->req_Lock, OldIrql);
	}

	if (done)
	{
		if (AtDpc)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_pAtpAddr->atpao_Lock);
		}
		else
		{
			ACQUIRE_SPIN_LOCK(&pAtpReq->req_pAtpAddr->atpao_Lock, &OldIrql);
		}

		//	Remove it from the list.
		AtalkUnlinkDouble(pAtpReq, req_Next, req_Prev);

		if (pAtpReq->req_Flags & ATP_REQ_RETRY_TIMER)
		{
			pAtpReq->req_Flags &= ~ATP_REQ_RETRY_TIMER;
			RemoveEntryList(&pAtpReq->req_List);
		}

		if (AtDpc)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_pAtpAddr->atpao_Lock);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pAtpReq->req_pAtpAddr->atpao_Lock, OldIrql);
		}

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpReqDeref: Completing req for tid %lx.%d\n",
				pAtpReq->req_Tid, pAtpReq->req_Tid));

		//	Call the completion routine for the request.
		if (pAtpReq->req_Comp != NULL)
		{
			KIRQL	OldIrql;

			// Resp handlers expect to be called at DISPATCH. If the
			// request was cancelled, make it so.
			if (pAtpReq->req_CompStatus == ATALK_ATP_REQ_CANCELLED)
				KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

			(*pAtpReq->req_Comp)(pAtpReq->req_CompStatus,
								 pAtpReq->req_Ctx,
								 pAtpReq->req_Buf,
								 pAtpReq->req_RespBuf,
								 pAtpReq->req_RespRecdLen,
								 pAtpReq->req_RespUserBytes);

			if (pAtpReq->req_CompStatus == ATALK_ATP_REQ_CANCELLED)
				KeLowerIrql(OldIrql);
		}

		//	Deref the address object
		if (AtDpc)
		{
			AtalkAtpAddrDereferenceDpc(pAtpReq->req_pAtpAddr);
		}
		else
		{
			AtalkAtpAddrDereference(pAtpReq->req_pAtpAddr);
		}

		//	Release the ndis buffer descriptors, if any
		AtalkIndAtpReleaseNdisBuffer(pAtpReq);

		AtalkBPFreeBlock(pAtpReq);
	}
}




VOID
atalkAtpRespRefNextNc(
	IN		PATP_RESP		pAtpResp,
	OUT		PATP_RESP	 *  ppNextNcResp,
	OUT		PATALK_ERROR	pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	PATP_RESP	pNextResp	= NULL;
	ATALK_ERROR	error 		= ATALK_FAILURE;

	for (; pAtpResp != NULL; pAtpResp = pAtpResp->resp_Next)
	{
		AtalkAtpRespReferenceByPtrDpc(pAtpResp, pError);
		if (ATALK_SUCCESS(*pError))
		{
			//	Ok, this request is referenced!
			*ppNextNcResp = pAtpResp;
			break;
		}
	}
}




VOID FASTCALL
AtalkAtpRespDeref(
	IN		PATP_RESP	pAtpResp,
	IN		BOOLEAN		AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	KIRQL			OldIrql;
	BOOLEAN			done = FALSE;
	BOOLEAN			NotifyRelHandler = FALSE;

	//	This will call the completion routine when the ref count goes to 1
	//	and remove it from the list when ref count goes to 0. The assumption
	//	here is that the release handler will be the last to Dereference.

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pAtpResp->resp_Lock, &OldIrql);
	}

	pAtpResp->resp_RefCount--;
	if (pAtpResp->resp_RefCount == 0)
	{
		ASSERT(pAtpResp->resp_Flags & (ATP_RESP_HANDLER_NOTIFIED | ATP_RESP_CANCELLED));

		done = TRUE;
	}
	else if ((pAtpResp->resp_RefCount == 1) &&
			 (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) &&
			 ((pAtpResp->resp_Flags & ATP_RESP_HANDLER_NOTIFIED) == 0))
	{
		NotifyRelHandler = TRUE;

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpRespDereference: Notifying release handler for Resp %lx, tid %x %s\n",
				pAtpResp, pAtpResp->resp_Tid,
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));
		pAtpResp->resp_Flags |= ATP_RESP_HANDLER_NOTIFIED;
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pAtpResp->resp_Lock, OldIrql);
	}

	if (NotifyRelHandler)
	{
		ASSERT (!done);

		//	Call the completion routine.
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpRespDereference: Calling resp handler for tid %lx %s\n",
				pAtpResp->resp_Tid,
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

        //
        // if Mac cancels its request before a response is posted by the client,
        // the compl. routine won't be set yet.
        //
        if (pAtpResp->resp_Comp != NULL)
        {
		    (*pAtpResp->resp_Comp)(pAtpResp->resp_CompStatus, pAtpResp->resp_Ctx);
        }
	}

	else if (done)
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpRespDereference: Freeing resp for tid %lx - %lx %s\n",
				pAtpResp->resp_Tid, pAtpResp->resp_CompStatus,
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

		pAtpAddr = pAtpResp->resp_pAtpAddr;
		if (AtDpc)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		}
		else
		{
			ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
		}


		//	Remove it from the list.
		AtalkUnlinkDouble(pAtpResp, resp_Next, resp_Prev);

		if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
		{
			ASSERT (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE);
			pAtpResp->resp_Flags &= ~ATP_RESP_REL_TIMER;
			RemoveEntryList(&pAtpResp->resp_List);
		}

		if (AtDpc)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);
		}

		//	Deref the address object
		if (AtDpc)
		{
			AtalkAtpAddrDereferenceDpc(pAtpResp->resp_pAtpAddr);
		}
		else
		{
			AtalkAtpAddrDereference(pAtpResp->resp_pAtpAddr);
		}
		AtalkBPFreeBlock(pAtpResp);
	}
}



VOID FASTCALL
AtalkAtpAddrDeref(
	IN OUT	PATP_ADDROBJ	pAtpAddr,
	IN		BOOLEAN			AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	BOOLEAN	done = FALSE;

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	}

	ASSERT(pAtpAddr->atpao_RefCount > 0);
	if (--(pAtpAddr->atpao_RefCount) == 0)
	{
		done = TRUE;
		ASSERT(pAtpAddr->atpao_Flags & ATPAO_CLOSING);
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);
	}

	if (done)
	{
		//	Call the close completion routine.
		if (pAtpAddr->atpao_CloseComp != NULL)
		{
			(*pAtpAddr->atpao_CloseComp)(ATALK_NO_ERROR, pAtpAddr->atpao_CloseCtx);
		}

		// 	This address is done for. Close the ddp socket.
		AtalkDdpCloseAddress(pAtpAddr->atpao_DdpAddr, NULL, NULL);

		//	Free up the memory
		AtalkFreeMemory(pAtpAddr);

		AtalkUnlockAtpIfNecessary();
	}
}


VOID FASTCALL
AtalkIndAtpSetupNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq,
	IN		ULONG			MaxSinglePktSize
)
{
	NDIS_STATUS		ndisStatus;
	PNDIS_BUFFER	ndisBuffer;
	PNDIS_BUFFER	ndisFirstBuffer;
	PNDIS_BUFFER	ndisPrevBuffer;
    UINT            ndisBufLen;
	USHORT			seqNum		= 0;
	USHORT			startOffset = 0;
    USHORT          Offset;
    USHORT          BytesRemaining;
    USHORT          PartialBytesNeeded=0;
    USHORT          PacketRoom;
    PMDL            pCurrentMdl;
    BOOLEAN         fPartialMdl;
	SHORT			BufLen = (SHORT)pAtpReq->req_RespBufLen;


	RtlZeroMemory(pAtpReq->req_NdisBuf,
				  sizeof(PVOID) * ATP_MAX_RESP_PKTS);

    if (BufLen == 0)
    {
        return;
    }

    //
    // BytesRemaining: bytes remaining in the current Mdl
    // PacketRoom: bytes required to complete setting up the
    //             Atp request corresponding to seqNum
    // ndisBufLen: bytes that will describe the (partial) mdl,
    //             obtained via NdisCopyBuffer
    //

    pCurrentMdl = pAtpReq->req_RespBuf;

    ASSERT(pCurrentMdl != NULL);

    BytesRemaining = (USHORT)MmGetMdlByteCount(pCurrentMdl);
    Offset = 0;

    ndisFirstBuffer = NULL;

	while (BufLen > 0 && seqNum < ATP_MAX_RESP_PKTS)
	{
        PacketRoom = MIN(BufLen, (USHORT)MaxSinglePktSize);

        while (PacketRoom > 0)
        {
            // are all the bytes there or are we at an Mdl boundary?
            if (BytesRemaining >= PacketRoom)
            {
                ndisBufLen = (UINT)PacketRoom;
                fPartialMdl = FALSE;
            }

            // looks like we are at boundary: need to get a partial mdl
            else
            {
                ndisBufLen = (UINT)BytesRemaining;
                fPartialMdl = TRUE;
            }

            ASSERT(ndisBufLen > 0);

		    NdisCopyBuffer(&ndisStatus,
			    		   &ndisBuffer,
				    	   AtalkNdisBufferPoolHandle,
					       (PVOID)pCurrentMdl,
    					   Offset,
	    				   ndisBufLen);

    		if (ndisStatus != NDIS_STATUS_SUCCESS)
            {
                DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
	                ("AtalkIndAtpSetupNdisBuffer: NdisCopyBuffer failed!\n"));
		    	break;
            }

            ASSERT(ndisBufLen == MmGetMdlByteCount(ndisBuffer));

            ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

            // first buffer for this packet?
            if (!ndisFirstBuffer)
            {
                ndisFirstBuffer = ndisBuffer;
                ndisPrevBuffer = ndisBuffer;
            }

            // no, it's not the first.  Chain it in!
            else
            {
                ndisPrevBuffer->Next = ndisBuffer;
                ndisPrevBuffer = ndisBuffer;
            }

		    BufLen -= (SHORT)ndisBufLen;
            Offset += (USHORT)ndisBufLen;
            BytesRemaining -= (USHORT)ndisBufLen;
            PacketRoom -= (USHORT)ndisBufLen;

            // did we exhaust the current Mdl?  move to the next mdl then!
            if (fPartialMdl)
            {
                ASSERT(PacketRoom > 0);

                pCurrentMdl = pCurrentMdl->Next;
                ASSERT(pCurrentMdl != NULL);

                BytesRemaining = (USHORT)MmGetMdlByteCount(pCurrentMdl);
                Offset = 0;
            }
        }

        if (PacketRoom > 0)
        {
            DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
	            ("AtalkIndAtpSetupNdisBuffer: couldn't get Mdl!\n"));

            // if an mdl was allocated (describing part of buffer), free it
            if (ndisFirstBuffer)
            {
                AtalkNdisFreeBuffer(ndisFirstBuffer);
            }
		   	break;
        }

        ASSERT(ndisFirstBuffer != NULL);

		pAtpReq->req_NdisBuf[seqNum++] = ndisFirstBuffer;
        ndisFirstBuffer = NULL;
	}
}

VOID FASTCALL
AtalkIndAtpReleaseNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq
)
{
	LONG	        i;
    PNDIS_BUFFER    ndisBuffer;
    PNDIS_BUFFER    ndisNextBuffer;

	for (i = 0; i < ATP_MAX_RESP_PKTS; i++)
	{
		if ((ndisBuffer = pAtpReq->req_NdisBuf[i]) != NULL)
        {
            AtalkNdisFreeBuffer(ndisBuffer);
        }
	}

}




LOCAL LONG FASTCALL
atalkAtpReqTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_REQ		pAtpReq;
	PATP_ADDROBJ	pAtpAddr;
	PLIST_ENTRY		pList, pListNext;
	ATALK_ERROR		error;
	LONG			now;
	BOOLEAN			retry;
#ifdef	PROFILING
	LARGE_INTEGER	TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	pAtpAddr = CONTAINING_RECORD(pTimer, ATP_ADDROBJ, atpao_RetryTimer);
	ASSERT(VALID_ATPAO(pAtpAddr));

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpReqTimer: Entered for address %lx\n", pAtpAddr));

	if (TimerShuttingDown ||
		(pAtpAddr->atpao_Flags & (ATPAO_CLOSING|ATPAO_CLEANUP)))
	{
		AtalkAtpAddrDereferenceDpc(pAtpAddr);
		return ATALK_TIMER_NO_REQUEUE;
	}

	now = AtalkGetCurrentTick();

	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	for (pList = pAtpAddr->atpao_ReqList.Flink;
		 pList != &pAtpAddr->atpao_ReqList;
		 pList = pListNext)
	{
		pAtpReq = CONTAINING_RECORD(pList, ATP_REQ, req_List);
		ASSERT (VALID_ATPRQ(pAtpReq));

		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		pListNext = pAtpReq->req_List.Flink;

		//	If either we are closing this request or have not timed out yet, skip.
		if (((pAtpReq->req_Flags & (ATP_REQ_CLOSING		|
									ATP_REQ_RETRY_TIMER	|
									ATP_REQ_RESPONSE_COMPLETE)) != ATP_REQ_RETRY_TIMER) ||
			(now < pAtpReq->req_RetryTimeStamp))

		{
			RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
			continue;
		}

		//	If retry count == 0, we have reached the end of the road.
		if ((pAtpReq->req_RetryCnt == ATP_INFINITE_RETRIES) ||
			(--(pAtpReq->req_RetryCnt) > 0))
		{
			//	Transmit the request again!
			retry = TRUE;
			pAtpReq->req_RetryTimeStamp = (now + pAtpReq->req_RetryInterval);
		}
		else
		{
			//	We should now be Dereferenced for creation.
			retry = FALSE;
		}

		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		if (retry)
		{
			// We do not want to update statistics for requests are that are never going to
			// be responded to (like tickle packets). Detect these and skip updating the
			// stats for these
			if (pAtpReq->req_RespBufLen > 0)	// i.e. response expected
			{
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumLocalRetries,
											   &AtalkStatsLock.SpinLock);
			}

			AtalkAtpReqReferenceByPtrDpc(pAtpReq, &error);

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

			if (ATALK_SUCCESS(error))
			{
				atalkAtpTransmitReq(pAtpReq);
				AtalkAtpReqDereferenceDpc(pAtpReq);
			}
		}
		else
		{
			//	We have run out of retries - complete with an error
			ASSERT (pAtpReq->req_RetryCnt == 0);
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("atalkAtpReqTimer: Request %lx, tid %x timed out !!!\n",
					pAtpReq, pAtpReq->req_Tid));

			AtalkAtpReqReferenceByPtrDpc(pAtpReq, &error);

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

			if (ATALK_SUCCESS(error))
			{
				atalkAtpReqComplete(pAtpReq, ATALK_ATP_REQ_TIMEOUT);
				AtalkAtpReqDereferenceDpc(pAtpReq);
			}
            else
            {
	            DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
			        ("atalkAtpReqTimer: couldn't reference pAtpReq %lx :nothing done!\n",pAtpReq));
            }
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

		// Start over
		pListNext = pAtpAddr->atpao_ReqList.Flink;
	}

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpReqTimerProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumReqTimer,
								   &AtalkStatsLock.SpinLock);
#endif

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAtpRelTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	PATP_RESP		pAtpResp;
	PLIST_ENTRY		pList, pListNext;
	LONG			now;
#ifdef	PROFILING
	LARGE_INTEGER	TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	pAtpAddr = CONTAINING_RECORD(pTimer, ATP_ADDROBJ, atpao_RelTimer);
	ASSERT(VALID_ATPAO(pAtpAddr));

	if (TimerShuttingDown ||
		(pAtpAddr->atpao_Flags & (ATPAO_CLOSING|ATPAO_CLEANUP)))
	{
		AtalkAtpAddrDereferenceDpc(pAtpAddr);
		return ATALK_TIMER_NO_REQUEUE;
	}

	now = AtalkGetCurrentTick();

	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	for (pList = pAtpAddr->atpao_RespList.Flink;
		 pList != &pAtpAddr->atpao_RespList;
		 pList = pListNext)
	{
		BOOLEAN	derefResp;

		pAtpResp = CONTAINING_RECORD(pList, ATP_RESP, resp_List);

		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		derefResp = TRUE;

		ASSERT (VALID_ATPRS(pAtpResp));
		ASSERT (pAtpResp->resp_Flags & (ATP_RESP_EXACTLY_ONCE|ATP_RESP_VALID_RESP|ATP_RESP_REL_TIMER));

		pListNext = pAtpResp->resp_List.Flink;

		if ((pAtpResp->resp_Flags &
				(ATP_RESP_CLOSING			|
				 ATP_RESP_REL_TIMER			|
				 ATP_RESP_TRANSMITTING		|
				 ATP_RESP_SENT				|
				 ATP_RESP_HANDLER_NOTIFIED	|
				 ATP_RESP_RELEASE_RECD)) == (ATP_RESP_REL_TIMER | ATP_RESP_SENT))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpRelTimer: Checking req tid %lx (%x)\n",
					pAtpResp->resp_Tid, pAtpResp->resp_Flags));

			if (now >= pAtpResp->resp_RelTimeStamp)
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
						("atalkAtpRelTimer: Releasing req %lx tid %lx (%x)\n",
						pAtpResp, pAtpResp->resp_Tid, pAtpResp->resp_Flags));

				RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

				RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
				derefResp = FALSE;

				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRespTimeout,
											   &AtalkStatsLock.SpinLock);

				//	Try to have the creation reference removed
				atalkAtpRespComplete(pAtpResp, ATALK_ATP_RESP_TIMEOUT);

				ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

				// Start over
				pListNext = pAtpAddr->atpao_RespList.Flink;
			}
		}

		if (derefResp)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpRelTimerProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRelTimer,
								   &AtalkStatsLock.SpinLock);
#endif

	return ATALK_TIMER_REQUEUE;
}


VOID FASTCALL
AtalkAtpGenericRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PATP_RESP				pAtpResp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	AtalkAtpRespDereference(pAtpResp);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\blkpool.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	blkpool.h

Abstract:

	This module contains routines to manage block pools.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_BLK_POOL
#define	_BLK_POOL

#define	SM_BLK	1024
#define	LG_BLK	2048
#define	XL_BLK	4096

#define	BC_SIGNATURE			*(PULONG)"BLKC"
#if	DBG
#define	VALID_BC(pChunk)	(((pChunk) != NULL) && \
							 ((pChunk)->bc_Signature == BC_SIGNATURE))
#else
#define	VALID_BC(pChunk)	((pChunk) != NULL)
#endif
typedef	struct _BLK_CHUNK
{
#if	DBG
	DWORD				bc_Signature;
#endif
	struct _BLK_CHUNK *	bc_Next;		// Pointer to next in the link
	struct _BLK_CHUNK **bc_Prev;		// Pointer to previous one
	UCHAR				bc_NumFree;		// Number of free blocks in the chunk
	UCHAR				bc_NumAlloc;	// Number of blocks used (DBG only)
	UCHAR				bc_Age;			// Number of invocations since the chunk free
	BLKID				bc_BlkId;		// Id of the block
	struct _BLK_HDR *	bc_FreeHead;	// Head of the list of free blocks
	// This is followed by an array of N blks of size M such that the block header
	// is exactly atalkChunkSize[i]
} BLK_CHUNK, *PBLK_CHUNK;

#define	BH_SIGNATURE			*(PULONG)"BLKH"
#if	DBG
#define	VALID_BH(pBlkHdr)	(((pBlkHdr) != NULL) && \
							 ((pBlkHdr)->bh_Signature == BH_SIGNATURE))
#else
#define	VALID_BH(pBlkHdr)	((pBlkHdr) != NULL)
#endif
typedef	struct _BLK_HDR
{
#if	DBG
	DWORD					bh_Signature;
#endif
	union
	{
		struct _BLK_HDR	*	bh_Next;	// Valid when it is free
		struct _BLK_CHUNK *	bh_pChunk;	// The parent chunk to which this blocks belong
										// valid when it is allocated
	};
} BLK_HDR, *PBLK_HDR;

#if	DBG
#define	BC_OVERHEAD				(8+4)	// DWORD for AtalkAllocMemory() header and
										// POOL_HEADER for ExAllocatePool() header
#else
#define	BC_OVERHEAD				(8+8)	// 2*DWORD for AtalkAllocMemory() header and
										// POOL_HEADER for ExAllocatePool() header
#endif

#define	BLOCK_SIZE(VirginSize)	DWORDSIZEBLOCK(sizeof(BLK_HDR)+VirginSize)

#define	NUM_BLOCKS(VirginSize, ChunkSize)	\
			((ChunkSize) - BC_OVERHEAD - sizeof(BLK_CHUNK))/BLOCK_SIZE(VirginSize)

extern	USHORT	atalkBlkSize[NUM_BLKIDS];

extern	USHORT	atalkChunkSize[NUM_BLKIDS];

extern	BYTE	atalkNumBlks[NUM_BLKIDS];

extern	ATALK_SPIN_LOCK	atalkBPLock[NUM_BLKIDS];

#define	BLOCK_POOL_TIMER			150	// Check interval - in 100ms units
#define	MAX_BLOCK_POOL_AGE			6	// # of timer invocations before free

extern	PBLK_CHUNK		atalkBPHead[NUM_BLKIDS];
extern	TIMERLIST		atalkBPTimer;

#if	DBG
extern	LONG	atalkNumChunksForId[NUM_BLKIDS];
extern	LONG	atalkBlksForId[NUM_BLKIDS];
#endif

LOCAL LONG FASTCALL
atalkBPAgePool(
	IN PTIMERLIST 	Context,
	IN BOOLEAN		TimerShuttingDown
);

#endif	// _BLK_POOL


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\data.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	data.c

Abstract:

	This module defines global data for the appletalk transport.

Author:

	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	22 Feb 1997		Initial Version

Notes:	Tab stop: 4
--*/

#include 	<atalk.h>
#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		DATAX

PWCHAR			AtalkDeviceNames[] =
	{
		ATALKDDP_DEVICENAME,
		ATALKADSP_DEVICENAME,
		ATALKASPS_DEVICENAME,
		ATALKPAP_DEVICENAME,
        ATALKARAP_DEVICENAME,
		ATALKASPC_DEVICENAME
	};

PATALK_DEV_OBJ  AtalkDeviceObject[ATALK_NO_DEVICES] = {0};
DWORD			AtalkBindnUnloadStates = 0;

LONG			AtalkTimerCurrentTick = 0;
PTIMERLIST		atalkTimerList			= NULL;
ATALK_SPIN_LOCK	atalkTimerLock			= {0};
LARGE_INTEGER	atalkTimerTick			= {0};
KTIMER			atalkTimer				= {0};
KDPC			atalkTimerDpc			= {0};
KEVENT			atalkTimerStopEvent		= {0};
BOOLEAN			atalkTimerStopped 		= FALSE;	// Set to TRUE if timer system stopped
BOOLEAN			atalkTimerRunning		= FALSE;	// Set to TRUE when timer Dpc is running
BOOLEAN         atalkRtmpVdtTmrRunning  = FALSE;
BOOLEAN         atalkZipQryTmrRunning   = FALSE;

PRTE *			AtalkRoutingTable =	NULL;			// Allocated at init time
PRTE *			AtalkRecentRoutes		= NULL;		// Allocated at init time
ATALK_SPIN_LOCK	AtalkRteLock = {0};
TIMERLIST		atalkRtmpVTimer = { 0 };
TIMERLIST		atalkZipQTimer = { 0 };

ATALK_SKT_CACHE	AtalkSktCache		= {0};
ATALK_SPIN_LOCK	AtalkSktCacheLock	= {0};

PPORT_DESCRIPTOR AtalkPortList	= NULL;	 		// Head of the port list
PPORT_DESCRIPTOR AtalkDefaultPort = NULL;		// Ptr to the def port
KEVENT			 AtalkDefaultPortEvent = { 0 };	// Signalled when default port is available
UNICODE_STRING	 AtalkDefaultPortName = { 0 };	// Name of the default port
ATALK_SPIN_LOCK	 AtalkPortLock = { 0 };			// Lock for AtalkPortList
ATALK_NODEADDR	 AtalkUserNode1 = { 0 };		// Node address of user node
ATALK_NODEADDR	 AtalkUserNode2 = { 0 };		// Node address of user node
SHORT	 		 AtalkNumberOfPorts = 0; 		// Determine dynamically
SHORT			 AtalkNumberOfActivePorts = 0;	// Number of ports active
BOOLEAN			 AtalkRouter =	FALSE;			// Are we a router?
BOOLEAN			 AtalkFilterOurNames =	TRUE;	// If TRUE, Nbplookup fails on names on this machine
KEVENT			 AtalkUnloadEvent = {0};		// Event for unloading
NDIS_HANDLE		 AtalkNdisPacketPoolHandle = NULL;
NDIS_HANDLE		 AtalkNdisBufferPoolHandle = NULL;
LONG			 AtalkHandleCount = 0;
UNICODE_STRING	 AtalkRegPath = { 0 };

HANDLE           TdiRegistrationHandle = NULL;
PVOID            TdiAddressChangeRegHandle = NULL;

KMUTEX			AtalkPgLkMutex						= { 0 };
ATALK_SPIN_LOCK	AtalkPgLkLock						= { 0 };
LOCK_SECTION	AtalkPgLkSection[LOCKABLE_SECTIONS]	= { 0 };

ATALK_SPIN_LOCK	AtalkZoneLock = {0};
PZONE *			AtalkZonesTable = NULL;
PZONE			AtalkDesiredZone = NULL;

BOOLEAN         AtalkNoDefPortPrinted = FALSE;  // If no default ATalk port print the message only once

//	Values for the 0.5, 1, 2, 4, 8 minute timer in ATP_RELEASE_TIMER_INTERVAL units.
SHORT			AtalkAtpRelTimerTicks[MAX_VALID_TIMERS] =
	{
		300, 600, 2*600, 4*600, 8*600
	};

//	Bitmaps for the s=ence numbers in response packets.
BYTE			AtpBitmapForSeqNum[ATP_MAX_RESP_PKTS] =
	{
		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
	};

BYTE			AtpEomBitmapForSeqNum[ATP_MAX_RESP_PKTS] =
	{
		0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF
	};

ATALK_SPIN_LOCK	atalkAspLock = {0};

ASP_CONN_MAINT	atalkAspConnMaint[NUM_ASP_CONN_LISTS] = { 0 };
ASPC_CONN_MAINT	atalkAspCConnMaint = { 0 };
ATALK_SPIN_LOCK	atalkAspCLock = {0};
PASPC_ADDROBJ	atalkAspCAddrList = NULL;
PASPC_CONNOBJ	atalkAspCConnList = NULL;

PPAP_ADDROBJ	atalkPapAddrList	= NULL;
PPAP_CONNOBJ	atalkPapConnList	= NULL;
TIMERLIST		atalkPapCMTTimer	= { 0 };
ATALK_SPIN_LOCK	atalkPapLock		= {0};

NDIS_MEDIUM		AtalkSupportedMedia[] =
	{
		NdisMedium802_3,
		NdisMediumFddi,
		NdisMedium802_5,
		NdisMediumLocalTalk,
        NdisMediumWan
	};


ULONG			AtalkSupportedMediaSize = sizeof(AtalkSupportedMedia)/sizeof(NDIS_MEDIUM);

NDIS_HANDLE		AtalkNdisProtocolHandle	= NULL;

BYTE			AtalkElapBroadcastAddr[ELAP_ADDR_LEN] = ELAP_BROADCAST_ADDR_INIT;

BYTE			AtalkAlapBroadcastAddr[] = {0xFF};

BYTE			AtalkAarpProtocolType[IEEE8022_PROTO_TYPE_LEN] =
	{
		0x00, 0x00,	0x00, 0x80,	0xF3
	};

BYTE			AtalkAppletalkProtocolType[IEEE8022_PROTO_TYPE_LEN] =
	{
		0x08, 0x00, 0x07, 0x80, 0x9B
	};

ATALK_NETWORKRANGE	AtalkStartupNetworkRange =
	{
		FIRST_STARTUP_NETWORK, LAST_STARTUP_NETWORK
	};
																
BYTE			AtalkEthernetZoneMulticastAddrsHdr[ELAP_MCAST_HDR_LEN] =
	{
		0x09, 0x00, 0x07, 0x00, 0x00
	};

BYTE			AtalkEthernetZoneMulticastAddrs[ELAP_ZONE_MULTICAST_ADDRS]	=
	{
		 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 ,
		 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F ,
		 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 ,
		 0x18 , 0x19 , 0x1A , 0x1B , 0x1C , 0x1D , 0x1E , 0x1F ,
		 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 ,
		 0x28 , 0x29 , 0x2A , 0x2B , 0x2C , 0x2D , 0x2E , 0x2F ,
		 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 ,
		 0x38 , 0x39 , 0x3A , 0x3B , 0x3C , 0x3D , 0x3E , 0x3F ,
		 0x40 , 0x41 , 0x42 , 0x43 , 0x44 , 0x45 , 0x46 , 0x47 ,
		 0x48 , 0x49 , 0x4A , 0x4B , 0x4C , 0x4D , 0x4E , 0x4F ,
		 0x50 , 0x51 , 0x52 , 0x53 , 0x54 , 0x55 , 0x56 , 0x57 ,
		 0x58 , 0x59 , 0x5A , 0x5B , 0x5C , 0x5D , 0x5E , 0x5F ,
		 0x60 , 0x61 , 0x62 , 0x63 , 0x64 , 0x65 , 0x66 , 0x67 ,
		 0x68 , 0x69 , 0x6A , 0x6B , 0x6C , 0x6D , 0x6E , 0x6F ,
		 0x70 , 0x71 , 0x72 , 0x73 , 0x74 , 0x75 , 0x76 , 0x77 ,
		 0x78 , 0x79 , 0x7A , 0x7B , 0x7C , 0x7D , 0x7E , 0x7F ,
		 0x80 , 0x81 , 0x82 , 0x83 , 0x84 , 0x85 , 0x86 , 0x87 ,
		 0x88 , 0x89 , 0x8A , 0x8B , 0x8C , 0x8D , 0x8E , 0x8F ,
		 0x90 , 0x91 , 0x92 , 0x93 , 0x94 , 0x95 , 0x96 , 0x97 ,
		 0x98 , 0x99 , 0x9A , 0x9B , 0x9C , 0x9D , 0x9E , 0x9F ,
		 0xA0 , 0xA1 , 0xA2 , 0xA3 , 0xA4 , 0xA5 , 0xA6 , 0xA7 ,
		 0xA8 , 0xA9 , 0xAA , 0xAB , 0xAC , 0xAD , 0xAE , 0xAF ,
		 0xB0 , 0xB1 , 0xB2 , 0xB3 , 0xB4 , 0xB5 , 0xB6 , 0xB7 ,
		 0xB8 , 0xB9 , 0xBA , 0xBB , 0xBC , 0xBD , 0xBE , 0xBF ,
		 0xC0 , 0xC1 , 0xC2 , 0xC3 , 0xC4 , 0xC5 , 0xC6 , 0xC7 ,
		 0xC8 , 0xC9 , 0xCA , 0xCB , 0xCC , 0xCD , 0xCE , 0xCF ,
		 0xD0 , 0xD1 , 0xD2 , 0xD3 , 0xD4 , 0xD5 , 0xD6 , 0xD7 ,
		 0xD8 , 0xD9 , 0xDA , 0xDB , 0xDC , 0xDD , 0xDE , 0xDF ,
		 0xE0 , 0xE1 , 0xE2 , 0xE3 , 0xE4 , 0xE5 , 0xE6 , 0xE7 ,
		 0xE8 , 0xE9 , 0xEA , 0xEB , 0xEC , 0xED , 0xEE , 0xEF ,
		 0xF0 , 0xF1 , 0xF2 , 0xF3 , 0xF4 , 0xF5 , 0xF6 , 0xF7 ,
		 0xF8 , 0xF9 , 0xFA , 0xFB , 0xFC
	};


BYTE			AtalkTokenRingZoneMulticastAddrsHdr[TLAP_MCAST_HDR_LEN] = { 0xC0, 0x00 };

BYTE			AtalkTokenRingZoneMulticastAddrs[TLAP_ZONE_MULTICAST_ADDRS]
												[TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN] =
	{
		{ 0x00, 0x00, 0x08, 0x00 },
		{ 0x00, 0x00, 0x10, 0x00 },
		{ 0x00, 0x00, 0x20, 0x00 },
		{ 0x00, 0x00, 0x40, 0x00 },
		{ 0x00, 0x00, 0x80, 0x00 },
		{ 0x00, 0x01, 0x00, 0x00 },
		{ 0x00, 0x02, 0x00, 0x00 },
		{ 0x00, 0x04, 0x00, 0x00 },
		{ 0x00, 0x08, 0x00, 0x00 },
		{ 0x00, 0x10, 0x00, 0x00 },
		{ 0x00, 0x20, 0x00, 0x00 },
		{ 0x00, 0x40, 0x00, 0x00 },
		{ 0x00, 0x80, 0x00, 0x00 },
		{ 0x01, 0x00, 0x00, 0x00 },
		{ 0x02, 0x00, 0x00, 0x00 },
		{ 0x04, 0x00, 0x00, 0x00 },
		{ 0x08, 0x00, 0x00, 0x00 },
		{ 0x10, 0x00, 0x00, 0x00 },
		{ 0x20, 0x00, 0x00, 0x00 }
	};

BYTE			AtalkTlapBroadcastAddr[TLAP_ADDR_LEN] = TLAP_BROADCAST_ADDR_INIT;

//
//	Static "source routing" info for a TokenRing broadcast/multicast packet;
//	the following values are set: single-route broadcast, 2 bytes of routing
//	info, outgoing packet, broadcast (bigo) frame size.
//
BYTE			AtalkBroadcastRouteInfo[TLAP_MIN_ROUTING_BYTES] = { 0xC2,	0x70 };

//
//	Same stuff for a non-broadcast packet's simple routing info; the following
//	values are set: non-broadcast, 2 bytes of routing info, outgoing packet,
//
//	802.5-style frame.
BYTE			AtalkSimpleRouteInfo[TLAP_MIN_ROUTING_BYTES] = { 0x02, 0x30 };

//
//	The following may not really be safe, but, we'll make the assumption that
//	all outgoing TokenTalk packets whos destination address starts with "0xC0
//	0x00" are broadcast (or multicast).	Further, we assume that no packets
//	that are intended to be boradcast/multicast will fail to meet this test.
//	If this proves not to be the case, we'll need to find a new way to determine
//	this from the destination address, or introduce a new perameter to the
//	various "buildHeader" routines.	This is all for "source routing" support.
//
BYTE			AtalkBroadcastDestHdr[TLAP_BROADCAST_DEST_LEN] = { 0xC0, 0x00};

PORT_HANDLERS	AtalkPortHandlers[LAST_PORTTYPE] =
	{
		{
			AtalkNdisAddMulticast,
			AtalkNdisRemoveMulticast,
			ELAP_BROADCAST_ADDR_INIT,
			MAX_HW_ADDR_LEN,
			AARP_ELAP_HW_TYPE,
			AARP_ATALK_PROTO_TYPE
		},
		{
			AtalkNdisAddMulticast,
			AtalkNdisRemoveMulticast,
			ELAP_BROADCAST_ADDR_INIT,
			MAX_HW_ADDR_LEN,
			AARP_ELAP_HW_TYPE,
			AARP_ATALK_PROTO_TYPE
		},
		{
			AtalkNdisAddFunctional,
			AtalkNdisRemoveFunctional,
			TLAP_BROADCAST_ADDR_INIT,
			MAX_HW_ADDR_LEN,
			AARP_TLAP_HW_TYPE,
			AARP_ATALK_PROTO_TYPE
		},
		{
			NULL,
			NULL,
			ALAP_BROADCAST_ADDR_INIT,
			1,
			0,
			0
		},
	    {
		    NULL,
		    NULL,
		    ARAP_BROADCAST_ADDR_INIT,
		    1,
		    0,
		    0
	    }
	};


ATALK_STATS		AtalkStatistics = {0};
ATALK_SPIN_LOCK	AtalkStatsLock	= {0};

// The following table ia taken from page D-3 of the Inside AppleTalk manual.
BYTE AtalkUpCaseTable[256] =
{
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,		// 0x00 - 0x07
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,	    // 0x08 - 0x0F
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	    // 0x10 - 0x17
	0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,	    // 0x18 - 0x1F
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,	    // 0x20 - 0x27
	0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,	    // 0x28 - 0x2F
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,	    // 0x30 - 0x37
	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,	    // 0x38 - 0x3F
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	    // 0x40 - 0x47
	0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,	    // 0x48 - 0x4F
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	    // 0x50 - 0x57
	0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,	    // 0x58 - 0x5F
	0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	    // 0x60 - 0x67
	0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,	    // 0x68 - 0x6F
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	    // 0x70 - 0x77
	0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,	    // 0x78 - 0x7F
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,	    // 0x80 - 0x87
	0xCB, 0x89, 0x80, 0xCC, 0x81, 0x82, 0x83, 0x8F,	    // 0x88 - 0x8F
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x84, 0x97,	    // 0x90 - 0x97
	0x98, 0x99, 0x85, 0xCD, 0x9C, 0x9D, 0x9E, 0x86,	    // 0x98 - 0x9F
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,	    // 0xA0 - 0xA7
	0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,	    // 0xA8 - 0xAF
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,	    // 0xB0 - 0xB7
	0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xAE, 0xAF,	    // 0xB8 - 0xBF
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,	    // 0xC0 - 0xC7
	0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCB, 0xCE, 0xCE,	    // 0xC8 - 0xCF
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,	    // 0xD0 - 0xD7
	0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,	    // 0xD8 - 0xDF
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,	    // 0xE0 - 0xE7
	0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,	    // 0xE8 - 0xEF
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,	    // 0xF0 - 0xF7
	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF	     // 0xF8 - 0xFF
};


USHORT	atalkBlkSize[NUM_BLKIDS] =	// Size of each block
	{
		BLOCK_SIZE(sizeof(BUFFER_DESC)),					// BLKID_BUFFDESC
		BLOCK_SIZE(sizeof(AMT)),							// BLKID_AMT
		BLOCK_SIZE(sizeof(AMT)+MAX_ROUTING_SPACE),			// BLKID_AMT_ROUTE
		BLOCK_SIZE(sizeof(BRE)),							// BLKID_BRE
		BLOCK_SIZE(sizeof(BRE)+MAX_ROUTING_SPACE),			// BLKID_BRE_ROUTE
		BLOCK_SIZE(sizeof(ATP_REQ)),						// BLKID_ATPREQ
		BLOCK_SIZE(sizeof(ATP_RESP)),						// BLKID_ATPRESP
		BLOCK_SIZE(sizeof(ASP_REQUEST)),					// BLKID_ASPREQ

		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_SMPKT_SIZE),      	// BLKID_ARAP_SMPKT
		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_MDPKT_SIZE),      	// BLKID_ARAP_MDPKT
		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_LGPKT_SIZE),      	// BLKID_ARAP_LGPKT
		BLOCK_SIZE(ARAP_SENDBUF_SIZE),      	            // BLKID_ARAP_SNDPKT
		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_LGBUF_SIZE),       	// BLKID_ARAP_LGBUF
		BLOCK_SIZE(sizeof(AARP_BUFFER)),					// BLKID_AARP
		BLOCK_SIZE(sizeof(DDP_SMBUFFER)),					// BLKID_DDPSM
		BLOCK_SIZE(sizeof(DDP_LGBUFFER)),					// BLKID_DDPLG
		BLOCK_SIZE(sizeof(SENDBUF)),						// BLKID_SENDBUF
		BLOCK_SIZE(sizeof(MNPSENDBUF)+MNP_MINSEND_LEN),     // BLKID_MNP_SMSENDBUF
		BLOCK_SIZE(sizeof(MNPSENDBUF)+MNP_MAXSEND_LEN)	    // BLKID_MNP_LGSENDBUF
	};

USHORT	atalkChunkSize[NUM_BLKIDS] =	// Size of each Chunk
	{
		SM_BLK-BC_OVERHEAD,									// BLKID_BUFFDESC
		SM_BLK-BC_OVERHEAD,									// BLKID_AMT
		SM_BLK-BC_OVERHEAD,									// BLKID_AMT_ROUTE
		SM_BLK-BC_OVERHEAD,									// BLKID_BRE
		SM_BLK-BC_OVERHEAD,									// BLKID_BRE_ROUTE
		LG_BLK-BC_OVERHEAD,									// BLKID_ATPREQ
		LG_BLK-BC_OVERHEAD,									// BLKID_ATPRESP
		LG_BLK-BC_OVERHEAD,									// BLKID_ASPREQ
		SM_BLK-BC_OVERHEAD,									// BLKID_ARAP_SMPKT
		SM_BLK-BC_OVERHEAD,									// BLKID_ARAP_MDPKT
		LG_BLK-BC_OVERHEAD,									// BLKID_ARAP_LGPKT
		XL_BLK-BC_OVERHEAD,                 	            // BLKID_ARAP_SNDPKT
		XL_BLK-BC_OVERHEAD,									// BLKID_ARAP_LGBUF
		SM_BLK-BC_OVERHEAD,									// BLKID_AARP
		SM_BLK-BC_OVERHEAD,									// BLKID_DDPSM
		XL_BLK-BC_OVERHEAD,									// BLKID_DDPLG
		LG_BLK-BC_OVERHEAD,									// BLKID_SENDBUF
		SM_BLK-BC_OVERHEAD,									// BLKID_MNP_SMSENDBUF
		LG_BLK-BC_OVERHEAD									// BLKID_MNP_LGSENDBUF
	};

BYTE	atalkNumBlks[NUM_BLKIDS] =	// Number of blocks per chunk
	{
		NUM_BLOCKS(sizeof(BUFFER_DESC),			SM_BLK),	// BLKID_BUFFDESC
		NUM_BLOCKS(sizeof(AMT),					SM_BLK),	// BLKID_AMT
		NUM_BLOCKS(sizeof(AMT)+MAX_ROUTING_SPACE,SM_BLK),	// BLKID_AMT_ROUTE
		NUM_BLOCKS(sizeof(BRE),					SM_BLK),	// BLKID_BRE
		NUM_BLOCKS(sizeof(BRE)+MAX_ROUTING_SPACE,SM_BLK),	// BLKID_BRE_ROUTE
		NUM_BLOCKS(sizeof(ATP_REQ),				LG_BLK),	// BLKID_ATPREQ
		NUM_BLOCKS(sizeof(ATP_RESP),			LG_BLK),	// BLKID_ATPRESP
		NUM_BLOCKS(sizeof(ASP_REQUEST),			LG_BLK),	// BLKID_ASPREQ
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_SMPKT_SIZE,SM_BLK), // BLKID_ARAP_SMPKT
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_MDPKT_SIZE,SM_BLK),	// BLKID_ARAP_MDPKT
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_LGPKT_SIZE,LG_BLK),	// BLKID_ARAP_LGPKT
		NUM_BLOCKS(ARAP_SENDBUF_SIZE,XL_BLK),	            // BLKID_ARAP_SNDPKT
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_LGBUF_SIZE,XL_BLK),	// BLKID_ARAP_LGBUF
		NUM_BLOCKS(sizeof(AARP_BUFFER),			SM_BLK),	// BLKID_AARP
		NUM_BLOCKS(sizeof(DDP_SMBUFFER),		SM_BLK),	// BLKID_DDPSM
		NUM_BLOCKS(sizeof(DDP_LGBUFFER),		XL_BLK),	// BLKID_DDPLG
		NUM_BLOCKS(sizeof(SENDBUF),				LG_BLK),	// BLKID_SENDBUF
		NUM_BLOCKS(sizeof(MNPSENDBUF)+MNP_MINSEND_LEN,SM_BLK), // BLKID_MNP_SMSENDBUF
		NUM_BLOCKS(sizeof(MNPSENDBUF)+MNP_MAXSEND_LEN,LG_BLK)  // BLKID_MNP_LGSENDBUF
	};

ATALK_SPIN_LOCK	atalkBPLock[NUM_BLKIDS] = { 0 };

PBLK_CHUNK		atalkBPHead[NUM_BLKIDS] = { 0 };
TIMERLIST		atalkBPTimer = { 0 };

//	List of all adsp address/connection objects.
PADSP_ADDROBJ	atalkAdspAddrList	= NULL;
PADSP_CONNOBJ	atalkAdspConnList	= NULL;
ATALK_SPIN_LOCK	atalkAdspLock		= {0};

//
// ARAP data
//
struct _PORT_DESCRIPTOR  *RasPortDesc  EQU  NULL;

// spinlock to guard the all the Arap global things
ATALK_SPIN_LOCK ArapSpinLock;

// global configuration info
ARAPGLOB        ArapGlobs           EQU {0};

PIRP            ArapSelectIrp       EQU NULL;
DWORD           ArapConnections     EQU 0;
DWORD           ArapStackState      EQU ARAP_STATE_INACTIVE_WAITING;

DWORD           PPPConnections      EQU 0;

#if	DBG

ATALK_SPIN_LOCK		AtalkDebugSpinLock;

DWORD               AtalkDbgMdlsAlloced  EQU 0;
DWORD               AtalkDbgIrpsAlloced  EQU 0;


ULONG			AtalkDebugDump 		= 0;
LONG			AtalkDumpInterval	= DBG_DUMP_DEF_INTERVAL;
ULONG			AtalkDebugLevel		= DBG_LEVEL_ERR;
ULONG			AtalkDebugSystems	= DBG_MOST;
TIMERLIST		AtalkDumpTimerList	= { 0 };
LONG			AtalkMemLimit = 10*1024*1024;

LONG	atalkNumChunksForId[NUM_BLKIDS] = { 0 };
LONG	atalkBlksForId[NUM_BLKIDS] = { 0 };

PIRP            ArapSniffIrp        = NULL;
ARAPSTATS       ArapStatistics      = {0,0,10000,10000,0,10000};
DWORD           ArapDumpLevel       = 0;
DWORD           ArapDumpLen         = 64;
DWORD           ArapDbgMnpSendSizes[30] = {0};
DWORD           ArapDbgMnpRecvSizes[30] = {0};
DWORD           ArapDbgArapSendSizes[15] = {0};
DWORD           ArapDbgArapRecvSizes[15] = {0};
LARGE_INTEGER   ArapDbgLastTraceTime;
UCHAR           ArapDbgLRPacket[30] = {0x1d,1,2,1,6,1,0,0,0,0,0xff,2,1,2,3,
                                       1,8,4,2,0x40,0,8,1,3,0xe,4,3,0,8,0xfa};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atp.h

Abstract:

	This module contains definitions for the ATP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATP_
#define _ATP_

// Command/control bit masks.
#define ATP_REL_TIMER_MASK					0x07
#define ATP_STS_MASK						0x08
#define ATP_EOM_MASK						0x10
#define ATP_XO_MASK							0x20

// Values for function code
#define ATP_REQUEST							0x40
#define ATP_RESPONSE						0x80
#define ATP_RELEASE							0xC0
#define ATP_FUNC_MASK						0xC0

#define ATP_CMD_CONTROL_OFF					0
#define ATP_BITMAP_OFF						1
#define ATP_SEQ_NUM_OFF						1
#define ATP_TRANS_ID_OFF					2
#define ATP_USER_BYTES_OFF					4
#define ATP_DATA_OFF						8

#define	ATP_MAX_RESP_PKTS					8
#define	ATP_USERBYTES_SIZE					4
#define	ATP_HEADER_SIZE						8

// NOTE: Event handler routines- ATP has no event handling support


// ATP Address Object

#define	ATP_DEF_MAX_SINGLE_PKT_SIZE			578
#define	ATP_MAX_TOTAL_RESPONSE_SIZE			(ATP_MAX_RESP_PKTS * ATP_DEF_MAX_SINGLE_PKT_SIZE)
#define	ATP_DEF_SEND_USER_BYTES_ALL			((BOOLEAN)FALSE)

#define	ATP_DEF_RETRY_INTERVAL				20	// 2 seconds in 100ms units
#define	ATP_INFINITE_RETRIES				-1

#define ATP_REQ_HASH_SIZE					29
#define ATP_RESP_HASH_SIZE					37

// Values for the release timer (.5, 1, 2, 4, 8 minutes).
typedef LONG	RELEASE_TIMERVALUE;

#define	FIRSTVALID_TIMER 					0
#define	THIRTY_SEC_TIMER					0
#define	ONE_MINUTE_TIMER					1
#define	TWO_MINUTE_TIMER					2
#define	FOUR_MINUTE_TIMER 					3
#define	EIGHT_MINUTE_TIMER					4
#define	LAST_VALID_TIMER					4
#define	MAX_VALID_TIMERS					5

//	Different subtypes for ATP indication type.
#define	ATP_ALLOC_BUF	0
#define	ATP_USER_BUF	1
#define	ATP_USER_BUFX	2		// Do not indicate the packet to Atp with this.

struct	_ATP_RESP;

typedef	VOID	(*ATPAO_CLOSECOMPLETION)(
	IN	ATALK_ERROR				CloseResult,
	IN	PVOID					CloseContext
);

typedef VOID	(*ATP_REQ_HANDLER)(
	IN	ATALK_ERROR				Error,
	IN	PVOID					CompletionContext,
	IN	struct _ATP_RESP *		pAtpResp,
	IN	PATALK_ADDR				SourceAddress,
	IN	USHORT					RequestLength,
	IN 	PBYTE					RequestPacket,
	IN 	PBYTE					RequestUserBytes	// 4 bytes of user bytes
);

typedef	VOID	(*ATP_RESP_HANDLER)(
	IN	ATALK_ERROR				Error,
	IN	PVOID					CompletionContext,
	IN	PAMDL					RequestBuffer,
	IN	PAMDL					ResponseBuffer,
	IN	USHORT					ResponseSize,
	IN	PBYTE					ResponseUserBytes	// 4 bytes of user bytes
);


typedef	VOID	(FASTCALL *ATP_REL_HANDLER)(
	IN	ATALK_ERROR				Error,
	IN	PVOID					CompletionContext
);


//  ATP ADDRESS OBJECT	STATES

#define	ATPAO_OPEN				0x00000001
#define ATPAO_SENDUSERBYTESALL  0x00000002
#define	ATPAO_CACHED			0x00000004
#define	ATPAO_TIMERS			0x00000008
#define	ATPAO_CLEANUP			0x40000000
#define	ATPAO_CLOSING			0x80000000

#define ATPAO_SIGNATURE			(*(PULONG)"ATPA")

#if	DBG
#define	VALID_ATPAO(pAtpAddr)	(((pAtpAddr) != NULL) &&						\
								 ((pAtpAddr)->atpao_Signature == ATPAO_SIGNATURE))
#else
#define	VALID_ATPAO(pAtpAddr)	((pAtpAddr) != NULL)
#endif
typedef struct _ATP_ADDROBJ
{
#if DBG
	ULONG					atpao_Signature;
#endif

	LONG					atpao_RefCount;

	// State of the address object
	ULONG					atpao_Flags;

	//	We pass a pointer to the ATP Address object to the upper layers to
	//	use as the endpoint, and this same pointer is passed to DDP Open
	//	Address	as the ATP address handler context.

	//	Linkage list for all responses to AtLeastOnce (ALO) transactions.
	//	These are not kept in the resp hash table for efficiency. These
	//	happen very infrequently and only exist on the list until the
	//	SENDs complete.
	struct _ATP_RESP	* 	atpao_AloRespLinkage;

	// next Transaction id to be used
	USHORT					atpao_NextTid;

	// Maximum single packet size to be used (PAP needs this to be 512)
	USHORT					atpao_MaxSinglePktSize;

	// Pointer to the DDP address object that this will create
	PDDP_ADDROBJ			atpao_DdpAddr;

	// Completion routine to be called when socket is closed
	ATPAO_CLOSECOMPLETION	atpao_CloseComp;
	PVOID					atpao_CloseCtx;

	// Hash table of pending ATP PostReq
	struct _ATP_REQ 	*	atpao_ReqHash[ATP_REQ_HASH_SIZE];

	LIST_ENTRY				atpao_ReqList;			// List of requests for retry timer
	TIMERLIST				atpao_RetryTimer;		// Retry timer for ALL requests

	// Hash table of pending ATP PostResponses
	struct _ATP_RESP 	*	atpao_RespHash[ATP_RESP_HASH_SIZE];

	LIST_ENTRY				atpao_RespList;			// List of requests for release timer
	TIMERLIST				atpao_RelTimer;			// Release timer for ALL XO responses

	// handler and corres. contexts for requests
	ATP_REQ_HANDLER			atpao_ReqHandler;
	PVOID					atpao_ReqCtx;

	PATALK_DEV_CTX			atpao_DevCtx;
	ATALK_SPIN_LOCK			atpao_Lock;
} ATP_ADDROBJ, *PATP_ADDROBJ;


#define	ATP_REQ_EXACTLY_ONCE		0x0001
#define	ATP_REQ_RETRY_TIMER			0x0002
#define	ATP_REQ_REMOTE				0x0004
#define	ATP_REQ_RESPONSE_COMPLETE	0x0008
#define	ATP_REQ_CLOSING				0x8000

#define ATP_REQ_SIGNATURE			(*(PULONG)"ATRQ")
#if	DBG
#define	VALID_ATPRQ(pAtpReq)		(((pAtpReq) != NULL) &&						\
									 ((pAtpReq)->req_Signature == ATP_REQ_SIGNATURE))
#else
#define	VALID_ATPRQ(pAtpReq)		((pAtpReq) != NULL)
#endif
typedef struct _ATP_REQ
{
#if DBG
	ULONG					req_Signature;
#endif

	LONG					req_RefCount;

	// Linkage of requests on this address object (hash overflow)
	struct _ATP_REQ 	*	req_Next;
	struct _ATP_REQ 	**	req_Prev;

	LIST_ENTRY				req_List;		// List of requests for retry timer

	// BackPointer to the ATP address object. Need for reference/Dereference.
	PATP_ADDROBJ			req_pAtpAddr;

	// State of the request
	USHORT					req_Flags;

	// ATP Bitmap showing the response packets we are waiting for/expect.
	BYTE					req_Bitmap;

	BYTE					req_RecdBitmap;

	// Destination of this request
	ATALK_ADDR				req_Dest;

	// Request buffer for retransmission
	PAMDL					req_Buf;
	USHORT					req_BufLen;

	// Transaction id
	USHORT					req_Tid;

	union
	{
		BYTE				req_UserBytes[ATP_USERBYTES_SIZE];
		DWORD				req_dwUserBytes;
	};

	// User's response buffer
	PAMDL					req_RespBuf;

	//	Buffer descriptors for parts of the resp buf.
	PNDIS_BUFFER			req_NdisBuf[ATP_MAX_RESP_PKTS];

	USHORT					req_RespBufLen;

	//	Received response length
	USHORT					req_RespRecdLen;
	BYTE					req_RespUserBytes[ATP_USERBYTES_SIZE];

	LONG					req_RetryInterval;
	LONG					req_RetryCnt;

	//	Release timer value to send to the remote end.
	RELEASE_TIMERVALUE		req_RelTimerValue;

	// Retry time stamp, time at which the request will be retried if no response
	LONG					req_RetryTimeStamp;

	// Completion routine to be called when request is done
	ATALK_ERROR				req_CompStatus;
	ATP_RESP_HANDLER		req_Comp;
	PVOID					req_Ctx;
	ATALK_SPIN_LOCK			req_Lock;
} ATP_REQ, *PATP_REQ;

// ATP_RESP_REMOTE indicates that the response is not to a local socket in which
// case we can avoid trying to deliver to our sockets
#define	ATP_RESP_EXACTLY_ONCE			0x0001
#define	ATP_RESP_ONLY_USER_BYTES		0x0002
#define	ATP_RESP_REL_TIMER				0x0004
#define	ATP_RESP_VALID_RESP				0x0008
#define	ATP_RESP_SENT					0x0010
#define	ATP_RESP_TRANSMITTING			0x0020
#define	ATP_RESP_REMOTE					0x0040
#define	ATP_RESP_HANDLER_NOTIFIED		0x0080
#define	ATP_RESP_CANCELLED				0x0100
#define	ATP_RESP_RELEASE_RECD			0x0200
#define	ATP_RESP_CLOSING				0x8000

#define ATP_RESP_SIGNATURE				(*(PULONG)"ATRS")
#if	DBG
#define	VALID_ATPRS(pAtpResp)			(((pAtpResp) != NULL) &&				\
										 ((pAtpResp)->resp_Signature == ATP_RESP_SIGNATURE))
#else
#define	VALID_ATPRS(pAtpResp)			((pAtpResp) != NULL)
#endif
typedef struct _ATP_RESP
{
#if DBG
	ULONG					resp_Signature;
#endif

	LONG					resp_RefCount;

	// Linkage of responses on this address object (hash overflow)
	struct _ATP_RESP 	*	resp_Next;
	struct _ATP_RESP 	**	resp_Prev;

	LIST_ENTRY				resp_List;		// List of resp for release timer

	// BackPointer to the ATP address object
	PATP_ADDROBJ			resp_pAtpAddr;

	// Transaction id
	USHORT					resp_Tid;

	// ATP Bitmap from corresponding request
	BYTE					resp_Bitmap;
	BYTE					resp_UserBytesOnly;

	// Destination of this request
	ATALK_ADDR				resp_Dest;

	// State of the response
	USHORT					resp_Flags;

	// User's response buffer
	USHORT					resp_BufLen;
	PAMDL					resp_Buf;
	union
	{
		BYTE				resp_UserBytes[ATP_USERBYTES_SIZE];
		DWORD				resp_dwUserBytes;
	};

	// Release timer value, How long do we wait before release.
	LONG					resp_RelTimerTicks;

	// Release time stamp, time at which the request arrived.
	LONG					resp_RelTimeStamp;

	// Routine to call when release comes in, or release timer expires
	ATALK_ERROR				resp_CompStatus;
	ATP_REL_HANDLER			resp_Comp;
	PVOID					resp_Ctx;
	ATALK_SPIN_LOCK			resp_Lock;
} ATP_RESP, *PATP_RESP;


#define	ATP_RETRY_TIMER_INTERVAL	10		// 1 second in 100ms units
											// NOTE: This will essentially put dampers on
											//		 the RT stuff. Thats not too bad since
											//		 we are guaranteed to try every second atleast
#define	ATP_RELEASE_TIMER_INTERVAL	300		// 30 seconds in 100ms units

//	Values for the 0.5, 1, 2, 4, 8 minute timer in ATP_RELEASE_TIMER_INTERVAL units.
extern	SHORT	AtalkAtpRelTimerTicks[MAX_VALID_TIMERS];

//	Bitmaps for the sequence numbers in response packets.
extern	BYTE	AtpBitmapForSeqNum[ATP_MAX_RESP_PKTS];

extern	BYTE	AtpEomBitmapForSeqNum[ATP_MAX_RESP_PKTS];

typedef struct
{
	BYTE		atph_CmdCtrl;
	union
	{
		BYTE	atph_SeqNum;
		BYTE	atph_Bitmap;
	};
	USHORT		atph_Tid;
	union
	{
		BYTE	atph_UserBytes[ATP_USERBYTES_SIZE];
		DWORD	atph_dwUserBytes;
	};
} ATP_HEADER, *PATP_HEADER;

//	Exported prototypes
#define	AtalkAtpGetDdpAddress(pAtpAddr)	((pAtpAddr)->atpao_DdpAddr)

extern
ATALK_ERROR
AtalkAtpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPort,
	IN		BYTE					Socket,
	IN OUT	PATALK_NODEADDR			pDesiredNode		OPTIONAL,
	IN		USHORT					MaxSinglePktSize,
	IN		BOOLEAN					SendUserBytesAll,
	IN		PATALK_DEV_CTX			pDevCtx				OPTIONAL,
	IN		BOOLEAN					CacheSocket,
	OUT		PATP_ADDROBJ	*		ppAtpAddr);

extern
ATALK_ERROR
AtalkAtpCleanupAddress(
	IN	PATP_ADDROBJ				pAtpAddr);

extern
ATALK_ERROR
AtalkAtpCloseAddress(
	IN	PATP_ADDROBJ				pAddr,
	IN	ATPAO_CLOSECOMPLETION		pCloseCmp	OPTIONAL,
	IN	PVOID						pCloseCtx	OPTIONAL);

extern
ATALK_ERROR
AtalkAtpPostReq(
	IN		PATP_ADDROBJ			pAddr,
	IN		PATALK_ADDR				pDest,
	OUT		PUSHORT					pTid,
	IN		USHORT					Flags,
	IN		PAMDL					pReq,
	IN		USHORT					ReqLen,
	IN		PBYTE					pUserBytes	OPTIONAL,
	IN OUT	PAMDL					pResp		OPTIONAL,
	IN  	USHORT					RespLen,
	IN		SHORT					RetryCnt,
	IN		LONG					RetryInterval,
	IN		RELEASE_TIMERVALUE		timerVal,
	IN		ATP_RESP_HANDLER		pCmpRoutine	OPTIONAL,
	IN		PVOID					pCtx		OPTIONAL);

extern
VOID
AtalkAtpSetReqHandler(
	IN		PATP_ADDROBJ			pAddr,
	IN		ATP_REQ_HANDLER			ReqHandler,
	IN		PVOID					ReqCtx		OPTIONAL);

extern
ATALK_ERROR
AtalkAtpPostResp(
	IN		PATP_RESP				pAtpResp,
	IN		PATALK_ADDR				pDest,
	IN OUT	PAMDL					pResp,
	IN		USHORT					RespLen,
	IN		PBYTE					pUbytes		OPTIONAL,
	IN		ATP_REL_HANDLER			pCmpRoutine,
	IN		PVOID					pCtx		OPTIONAL);

extern
ATALK_ERROR
AtalkAtpCancelReq(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		USHORT					Tid,
	IN		PATALK_ADDR				pDest);

extern
BOOLEAN
AtalkAtpIsReqComplete(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		USHORT					Tid,
	IN		PATALK_ADDR				pDest);

extern
ATALK_ERROR
AtalkAtpCancelResp(
	IN		PATP_RESP				pAtpResp);

extern
ATALK_ERROR
AtalkAtpCancelRespByTid(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		PATALK_ADDR				pDest,
	IN		USHORT					Tid);

extern
VOID
AtalkAtpPacketIn(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDstAddr,
	IN	ATALK_ERROR					ErrorCode,
	IN	BYTE						DdpType,
	IN	PATP_ADDROBJ				pAtpAddr,
	IN	BOOLEAN						OptimizePath,
	IN	PVOID						OptimizeCtx);

#define	AtalkAtpAddrReference(_pAtpAddr, _pError)								\
	{																			\
		KIRQL	OldIrql;														\
																				\
		ACQUIRE_SPIN_LOCK(&(_pAtpAddr)->atpao_Lock, &OldIrql);					\
		atalkAtpAddrRefNonInterlock((_pAtpAddr), _pError);						\
		RELEASE_SPIN_LOCK(&(_pAtpAddr)->atpao_Lock, OldIrql);					\
	}

#define	AtalkAtpAddrReferenceDpc(_pAtpAddr, _pError)							\
	{																			\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpAddr)->atpao_Lock);						\
		atalkAtpAddrRefNonInterlock((_pAtpAddr), _pError);						\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpAddr)->atpao_Lock);						\
	}

#define	atalkAtpAddrRefNonInterlock(_pAtpAddr, _pError)							\
	{																			\
		*(_pError) = ATALK_NO_ERROR;											\
		if (((_pAtpAddr)->atpao_Flags & (ATPAO_CLOSING|ATPAO_OPEN))==ATPAO_OPEN)\
		{																		\
			ASSERT((_pAtpAddr)->atpao_RefCount >= 1);							\
			(_pAtpAddr)->atpao_RefCount++;										\
		}																		\
		else																	\
		{																		\
			*(_pError) = ATALK_ATP_CLOSING;										\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("atalkAtpAddrRefNonInterlock: %lx %s (%ld) Failure\n",		\
					_pAtpAddr, __FILE__, __LINE__));							\
		}																		\
	}


VOID FASTCALL
AtalkAtpAddrDeref(
	IN OUT	PATP_ADDROBJ			pAtpAddr,
	IN		BOOLEAN					AtDpc);

#define	AtalkAtpAddrDereference(_pAtpAddr)										\
		AtalkAtpAddrDeref(_pAtpAddr, FALSE)

#define	AtalkAtpAddrDereferenceDpc(_pAtpAddr)									\
		AtalkAtpAddrDeref(_pAtpAddr, TRUE)

VOID FASTCALL
AtalkAtpRespDeref(
	IN		PATP_RESP				pAtpResp,
	IN		BOOLEAN					AtDpc);

#define	AtalkAtpRespDereference(_pAtrpResp)										\
		AtalkAtpRespDeref(_pAtrpResp, FALSE)

#define	AtalkAtpRespDereferenceDpc(_pAtrpResp)									\
		AtalkAtpRespDeref(_pAtrpResp, TRUE)

#define	AtalkAtpRespReferenceByPtr(_pAtpResp, _pError)							\
	{																			\
		KIRQL	OldIrql;														\
																				\
		*(_pError) = ATALK_NO_ERROR;											\
																				\
		ACQUIRE_SPIN_LOCK(&(_pAtpResp)->resp_Lock, &OldIrql);					\
		if (((_pAtpResp)->resp_Flags & ATP_RESP_CLOSING) == 0)					\
		{																		\
			(_pAtpResp)->resp_RefCount++;										\
		}																		\
		else																	\
		{																		\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("AtalkAtpRespReferenceByPtr: %lx %s (%ld) Failure\n",		\
					_pAtpResp, __FILE__, __LINE__));							\
			*(_pError) = ATALK_ATP_RESP_CLOSING;								\
		}																		\
		RELEASE_SPIN_LOCK(&(_pAtpResp)->resp_Lock, OldIrql);					\
	}

#define	AtalkAtpRespReferenceByPtrDpc(_pAtpResp, _pError)						\
	{																			\
		*(_pError) = ATALK_NO_ERROR;											\
																				\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
		if (((_pAtpResp)->resp_Flags & ATP_RESP_CLOSING) == 0)					\
		{																		\
			(_pAtpResp)->resp_RefCount++;										\
		}																		\
		else																	\
		{																		\
			*(_pError) = ATALK_ATP_RESP_CLOSING;								\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("atalkAtpRespRefByPtrDpc: %lx %s (%ld) Failure\n",			\
					_pAtpResp, __FILE__, __LINE__));							\
		}																		\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
	}

ATALK_ERROR
AtalkIndAtpPkt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLookahead,
	IN		USHORT				PktLen,
	IN	OUT	PUINT				pXferOffset,
	IN		PBYTE				pLinkHdr,
	IN		BOOLEAN				ShortDdpHdr,
	OUT		PBYTE				SubType,
	OUT		PBYTE			* 	ppPacket,
	OUT		PNDIS_PACKET	*	pNdisPkt);

ATALK_ERROR
AtalkIndAtpCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr,
	IN	PPORT_DESCRIPTOR		pPortDesc);

VOID
AtalkIndAtpUnCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr);

VOID FASTCALL
AtalkAtpGenericRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PATP_RESP				pAtpResp
);

VOID FASTCALL
AtalkIndAtpSetupNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq,
	IN		ULONG			MaxSinglePktSize
);

VOID FASTCALL
AtalkIndAtpReleaseNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq
);


//	ATALK_ERROR
//	AtalkIndAtpCacheLkUpSocket(
//		IN	PATALK_ADDR				pDestAddr,
//		OUT	struct _ATP_ADDROBJ	**	ppAtpAddr,
//		OUT	ATALK_ERROR			*	pError);
//
#define	AtalkIndAtpCacheLkUpSocket(pDestAddr, ppAtpAddr, pError)	\
	{																\
		USHORT					i;									\
		struct ATALK_CACHED_SKT	*pCachedSkt;						\
																	\
		*(pError) = ATALK_FAILURE;									\
																	\
		if (((pDestAddr)->ata_Network == AtalkSktCache.ac_Network) &&	\
			((pDestAddr)->ata_Node	== AtalkSktCache.ac_Node))		\
		{															\
			ACQUIRE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
																	\
			for (i = 0, pCachedSkt = &AtalkSktCache.ac_Cache[0];	\
				 i < ATALK_CACHE_SKTMAX;							\
				 i++, pCachedSkt++)									\
			{														\
				if ((pCachedSkt->Type == (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT))	&&	\
					(pCachedSkt->Socket == (pDestAddr)->ata_Socket))\
				{													\
					AtalkAtpAddrReferenceDpc(pCachedSkt->u.pAtpAddr,\
											 pError);				\
																	\
					if (ATALK_SUCCESS(*pError))						\
					{												\
						*(ppAtpAddr) = pCachedSkt->u.pAtpAddr;		\
					}												\
					break;											\
				}													\
			}														\
																	\
			RELEASE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
		}															\
	}

VOID FASTCALL
atalkAtpReqDeref(
	IN		PATP_REQ				pAtpReq,
	IN		BOOLEAN					AtDpc);

//	MACROS
//	Top byte of network number is pretty static so we get rid of it and add
//	in the tid.
#define	ATP_HASH_TID_DESTADDR(_tid, _pAddr, _BucketSize)						\
			(((_pAddr)->ata_Node+((_pAddr)->ata_Network & 0xFF)+_tid)%(_BucketSize))

#define	atalkAtpReqReferenceByAddrTidDpc(_pAtpAddr, _pAddr, _Tid, _ppAtpReq, _pErr)	\
	{																			\
		PATP_REQ		__p;													\
		ULONG			__i;													\
																				\
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,									\
				("atalkAtpReqRefByAddrTid: %lx.%lx.%lx tid %lx\n",				\
				(_pAddr)->ata_Network, (_pAddr)->ata_Node,						\
				(_pAddr)->ata_Socket, (_Tid)));									\
																				\
		__i = ATP_HASH_TID_DESTADDR((_Tid), (_pAddr), ATP_REQ_HASH_SIZE);		\
		for (__p = (_pAtpAddr)->atpao_ReqHash[(__i)];							\
			 __p != NULL;														\
			 __p = __p->req_Next)												\
		{																		\
			if ((ATALK_ADDRS_EQUAL(&__p->req_Dest, (_pAddr))) &&				\
				(__p->req_Tid == (_Tid)))										\
			{																	\
				AtalkAtpReqReferenceByPtrDpc(__p, _pErr);						\
				if (ATALK_SUCCESS(*(_pErr)))									\
				{																\
					*(_ppAtpReq) = __p;											\
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,						\
							("atalkAtpReqRefByAddrTid: FOUND %lx\n", __p));		\
				}																\
				break;															\
			}																	\
		}																		\
		if (__p == NULL)														\
			*(_pErr) = ATALK_ATP_NOT_FOUND;										\
	}

#define	AtalkAtpReqReferenceByPtr(_pAtpReq, _pErr)								\
	{																			\
		KIRQL	OldIrql;														\
																				\
		*(_pErr) = ATALK_NO_ERROR;												\
																				\
		ACQUIRE_SPIN_LOCK(&(_pAtpReq)->req_Lock, &OldIrql);						\
		if (((_pAtpReq)->req_Flags & ATP_REQ_CLOSING) == 0)						\
		{																		\
			(_pAtpReq)->req_RefCount++;											\
		}																		\
		else																	\
		{																		\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("AtalkAtpReqReferenceByPtr: %lx %s (%ld) Failure\n",		\
					_pAtpReq, __FILE__, __LINE__));								\
			*(_pErr) = ATALK_ATP_REQ_CLOSING;									\
		}																		\
		RELEASE_SPIN_LOCK(&(_pAtpReq)->req_Lock, OldIrql);						\
	}

#define	AtalkAtpReqReferenceByPtrDpc(_pAtpReq, _pErr)							\
	{																			\
		*(_pErr) = ATALK_NO_ERROR;												\
																				\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpReq)->req_Lock);							\
		if (((_pAtpReq)->req_Flags & ATP_REQ_CLOSING) == 0)						\
		{																		\
			(_pAtpReq)->req_RefCount++;											\
		}																		\
		else																	\
		{																		\
			*(_pErr) = ATALK_ATP_REQ_CLOSING;									\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("AtalkAtpReqReferenceByPtrDpc: %lx %s (%ld) Failure\n",	\
					_pAtpReq, __FILE__, __LINE__));								\
		}																		\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpReq)->req_Lock);							\
	}

#define	atalkAtpRespReferenceNDpc(_pAtpResp, _N, _pError)						\
	{																			\
		*(_pError) = ATALK_NO_ERROR;											\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
		if (((_pAtpResp)->resp_Flags & ATP_RESP_CLOSING) == 0)					\
		{																		\
			(_pAtpResp)->resp_RefCount += _N;									\
		}																		\
		else																	\
		{																		\
			*(_pError) = ATALK_ATP_RESP_CLOSING;								\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("atalkAtpRespReferenceNDpc: %lx %d %s (%ld) Failure\n",	\
					_pAtpResp, _N, __FILE__, __LINE__));						\
		}																		\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
	}

// THIS SHOULD BE CALLED WITH ADDRESS LOCK HELD !!!

#define	atalkAtpRespReferenceByAddrTidDpc(_pAtpAddr, _pAddr, _Tid, _ppAtpResp, _pErr)\
	{																			\
		PATP_RESP		__p;													\
		ULONG			__i;													\
																				\
		__i = ATP_HASH_TID_DESTADDR((_Tid), (_pAddr), ATP_RESP_HASH_SIZE);		\
																				\
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,									\
				("atalkAtpRespRefByAddrTid: %lx.%lx.%lx tid %lx\n",				\
				(_pAddr)->ata_Network, (_pAddr)->ata_Node,						\
				(_pAddr)->ata_Socket, (_Tid)));									\
																				\
		for (__p = (_pAtpAddr)->atpao_RespHash[__i];							\
			 __p != NULL;														\
			 __p = __p->resp_Next)												\
		{																		\
			if (ATALK_ADDRS_EQUAL(&__p->resp_Dest, _pAddr) &&					\
				(__p->resp_Tid == (_Tid)))										\
			{																	\
				AtalkAtpRespReferenceByPtrDpc(__p, _pErr);						\
				if (ATALK_SUCCESS((*(_pErr))))									\
				{																\
					*(_ppAtpResp) = __p;										\
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,						\
							("atalkAtpRespRefByAddrTid: FOUND %lx\n", __p));	\
				}																\
				break;															\
			}																	\
		}																		\
		if (__p == NULL)														\
			*(_pErr) = ATALK_ATP_NOT_FOUND;										\
	}

#define		AtalkAtpReqDereference(_pAtpReq)									\
			atalkAtpReqDeref(_pAtpReq, FALSE)

#define		AtalkAtpReqDereferenceDpc(_pAtpReq)									\
			atalkAtpReqDeref(_pAtpReq, TRUE)

VOID FASTCALL
atalkAtpTransmitReq(
	IN		PATP_REQ			pAtpReq);

VOID FASTCALL
atalkAtpTransmitResp(
	IN		PATP_RESP			pAtpResp);

VOID FASTCALL
atalkAtpTransmitRel(
	IN		PATP_REQ			pAtpReq);

VOID
atalkAtpGetNextTidForAddr(
	IN		PATP_ADDROBJ		pAtpAddr,
	IN		PATALK_ADDR			pRemoteAddr,
	OUT		PUSHORT				pTid,
	OUT		PULONG				pIndex);

LOCAL LONG FASTCALL
atalkAtpReqTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAtpRelTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

#define	atalkAtpBufferSizeToBitmap(_Bitmap, _BufSize, _SinglePktSize)			\
	{																			\
		SHORT	__bufSize = (_BufSize);											\
																				\
		(_Bitmap) = 0;															\
		while(__bufSize > 0)													\
		{																		\
			(_Bitmap) = ((_Bitmap) <<= 1) | 1;									\
			__bufSize -= (_SinglePktSize);										\
		}																		\
	}


#define	atalkAtpBitmapToBufferSize(_Size, _Bitmap, _SinglePktSize)				\
	{																			\
		BYTE	__bitmap = (_Bitmap);											\
		BOOLEAN __bitOn;														\
																				\
		_Size = 0;																\
		while (__bitmap)														\
		{																		\
			__bitOn = (__bitmap & 1);											\
			__bitmap >>= 1;														\
			if (__bitOn)														\
			{																	\
				(_Size) += (_SinglePktSize);									\
			}																	\
			else																\
			{																	\
				if (__bitmap)													\
				{																\
					(_Size) = -1;												\
				}																\
				break;															\
			}																	\
		}																		\
	}

VOID FASTCALL
atalkAtpSendReqComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAtpSendRespComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAtpSendRelComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID
atalkAtpRespRefNextNc(
	IN		PATP_RESP			pAtpResp,
	OUT		PATP_RESP	 *  	ppNextNcResp,
	OUT		PATALK_ERROR		pError);

VOID
atalkAtpReqRefNextNc(
	IN		PATP_REQ			pAtpReq,
	OUT		PATP_REQ	*		pNextNcReq,
	OUT		PATALK_ERROR		pError);

VOID FASTCALL
atalkAtpRespComplete(
	IN	OUT	PATP_RESP			pAtpResp,
	IN		ATALK_ERROR			CompletionStatus);

VOID FASTCALL
atalkAtpReqComplete(
	IN	OUT	PATP_REQ			pAtpReq,
	IN		ATALK_ERROR			CompletionStatus);

#endif	// _ATP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\ddp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ddp.c

Abstract:

	This module implements the ddp protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	DDP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkDdpInitCloseAddress)
#pragma alloc_text(PAGEINIT, atalkDdpInitCloseComplete)
#pragma alloc_text(PAGEINIT, AtalkInitDdpOpenStaticSockets)
#endif

//
//	AtalkDdpOpenAddress()
//	This opens a DDP address object and returns a pointer to it in
//	DdpAddrObject. The AppletalkSocket is created and will be the
//	address of this object.
//

ATALK_ERROR
AtalkDdpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN OUT	PATALK_NODEADDR			pDesiredNode	OPTIONAL,
	IN 		DDPAO_HANDLER			pSktHandler 	OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					Protocol		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ	*		ppDdpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pAtalkNode, pNextNode;

	PDDP_ADDROBJ 	pDdpAddr 	= NULL;
	ATALK_ERROR		error 		= ATALK_NO_ERROR;

	DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
			("AtalkDdpOpenAddress: Opening DDP socket %d on port %lx\n",
			Socket, pPortDesc));

	do
	{
		//	Verify the Appletalk socket number
		if (!IS_VALID_SOCKET(Socket))
		{
			error = ATALK_SOCKET_INVALID;
			break;
		}
		//	Allocate space for the address object
		if ((pDdpAddr = AtalkAllocZeroedMemory(sizeof(DDP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}
	
		if (pDesiredNode != NULL)
		{
			AtalkNodeReferenceByAddr(pPortDesc,
									 pDesiredNode,
									 &pAtalkNode,
									 &error);
	
			if (ATALK_SUCCESS(error))
			{
				ASSERT(VALID_ATALK_NODE(pAtalkNode));

				//	try to allocate the socket on this node.
				error = atalkDdpAllocSocketOnNode(pPortDesc,
												  Socket,
												  pAtalkNode,
												  pSktHandler,
												  pSktCtx,
												  Protocol,
												  pDevCtx,
												  pDdpAddr);
	
				//	Remove the reference on the node.
				AtalkNodeDereference(pAtalkNode);
			}

			break;
		}
		else
		{
			KIRQL	OldIrql;

			//	We can open the socket on any one of our
			//	nodes.

			//	We first get the port lock
			//	Then we go through all the nodes on the port
			//	reference a node, let go of the port lock
			//	acquire the node lock, try to open the socket
			//	on it. If we succeed, we return, else we fail.

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			do
			{
				//	Try to get a referenced node. null if no non-closing node found.
				AtalkNodeReferenceNextNc(pPortDesc->pd_Nodes, &pAtalkNode, &error);
		
				while (ATALK_SUCCESS(error))
				{
					//	We do not use this node if it is orphaned or if
					//	it is a router node and we are trying to open a
					//	user socket (dynamic or non-reserved).
					if (((pAtalkNode->an_Flags & (AN_ORPHAN_NODE | AN_ROUTER_NODE)) == 0) ||
						((Socket != UNKNOWN_SOCKET) && (Socket <= LAST_APPLE_RESD_SOCKET)))
					{
						RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
						//	try to allocate the socket on this node. PortLock held!
						error = atalkDdpAllocSocketOnNode(pPortDesc,
														  Socket,
														  pAtalkNode,
														  pSktHandler,
														  pSktCtx,
														  Protocol,
														  pDevCtx,
														  pDdpAddr);
	
						if (ATALK_SUCCESS(error))
						{
							//	Done! Break out of the loop. Remove the ref we added.
							AtalkNodeDereference(pAtalkNode);
							ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
							break;
						}

						ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
					}

					//	Gotta get to the next node.
					AtalkNodeReferenceNextNc(pAtalkNode->an_Next, &pNextNode, &error);

					RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
					AtalkNodeDereference(pAtalkNode);
					ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

					pAtalkNode = pNextNode;
				}
		
			} while (FALSE);

			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
		}

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		if (ppDdpAddr != NULL)
			*ppDdpAddr = pDdpAddr;
	}
	else
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
				("AtalkDdpOpenAddress: failed with error %lx\n", error));

		if (pDdpAddr)
			AtalkFreeMemory(pDdpAddr);
	}

	return error;
}




ATALK_ERROR
AtalkDdpCleanupAddress(
	IN	PDDP_ADDROBJ			pDdpAddr
	)
/*++

Routine Description:

	Releases any pending requests on the address.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;

	//	Free all pending ddp reads.
	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	while (!IsListEmpty(&pDdpAddr->ddpao_ReadLinkage))
	{
		PLIST_ENTRY	p;
		PDDP_READ	pRead;

		p = RemoveHeadList(&pDdpAddr->ddpao_ReadLinkage);
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

		pRead 	= CONTAINING_RECORD(p, DDP_READ, dr_Linkage);

		(*pRead->dr_RcvCmp)(ATALK_FAILURE,
							pRead->dr_OpBuf,
							0,
							NULL,
							pRead->dr_RcvCtx);

		AtalkDdpDereference(pDdpAddr);
		AtalkFreeMemory(pRead);
		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkDdpCloseAddress(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	GENERIC_COMPLETION		pCloseCmp	OPTIONAL,	
	IN	PVOID					pCloseCtx	OPTIONAL
	)
/*++

Routine Description:

	Called to close an open ddp address object. This will complete after all
	requests on the object are done/cancelled, and the Appletalk Socket is
	closed.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			closing;
    BOOLEAN         pnpZombie;


	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	closing = ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) != 0) ? TRUE : FALSE;
    pnpZombie = ((pDdpAddr->ddpao_Flags & DDPAO_SOCK_PNPZOMBIE) != 0) ? TRUE: FALSE;

	ASSERTMSG("DdpAddr is already closing!\n", ((!closing) || pnpZombie));

	if (!closing)
	{
		//	Set the closing flag and remember the completion routines.
		pDdpAddr->ddpao_Flags |= DDPAO_CLOSING;
		pDdpAddr->ddpao_CloseComp = pCloseCmp;
		pDdpAddr->ddpao_CloseCtx  = pCloseCtx;
	}
	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

	if (!closing)
	{
		//	Release any pending reads
		AtalkDdpCleanupAddress(pDdpAddr);
		AtalkNbpCloseSocket(pDdpAddr);

		//	Remove reference for the creation
		AtalkDdpDereference(pDdpAddr);
	}

    // is this socket in a zombie state?  if so, deref it so it'll get freed
    if (pnpZombie)
    {
        ASSERT(closing == TRUE);

	    DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
		    ("AtalkDdpClose..: zombie addr %lx (%lx) deref'ed\n",
            pDdpAddr,pDdpAddr->ddpao_Handler));

        AtalkDdpDereference(pDdpAddr);
    }

	return ATALK_PENDING;
}


ATALK_ERROR
AtalkDdpPnPSuspendAddress(
	IN	PDDP_ADDROBJ			pDdpAddr
	)
/*++

Routine Description:

	Called to "suspend" an open ddp address object. This is called during PnP,
    to "suspend" "external" sockets. The nodes associated with this address are
    released (deref'ed) and this socket is cleaned up but kept around because
    the client might close it.  When the client does close it, it gets freed.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
    PATALK_NODE     pNode = pDdpAddr->ddpao_Node;
	BOOLEAN			closing;


	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	closing = ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) != 0) ? TRUE : FALSE;

	ASSERTMSG("DdpAddr is already closing!\n", !closing);

	if (!closing)
	{
		//	Set the closing flag and remember the completion routines.
		pDdpAddr->ddpao_Flags |= DDPAO_CLOSING;

        // this call is only for external sockets
        ASSERT((pDdpAddr->ddpao_Flags & DDPAO_SOCK_INTERNAL) == 0);

        pDdpAddr->ddpao_Flags |= DDPAO_SOCK_PNPZOMBIE;
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

	if (!closing)
	{
        PDDP_ADDROBJ *  ppDdpAddr;
        int             index;

		//	Release any pending reads
		AtalkDdpCleanupAddress(pDdpAddr);
		AtalkNbpCloseSocket(pDdpAddr);

	    ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);
	
	    index = HASH_ATALK_ADDR(&pDdpAddr->ddpao_Addr) % NODE_DDPAO_HASH_SIZE;

	    for (ppDdpAddr = &pNode->an_DdpAoHash[index];
		     *ppDdpAddr != NULL;
		    ppDdpAddr = &((*ppDdpAddr)->ddpao_Next))
	    {
		    if (*ppDdpAddr == pDdpAddr)
		    {
			    *ppDdpAddr = pDdpAddr->ddpao_Next;

                // to catch weirdnesses!
                pDdpAddr->ddpao_Next = (PDDP_ADDROBJ)0x081294;
			    break;
		    }
	    }

	    RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

	    if (pDdpAddr->ddpao_EventInfo != NULL)
	    {
		    AtalkFreeMemory(pDdpAddr->ddpao_EventInfo);
            pDdpAddr->ddpao_EventInfo = NULL;
	    }

	    //	Call the completion routines
	    if (pDdpAddr->ddpao_CloseComp != NULL)
	    {
		    (*pDdpAddr->ddpao_CloseComp)(ATALK_NO_ERROR, pDdpAddr->ddpao_CloseCtx);
            pDdpAddr->ddpao_CloseComp = NULL;
	    }

	    //	Dereference the node for this address
	    AtalkNodeDereference(pNode);

	    DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
		    ("AtalkDdpPnp..: addr %lx (%lx) put in zombie state\n",
            pDdpAddr,pDdpAddr->ddpao_Handler));
	}

	return ATALK_PENDING;
}



ATALK_ERROR
AtalkDdpInitCloseAddress(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pAtalkAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PDDP_ADDROBJ	pDdpAddr;

	//	!!!This should only be called during initialization!!!
	KEVENT	Event	= {0};

	//	Try to see if the socket exists.
	AtalkDdpRefByAddr(pPortDesc, pAtalkAddr, &pDdpAddr, &error);
	if (ATALK_SUCCESS(error))
	{
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

		KeInitializeEvent(&Event, NotificationEvent, FALSE);

		//	Call close with the appropriate completion routine.
		error = AtalkDdpCloseAddress(pDdpAddr,
									 atalkDdpInitCloseComplete,
									 (PVOID)&Event);

		//	Remove the reference we added.
		AtalkDdpDereference(pDdpAddr);

		if (error == ATALK_PENDING)
		{
			// 	Wait on event, completion routine will set NdisRequestEvent
			KeWaitForSingleObject(&Event,
								  Executive,
								  KernelMode,
								  TRUE,
								  NULL);

			//	Assume socket closed successfully.
			error = ATALK_NO_ERROR;
		}
	}

	return error;
}




VOID
atalkDdpInitCloseComplete(
	ATALK_ERROR 	Error,
	PVOID			Ctx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PKEVENT		pEvent = (PKEVENT)Ctx;

	if (!ATALK_SUCCESS(Error))
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
				("atalkDdpInitCloseComplete: Closed with error %lx\n", Error));
	}

	KeSetEvent(pEvent, 0L, FALSE);
}




ATALK_ERROR
AtalkInitDdpOpenStaticSockets(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN	OUT PATALK_NODE				pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ	pDdpAddr, pDdpAddr1, pDdpAddr2, pDdpAddr3;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	//	This is called whenever a new node is created.
	do
	{
		error = AtalkDdpOpenAddress(pPortDesc,
									NAMESINFORMATION_SOCKET,
									&pNode->an_NodeAddr,
									AtalkNbpPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr);
	
		if (!ATALK_SUCCESS(error))
			break;
	
        // mark the fact that this is an "internal" socket
        pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

		// A lot of devices today work around the fact that a macintosh uses socket 254
		// for lookups from chooser. Agfa is one such beast. To make this work, we reserve
		// this socket for Nbp lookups ourselves.
		error = AtalkDdpOpenAddress(pPortDesc,
									LAST_DYNAMIC_SOCKET,
									&pNode->an_NodeAddr,
									AtalkNbpPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr1);
	
		if (!ATALK_SUCCESS(error))
		{
			AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
			break;
		}
	
        // mark the fact that this is an "internal" socket
        pDdpAddr1->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

		error = AtalkDdpOpenAddress(pPortDesc,
									ECHOER_SOCKET,
									&pNode->an_NodeAddr,
									AtalkAepPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr2);
	
		if (!ATALK_SUCCESS(error))
		{
			AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
			AtalkDdpCloseAddress(pDdpAddr1, NULL, NULL);
			break;
		}

        // mark the fact that this is an "internal" socket
        pDdpAddr2->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

		//	NOTE: RTMP uses two protocol types.
		error = AtalkDdpOpenAddress(pPortDesc,
									RTMP_SOCKET,
									&pNode->an_NodeAddr,
									AtalkRtmpPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr3);
	
		if (!ATALK_SUCCESS(error))
		{
			AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
			AtalkDdpCloseAddress(pDdpAddr1, NULL, NULL);
			AtalkDdpCloseAddress(pDdpAddr2, NULL, NULL);
		}

        // mark the fact that this is an "internal" socket
        pDdpAddr3->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

	} while (FALSE);

	return error;
}


//
//	AtalkDdpReceive()
//	Called by an external caller to the stack.
// 	PAMDL is an Appletalk Memory Descriptor List. On NT, it will be an MDL.
//


ATALK_ERROR
AtalkDdpReceive(
	IN		PDDP_ADDROBJ		pDdpAddr,
	IN		PAMDL				pAmdl,
	IN		USHORT				AmdlLen,
	IN		ULONG				RecvFlags,
	IN		RECEIVE_COMPLETION	pRcvCmp,
	IN		PVOID				pRcvCtx		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PDDP_READ		pRead;
	NTSTATUS		status;
	ULONG			bytesCopied;
	ATALK_ADDR		remoteAddr;
	KIRQL			OldIrql;
	BOOLEAN			completeRecv 	= FALSE,
					DerefAddr		= FALSE;
	BOOLEAN			pendingDgram 	= FALSE;

	do
	{
		if (pRcvCmp == NULL)
		{
			error = ATALK_DDP_INVALID_PARAM;
			break;
		}

		AtalkDdpReferenceByPtr(pDdpAddr, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		DerefAddr 	= TRUE;
		error		= ATALK_NO_ERROR;

		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
		if (pDdpAddr->ddpao_Flags & DDPAO_DGRAM_PENDING)
		{
			if (AmdlLen < pDdpAddr->ddpao_EventInfo->ev_IndDgramLen)
			{
				error	= ATALK_BUFFER_TOO_SMALL;
			}

			AmdlLen = MIN(AmdlLen, pDdpAddr->ddpao_EventInfo->ev_IndDgramLen);
			status = TdiCopyBufferToMdl(
						pDdpAddr->ddpao_EventInfo->ev_IndDgram,
						0,
						AmdlLen,
						pAmdl,
						0,
						&bytesCopied);

			remoteAddr				= pDdpAddr->ddpao_EventInfo->ev_IndSrc;
			pDdpAddr->ddpao_Flags  &= ~DDPAO_DGRAM_PENDING;
			completeRecv			= TRUE;
		}
		else
		{
			//	This case never really will be executed for non-blocking sockets.
			//	Dont bother about this alloc with spinlock held for now.
			//	RACE CONDITION is with a packet coming in and setting DGRAM_PENDING.
			if ((pRead = AtalkAllocMemory(sizeof(DDP_READ))) == NULL)
			{
				RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
				error = ATALK_RESR_MEM;
				break;
			}

			InsertTailList(&pDdpAddr->ddpao_ReadLinkage, &pRead->dr_Linkage);

			DerefAddr = FALSE;
			pRead->dr_OpBuf 	= pAmdl;
			pRead->dr_OpBufLen 	= AmdlLen;
			pRead->dr_RcvCmp 	= pRcvCmp;
			pRead->dr_RcvCtx 	= pRcvCtx;
			error 				= ATALK_PENDING;

		}
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	
	} while (FALSE);

	if (completeRecv)
	{
		ASSERT((error == ATALK_NO_ERROR) || (error == ATALK_BUFFER_TOO_SMALL));
		(*pRcvCmp)(error,
				   pAmdl,
				   AmdlLen,
				   &remoteAddr,
				   pRcvCtx);

		//	And return pending for sure!
		error		= ATALK_PENDING;
		DerefAddr	= TRUE;
	}


	if (DerefAddr)
	{
		AtalkDdpDereference(pDdpAddr);
	}

	return error;
}




//
//	DdpSend()
//	This function is used to deliver packets submitted by the ddp clients.
//	The packets are assummed to either be destined for one of the nodes on
//	the port, or need to be routed to another port (if router is on), or to
//	be transmitted onto the physical medium.
//
//	This takes a buffer descriptor as an input. This can contain either a
//	PAMDL or a PBYTE depending on where the data is coming from (user space
//	or router code respectively). In addition, it will take an optional header
//	buffer that will be appended to the ddp header. The buffer descriptor is
//	optional, that if NULL, it will be construed as a zero-length send.
//

ATALK_ERROR
AtalkDdpSend(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PATALK_ADDR					pDestAddr,
	IN	BYTE						Protocol,
	IN	BOOLEAN						DefinitelyRemoteAddr,
	IN	PBUFFER_DESC				pBuffDesc		OPTIONAL,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	PBYTE						pMcastAddr		OPTIONAL,
	IN	PSEND_COMPL_INFO			pSendInfo		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR			error;
	BOOLEAN				shouldBeRouted;
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ADDR			srcAddr;
	KIRQL				OldIrql;
	BOOLEAN				delivered 	= FALSE;

	//	NULL buffer descriptor => 0-length send.
	ASSERT((pBuffDesc == NULL) || (pBuffDesc->bd_Length > 0));

#ifdef DDP_STRICT
	//	Check destination address
	if (INVALID_ADDRESS(pDestAddr))
	{
		return ATALK_DDP_INVALID_ADDR;
	}
	
	//	Check the datagram length.
	if (pBuffDesc)
	{
		USHORT	dgramLen;

		AtalkSizeOfBuffDescData(pBuffDesc, &dgramLen);
		if (dgramLen > MAX_DGRAM_SIZE)
		{
			return ATALK_BUFFER_TOO_BIG;
		}
	}
#endif

    //
    // if this socket is in a zombie state (pnp changes are over) then reject
    // this send
    //
    if (pDdpAddr->ddpao_Flags & DDPAO_SOCK_PNPZOMBIE)
    {
		return ATALK_DDP_INVALID_ADDR;
    }

	//	Get a pointer to the port on which the socket exists.
	pPortDesc = pDdpAddr->ddpao_Node->an_Port;

	//	Get the source address
	srcAddr = pDdpAddr->ddpao_Addr;

	if (!DefinitelyRemoteAddr)
	{
		// All socket handlers assume that they are called at DISPACTH. Make it so.
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

		AtalkDdpOutBufToNodesOnPort(pPortDesc,
									&srcAddr,
									pDestAddr,
									Protocol,
									pBuffDesc,
									pOptHdr,
									OptHdrLen,
									&delivered);
		KeLowerIrql(OldIrql);

		if (delivered)
		{
			//	Ok, packet meant for one of our own nodes on this port,
			//	and we delivered it. Call the completion routine.
	
			if (pSendInfo != NULL)
			{
				(*pSendInfo->sc_TransmitCompletion)(NDIS_STATUS_SUCCESS, pSendInfo);
			}
			return ATALK_PENDING;
		}
	}

	ASSERT (!delivered);

	//	Can our router handle it?
	shouldBeRouted = ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING)					&&
					  (pDestAddr->ata_Network != CABLEWIDE_BROADCAST_NETWORK)	&&
					  !(WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
											 &pPortDesc->pd_NetworkRange))		&&
					  !(WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
											 &AtalkStartupNetworkRange)));

	DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
			("AtalkDdpSend: destNet %lx shouldBeRouted %s\n",
			pDestAddr->ata_Network, shouldBeRouted ? "Yes" : "No"));

	if (shouldBeRouted)
	{
		ASSERT (!((WITHIN_NETWORK_RANGE(pDestAddr->ata_Network, &pPortDesc->pd_NetworkRange)) &&
				  (pDestAddr->ata_Node == ATALK_BROADCAST_NODE)));

		//	If we're a router and the packet isn't destined for the target ports
		//	local network, let our router handle it -- rather than sending to
		//	whatever the "best router" is or to "a router".
		do
		{
			// This algorithm is taken from the "Appletalk Phase 2 Specification".
		
			// If the destination network number is within the range of the reception
			// port's network range and the destination node number is broadcast, then
			// we can drop the packet on the floor -- it is a network specific broadcast
			// not for this router.  Note that we've already delivered the packet, and
			// thus not gotten here, if it was really addressed to the network of any
			// node owned by the reception port (in AtalkDdpPacketIn).
			// Also:
			// Try to find an entry in the routing table that contains the target
			// network.  If not found, discard the packet.

			PDDP_ADDROBJ		pRouteDdpAddr;
			PRTE				pRte;
			PPORT_DESCRIPTOR	pDestPortDesc;
			PATALK_NODE			pRouterNode;
			ATALK_ADDR			actualDest;
		
			if ((pRte = AtalkRtmpReferenceRte(pDestAddr->ata_Network)) == NULL)
			{
				DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_FATAL,
						("AtalkDdpRouter: %lx RtmpRte/Not in ThisCableRange\n",
						pDestAddr->ata_Network));
		
				error = ATALK_RESR_MEM;
				break;
			}
		
			do
			{
				//	Get the port descriptor corres. to the RTE
				pDestPortDesc = pRte->rte_PortDesc;
		
				ASSERT(VALID_PORT(pDestPortDesc));
		
				//	If the target network's hop count is non-zero, we really need to send
				//	the beast, so, just do it!
				if (pRte->rte_NumHops != 0)
				{
					//	Too many hops?
					error = AtalkDdpTransmit(pDestPortDesc,
											 &srcAddr,
											 pDestAddr,
											 Protocol,
											 pBuffDesc,
											 pOptHdr,
											 OptHdrLen,
											 1,						//	HopCount
											 NULL,					//	pZoneMcastAddr
											 &pRte->rte_NextRouter,
											 pSendInfo);
					break;
				}
				
				//	If the destination node is zero, the packet is really destined for the
				//	router's node on this port.
				if (pDestAddr->ata_Node == ANY_ROUTER_NODE)
				{
					//	Try to reference this port, if not successful, its probably
					//	closing down. Grab the port lock and read the router node address.
					//	No need to reference, just ensure its not null.
					ACQUIRE_SPIN_LOCK(&pDestPortDesc->pd_Lock, &OldIrql);
		
					if ((pDestPortDesc->pd_Flags & PD_CLOSING) == 0)
					{
						ASSERT(pDestPortDesc->pd_RefCount > 0);
						pDestPortDesc->pd_RefCount++;
					}
					else
					{
						ASSERTMSG("AtalkDdpRouter: Could not ref port!\n", 0);
						error = ATALK_PORT_CLOSING;
						RELEASE_SPIN_LOCK(&pDestPortDesc->pd_Lock, OldIrql);
						break;
					}
		
					pRouterNode = pDestPortDesc->pd_RouterNode;
					if (pRouterNode != NULL)
					{
						actualDest.ata_Network = pRouterNode->an_NodeAddr.atn_Network;
						actualDest.ata_Node    = pRouterNode->an_NodeAddr.atn_Node;
		
						//	Set the actual destination socket.
						actualDest.ata_Socket  = pDestAddr->ata_Socket;
					}
					else
					{
						ASSERTMSG("AtalkDdpRouter: pRouter node is null!\n", 0);
						error = ATALK_DDP_NOTFOUND;
					}
		
					if (ATALK_SUCCESS(error))
					{
						AtalkDdpRefByAddrNode(pDestPortDesc,
											  &actualDest,
											  pRouterNode,
											  &pRouteDdpAddr,
											  &error);
					}
		
					RELEASE_SPIN_LOCK(&pDestPortDesc->pd_Lock, OldIrql);
		
					if (ATALK_SUCCESS(error))
					{
						KIRQL	OldIrql;

						// Socket handlers assume that they are called at DISPATCH. Make it so.
						KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

						AtalkDdpInvokeHandlerBufDesc(pDestPortDesc,
													 pRouteDdpAddr,
													 &srcAddr,
													 pDestAddr,		// Pass in the actual destination
													 Protocol,
													 pBuffDesc,
													 pOptHdr,
													 OptHdrLen);
		
						//	Remove the reference on the socket
						AtalkDdpDereferenceDpc(pRouteDdpAddr);

						KeLowerIrql(OldIrql);
					}
					else
					{
						ASSERTMSG("AtalkDdpRouter: pSocket on router node is null!\n", 0);
					}
					break;
				}
		
				//	Okay, now walk through the nodes on the target port, looking for a
				//	home for this packet.
				if (!DefinitelyRemoteAddr)
				{
					// All socket handlers assume that they are called at DISPACTH. Make it so.
					KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

					AtalkDdpOutBufToNodesOnPort(pDestPortDesc,
												&srcAddr,
												pDestAddr,
												Protocol,
												pBuffDesc,
												pOptHdr,
												OptHdrLen,
												&delivered);
					KeLowerIrql(OldIrql);

					if (delivered)
					{
			            if (pSendInfo != NULL)
			            {
				            (*pSendInfo->sc_TransmitCompletion)(NDIS_STATUS_SUCCESS, pSendInfo);
			            }
						error = ATALK_NO_ERROR;
						break;
					}
				}
			
				//	We need to deliver this packet to a local ports network.
				error = AtalkDdpTransmit(pDestPortDesc,
										 &srcAddr,
										 pDestAddr,
										 Protocol,
										 pBuffDesc,
										 pOptHdr,
										 OptHdrLen,
										 1,						//	HopCount
										 NULL,					//	pZoneMcastAddr,
										 NULL,	
										 pSendInfo);
			} while (FALSE);
		
			INTERLOCKED_INCREMENT_LONG_DPC(
					&pDestPortDesc->pd_PortStats.prtst_NumPktRoutedOut,
					&AtalkStatsLock.SpinLock);
		
			AtalkRtmpDereferenceRte(pRte, FALSE);				// Lock held?
		} while (FALSE);

		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumPktRoutedIn,
			&AtalkStatsLock.SpinLock);
	}
	else
	{
		error = AtalkDdpTransmit(pPortDesc,
								 &srcAddr,
								 pDestAddr,
								 Protocol,
								 pBuffDesc,
								 pOptHdr,
								 OptHdrLen,
								 0,					//	HopCnt,
								 pMcastAddr,
								 NULL,				//	pXmitDestNode,
								 pSendInfo);
	}

	return error;
}


//
//	DdpTransmit()
//	This function is called to build the headers for the packet and send it
//	out via the depend level functions. It is assumed at this point that the
//	packet is destined for nodes not currently controlled by this stack.
//
//	KnownMulticastAddress: Although the DDP destination is encoded using
//	'Destination', if this parameter is non-null, the packet is actually
//	sent to this address.
//
//	TransmitDestination: Again, as above, the router uses this to pass on the
//	packet to the next router it needs to go to, if 'Destination' is still one
//	or more hops away.
//
//	This is only called from within ddp send or by the router code (rtmp/zip/router).
//

ATALK_ERROR
AtalkDdpTransmit(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDestAddr,
	IN	BYTE						Protocol,
	IN	PBUFFER_DESC				pBuffDesc		OPTIONAL,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	USHORT						HopCnt,
	IN	PBYTE						pMcastAddr		OPTIONAL,	
	IN	PATALK_NODEADDR				pXmitDestNode	OPTIONAL,
	IN	PSEND_COMPL_INFO			pSendInfo		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE			pDgram, pDgramStart, pLinkDdpOptHdr;
	PBUFFER_DESC	pPktDesc;
	USHORT			linkLen;
	ATALK_NODEADDR	srcNode;
	ATALK_NODEADDR	destNode;
	USHORT			actualLength;
	ATALK_NODEADDR	actualDest;
	PBUFFER_DESC	probe;
	PBRE			routerNode;
	USHORT			bufLen				= 0;
	USHORT			checksum 			= 0;
	PBYTE			knownAddress 		= NULL;
	PBYTE			knownRouteInfo 		= NULL;
	USHORT	   		knownRouteInfoLen 	= 0;
	BOOLEAN			broadcast 			= FALSE;
	ATALK_ERROR		error 				= ATALK_NO_ERROR;
	BOOLEAN			shortDdpHeader		= FALSE;
	BOOLEAN			errorFreePkt		= FALSE;
    PARAPCONN       pArapConn           = NULL;
    PATCPCONN       pAtcpConn           = NULL;
    DWORD           StatusCode;
    DWORD           dwFlags;
    USHORT          SrpLen;
    PBYTE           pTmpPtr;
    NDIS_STATUS     status;
    BOOLEAN         fThisIsPPP;
    PVOID           pRasConn;


	//
	// The basic transmit algorithum is:
	//
	//	   if (non-extended-network)
	//	   {
	//			if ((destination-network is 0 or
	//				 destination-network is NetworkRange.firstNetwork) and
	//				(source-network is 0 or
	//				 source-network is NetworkRange.firstNetwork))
	//			{
	//				 <send short form DDP packet to local network>
	//				 return-okay
	//			}
	//	   }
	//	   if (destination-network is CableWideBroadcastNetworkNumber or
	//		   destination-network in NetworkRange or
	//		   destination-network in SartupRange or
	//	   {
	//			<send long form DDP packet to local network>
	//			return-okay
	//	   }
	//	   if (destination-network-and-node in best-router-cache)
	//	   {
	//			<send long form DDP packet to best router>
	//			return-okay
	//	   }
	//	   if (seen-a-router-recently)
	//	   {
	//			<send long form DDP packet to a-router>
	//			return-okay
	//	   }
	//	   return-error
	
	destNode.atn_Network = pDestAddr->ata_Network;
	destNode.atn_Node = pDestAddr->ata_Node;
	actualDest.atn_Network = UNKNOWN_NETWORK;
	actualDest.atn_Node = UNKNOWN_NODE;

	do
	{
		if (pBuffDesc != NULL)
		{
			//	Get the buffer length. Check the datagram length.
			AtalkSizeOfBuffDescData(pBuffDesc, &bufLen);
			ASSERT(bufLen > 0);
		}

#ifdef DDP_STRICT
		//	Check destination address
		if (INVALID_ADDRESS(pDestAddr) || INVALID_ADDRESS(pSrcAddr))
		{
			error = ATALK_DDP_INVALID_ADDR;
			break;
		}
	
		if (pBuffDesc != NULL)
		{
			//	Ensure we do not have a chained datagram.
			if (pBuffDesc->bd_Next != NULL)
			{
				KeBugCheck(0);
			}

			if (bufLen > MAX_DGRAM_SIZE)
			{
				error = ATALK_BUFFER_TOO_BIG;
				break;
			}
		}

		if (OptHdrLen > MAX_OPTHDR_LEN)
		{
			error = ATALK_BUFFER_TOO_BIG;
			break;
		}
#endif

        //
        // is the desination one of our dial-in clients?
        //
        pRasConn = FindAndRefRasConnByAddr(destNode, &dwFlags, &fThisIsPPP);

        if ((pRasConn == NULL) && (pPortDesc->pd_Flags & PD_RAS_PORT))
        {
			DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
					("AtalkDdpTransmit: pArapConn is NULL! Network, Node = %lx %lx\n",
					pDestAddr->ata_Network,pDestAddr->ata_Node));

			error = ATALK_FAILURE;
			break;
        }

        pArapConn = NULL;
        pAtcpConn = NULL;

        // if this is a dial-in client, see if it's PPP or ARAP
        if (pRasConn)
        {
            if (fThisIsPPP)
            {
                pAtcpConn = (PATCPCONN)pRasConn;

                // we can send only if the PPP connection is up
                if (!(dwFlags & ATCP_CONNECTION_UP))
                {
                    DerefPPPConn(pAtcpConn);
                    pAtcpConn = NULL;
                }
            }
            else
            {
                pArapConn = (PARAPCONN)pRasConn;
            }
        }

        //
        // if the destination is a dial-in client, we have more work to do
        //

        // PPP client?
        if (pAtcpConn != NULL)
        {
			//	the buffer that will hold both the link and ddp hdrs.
			shortDdpHeader	= FALSE;

			AtalkNdisAllocBuf(&pPktDesc);
			if (pPktDesc == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	In cases of error, free the allocated packet.
			errorFreePkt = TRUE;

			actualLength 		= bufLen + LDDP_HDR_LEN + OptHdrLen;
			pLinkDdpOptHdr		= pPktDesc->bd_CharBuffer;

            AtalkNdisBuildPPPPHdr(pLinkDdpOptHdr, pAtcpConn);
            linkLen = WAN_LINKHDR_LEN;

            break;
        }

        // nope, ARAP client?
        else if ( pArapConn != NULL )
        {
			shortDdpHeader	= FALSE;          // ARAP mandates always long form

			AtalkNdisAllocBuf(&pPktDesc);
			if (pPktDesc == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	In cases of error, free the allocated packet.
			errorFreePkt = TRUE;

			actualLength = bufLen + LDDP_HDR_LEN + OptHdrLen;
			pLinkDdpOptHdr = pTmpPtr = pPktDesc->bd_CharBuffer;

			linkLen	= ARAP_LAP_HDRSIZE + ARAP_HDRSIZE;

            // don't count the 2 length bytes
            SrpLen = actualLength + linkLen - sizeof(USHORT);

            //
            // put the 2 SRP bytes and the 1 byte DGroup flag (we have enough room)
            //
            PUTSHORT2SHORT(pTmpPtr, SrpLen);
            pTmpPtr += sizeof(USHORT);

            // the Dgroup byte
            *pTmpPtr++ = (ARAP_SFLAG_PKT_DATA | ARAP_SFLAG_LAST_GROUP);

            // the LAP hdr
            *pTmpPtr++ = 0;
            *pTmpPtr++ = 0;
            *pTmpPtr++ = 2;

            break;
        }

		//	For non-extended networks, we may want to send a short DDP header.
		if (!(EXT_NET(pPortDesc)) &&
			((pDestAddr->ata_Network == UNKNOWN_NETWORK) ||
			 (pDestAddr->ata_Network == pPortDesc->pd_NetworkRange.anr_FirstNetwork)) &&
			((pSrcAddr->ata_Network == UNKNOWN_NETWORK) ||
			 (pSrcAddr->ata_Network == pPortDesc->pd_NetworkRange.anr_FirstNetwork)))
		{
			//	Use a short ddp header. Call the port handler to first alloc
			//	the buffer that will hold both the link and ddp hdrs.
			shortDdpHeader	= TRUE;
			AtalkNdisAllocBuf(&pPktDesc);
			if (pPktDesc == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	In cases of error, free the allocated packet.
			errorFreePkt = TRUE;

			//	pPkt will be the beginning of the packet and pDgram is where
			//	we fill in the ddp header.
			actualLength 		= bufLen + SDDP_HDR_LEN + OptHdrLen;
			pLinkDdpOptHdr		= pPktDesc->bd_CharBuffer;
			linkLen				= 0;
		
			ASSERT (pPortDesc->pd_NdisPortType == NdisMediumLocalTalk);

			//	Build the LAP header. This will build it from pDgram backwards,
			//	and set the pPkt pointer as the packet to be freed in the
			//	built buffer descriptor.
			linkLen = AtalkNdisBuildLTHdr(pLinkDdpOptHdr,
										  &pDestAddr->ata_Node,
										  pSrcAddr->ata_Node,
										  ALAP_SDDP_HDR_TYPE);
	
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpTransmit: Sending short hdr on non-ext net! %ld\n",
					pDestAddr->ata_Node, pDestAddr->ata_Network));
			break;
		}

		//	LONG DDP HEADER
		// 	Compute the extended AppleTalk node number that we'll really need to
		//  send the packet to.

		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
				("AtalkDdpTransmit: Building a long ddp header for bufdesc %lx on port %lx\n",
				pBuffDesc, pPortDesc));

		do
		{
			if (pMcastAddr != NULL)
			{
				knownAddress = pMcastAddr ;
				break;
			}

			if (pXmitDestNode != NULL)
			{
				actualDest = *pXmitDestNode;
				break;
			}

			if ((WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
									  &pPortDesc->pd_NetworkRange))	 ||
				(pDestAddr->ata_Network == CABLEWIDE_BROADCAST_NETWORK) ||
				(WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
									  &AtalkStartupNetworkRange)))
			{
				actualDest.atn_Node = pDestAddr->ata_Node;
				actualDest.atn_Network = pDestAddr->ata_Network;
				broadcast = (pDestAddr->ata_Node == ATALK_BROADCAST_NODE);
				break;
			}

			atalkDdpFindInBrc(pPortDesc, destNode.atn_Network, &routerNode);
			if (routerNode != NULL)
			{
				// Okay, we know where to go.
				knownAddress 		= routerNode->bre_RouterAddr;
				knownRouteInfo 		= (PBYTE)routerNode + sizeof(BRE);
				knownRouteInfoLen 	= routerNode->bre_RouteInfoLen;
				break;
			}

			if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
			{
				actualDest = pPortDesc->pd_ARouter;
				break;
			}

			//	No router known. What do we do ? If its not an extended net,
			//  just send it - else return error.
			if (EXT_NET(pPortDesc))
			{
				error = ATALK_DDP_NO_ROUTER;
				break;
			}
			actualDest.atn_Node = pDestAddr->ata_Node;
			actualDest.atn_Network = pDestAddr->ata_Network;
			broadcast = (pDestAddr->ata_Node == ATALK_BROADCAST_NODE);
		} while (FALSE);

		if (error != ATALK_NO_ERROR)
		{
			break;
		}

		AtalkNdisAllocBuf(&pPktDesc);
		if (pPktDesc == NULL)
		{
			error = ATALK_FAILURE;
			break;
		}

		//	In cases of error, free the allocated packet.
		errorFreePkt = TRUE;

		pLinkDdpOptHdr		= pPktDesc->bd_CharBuffer;
		linkLen				= 0;
		actualLength 		= bufLen + LDDP_HDR_LEN + OptHdrLen;
	
		//	If we already know where we're headed, just blast it out.  Also,
		//	if we're broadcasting, just do it.  "knownAddress" will be NULL
		//	if we're broadcasting and that will cause the BuildHeader to make
		//	a broadcast packet.
		
		if (EXT_NET(pPortDesc) &&
			((knownAddress != NULL) ||
			  broadcast				||
			 (actualDest.atn_Network == CABLEWIDE_BROADCAST_NETWORK)))
		{
			//	Build the LAP header.
			AtalkNdisBuildHdr(pPortDesc,
							  pLinkDdpOptHdr,
							  linkLen,
							  actualLength,
							  knownAddress,
							  knownRouteInfo,
							  knownRouteInfoLen,
							  APPLETALK_PROTOCOL);
			break;
		}

		//	On non-extended networks, just send the packet to the desired node --
		//	no AARP games here.
		if (!EXT_NET(pPortDesc))
		{
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpTransmit: Sending long hdr on non-ext net! %ld\n",
					actualDest.atn_Network, actualDest.atn_Node));
			
			ASSERT (pPortDesc->pd_NdisPortType == NdisMediumLocalTalk);

			linkLen = AtalkNdisBuildLTHdr(pLinkDdpOptHdr,
										  &actualDest.atn_Node,
										  pSrcAddr->ata_Node,
										  ALAP_LDDP_HDR_TYPE);
			break;
		}
	
		//	We're sending to a particular node on an extended network.
		//	Do we know its hardware address ? If so, send it out.
		{
			KIRQL		OldIrql;
			USHORT		index;
			PAMT		pAmt;
		
			//	Go through the AMT and find the entry for the destination
			//	address if present.
			index = HASH_ATALK_NODE(&actualDest) % PORT_AMT_HASH_SIZE;
		
			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			
			for (pAmt = pPortDesc->pd_Amt[index];
				 pAmt != NULL;
				 pAmt = pAmt->amt_Next)
			{
				if (ATALK_NODES_EQUAL(&pAmt->amt_Target, &actualDest))
				{
					ASSERT(EXT_NET(pPortDesc));
					AtalkNdisBuildHdr(pPortDesc,
									  pLinkDdpOptHdr,
									  linkLen,
									  actualLength,
									  pAmt->amt_HardwareAddr,
									  (PBYTE)pAmt+sizeof(AMT),
									  pAmt->amt_RouteInfoLen,
									  APPLETALK_PROTOCOL);
					error = ATALK_NO_ERROR;
					break;
				}
			}
		
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

			if (pAmt == NULL)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
						("atalkDdpFindInAmt: Could not find %lx.%lx\n",
						actualDest.atn_Network, actualDest.atn_Node));
				error = ATALK_DDP_NO_AMT_ENTRY;
			}
			else break;				// Found the actual h/w address we want to go to.
		}

		//	Free up the allocated header buffer.
		errorFreePkt = TRUE;

		ASSERT(!ATALK_SUCCESS(error));

		//	We dont have the hardware address for the logical address that we
		//	need to send the packet to. Send out aarp requests and drop this packet.
		//	The higher layers can retry later if they have to.
		srcNode.atn_Network = pSrcAddr->ata_Network;
		srcNode.atn_Node	= pSrcAddr->ata_Node;

		probe = BUILD_AARPREQUEST(pPortDesc,
								  MAX_HW_ADDR_LEN,
								  srcNode,
								  actualDest);

		if (probe != NULL)
		{
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG(
				&pPortDesc->pd_PortStats.prtst_NumAarpProbesOut,
				&AtalkStatsLock.SpinLock);
#endif

			//	Send the aarp packet.
			error = AtalkNdisSendPacket(pPortDesc,
										probe,
										AtalkAarpSendComplete,
										NULL);
		
			if (!ATALK_SUCCESS(error))
			{
				TMPLOGERR()
				AtalkAarpSendComplete(NDIS_STATUS_FAILURE,
									  probe,
									  NULL);
			}
		}

		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
				("AMT Entry not found for %lx.%lx\n",
				pDestAddr->ata_Network, pDestAddr->ata_Node));

		error = ATALK_DDP_NO_AMT_ENTRY;
		break;

	} while (FALSE);

	//	Do we need to send the packet?
	if (ATALK_SUCCESS(error))
	{
		ASSERT(HopCnt <= RTMP_MAX_HOPS);

		//	Remember the beginning of the dgram
		pDgramStart = pDgram = pLinkDdpOptHdr + linkLen;

		if (!shortDdpHeader)
		{

			*pDgram++ = (DDP_HOP_COUNT(HopCnt) + DDP_MSB_LEN(actualLength));
		
			PUTSHORT2BYTE(pDgram, actualLength);
			pDgram++;
	
			ASSERT(checksum == 0);
			PUTSHORT2SHORT(pDgram, checksum);
			pDgram += sizeof(USHORT);
		
			PUTSHORT2SHORT(pDgram, pDestAddr->ata_Network);
			pDgram += sizeof(USHORT);
		
			PUTSHORT2SHORT(pDgram, pSrcAddr->ata_Network);
			pDgram += sizeof(USHORT);
		
			*pDgram++ = pDestAddr->ata_Node;
			*pDgram++ = pSrcAddr->ata_Node;
			*pDgram++ = pDestAddr->ata_Socket;
			*pDgram++ = pSrcAddr->ata_Socket;
			*pDgram++ = Protocol;
	
			//	Copy the optional header if present
			if (OptHdrLen > 0)
			{
				ASSERT(pOptHdr != NULL);
				RtlCopyMemory(pDgram, pOptHdr, OptHdrLen);
			}
	
			//	Set length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pPktDesc,
									   linkLen + LDDP_HDR_LEN + OptHdrLen);
		}
		else
		{
			*pDgram++ 	= DDP_MSB_LEN(actualLength);

			PUTSHORT2BYTE(pDgram, actualLength);
			pDgram++;
	
			*pDgram++ = pDestAddr->ata_Socket;
			*pDgram++ = pSrcAddr->ata_Socket;
			*pDgram++ = Protocol;
	
			//	Copy the optional header if present
			if (OptHdrLen > 0)
			{
				ASSERT(pOptHdr != NULL);
				RtlCopyMemory(pDgram, pOptHdr, OptHdrLen);
			}

			//	Set length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pPktDesc,
									   linkLen + SDDP_HDR_LEN + OptHdrLen);
		}

		//	Chain the passed in buffer desc onto the tail of the one
		//	returned above.
		AtalkPrependBuffDesc(pPktDesc, pBuffDesc);

		//	Okay, set checksum if needed.
		if (pPortDesc->pd_Flags & PD_SEND_CHECKSUMS)
		{
			// 	Temporary skip over the leading unchecksumed bytes.
			checksum = AtalkDdpCheckSumBufferDesc(pPktDesc,
												  (USHORT)(linkLen + LEADING_UNCHECKSUMED_BYTES));
									

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpTransmit: checksum %lx\n", checksum));

			PUTSHORT2SHORT(&pDgramStart[LDDP_CHECKSUM_OFFSET], checksum);
		}
		
		INTERLOCKED_ADD_STATISTICS(&pPortDesc->pd_PortStats.prtst_DataOut,
								   AtalkSizeBuffDesc(pPktDesc),
								   &AtalkStatsLock.SpinLock);

        //
        // is this packet going to an Arap client?  If so, we may need to compress,
        // and do other processing
        //
        if (pArapConn)
        {
            StatusCode =  ArapSendPrepare( pArapConn,
                                           pPktDesc,
                                           ARAP_SEND_PRIORITY_HIGH );

            if (StatusCode == ARAPERR_NO_ERROR)
            {
		        //	Send the packet(s)
                ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);

                status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                status = NDIS_STATUS_FAILURE;
            }

			AtalkDdpSendComplete(status, pPktDesc, pSendInfo);

			//	Return pending here
			error = ATALK_PENDING;
        }
        else
        {
            // PPP packets need to go over the RAS port
            if (pAtcpConn)
            {
                pPortDesc = RasPortDesc;
            }

		    //	Send the packet.  The completion routine will handle freeing
            // the buffer chain.
		    error = AtalkNdisSendPacket(pPortDesc,
			    						pPktDesc,
				    					AtalkDdpSendComplete,
					    				pSendInfo);
			
		    if (!ATALK_SUCCESS(error))
		    {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	                ("AtalkDdpTransmit: AtalkNdisSendPacket failed %ld\n",error));

			    AtalkDdpSendComplete(NDIS_STATUS_FAILURE,
				    				 pPktDesc,
					    			 pSendInfo);

			    //	Return pending. We've alredy called the completion
			    //	routine here, which will have called the callers
			    //	completion routine.
			    error = ATALK_PENDING;
		    }
        }
	}

    // Ras connection? remove the refcount put by FindAndRefRasConnByAddr
    if (pAtcpConn)
    {
        DerefPPPConn(pAtcpConn);
    }
    else if (pArapConn)
    {
        DerefArapConn(pArapConn);
    }

	//	Do we need to free the allocated header packet?
	if (!ATALK_SUCCESS(error) && (errorFreePkt))
	{
		AtalkNdisFreeBuf(pPktDesc);
	}

	return error;
}



VOID
AtalkDdpSendComplete(
	NDIS_STATUS				Status,
	PBUFFER_DESC			pBuffDesc,
	PSEND_COMPL_INFO		pInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Free up the buffer descriptor for the first part
	//	and call the specified completion. One of the contexts
	//	should be the remaining part of the buffer descriptor
	//	chain.

	//	There will always be atleast the ddp header, although the next
	//	part could be null. Thats upto the completion routine to care
	//	about.

	ASSERT(pBuffDesc != NULL);
	pBuffDesc->bd_Next = NULL;

	ASSERT(pBuffDesc->bd_Flags & BD_CHAR_BUFFER);
	AtalkNdisFreeBuf(pBuffDesc);

	//	If null, just return.
	if (pInfo != NULL)
	{
		//	Call the completion routine for the transmit if present
		if (pInfo->sc_TransmitCompletion)
			(pInfo->sc_TransmitCompletion)(Status, pInfo);
	}
}
	
VOID
AtalkDdpInvokeHandlerBufDesc(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PDDP_ADDROBJ		pDdpAddr,
	IN		PATALK_ADDR			pSrc,
	IN		PATALK_ADDR			pDest,
	IN		BYTE				Protocol,
	IN		PBUFFER_DESC		pBuffDesc		OPTIONAL,
	IN		PBYTE				pOptHdr			OPTIONAL,
	IN		USHORT				OptHdrLen		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			pktLen	= 0;
	PBYTE			pPkt	= NULL;
	BOOLEAN			freePkt = FALSE;

	//	This is only called from directly or indirectly throught
	//	the router in AtalkDdpSend. Both of these cases indicate
	//	that we have completion routines to deal with. We just make
	//	a copy and assume caller will deal with its buffer descriptor.


	//	Alloc and copy the buffer descriptor data into pPkt.
	//	optimization: If the buffer descriptor is not a chain
	//				  and contains a PBYTE and OptHdrLen = 0,
	//				  then pass that directly.
	//				  Or if buffer descriptor is NULL indicating 0-length
	//				  sends.

	do
	{
		if ((pBuffDesc != NULL) &&
			(pBuffDesc->bd_Next == NULL) &&
			(pBuffDesc->bd_Flags & BD_CHAR_BUFFER) &&
			(OptHdrLen == 0))
		{
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpInvokeHandlerBufDesc: one element, opt hdr null %ld\n",
					pBuffDesc->bd_Length));
	
			pPkt 	= pBuffDesc->bd_CharBuffer;
			pktLen 	= pBuffDesc->bd_Length;
		}
		else if ((pBuffDesc != NULL) || (OptHdrLen != 0))
		{
			//	Make a copy! Either the buffer descriptor of the Optional Header
			//	is non null. Or both or non-null.
			if (pBuffDesc != NULL)
			{
				AtalkSizeOfBuffDescData(pBuffDesc, &pktLen);
				ASSERT(pktLen > 0);
			}
	
			//	Add the optHdrLen
			pktLen += OptHdrLen;
	
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpInvokeHandlerBufDesc: Size (incl opt hdr len) %ld\n",
					pktLen));
	
			if ((pPkt = AtalkAllocMemory(pktLen)) != NULL)
			{
				//	First copy the OptHdr if present
				if (pOptHdr != NULL)
				{
					RtlCopyMemory(pPkt, pOptHdr, OptHdrLen);
				}

				if (pBuffDesc != NULL)
				{
					AtalkCopyBuffDescToBuffer(pBuffDesc,
											  0,						// SrcOff
											  pktLen - OptHdrLen,
											  pPkt + OptHdrLen);
				}

				freePkt = TRUE;
			}
			else
			{
				break;
			}
		}
		else
		{
			ASSERT((pBuffDesc == NULL) && (OptHdrLen == 0));
			ASSERT(pPkt == NULL);
			ASSERT(pktLen == 0);
		}
	
		AtalkDdpInvokeHandler(pPortDesc,
							  pDdpAddr,
							  pSrc,
							  pDest,
							  Protocol,
							  pPkt,
							  pktLen);

	} while (FALSE);

	if (freePkt)
	{
        AtalkFreeMemory(pPkt);
	}
}




VOID
AtalkDdpInvokeHandler(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PDDP_ADDROBJ		pDdpAddr,
	IN		PATALK_ADDR			pSrc,
	IN		PATALK_ADDR			pDest,
	IN		BYTE				Protocol,
	IN		PBYTE				pPkt		OPTIONAL,
	IN		USHORT				PktLen		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PLIST_ENTRY	p;
	PDDP_READ	pRead;
	NTSTATUS	status;
	ATALK_ERROR	error;
	ULONG		bytesCopied;
	BOOLEAN		eventDone = FALSE;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	The address object should be referenced, and we just assume
	//	it will be valid during the lifetime of this call.

	//	Check if protocol type is valid.
	if ((pDdpAddr->ddpao_Protocol != Protocol) &&
		(pDdpAddr->ddpao_Protocol != DDPPROTO_ANY))
	{
		return;
	}

	//	First check for queued ddp reads
	ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	if (!IsListEmpty(&pDdpAddr->ddpao_ReadLinkage))
	{
		p = RemoveHeadList(&pDdpAddr->ddpao_ReadLinkage);
		RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);

		error	= ATALK_NO_ERROR;
		pRead 	= CONTAINING_RECORD(p, DDP_READ, dr_Linkage);

		//	Do copy if > 0 bytes
		if (PktLen > 0)
		{
			if (PktLen > pRead->dr_OpBufLen)
			{
				error 	= ATALK_BUFFER_TOO_SMALL;
			}

			PktLen 	= MIN(PktLen, pRead->dr_OpBufLen);
			status = TdiCopyBufferToMdl(pPkt,
										0,
										PktLen,
										GET_MDL_FROM_OPAQUE(pRead->dr_OpBuf),
										0,
										&bytesCopied);

			ASSERT(status == STATUS_SUCCESS);
		}


		(*pRead->dr_RcvCmp)(error, pRead->dr_OpBuf, PktLen, pSrc, pRead->dr_RcvCtx);

		AtalkFreeMemory(pRead);
		return;
	}

	//	If a handler was set on this socket,call it.
	else if (pDdpAddr->ddpao_Handler != NULL)
	{
		RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
		(*pDdpAddr->ddpao_Handler)(pPortDesc,
								   pDdpAddr,
								   pPkt,
								   PktLen,
								   pSrc,
								   pDest,
								   ATALK_NO_ERROR,
								   Protocol,
								   pDdpAddr->ddpao_HandlerCtx,
								   FALSE,
								   NULL);
	}
	else
	{
		//	if there is an event handler on this address object call it.
		//	If there is already a buffered datagram, drop this packet.
		//	If not, save this datagram as the buffered one, and then
		//	indicate,

		if (pDdpAddr->ddpao_Flags & DDPAO_DGRAM_EVENT)
		{
			do
			{
				//	We have datagram event handler set on this AO.
				if (pDdpAddr->ddpao_Flags & (DDPAO_DGRAM_ACTIVE |
											 DDPAO_DGRAM_PENDING))
				{
					//	We are already indicating an event. Or we
					//	have a buffered datagram. Drop this pkt.
					break;
				}
				else
				{
					PTDI_IND_RECEIVE_DATAGRAM 	RcvHandler;
					PVOID 						RcvCtx;
					ULONG						bytesTaken;
					PIRP						rcvDgramIrp;
					TA_APPLETALK_ADDRESS		srcTdiAddr;
					NTSTATUS					status;
				
					ASSERT(pDdpAddr->ddpao_EventInfo != NULL);

					pDdpAddr->ddpao_Flags |= (DDPAO_DGRAM_ACTIVE	|
											  DDPAO_DGRAM_PENDING);

					RcvHandler = pDdpAddr->ddpao_EventInfo->ev_RcvDgramHandler;
					RcvCtx	 = pDdpAddr->ddpao_EventInfo->ev_RcvDgramCtx;

					ATALKADDR_TO_TDI(&srcTdiAddr, pSrc);

					//	Save the dgram in the event info.
					RtlCopyMemory(pDdpAddr->ddpao_EventInfo->ev_IndDgram, pPkt, PktLen);

					pDdpAddr->ddpao_EventInfo->ev_IndDgramLen 	= PktLen;
					pDdpAddr->ddpao_EventInfo->ev_IndSrc 		= *pSrc;
					pDdpAddr->ddpao_EventInfo->ev_IndProto 		= Protocol;
					RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);

					status = (*RcvHandler)(RcvCtx,
										   sizeof(TA_APPLETALK_ADDRESS),
										   &srcTdiAddr,
										   0,					  	// Options length
										   NULL,				   	// Options
										   0,						// Datagram flags
										   (ULONG)PktLen,  		// Bytes indicated
										   (ULONG)PktLen,  		// Bytes available
										   (ULONG *)&bytesTaken,
										   pPkt,
										   &rcvDgramIrp);
		
					ASSERT((bytesTaken == 0) || (bytesTaken == PktLen));
		
					if (status == STATUS_MORE_PROCESSING_REQUIRED)
					{
						if (rcvDgramIrp != NULL)
						{
							//  Post the receive as if it came from the io system
							status= AtalkDispatchInternalDeviceControl(
									(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_DDP],
									 rcvDgramIrp);
			
							ASSERT(status == STATUS_PENDING);
						}
					}	
					else if (status == STATUS_SUCCESS)
					{
						if (bytesTaken != 0)
						{
							//	Assume all of the data was read.
							pDdpAddr->ddpao_Flags &= ~DDPAO_DGRAM_PENDING;
						}
					}
					else if (status == STATUS_DATA_NOT_ACCEPTED)
					{
						//	Client may have posted a receive in the indication. Or
						//	it will post a receive later on. Do nothing here.
						DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
								("atalkDdpRecvData: Indication status %lx\n", status));
					}

					ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
				}

			} while (FALSE);

			//	reset the event flags
			pDdpAddr->ddpao_Flags &= ~DDPAO_DGRAM_ACTIVE;
		}
		RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	}
}




VOID
AtalkDdpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PBYTE				pLinkHdr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
    IN  BOOLEAN             fWanPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			dgramLen, ddpHdrLen;
	USHORT			hopCnt, checksum;
	BYTE			Protocol;
	ATALK_ADDR		destAddr, srcAddr;
	PBYTE			pDdpHdr;

	//	Only for localtalk
	BYTE			alapSrcNode;
	BYTE			alapDestNode;

    PBUFFER_DESC    pBufCopy = NULL;
    SEND_COMPL_INFO SendInfo;
	PBYTE			pOrgPkt;
	USHORT			srcOffset;
	BOOLEAN			extHdr	  = TRUE;
	PBYTE			pRouteInfo;
	USHORT			routeLen  = 0;
	BOOLEAN			delivered = FALSE;
	BOOLEAN			broadcast = FALSE;
	BOOLEAN			shouldBeRouted = FALSE;
    BOOLEAN         sendOnDefAdptr = FALSE;
	ATALK_ERROR		error = ATALK_NO_ERROR;
    KIRQL           OldIrql;
	TIME			TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);

	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return;
	}

    // save the packet starting
    pOrgPkt = pPkt;

	do
	{
		ASSERT((PktLen > 0) || ((PktLen == 0) && (pPkt == NULL)));

		if (PktLen > (MAX_DGRAM_SIZE + LDDP_HDR_LEN))
		{
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
					("AtalkDdpPacketIn: Invalid size %lx\n", PktLen));
			error = ATALK_DDP_INVALID_LEN;
			break;
		}

		//	Get to the ddp header
		pDdpHdr		= pPkt;

		//	Short and long header formats have the length in the same place,
		dgramLen = DDP_GET_LEN(pDdpHdr);
		hopCnt   = DDP_GET_HOP_COUNT(pDdpHdr);

		//	Is the packet too long?
		if ((hopCnt > RTMP_MAX_HOPS) || (dgramLen > PktLen))
		{
			error = ATALK_DDP_INVALID_LEN;
			break;
		}

		//	First glean the information. Check for route info if
		//	tokenring network.
		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_5:
	
			if (pLinkHdr[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
			{
				routeLen = (pLinkHdr[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);

				//  First, glean any AARP information that we can, then handle the DDP
				//  packet.  This guy also makes sure we have a good 802.2 header...
				//
				//  Need to make a localcopy of the source address and then turn
				//  the source routing bit off before calling GleanAarpInfo
				//
			
				pLinkHdr[TLAP_SRC_OFFSET] &= ~TLAP_SRC_ROUTING_MASK;
				pRouteInfo = pLinkHdr + TLAP_ROUTE_INFO_OFFSET;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			srcOffset = TLAP_SRC_OFFSET;
			break;
	
		  case NdisMedium802_3:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > MAX_DGRAM_SIZE + LDDP_HDR_LEN))
			{
				error = ATALK_DDP_INVALID_LEN;
				break;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			srcOffset	 = ELAP_SRC_OFFSET;
			break;
	
		  case NdisMediumFddi:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > MAX_DGRAM_SIZE + LDDP_HDR_LEN))
			{
				error = ATALK_DDP_INVALID_LEN;
				break;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			srcOffset	 = FDDI_SRC_OFFSET;
			break;
	
		  case NdisMediumLocalTalk:
	
			//	Do we have an extended header?
			extHdr = (BOOLEAN)(pLinkHdr[ALAP_TYPE_OFFSET] == ALAP_LDDP_HDR_TYPE);

			if (extHdr)
			{
				ddpHdrLen	 = LDDP_HDR_LEN;
			}
			else
			{
				alapDestNode 	= *(pLinkHdr + ALAP_DEST_OFFSET);
				alapSrcNode 	= *(pLinkHdr + ALAP_SRC_OFFSET);

				if ((dgramLen < SDDP_HDR_LEN) ||
					(dgramLen > (MAX_DGRAM_SIZE + SDDP_HDR_LEN)))
				{
					error = ATALK_DDP_INVALID_LEN;
					break;
				}
	
				ddpHdrLen	 = SDDP_HDR_LEN;
			}

			break;
	
		  case NdisMediumWan:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > MAX_DGRAM_SIZE + LDDP_HDR_LEN))
			{
				error = ATALK_DDP_INVALID_LEN;
				break;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			extHdr = TRUE;           // always extended for ARAP

			break;
	
		  default:
			//  Should never happen!
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_FATAL,
					("AtalkDdpPacketIn: Unknown media\n"));

			KeBugCheck(0);
			break;
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		//	Advance packet to point to the data. Caller frees up packet.
		pPkt += ddpHdrLen;

		//	Glean aarp information for non-localtalk and non-RAS ports
		if ((pPortDesc->pd_NdisPortType != NdisMediumLocalTalk) && !fWanPkt)
		{
			AtalkAarpGleanInfo(pPortDesc,
							   pLinkHdr + srcOffset,
							   TLAP_ADDR_LEN,
							   pRouteInfo,
							   (USHORT)routeLen,
							   pDdpHdr,
							   (USHORT)ddpHdrLen);
		}

		pDdpHdr += 2;	// Past off-cable & len
	
		if (extHdr)		//	Long DDP header
		{
			//	Get checksum, verification, if needed.
			GETSHORT2SHORT(&checksum, pDdpHdr);
			pDdpHdr += 2;

			if (checksum != 0)
			{
				USHORT	calcCheckSum;

				//	pDdpHdr has already moved passed LEADING_UNCHECKSUMED_BYTES.
				//	So we just need to decrease the header length field. Use
				//	dgramLen, NOT PktLen!
				calcCheckSum = AtalkDdpCheckSumPacket(pDdpHdr,
													  (USHORT)(ddpHdrLen - LEADING_UNCHECKSUMED_BYTES),
													  pPkt,
													  (USHORT)(dgramLen - ddpHdrLen));
				if (checksum != calcCheckSum)
				{
					DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
							("AtalkDdpPacketIn: Checksums dont match! %lx.%lx\n",
							checksum, calcCheckSum));

					AtalkLogBadPacket(pPortDesc,
									  &srcAddr,
									  &destAddr,
									  pDdpHdr,
									  (USHORT)(ddpHdrLen - LEADING_UNCHECKSUMED_BYTES));

					error = ATALK_DDP_PKT_DROPPED;
					break;
				}
			}
			

			//	Build full source and destination AppleTalk address structures
			//	from our DDP header.
			GETSHORT2SHORT(&destAddr.ata_Network, pDdpHdr);
			pDdpHdr += 2;

			GETSHORT2SHORT(&srcAddr.ata_Network, pDdpHdr);
			pDdpHdr += 2;

			destAddr.ata_Node 	= *pDdpHdr++;
			srcAddr.ata_Node 	= *pDdpHdr++;

			destAddr.ata_Socket	= *pDdpHdr++;
			srcAddr.ata_Socket 	= *pDdpHdr++;

			//	Get the protocol type.
			Protocol 			= *pDdpHdr;

			broadcast = (destAddr.ata_Node == ATALK_BROADCAST_NODE);
			
			//	Do we like what we see?  Note "nnnn00" is now allowed and used by
			//	NBP.
			
			if ((srcAddr.ata_Network > LAST_VALID_NETWORK) ||
				(srcAddr.ata_Network < FIRST_VALID_NETWORK) ||
				(srcAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE))
			{
				error = ATALK_DDP_INVALID_SRC;
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
					("DdpPacketIn: Received pkt with bad src addr %lx.%lx\n",
                        srcAddr.ata_Network,srcAddr.ata_Node));
				break;
			}

			if ((destAddr.ata_Network > LAST_VALID_NETWORK) ||
				((destAddr.ata_Node > MAX_USABLE_ATALKNODE) &&
				  !broadcast))
			{
				error = ATALK_DDP_INVALID_DEST;
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
					("DdpPacketIn: Received pkt with bad src addr %lx.%lx\n",
                        destAddr.ata_Network,destAddr.ata_Node));
				break;
			}

			//	Loop through all nodes that are on the reception port and see if
			//	anybody wants this packet.  The algorithm is from the "AppleTalk
			//	Phase 2 Protocol Specification" with enhacements to support ports
			//	that have multiple nodes.
			
			//	"0000xx" (where "xx" isnt "FF") should not be accepted on an
			//	extended port... For some unknown reason, the spec would like
			//	us to pass this case onto the router (which will, no doubt,
			//	drop it on the floor because it won't find network zero in its
			//	routing table)... you know, bug-for-bug compatible!
			if ((destAddr.ata_Network == UNKNOWN_NETWORK) &&
				(pPortDesc->pd_Flags & PD_EXT_NET) &&
				(!broadcast))
			{
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
						("DdpPacketIn: Received pkt with net/node %lx.%lx on ext\n",
						destAddr.ata_Network, destAddr.ata_Node));

				shouldBeRouted = TRUE;
			}
			else
			{
                //
                // if we have RAS port configured, and currently have dial-in
                // client(s) connected then see if any (or all) of them are
                // interested in this packet
                // Make sure that any broadcasts we forward came on default port
                //
                if ( (RasPortDesc) &&
                     ((!broadcast) ||
                      (broadcast && (pPortDesc == AtalkDefaultPort))) )
                {

                    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

                    if (!IsListEmpty(&RasPortDesc->pd_PPPConnHead))
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                        // see if any PPP client(s) are interested
                        PPPRoutePacketToWan(
                                &destAddr,
                                &srcAddr,
    						    Protocol,
                                pPkt,                             // only data, no DDP hdr
                                (USHORT)(dgramLen - ddpHdrLen),   // only data length
                                hopCnt,
                                broadcast,
                                &delivered);
                        //
                        // if we delivered it to any of the PPP clients, and
                        // this was not a broadcast, then we 're done here
                        //
                        if (delivered && !broadcast)
                        {
                            break;
                        }

                    }
                    else
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
                    }

                    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

                    if (!IsListEmpty(&RasPortDesc->pd_ArapConnHead))
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                        // see if any ARAP client(s) are interested
                        ArapRoutePacketToWan(
                                &destAddr,
                                &srcAddr,
			    			    Protocol,
                                pOrgPkt,                // whole packet (with DDP hdr)
                                dgramLen,               // whole packet length
                                broadcast,
                                &delivered);

                        //
                        // if we delivered it to any of the ARAP clients, and
                        // this was not a broadcast, then we 're done here
                        //
                        if (delivered && !broadcast)
                        {
                            break;
                        }
                    }
                    else
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
                    }
                }

				//	Now, on the packet in path, we either deliver the packet
				//	to one of our nodes on this port, or we pass it on to the
				//	router. Even if the packet is a broadcast, the delivered
				//	flag will be set to true. shouldBeRouter will be set to
				//	true, only if the packet *DOES NOT* seem to be destined for
				//	this port. We route the packet *ONLY IF* shouldBeRouter
				//	is true
				AtalkDdpInPktToNodesOnPort(pPortDesc,
										   &destAddr,
										   &srcAddr,
										   Protocol,
										   pPkt,
										   (USHORT)(dgramLen - LDDP_HDR_LEN),
										   &shouldBeRouted);
			}

            //
            // if this packet originated from a dial-in client and the packet wasn't
            // claimed by any of our nodes then we need to send it over to the LAN net:
            // see if we must
            //
            if (fWanPkt)
            {
                sendOnDefAdptr = FALSE;

                //
                // broadcasts are meant for the local net, so default adapter only
                //
	            if (broadcast)
	            {
                    sendOnDefAdptr = TRUE;
                }

                //
                // if destination is on the same net as the default adapter, or
                // if the router is not running then send it on the default adapter
                //
	            if (shouldBeRouted)
                {
                    if ((WITHIN_NETWORK_RANGE(destAddr.ata_Network,
                                    &pPortDesc->pd_NetworkRange)) ||
                        (!(pPortDesc->pd_Flags & PD_ROUTER_RUNNING)))
                    {
                        sendOnDefAdptr = TRUE;
                    }
                }

                //
                // ok, we must send it on the default adapter.
                //
                if (sendOnDefAdptr)
                {
                    // no need to send this packet to router: we're sending here
                    shouldBeRouted = FALSE;

    			    pBufCopy = AtalkAllocBuffDesc(
                                    NULL,
                                    (USHORT)(dgramLen - LDDP_HDR_LEN),
                                    (BD_FREE_BUFFER | BD_CHAR_BUFFER));

                    if (pBufCopy == NULL)
				    {
    				    error = ATALK_RESR_MEM;
				        break;
				    }

    			    AtalkCopyBufferToBuffDesc(pPkt,
                                            (USHORT)(dgramLen - LDDP_HDR_LEN),
                                            pBufCopy,
                                            0);

                    SendInfo.sc_TransmitCompletion = atalkDdpRouteComplete;
		            SendInfo.sc_Ctx1 = pPortDesc;
		            SendInfo.sc_Ctx3 = NULL;
				    SendInfo.sc_Ctx2 = pBufCopy;

    			    error = AtalkDdpTransmit(pPortDesc,
				    					    &srcAddr,
					    				    &destAddr,
						    			    Protocol,
							    		    pBufCopy,
								    	    NULL,
									        0,
    									    0,
	    								    NULL,
		    							    NULL,
			    						    &SendInfo);

                    if (error != ATALK_PENDING)
                    {
                        AtalkFreeBuffDesc(pBufCopy);
                        break;
                    }
	            }
            }

            //
			//	if we still haven't been able to deliver the packet, and if we
            //  have routing enabled, give router a crack at it
            //
            if (shouldBeRouted && pPortDesc->pd_Flags & PD_ROUTER_RUNNING)
			{
			    AtalkDdpRouteInPkt(pPortDesc,
				    			   &srcAddr,
					    		   &destAddr,
						    	   Protocol,
							       pPkt,
        						   (USHORT)(dgramLen - LDDP_HDR_LEN),
		    					   hopCnt);
			}
		}
		else		//	Short DDP header!
		{
			BYTE	ThisNode;

			ASSERT(!EXT_NET(pPortDesc));

			if (pPortDesc->pd_Flags & PD_EXT_NET)
			{
				error = ATALK_DDP_SHORT_HDR;
				break;
			}

			//	Use network number for the node on this port for source/destination
			//	network numbers. When we search for the socket/address
			//	object, the concept net = 0, matches anything will come
			//	into play.

			srcAddr.ata_Network = destAddr.ata_Network = NET_ON_NONEXTPORT(pPortDesc);
			srcAddr.ata_Node 	= alapSrcNode;

			ThisNode = NODE_ON_NONEXTPORT(pPortDesc);
			if (alapDestNode == ATALK_BROADCAST_NODE)
			{
				destAddr.ata_Node = ThisNode;
			}
			else if (alapDestNode != ThisNode)
			{
				error = ATALK_DDP_INVALID_DEST;
				break;
			}
			else
			{
				destAddr.ata_Node  	= alapDestNode;
			}

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
					("AtalkDdpPacketIn: NonExtended Dest Net.Node %lx.%lx\n",
					destAddr.ata_Network, destAddr.ata_Node));

			//	Get the socket numbers from the ddp header.
			destAddr.ata_Socket = *pDdpHdr++;
			srcAddr.ata_Socket	= *pDdpHdr++;

			//	Get the protocol type
			Protocol 			= *pDdpHdr;

			//	If the protocol type is 0, we have an error.
			if (Protocol == 0)
			{
				error = ATALK_DDP_INVALID_PROTO;
				break;
			}

			//	Now the destination node address could be
			//	ALAP_BROADCAST_NODE (0xFF).
			if ((srcAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE))
			{
				error = ATALK_DDP_INVALID_SRC;
				break;
			}

			if (((destAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				 (destAddr.ata_Node > MAX_USABLE_ATALKNODE)) &&
				(destAddr.ata_Node != ATALK_BROADCAST_NODE))
			{
				error = ATALK_DDP_INVALID_DEST;
				break;
			}

			//	On a non-extended port, there will be only one node.
			AtalkDdpInPktToNodesOnPort(pPortDesc,
									   &destAddr,
									   &srcAddr,
									   Protocol,
									   pPkt,
									   (USHORT)(dgramLen - SDDP_HDR_LEN),
									   &shouldBeRouted);		// This is a dud parameter
																// for non-ext nets
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
				("AtalkDdpPacketIn: Dropping packet %lx\n", error) );
	}

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_DdpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumDdpPacketsIn,
		&AtalkStatsLock.SpinLock);
}



VOID
AtalkDdpQuery(
	IN	PDDP_ADDROBJ	pDdpAddr,
	IN	PAMDL			pAmdl,
	OUT	PULONG			BytesWritten
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	TDI_ADDRESS_INFO		tdiInfo;
	PTA_APPLETALK_ADDRESS	pTaAddr;

	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	pTaAddr	= (PTA_APPLETALK_ADDRESS)&tdiInfo.Address;
	ATALKADDR_TO_TDI(pTaAddr, &pDdpAddr->ddpao_Addr);
	TdiCopyBufferToMdl ((PBYTE)&tdiInfo,
						0L,
						sizeof(tdiInfo),
						pAmdl,
						0,
						BytesWritten);
}




VOID
AtalkDdpOutBufToNodesOnPort(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pSrc,
	IN	PATALK_ADDR			pDest,
	IN	BYTE				Protocol,
	IN	PBUFFER_DESC		pBuffDesc		OPTIONAL,
	IN	PBYTE				pOptHdr			OPTIONAL,
	IN	USHORT				OptHdrLen		OPTIONAL,
	OUT	PBOOLEAN			Delivered
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PATALK_NODE		pAtalkNode, pNextNode;
	PDDP_ADDROBJ	pDdpAddr;
	BOOLEAN			fDeliver, fSpecific, needToRef;
	BOOLEAN			lockHeld = FALSE;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	Do not internally loopback broadcast frames, these should come
	//	back to us from the mac.
	if (pDest->ata_Node == ATALK_BROADCAST_NODE)
	{
		*Delivered = FALSE;
		return;
	}

	fSpecific	= (pDest->ata_Network != CABLEWIDE_BROADCAST_NETWORK);

	//	Walk through our nodes to see if we can deliver this packet.
	//	OPTIMIZATIONS:
	//	In most cases, this will not be true. Optimize for returning false.
	//	Also, a node closing is a rare occurence. If we run into one that is
	//	closing, we abort trying to deliver this packet to a node on our port,
	//	and instead return delivered = FALSE. DDP - unreliable, and node closing
	//	should be a transient state. We avoid the acquire/release code.
	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	lockHeld	= TRUE;

	pNextNode	= pPortDesc->pd_Nodes;
	needToRef	= TRUE;
	for (; (pAtalkNode = pNextNode) != NULL; )
	{
		fDeliver	= FALSE;
		error		= ATALK_NO_ERROR;

		if (((pAtalkNode->an_NodeAddr.atn_Network == pDest->ata_Network) ||
			 !fSpecific) &&
			(pAtalkNode->an_NodeAddr.atn_Node == pDest->ata_Node))
		{
			//	Reference node. If we fail, we abort.
			if (needToRef)
			{
				AtalkNodeRefByPtr(pAtalkNode, &error);
			}

			if (ATALK_SUCCESS(error))
			{
				fDeliver	= TRUE;

				//	Set up for next node.
				if (fSpecific)
				{
					pNextNode	= NULL;
				}
				else
				{
					//	Get next eligible node.
					pNextNode	= pAtalkNode->an_Next;
					while (pNextNode != NULL)
					{
						if (pNextNode->an_NodeAddr.atn_Node == pDest->ata_Node)
						{
							AtalkNodeRefByPtr(pNextNode, &error);
							if (!ATALK_SUCCESS(error))
							{
								pNextNode	= NULL;
							}

							needToRef	= FALSE;
							break;
						}
						else
						{
							pNextNode	= pNextNode->an_Next;
						}
					}
				}
			}
			else
			{
				//	Break out of the for loop.
				break;
			}
		}
		else
		{
			pNextNode	= pAtalkNode->an_Next;
			needToRef	= TRUE;
		}

		if (fDeliver)
		{
			//	Release port lock, deliver packet, and Deref the node.
			//	Find the ddp address object on this node corresponding
			//	to this address. This will get the node lock.
			AtalkDdpRefByAddrNode(pPortDesc,
								  pDest,
								  pAtalkNode,
								  &pDdpAddr,
								  &error);

			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= FALSE;

			if (ATALK_SUCCESS(error))
			{
				//	Invoke socket handler on this address object.
				AtalkDdpInvokeHandlerBufDesc(pPortDesc,
											 pDdpAddr,
											 pSrc,
											 pDest,
											 Protocol,
											 pBuffDesc,
											 pOptHdr,
											 OptHdrLen);
	
				//	Remove the reference on the socket
				AtalkDdpDereferenceDpc(pDdpAddr);
			}

			//	Remove the reference on the node
			AtalkNodeDereference(pAtalkNode);

			//	If we had to deliver to a specific node, we are done.
			if (fSpecific)
			{
				break;
			}

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= TRUE;
		}
	}

	if (lockHeld)
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}

	*Delivered = (fSpecific && fDeliver);
}




VOID
AtalkDdpInPktToNodesOnPort(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pDest,
	IN	PATALK_ADDR			pSrc,
	IN	BYTE				Protocol,
	IN	PBYTE				pPkt			OPTIONAL,
	IN	USHORT				PktLen			OPTIONAL,
	OUT	PBOOLEAN			ShouldBeRouted
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pAtalkNode, pNextNode;
	PDDP_ADDROBJ	pDdpAddr;
	BOOLEAN			broadcast;
	BOOLEAN			fSpecific, fDeliver, needToRef;
	ATALK_ERROR		error			= ATALK_NO_ERROR;
	BOOLEAN			lockHeld 		= FALSE;
	BOOLEAN			shouldBeRouted  = FALSE;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	broadcast = (pDest->ata_Node == ATALK_BROADCAST_NODE);

	//	is a directed packet to a socket on a particular node...?
	fSpecific = (!broadcast &&
					(pDest->ata_Network != UNKNOWN_NETWORK));

	//	OPTIMIZATIONS:
	//	In most cases, this will not be true. Optimize for returning false.
	//	Also, a node closing is a rare occurence. If we run into one that is
	//	closing, we abort trying to deliver this packet to a node on our port,
	//	and instead return delivered = FALSE. DDP - unreliable, and node closing
	//	should be a transient state. We avoid the acquire/release code.
	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	lockHeld	= TRUE;

	pNextNode	= pPortDesc->pd_Nodes;
	needToRef	= TRUE;
	while ((pAtalkNode = pNextNode) != NULL)
	{
		fDeliver	= FALSE;
		error		= ATALK_NO_ERROR;

		//	For incoming packet, we check to see if the destination
		//	net is 0, or destination net is our node's net, or we are
		//	non-extended and our node's net is zero. i.e. is the packet
		//	destined for a node on this port. If not, route it. Continue
		//	checking all nodes though, as a single port can have nodes with
		//	different network numbers.

		if (((pAtalkNode->an_NodeAddr.atn_Network == pDest->ata_Network) 	||
			 (pDest->ata_Network == UNKNOWN_NETWORK)						||
			 (!EXT_NET(pPortDesc) &&
			  (pAtalkNode->an_NodeAddr.atn_Network == UNKNOWN_NETWORK)))	&&
			(broadcast || (pAtalkNode->an_NodeAddr.atn_Node == pDest->ata_Node)))
		{
			//	Reference node if we need to. Only happens for the first
			//	time we enter the loop. If we fail, we  abort.
			if (needToRef)
			{
				AtalkNodeRefByPtr(pAtalkNode, &error);
				if (!ATALK_SUCCESS(error))
				{
					break;
				}
			}

			fDeliver	= TRUE;

			//	Set up for next node.
			if (fSpecific)
			{
				//	Only one node on a non-extended port. So set next to NULL.
				pNextNode	= NULL;
			}
			else
			{
				//	Get next eligible node.
				pNextNode	= pAtalkNode->an_Next;
				while (pNextNode != NULL)
				{
					if (((pNextNode->an_NodeAddr.atn_Network == pDest->ata_Network) ||
						(pDest->ata_Network == UNKNOWN_NETWORK)						||
						(!EXT_NET(pPortDesc) &&
						 (pNextNode->an_NodeAddr.atn_Network == UNKNOWN_NETWORK)))	&&
						(broadcast ||
						 (pNextNode->an_NodeAddr.atn_Node == pDest->ata_Node)))
					{
						AtalkNodeRefByPtr(pNextNode, &error);
						if (!ATALK_SUCCESS(error))
						{
							pNextNode	= NULL;
						}
	
						needToRef	= FALSE;
						break;
					}

					pNextNode	= pNextNode->an_Next;
				}
			}
		}
		else
		{
			//	The packet probably could be meant to be routed.
			//	This could be set multiple times - idempotent.
			shouldBeRouted 	= TRUE;
			needToRef		= TRUE;
			pNextNode		= pAtalkNode->an_Next;
		}

		if (fDeliver)
		{
			//	Release port lock, deliver packet, and Deref the node.
			//	Find the ddp address object on this node corresponding
			//	to this address. This will get the node lock.
			if (broadcast)
				pDest->ata_Node = pAtalkNode->an_NodeAddr.atn_Node;
		
			AtalkDdpRefByAddrNode(pPortDesc,
								  pDest,
								  pAtalkNode,
								  &pDdpAddr,
								  &error);

			//	If we had changed the destination node, change it back.		
			if (broadcast)
				pDest->ata_Node = ATALK_BROADCAST_NODE;

			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= FALSE;

			if (ATALK_SUCCESS(error))
			{
				//	Invoke socket handler on this address object.
				//	Use the packet pointer directly!

				AtalkDdpInvokeHandler(pPortDesc,
									  pDdpAddr,
									  pSrc,
									  pDest,
									  Protocol,
									  pPkt,
									  PktLen);
	
				//	Remove the reference on the socket
				AtalkDdpDereferenceDpc(pDdpAddr);
			}

			//	Remove the reference on the node
			AtalkNodeDereference(pAtalkNode);

			//	If we had to deliver to a specific node, we are done.
			if (fSpecific)
			{
				shouldBeRouted = FALSE;
				break;
			}

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= TRUE;
		}
	}

	if (lockHeld)
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}

	*ShouldBeRouted = shouldBeRouted;
}




USHORT
AtalkDdpCheckSumBuffer(
	IN	PBYTE	Buffer,
	IN	USHORT	BufLen,
	IN	USHORT	CurrentCheckSum
	)
/*++

Routine Description:

	Calculate the DDP checksum of a byte array

Arguments:


Return Value:


--*/
{
	USHORT	CheckSum = CurrentCheckSum;
	ULONG	i;

	// The following algorithm is from Inside AppleTalk, Second Edition
	// page 4-17
	for (i = 0; i < BufLen; i++)
	{
		CheckSum += Buffer[i];
		if (CheckSum & 0x8000)	// 16-bit rotate left one bit
		{
			CheckSum <<= 1;
			CheckSum ++;
		}
		else CheckSum <<= 1;
	}
	if (CheckSum == 0)
		CheckSum = 0xFFFF;

	return CheckSum;
}




USHORT
AtalkDdpCheckSumPacket(
	IN	PBYTE	pHdr,
	IN	USHORT	HdrLen,
	IN	PBYTE	pPkt,
	IN	USHORT	PktLen
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT	checksum = 0;

	//	MAX_LDDP_PKT_SIZE is 600, so we use < instead of <=

	ASSERT(HdrLen + PktLen < MAX_LDDP_PKT_SIZE);
	if ((HdrLen + PktLen) < MAX_LDDP_PKT_SIZE)
	{
		if (HdrLen > 0)
		{
			checksum = AtalkDdpCheckSumBuffer(pHdr, HdrLen, 0);
		}

		if (PktLen > 0)
		{
			checksum = AtalkDdpCheckSumBuffer(pPkt, PktLen, checksum);
		}
	}

	return checksum;
}


// Calculate the DDP checksum of the passed in buffer. The buffer is described
// by the buffer descriptor
USHORT
AtalkDdpCheckSumBufferDesc(
	IN	PBUFFER_DESC	pBuffDesc,
	IN	USHORT			Offset
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE	pBuf;
	USHORT	checksum = 0;

	while (pBuffDesc != NULL)
	{
		if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
		{
			pBuf = pBuffDesc->bd_CharBuffer;
		}
		else
		{
			pBuf = MmGetSystemAddressForMdlSafe(
					pBuffDesc->bd_OpaqueBuffer,
					NormalPagePriority);
		}
		if (pBuf != NULL) {
			checksum = AtalkDdpCheckSumBuffer(pBuf, pBuffDesc->bd_Length, checksum);
			pBuffDesc = pBuffDesc->bd_Next;
		}
	}

	return checksum;
}



//	This routine needs to verify that the socket does not already
//	exist on the node. If it doesnt it will alloc the ddp address
//	object and link it into the node and do all the required initialization.
//	The node is guaranteed to be referenced.

ATALK_ERROR
atalkDdpAllocSocketOnNode(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN		PATALK_NODE				pAtalkNode,
	IN 		DDPAO_HANDLER			pSktHandler 	OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					Protocol		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ			pDdpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ADDR			addr;
	PDDP_ADDROBJ		pDdpAddrx;
	KIRQL				OldIrql;
	int					i, j, index;
	BOOLEAN				found	= TRUE;
	ATALK_ERROR			error 	= ATALK_NO_ERROR;

	//	See if the socket exists else, link our new socket into
	//	the node linkage. All within a critical section.

	addr.ata_Network = pAtalkNode->an_NodeAddr.atn_Network;
	addr.ata_Node = pAtalkNode->an_NodeAddr.atn_Node;
	addr.ata_Socket = Socket;

	//	Now reference the node on which this socket will reside.
	//	This will go away when the socket is closed.
	AtalkNodeReferenceByPtr(pAtalkNode, &error);
	if (!ATALK_SUCCESS(error))
	{
		TMPLOGERR();
		return error;
	}

	ACQUIRE_SPIN_LOCK(&pAtalkNode->an_Lock, &OldIrql);

	if (Socket == DYNAMIC_SOCKET)
	{
		//	Two attempts if we are at the end of the range and restart from
		//	the beginning.
		for (j = 0; (j < NUM_USER_NODES) && found; j++)
		{
			for (i = pAtalkNode->an_NextDynSkt; i <= LAST_DYNAMIC_SOCKET; i++)
			{
				addr.ata_Socket = (BYTE)i;
				index = HASH_ATALK_ADDR(&addr) % NODE_DDPAO_HASH_SIZE;

				found = atalkDdpFindAddrOnList(pAtalkNode, index, (BYTE)i, &pDdpAddrx);

				if (found)
					continue;

				Socket = (BYTE)i;
				break;
			}

			//	Now if still havent found the socket id, set NextDynSkt to
			//	beginning of the range and try again.
			if (found)
			{
				pAtalkNode->an_NextDynSkt = FIRST_DYNAMIC_SOCKET;
				continue;
			}

			//	Not found. Increment next id to be used.
			if (++(pAtalkNode->an_NextDynSkt) == 0)
			{
				//	We wrapped! Set the value to the lowest dynamic
				//	socket. Thats what it should have been initialized
				//	to.
				pAtalkNode->an_NextDynSkt = FIRST_DYNAMIC_SOCKET;
			}

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("atalkDdpAllocSocketOnNode: Created dynamic socket %x\n", Socket));

			//	Done.
			break;
		}

		if (found)
		{
			error = ATALK_SOCKET_NODEFULL;
		}
	}
	else
	{
		index = HASH_ATALK_ADDR(&addr) % NODE_DDPAO_HASH_SIZE;

		found = atalkDdpFindAddrOnList(pAtalkNode, index, (BYTE)Socket, &pDdpAddrx);

		if (found)
		{
			error = ATALK_SOCKET_EXISTS;
		}
	}

	if (ATALK_SUCCESS(error))
	{
		//	Initialize and thread in the structure

		pDdpAddr->ddpao_Signature	= DDPAO_SIGNATURE;

		pDdpAddr->ddpao_RefCount 	= 1;		//	Creation
		pDdpAddr->ddpao_DevCtx 		= pDevCtx;
		pDdpAddr->ddpao_Node 		= pAtalkNode;

		pDdpAddr->ddpao_Addr.ata_Network	= pAtalkNode->an_NodeAddr.atn_Network;
		pDdpAddr->ddpao_Addr.ata_Node  		= pAtalkNode->an_NodeAddr.atn_Node;
		pDdpAddr->ddpao_Addr.ata_Socket		= Socket;

		pDdpAddr->ddpao_Protocol 	= Protocol;
		pDdpAddr->ddpao_Handler 	= pSktHandler;
		pDdpAddr->ddpao_HandlerCtx 	= pSktCtx;

		INITIALIZE_SPIN_LOCK(&pDdpAddr->ddpao_Lock);
		InitializeListHead(&pDdpAddr->ddpao_ReadLinkage);

		//	We use 'index' to link this in.
		pDdpAddr->ddpao_Next = pAtalkNode->an_DdpAoHash[index];
		pAtalkNode->an_DdpAoHash[index] = pDdpAddr;
	}

	RELEASE_SPIN_LOCK(&pAtalkNode->an_Lock, OldIrql);

	//	If we failed, Dereference the node
	if (!ATALK_SUCCESS(error))
		AtalkNodeDereference(pAtalkNode);

	return error;
}




BOOLEAN
atalkDdpFindAddrOnList(
	IN	PATALK_NODE		pAtalkNode,
	IN	ULONG			Index,
	IN	BYTE			Socket,
	OUT	PDDP_ADDROBJ *	ppDdpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ	pDdpAddr;

   	BOOLEAN		found = FALSE;

	for (pDdpAddr = pAtalkNode->an_DdpAoHash[Index];
		 pDdpAddr != NULL;
		 pDdpAddr = pDdpAddr->ddpao_Next)
	{
		if (pDdpAddr->ddpao_Addr.ata_Socket == Socket)
		{
			*ppDdpAddr = pDdpAddr;
			found = TRUE;
			break;
		}
	}

	return found;
}




VOID
AtalkDdpRefByAddr(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PATALK_ADDR			pAtalkAddr,
	OUT		PDDP_ADDROBJ	*	ppDdpAddr,
	OUT		PATALK_ERROR		pErr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG				index;
	ATALK_NODEADDR		node;
	PATALK_NODE			pAtalkNode;
	PDDP_ADDROBJ		pDdpAddr;
	KIRQL				OldIrql;
	ATALK_ERROR			ErrorCode;

	node.atn_Network = pAtalkAddr->ata_Network;
	node.atn_Node	= pAtalkAddr->ata_Node;

	//	First find the node on this port given its address
	AtalkNodeReferenceByAddr(pPortDesc,
							 &node,
							 &pAtalkNode,
							 &ErrorCode);

	if (ATALK_SUCCESS(ErrorCode))
	{
		ASSERT(VALID_ATALK_NODE(pAtalkNode));

		index = HASH_ATALK_ADDR(pAtalkAddr) % NODE_DDPAO_HASH_SIZE;

		ACQUIRE_SPIN_LOCK(&pAtalkNode->an_Lock, &OldIrql);
		if(atalkDdpFindAddrOnList(pAtalkNode,
								  index,
								  pAtalkAddr->ata_Socket,
								  &pDdpAddr))
		{
			AtalkDdpReferenceByPtr(pDdpAddr, &ErrorCode);
			if (ATALK_SUCCESS(ErrorCode))
			{
				ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));
				*ppDdpAddr = pDdpAddr;
			}
		}
		else
		{
			ErrorCode = ATALK_DDP_NOTFOUND;
		}
		RELEASE_SPIN_LOCK(&pAtalkNode->an_Lock, OldIrql);

		//	Remove the node reference
		ASSERT(VALID_ATALK_NODE(pAtalkNode));
		AtalkNodeDereference(pAtalkNode);
	}
	*pErr = ErrorCode;
}




VOID
AtalkDdpRefByAddrNode(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PATALK_ADDR			pAtalkAddr,
	IN		PATALK_NODE			pAtalkNode,
	OUT		PDDP_ADDROBJ	*	ppDdpAddr,
	OUT		PATALK_ERROR		pErr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			index;
	KIRQL			OldIrql;
	PDDP_ADDROBJ	pDdpAddr;

	ASSERT(VALID_ATALK_NODE(pAtalkNode));

	index = HASH_ATALK_ADDR(pAtalkAddr) % NODE_DDPAO_HASH_SIZE;

	ACQUIRE_SPIN_LOCK(&pAtalkNode->an_Lock, &OldIrql);
	if(atalkDdpFindAddrOnList(pAtalkNode,
							  index,
							  pAtalkAddr->ata_Socket,
							  &pDdpAddr))
	{
		AtalkDdpReferenceByPtr(pDdpAddr, pErr);
		if (ATALK_SUCCESS(*pErr))
		{
			ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));
			*ppDdpAddr = pDdpAddr;
		}
	}
	else
	{
		*pErr = ATALK_DDP_NOTFOUND;
	}
	RELEASE_SPIN_LOCK(&pAtalkNode->an_Lock, OldIrql);
}




VOID
AtalkDdpRefNextNc(
	IN	PDDP_ADDROBJ	pDdpAddr,
	IN	PDDP_ADDROBJ *	ppDdpAddr,
	OUT	PATALK_ERROR	pErr
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE NODE LOCK HELD!

Arguments:


Return Value:


--*/
{
	*pErr = ATALK_FAILURE;
	*ppDdpAddr = NULL;
	for (; pDdpAddr != NULL; pDdpAddr = pDdpAddr->ddpao_Next)
	{
		AtalkDdpReferenceByPtrDpc(pDdpAddr, pErr);
		if (ATALK_SUCCESS(*pErr))
		{
			//	Ok, this address is referenced!
			ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));
			*ppDdpAddr = pDdpAddr;
			break;
		}
	}
}




VOID FASTCALL
AtalkDdpDeref(
	IN	OUT	PDDP_ADDROBJ		pDdpAddr,
	IN		BOOLEAN				AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error = ATALK_NO_ERROR;
	PATALK_NODE		pNode = pDdpAddr->ddpao_Node;
	BOOLEAN			done = FALSE;
	KIRQL			OldIrql;

	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	if (AtDpc)
	{
		 ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	}

	ASSERT(pDdpAddr->ddpao_RefCount > 0);
	if (--(pDdpAddr->ddpao_RefCount) == 0)
	{
		done = TRUE;
	}

	if (AtDpc)
	{
		 RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	}

	if (done)
	{
		PDDP_ADDROBJ *	ppDdpAddr;
		int				index;

        //
        // if this is a zombie socket (that is, it was cleaned up but not freed
        // because it's an external socket) then now is the time to free it.
        // Cleanup is all done already.
        //
        if ((pDdpAddr->ddpao_Flags & DDPAO_SOCK_PNPZOMBIE) != 0)
        {
	        DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
		        ("AtalkDdpDeref..: zombie addr %lx (%lx) freed\n",
                pDdpAddr,pDdpAddr->ddpao_Handler));

		    //	Free the address structure
		    AtalkFreeMemory(pDdpAddr);

            return;
        }

		ASSERT((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) != 0);

		if ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) == 0)
		{
			KeBugCheck(0);
		}

		//	Remove this guy from the node linkage
		if (AtDpc)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);
		}
		else
		{
			ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);
		}
		index = HASH_ATALK_ADDR(&pDdpAddr->ddpao_Addr) % NODE_DDPAO_HASH_SIZE;
		for (ppDdpAddr = &pNode->an_DdpAoHash[index];
			 *ppDdpAddr != NULL;
			 ppDdpAddr = &((*ppDdpAddr)->ddpao_Next))
		{
			if (*ppDdpAddr == pDdpAddr)
			{
				*ppDdpAddr = pDdpAddr->ddpao_Next;
				break;
			}
		}
		if (AtDpc)
		{
			RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);
		}

		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
				("AtalkDdpDeref: Closing ddp socket %lx\n", pDdpAddr->ddpao_Addr.ata_Socket));

		if (pDdpAddr->ddpao_EventInfo != NULL)
		{
			AtalkFreeMemory(pDdpAddr->ddpao_EventInfo);
		}

		//	Call the completion routines
		if (*pDdpAddr->ddpao_CloseComp != NULL)
		{
			(*pDdpAddr->ddpao_CloseComp)(ATALK_NO_ERROR, pDdpAddr->ddpao_CloseCtx);
		}

		//	Free the address structure
		AtalkFreeMemory(pDdpAddr);

		//	Dereference the node for this address
		AtalkNodeDereference(pNode);
	}
}




VOID
AtalkDdpNewHandlerForSocket(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	DDPAO_HANDLER			pSktHandler,
	IN	PVOID					pSktHandlerCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	pDdpAddr->ddpao_Handler = pSktHandler;
	pDdpAddr->ddpao_HandlerCtx = pSktHandlerCtx;

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\fwddecl.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fwddecl.h

Abstract:

	This file defines dummy structures to avoid the circular relationships in
	header files.

Author:

	Jameel Hyder (microsoft!jameelh)
	Nikhil Kamkolkar (microsoft!nikhilk)


Revision History:
	10 Mar 1993             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _FWDDECL_
#define _FWDDECL_

struct _PORT_DESCRIPTOR;

struct _AMT_NODE;

struct _ZONE;

struct _ZONE_LIST;

struct _DDP_ADDROBJ;

struct _ATP_ADDROBJ;

struct _PEND_NAME;

struct _REGD_NAME;

struct _BUFFER_DESC;

struct _AARP_BUFFER;

struct _DDP_SMBUFFER;

struct _DDP_LGBUFFER;

struct _TimerList;

struct _RoutingTableEntry;

struct _ZipCompletionInfo;

struct _SEND_COMPL_INFO;

struct _ActionReq;

struct _BLK_HDR;

struct _BLK_CHUNK;

// Support for debugging
typedef	struct
{
	KSPIN_LOCK		SpinLock;
#if	DBG
	ULONG			FileLineLock;
	ULONG			FileLineUnlock;
#endif
} ATALK_SPIN_LOCK, *PATALK_SPIN_LOCK;

#endif  // _FWDDECL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\nbp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nbp.c

Abstract:

	This module contains nbp code

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		NBP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_NZ, AtalkNbpAction)
#pragma alloc_text(PAGE_NZ, atalkNbpLinkPendingNameInList)
#pragma alloc_text(PAGE_NZ, atalkNbpSendRequest)
#endif

/***	AtalkNbpPacketIn
 *
 */
VOID
AtalkNbpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
{
	PPEND_NAME		pPendName;
	PATALK_NODE		pNode;
	TIME			TimeS, TimeE, TimeD;
	PNBPHDR			pNbpHdr = (PNBPHDR)pPkt;
	PRTE			pRte;
	SHORT			i, NbpId, NbpCmd, TupleCnt;
	PNBPTUPLE		pNbpTuple = NULL, pInBufTuple = NULL;
	BOOLEAN			DefZone = FALSE, RestartTimer = FALSE;
    BOOLEAN         fWeCancelledTimer = TRUE;
	BOOLEAN			Found;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);

	do
	{
		if ((ErrorCode == ATALK_SOCKET_CLOSED) || (DdpType != DDPPROTO_NBP))
			break;

		else if ((ErrorCode != ATALK_NO_ERROR) || (PktLen < sizeof(NBPHDR)))
		{
			break;
		}

		// Get NBP header information and decide what to do
		NbpCmd = (SHORT)((pNbpHdr->_CmdAndTupleCnt >> 4) & 0x0F);
		TupleCnt = (SHORT)(pNbpHdr->_CmdAndTupleCnt & 0x0F);
		NbpId = (SHORT)pNbpHdr->_NbpId;

		if ((pNbpTuple = AtalkAllocMemory(sizeof(NBPTUPLE))) == NULL)
		{
			TMPLOGERR();
			break;
		}

		switch (NbpCmd)
		{
		  case NBP_LOOKUP:
  			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpPacketIn: Cmd Lookup\n"));
  			if ((TupleCnt == 1) &&
				(atalkNbpDecodeTuple(pPkt + sizeof(NBPHDR),
									 (USHORT)(PktLen - sizeof(NBPHDR)),
									 pNbpTuple) > 0))
			{
				atalkNbpLookupNames(pPortDesc, pDdpAddr, pNbpTuple, NbpId);
			}
			else
			{
#if 0
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
#endif
				break;
			}
			break;

		  case NBP_BROADCAST_REQUEST:
		  case NBP_FORWARD_REQUEST:
  			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpPacketIn: Cmd %sRequest\n",
					(NbpCmd == NBP_BROADCAST_REQUEST) ? "Broadcast" : "Forward"));
			// We don't care if we are not a router
			if ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING) == 0)
				break;

			if (TupleCnt != 1)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			if (atalkNbpDecodeTuple(pPkt + sizeof(NBPHDR),
									(USHORT)(PktLen - sizeof(NBPHDR)),
									pNbpTuple) == 0)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			if ((pNbpTuple->tpl_ZoneLen == 0) ||
				((pNbpTuple->tpl_Zone[0] == '*') && (pNbpTuple->tpl_ZoneLen == 1)))
				DefZone = TRUE;

			if (EXT_NET(pPortDesc))
			{
				if (DefZone)
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
			}
			else				// Non-extended network
			{
				if	(DefZone)
				{
					if (pPortDesc->pd_NetworkRange.anr_FirstNetwork != pSrcAddr->ata_Network)
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
								("AtalkNbpPacketIn: LT Port, '*' zone - SrcAddr %d.%d, Net %d\n",
								pSrcAddr->ata_Network, pSrcAddr->ata_Node,
                                pPortDesc->pd_NetworkRange.anr_FirstNetwork));
								AtalkLogBadPacket(pPortDesc,
												  pSrcAddr,
												  pDstAddr,
												  pPkt,
												  PktLen);
						break;
					}
					if (!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
						break;

					ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					pNbpTuple->tpl_ZoneLen = pPortDesc->pd_DesiredZone->zn_ZoneLen;
					RtlCopyMemory(pNbpTuple->tpl_Zone,
								  pPortDesc->pd_DesiredZone->zn_Zone,
								  pPortDesc->pd_DesiredZone->zn_ZoneLen);
					RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				}
			}

			// For a forward request send a lookup datagram
			if (NbpCmd == NBP_FORWARD_REQUEST)
			{
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("AtalkNbpPacketIn: Sending NbpLookup for a NbpForwardRequest\n"));
				atalkNbpSendLookupDatagram(pPortDesc, pDdpAddr, NbpId, pNbpTuple);
				break;
			}

			// We have a broadcast request. Walk through the routing tables
			// sending either a forward request or a lookup (broadcast) to
			// each network that contains the specified zone
			ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);

			for (i = 0;i < NUM_RTMP_HASH_BUCKETS; i++)
			{
				for (pRte = AtalkRoutingTable[i];
					 pRte != NULL;
					 pRte = pRte->rte_Next)
				{
					ATALK_ERROR			Status;

					// If the network is directly connected i.e. 0 hops away
					// use the zone-list in the PortDesc rather than the
					// routing table - the routing table may not be filled
					// in with a zone list (due to the normal ZipQuery mechanism)
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					if (!(pRte->rte_Flags & RTE_ZONELIST_VALID))
					{
						if ((pRte->rte_NumHops != 0) ||
							!AtalkZoneNameOnList(pNbpTuple->tpl_Zone,
												 pNbpTuple->tpl_ZoneLen,
												 pRte->rte_PortDesc->pd_ZoneList))
						{
							RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
							continue;
						}
					}
					else if (!AtalkZoneNameOnList(pNbpTuple->tpl_Zone,
												  pNbpTuple->tpl_ZoneLen,
												  pRte->rte_ZoneList))
					{
						RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
						continue;
					}

					pRte->rte_RefCount ++;
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);

					// If not a local network, send a forward request
					if (pRte->rte_NumHops != 0)
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("AtalkNbpPacketIn: Sending NbpForwardRequest for a broadcast\n"));

						// Do not hold the Rte lock during a DdpSend
						RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
						atalkNbpSendForwardRequest(pDdpAddr,
												   pRte,
												   NbpId,
												   pNbpTuple);
						ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
						AtalkRtmpDereferenceRte(pRte, TRUE);
					}
					else
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("AtalkNbpPacketIn: Sending Lookup for a broadcast\n"));
						// Send a lookup
						RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
						atalkNbpSendLookupDatagram(pRte->rte_PortDesc,
												   NULL,
												   NbpId,
												   pNbpTuple);
						ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
						AtalkRtmpDereferenceRte(pRte, TRUE);
					}
				}
			}

			RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
			break;

		  case NBP_LOOKUP_REPLY:
  			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpPacketIn: Cmd LookupReply\n"));
  			// This had better be a response to a previous lookup
			// Look for a pending name on all open sockets on this node

			if (TupleCnt == 0)
				break;

			// Decode the tuple for Register/Confirm case
			if (atalkNbpDecodeTuple(pPkt + sizeof(NBPHDR),
									(USHORT)(PktLen - sizeof(NBPHDR)),
									pNbpTuple) == 0)
			{
				break;
			}

			pNode = pDdpAddr->ddpao_Node;
			ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);

			Found = FALSE;
			for (i = 0; (i < NODE_DDPAO_HASH_SIZE) && !Found; i++)
			{
				PDDP_ADDROBJ	pSkt;

				for (pSkt = pNode->an_DdpAoHash[i];
					 (pSkt != NULL) && !Found;
					 pSkt = pSkt->ddpao_Next)
				{
					PPEND_NAME	*	ppPendName;

					ACQUIRE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);

					for (ppPendName = &pSkt->ddpao_PendNames;
						 (pPendName = *ppPendName) != NULL;
						 ppPendName = &pPendName->pdn_Next)
					{
						ASSERT (VALID_PENDNAME(pPendName));

						if (pPendName->pdn_Flags & PDN_CLOSING)
						{
							continue;
						}

						if (pPendName->pdn_NbpId == NbpId)
						{
							DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: LookupReply Found name\n"));
							Found = TRUE;
							ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
							pPendName->pdn_RefCount ++;
							RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
							break;
						}
					}

					RELEASE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);
				}
			}

			RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);

			// If the timer fired just before we could find and cancel it
			if (pPendName == NULL)
				break;

			do
			{
				if (AtalkTimerCancelEvent(&pPendName->pdn_Timer, NULL))
				{
					// if the timer was successfully cancelled, take away
					// the reference for it
					atalkNbpDerefPendName(pPendName);
					RestartTimer = TRUE;
				}
                else
                {
                    fWeCancelledTimer = FALSE;
                }

				if ((pPendName->pdn_Reason == FOR_REGISTER) ||
					(pPendName->pdn_Reason == FOR_CONFIRM))
				{
					BOOLEAN	NoMatch;

					// Does the reply match the one we're trying to register ?
					NoMatch = ( (TupleCnt != 1) ||
								(pPendName->pdn_pRegdName == NULL) ||
								!AtalkFixedCompareCaseInsensitive(
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_Object,
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_ObjectLen,
									pNbpTuple->tpl_Object,
									pNbpTuple->tpl_ObjectLen) ||
								!AtalkFixedCompareCaseInsensitive(
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_Type,
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_TypeLen,
									pNbpTuple->tpl_Type,
									pNbpTuple->tpl_TypeLen));

					if (NoMatch)
					{
						if (TupleCnt != 1)
							AtalkLogBadPacket(pPortDesc,
											  pSrcAddr,
											  pDstAddr,
											  pPkt,
											  PktLen);
						break;
					}

					// If we are registering, we're done as someone already
					// has our name
					if (pPendName->pdn_Reason == FOR_REGISTER)
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: Register failure\n"));
						ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
						pPendName->pdn_Status = ATALK_SHARING_VIOLATION;
						pPendName->pdn_Flags |= PDN_CLOSING;
						RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
						if (fWeCancelledTimer)
						{
							atalkNbpDerefPendName(pPendName);	// Take away creation ref
						}
						RestartTimer = FALSE;
						break;
					}

					// We're confirming, if no match get out
					if ((pPendName->pdn_ConfirmAddr.ata_Network != pNbpTuple->tpl_Address.ata_Network) ||
						(pPendName->pdn_ConfirmAddr.ata_Node != pNbpTuple->tpl_Address.ata_Node))
					{
						break;
					}

					DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
							("atalkNbpPacketIn: Confirm success\n"));
					ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
					pPendName->pdn_Status = ATALK_NO_ERROR;
					((PNBP_CONFIRM_PARAMS)(pPendName->pdn_pActReq->ar_pParms))->ConfirmTuple.Address.Address =
															pNbpTuple->tpl_Address.ata_Address;
					if (pPendName->pdn_ConfirmAddr.ata_Socket != pNbpTuple->tpl_Address.ata_Socket)
					{
						pPendName->pdn_Status = ATALK_NEW_SOCKET;
					}
					pPendName->pdn_Flags |= PDN_CLOSING;
					RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
					atalkNbpDerefPendName(pPendName);	// Take away creation ref
					RestartTimer = FALSE;
				}

				else			// FOR_LOOKUP
				{
					int			i, j, tmp, NextTupleOff = sizeof(NBPHDR);
					BOOLEAN		Done = FALSE;
					ULONG		BytesCopied;

					DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
							("atalkNbpPacketIn: Lookup searching...\n"));

					// Allocate space for an NBP tuple for copying and comparing
					// Failure to allocate can result in duplicates - so be it
					if (pInBufTuple == NULL)
						pInBufTuple = AtalkAllocMemory(sizeof(NBPTUPLE));
					for (i = 0; i < TupleCnt && !Done; i++)
					{
						BOOLEAN	Duplicate = FALSE;

						// If we encounter a bad tuple, ignore the rest. Drop tuples which are
						// our names and we are set to drop them !!!
						if (((tmp = atalkNbpDecodeTuple(pPkt + NextTupleOff,
														(USHORT)(PktLen - NextTupleOff),
														pNbpTuple)) == 0) ||
							(AtalkFilterOurNames &&
							(((pNbpTuple->tpl_Address.ata_Network == AtalkUserNode1.atn_Network) &&
							  (pNbpTuple->tpl_Address.ata_Node == AtalkUserNode1.atn_Node)) ||
							 ((pNbpTuple->tpl_Address.ata_Network == AtalkUserNode2.atn_Network) &&
							  (pNbpTuple->tpl_Address.ata_Node == AtalkUserNode2.atn_Node)))))
							break;

						NextTupleOff += tmp;
						ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);

						// Now walk through the tuples that we already picked
						// up and drop duplicates
						if (pInBufTuple != NULL)
						{
							for (j = 0; j < pPendName->pdn_TotalTuples; j++)
							{
								TdiCopyMdlToBuffer(pPendName->pdn_pAMdl,
													j * sizeof(NBPTUPLE),
													(PBYTE)pInBufTuple,
													0,
													sizeof(NBPTUPLE),
													&BytesCopied);
								ASSERT (BytesCopied == sizeof(NBPTUPLE));
	
								if ((pInBufTuple->tpl_Address.ata_Network ==
											pNbpTuple->tpl_Address.ata_Network) &&
									(pInBufTuple->tpl_Address.ata_Node ==
											pNbpTuple->tpl_Address.ata_Node) &&
									(pInBufTuple->tpl_Address.ata_Socket ==
											pNbpTuple->tpl_Address.ata_Socket))
								{
									Duplicate = TRUE;
									break;
								}
							}
							if (Duplicate)
							{
								RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
								continue;
							}
						}

						// We are guaranteed that there is space available
						// for another tuple.
						TdiCopyBufferToMdl((PBYTE)pNbpTuple,
											0,
											sizeof(NBPTUPLE),
											pPendName->pdn_pAMdl,
											pPendName->pdn_TotalTuples * sizeof(NBPTUPLE),
											&BytesCopied);
						ASSERT (BytesCopied == sizeof(NBPTUPLE));

						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: Lookup, found a tuple\n"));
						pPendName->pdn_TotalTuples ++;

						if ((pPendName->pdn_TotalTuples == pPendName->pdn_MaxTuples) ||
							(pPendName->pdn_MdlLength -
								(pPendName->pdn_TotalTuples * sizeof(NBPTUPLE)) <
														sizeof(NBPTUPLE)))
						{
							Done = TRUE;
							((PNBP_LOOKUP_PARAMS)(pPendName->pdn_pActReq->ar_pParms))->NoTuplesRead =
														pPendName->pdn_TotalTuples;
							pPendName->pdn_Status = ATALK_NO_ERROR;
							pPendName->pdn_Flags |= PDN_CLOSING;

							RestartTimer = FALSE;
						}

						RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);

						if (Done)
						{
							DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: Lookup calling completion\n"));

                            if (fWeCancelledTimer)
                            {
							    atalkNbpDerefPendName(pPendName);	// Take away creation ref
                            }
							break;
						}
					}
				}
			} while (FALSE);

			if (RestartTimer)
			{
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("atalkNbpPacketIn: Restarting timer\n"));

				ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
				pPendName->pdn_RefCount ++;
				RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
				AtalkTimerScheduleEvent(&pPendName->pdn_Timer);
			}
			atalkNbpDerefPendName(pPendName);
			break;

		  default:
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}
	} while (FALSE);

	if (pNbpTuple != NULL)
		AtalkFreeMemory(pNbpTuple);

	if (pInBufTuple != NULL)
		AtalkFreeMemory(pInBufTuple);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR(
		&pPortDesc->pd_PortStats.prtst_NbpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumNbpPacketsIn,
		&AtalkStatsLock.SpinLock);
}


/***	atalkNbpTimer
 *
 */
LOCAL LONG FASTCALL
atalkNbpTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
)
{
	PPEND_NAME		pCurrPendName;
	ATALK_ERROR		error;
	PDDP_ADDROBJ	pDdpAddr;
	BOOLEAN			RestartTimer = TRUE;
	BYTE			Reason;

	pCurrPendName = (PPEND_NAME)CONTAINING_RECORD(pTimer, PEND_NAME, pdn_Timer);
	ASSERT (VALID_PENDNAME(pCurrPendName));


	Reason = pCurrPendName->pdn_Reason;
	ASSERT ((Reason == FOR_REGISTER) ||
			(Reason == FOR_LOOKUP)	||
			(Reason == FOR_CONFIRM));

	pDdpAddr = pCurrPendName->pdn_pDdpAddr;

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpTimer: For Socket %lx, PendName %lx\n",
			pDdpAddr, pCurrPendName));

	ACQUIRE_SPIN_LOCK_DPC(&pCurrPendName->pdn_Lock);

	if (TimerShuttingDown ||
		(pCurrPendName->pdn_Flags & PDN_CLOSING))
		    pCurrPendName->pdn_RemainingBroadcasts = 1;

	if (--(pCurrPendName->pdn_RemainingBroadcasts) == 0)
	{
		RestartTimer = FALSE;
		if (Reason == FOR_REGISTER)
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpTimer: Register success\n"));

			ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
			pCurrPendName->pdn_pRegdName->rdn_Next = pDdpAddr->ddpao_RegNames;
			pDdpAddr->ddpao_RegNames = pCurrPendName->pdn_pRegdName;
			RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);

			pCurrPendName->pdn_Flags &= ~PDN_FREE_REGDNAME;
		}
		pCurrPendName->pdn_Flags |= PDN_CLOSING;
	}

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpTimer: Remaining broadcasts %d\n",
			pCurrPendName->pdn_RemainingBroadcasts));

	if (RestartTimer)
	{
		pCurrPendName->pdn_RefCount ++;
		RELEASE_SPIN_LOCK_DPC(&pCurrPendName->pdn_Lock);

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpTimer: Sending another request\n"));

		if (!atalkNbpSendRequest(pCurrPendName))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
					("atalkNbpTimer: atalkNbpSendRequest failed\n"));
		}
	}
	else
	{
		RELEASE_SPIN_LOCK_DPC(&pCurrPendName->pdn_Lock);
		error = ATALK_NO_ERROR;
		if (Reason == FOR_CONFIRM)
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpTimer: Confirm Failure\n"));
			error = ATALK_TIMEOUT;
		}
		else if (Reason == FOR_LOOKUP)
		{
			((PNBP_LOOKUP_PARAMS)(pCurrPendName->pdn_pActReq->ar_pParms))->NoTuplesRead =
								pCurrPendName->pdn_TotalTuples;
		}

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpTimer: Calling completion routine\n"));
		pCurrPendName->pdn_Status = error;

		atalkNbpDerefPendName(pCurrPendName);	// Take away creation reference
	}
	atalkNbpDerefPendName(pCurrPendName);

	return (RestartTimer ? ATALK_TIMER_REQUEUE : ATALK_TIMER_NO_REQUEUE);
}


/***	atalkNbpLookupNames
 *
 */
LOCAL VOID
atalkNbpLookupNames(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PNBPTUPLE			pNbpTuple,
	IN	SHORT				NbpId
)
{
	int				i, index, TupleCnt;
	BOOLEAN			AllocNewBuffDesc = TRUE;
	PBUFFER_DESC	pBuffDesc,
					pBuffDescStart = NULL,
					*ppBuffDesc = &pBuffDescStart;
	PATALK_NODE		pNode = pDdpAddr->ddpao_Node;
	SEND_COMPL_INFO	SendInfo;
	PBYTE			Datagram;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpLookupNames: Entered\n"));

	// Does the requestor atleast has the right zone ?
	if ((pNbpTuple->tpl_Zone[0] != '*') ||
		(pNbpTuple->tpl_ZoneLen != 1))
	{
		// If either we do not know our zone or if it does not match or
		// we are an extended network, return - we have nothing to do
		if (EXT_NET(pPortDesc))
		{
			if (!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) ||
				((pPortDesc->pd_DesiredZone == NULL) ?1:
				 (!AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Zone,
							pNbpTuple->tpl_ZoneLen,
							pPortDesc->pd_DesiredZone->zn_Zone,
							pPortDesc->pd_DesiredZone->zn_ZoneLen))))
			{
				return;
			}
		}
	}

	// Walk the registered names list on all sockets open on this node and
	// see if we have a matching name. We have to walk the pending names
	// list also (should not answer, if we the node trying to register the
	// name).

	ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Node->an_Lock);

	for (i = 0; i < NODE_DDPAO_HASH_SIZE; i++)
	{
		PDDP_ADDROBJ	pSkt;

		for (pSkt = pNode->an_DdpAoHash[i];
			 pSkt != NULL;
			 pSkt = pSkt->ddpao_Next)
		{
			PREGD_NAME		pRegdName;
			PPEND_NAME		pPendName;

			ACQUIRE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);

			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpLookupNames: Checking Socket %lx\n", pSkt));

			// First check registered names
			for (pRegdName = pSkt->ddpao_RegNames;
				 pRegdName != NULL;
				 pRegdName = pRegdName->rdn_Next)
			{
				ASSERT (VALID_REGDNAME(pRegdName));
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("atalkNbpLookupNames: Checking RegdName %lx\n", pRegdName));

				if (!atalkNbpMatchWild(pNbpTuple->tpl_Object,
									   pNbpTuple->tpl_ObjectLen,
									   pRegdName->rdn_Tuple.tpl_Object,
									   pRegdName->rdn_Tuple.tpl_ObjectLen) ||
					!atalkNbpMatchWild(pNbpTuple->tpl_Type,
									   pNbpTuple->tpl_TypeLen,
									   pRegdName->rdn_Tuple.tpl_Type,
									   pRegdName->rdn_Tuple.tpl_TypeLen))
					continue;

				// Allocate a new buffer descriptor, if we must
				if (AllocNewBuffDesc)
				{
					if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										MAX_DGRAM_SIZE,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
						break;
					Datagram = pBuffDesc->bd_CharBuffer;
					index = sizeof(NBPHDR);
					TupleCnt = 0;
					*ppBuffDesc = pBuffDesc;
					pBuffDesc->bd_Next = NULL;
					ppBuffDesc = &pBuffDesc->bd_Next;
					AllocNewBuffDesc = FALSE;
				}

				// We have a match. Build complete Nbp tuple
				index += atalkNbpEncodeTuple(&pRegdName->rdn_Tuple,
											 "*",
											 1,
											 0,
											 Datagram+index);
				TupleCnt ++;

				if (((index + MAX_NBP_TUPLELENGTH) > MAX_DGRAM_SIZE) ||
					(TupleCnt == 0x0F))
				{
					((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
					((PNBPHDR)Datagram)->_CmdAndTupleCnt =
											(NBP_LOOKUP_REPLY << 4) + TupleCnt;
					AllocNewBuffDesc = TRUE;
					pBuffDesc->bd_Length = (SHORT)index;
				}
			}

			// Now check pending names
			for (pPendName = pSkt->ddpao_PendNames;
				 pPendName != NULL;
				 pPendName = pPendName->pdn_Next)
			{
				ASSERT (VALID_PENDNAME(pPendName));
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("atalkNbpLookupNames: Checking PendName %lx\n", pPendName));

				// Ignore all but the ones that are being registered
				if (pPendName->pdn_Reason != FOR_REGISTER)
					continue;

				// Also those that we are registering
				if ((pSkt->ddpao_Node->an_NodeAddr.atn_Network ==
										pNbpTuple->tpl_Address.ata_Network) &&
					(pSkt->ddpao_Node->an_NodeAddr.atn_Node ==
										pNbpTuple->tpl_Address.ata_Node) &&
					(pPendName->pdn_NbpId == (BYTE)NbpId))
					continue;

				if ((pPendName->pdn_pRegdName == NULL) ||
					!atalkNbpMatchWild(
								pNbpTuple->tpl_Object,
								pNbpTuple->tpl_ObjectLen,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_Object,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_ObjectLen) ||
					 !atalkNbpMatchWild(
								pNbpTuple->tpl_Type,
								pNbpTuple->tpl_TypeLen,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_Type,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_TypeLen))
				{
					continue;
				}

				// Allocate a new buffer descriptor, if we must
				if (AllocNewBuffDesc)
				{
					if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										MAX_DGRAM_SIZE,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
					break;
					Datagram = pBuffDesc->bd_CharBuffer;
					index = sizeof(NBPHDR);
					TupleCnt = 0;
					*ppBuffDesc = pBuffDesc;
					pBuffDesc->bd_Next = NULL;
					ppBuffDesc = &pBuffDesc->bd_Next;
					AllocNewBuffDesc = FALSE;
				}

				// We have a match. Build complete Nbp tuple
				index += atalkNbpEncodeTuple(&pPendName->pdn_pRegdName->rdn_Tuple,
											 "*",
											 1,
											 0,
											 Datagram+index);

				TupleCnt ++;

				if (((index + MAX_NBP_TUPLELENGTH) > MAX_DGRAM_SIZE) ||
					(TupleCnt == 0x0F))
				{
					((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
					((PNBPHDR)Datagram)->_CmdAndTupleCnt =
											(NBP_LOOKUP_REPLY << 4) + TupleCnt;
					AllocNewBuffDesc = TRUE;
					pBuffDesc->bd_Length = (SHORT)index;
				}
			}

			RELEASE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Node->an_Lock);

	// Close the current buffdesc
	if (!AllocNewBuffDesc)
	{
		((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
		((PNBPHDR)Datagram)->_CmdAndTupleCnt = (NBP_LOOKUP_REPLY << 4) + TupleCnt;
		pBuffDesc->bd_Length = (SHORT)index;

	}

	// Now blast off all the datagrams that we have filled up
	SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	for (pBuffDesc = pBuffDescStart;
		 pBuffDesc != NULL;
		 pBuffDesc = pBuffDescStart)
	{
		ATALK_ERROR	ErrorCode;

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpLookupNames: Sending lookup response\n"));

		pBuffDescStart = pBuffDesc->bd_Next;
		pBuffDesc->bd_Next = NULL;

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpLookupNames: Sending %lx\n", pBuffDesc));

		ASSERT(pBuffDesc->bd_Length > 0);

		//	Length is already properly set in the buffer descriptor.
		SendInfo.sc_Ctx1 = pBuffDesc;
		ErrorCode = AtalkDdpSend(pDdpAddr,
								 &pNbpTuple->tpl_Address,
								 DDPPROTO_NBP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);

		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_WARN,
					("atalkNbpLookupNames: DdpSend failed %ld\n", ErrorCode));
			AtalkFreeBuffDesc(pBuffDesc);
		}
	}
}


/***	AtalkNbpAction
 *
 */
ATALK_ERROR
AtalkNbpAction(
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	BYTE				Reason,
	IN	PNBPTUPLE			pNbpTuple,
	OUT	PAMDL				pAMdl			OPTIONAL,	// FOR_LOOKUP
	IN	USHORT				MaxTuples		OPTIONAL,	// FOR_LOOKUP
	IN	PACTREQ				pActReq
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	PPEND_NAME			pPendName = NULL;
	PREGD_NAME			pRegdName = NULL;
	ATALK_ERROR			Status = ATALK_INVALID_PARAMETER;
	LONG				MdlLen = 0;
	BOOLEAN				DefZone = FALSE;

	ASSERT (Reason == FOR_REGISTER	||
			Reason == FOR_CONFIRM	||
			Reason == FOR_LOOKUP);

	do
	{
		if ((pNbpTuple->tpl_ObjectLen == 0)					||
			(pNbpTuple->tpl_ObjectLen > MAX_ENTITY_LENGTH)	||
			(pNbpTuple->tpl_TypeLen == 0)					||
			(pNbpTuple->tpl_TypeLen > MAX_ENTITY_LENGTH))
			break;

		if ((Reason == FOR_LOOKUP) &&
			((pAMdl == NULL) ||
			((MdlLen = AtalkSizeMdlChain(pAMdl)) < sizeof(NBPTUPLE))))
		{
			Status = ATALK_BUFFER_TOO_SMALL;
			break;
		}

		pPortDesc = pDdpAddr->ddpao_Node->an_Port;
		if (pNbpTuple->tpl_ZoneLen != 0)
		{
			if (pNbpTuple->tpl_ZoneLen > MAX_ENTITY_LENGTH)
				break;

			if (((pNbpTuple->tpl_Zone[0] == '*') && (pNbpTuple->tpl_ZoneLen == 1)) ||
				((pPortDesc->pd_DesiredZone != NULL) &&
				 AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Zone,
												  pNbpTuple->tpl_ZoneLen,
												  pPortDesc->pd_DesiredZone->zn_Zone,
												  pPortDesc->pd_DesiredZone->zn_ZoneLen)))
			{
				DefZone = TRUE;
			}
		}
		else
		{
			pNbpTuple->tpl_Zone[0] = '*';
			pNbpTuple->tpl_ZoneLen = 1;
			DefZone = TRUE;
		}

		if (Reason != FOR_LOOKUP)	// i.e. REGISTER or CONFIRM
		{
			if ((pNbpTuple->tpl_Object[0] == '=')	||
				(pNbpTuple->tpl_Type[0] == '=')		||
				(AtalkSearchBuf(pNbpTuple->tpl_Object,
								pNbpTuple->tpl_ObjectLen,
								NBP_WILD_CHARACTER) != NULL) ||
				(AtalkSearchBuf(pNbpTuple->tpl_Type,
								pNbpTuple->tpl_TypeLen,
								NBP_WILD_CHARACTER) != NULL))
				break;

			if ((Reason == FOR_REGISTER) && !DefZone)
				break;
		}

		// For extended networks, set the zone name correctly
		if (DefZone &&
			(pPortDesc->pd_Flags & (PD_EXT_NET | PD_VALID_DESIRED_ZONE)) ==
									(PD_EXT_NET | PD_VALID_DESIRED_ZONE))
		{
			RtlCopyMemory(pNbpTuple->tpl_Zone,
						  pPortDesc->pd_DesiredZone->zn_Zone,
						  pPortDesc->pd_DesiredZone->zn_ZoneLen);
			pNbpTuple->tpl_ZoneLen = pPortDesc->pd_DesiredZone->zn_ZoneLen;
		}

		// Start by building the pending name structure. This needs to be linked
		// to the socket holding the spin lock and getting a unique enumerator
		// and an nbp id. If either of these fail, then we undo the stuff.
		if (((pPendName = (PPEND_NAME)AtalkAllocZeroedMemory(sizeof(PEND_NAME))) == NULL) ||
			((pRegdName = (PREGD_NAME)AtalkAllocZeroedMemory(sizeof(REGD_NAME))) == NULL))
		{
			if (pPendName != NULL)
			{
				AtalkFreeMemory(pPendName);
				pPendName = NULL;
			}
			Status = ATALK_RESR_MEM;
			break;
		}

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("AtalkNbpAction: %s, Socket %lx, PendName %lx, RegdName %lx\n",
				(Reason == FOR_REGISTER) ? "Register" :
					((Reason == FOR_CONFIRM) ? "Confirm" : "Lookup"),
				pDdpAddr, pPendName, pRegdName));

#if	DBG
		pRegdName->rdn_Signature = RDN_SIGNATURE;
		pPendName->pdn_Signature = PDN_SIGNATURE;
#endif
		pRegdName->rdn_Tuple.tpl_ObjectLen = pNbpTuple->tpl_ObjectLen;;
		RtlCopyMemory(pRegdName->rdn_Tuple.tpl_Object,
					  pNbpTuple->tpl_Object,
					  pNbpTuple->tpl_ObjectLen);
		pRegdName->rdn_Tuple.tpl_TypeLen = pNbpTuple->tpl_TypeLen;;
		RtlCopyMemory(pRegdName->rdn_Tuple.tpl_Type,
					  pNbpTuple->tpl_Type,
					  pNbpTuple->tpl_TypeLen);
		pRegdName->rdn_Tuple.tpl_ZoneLen = pNbpTuple->tpl_ZoneLen;;
		RtlCopyMemory(pRegdName->rdn_Tuple.tpl_Zone,
					  pNbpTuple->tpl_Zone,
					  pNbpTuple->tpl_ZoneLen);

		pRegdName->rdn_Tuple.tpl_Address.ata_Address = pDdpAddr->ddpao_Addr.ata_Address;

		pPendName->pdn_pRegdName = pRegdName;

		INITIALIZE_SPIN_LOCK(&pPendName->pdn_Lock);
		pPendName->pdn_RefCount = 3;	// Reference for creation, timer & for ourselves
		pPendName->pdn_pDdpAddr = pDdpAddr;
		AtalkDdpReferenceByPtr(pDdpAddr, &Status);
		ASSERT(ATALK_SUCCESS(Status));

		pPendName->pdn_Flags = PDN_FREE_REGDNAME;
		pPendName->pdn_Reason = Reason;
		pPendName->pdn_pActReq = pActReq;
		pPendName->pdn_RemainingBroadcasts = NBP_NUM_BROADCASTS;
		AtalkTimerInitialize(&pPendName->pdn_Timer,
							 atalkNbpTimer,
							 NBP_BROADCAST_INTERVAL);
		if (Reason == FOR_CONFIRM)
			pPendName->pdn_ConfirmAddr = pNbpTuple->tpl_Address;

		else if (Reason == FOR_LOOKUP)
		{
			pPendName->pdn_pAMdl = pAMdl;
			pPendName->pdn_MdlLength = (USHORT)MdlLen;
			pPendName->pdn_TotalTuples = 0;
			pPendName->pdn_MaxTuples = MaxTuples;

			// If we are not doing a wild card search, restrict
			// the tuples to one so we get out early instead of
			// the max. time-out since we are never going to
			// fill the buffer
			if (!((pNbpTuple->tpl_Object[0] == '=')				||
				 (pNbpTuple->tpl_Type[0] == '=')				||
				 (pNbpTuple->tpl_Zone[0] == '=')				||
				 (AtalkSearchBuf(pNbpTuple->tpl_Object,
								pNbpTuple->tpl_ObjectLen,
								NBP_WILD_CHARACTER) != NULL)	||
				 (AtalkSearchBuf(pNbpTuple->tpl_Type,
								pNbpTuple->tpl_TypeLen,
								NBP_WILD_CHARACTER) != NULL)	||
				 (AtalkSearchBuf(pNbpTuple->tpl_Zone,
								pNbpTuple->tpl_ZoneLen,
								NBP_WILD_CHARACTER) != NULL)))
			{
				pPendName->pdn_MaxTuples = 1;
			}
		}

		// We're going to send a directed lookup for confirms, or either a
		// broadcast request or a lookup for registers or lookup depending
		// on whether we know about a router or not. We do not have to bother
		// checking the registered names list, for register, in our node
		// because the broadcast will eventually get to us and we'll handle
		// it then ! Request packet, with one tuple

		if (Reason == FOR_CONFIRM)	// Send to confirming node
			((PNBPHDR)(pPendName->pdn_Datagram))->_CmdAndTupleCnt =
											(NBP_LOOKUP << 4) + 1;
		else if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
			((PNBPHDR)(pPendName->pdn_Datagram))->_CmdAndTupleCnt =
											(NBP_BROADCAST_REQUEST << 4) + 1;
		else ((PNBPHDR)(pPendName->pdn_Datagram))->_CmdAndTupleCnt =
											(NBP_LOOKUP << 4) + 1;

		pPendName->pdn_DatagramLength = sizeof(NBPHDR) +
					atalkNbpEncodeTuple(&pPendName->pdn_pRegdName->rdn_Tuple,
										NULL,
										0,
										// NAMESINFORMATION_SOCKET,
										LAST_DYNAMIC_SOCKET,
										pPendName->pdn_Datagram + sizeof(NBPHDR));
		// Alloc an Nbp Id and an enumerator and link it into the list
		atalkNbpLinkPendingNameInList(pDdpAddr, pPendName);

		((PNBPHDR)(pPendName->pdn_Datagram))->_NbpId = (BYTE)(pPendName->pdn_NbpId);

		AtalkTimerScheduleEvent(&pPendName->pdn_Timer);

		atalkNbpSendRequest(pPendName);

		atalkNbpDerefPendName(pPendName);		// We are done now.

		Status = ATALK_PENDING;
	} while (FALSE);

	return Status;
}


/***	AtalkNbpRemove
 *
 */
ATALK_ERROR
AtalkNbpRemove(
	IN	PDDP_ADDROBJ	pDdpAddr,
	IN	PNBPTUPLE		pNbpTuple,
	IN	PACTREQ			pActReq
)
{
	PREGD_NAME	pRegdName, *ppRegdName;
	KIRQL		OldIrql;
	ATALK_ERROR	Status = ATALK_INVALID_PARAMETER;

	do
	{
		// Remove a registered NBP name. Zone must either be NULL or "*"
		if ((pNbpTuple->tpl_ObjectLen == 0) ||
			(pNbpTuple->tpl_ObjectLen > MAX_ENTITY_LENGTH) ||
			(pNbpTuple->tpl_TypeLen == 0) ||
			(pNbpTuple->tpl_TypeLen > MAX_ENTITY_LENGTH))
			break;
	
		if (pNbpTuple->tpl_ZoneLen == 0)
		{
			pNbpTuple->tpl_ZoneLen = 1;
			pNbpTuple->tpl_Zone[0] = '*';
		}
		else
		{
			if ((pNbpTuple->tpl_ZoneLen != 1) ||
				(pNbpTuple->tpl_Zone[0] != '*'))
				break;
		}
	
		if ((pNbpTuple->tpl_Object[0] == '=') || (pNbpTuple->tpl_Type[0] == '=') ||
			AtalkSearchBuf(pNbpTuple->tpl_Object, pNbpTuple->tpl_ObjectLen, NBP_WILD_CHARACTER)  ||
			AtalkSearchBuf(pNbpTuple->tpl_Type, pNbpTuple->tpl_TypeLen, NBP_WILD_CHARACTER))
			break;
	
		// Search in the registered names list in the open socket
		// Lock down the structure first
		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	
		for (ppRegdName = &pDdpAddr->ddpao_RegNames;
			 (pRegdName = *ppRegdName) != NULL;
			 ppRegdName = &pRegdName->rdn_Next)
		{
			ASSERT (VALID_REGDNAME(pRegdName));
			if (AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Object,
												 pNbpTuple->tpl_ObjectLen,
												 pRegdName->rdn_Tuple.tpl_Object,
												 pRegdName->rdn_Tuple.tpl_ObjectLen) &&
				AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Type,
												 pNbpTuple->tpl_TypeLen,
												 pRegdName->rdn_Tuple.tpl_Type,
												 pRegdName->rdn_Tuple.tpl_TypeLen))
			{
				*ppRegdName = pRegdName->rdn_Next;
				break;
			}
		}
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	
		Status = ATALK_FAILURE;
		if (pRegdName != NULL)
		{
			AtalkFreeMemory(pRegdName);
			Status = ATALK_NO_ERROR;
		}
	} while (FALSE);

	AtalkUnlockNbpIfNecessary();
	(*pActReq->ar_Completion)(Status, pActReq);

	return (ATALK_PENDING);
}



/***	atalkNbpMatchWild
 *
 */
LOCAL BOOLEAN
atalkNbpMatchWild(
	IN	PBYTE	WildString,
	IN	BYTE	WildStringLen,
	IN	PBYTE	String,
	IN	BYTE	StringLen
)
/*++
	There are two kinds of wild card searches. An '=' by itself matches anything.
	Partial matches use the 'curly equals' or 0xC5. So representing that by the
	'=' character below.

	foo= will match any name which starts with foo.
	=foo will match any name which ends in foo.
	=foo= will match any name with foo in it.
	foo=bar will match any name that starts with foo and ends with bar.

--*/
{
        PBYTE   pTarget, pTokStr;
        int     TargetLen, TokStrLen;
	PBYTE	pWildCard, pCurStr, pCurWild;
	int		Len;
        int     i;
        BOOLEAN fWildCharPresent = FALSE;


        // first see if it's a 'match any' request
	if ((WildString[0] == 0) ||
		((WildString[0] == '=') && (WildStringLen == 1)))
		return TRUE;

        // now, check to see if there is any wild char in the requested name
        for (i=0; i<WildStringLen; i++)
        {
            if (WildString[i] == NBP_WILD_CHARACTER)
            {
                fWildCharPresent = TRUE;
                break;
            }
        }

        // if there is no wild character in the requested name, this is
        // a straight forward string compare!
        if (!fWildCharPresent)
        {
            if (WildStringLen != StringLen)
                return FALSE;

            if (SubStringMatch(WildString,String,StringLen,WildStringLen))
                return TRUE;
            else
                return FALSE;
        }


        // ok, now deal with the wild character mess

	pTarget = String;
	pTokStr = WildString;
        TargetLen = StringLen;

        while (WildStringLen > 0 && StringLen > 0)
        {
            // find length of substring until the next wild-char
            TokStrLen = GetTokenLen(pTokStr,WildStringLen,NBP_WILD_CHARACTER);

            if (TokStrLen > 0)
            {
                if (!SubStringMatch(pTarget,pTokStr,StringLen,TokStrLen))
                {
                    return (FALSE);
                }

                pTokStr += TokStrLen;
                WildStringLen -= (BYTE)TokStrLen;
                pTarget += TokStrLen;
                StringLen -= (BYTE)TokStrLen;
            }
            // the very first char was wild-char: skip over it
            else
            {
                pTokStr++;
                WildStringLen--;
            }
        }

        // if we survived all the checks, this string is a match!
	return (TRUE);
}


/***	atalkNbpEncodeTuple
 *
 */
LOCAL SHORT
atalkNbpEncodeTuple(
	IN	PNBPTUPLE	pNbpTuple,
	IN	PBYTE		pZone	OPTIONAL,	// Override zone
	IN	BYTE		ZoneLen OPTIONAL,	// Valid only if pZone != NULL
	IN	BYTE		Socket	OPTIONAL,
	OUT	PBYTE		pBuffer
)
{
	typedef struct
	{
		BYTE	_NetNum[2];
		BYTE	_Node;
		BYTE	_Socket;
		BYTE	_Enumerator;
	} HDR, *PHDR;
	SHORT		Len = sizeof(HDR);

	if (pZone == NULL)
	{
		pZone = pNbpTuple->tpl_Zone;
		ZoneLen = pNbpTuple->tpl_ZoneLen;
	}

	PUTSHORT2SHORT(((PHDR)pBuffer)->_NetNum, pNbpTuple->tpl_Address.ata_Network);
	((PHDR)pBuffer)->_Node = pNbpTuple->tpl_Address.ata_Node;
	((PHDR)pBuffer)->_Socket = pNbpTuple->tpl_Address.ata_Socket;
	if (Socket != 0)
		((PHDR)pBuffer)->_Socket = Socket;
	PUTSHORT2BYTE(&((PHDR)pBuffer)->_Enumerator, pNbpTuple->tpl_Enumerator);

	pBuffer += sizeof(HDR);

	*pBuffer++ = pNbpTuple->tpl_ObjectLen;
	RtlCopyMemory(pBuffer, pNbpTuple->tpl_Object, pNbpTuple->tpl_ObjectLen);
	pBuffer += pNbpTuple->tpl_ObjectLen;
	Len += (pNbpTuple->tpl_ObjectLen + 1);

	*pBuffer++ = pNbpTuple->tpl_TypeLen;
	RtlCopyMemory(pBuffer, pNbpTuple->tpl_Type, pNbpTuple->tpl_TypeLen);
	pBuffer += pNbpTuple->tpl_TypeLen;
	Len += (pNbpTuple->tpl_TypeLen + 1);

	*pBuffer++ = ZoneLen;
	RtlCopyMemory(pBuffer, pZone, ZoneLen);
	// pBuffer += ZoneLen;
	Len += (ZoneLen + 1);

	return (Len);
}


/***	atalkNbpDecodeTuple
 *
 */
LOCAL SHORT
atalkNbpDecodeTuple(
	IN	PBYTE		pBuffer,
	IN	USHORT		PktLen,
	OUT	PNBPTUPLE	pNbpTuple
)
{
	typedef struct
	{
		BYTE	_NetNum[2];
		BYTE	_Node;
		BYTE	_Socket;
		BYTE	_Enumerator;
	} HDR, *PHDR;
	SHORT		Len = 0;

	do
	{
		if (PktLen < MIN_NBP_TUPLELENGTH)
		{
			break;
		}

		GETSHORT2SHORT(&pNbpTuple->tpl_Address.ata_Network,
					   ((PHDR)pBuffer)->_NetNum);
		pNbpTuple->tpl_Address.ata_Node = ((PHDR)pBuffer)->_Node;
		pNbpTuple->tpl_Address.ata_Socket = ((PHDR)pBuffer)->_Socket;
		GETBYTE2SHORT(&pNbpTuple->tpl_Enumerator,
						&((PHDR)pBuffer)->_Enumerator);
	
		// Get past the header
		pBuffer += sizeof(HDR);
		PktLen -= sizeof(HDR);
	
		Len = sizeof(HDR);

		pNbpTuple->tpl_ObjectLen = *pBuffer++;
		PktLen --;
		if ((pNbpTuple->tpl_ObjectLen > PktLen) ||
			(pNbpTuple->tpl_ObjectLen > MAX_ENTITY_LENGTH))
		{
			Len = 0;
			break;
		}
		RtlCopyMemory(pNbpTuple->tpl_Object, pBuffer, pNbpTuple->tpl_ObjectLen);
		pBuffer += pNbpTuple->tpl_ObjectLen;
		PktLen -= pNbpTuple->tpl_ObjectLen;
		Len += (pNbpTuple->tpl_ObjectLen + 1);
	
		if (PktLen == 0)
		{
			Len = 0;
			break;
		}
		pNbpTuple->tpl_TypeLen = *pBuffer++;
		PktLen --;
		if ((pNbpTuple->tpl_TypeLen > PktLen) ||
			(pNbpTuple->tpl_TypeLen > MAX_ENTITY_LENGTH))
		{
			Len = 0;
			break;
		}
		RtlCopyMemory(pNbpTuple->tpl_Type, pBuffer, pNbpTuple->tpl_TypeLen);
		pBuffer += pNbpTuple->tpl_TypeLen;
		PktLen -= pNbpTuple->tpl_TypeLen;
		Len += (pNbpTuple->tpl_TypeLen + 1);
	
		if (PktLen == 0)
		{
			Len = 0;
			break;
		}
		pNbpTuple->tpl_ZoneLen = *pBuffer++;
		PktLen --;
		if ((pNbpTuple->tpl_ZoneLen > PktLen) ||
			(pNbpTuple->tpl_ZoneLen > MAX_ENTITY_LENGTH))
		{
			Len = 0;
			break;
		}
		RtlCopyMemory(pNbpTuple->tpl_Zone, pBuffer, pNbpTuple->tpl_ZoneLen);
		Len += (pNbpTuple->tpl_ZoneLen + 1);
	} while (FALSE);

	return (Len);
}



/***	atalkNbpLinkPendingNameInList
 *
 */
LOCAL VOID
atalkNbpLinkPendingNameInList(
	IN		PDDP_ADDROBJ	pDdpAddr,
	IN OUT	PPEND_NAME		pPendName
)
{
	PATALK_NODE		pNode = pDdpAddr->ddpao_Node;
	KIRQL			OldIrql;

	ASSERT (VALID_PENDNAME(pPendName));

	ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);

	// Use the next consecutive values. If there are > 256 pending names on a node, we'll
	// end up re-using the ids and enums. Still ok unless all of them are of the form
	// =:=@=. Well lets just keep it simple.
	pPendName->pdn_NbpId = ++(pNode->an_NextNbpId);
	pPendName->pdn_pRegdName->rdn_Tuple.tpl_Enumerator = ++(pNode->an_NextNbpEnum);

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpLinkPendingNameInList: Linking PendingName %lx in socket %lx\n",
			pPendName, pDdpAddr));

	pPendName->pdn_Next = pDdpAddr->ddpao_PendNames;
	pDdpAddr->ddpao_PendNames = pPendName;

	RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);
}


/***	AtalkNbpCloseSocket
 *
 */
VOID
AtalkNbpCloseSocket(
	IN	PDDP_ADDROBJ	pDdpAddr
)
{
	PPEND_NAME	pPendName, *ppPendName;
	PREGD_NAME	pRegdName, *ppRegdName;
	KIRQL		OldIrql;

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	// Free the pending names from the open socket.
	for (ppPendName = &pDdpAddr->ddpao_PendNames;
		 (pPendName = *ppPendName) != NULL;
		 NOTHING)
	{
		ASSERT (VALID_PENDNAME(pPendName));
		if (pPendName->pdn_Flags & PDN_CLOSING)
		{
	        ppPendName = &pPendName->pdn_Next;
			continue;
		}

		pPendName->pdn_Flags |= PDN_CLOSING;
		pPendName->pdn_Status = ATALK_SOCKET_CLOSED;
		// Cancel outstanding timers on the pending names
		if (AtalkTimerCancelEvent(&pPendName->pdn_Timer, NULL))
		{
			atalkNbpDerefPendName(pPendName);
		}

		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

		ASSERT (pPendName->pdn_RefCount > 0);

		atalkNbpDerefPendName(pPendName);

		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	    ppPendName = &pDdpAddr->ddpao_PendNames;
	}

	// Free the registered names from the open socket.
	for (ppRegdName = &pDdpAddr->ddpao_RegNames;
		 (pRegdName = *ppRegdName) != NULL;
		 NOTHING)
	{
		ASSERT (VALID_REGDNAME(pRegdName));
		*ppRegdName = pRegdName->rdn_Next;
		AtalkFreeMemory(pRegdName);
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
}


/***	atalkNbpSendRequest
 *
 */
LOCAL BOOLEAN
atalkNbpSendRequest(
	IN	PPEND_NAME	pPendName
)
{
	PDDP_ADDROBJ		pDdpAddr;
	PBUFFER_DESC		pBuffDesc;
	ATALK_ADDR			DestAddr;
	ATALK_ADDR			SrcAddr;
	ATALK_ERROR			Status;
	PPORT_DESCRIPTOR	pPortDesc;
	SEND_COMPL_INFO		SendInfo;

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpSendRequest: Sending request for PendName %lx\n", pPendName));

	ASSERT(!(pPendName->pdn_Flags & PDN_CLOSING));

	pPortDesc = pPendName->pdn_pDdpAddr->ddpao_Node->an_Port;
	DestAddr.ata_Socket = NAMESINFORMATION_SOCKET;
	if (pPendName->pdn_Reason == FOR_CONFIRM)
	{
		DestAddr.ata_Network = pPendName->pdn_ConfirmAddr.ata_Network;
		DestAddr.ata_Node = pPendName->pdn_ConfirmAddr.ata_Node;
	}
	else
	{
		if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
		{
			DestAddr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
			DestAddr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		}
		else
		{
			DestAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
			DestAddr.ata_Node = ATALK_BROADCAST_NODE;
		}
	}

	SrcAddr.ata_Address = pPendName->pdn_pDdpAddr->ddpao_Addr.ata_Address;

	// SrcAddr.ata_Socket = NAMESINFORMATION_SOCKET;
	SrcAddr.ata_Socket = LAST_DYNAMIC_SOCKET;
	AtalkDdpReferenceByAddr(pPendName->pdn_pDdpAddr->ddpao_Node->an_Port,
							&SrcAddr,
							&pDdpAddr,
							&Status);

	if (!ATALK_SUCCESS(Status))
	{
		return FALSE;
	}

	if ((pBuffDesc = AtalkAllocBuffDesc(pPendName->pdn_Datagram,
										pPendName->pdn_DatagramLength,
										BD_CHAR_BUFFER)) == NULL)
	{
		AtalkDdpDereference(pDdpAddr);
		return FALSE;
	}

	ASSERT(pBuffDesc->bd_Length == pPendName->pdn_DatagramLength);
	ASSERT(pBuffDesc->bd_Length > 0);
	SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
	SendInfo.sc_Ctx1 = pBuffDesc;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	Status = AtalkDdpSend(pDdpAddr,
						  &DestAddr,
						  DDPPROTO_NBP,
						  FALSE,
						  pBuffDesc,
						  NULL,
						  0,
						  NULL,
						  &SendInfo);

	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
				("atalkNbpSendRequest: AtalkDdpSend Failed %lx\n", Status));
		AtalkFreeBuffDesc(pBuffDesc);
	}
	AtalkDdpDereference(pDdpAddr);

	return (ATALK_SUCCESS(Status));
}


/***	atalkNbpSendLookupDatagram
 *
 */
LOCAL VOID
atalkNbpSendLookupDatagram(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr OPTIONAL,
	IN	SHORT				NbpId,
	IN	PNBPTUPLE			pNbpTuple
)
{
	PBYTE			Datagram = NULL;
	BYTE			MulticastAddr[ELAP_ADDR_LEN];
	PBUFFER_DESC	pBuffDesc = NULL;
	BOOLEAN			DerefDdp = FALSE;
	ULONG			Len;
	ATALK_ADDR		Dst, Src;
	ATALK_ERROR		Status;
	SEND_COMPL_INFO	SendInfo;

	if (pDdpAddr == NULL)
	{
		Src.ata_Network = pPortDesc->pd_ARouter.atn_Network;
		Src.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		Src.ata_Socket = NAMESINFORMATION_SOCKET;

		AtalkDdpReferenceByAddr(pPortDesc, &Src, &pDdpAddr, &Status);
		if (!ATALK_SUCCESS(Status))
		{
			return;
		}
		DerefDdp = TRUE;
	}

	do
	{
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										sizeof(NBPHDR) + MAX_NBP_TUPLELENGTH,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
			break;

		Datagram = pBuffDesc->bd_CharBuffer;
		((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
		((PNBPHDR)Datagram)->_CmdAndTupleCnt = (NBP_LOOKUP << 4) + 1;
		Len = sizeof(NBPHDR) +
			  atalkNbpEncodeTuple(pNbpTuple,
								  NULL,
								  0,
								  0,
								  Datagram+sizeof(NBPHDR));

		Dst.ata_Node = ATALK_BROADCAST_NODE;
		Dst.ata_Socket = NAMESINFORMATION_SOCKET;

		if (EXT_NET(pPortDesc))
		{
			// Send to "0000FF" at correct zone multicast address
			Dst.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
			AtalkZipMulticastAddrForZone(pPortDesc,
										 pNbpTuple->tpl_Zone,
										 pNbpTuple->tpl_ZoneLen,
										 MulticastAddr);
		}
		else
		{
			// Send to "nnnnFF" as broadcast
			Dst.ata_Network = pPortDesc->pd_NetworkRange.anr_FirstNetwork;
		}

		//	Set the length in the buffer descriptor.
		AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)Len);

		ASSERT(pBuffDesc->bd_Length > 0);
		SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
		if (!ATALK_SUCCESS(Status = AtalkDdpSend(pDdpAddr,
												 &Dst,
												 DDPPROTO_NBP,
												 FALSE,
												 pBuffDesc,
												 NULL,
												 0,
												 MulticastAddr,
												 &SendInfo)))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
					("atalkNbpSendLookupDatagram: DdpSend failed %ld\n", Status));
			break;
		}
		Datagram = NULL;
		pBuffDesc = NULL;
	} while (FALSE);

	if (DerefDdp)
		AtalkDdpDereference(pDdpAddr);

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);
}


/***	atalkNbpSendForwardRequest
 *
 */
LOCAL VOID
atalkNbpSendForwardRequest(
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PRTE				pRte,
	IN	SHORT				NbpId,
	IN	PNBPTUPLE			pNbpTuple
)
{
	PBYTE			Datagram = NULL;
	PBUFFER_DESC	pBuffDesc = NULL;
	SEND_COMPL_INFO	SendInfo;
	ATALK_ERROR		ErrorCode;
	ULONG			Len;
	ATALK_ADDR		Dst;

	do
	{
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
											sizeof(NBPHDR) + MAX_NBP_TUPLELENGTH,
											BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
			break;

		Datagram = pBuffDesc->bd_CharBuffer;
		((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
		((PNBPHDR)Datagram)->_CmdAndTupleCnt = (NBP_FORWARD_REQUEST << 4) + 1;
		Len = sizeof(NBPHDR) +
			  atalkNbpEncodeTuple(pNbpTuple,
								  NULL,
								  0,
								  0,
								  Datagram+sizeof(NBPHDR));

		Dst.ata_Network = pRte->rte_NwRange.anr_FirstNetwork;
		Dst.ata_Node = ANY_ROUTER_NODE;
		Dst.ata_Socket = NAMESINFORMATION_SOCKET;

		//	Set the length in the buffer descriptor.
		AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)Len);

		ASSERTMSG("Dest in rte 0\n", Dst.ata_Network != CABLEWIDE_BROADCAST_NETWORK);

		ASSERT(pBuffDesc->bd_Length > 0);
		SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
        ErrorCode = AtalkDdpSend(pDdpAddr,
								 &Dst,
								 DDPPROTO_NBP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
					("atalkNbpSendForwardRequest: DdpSend failed %ld\n", ErrorCode));
			break;
		}
		Datagram = NULL;
		pBuffDesc = NULL;
	} while (FALSE);

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);
}


/***	atalkNbpDerefPendName
 *
 */
VOID
atalkNbpDerefPendName(
	IN	PPEND_NAME		pPendName
)
{
	PPEND_NAME	*	ppPendName;
	PDDP_ADDROBJ	pDdpAddr = pPendName->pdn_pDdpAddr;
	BOOLEAN			Unlink, Found = FALSE;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pPendName->pdn_Lock, &OldIrql);

	Unlink = (--(pPendName->pdn_RefCount) == 0);

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpDerefPendName: New Count %d\n", pPendName->pdn_RefCount));

	RELEASE_SPIN_LOCK(&pPendName->pdn_Lock, OldIrql);

	if (!Unlink)
		return;

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpDerefPendName: Unlinking pPendName\n"));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	for (ppPendName = &pDdpAddr->ddpao_PendNames;
		 *ppPendName != NULL;
		 ppPendName = &(*ppPendName)->pdn_Next)
	{
		if (*ppPendName == pPendName)
		{
			*ppPendName = pPendName->pdn_Next;
			Found = TRUE;
			break;
		}
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

	if (Found)
	{
		AtalkDdpDereference(pDdpAddr);
	}
	else ASSERTMSG("atalkNbpDerefPendName: Could not find\n", 0);

	AtalkUnlockNbpIfNecessary();
	(*pPendName->pdn_pActReq->ar_Completion)(pPendName->pdn_Status, pPendName->pdn_pActReq);
	if (pPendName->pdn_Flags & PDN_FREE_REGDNAME)
		AtalkFreeMemory(pPendName->pdn_pRegdName);
	AtalkFreeMemory(pPendName);
}


/***	atalkNbpSendComplete
 *
 */
VOID FASTCALL
atalkNbpSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
)
{
	PBUFFER_DESC	pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx1);

	if (!ATALK_SUCCESS(Status))
		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
				("atalkNbpSendComplete: Failed %lx, pBuffDesc %lx\n",
				Status, pBuffDesc));

	AtalkFreeBuffDesc(pBuffDesc);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\lists.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	lists.h

Abstract:

	This module contains the macros for managing lists

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Oct 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _LISTS_
#define _LISTS_

#define	AtalkLinkDoubleAtHead(_pHead, _p, Next, Prev)		\
	{														\
		(_p)->Next = (_pHead);								\
		(_p)->Prev = &(_pHead);								\
		if ((_pHead) != NULL)								\
		(_pHead)->Prev = &(_p)->Next;						\
			(_pHead) = (_p);								\
	}

#define	AtalkLinkDoubleAtEnd(_pThis, _pLast, Next, Prev)	\
	{														\
		(_pLast)->Next = (_pThis);							\
		(_pThis)->Prev = &(_pLast)->Next;					\
		(_pThis)->Next = NULL;								\
	}

#define	AtalkInsertDoubleBefore(_pThis, _pBefore, Next, Prev)\
	{														\
		(_pThis)->Next = (_pBefore);						\
		(_pThis)->Prev = (_pBefore)->Prev;					\
		(_pBefore)->Prev = &(_pThis)->Next;					\
		*((_pThis)->Prev) = (_pThis);						\
	}

#define	AtalkUnlinkDouble(_p, Next, Prev)					\
	{														\
		*((_p)->Prev) = (_p)->Next;							\
		if ((_p)->Next != NULL)								\
			(_p)->Next->Prev = (_p)->Prev;					\
	}

#endif	// _LISTS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\ddp.h ===
/*+++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ddp.h

Abstract:

	This module contains the DDP address object and ddp related definitions

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_DDP_
#define	_DDP_

// Network number information.
#define FIRST_VALID_NETWORK			0x0001
#define LAST_VALID_NETWORK			0xFFFE
#define FIRST_STARTUP_NETWORK		0xFF00
#define LAST_STARTUP_NETWORK		0xFFFE
#define NULL_NETWORK				0x0000
#define UNKNOWN_NETWORK				NULL_NETWORK
#define CABLEWIDE_BROADCAST_NETWORK	NULL_NETWORK

//	Appletalk Sockets Definitions
#define UNKNOWN_SOCKET				0
#define	DYNAMIC_SOCKET				UNKNOWN_SOCKET
#define LAST_VALID_SOCKET			254
#define FIRST_DYNAMIC_SOCKET		128
#define LAST_DYNAMIC_SOCKET			LAST_VALID_SOCKET
#define FIRST_STATIC_SOCKET			1
#define FIRST_VALID_SOCKET			FIRST_STATIC_SOCKET
#define LAST_STATIC_SOCKET			127

// "Well known" sockets:
#define RTMP_SOCKET					1		// RTMP
#define NAMESINFORMATION_SOCKET		2		// NBP
#define ECHOER_SOCKET				4		// EP
#define ZONESINFORMATION_SOCKET		6		// ZIP

#define LAST_APPLE_RESD_SOCKET		0x3F	// Apple reserves 1 thru 0x3F

//	DDP Datagram Definitions
#define MAX_DGRAM_SIZE				586
#define MAX_LDDP_PKT_SIZE			600		// Really 599, but even is nicer
#define MAX_SDDP_PKT_SIZE			592		// Again, really 591

//	Define temporary buffer sizes, these must be big enough to hold both all
//	of the packet data plus any link/hardware headers...
#define MAX_PKT_SIZE				(MAX_HDR_LEN + MAX_LDDP_PKT_SIZE)

#define DDP_LEN_MASK1				0x03	// High order 3 bits of length
#define DDP_LEN_MASK2				0xFF	// Next byte of length

// DDP packet offsets (skipping Link/Hardware headers):
#define SDDP_HDR_LEN				5

#define SDDP_LEN_OFFSET				0
#define SDDP_DEST_SOCKET_OFFSET		2
#define SDDP_SRC_SOCKET_OFFSET		3
#define SDDP_PROTO_TYPE_OFFSET		4
#define SDDP_DGRAM_OFFSET			5

#define LDDP_HDR_LEN				13

#define LDDP_LEN_OFFSET				0
#define LDDP_CHECKSUM_OFFSET		2
#define LDDP_DEST_NETWORK_OFFSET	4
#define LDDP_SRC_NETWORK_OFFSET		6
#define LDDP_DEST_NODE_OFFSET		8
#define LDDP_SRC_NODE_OFFSET		9
#define LDDP_DEST_SOCKET_OFFSET		10
#define LDDP_SRC_SOCKET_OFFSET		11
#define LDDP_PROTO_TYPE_OFFSET		12
#define LDDP_DGRAM_OFFSET			13

#define LEADING_UNCHECKSUMED_BYTES	4
#define LDDP_HOPCOUNT_MASK			0x3C

#define DECIMAL_BASE    			10

// DDP protocol types:
#define	DDPPROTO_ANY				0	// Used to allow any protocol packet

#define DDPPROTO_DDP    			0
#define DDPPROTO_RTMPRESPONSEORDATA 1
#define DDPPROTO_NBP				2
#define DDPPROTO_ATP				3
#define DDPPROTO_EP					4
#define DDPPROTO_RTMPREQUEST		5
#define DDPPROTO_ZIP				6
#define DDPPROTO_ADSP				7
#define DDPPROTO_MAX        		255

typedef	struct _DDPEVENT_INFO
{
	//	Event handler routines: DDP Only has RecvDatagram/Error handlers

	//	The following function pointer always points to a TDI_IND_RECEIVE_DATAGRAM
	//	event handler for the address.
	PTDI_IND_RECEIVE_DATAGRAM	ev_RcvDgramHandler;
	PVOID						ev_RcvDgramCtx;

	// The following function pointer always points to a TDI_IND_ERROR
	// handler for the address.
	PTDI_IND_ERROR				ev_ErrHandler;
	PVOID						ev_ErrCtx;
	PVOID						ev_ErrOwner;

	//	Winsock assumes a buffering transport. So we buffer the last datagram
	//	indicated that was not accepted.
	BYTE						ev_IndDgram[MAX_DGRAM_SIZE];
	int							ev_IndDgramLen;
	int							ev_IndProto;

	//	Source address of buffered datagram
	ATALK_ADDR					ev_IndSrc;

} DDPEVENT_INFO, *PDDPEVENT_INFO;



//	Handler type for the DDP address object
typedef	VOID	(*DDPAO_HANDLER)(
					IN	PPORT_DESCRIPTOR	pPortDesc,
					IN	struct _DDP_ADDROBJ *pAddr,
					IN	PBYTE				pPkt,
					IN	USHORT				pPktLen,
					IN	PATALK_ADDR			pSrcAddr,
					IN	PATALK_ADDR			pActDest,
					IN	ATALK_ERROR			ErrorCode,
					IN	BYTE				pDdpType,
					IN	PVOID				pHandlerCtx,
					IN	BOOLEAN				OptimizedPath,
					IN	PVOID				OptimizeCtx);

//	DDP Address Object
//	This is the basic address object in the stack. All other address objects
//	eventually resolve to this one. It also holds the AppletalkSocket opened
//	as its actual address. One address object corresponds to one address.

//	DDP ADDRESS OBJECT	STATES
#define	DDPAO_DGRAM_EVENT		0x00000001
#define	DDPAO_DGRAM_ACTIVE		0x00000002
#define	DDPAO_DGRAM_PENDING		0x00000004
#define DDPAO_SOCK_INTERNAL     0x00000008
#define DDPAO_SOCK_PNPZOMBIE    0x00000010
#define	DDPAO_CLOSING			0x80000000


#define	DDPAO_SIGNATURE			(*(PULONG)"DDPA")
#define	VALID_DDP_ADDROBJ(pDdpAddr)	(((pDdpAddr) != NULL) &&	\
			(((struct _DDP_ADDROBJ *)(pDdpAddr))->ddpao_Signature == DDPAO_SIGNATURE))
typedef struct _DDP_ADDROBJ
{
	ULONG					ddpao_Signature;

	//	This will be a hash overflow list. Hash on the internet address.
	//	List of address objects on the node linkage
	struct _DDP_ADDROBJ	*	ddpao_Next;

	ULONG					ddpao_RefCount;

	//	State of the address object
	ULONG					ddpao_Flags;

	//	Backpointer to the node on which this socket exists
	struct _ATALK_NODE	 *	ddpao_Node;

	//	The Appletalk address number for this object
	ATALK_ADDR				ddpao_Addr;

	//	List of NBP names registered on this socket
	struct _REGD_NAME	*	ddpao_RegNames;

	//	List of NBP names being looked up, registered or confirmed on
	//	this socket.
	struct _PEND_NAME	*	ddpao_PendNames;

	//	Linked list of pending ddp reads
	LIST_ENTRY				ddpao_ReadLinkage;

	//	The protocol type to use for datagrams sent on this socket and
	//	which can be received on this socket. 0 => no restrictions.
	BYTE					ddpao_Protocol;

	ATALK_SPIN_LOCK			ddpao_Lock;
	PATALK_DEV_CTX			ddpao_DevCtx;

	//	The handler below is an listener for the upper layers. Note that
	//	this will take precedence over a incoming datagram event handler
	//	which would be set in ddpao_EventInfo.
	DDPAO_HANDLER			ddpao_Handler;
	PVOID					ddpao_HandlerCtx;

	//	This structure is allocated when setting an event handler
	//	on this socket. All the event handler addresses are part of this
	//	structure.
	PDDPEVENT_INFO			ddpao_EventInfo;

	//	Completion routine to be called when socket is closed
	GENERIC_COMPLETION		ddpao_CloseComp;
	PVOID					ddpao_CloseCtx;
} DDP_ADDROBJ, *PDDP_ADDROBJ;

//	Receive datagram completion: This will return the mdl we pass in along
//	with the received length written into the mdl. Also, the protocol type
//	and the RemoteAddress are passed back. The receive context will be the
//	irp for the request. As will be the send context.
typedef	VOID	(*RECEIVE_COMPLETION)(
						IN	ATALK_ERROR			ErrorCode,
						IN	PAMDL				OpaqueBuffer,
						IN	USHORT          	LengthReceived,
						IN	PATALK_ADDR			RemoteAddress,
						IN	PVOID				ReceiveContext);

typedef	VOID	(FASTCALL *WRITE_COMPLETION)(
						IN	NDIS_STATUS			Status,
						IN	PVOID				Ctx);

typedef	VOID	(FASTCALL *TRANSMIT_COMPLETION)(
						IN	NDIS_STATUS			Status,
						IN	struct _SEND_COMPL_INFO	*	pInfo);

//	If the above routine was set in the AtalkDdpSend(), then
//	then context values would be:
//	Ctx1 = pddp address object
//	Ctx2 = pbuffer descriptor
//	Ctx3 = Only for DdpWrite calls, this will be a pointer to the
//			write structure enqueued in the ddp address object.
//
//	If the above routine was set in the AtalkDdpTransmit(), then
//	the context values would be (as specified by the client of
//	course):
//	Ctx1 = pport descriptor
//	Ctx2 = pbuffer descriptor
//	Ctx3 = not used.
//
//	These are only suggested ideas, but probably is what the internal
//	stack routines will use.

//	This is used to store a pending read on a particular socket.
typedef struct _DDP_READ
{
	//	Linkage chain for reads on a socket.
	LIST_ENTRY			dr_Linkage;

	PAMDL				dr_OpBuf;
	USHORT				dr_OpBufLen;

	RECEIVE_COMPLETION	dr_RcvCmp;
	PVOID				dr_RcvCtx;

} DDP_READ, *PDDP_READ;


//	This is used to store a pending write on a particular socket
//	DDP will create a buffer descriptor for the header
//	and will chain it in front of the buffer descriptor passed in.
//	A pointer to this structure will then be passed as a completion
//	context to DdpSend.
typedef struct _DDP_WRITE
{
	//	Linkage chain for writes on a socket.
	LIST_ENTRY		dw_Linkage;

	//	The buffer descriptor chain, including the ddp buffer
	//	descriptor containing the ddp/optional/link headers.
	PBUFFER_DESC	dw_BufferDesc;

	//	Write completion
	//	This will be called with the context (which will be a pointer
	//	to the write irp) after the write completes.
	WRITE_COMPLETION	dw_WriteRoutine;
	PVOID				dw_WriteCtx;

} DDP_WRITE, *PDDP_WRITE;

//
//	CANCEL IRP Functionality for NT:
//
//	We have decided that if we receive a cancel irp for a particular request,
//	we will shutdown the file object associated with that request, whether it
//	be a connection object or an address object. This implies that the socket/
//	connection/listener will be closed, thus cancelling *all* pending requests.
//

ATALK_ERROR
AtalkDdpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN	OUT	PATALK_NODEADDR			pDesiredNode	OPTIONAL,
	IN		DDPAO_HANDLER			pSktHandler		OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					ProtoType		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ	*		pAddr);

ATALK_ERROR
AtalkDdpCloseAddress(
	IN	PDDP_ADDROBJ				pAddr,
	IN	GENERIC_COMPLETION			pCloseCmp	OPTIONAL,	
	IN	PVOID						pCloseCtx	OPTIONAL);

ATALK_ERROR
AtalkDdpPnPSuspendAddress(
	IN	PDDP_ADDROBJ			pDdpAddr);

ATALK_ERROR
AtalkDdpCleanupAddress(
	IN	PDDP_ADDROBJ				pAddr);

ATALK_ERROR
AtalkDdpInitCloseAddress(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pAtalkAddr);

ATALK_ERROR
AtalkInitDdpOpenStaticSockets(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN	OUT PATALK_NODE				pNode);

ATALK_ERROR
AtalkDdpReceive(
	IN		PDDP_ADDROBJ			pAddr,
	IN		PAMDL					pAmdl,
	IN		USHORT					AmdlLen,
	IN		ULONG					RecvFlags,
	IN		RECEIVE_COMPLETION		pRcvCmp,
	IN		PVOID					pRcvCtx);

ATALK_ERROR
AtalkDdpSend(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PATALK_ADDR					DestAddr,
	IN	BYTE						ProtoType,
	IN	BOOLEAN						DefinitelyRemoteAddr,
	IN	PBUFFER_DESC				pBufDesc,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	PBYTE						pZoneMcastAddr	OPTIONAL,
	IN	struct _SEND_COMPL_INFO	*	pInfo			OPTIONAL);

ATALK_ERROR
AtalkDdpTransmit(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					SrcAddr,
	IN	PATALK_ADDR					DestAddr,
	IN	BYTE						ProtoType,
	IN	PBUFFER_DESC				pBufDesc,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	USHORT						HopCnt,
	IN	PBYTE						pMcastAddr		OPTIONAL,	
	IN	PATALK_NODEADDR				pXmitDestNode	OPTIONAL,
	IN	struct _SEND_COMPL_INFO	*	pInfo			OPTIONAL);

VOID
AtalkDdpSendComplete(
	IN	NDIS_STATUS					Status,
	IN	PBUFFER_DESC				pBufDesc,
	IN	struct _SEND_COMPL_INFO	*	pInfo			OPTIONAL);

VOID
AtalkDdpPacketIn(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBYTE						pLinkHdr,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
    IN  BOOLEAN                     fWanPkt);

VOID
AtalkDdpQuery(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PAMDL						pAmdl,
	OUT	PULONG						BytesWritten);

VOID
AtalkDdpRefByAddr(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PATALK_ADDR				pAtalkAddr,
	OUT		PDDP_ADDROBJ	*		ppDdpAddr,
	OUT		PATALK_ERROR			pErr);

VOID
AtalkDdpRefByAddrNode(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PATALK_ADDR				pAtalkAddr,
	IN		PATALK_NODE				pAtalkNode,
	OUT		PDDP_ADDROBJ	*		ppDdpAddr,
	OUT		PATALK_ERROR			pErr);

VOID
AtalkDdpRefNextNc(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PDDP_ADDROBJ	*			ppDdpAddr,
	OUT	PATALK_ERROR				pErr);

VOID FASTCALL
AtalkDdpDeref(
	IN	OUT		PDDP_ADDROBJ		pDdpAddr,
	IN			BOOLEAN				AtDpc);

VOID
AtalkDdpOutBufToNodesOnPort(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pSrc,
	IN	PATALK_ADDR					pDest,
	IN	BYTE						ProtoType,
	IN	PBUFFER_DESC				pBufDesc,
	IN	PBYTE						pOptHdr,
	IN	USHORT						OptHdrLen,
	OUT	PBOOLEAN					Delivered);

VOID
AtalkDdpInPktToNodesOnPort(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pDest,
	IN	PATALK_ADDR					pSrc,
	IN	BYTE						ProtoType,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
	OUT	PBOOLEAN					Routed);

VOID
AtalkDdpInvokeHandlerBufDesc(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PDDP_ADDROBJ			pDdpAddr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		PATALK_ADDR				pActDest,
	IN		BYTE					ProtoType,
	IN		PBUFFER_DESC			pBufDesc,
	IN		PBYTE					pOptHdr,
	IN		USHORT					OptHdrLen);

VOID
AtalkDdpInvokeHandler(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PDDP_ADDROBJ			pDdpAddr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		PATALK_ADDR				pActDest,
	IN		BYTE					ProtoType,
	IN		PBYTE					pPkt,
	IN		USHORT					PktLen);

USHORT
AtalkDdpCheckSumBuffer(
	IN	PBYTE						Buffer,
	IN	USHORT						BufLen,
	IN	USHORT						CurrentCheckSum);

USHORT
AtalkDdpCheckSumBufferDesc(
	IN	PBUFFER_DESC				pBuffDesc,
	IN	USHORT						Offset);

USHORT
AtalkDdpCheckSumPacket(
	IN	PBYTE						pHdr,
	IN	USHORT						HdrLen,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen);

VOID
AtalkDdpNewHandlerForSocket(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	DDPAO_HANDLER				pSktHandler,
	IN	PVOID						pSktHandlerCtx);

//	MACROS
#define	DDP_MSB_LEN(L)			(((L) >> 8) & 0x03)
#define	DDP_GET_LEN(P)			((((*P) & 0x03) << 8) + *(P+1))
#define	DDP_GET_HOP_COUNT(P)	(((*P) >> 2) & 0x0F)
#define	DDP_HOP_COUNT(H)		(((H) & 0x0F) << 2)

#if DBG

#define	AtalkDdpReferenceByPtr(pDdpAddr, pErr)					\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, &OldIrql);	\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, OldIrql);	\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpReferenceByPtr: %s %d PostCount %d\n",\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
	}

#define	AtalkDdpReferenceByPtrDpc(pDdpAddr, pErr)				\
	{															\
		ACQUIRE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpReferenceByPtr: %s %d PostCount %d\n",\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
	}

#define	AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr)			\
	{															\
		ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));					\
																\
		*pErr = ATALK_DDP_CLOSING;								\
																\
		if ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) == 0)		\
		{														\
			pDdpAddr->ddpao_RefCount++;							\
			*pErr = ATALK_NO_ERROR;								\
		}														\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpReferenceByPtrNonInterlock: %s %d PostCount %d\n",\
				__FILE__, __LINE__,							\
				pDdpAddr->ddpao_RefCount));					\
	}

#define	AtalkDdpReferenceNextNc(pDdpAddr, ppDdpAddr, pErr)		\
	{															\
		AtalkDdpRefNextNc(pDdpAddr, ppDdpAddr, pErr);			\
		if (ATALK_SUCCESS(*pErr))								\
		{														\
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,			\
					("DdpRefNextNc : %s %d PostCount %d\n",		\
					__FILE__, __LINE__,							\
					(*ppDdpAddr)->ddpao_RefCount));				\
		}														\
	}

#define	AtalkDdpReferenceByAddr(pPortDesc, pAddr, ppDdpAddr, pErr)	\
	{															\
		AtalkDdpRefByAddr(pPortDesc, pAddr, ppDdpAddr, pErr);	\
		if (ATALK_SUCCESS(*pErr))								\
		{														\
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,			\
					("AtalkDdpReferenceByAddr: %s %d PostCount %d\n",\
					__FILE__, __LINE__,							\
					(*ppDdpAddr)->ddpao_RefCount));				\
		}														\
	}

#define	AtalkDdpDereference(pDdpAddr)							\
	{															\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpDereference: %s %d PreCount %d\n",	\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
		AtalkDdpDeref(pDdpAddr, FALSE);							\
	}

#define	AtalkDdpDereferenceDpc(pDdpAddr)						\
	{															\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpDereferenceDpc: %s %d PreCount %d\n",	\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
		AtalkDdpDeref(pDdpAddr, TRUE);							\
	}

#else
#define	AtalkDdpReferenceByPtr(pDdpAddr, pErr) 					\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, &OldIrql);	\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, OldIrql);	\
	}

#define	AtalkDdpReferenceByPtrDpc(pDdpAddr, pErr)				\
	{															\
		ACQUIRE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
	}

#define	AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr)			\
	{															\
		*pErr = ATALK_DDP_CLOSING;								\
																\
		if ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) == 0)		\
		{														\
			pDdpAddr->ddpao_RefCount++;							\
			*pErr = ATALK_NO_ERROR;								\
		}														\
	}

#define	AtalkDdpReferenceByAddr(pPortDesc, pAddr, ppDdpAddr, pErr) \
		AtalkDdpRefByAddr(pPortDesc, pAddr, ppDdpAddr, pErr)

#define	AtalkDdpReferenceNextNc(pDdpAddr, ppDdpAddr, pErr)		\
		AtalkDdpRefNextNc(pDdpAddr, ppDdpAddr, pErr)

#define	AtalkDdpDereference(pDdpAddr) 							\
		AtalkDdpDeref(pDdpAddr, FALSE)

#define	AtalkDdpDereferenceDpc(pDdpAddr) 						\
		AtalkDdpDeref(pDdpAddr, TRUE)
#endif

#define	NET_ON_NONEXTPORT(pPort)								\
			(pPort->pd_LtNetwork)

#define	NODE_ON_NONEXTPORT(pPort)								\
			(((pPort)->pd_Nodes != NULL) ?						\
				(pPort)->pd_Nodes->an_NodeAddr.atn_Node : 0)

ATALK_ERROR
atalkDdpAllocSocketOnNode(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN		PATALK_NODE				pAtalkNode,
	IN		DDPAO_HANDLER			pSktHandler	OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					ProtoType		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ			pDdpAddr);

VOID
atalkDdpInitCloseComplete(
	IN	ATALK_ERROR					Error,
	IN	PVOID						Ctx);

/*
PBRE
atalkDdpFindInBrc(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_NODEADDR				pDestNodeAddr);
*/
#define	atalkDdpFindInBrc(_pPortDesc, _Network, _ppBre)		\
{															\
	USHORT		index;										\
	KIRQL		OldIrql;									\
	PBRE		pBre;										\
															\
	index = (_Network) & (PORT_BRC_HASH_SIZE - 1);			\
															\
	ACQUIRE_SPIN_LOCK(&(_pPortDesc)->pd_Lock, &OldIrql);	\
															\
	for (pBre = (_pPortDesc)->pd_Brc[index];				\
		 pBre != NULL;										\
		 pBre = pBre->bre_Next)								\
	{														\
		if ((_Network) == pBre->bre_Network)				\
		{													\
			break;											\
		}													\
	}														\
															\
	RELEASE_SPIN_LOCK(&(_pPortDesc)->pd_Lock, OldIrql);		\
															\
 	*(_ppBre) = pBre;										\
}


BOOLEAN
atalkDdpFindAddrOnList(
	IN	PATALK_NODE					pAtalkNode,
	IN	ULONG						Index,
	IN	BYTE						Socket,
	OUT	PDDP_ADDROBJ	*			ppDdpAddr);

#define	IS_VALID_SOCKET(Socket)								\
			((Socket == DYNAMIC_SOCKET)			||			\
			 (Socket == LAST_DYNAMIC_SOCKET)	||			\
			 ((Socket >= FIRST_STATIC_SOCKET) &&			\
				(Socket <= LAST_STATIC_SOCKET)))

#endif	// _DDP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\node.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	node.c

Abstract:

	This module contains the Appletalk Node management code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	NODE


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkInitNodeCreateOnPort)
#pragma alloc_text(PAGEINIT, AtalkInitNodeAllocate)
#pragma alloc_text(PAGEINIT, AtalkInitNodeGetPramAddr)
#pragma alloc_text(PAGEINIT, AtalkInitNodeSavePramAddr)
#endif

ATALK_ERROR
AtalkInitNodeCreateOnPort(
	PPORT_DESCRIPTOR	pPortDesc,
	BOOLEAN				AllowStartupRange,
	BOOLEAN				RouterNode,
	PATALK_NODEADDR		NodeAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE			pNode;
	ATALK_ERROR			error = ATALK_NO_ERROR;
	ATALK_NODEADDR		desiredNode = { UNKNOWN_NETWORK, UNKNOWN_NODE};
	PWSTR				NodeName;
	KIRQL				OldIrql;

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	do
	{
		if ((pPortDesc->pd_Flags & PD_FINDING_NODE) == 0)
		{
			pPortDesc->pd_Flags |= PD_FINDING_NODE;
		}
		else
		{
			//	Return if we are already trying to find a node
			error = ATALK_NODE_FINDING;
			break;
		}
	
		//	We should not be here if we have already allocated a router node and the user nodes
		ASSERT(!RouterNode || ((pPortDesc->pd_Flags & PD_ROUTER_NODE) == 0));
		ASSERT ((pPortDesc->pd_Flags & (PD_ROUTER_NODE | PD_USER_NODE_1 | PD_USER_NODE_2))
				!= (PD_ROUTER_NODE | PD_USER_NODE_1 | PD_USER_NODE_2));
	
		//	On non-extended ports we only allow one node!  The theory being that some
		//	LocalTalk cards are too smart for their own good and have a concept of
		//	their "source node number" and thus only support one node, also on
		//	non-extended ports, nodes are scarse.
		if (!EXT_NET(pPortDesc))
		{
			//	For a localtalk node we do things differently.
			//	During initialization time, we would have obtained
			//	the address from the mac, that will be the node
			//	address.

			ASSERT(pPortDesc->pd_Flags & PD_BOUND);
			ASSERT(pPortDesc->pd_AlapNode != 0);

			//	This needs to be initialized to UNKNOWN_NETWORK or obtained
			//	from the net during initialization.
			ASSERT(pPortDesc->pd_NetworkRange.anr_FirstNetwork == UNKNOWN_NETWORK);

			if (!ATALK_SUCCESS((error = AtalkInitNodeAllocate(pPortDesc, &pNode))))
			{
				LOG_ERRORONPORT(pPortDesc,
				                EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
				break;
			}

			// 	Use the allocated structure to set the info.
			//	Thread this into the port structure.
			pPortDesc->pd_LtNetwork =
			pNode->an_NodeAddr.atn_Network =
								pPortDesc->pd_NetworkRange.anr_FirstNetwork;
			pNode->an_NodeAddr.atn_Node = (BYTE)pPortDesc->pd_AlapNode;

			//	Reference the port for this node.
			AtalkPortReferenceByPtrNonInterlock(pPortDesc, &error);
			if (!ATALK_SUCCESS(error))
			{
				AtalkFreeMemory(pNode);
				break;
			}

			//	Now put it in the port descriptor
			pNode->an_Next = pPortDesc->pd_Nodes;
			pPortDesc->pd_Nodes = pNode;
		}
		else
		{
			//	Use PRAM values if we have them
			if (RouterNode)
			{
	            NodeName = ROUTER_NODE_VALUE;
				if (pPortDesc->pd_RoutersPramNode.atn_Network != UNKNOWN_NETWORK)
				{
					desiredNode = pPortDesc->pd_RoutersPramNode;
				}
			}
			else
			{
				if ((pPortDesc->pd_Flags & PD_USER_NODE_1) == 0)
				{
	                NodeName = USER_NODE1_VALUE;
	                if (pPortDesc->pd_UsersPramNode1.atn_Network != UNKNOWN_NETWORK)
					{
						//	If we are not a router node, and the first user node
						//	has not been allocated...
						desiredNode = pPortDesc->pd_UsersPramNode1;
					}
				}
				else if ((pPortDesc->pd_Flags & PD_USER_NODE_2) == 0)
				{
	                NodeName = USER_NODE2_VALUE;
	                if (pPortDesc->pd_UsersPramNode2.atn_Network != UNKNOWN_NETWORK)
					{
						//	If we are not a router node, and the second user node
						//	has not been allocated...
						desiredNode = pPortDesc->pd_UsersPramNode2;
					}
				}
			}

			//	Flags should be set so future get node requests return failure
			//	until we are done with this attempt. We need to call
			//	the aarp routines without the lock held - they will
			//	block.

			ASSERT(pPortDesc->pd_Flags & PD_FINDING_NODE);

			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

			//	If this routine succeeds in finding the node, it
			//	will chain in the atalkNode into the port. It also
			//	returns with the proper flags set/reset in the
			//	pPortDesc structure. It will also have referenced the port
			//	and inserted the node into the port's node list.
			error = AtalkInitAarpForNodeOnPort(pPortDesc,
											   AllowStartupRange,
											   desiredNode,
											   &pNode);

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

			if (!ATALK_SUCCESS(error))
			{
				//	AARP for node failed.
				LOG_ERRORONPORT(pPortDesc,
				                EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
			}
		}

	} while (FALSE);

	//	Ok, done finding node. No need for a crit section.
	pPortDesc->pd_Flags &= ~PD_FINDING_NODE;

	if (ATALK_SUCCESS(error))
	{
		//	If router node, remember it in port descriptor
		//	Do this before setting up the rtmp/nbp listeners.
		//	In anycase, clients must check this value for null,
		//	not guaranteed as zip socket could already be open.
		if (RouterNode)
			pPortDesc->pd_RouterNode = pNode;

		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		//	Setup the RTMP, NBP and EP listeners on this node.
		//	These will be the non-router versions. StartRouting
		//	calls will then switch them to be the router versions
		//	at the appropriate time.
	
		error = AtalkInitDdpOpenStaticSockets(pPortDesc, pNode);
	
		if (ATALK_SUCCESS(error))
		{
			if (EXT_NET(pPortDesc))
			{
				//	We always save this address.
				AtalkInitNodeSavePramAddr(pPortDesc,
										  NodeName,
										  &pNode->an_NodeAddr);
			}
			
			// 	Return the address of the node opened.
			if (NodeAddr != NULL)
				*NodeAddr = pNode->an_NodeAddr;
		}
		else
		{
			//	Error opening sockets. Release node, return failure
			LOG_ERRORONPORT(pPortDesc,
			                EVENT_ATALK_NODE_OPENSOCKETS,
							0,
							NULL,
							0);
			AtalkNodeReleaseOnPort(pPortDesc, pNode);
		}
	}
	else
	{
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	}

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_INFO,
				("Creation node on port %lx failed! %lx\n",
				pPortDesc,  error));
	}
	else
	{
		DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_INFO,
				("Creation node on port %lx with addr %lx.%lx and p%lx\n",
				pPortDesc,  pNode->an_NodeAddr.atn_Network,
				pNode->an_NodeAddr.atn_Node, pNode));
	}

	return(error);
}




ATALK_ERROR
AtalkNodeReleaseOnPort(
	PPORT_DESCRIPTOR	pPortDesc,
	PATALK_NODE			pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ	pDdpAddr, pNextAddr;
	ATALK_ERROR	error;
	KIRQL			OldIrql;
	SHORT			i;

	DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_WARN,
			("AtalkNodeReleaseOnPort: Releasing node %lx on port %lx!\n", pNode, pPortDesc));

	ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);

	if ((pNode->an_NodeAddr.atn_Network == AtalkUserNode1.atn_Network) &&
		(pNode->an_NodeAddr.atn_Node == AtalkUserNode1.atn_Node))
	{
		pPortDesc->pd_Flags &= ~PD_USER_NODE_1;
		AtalkUserNode1.atn_Network = 0;
		AtalkUserNode1.atn_Node = 0;
	}
	else if ((pNode->an_NodeAddr.atn_Network == AtalkUserNode2.atn_Network) &&
			 (pNode->an_NodeAddr.atn_Node == AtalkUserNode2.atn_Node))
	{
		pPortDesc->pd_Flags &= ~PD_USER_NODE_2;
		AtalkUserNode2.atn_Network = 0;
		AtalkUserNode2.atn_Node = 0;
	}

	if ((pNode->an_Flags & AN_CLOSING) == 0)
	{
		//	Set the closing flag.
		pNode->an_Flags |= AN_CLOSING;

		//	First close all the sockets on the node
		for (i = 0; i < NODE_DDPAO_HASH_SIZE; i++)
		{
			pNextAddr = NULL;
			AtalkDdpReferenceNextNc(pNode->an_DdpAoHash[i],
									&pDdpAddr,
									&error);

			if (!ATALK_SUCCESS(error))
			{
				//	Check the other hash table entries. No non-closing
				//	sockets on this list.
				continue;
			}
	
			while (TRUE)
			{
				//	Get the next non-closing node using our referenced node before
				//	closing it. Note we use pDdpAddr->...Flink.
				AtalkDdpReferenceNextNc(pDdpAddr->ddpao_Next,
										&pNextAddr,
										&error);
	
				//	Close the referenced ddp addr after releasing the node lock.
				RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

                if (pDdpAddr->ddpao_Flags & DDPAO_SOCK_INTERNAL)
                {
				    AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
                }
                else
                {
                    AtalkDdpPnPSuspendAddress(pDdpAddr);
                }

				//	Dereference the address.
				AtalkDdpDereference(pDdpAddr);

				ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);
	
				if (pNextAddr != NULL)
					pDdpAddr = pNextAddr;
				else
					break;
			}
		}

		RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

		//	Remove the creation reference for this node.
		AtalkNodeDereference(pNode);
	}
	else
	{
		//	We are already closing.
		RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);
	}

	return(ATALK_NO_ERROR);
}




BOOLEAN
AtalkNodeExistsOnPort(
	PPORT_DESCRIPTOR	pPortDesc,
	PATALK_NODEADDR		pNodeAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pCheckNode;
	BOOLEAN			exists = FALSE;


	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	for (pCheckNode = pPortDesc->pd_Nodes;
		 pCheckNode != NULL;
		 pCheckNode = pCheckNode->an_Next)
	{
		if (ATALK_NODES_EQUAL(&pCheckNode->an_NodeAddr, pNodeAddr))
		{
			exists = TRUE;
			break;
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return(exists);
}




VOID
AtalkInitNodeSavePramAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	OUT	PATALK_NODEADDR		pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	UNICODE_STRING	valueName;
	ULONG			bytesWritten;
	ULONG			ValueToSave;

	// Save the node value as xxxx00yy where xxxx is network, yy is node
	ValueToSave = (pNode->atn_Network << 16) + pNode->atn_Node;

	RtlInitUnicodeString (&valueName, RegValue);

	ZwSetValueKey(pPortDesc->pd_AdapterInfoHandle,
				  &valueName,
				  0,
				  REG_DWORD,
				  &ValueToSave,
				  sizeof(ULONG));
}




VOID
AtalkInitNodeGetPramAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	OUT	PATALK_NODEADDR		pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		Status;
	UNICODE_STRING	valueName;
	ULONG			bytesWritten;
	ULONG			ValueRead;
	BYTE			buffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 32];
	PKEY_VALUE_FULL_INFORMATION nodeValue = (PKEY_VALUE_FULL_INFORMATION)buffer;

	RtlInitUnicodeString (&valueName, RegValue);

	Status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 buffer,
							 sizeof(buffer),
							 &bytesWritten);
	if (NT_SUCCESS(Status))
	{
		ValueRead = *(PULONG)(buffer + nodeValue->DataOffset);
	}
	else
	{
		ValueRead = 0;
		ASSERT (UNKNOWN_NETWORK == 0);
		ASSERT (UNKNOWN_NODE == 0);
	}
	pNode->atn_Node = (BYTE)(ValueRead & 0xFF);
	pNode->atn_Network = (USHORT)(ValueRead >> 16);
	if ((pNode->atn_Network == UNKNOWN_NETWORK) ||
		(pNode->atn_Node == UNKNOWN_NODE))
	{
		pNode->atn_Node = UNKNOWN_NODE;
        pNode->atn_Network = UNKNOWN_NETWORK;
	}
}




VOID
AtalkZapPramValue(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue
)
{
	UNICODE_STRING	valueName;
	ULONG			bytesWritten;
	ULONG			ValueToSave;

	// Write 0 to the value to zap it for now.
	ValueToSave = 0;

	RtlInitUnicodeString (&valueName, RegValue);

	ZwSetValueKey(pPortDesc->pd_AdapterInfoHandle,
				  &valueName,
				  0,
				  REG_DWORD,
				  &ValueToSave,
				  sizeof(ULONG));
}


ATALK_ERROR
AtalkInitNodeAllocate(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	OUT PATALK_NODE			*ppNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pNode;

	// 	Allocate a new active Node structure
	if ((pNode = (PATALK_NODE)AtalkAllocZeroedMemory(sizeof(ATALK_NODE))) == NULL)
	{
		return(ATALK_RESR_MEM);
	}

	//	Initialize some elements of the structure. Remaining stuff
	//	done when the node is actually being inserted into the port
	//	hash table.
#if	DBG
	pNode->an_Signature = AN_SIGNATURE;
#endif

	// Initialize the Nbp Id & Enumerator
	pNode->an_NextNbpId = 0;
	pNode->an_NextNbpEnum = 0;
	pNode->an_NextDynSkt = FIRST_DYNAMIC_SOCKET;
	INITIALIZE_SPIN_LOCK(&pNode->an_Lock);
	pNode->an_Port = pPortDesc;			// Port on which node exists
	pNode->an_RefCount = 1;				// Reference for creation.

	//	Return pointer to allocated node
	*ppNode = pNode;

	return(ATALK_NO_ERROR);
}




VOID
AtalkNodeRefByAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		NodeAddr,
	OUT	PATALK_NODE		*	ppNode,
	OUT	PATALK_ERROR		pErr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE	pNode;
	KIRQL		OldIrql;
	BOOLEAN		foundNode = FALSE;

	*pErr = ATALK_NODE_NONEXISTENT;

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	for (pNode = pPortDesc->pd_Nodes; pNode != NULL; pNode = pNode->an_Next)
	{
		ASSERT(VALID_ATALK_NODE(pNode));

		//	Note: On non-extended ports, there should be only one pNode.
		if (((NodeAddr->atn_Network == CABLEWIDE_BROADCAST_NETWORK) 	||
			 (pNode->an_NodeAddr.atn_Network == NodeAddr->atn_Network)	||
			 (!EXT_NET(pPortDesc) && (pNode->an_NodeAddr.atn_Network == UNKNOWN_NETWORK)))

			&&

			((NodeAddr->atn_Node == ATALK_BROADCAST_NODE) ||
			 (pNode->an_NodeAddr.atn_Node == NodeAddr->atn_Node)))
		{
			DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_INFO,
					("AtalkNodeRefByAddr: Found: %lx.%lx for Lookup: %lx.%lx\n",
						pNode->an_NodeAddr.atn_Network, pNode->an_NodeAddr.atn_Node,
						NodeAddr->atn_Network, NodeAddr->atn_Node));

			foundNode = TRUE;
			break;
		}
	}

	if (foundNode)
	{
		AtalkNodeRefByPtr(pNode, pErr);

		// Return a pointer to the referenced node.
		if (ATALK_SUCCESS(*pErr))
		{
			ASSERT(ppNode != NULL);
			ASSERT(pNode != NULL);

			*ppNode = pNode;
		}
	}
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
}




VOID
AtalkNodeRefNextNc(
	IN	PATALK_NODE		pNode,
	IN	PATALK_NODE	*	ppNode,
	OUT	PATALK_ERROR	pErr
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE PORTLOCK HELD!

Arguments:


Return Value:


--*/
{
	*pErr = ATALK_FAILURE;
	*ppNode = NULL;
	for (; pNode != NULL; pNode = pNode->an_Next)
	{
		ASSERT(VALID_ATALK_NODE(pNode));

		AtalkNodeRefByPtr(pNode, pErr);
		if (ATALK_SUCCESS(*pErr))
		{
			//	Ok, this node is referenced!
			*ppNode = pNode;
			break;
		}
	}
}




VOID
AtalkNodeDeref(
	IN	OUT	PATALK_NODE	pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc = pNode->an_Port;
	KIRQL				OldIrql;
	BOOLEAN				done = FALSE;

	ASSERT(VALID_ATALK_NODE(pNode));

	ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);

	ASSERT(pNode->an_RefCount > 0);
	if (--pNode->an_RefCount == 0)
	{
		done = TRUE;
	}
	RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

	if (done)
	{
		PATALK_NODE	*ppNode;

		ASSERT((pNode->an_Flags & AN_CLOSING) != 0);

		DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_WARN,
				("AtalkNodeDeref: Freeing node %lx\n", pNode));

		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		//	Remove this guy from the port linkage
		for (ppNode = &pNode->an_Port->pd_Nodes;
			 *ppNode != NULL;
			 ppNode = &((*ppNode)->an_Next))
		{
			if (*ppNode == pNode)
			{
				*ppNode = pNode->an_Next;
				break;
			}
		}
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		//	Dereference the port for this node
		AtalkPortDereference(pPortDesc);

		//	Free the node structure
		AtalkFreeMemory(pNode);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\node.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	node.h

Abstract:

	This module contains support for the Appletalk Node structure.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_NODE_
#define	_NODE_

#define ANY_ROUTER_NODE		 		0
#define UNKNOWN_NODE				0
#define MAX_ATALK_NODES				256
#define MIN_USABLE_ATALKNODE  		1
#define MAX_USABLE_ATALKNODE  		254
#define MAX_EXT_ATALKNODE			253
#define HIGHEST_WORKSTATION_NODE	127
#define LOWEST_SERVER_NODE	  		128
#define ATALK_BROADCAST_NODE		((BYTE)0xFF)
#define	NUM_USER_NODES				2


//  NODE STATES
#define	AN_OPEN						0x01
#define	AN_ROUTER_NODE				0x02
#define	AN_ORPHAN_NODE				0x04
#define AN_CLOSING					0x80

// values under which pram nodes are stored
#define	ROUTER_NODE_VALUE			L"RouterPramNode"
#define	USER_NODE1_VALUE			L"UserPramNode1"
#define	USER_NODE2_VALUE			L"UserPramNode2"

//	Number of slots in the socket hash table stored per node
#define		NODE_DDPAO_HASH_SIZE	8

#define	AN_SIGNATURE			(*(PULONG)"ANOD")
#if	DBG
#define	VALID_ATALK_NODE(pNode)	(((pNode) != NULL) &&	\
								 ((pNode)->an_Signature == AN_SIGNATURE))
#else
#define	VALID_ATALK_NODE(pNode)	((pNode) != NULL)
#endif
typedef struct _ATALK_NODE
{

#if DBG
	ULONG					an_Signature;
#endif

	//	List for all active nodes on a port
	struct _ATALK_NODE *	an_Next;

	ULONG  					an_RefCount;

	//	Backpointer to the port for this node
	struct _PORT_DESCRIPTOR	*an_Port;

	//  State of the node
	BYTE 					an_Flags;

	//	Next dynamic socket number to create on this node.
	BYTE					an_NextDynSkt;

	//	Nbp Id & Enumerator to use on the next NbpAction
	BYTE					an_NextNbpId;
	BYTE					an_NextNbpEnum;

	//	Hash List of ddp address objects (accessed by the
	//	Appletalk socket address) on this node
	struct _DDP_ADDROBJ	*	an_DdpAoHash[NODE_DDPAO_HASH_SIZE];

	//	Address of this node
	ATALK_NODEADDR			an_NodeAddr;

	//	Lock
	ATALK_SPIN_LOCK			an_Lock;
} ATALK_NODE, *PATALK_NODE;

//	Exports

VOID
AtalkNodeRefByAddr(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN  PATALK_NODEADDR     	pNodeAddr,
	OUT	PATALK_NODE			*	pNode,
	OUT	PATALK_ERROR			pErr
);

// VOID
// AtalkNodeRefByPtr(
// 	IN	OUT	PATALK_NODE			Node,
// 	OUT		PATALK_ERROR		pErr
// );
#define	AtalkNodeRefByPtr(_pNode, _pErr)				\
	{													\
		KIRQL	OldIrql;								\
														\
		ASSERT(VALID_ATALK_NODE(_pNode));				\
														\
		ACQUIRE_SPIN_LOCK(&(_pNode)->an_Lock, &OldIrql);\
		AtalkNodeRefByPtrNonInterlock(_pNode, _pErr);	\
		RELEASE_SPIN_LOCK(&(_pNode)->an_Lock, OldIrql);	\
	}

// VOID
// AtalkNodeRefByPtrNonInterlock(
//	IN	OUT	PATALK_NODE			Node,
//	OUT		PATALK_ERROR		pErr
// );

#define	AtalkNodeRefByPtrNonInterlock(_pNode, _pErr)	\
	{													\
		ASSERT(VALID_ATALK_NODE(_pNode));				\
														\
		if (((_pNode)->an_Flags & AN_CLOSING) == 0)		\
		{												\
			(_pNode)->an_RefCount++;					\
			*(_pErr) = ATALK_NO_ERROR;					\
		}												\
		else											\
		{												\
			*(_pErr) = ATALK_NODE_CLOSING;				\
			DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_WARN,		\
					("AtalkNodeRefByPtrNonInterlock: Attempt to ref a closing node %lx (%x.%x)\n",\
					_pNode, (_pNode)->an_NodeAddr.atn_Network, (_pNode)->an_NodeAddr.atn_Node));\
		}												\
	}

VOID
AtalkNodeRefNextNc(
	IN	PATALK_NODE				pNode,
	IN	PATALK_NODE		*		ppNode,
	OUT	PATALK_ERROR			pErr
);

VOID
AtalkNodeDeref(
	IN	OUT	PATALK_NODE			pNode
);

ATALK_ERROR
AtalkInitNodeCreateOnPort(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  BOOLEAN					AllowStartupRange,
	IN  BOOLEAN					RouterNode,
	IN  PATALK_NODEADDR			pNodeAddr
);

ATALK_ERROR
AtalkNodeReleaseOnPort(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PATALK_NODE				pNode
);

BOOLEAN
AtalkNodeExistsOnPort(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PATALK_NODEADDR			pNodeAddr
);

ATALK_ERROR
AtalkInitNodeAllocate(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	OUT PATALK_NODE			*	ppNode
);

//	MACROS

#if DBG
#define	AtalkNodeReferenceByAddr(pPortDesc,NodeAddr,Node, pErr)	\
		{														\
			AtalkNodeRefByAddr(pPortDesc,NodeAddr,Node, pErr);	\
			if (ATALK_SUCCESS(*pErr))							\
			{													\
				DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE,		\
				("AtalkNodeRefByAddr : %s %d PostCount %d\n",	\
				__FILE__, __LINE__,(*Node)->an_RefCount));		\
			}													\
		}

#define	AtalkNodeReferenceByPtr(Node, pErr)						\
		{														\
			AtalkNodeRefByPtr(Node, pErr);						\
			DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE,			\
			("AtalkNodeRefByPtr : %s %d PostCount %d\n",		\
			__FILE__, __LINE__, Node->an_RefCount))				\
		}

#define	AtalkNodeReferenceByPtrNonInterlock(Node, pErr)			\
		{														\
			AtalkNodeRefByPtrNonInterlock(Node, pErr);			\
			DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE,			\
			("AtalkNodeRefByPtrNi : %s %d PostCount %d\n",		\
				__FILE__, __LINE__,Node->an_RefCount));			\
		}

#define	AtalkNodeReferenceNextNc(pNode, ppNode, pErr)			\
		{														\
			AtalkNodeRefNextNc(pNode, ppNode, pErr);			\
			if (ATALK_SUCCESS(*pErr))							\
			{													\
				DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE, 		\
				("AtalkNodeRefByPtrNc : %s %d PostCount %d\n",	\
				__FILE__, __LINE__, (*ppNode)->an_RefCount));	\
			}													\
		}

#define	AtalkNodeDereference(Node)								\
		{														\
			DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE, 			\
			("AtalkNodeDerefByPtr : %s %d PreCount %d\n",		\
			__FILE__, __LINE__,Node->an_RefCount));				\
			AtalkNodeDeref(Node);								\
		}

#else
#define	AtalkNodeReferenceByAddr(pPortDesc,NodeAddr,Node, pErr)	\
			AtalkNodeRefByAddr(pPortDesc,NodeAddr,Node, pErr)

#define	AtalkNodeReferenceByPtr(Node, pErr)						\
			AtalkNodeRefByPtr(Node, pErr)

#define	AtalkNodeReferenceByPtrNonInterlock(Node, pErr)			\
			AtalkNodeRefByPtrNonInterlock(Node, pErr)		

#define	AtalkNodeReferenceNextNcNonInterlock(pNode, ppNode, pErr)\
			AtalkNodeRefNextNcNonInterlock(pNode, ppNode, pErr)	

#define	AtalkNodeReferenceNextNc(pNode, ppNode, pErr)			\
			AtalkNodeRefNextNc(pNode, ppNode, pErr);

#define	AtalkNodeDereference(Node)	AtalkNodeDeref(Node)							
#endif


VOID
AtalkInitNodeSavePramAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	IN	PATALK_NODEADDR		Node
);

VOID
AtalkInitNodeGetPramAddr(       	
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	OUT	PATALK_NODEADDR		Node
);


VOID
AtalkZapPramValue(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue
);

#endif	// _NODE_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\nbp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nbp.h

Abstract:

	This module contains NBP specific declarations.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	25 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_NBP_

// Each "OpenSocket" structure has a "RegsiteredName" field which is the list
// of Network Visible Entities (NVE) available on that socket.  Each NVE is
// made up of three fields: object, type, zone For example:
// "Sidhu:MailBox:Bandley3".  We don't have to store the zone in the NVE
// structure because each entity must be registered in the zone that the node
// resides in.

// NBP entity multiple character wildcard.
#define NBP_WILD_CHARACTER			0xC5

// The largest "on the wire" NBP tuple
#define MAX_NBP_TUPLELENGTH			(2 + 1 + 1 + 1 + \
									 3 * (MAX_ENTITY_LENGTH + 1))

#define MIN_NBP_TUPLELENGTH			(2 + 1 + 1 + 1 + 3 * (1 + 1))

// Structure of NBP Header
typedef struct _NbpHeader {
	BYTE	_CmdAndTupleCnt;
	BYTE	_NbpId;
} NBPHDR, *PNBPHDR;

// An internal representation of an NBP tuple.  This structure is never
// actually put out on the wire so it can be in a convienient form to work
// with.  See "Inside AppleTalk" for further information.
typedef struct
{
	ATALK_ADDR			tpl_Address;
	SHORT				tpl_Enumerator;
	BYTE				tpl_ObjectLen;
	BYTE				tpl_Object[MAX_ENTITY_LENGTH];
	BYTE				tpl_TypeLen;
	BYTE				tpl_Type  [MAX_ENTITY_LENGTH];
	BYTE				tpl_ZoneLen;
	BYTE				tpl_Zone  [MAX_ENTITY_LENGTH];
} NBPTUPLE, *PNBPTUPLE;

// A registered name hangs off a open socket
#define	RDN_SIGNATURE	*(PULONG)"NBPR"
#if	DBG
#define	VALID_REGDNAME(pRegdName)	(((pRegdName) != NULL) && \
									 ((pRegdName)->rdn_Signature == RDN_SIGNATURE))
#else
#define	VALID_REGDNAME(pRegdName)	((pRegdName) != NULL)
#endif
typedef struct _REGD_NAME
{
#if	DBG
	ULONG					rdn_Signature;
#endif
	struct _REGD_NAME *		rdn_Next;
	NBPTUPLE				rdn_Tuple;
} REGD_NAME, *PREGD_NAME;

#define FOR_REGISTER			1
#define FOR_CONFIRM				2
#define FOR_LOOKUP				3

#define	PDN_FREE_REGDNAME		0x0001
#define	PDN_CLOSING				0x8000

// When we're doing NBP registers, lookups, or confirms we need to have a
// concept of "pending" NVE's.
#define	PDN_SIGNATURE	*(PULONG)"NBPP"
#if	DBG
#define	VALID_PENDNAME(pPendName)	(((pPendName) != NULL) && \
									 ((pPendName)->pdn_Signature == PDN_SIGNATURE))
#else
#define	VALID_PENDNAME(pPendName)	((pPendName) != NULL)
#endif
typedef struct _PEND_NAME
{
#if	DBG
	ULONG					pdn_Signature;
#endif
	struct _PEND_NAME 	*	pdn_Next;				// Next in the chain
	PREGD_NAME				pdn_pRegdName;			// This is moved to the open socket, if
													// FOR_REGISTER and successful
	PDDP_ADDROBJ			pdn_pDdpAddr;			// Socket that is registering,
													// confiming or looking-up.
	ATALK_ADDR				pdn_ConfirmAddr;		// The expected internet address
													// that we're trying to confirm.
	TIMERLIST				pdn_Timer;				// Broadcast timer
	LONG					pdn_RefCount;			// Reference count
	USHORT					pdn_NbpId;				// So we can sort out answers!
	USHORT					pdn_Flags;				// PDN_xxx values
	USHORT					pdn_MaxTuples;			// For lookup, what is the max # of
								    				// tuples our client is expecting?
	USHORT					pdn_TotalTuples;		// For lookup, how many tuples have we stored so far?
	BYTE					pdn_Reason;				// Confirm,Lookup or Register
	BYTE					pdn_RemainingBroadcasts;// How many more till we assume we're finished?
	USHORT					pdn_DatagramLength;		// Actual length of the datagram
	USHORT					pdn_MdlLength;			// Length of user Mdl
	PAMDL					pdn_pAMdl;				// Start of caller's "buffer" used to recieve tuples.
	PACTREQ					pdn_pActReq;			// Passed on to the completion routine.
	ATALK_ERROR				pdn_Status;				// Final status
	ATALK_SPIN_LOCK			pdn_Lock;				// Lock for this pending name
	CHAR					pdn_Datagram[sizeof(NBPHDR) + MAX_NBP_TUPLELENGTH];
								    				// The DDP datagram that we use to broadcast
								    				// the request.
} PEND_NAME, *PPEND_NAME;

// Default values for NBP timers

#define NBP_BROADCAST_INTERVAL		10		// In 100ms units
#define NBP_NUM_BROADCASTS			10

// The three NBP command types
#define NBP_BROADCAST_REQUEST		1
#define NBP_LOOKUP					2
#define NBP_LOOKUP_REPLY			3
#define NBP_FORWARD_REQUEST			4

extern
VOID
AtalkNbpPacketIn(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PVOID					pHandlerCtx,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

extern
ATALK_ERROR
AtalkNbpAction(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	BYTE					Reason,
	IN	PNBPTUPLE				pNbpTuple,
	OUT	PAMDL					pAMdl			OPTIONAL,	// FOR_LOOKUP
	IN	USHORT					MaxTuples		OPTIONAL,	// FOR_LOOKUP
	IN	PACTREQ					pActReq
);

extern
VOID
AtalkNbpCloseSocket(
	IN	PDDP_ADDROBJ			pDdpAddr
);

extern
ATALK_ERROR
AtalkNbpRemove(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PNBPTUPLE				pNbpTuple,
	IN	PACTREQ					pActReq
);

LOCAL LONG FASTCALL
atalkNbpTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);
	
LOCAL VOID                  	
atalkNbpLookupNames(        	
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PNBPTUPLE				pNbpTuple,
	IN	SHORT					NbpId
);

LOCAL BOOLEAN
atalkNbpMatchWild(
	IN	PBYTE					WildString,
	IN	BYTE					WildStringLen,
	IN	PBYTE					String,
	IN	BYTE					StringLen
);

LOCAL SHORT
atalkNbpEncodeTuple(
	IN	PNBPTUPLE				pNbpTuple,
	IN	PBYTE					pZone	OPTIONAL,
	IN	BYTE					ZoneLen OPTIONAL,
	IN	BYTE					Socket	OPTIONAL,
	OUT	PBYTE					pBuffer
);

LOCAL SHORT
atalkNbpDecodeTuple(
	IN	PBYTE					pBuffer,
	IN	USHORT					PktLen,
	OUT	PNBPTUPLE				pNbpTuple
);

LOCAL VOID
atalkNbpLinkPendingNameInList(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN OUT	PPEND_NAME			pPendName
);

LOCAL BOOLEAN
atalkNbpSendRequest(
	IN	PPEND_NAME				pPendName
);

LOCAL VOID
atalkNbpSendLookupDatagram(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	SHORT					NbpId,
	IN	PNBPTUPLE				pNbpTuple
);

LOCAL VOID
atalkNbpSendForwardRequest(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	struct _RoutingTableEntry *	pRte,
	IN	SHORT					NbpId,
	IN	PNBPTUPLE				pNbpTuple
);

VOID
atalkNbpDerefPendName(
	IN	PPEND_NAME				pPendName
);

VOID FASTCALL
atalkNbpSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo
);

#endif	// _NBP_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\pap.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pap.c

Abstract:

	This module implements the PAP protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		PAP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitPapInitialize)
#pragma alloc_text(PAGE_PAP, AtalkPapCreateAddress)
#pragma alloc_text(PAGE_PAP, AtalkPapCreateConnection)
#pragma	alloc_text(PAGE_PAP, AtalkPapCleanupAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapCloseAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapCleanupConnection)
#pragma	alloc_text(PAGE_PAP, AtalkPapCloseConnection)
#pragma	alloc_text(PAGE_PAP, AtalkPapAssociateAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapDissociateAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapPostListen)
#pragma	alloc_text(PAGE_PAP, AtalkPapPrimeListener)
#pragma	alloc_text(PAGE_PAP, AtalkPapCancelListen)
#pragma	alloc_text(PAGE_PAP, AtalkPapPostConnect)
#pragma	alloc_text(PAGE_PAP, AtalkPapDisconnect)
#pragma	alloc_text(PAGE_PAP, AtalkPapRead)
#pragma	alloc_text(PAGE_PAP, AtalkPapPrimeRead)
#pragma	alloc_text(PAGE_PAP, AtalkPapWrite)
#pragma	alloc_text(PAGE_PAP, AtalkPapSetStatus)
#pragma	alloc_text(PAGE_PAP, AtalkPapGetStatus)
#pragma	alloc_text(PAGE_PAP, AtalkPapQuery)
#pragma	alloc_text(PAGE_PAP, atalkPapConnRefByPtrNonInterlock)
#pragma	alloc_text(PAGE_PAP, atalkPapConnRefByCtxNonInterlock)
#pragma	alloc_text(PAGE_PAP, atalkPapConnRefNextNc)
#pragma	alloc_text(PAGE_PAP, atalkPapPostSendDataResp)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingReadComplete)
#pragma	alloc_text(PAGE_PAP, atalkPapPrimedReadComplete)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingStatus)
#pragma	alloc_text(PAGE_PAP, atalkPapSendDataRel)
#pragma	alloc_text(PAGE_PAP, atalkPapSlsHandler)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingReq)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingOpenReply)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingRel)
#pragma	alloc_text(PAGE_PAP, atalkPapStatusRel)
#pragma	alloc_text(PAGE_PAP, atalkPapConnAccept)
#pragma	alloc_text(PAGE_PAP, atalkPapGetNextConnId)
#pragma	alloc_text(PAGE_PAP, atalkPapQueueAddrGlobalList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueAssocList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueConnectList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueListenList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueActiveList)
#endif

//
//	The model for PAP calls in this module is as follows:
//	- For create calls (CreateAddress & CreateSession), a pointer to the created
//	 object is returned. This structure is referenced for creation.
//	- For all other calls, it expects a referenced pointer to the object.
//

VOID
AtalkInitPapInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	INITIALIZE_SPIN_LOCK(&atalkPapLock);
	AtalkTimerInitialize(&atalkPapCMTTimer,
						 atalkPapConnMaintenanceTimer,
						 PAP_CONNECTION_INTERVAL);
	AtalkTimerScheduleEvent(&atalkPapCMTTimer);
}




ATALK_ERROR
AtalkPapCreateAddress(
	IN	PATALK_DEV_CTX		pDevCtx	OPTIONAL,
	OUT	PPAP_ADDROBJ	*	ppPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ		pPapAddr = NULL;
	ATALK_ERROR			error;

	do
	{
		// Allocate memory for the Pap address object
		if ((pPapAddr = AtalkAllocZeroedMemory(sizeof(PAP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		// Create an Atp Socket on the port for the Sls/Connection Socket.
		error = AtalkAtpOpenAddress(AtalkDefaultPort,
									0,
									NULL,
									PAP_MAX_DATA_PACKET_SIZE,
									TRUE,					// SEND_USER_BYTES_ALL
									NULL,
									FALSE,		// CACHE address
									&pPapAddr->papao_pAtpAddr);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapCreateAddress: AtalkAtpOpenAddress fail %ld\n",error));

			break;
		}

		// Initialize the Pap address object
		pPapAddr->papao_Signature = PAPAO_SIGNATURE;

		INITIALIZE_SPIN_LOCK(&pPapAddr->papao_Lock);

		//	Creation reference
		pPapAddr->papao_RefCount = 1;

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		//	Insert into the global address list.
		atalkPapQueueAddrGlobalList(pPapAddr);
		*ppPapAddr = pPapAddr;
	}
	else if (pPapAddr != NULL)
	{
		AtalkFreeMemory(pPapAddr);
	}

	return error;
}




ATALK_ERROR
AtalkPapCleanupAddress(
	IN	PPAP_ADDROBJ			pPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn, pPapConnNext;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCleanupAddress: %lx\n", pPapAddr));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);

#if DBG
	pPapAddr->papao_Flags	|= PAPAO_CLEANUP;
#endif

	if ((pPapConn = pPapAddr->papao_pAssocConn) != NULL)
	{
		atalkPapConnRefNextNc(pPapConn, &pPapConnNext, &error);
		if (ATALK_SUCCESS(error))
		{
			while (TRUE)
			{
				if ((pPapConn = pPapConnNext) == NULL)
				{
					break;
				}

				if ((pPapConnNext = pPapConn->papco_pNextAssoc) != NULL)
				{
					atalkPapConnRefNextNc(pPapConnNext, &pPapConnNext, &error);
					if (!ATALK_SUCCESS(error))
					{
						pPapConnNext = NULL;
					}
				}

				//	Shutdown this connection
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("AtalkPapCloseAddress: Stopping conn %lx\n", pPapConn));

				AtalkPapCleanupConnection(pPapConn);

				AtalkPapConnDereference(pPapConn);
				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			}
		}
	}
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapCloseAddress(
	IN	PPAP_ADDROBJ			pPapAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	PPAP_CONNOBJ	pPapConn, pPapConnNext;
    DWORD   dwAssocRefCounts=0;


	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCloseAddress: %lx\n", pPapAddr));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	if (pPapAddr->papao_Flags & PAPAO_CLOSING)
	{
		//	We are already closing! This should never happen!
		ASSERT(0);
	}
	pPapAddr->papao_Flags |= PAPAO_CLOSING;

	//	Set the completion info.
	pPapAddr->papao_CloseComp  = CompletionRoutine;
	pPapAddr->papao_CloseCtx   = pCloseCtx;


	// Implicitly dissociate any connection objects
	for (pPapConn = pPapAddr->papao_pAssocConn;
		 pPapConn != NULL;
		 pPapConn = pPapConnNext)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		pPapConnNext = pPapConn->papco_pNextAssoc;

		//	when the conn was associate, we put a refcount: remove it
        if (pPapConn->papco_Flags & PAPCO_ADDR_ACTIVE)
        {
		    pPapConn->papco_Flags &= ~PAPCO_ADDR_ACTIVE;
            dwAssocRefCounts++;
        }

		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	}

	ASSERT(pPapAddr->papao_CloseComp != NULL);
	ASSERT(pPapAddr->papao_CloseCtx  != NULL);

    // ok to subtract: at least Creation refcount is still around
    pPapAddr->papao_RefCount -= dwAssocRefCounts;

	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	//	Close the ATP Address Object.
	if (pPapAddr->papao_pAtpAddr != NULL)
		AtalkAtpCloseAddress(pPapAddr->papao_pAtpAddr, NULL, NULL);
    pPapAddr->papao_pAtpAddr = NULL;

	//	Remove the creation reference count
	AtalkPapAddrDereference(pPapAddr);
	return ATALK_PENDING;
}




ATALK_ERROR
AtalkPapCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PPAP_CONNOBJ 	*		ppPapConn
	)
/*++

Routine Description:

 	Create an PAP session. The created session starts off being an orphan, i.e.
 	it has no parent address object. It gets one when it is associated.

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn;
	KIRQL			OldIrql;

	// Allocate memory for a connection object
	if ((pPapConn = AtalkAllocZeroedMemory(sizeof(PAP_CONNOBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	pPapConn->papco_Signature = PAPCO_SIGNATURE;

	INITIALIZE_SPIN_LOCK(&pPapConn->papco_Lock);
	pPapConn->papco_ConnCtx 	= pConnCtx;
	pPapConn->papco_Flags 		= 0;
	pPapConn->papco_RefCount 	= 1;					// Creation reference
	pPapConn->papco_NextOutgoingSeqNum = 1;				// Set to 1, not 0.
	pPapConn->papco_NextIncomingSeqNum = 1;				// Next expected incoming.
	AtalkInitializeRT(&pPapConn->papco_RT,
					  PAP_INIT_SENDDATA_REQ_INTERVAL,
                      PAP_MIN_SENDDATA_REQ_INTERVAL,
                      PAP_MAX_SENDDATA_REQ_INTERVAL);

	*ppPapConn = pPapConn;

	//	Insert into the global connection list.
	ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkPapConnList, pPapConn, papco_Next, papco_Prev);
	RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapCreateConnection: %lx\n", pPapConn));

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapCleanupConnection(
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	BOOLEAN		stopping 	= FALSE;
	BOOLEAN		pendingRead = FALSE;
    BOOLEAN     fWaitingRead = FALSE;
	KIRQL		OldIrql;
	ATALK_ERROR	error 		= ATALK_NO_ERROR;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCleanupConnection: %lx\n", pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	pPapConn->papco_Flags |= PAPCO_LOCAL_DISCONNECT;

#if DBG
	pPapConn->papco_Flags |= PAPCO_CLEANUP;
#endif

	if ((pPapConn->papco_Flags & PAPCO_STOPPING) == 0)
	{
		//	Allows completion of cleanup irp in Deref.
		pPapConn->papco_Flags |= PAPCO_STOPPING;

		//	If already effectively stopped, just return.
		if (pPapConn->papco_Flags & PAPCO_ASSOCIATED)
		{
			pendingRead = (pPapConn->papco_Flags & PAPCO_READDATA_PENDING) ? TRUE : FALSE;
			if (pPapConn->papco_Flags & PAPCO_READDATA_WAITING)
            {
                fWaitingRead = TRUE;
                pPapConn->papco_Flags &= ~PAPCO_READDATA_WAITING;
            }

			ASSERTMSG("PapCleanup: Called with read data unread\n", !pendingRead);

			stopping = TRUE;

		}
		else
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("AtalkPapCleanupConnection: Called for a stopped conn %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));
		}

	}
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Close the ATP Address Object if this was a server connection and
	//	opened its own socket.
	if (stopping)
	{
		//	If there is a pending read, then we need to cancel that atp request.
		if ((pendingRead || fWaitingRead) && (pPapConn->papco_pAtpAddr != NULL))
		{
			AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
							  pPapConn->papco_ReadDataTid,
							  &pPapConn->papco_RemoteAddr);
		}

		//	If we are already disconnecting this will return an error which
		//	we ignore. But if we were only in the ASSOCIATED state, then we
		//	need to call disassociate here.
		error = AtalkPapDisconnect(pPapConn,
								   ATALK_LOCAL_DISCONNECT,
								   NULL,
								   NULL);

		//	We were already disconnected.
		if (error == ATALK_INVALID_REQUEST)
		{
			AtalkPapDissociateAddress(pPapConn);
		}
	}

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapCloseConnection(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCloseConnection: %lx\n", pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	if (pPapConn->papco_Flags & PAPCO_CLOSING)
	{
		//	We are already closing! This should never happen!
		KeBugCheck(0);
	}
	pPapConn->papco_Flags |= PAPCO_CLOSING;

	//	Set the completion info.
	pPapConn->papco_CloseComp	= CompletionRoutine;
	pPapConn->papco_CloseCtx	= pCloseCtx;
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Remove the creation reference count
	AtalkPapConnDereference(pPapConn);

	return ATALK_PENDING;
}




ATALK_ERROR
AtalkPapAssociateAddress(
	IN	PPAP_ADDROBJ			pPapAddr,
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:

	Removed reference for the address for this connection. Causes deadlock in AFD where
	AFD blocks on close of the address object and we wait for connections to be closed
	first

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;

	ASSERT(VALID_PAPAO(pPapAddr));
	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	error = ATALK_ALREADY_ASSOCIATED;
	if ((pPapConn->papco_Flags & PAPCO_ASSOCIATED) == 0)
	{
		error = ATALK_NO_ERROR;

		//	Link it in.
		pPapConn->papco_pNextAssoc 	= pPapAddr->papao_pAssocConn;
		pPapAddr->papao_pAssocConn	= pPapConn;

		//	Remove not associated flag.
		pPapConn->papco_Flags 	   |= PAPCO_ASSOCIATED;
		pPapConn->papco_pAssocAddr	= pPapAddr;

        // put Association refcount
        pPapAddr->papao_RefCount++;

        // mark that fact that we now have a refcount on addr obj for this conn
        pPapConn->papco_Flags |= PAPCO_ADDR_ACTIVE;
	}

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkPapDissociateAddress(
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ	pPapAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error = ATALK_NO_ERROR;
    BOOLEAN         fDerefAddr = FALSE;

	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	if ((pPapConn->papco_Flags & (PAPCO_LISTENING 	|
								  PAPCO_CONNECTING	|
								  PAPCO_ACTIVE 		|
								  PAPCO_ASSOCIATED)) != PAPCO_ASSOCIATED)
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		pPapAddr = pPapConn->papco_pAssocAddr ;
		ASSERT(VALID_PAPAO(pPapAddr));

		//	Set not associated flag.
		pPapConn->papco_Flags 	   &= ~PAPCO_ASSOCIATED;
		pPapConn->papco_pAssocAddr	= NULL;

        if (pPapConn->papco_Flags & PAPCO_ADDR_ACTIVE)
        {
            pPapConn->papco_Flags &= ~PAPCO_ADDR_ACTIVE;
            fDerefAddr = TRUE;
        }
	}
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	  Unlink it if ok.
	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		atalkPapConnDeQueueAssocList(pPapAddr, pPapConn);
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

        if (fDerefAddr)
        {
            // remove the Association refcount
		    AtalkPapAddrDereference(pPapAddr);
        }

	}

	return error;
}




ATALK_ERROR
AtalkPapPostListen(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PVOID					pListenCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ	pPapAddr = pPapConn->papco_pAssocAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	//	This will also insert the connection object in the address objects
	//	list of connection which have a listen posted on them. When open
	//	connection requests come in, the first connection is taken off the list
	//	and the request satisfied.

	ASSERT(VALID_PAPCO(pPapConn));
	ASSERT(VALID_PAPAO(pPapAddr));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	do
	{
		if ((pPapConn->papco_Flags & (PAPCO_LISTENING 	|
									  PAPCO_CONNECTING	|
									  PAPCO_ACTIVE 		|
									  PAPCO_ASSOCIATED)) != PAPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a connect address type.
		if (pPapAddr->papao_Flags & PAPAO_CONNECT)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	Make the address object a listener.
		pPapAddr->papao_Flags		 	   |= PAPAO_LISTENER;

		pPapConn->papco_Flags 			   |= PAPCO_LISTENING;
		pPapConn->papco_ListenCtx 			= pListenCtx;
		pPapConn->papco_ListenCompletion 	= CompletionRoutine;

		//	Insert into the listen list.
		pPapConn->papco_pNextListen			= pPapAddr->papao_pListenConn;
		pPapAddr->papao_pListenConn			= pPapConn;

		//	Unblock the address object.
		pPapAddr->papao_Flags			   |= PAPAO_UNBLOCKED;
		error = ATALK_NO_ERROR;

	} while (FALSE);

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		//	Now enqueue a few handlers on the address object. These will handle
		//	open conn/get status etc.
		//
		//	DOC: For our implementation, until a server associates and places a
		//		 listen on one of the connection objects, we do not become a
		//		 listener. So the fact that we will not handle any request
		//		 until that point is ok. Note that for a connect, the requests
		//		 get posted on the connections atp address, which will be the same
		//		 as the address's atp address.
		if (!ATALK_SUCCESS(error = AtalkPapPrimeListener(pPapAddr)))
		{
			//	Undo insert into the listen list.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			atalkPapConnDeQueueListenList(pPapAddr, pPapConn);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
		}
	}

	return error;
}




ATALK_ERROR
AtalkPapPrimeListener(
	IN	PPAP_ADDROBJ			pPapAddr
	)
/*++

Routine Description:

 	Enqueue a handler on the listener.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;
	KIRQL		OldIrql;
	BOOLEAN		Unlock = TRUE;

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);

	if ((pPapAddr->papao_Flags & PAPAO_SLS_QUEUED) == 0)
	{
		//	Reference the address object for this handler we will be enqueuing.
		AtalkPapAddrReferenceNonInterlock(pPapAddr, &error);
		if (ATALK_SUCCESS(error))
		{
			pPapAddr->papao_Flags |= PAPAO_SLS_QUEUED;
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
            Unlock = FALSE;
	
			AtalkAtpSetReqHandler(pPapAddr->papao_pAtpAddr,
								  atalkPapSlsHandler,
								  pPapAddr);
		}
	}
	if (Unlock)
	{
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
	}

	return error;
}




ATALK_ERROR
AtalkPapCancelListen(
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:

  	Cancel a previously posted listen.

Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ		pPapAddr 	= pPapConn->papco_pAssocAddr;
	ATALK_ERROR			error 	 	= ATALK_NO_ERROR;
	GENERIC_COMPLETION	completionRoutine = NULL;
	KIRQL				OldIrql;
	PVOID			  	completionCtx = NULL;

	ASSERT(VALID_PAPCO(pPapConn));
	ASSERT(VALID_PAPAO(pPapAddr));
	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	if (!atalkPapConnDeQueueListenList(pPapAddr, pPapConn))
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		//	We complete the listen routine
		ASSERT(pPapConn->papco_Flags & PAPCO_LISTENING);
		pPapConn->papco_Flags  &= ~PAPCO_LISTENING;
		completionRoutine 		= pPapConn->papco_ListenCompletion;
		completionCtx			= pPapConn->papco_ListenCtx;
	}
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (*completionRoutine != NULL)
	{
		(*completionRoutine)(ATALK_REQUEST_CANCELLED, completionCtx);
	}

	return error;
}




ATALK_ERROR
AtalkPapPostConnect(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN			DerefConn = FALSE;
	KIRQL			OldIrql;
	ATALK_ERROR		error	= ATALK_NO_ERROR;
	PBYTE			pOpenPkt = NULL, pRespPkt = NULL;
	PAMDL			pOpenAmdl = NULL, pRespAmdl = NULL;
	PPAP_ADDROBJ	pPapAddr = pPapConn->papco_pAssocAddr;

	ASSERT(VALID_PAPAO(pPapAddr));
	ASSERT(VALID_PAPCO(pPapConn));

	//	Allocate a buffer to use.
	if (((pOpenPkt = AtalkAllocMemory(PAP_STATUS_OFF)) == NULL)				||
		((pOpenAmdl = AtalkAllocAMdl(pOpenPkt, PAP_STATUS_OFF)) == NULL)	||
		((pRespPkt = AtalkAllocMemory(PAP_MAX_DATA_PACKET_SIZE)) == NULL)	||
		((pRespAmdl = AtalkAllocAMdl(pRespPkt, PAP_MAX_DATA_PACKET_SIZE)) == NULL))

	{
		if (pOpenPkt != NULL)
			AtalkFreeMemory(pOpenPkt);
		if (pOpenAmdl != NULL)
			AtalkFreeAMdl(pOpenAmdl);
		if (pRespPkt != NULL)
			AtalkFreeMemory(pRespPkt);

		return ATALK_RESR_MEM;
	}

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	do
	{
		if ((pPapConn->papco_Flags & (PAPCO_LISTENING 	|
									  PAPCO_CONNECTING	|
									  PAPCO_ACTIVE 		|
									  PAPCO_ASSOCIATED)) != PAPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a listener address type.
		if (pPapAddr->papao_Flags & PAPAO_LISTENER)
		{
			error = ATALK_INVALID_ADDRESS;
			break;
		}

		//	Reference the connection for the request we will be posting
		AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		if (!ATALK_SUCCESS(error))
		{
			ASSERTMSG("AtalkPapPostConnect: Connection ref failed\n", 0);
			break;
		}

		DerefConn = TRUE;

		pPapConn->papco_ConnId	= atalkPapGetNextConnId(pPapAddr, &error);
		if (ATALK_SUCCESS(error))
		{
			//	Make sure flags are clean.
			pPapConn->papco_Flags			   &= ~(PAPCO_SENDDATA_RECD		|
													PAPCO_WRITEDATA_WAITING	|
													PAPCO_SEND_EOF_WRITE   	|
													PAPCO_READDATA_PENDING 	|
													PAPCO_REMOTE_CLOSE	 	|
													PAPCO_NONBLOCKING_READ 	|
													PAPCO_READDATA_WAITING);

			pPapConn->papco_Flags 			   |= PAPCO_CONNECTING;
			pPapConn->papco_ConnectCtx 			= pConnectCtx;
			pPapConn->papco_ConnectCompletion 	= CompletionRoutine;
			pPapConn->papco_pConnectRespBuf		= pRespPkt;
			pPapConn->papco_pConnectOpenBuf		= pOpenPkt;
			pPapConn->papco_ConnectRespLen		= PAP_MAX_DATA_PACKET_SIZE;
			pPapConn->papco_RemoteAddr			= *pRemoteAddr;
			pPapConn->papco_WaitTimeOut			= 0;	// To begin with

			//	For CONNECT, the connection object inherits the associated
			//	address objects atp address.
			pPapConn->papco_pAtpAddr			= pPapAddr->papao_pAtpAddr;

			//	Insert into the connect list.
			pPapConn->papco_pNextConnect		= pPapAddr->papao_pConnectConn;
			pPapAddr->papao_pConnectConn		= pPapConn;
			pPapAddr->papao_Flags 			   |= PAPAO_CONNECT;
		}
		else
		{
			ASSERTMSG("AtalkPapPostConnect: Unable to get conn id > 255 sess?\n", 0);
		}
	} while (FALSE);

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		error = atalkPapRepostConnect(pPapConn, pOpenAmdl, pRespAmdl);

		if (ATALK_SUCCESS(error))
		{
			error = ATALK_PENDING;
			DerefConn = FALSE;
		}
		else
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapConnect: AtalkAtpPostReq: failed %ld\n", error));

			//	Remove connection from the connect list and reset states.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			pPapConn->papco_Flags 			   &= ~PAPCO_CONNECTING;
			pPapConn->papco_ConnectCtx 			= NULL;
			pPapConn->papco_ConnectCompletion 	= NULL;
			pPapConn->papco_pConnectRespBuf		= NULL;
			pPapConn->papco_ConnectRespLen		= 0;
			pPapConn->papco_pAtpAddr			= NULL;

			//	Remove from the connect list.
			atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
		}
	}

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("AtalkPapConnect: failed %ld\n", error));

		//	Free all buffers.
		ASSERT(pOpenPkt != NULL);
		AtalkFreeMemory(pOpenPkt);

		ASSERT(pOpenAmdl != NULL);
		AtalkFreeAMdl(pOpenAmdl);

		ASSERT(pRespPkt != NULL);
		AtalkFreeMemory(pRespPkt);

		ASSERT(pRespAmdl != NULL);
		AtalkFreeAMdl(pRespAmdl);
	}

	if (DerefConn)
	{
		AtalkPapConnDereference(pPapConn);
	}

	return error;
}




ATALK_ERROR
AtalkPapDisconnect(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR					tmpError;
	PACTREQ						pActReq;
	PAMDL						writeBuf;
	PVOID						writeCtx;
	GENERIC_WRITE_COMPLETION	writeCompletion	= NULL;
	ATALK_ERROR					error 			= ATALK_PENDING;
	KIRQL						OldIrql;
	BOOLEAN						cancelPrimedRead = FALSE;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapDisconnect: %lx.%lx\n", pPapConn, DisconnectType));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

    // is it already disconnecting?
    if (pPapConn->papco_Flags & PAPCO_DISCONNECTING)
    {
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
        return(ATALK_PAP_CONN_CLOSING);
    }

	//	When a disconnect comes in, we abort any sends waiting for a remote
	//	send data to come in.
	if ((pPapConn->papco_Flags & (PAPCO_WRITEDATA_WAITING|PAPCO_SENDDATA_RECD)) ==
															PAPCO_WRITEDATA_WAITING)
	{
		//	In this situation, what happened is that a write was posted
		//	before a send data was received. As PapPostSendData response
		//	was never called in that case, there will be no pending reference
		//	on the connection.
		writeCompletion = pPapConn->papco_WriteCompletion;
		writeCtx		= pPapConn->papco_WriteCtx;
		writeBuf		= pPapConn->papco_pWriteBuf;

		pPapConn->papco_Flags	&= ~PAPCO_WRITEDATA_WAITING;
		pPapConn->papco_WriteCtx = NULL;
		pPapConn->papco_pWriteBuf= NULL;
		pPapConn->papco_WriteCompletion	= NULL;
	}

	// Handle the case where a send data was received, but no data is to be sent
	// just cancel the response.
	if (pPapConn->papco_Flags & PAPCO_SENDDATA_RECD)
	{
		PATP_RESP	pAtpResp = pPapConn->papco_pAtpResp;

		ASSERT(VALID_ATPRS(pAtpResp));

		pPapConn->papco_Flags &= ~PAPCO_SENDDATA_RECD;

		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		AtalkAtpCancelResp(pAtpResp);

		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	}

	//	Handle the race condition between disconnect and last recv. indication.
	//	The fact that we have received a disconnect from the other side implies
	//	that we have sent out a release which in turn implies that we have all
	//	the data. If this is the case, then we defer disconnect till the recv.
	//	indication is done. Otherwise AFD gets real upset.
	if ((DisconnectType == ATALK_REMOTE_DISCONNECT) &&
		(pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ))
	{
		if (AtalkAtpIsReqComplete(pPapConn->papco_pAtpAddr,
								  pPapConn->papco_ReadDataTid,
								  &pPapConn->papco_RemoteAddr))
		{
			pPapConn->papco_Flags |= PAPCO_DELAYED_DISCONNECT;
		}
	}

	//	Support for graceful disconnect. We only drop the received
	//	data when the local end does a disconnect. This will happen
	//	regardless of whether this routine was previously called or
	//	not. Also, this means that we must satisfy a read if disconnect is pending.
	if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
		(DisconnectType == ATALK_TIMER_DISCONNECT))
	{
        pPapConn->papco_Flags |= PAPCO_REJECT_READS;

		if (pPapConn->papco_Flags & PAPCO_READDATA_WAITING)
		{
			ASSERT(pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ);

			pActReq		= pPapConn->papco_NbReadActReq;

			//	Reset the flags
			pPapConn->papco_Flags &= ~(PAPCO_NONBLOCKING_READ | PAPCO_READDATA_WAITING);

			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

			//	Call the action completion routine for the prime read.
			(*pActReq->ar_Completion)(ATALK_LOCAL_CLOSE, pActReq);

			ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
		}
	}

	if ((pPapConn->papco_Flags & (PAPCO_DISCONNECTING | PAPCO_DELAYED_DISCONNECT)) == 0)
	{
		if (pPapConn->papco_Flags & (PAPCO_LISTENING	|
									 PAPCO_CONNECTING   |
									 PAPCO_ACTIVE))
		{
			pPapConn->papco_Flags |= PAPCO_DISCONNECTING;
			if (pPapConn->papco_Flags & PAPCO_LISTENING)
			{
				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
				AtalkPapCancelListen(pPapConn);
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			}
			else if (pPapConn->papco_Flags & PAPCO_CONNECTING)
			{
				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
				tmpError = AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
											 pPapConn->papco_ConnectTid,
											 &pPapConn->papco_RemoteAddr);

				//	We just stop the address. If success, it'll be dequeued from the
				//	connect list. If !success, its gone active. In either
				//	case we do not need to cleanup the ATP address. It could
				//	possibly be set to NULL by now as disconnect would have
				//	completed.
				if (ATALK_SUCCESS(tmpError))
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("atalkPapDisconnect: Stopping atp address for %lx\n", pPapConn));

					//	AtalkAtpCleanupAddress(pPapConn->papco_pAtpAddr);
				}
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			}

			//	Both of the above could have failed as the connection
			//	might have become active before the cancel succeeded.
			//	In that case (or if we were active to begin with), do
			//	a disconnect here.
			if (pPapConn->papco_Flags & PAPCO_ACTIVE)
			{
				//	Remember completion routines as appropriate.
				if (DisconnectType == ATALK_INDICATE_DISCONNECT)
				{
					if (pPapConn->papco_DisconnectInform == NULL)
					{
						pPapConn->papco_DisconnectInform = CompletionRoutine;
						pPapConn->papco_DisconnectInformCtx = pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
								("AtalkPapDisconnect: duplicate disc comp rou%lx\n", pPapConn));

						error = ATALK_TOO_MANY_COMMANDS;
					}
				}
				else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
				{
					//	Replace completion routines only if previous ones are NULL.
					if (pPapConn->papco_DisconnectCompletion == NULL)
					{
						pPapConn->papco_DisconnectCompletion = CompletionRoutine;
						pPapConn->papco_DisconnectCtx		 = pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
								("AtalkPapDisconnect: duplicate disc comp rou%lx\n", pPapConn));
						error = ATALK_TOO_MANY_COMMANDS;
					}
				}

				//	Figure out the disconnect status and remember it in the
				//	connection object.
				pPapConn->papco_DisconnectStatus = DISCONN_STATUS(DisconnectType);

				if ((pPapConn->papco_Flags & (PAPCO_NONBLOCKING_READ|PAPCO_READDATA_WAITING)) ==
																	PAPCO_NONBLOCKING_READ)
				{
					pPapConn->papco_Flags &= ~PAPCO_NONBLOCKING_READ;
					cancelPrimedRead = TRUE;
				}

				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

				//	If there is a pending write, then we need to complete the write.
				if (writeCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
							("AtalkPapDisconect: Completing write %lx.%lx\n",
							pPapConn, pPapConn->papco_DisconnectStatus));

					(*writeCompletion)(pPapConn->papco_DisconnectStatus,
									   writeBuf,
									   0,							// Write length
									   writeCtx);
    				}

				if (cancelPrimedRead)
				{
					AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
									  pPapConn->papco_ReadDataTid,
									  &pPapConn->papco_RemoteAddr);
				}

				//	Cancel the tickle request
				AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
								  pPapConn->papco_TickleTid,
								  &pPapConn->papco_RemoteAddr);

				//	Send out disconnect packet if this was a timer or local close.
				if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{
					BYTE		userBytes[ATP_USERBYTES_SIZE];
					USHORT		tid;

					userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
					userBytes[PAP_CMDTYPE_OFF]		= PAP_CLOSE_CONN;
					PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("AtalkPapDisconect: Sending disc to %lx - %lx\n",
							pPapConn->papco_RemoteAddr.ata_Address,
							DisconnectType));

					tmpError = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
											   &pPapConn->papco_RemoteAddr,
											   &tid,
											   0,						// ALO request
											   NULL,
											   0,
											   userBytes,
											   NULL,
											   0,
											   0,						// Retry count
											   0,						// Retry interval
											   THIRTY_SEC_TIMER,
											   NULL,
											   NULL);

					if (!ATALK_SUCCESS(tmpError))
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
								("AtalkPapDisconnect: post disc to rem fail%lx\n", pPapConn));
					}
				}

				//	Call the disconnect indication routine if present for a timer/
				//	remote disconnect.
				if ((DisconnectType == ATALK_REMOTE_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{
					PVOID 					discCtx;
					PTDI_IND_DISCONNECT 	discHandler = NULL;

					//	Acquire lock so we get a consistent handler/ctx.
					ACQUIRE_SPIN_LOCK(&pPapConn->papco_pAssocAddr->papao_Lock, &OldIrql);
					discHandler = pPapConn->papco_pAssocAddr->papao_DisconnectHandler;
					discCtx = pPapConn->papco_pAssocAddr->papao_DisconnectHandlerCtx;

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("AtalkPapDisconnect: IndDisc to AFD %lx\n", pPapConn));
#if DBG
					if (discHandler != NULL)
					{
						pPapConn->papco_Flags |= PAPCO_INDICATE_AFD_DISC;
					}
#endif
					RELEASE_SPIN_LOCK(&pPapConn->papco_pAssocAddr->papao_Lock, OldIrql);

					if (discHandler != NULL)
					{
						//	We use TDI_DISCONNECT_ABORT for flags. This makes
						//	AFD call Close for connection, but also allows a
						//	recv to come in as we are a buffering transport.
						(*discHandler)(discCtx,
									   pPapConn->papco_ConnCtx,
									   0,						//	DisconnectDataLength
									   NULL,					//	DisconnectData
									   0,		 				//	DisconnectInfoLength
									   NULL,					//	DisconnectInfo
									   TDI_DISCONNECT_ABORT);	//	Disconnect flags.
					}
				}

				//	Stop the atp address. only if we are a server job ?
				//	Client side pap connections can be many-to-one atp address.
				//	Doesn't affect monitor.
				AtalkAtpCleanupAddress(pPapConn->papco_pAtpAddr);
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			}
		}
		else
		{
			error = ATALK_INVALID_REQUEST;
		}
	}
	else
	{
		//	Do we need to remember the completion routines?
		//	Yes, if this is a disconnect or a indicate disconnect request,
		//	and our current disconnect was started due to the address object
		//	being closed.
		if (DisconnectType == ATALK_INDICATE_DISCONNECT)
		{
			if (pPapConn->papco_DisconnectInform == NULL)
			{
				pPapConn->papco_DisconnectInform = CompletionRoutine;
				pPapConn->papco_DisconnectInformCtx = pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
		else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
		{
			//	Replace completion routines only if previous ones are NULL.
			if (pPapConn->papco_DisconnectCompletion == NULL)
			{
				pPapConn->papco_DisconnectCompletion = CompletionRoutine;
				pPapConn->papco_DisconnectCtx		 = pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
	}

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkPapRead(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE			userBytes[ATP_USERBYTES_SIZE];
	USHORT			readLen, timeout;
	ULONG			readFlags;
	PACTREQ			pActReq;
	BOOLEAN			delayedDisConn = FALSE;
	KIRQL			OldIrql;
	ATALK_ERROR		error 		= ATALK_NO_ERROR;

	ASSERT(VALID_PAPCO(pPapConn));
	ASSERT(*CompletionRoutine != NULL);

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	do
	{
		if (ReadFlags & TDI_RECEIVE_EXPEDITED)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		if (pPapConn->papco_Flags & PAPCO_READDATA_PENDING)
		{
			error = ATALK_PAP_TOO_MANY_READS;
			break;
		}

		//	PEEK not supported for PAP
		if (ReadFlags & TDI_RECEIVE_PEEK)
		{
			error = ATALK_PAP_INVALID_REQUEST;
			break;
		}


		//	Do we already have a pending/indicated read waiting?
		//	!!!NOTE!!! If we do we complete the read regardless. With winsock
		//	our primed read will complete and we will indicate the data, but the
		//	mac immediately follows with a disconnect. if the winsock client is
		//	unable to read the data, before the disconnect comes in, it will lose
		//	the last block of data.
		if (pPapConn->papco_Flags & PAPCO_READDATA_WAITING)
		{
			pActReq		= pPapConn->papco_NbReadActReq;
			readLen		= pPapConn->papco_NbReadLen;
			readFlags	= pPapConn->papco_NbReadFlags;

			//	Make sure buffer size is atleast that of the indicated
			//	data.
			if (ReadBufLen < readLen)
			{
				error = ATALK_BUFFER_TOO_SMALL;
				break;
			}

			//	Reset the flags allowing primes to happen.
			pPapConn->papco_Flags	&= ~(PAPCO_NONBLOCKING_READ |
										 PAPCO_READDATA_WAITING);

			pPapConn->papco_NbReadLen	= 0;
			pPapConn->papco_NbReadFlags = 0;
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

			//	Call the action completion routine for the prime read.
			(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);

			if (ATALK_SUCCESS(error))
			{
				error = ((readFlags & TDI_RECEIVE_PARTIAL) ?
							ATALK_PAP_PARTIAL_RECEIVE : ATALK_NO_ERROR);
			}

			//	Call completion routine and return status success.
			(*CompletionRoutine)(error,
								pReadBuf,
								readLen,
								readFlags,
								pReadCtx);

			//	Return pending.
			return ATALK_PENDING;
		}

		if ((pPapConn->papco_Flags & PAPCO_ACTIVE) == 0)
		{
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
		}


		if (ReadBufLen < (PAP_MAX_FLOW_QUANTUM*PAP_MAX_DATA_PACKET_SIZE))
		{
			error = ATALK_BUFFER_TOO_SMALL;
			break;
		}

		error = ATALK_INVALID_CONNECTION;
		if ((pPapConn->papco_Flags & (PAPCO_CLOSING 	|
									  PAPCO_STOPPING |
									  PAPCO_DISCONNECTING)) == 0)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		pPapConn->papco_Flags 	|= PAPCO_READDATA_PENDING;

		//	Remember read information in the connection object.
		pPapConn->papco_ReadCompletion	= CompletionRoutine;
		pPapConn->papco_ReadCtx			= pReadCtx;

	} while (FALSE);

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	if (!ATALK_SUCCESS(error))
	{
		return error;
	}

	//	Build up the user bytes to post the 'SendData' to the remote end.
	userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_SEND_DATA;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], pPapConn->papco_NextOutgoingSeqNum);

	//	PAP Sequence number 0 means unsequenced.
	if (++pPapConn->papco_NextOutgoingSeqNum == 0)
		pPapConn->papco_NextOutgoingSeqNum = 1;

	//	Post the SendData request.
	pPapConn->papco_RT.rt_New = AtalkGetCurrentTick();
	if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
		 timeout = pPapConn->papco_RT.rt_Base;
	else timeout = PAP_MAX_SENDDATA_REQ_INTERVAL;

	error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
							&pPapConn->papco_RemoteAddr,
							&pPapConn->papco_ReadDataTid,
							ATP_REQ_EXACTLY_ONCE,
							NULL,
							0,
							userBytes,
							pReadBuf,
							ReadBufLen,
							ATP_INFINITE_RETRIES,
							timeout,
							THIRTY_SEC_TIMER,
							atalkPapIncomingReadComplete,
							pPapConn);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("AtalkPapRead: AtalkAtpPostReq %ld\n", error));

		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

		//	Undo the seq number change.
		if (--pPapConn->papco_NextOutgoingSeqNum == 0)
			pPapConn->papco_NextOutgoingSeqNum = (USHORT)0xFFFF;

		pPapConn->papco_Flags 	&= ~PAPCO_READDATA_PENDING;

		//	Clear out read information in the connection object.
		pPapConn->papco_ReadCompletion	= NULL;
		pPapConn->papco_ReadCtx			= NULL;
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		AtalkPapConnDereference(pPapConn);
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapRead: No error - AtalkAtpPostReq tid %lx\n",
				pPapConn->papco_ReadDataTid));

		error = ATALK_PENDING;
	}

	return error;
}




ATALK_ERROR
AtalkPapPrimeRead(
	IN	PPAP_CONNOBJ	pPapConn,
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE			userBytes[ATP_USERBYTES_SIZE];
	USHORT			timeout;
	KIRQL			OldIrql;
	ATALK_ERROR		error 		= ATALK_NO_ERROR;
        SHORT                   MaxRespBufLen;

	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	do
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapPrimeRead: %lx\n", pPapConn));

		if (pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ)
		{
			error = ATALK_PAP_TOO_MANY_READS;
			break;
		}

        if (pPapConn->papco_Flags & PAPCO_REJECT_READS)
        {
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
        }

		if ((pPapConn->papco_Flags & PAPCO_ACTIVE) == 0)
		{
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
		}

		error = ATALK_INVALID_CONNECTION;
		if ((pPapConn->papco_Flags & (PAPCO_CLOSING 			|
									  PAPCO_STOPPING			|
									  PAPCO_DELAYED_DISCONNECT	|
									  PAPCO_DISCONNECTING)) == 0)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		}

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapPrimeRead: Conn %lx Reference Failed %lx\n", pPapConn, error));
			break;
		}

		//	Remember info in the connection
		pPapConn->papco_Flags 		|= PAPCO_NONBLOCKING_READ;
		pPapConn->papco_NbReadLen 	 = 0;
		pPapConn->papco_NbReadActReq = pActReq;
	} while (FALSE);

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapPrimeRead: Failed %lx.%lx\n", error, pPapConn));

		return error;
	}



	//	Build up the user bytes to post the 'SendData' to the remote end.
	userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_SEND_DATA;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], pPapConn->papco_NextOutgoingSeqNum);

	//	PAP Sequence number 0 means unsequenced.
	if (++pPapConn->papco_NextOutgoingSeqNum == 0)
		pPapConn->papco_NextOutgoingSeqNum = 1;

	//	Post the SendData request.
	pPapConn->papco_RT.rt_New = AtalkGetCurrentTick();
	if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
		 timeout = pPapConn->papco_RT.rt_Base;
	else timeout = PAP_MAX_SENDDATA_REQ_INTERVAL;

        MaxRespBufLen = (pPapConn->papco_pAtpAddr->atpao_MaxSinglePktSize * ATP_MAX_RESP_PKTS);
        if (pActReq->ar_MdlSize > MaxRespBufLen)
        {
            pActReq->ar_MdlSize = MaxRespBufLen;
        }

	error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
							&pPapConn->papco_RemoteAddr,
							&pPapConn->papco_ReadDataTid,
							ATP_REQ_EXACTLY_ONCE,				// ExactlyOnce request
							NULL,
							0,
							userBytes,
							pActReq->ar_pAMdl,
							pActReq->ar_MdlSize,
							ATP_INFINITE_RETRIES,
							timeout,
							THIRTY_SEC_TIMER,
							atalkPapPrimedReadComplete,
							pPapConn);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("AtalkPapRead: AtalkAtpPostReq %ld\n", error));

		//	Out of resources error log.
		TMPLOGERR();

		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

		//	Undo the seq number change.
		if (--pPapConn->papco_NextOutgoingSeqNum == 0)
			pPapConn->papco_NextOutgoingSeqNum = (USHORT)0xFFFF;

		pPapConn->papco_Flags 		&= ~PAPCO_NONBLOCKING_READ;
		pPapConn->papco_NbReadActReq = NULL;
		pPapConn->papco_NbReadLen 	 = 0;
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		AtalkPapConnDereference(pPapConn);
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapPrimedRead: No error - AtalkAtpPostReq tid %lx\n",
				pPapConn->papco_ReadDataTid));

		error = ATALK_PENDING;

		//	If a disconnect happened, cancel prime read just in case disconnect
		//	was unable to due to the tid having been uninitialized.
		if (pPapConn->papco_Flags & PAPCO_DISCONNECTING)
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapPrimedRead: DISC When PRIMEREAD %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));

			AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
							  pPapConn->papco_ReadDataTid,
							  &pPapConn->papco_RemoteAddr);
		}
	}

	return error;
}




ATALK_ERROR
AtalkPapWrite(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN					sendDataRecd, eom;
	ATALK_ERROR				error;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;
	KIRQL					OldIrql;
	PPAP_ADDROBJ			pPapAddr;


	ASSERT(VALID_PAPCO(pPapConn));

	pPapAddr = pPapConn->papco_pAssocAddr;

	ASSERT(VALID_PAPAO(pPapAddr));

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	do
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapWrite: Buffer size %lx.%lx\n",
				WriteBufLen, pPapConn->papco_SendFlowQuantum * PAP_MAX_DATA_PACKET_SIZE));

		if (WriteBufLen > (pPapConn->papco_SendFlowQuantum * PAP_MAX_DATA_PACKET_SIZE))
		{
			error = ATALK_BUFFER_TOO_BIG;
			ASSERTMSG("AtalkPapWrite: An invalid buffer size used for write\n",
					(WriteBufLen <= (pPapConn->papco_SendFlowQuantum * PAP_MAX_DATA_PACKET_SIZE)));
			break;
		}

		if (pPapConn->papco_Flags & PAPCO_WRITEDATA_WAITING)
		{
			error = ATALK_PAP_TOO_MANY_WRITES;
			ASSERTMSG("AtalkPapWrite: A second write was posted\n", 0);
			break;
		}

		if ((pPapConn->papco_Flags & PAPCO_ACTIVE) == 0)
		{
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
		}

		//  Non-blocking sends for PAP:
		//  Pap uses a binary event - send data credit thats sent to the remote
		//  end. ATP remembers the actual size of the remote entity's response
		//  buffer. In any case, if we do not have send credit the call would
		//  block, and we dont want that to happen. Also, there should be no
		//  pending writes on the connection to begin with.
		//

		if (SendFlags & TDI_SEND_EXPEDITED)
		{
			ASSERTMSG("AtalkPapWrite: Expedited set for pap\n", 0);
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	This goes away before the call returns. PostSendData has its
		//	own reference.
		error = ATALK_INVALID_CONNECTION;
		if ((pPapConn->papco_Flags & (	PAPCO_CLOSING			|
										PAPCO_STOPPING			|
										PAPCO_DISCONNECTING)) == 0)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
			if (ATALK_SUCCESS(error))
			{
				sendDataRecd = ((pPapConn->papco_Flags & PAPCO_SENDDATA_RECD) != 0);

				if (!sendDataRecd &&
					(SendFlags & TDI_SEND_NON_BLOCKING))
				{
					//	!!!NOTE!!!
					//	To avoid the race condition in AFD where an incoming
					//	send data indication setting send's possible to true
					//	is overwritten by this read's unwinding and setting it
					//	to false, we return ATALK_REQUEST_NOT_ACCEPTED, which
					//	will map to STATUS_REQUEST_NOT_ACCEPTED and then to
					//	WSAEWOULDBLOCK.

					error = ATALK_REQUEST_NOT_ACCEPTED;

					RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

					//	We have a reference on the connection we must remove.
					AtalkPapConnDereference(pPapConn);

					ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				}
			}
		}

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("AtalkPapWrite: Write failed %lx\n", error));
			break;
		}

		error = ATALK_PENDING;

		eom = (SendFlags & TDI_SEND_PARTIAL) ? FALSE : TRUE;

		pPapConn->papco_Flags 		   |= PAPCO_WRITEDATA_WAITING;
		if (eom)
		{
			pPapConn->papco_Flags	   |= PAPCO_SEND_EOF_WRITE;
		}

		pPapConn->papco_WriteCompletion	= CompletionRoutine;
		pPapConn->papco_WriteCtx		= pWriteCtx;

		pPapConn->papco_pWriteBuf		= pWriteBuf;
		pPapConn->papco_WriteLen		= WriteBufLen;

		//	Stop further writes from happening by indicating to afd.
		//	Call the send data event handler on the associated address with
		//	0 to turn off selects on writes. We do this before we post any
		//	get requests, so there is no race condition.
		//	remember send possible handler/context.
		sendPossibleHandler	= pPapAddr->papao_SendPossibleHandler;
		sendPossibleHandlerCtx = pPapAddr->papao_SendPossibleHandlerCtx;

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		if (sendDataRecd)
		{
			if (*sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pPapConn->papco_ConnCtx,
									   0);
			}

			// atalkPostSendDataResp() will release the conn lock
			error = atalkPapPostSendDataResp(pPapConn);

			if (!ATALK_SUCCESS(error))
			{
				ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				pPapConn->papco_Flags &= ~PAPCO_WRITEDATA_WAITING;
				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("AtalkPapWrite: atalkPapPostSendDataResp Failed %lx\n", pPapConn));
			}
		}
		else
		{
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		}

		AtalkPapConnDereference(pPapConn);
	}
	else
	{
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	}

	if (OldIrql != DISPATCH_LEVEL)
		KeLowerIrql(OldIrql);

	return error;
}




ATALK_ERROR
AtalkPapSetStatus(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PAMDL			pStatusMdl,			// NULL if 0-length status
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		status;
	USHORT			stsBufSize=0;
	ULONG			bytesCopied;
	KIRQL			OldIrql;
	PBYTE			pStatusBuf = NULL, pFreeStatusBuf = NULL;

	ASSERT(VALID_PAPAO(pPapAddr));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapSetStatus: Entered for Addr %lx\n", pPapAddr));

	if (pStatusMdl == NULL)
	{
		pStatusBuf = NULL;
		stsBufSize = 0;
	}
	else
	{
		// Allocate a buffer and copy the contents of the passed in
		// buffer descriptor in it. Free an existing status buffer if one exists
		stsBufSize = (USHORT)AtalkSizeMdlChain(pStatusMdl);
		if (stsBufSize >= PAP_MAX_STATUS_SIZE)
			return ATALK_BUFFER_TOO_BIG;
		if (stsBufSize < 0)
			return ATALK_BUFFER_TOO_SMALL;
	}

	if (stsBufSize > 0)
	{
		if ((pStatusBuf = AtalkAllocMemory(stsBufSize)) == NULL)
		{
			return ATALK_RESR_MEM;
		}

		status = TdiCopyMdlToBuffer(pStatusMdl,
									0,
									pStatusBuf,
									0,
									stsBufSize,
									&bytesCopied);

		ASSERT(NT_SUCCESS(status) && (bytesCopied == stsBufSize));
	}

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);

	pFreeStatusBuf = pPapAddr->papao_pStatusBuf;

	pPapAddr->papao_pStatusBuf = pStatusBuf;
	pPapAddr->papao_StatusSize = stsBufSize;
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (pFreeStatusBuf != NULL)
	{
		AtalkFreeMemory(pFreeStatusBuf);
	}

	// Call the completion routine before returning.
	(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapGetStatus(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PATALK_ADDR		pRemoteAddr,
	IN	PAMDL			pStatusAmdl,
	IN	USHORT			AmdlSize,
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:

	The Status Buffer passed in will be preceded by 4 bytes for the
	unused bytes.

Return Value:


--*/
{
	ATALK_ERROR	error;
	BYTE		userBytes[ATP_USERBYTES_SIZE];
	USHORT		tid;

	if ((pRemoteAddr->ata_Network == 0) ||
        (pRemoteAddr->ata_Node == 0)	||
        (pRemoteAddr->ata_Socket == 0))
	{
		return ATALK_SOCKET_INVALID;
	}
	userBytes[PAP_CONNECTIONID_OFF]	= 0;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_SEND_STATUS;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

	error = AtalkAtpPostReq(pPapAddr->papao_pAtpAddr,
							pRemoteAddr,
							&tid,
							0,							// ExactlyOnce request
							NULL,
							0,
							userBytes,
							pStatusAmdl,
							AmdlSize,
							PAP_GETSTATUS_REQ_RETRYCOUNT,
							PAP_GETSTATUS_ATP_INTERVAL,
							THIRTY_SEC_TIMER,
							atalkPapIncomingStatus,
							(PVOID)pActReq);

	if (ATALK_SUCCESS(error))
	{
		error = ATALK_PENDING;
	}

	return error;
}



VOID
AtalkPapQuery(
	IN	PVOID			pObject,
	IN	ULONG			ObjectType,
	IN	PAMDL			pAmdl,
	OUT	PULONG			BytesWritten
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	switch (ObjectType)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		ASSERT(VALID_PAPAO((PPAP_ADDROBJ)pObject));
		AtalkDdpQuery(AtalkPapGetDdpAddress((PPAP_ADDROBJ)pObject),
					  pAmdl,
					  BytesWritten);

		break;

	  case TDI_CONNECTION_FILE :
		{
			PPAP_CONNOBJ	pPapConn;
			KIRQL			OldIrql;

			pPapConn	= (PPAP_CONNOBJ)pObject;
			ASSERT(VALID_PAPCO(pPapConn));

			*BytesWritten = 0;
			//	Get the address from the associated address if any.
			ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			if (pPapConn->papco_Flags & PAPCO_ASSOCIATED)
			{
				AtalkDdpQuery(AtalkPapGetDdpAddress(pPapConn->papco_pAssocAddr),
							  pAmdl,
							  BytesWritten);
			}
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
		}
		break;

	  case TDI_CONTROL_CHANNEL_FILE :
	  default:
		break;
	}

}




LOCAL	ATALK_ERROR
atalkPapRepostConnect(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PAMDL					pOpenAmdl,
	IN	PAMDL					pRespAmdl
	)
/*++

Routine Description:


Arguments:



Return Value:


--*/
{
	BYTE		userBytes[ATP_USERBYTES_SIZE];
	PBYTE		pOpenPkt = AtalkGetAddressFromMdlSafe(pOpenAmdl, NormalPagePriority);
	ATALK_ERROR	error;

	if (pOpenPkt == NULL) {
		error = ATALK_RESR_MEM;
		return error;
	}

	//	Okay, prepare to post the OpenConn request; build up both userBytes and
	//	data buffer!
	userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_OPEN_CONN;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

	pOpenPkt[PAP_RESP_SOCKET_OFF] 	= PAPCONN_DDPSOCKET(pPapConn);
	pOpenPkt[PAP_FLOWQUANTUM_OFF]	= PAP_MAX_FLOW_QUANTUM;
	PUTDWORD2SHORT(&pOpenPkt[PAP_WAITTIME_OFF], pPapConn->papco_WaitTimeOut);

	//	Post the open connection request. We do it on the atp address of the
	//	pap address object.
	error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
							&pPapConn->papco_RemoteAddr,
							&pPapConn->papco_ConnectTid,
							ATP_REQ_EXACTLY_ONCE,				// ExactlyOnce request
							pOpenAmdl,
							PAP_STATUS_OFF,
							userBytes,
							pRespAmdl,
							PAP_MAX_DATA_PACKET_SIZE,
							PAP_OPENCONN_REQ_RETRYCOUNT,
							PAP_OPENCONN_INTERVAL,
							THIRTY_SEC_TIMER,
							atalkPapIncomingOpenReply,
							pPapConn);
	return error;
}


LOCAL VOID FASTCALL
atalkPapAddrDeref(
	IN	PPAP_ADDROBJ		pPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	BOOLEAN	done = FALSE;

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ASSERT(pPapAddr->papao_RefCount > 0);
	if (--pPapAddr->papao_RefCount == 0)
	{
		done = TRUE;
		ASSERT(pPapAddr->papao_Flags & PAPAO_CLOSING);
	}
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (done)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("atalkPapAddrDeref: Addr %lx done with.\n", pPapAddr));

		if (pPapAddr->papao_CloseComp != NULL)
		{
			(*pPapAddr->papao_CloseComp)(ATALK_NO_ERROR,
										 pPapAddr->papao_CloseCtx);
		}

		//	Remove from the global list.
		ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
		AtalkUnlinkDouble(pPapAddr, papao_Next, papao_Prev);
		RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);

		// Free any status buffer allocated for this address object
		if (pPapAddr->papao_pStatusBuf != NULL)
			AtalkFreeMemory(pPapAddr->papao_pStatusBuf);

		AtalkFreeMemory(pPapAddr);

		AtalkUnlockPapIfNecessary();
	}
}




LOCAL VOID FASTCALL
atalkPapConnRefByPtrNonInterlock(
	IN	PPAP_CONNOBJ		pPapConn,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pError = ATALK_NO_ERROR;
	ASSERT(VALID_PAPCO(pPapConn));

	if ((pPapConn->papco_Flags & PAPCO_CLOSING) == 0)
	{
		ASSERT(pPapConn->papco_RefCount >= 1);

		pPapConn->papco_RefCount ++;
	}
	else
	{
		*pError = ATALK_PAP_CONN_CLOSING;
	}
}




LOCAL	VOID
atalkPapConnRefByCtxNonInterlock(
	IN	PPAP_ADDROBJ		pPapAddr,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PPAP_CONNOBJ	*	pPapConn,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS SPINLOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapChkConn;
	ATALK_ERROR		error = ATALK_PAP_CONN_NOT_FOUND;

	for (pPapChkConn = pPapAddr->papao_pAssocConn;
		 pPapChkConn != NULL;
		 pPapChkConn = pPapChkConn->papco_pNextAssoc)
	{
		if (pPapChkConn->papco_ConnCtx == Ctx)
		{
			AtalkPapConnReferenceByPtr(pPapChkConn, &error);
			if (ATALK_SUCCESS(error))
			{
				*pPapConn = pPapChkConn;
			}
			break;
		}
	}

	*pError = error;
}




LOCAL	VOID
atalkPapConnRefNextNc(
	IN		PPAP_CONNOBJ		pPapConn,
	IN		PPAP_CONNOBJ	*	ppPapConnNext,
	OUT		PATALK_ERROR		pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ASSOCIATED ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pNextConn 	= NULL;
	ATALK_ERROR		error 		= ATALK_FAILURE;

	ASSERT(VALID_PAPCO(pPapConn));

	for (; pPapConn != NULL; pPapConn = pPapConn->papco_pNextActive)
	{
		AtalkPapConnReferenceByPtrDpc(pPapConn, &error);
		if (ATALK_SUCCESS(error))
		{
			//	Ok, this connection is referenced!
			*ppPapConnNext = pPapConn;
			break;
		}
	}

	*pError = error;
}




LOCAL VOID FASTCALL
atalkPapConnDeref(
	IN	PPAP_CONNOBJ		pPapConn
	)
/*++

Routine Description:

	Disconnect completion happens when the reference count goes from
	2->1 if the creation reference is not already removed. If the creation
	reference is already removed, it will be done when the refcount goes
	from 1->0.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			fEndProcessing = FALSE;

	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	ASSERT(pPapConn->papco_RefCount > 0);
	pPapConn->papco_RefCount--;

	if (pPapConn->papco_RefCount > 1)
	{
		fEndProcessing = TRUE;
	}
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	if (fEndProcessing)
	{
		return;
	}
	else
	{
		PTDI_IND_DISCONNECT 	discHandler;
		PVOID 					discCtx;
		ATALK_ERROR				disconnectStatus;

		GENERIC_COMPLETION		disconnectInform		= NULL;
		PVOID					disconnectInformCtx		= NULL;
		GENERIC_COMPLETION		disconnectCompletion	= NULL;
		PVOID					cleanupCtx				= NULL;
		GENERIC_COMPLETION		cleanupCompletion		= NULL;
		PVOID					closeCtx				= NULL;
		GENERIC_COMPLETION		closeCompletion			= NULL;
		PVOID					disconnectCtx			= NULL;
		PATP_ADDROBJ			pAtpAddr				= NULL;

		PPAP_ADDROBJ			pPapAddr	= pPapConn->papco_pAssocAddr;
		BOOLEAN					disconnDone = FALSE;

		//	We allow stopping phase to happen only after disconnecting is done.
		//	If disconnecting is not set and stopping is, it implies we are only
		//	in an associated state.
		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
		if (pPapConn->papco_Flags & PAPCO_DISCONNECTING)
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeref: Disconnect set for %lx\n", pPapConn));

			if (pPapConn->papco_RefCount == 1)
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnDeref: Disconnect done %lx\n",
						pPapConn));

				disconnDone = TRUE;

				//	Avoid multiple disconnect completions/close atp addresses
				//	Remember all the disconnect info before we release the lock
				disconnectInform		= pPapConn->papco_DisconnectInform;
				disconnectInformCtx		= pPapConn->papco_DisconnectInformCtx;
				disconnectStatus		= pPapConn->papco_DisconnectStatus;
				disconnectCompletion	= pPapConn->papco_DisconnectCompletion;
				disconnectCtx			= pPapConn->papco_DisconnectCtx;

				//	The atp address to be closed
				pAtpAddr 			= pPapConn->papco_pAtpAddr;

				//	Reset all the be null, so next request doesnt get any
				pPapConn->papco_DisconnectInform		= NULL;
				pPapConn->papco_DisconnectInformCtx		= NULL;
				pPapConn->papco_DisconnectCompletion	= NULL;
				pPapConn->papco_DisconnectCtx			= NULL;
				pPapConn->papco_pAtpAddr				= NULL;
			}
		}

		if (pPapConn->papco_RefCount == 0)
		{
			closeCtx			= pPapConn->papco_CloseCtx;
			closeCompletion		= pPapConn->papco_CloseComp;

			pPapConn->papco_CloseCtx = NULL;
			pPapConn->papco_CloseComp= NULL;

			ASSERT(pPapConn->papco_Flags & PAPCO_CLOSING);
		}
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		if (disconnDone)
		{
			//	Remove from the active queue.
			//	Reset all relevent flags.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			atalkPapConnDeQueueActiveList(pPapAddr, pPapConn);

			discHandler = pPapConn->papco_pAssocAddr->papao_DisconnectHandler;
			discCtx = pPapConn->papco_pAssocAddr->papao_DisconnectHandlerCtx;

			//	Close the atp address if a server object. If the SERVER_JOB flag
			//	is set, it implies that the atp address object was open.
			if ((pPapConn->papco_Flags & PAPCO_SERVER_JOB) == 0)
			{
				pAtpAddr = NULL;
			}

			//	This can be done outside the spinlock section. Keep disconnection
			//	flag set so no other requests can get in.
			//	!!!NOTE!!! We keep the readdata_waiting flag so that the client
			//	may read the last set of data sent by the mac.

			pPapConn->papco_Flags	&=	~(PAPCO_LISTENING 			|
										  PAPCO_CONNECTING			|
										  PAPCO_ACTIVE				|
                                          PAPCO_DISCONNECTING       |
										  PAPCO_READDATA_PENDING	|
										  PAPCO_WRITEDATA_WAITING	|
										  PAPCO_NONBLOCKING_READ	|
										  PAPCO_SENDDATA_RECD);

            pPapConn->papco_Flags |= PAPCO_REJECT_READS;

			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

			//	Call the disconnect completion routines.
			if (*disconnectInform != NULL)
			{
				(*disconnectInform)(disconnectStatus, disconnectInformCtx);
			}

			if (*disconnectCompletion != NULL)
			{
				(*disconnectCompletion)(disconnectStatus, disconnectCtx);
			}

			//	Close the atp address if a server object. If the SERVER_JOB flag
			//	is set, it implies that the atp address object was open.
			if (pAtpAddr != NULL)
			{
				ASSERT(VALID_ATPAO(pAtpAddr));
				ASSERT(pPapConn->papco_pAtpAddr == NULL);
				AtalkAtpCloseAddress(pAtpAddr, NULL, NULL);
			}
		}

		//	Check if we are done with stopping. We could either just be done with
		//	disconnect, or be done previously, and just need to complete the stop
		//	now.
		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
		if ((pPapConn->papco_Flags & PAPCO_STOPPING) != 0)
		{
			BOOLEAN	fDisassoc = FALSE;

			//	See if we do the cleanup irp completion.
			if (pPapConn->papco_RefCount == 1)
			{
				cleanupCtx			= pPapConn->papco_CleanupCtx;
				cleanupCompletion	= pPapConn->papco_CleanupComp;

				pPapConn->papco_CleanupComp	= NULL;
				pPapConn->papco_CleanupCtx  = NULL;

				pPapConn->papco_Flags &= ~PAPCO_STOPPING;

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnDeref: Cleanup on %lx.%lx\n",
						pPapConn, cleanupCtx));
			}

			if ((pPapConn->papco_Flags & (	PAPCO_LISTENING 	|
											PAPCO_CONNECTING  	|
											PAPCO_ACTIVE)) == 0)
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnDeref: Stopping - do disassoc for %lx\n", pPapConn));

				fDisassoc = ((pPapConn->papco_Flags & PAPCO_ASSOCIATED) != 0);
			}
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

			//	Call the disassociate routine. This should just fail, if the
			//	connection is still active or any other state than just
			//	plain associated. This will also reset the stopping flag.
			if (fDisassoc)
			{
				AtalkPapDissociateAddress(pPapConn);
			}
		}
		else
		{
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
		}

		//	Complete cleanup at the end.
		if (*cleanupCompletion != NULL)
			(*cleanupCompletion)(ATALK_NO_ERROR, cleanupCtx);

		if (*closeCompletion != NULL)
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeref: Close done for %lx\n", pPapConn));

			//	Call the close completion routines
			(*closeCompletion)(ATALK_NO_ERROR, closeCtx);

			//	Remove from the global list.
			ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
			AtalkUnlinkDouble(pPapConn, papco_Next, papco_Prev);
			RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);

			//	Free up the connection memory.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeref: Freeing up connection %lx\n", pPapConn));

			AtalkUnlockPapIfNecessary();
			AtalkFreeMemory(pPapConn);
		}
	}
}




LOCAL ATALK_ERROR FASTCALL
atalkPapPostSendDataResp(
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:

	Timing Thoughts:	We could get here from PapWrite *only* if we had already
	received a senddata. And so we will not get here from a send data being received
	as it will not be accepted while we have a previous send data pending. The
	other way around- we will only get here from a send data coming in if we
	have a write pending. So we will never get here from write as we would not
	have had a send data pending at that time.

	If the connection reference fails, that means we are shutting down, and
	the shutdown code would already have called the write completion with an
	error. We just get outta here.

	THIS IS CALLED WITH papco_Lock held !!!

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PATP_RESP		pAtpResp;
	BYTE			userBytes[ATP_USERBYTES_SIZE];

	ASSERT(VALID_PAPCO(pPapConn));

	// ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	//	If we are disconnecting or received a remote disconnect, get out.
	//	The disconnect routine would have already cancelled the response.
	error	= ATALK_FAILURE;
	if ((pPapConn->papco_Flags & (PAPCO_CLOSING 			|
								  PAPCO_STOPPING 			|
								  PAPCO_DELAYED_DISCONNECT 	|
								  PAPCO_RECVD_DISCONNECT 	|
								  PAPCO_DISCONNECTING)) == 0)
	{
		ASSERT ((pPapConn->papco_Flags & (PAPCO_SENDDATA_RECD | PAPCO_WRITEDATA_WAITING)) ==
										 (PAPCO_SENDDATA_RECD | PAPCO_WRITEDATA_WAITING));
	
		userBytes[PAP_CONNECTIONID_OFF] = pPapConn->papco_ConnId;
		userBytes[PAP_CMDTYPE_OFF] = PAP_DATA;
	
		//	If EOF, need a non-zero value in the first byte.
		PUTSHORT2SHORT(&userBytes[PAP_EOFFLAG_OFF], 0);
		if (pPapConn->papco_Flags & PAPCO_SEND_EOF_WRITE)
			userBytes[PAP_EOFFLAG_OFF] = TRUE;
	
		pAtpResp = pPapConn->papco_pAtpResp;

		//	Reference connection for this send.
		AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);

		if (ATALK_SUCCESS(error))
		{
			AtalkAtpRespReferenceByPtrDpc(pAtpResp, &error);
		}
		else
		{
			//	Connection reference failed!
			//	Pending write would have been completed by the closing routine.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapPostSendData: Conn ref failed for %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));

			//	This should never happen as we check closing flag above and the reference
			//	shouldn't fail for any other reason.
			KeBugCheck(0);
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkPapPostSendData: HIT RACE CONDITION conn %lx Resp %lx\n",
				pPapConn, pPapConn->papco_pAtpResp));
	}

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkPapPostSendData: conn %lx Resp %lx\n",
			pPapConn, pPapConn->papco_pAtpResp));

	if (ATALK_SUCCESS(error))
	{
		//	Post the response.
		error = AtalkAtpPostResp(pAtpResp,
								 &pPapConn->papco_SendDataSrc,
								 pPapConn->papco_pWriteBuf,
								 pPapConn->papco_WriteLen,
								 userBytes,
								 atalkPapSendDataRel,
								 pPapConn);
		AtalkAtpRespDereference(pAtpResp);

		if (!ATALK_SUCCESS(error))
		{
			//	Simulate completion with an error.
			atalkPapSendDataRel(error, pPapConn);
		}
		error = ATALK_PENDING;
	}

	return error;
}




LOCAL VOID
atalkPapIncomingReadComplete(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn,		// Our context
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pReadAmdl,
	IN	USHORT			ReadLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	GENERIC_READ_COMPLETION	pReadCompletion;
	PVOID					pReadCtx;
	KIRQL					OldIrql;
	ULONG					readFlags = TDI_RECEIVE_PARTIAL;

	ASSERT(VALID_PAPCO(pPapConn));

	if (ATALK_SUCCESS(ErrorCode))
	{
		//	When a read completes, tag that we have heard something from the other side
		pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

		if ((ReadUserBytes[PAP_CONNECTIONID_OFF] != pPapConn->papco_ConnId) ||
			(ReadUserBytes[PAP_CMDTYPE_OFF] != PAP_DATA))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReadComplete: ReadUserBytes %lx. %lx\n",
					*((PULONG)ReadUserBytes), pPapConn->papco_ConnId));

			ErrorCode = ATALK_PAP_INVALID_USERBYTES;
		}
		if (ReadUserBytes[PAP_EOFFLAG_OFF] != 0)
		{
			readFlags = 0;
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapIncomingReadComplete: Error %lx for pPapConn %lx\n",
					ErrorCode, pPapConn));
	}

	ASSERT(pReqAmdl == NULL);


	// Estimate the retry interval for next time.
	if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
	{
		pPapConn->papco_RT.rt_New = AtalkGetCurrentTick() - pPapConn->papco_RT.rt_New;
		AtalkCalculateNewRT(&pPapConn->papco_RT);
	}

#ifdef	PROFILING
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkStatsLock, &OldIrql);

		AtalkStatistics.stat_LastPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);
		if ((ULONG)(pPapConn->papco_RT.rt_Base) > AtalkStatistics.stat_MaxPapRTT)
			AtalkStatistics.stat_MaxPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);

		RELEASE_SPIN_LOCK(&AtalkStatsLock, OldIrql);
	}
#endif

	//	Before we look at the incoming error code, see if we can mark in the
	//	job structure that the other sides sendData is complete.
	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	pPapConn->papco_Flags 	&= ~PAPCO_READDATA_PENDING;
	pReadCompletion			 = pPapConn->papco_ReadCompletion;
	pReadCtx				 = pPapConn->papco_ReadCtx;

	ASSERT(pReadCompletion != NULL);
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	(*pReadCompletion)(ErrorCode, pReadAmdl, ReadLen, readFlags, pReadCtx);

	//	Deref the connection object.
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID
atalkPapPrimedReadComplete(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn,		// Our context
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pReadAmdl,
	IN	USHORT			ReadLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PTDI_IND_RECEIVE 		recvHandler;
	PVOID 					recvHandlerCtx;
	PIRP					recvIrp;
	NTSTATUS				ntStatus;
	ULONG					bytesTaken;
	PBYTE					pReadBuf;
	KIRQL					OldIrql;
	PACTREQ					pActReq;
	BOOLEAN					completeRead = FALSE, delayedDisConn = FALSE;
	ULONG					readFlags = (TDI_RECEIVE_PARTIAL | TDI_RECEIVE_NORMAL);

	ASSERT(VALID_PAPCO(pPapConn));

	if (ATALK_SUCCESS(ErrorCode))
	{
		if ((ReadUserBytes[PAP_CONNECTIONID_OFF] != pPapConn->papco_ConnId) ||
			(ReadUserBytes[PAP_CMDTYPE_OFF] != PAP_DATA))
		{
			//	This will mean a primed read completes with disconnect indication to afd!!
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReadComplete: ReadUserBytes %lx. %lx\n",
					*((PULONG)ReadUserBytes), pPapConn->papco_ConnId));

			ErrorCode = ATALK_PAP_INVALID_USERBYTES;
		}
		if (ReadUserBytes[PAP_EOFFLAG_OFF] != 0)
		{
			readFlags = TDI_RECEIVE_NORMAL;
		}
	}
	else if (ErrorCode == ATALK_ATP_REQ_CANCELLED)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapIncomingReadComplete: Request cancelled\n"));
		completeRead = TRUE;
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapIncomingReadComplete: Error %lx for pPapConn %lx\n",
				ErrorCode, pPapConn));
	}

	ASSERT(pReqAmdl == NULL);

#ifdef	PROFILING
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkStatsLock, &OldIrql);

		AtalkStatistics.stat_LastPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);
		if ((ULONG)(pPapConn->papco_RT.rt_Base) > AtalkStatistics.stat_MaxPapRTT)
			AtalkStatistics.stat_MaxPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);

		RELEASE_SPIN_LOCK(&AtalkStatsLock, OldIrql);
	}
#endif

	//	Remember the info in the connection object.
	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	pActReq	= pPapConn->papco_NbReadActReq;
	recvHandler 	= pPapConn->papco_pAssocAddr->papao_RecvHandler;
	recvHandlerCtx	= pPapConn->papco_pAssocAddr->papao_RecvHandlerCtx;

	if (ATALK_SUCCESS(ErrorCode))
	{
		//	When a read completes, tag that we have heard something from the other side
		pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

		// Estimate the retry interval for next time.
		if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
		{
			pPapConn->papco_RT.rt_New = AtalkGetCurrentTick() - pPapConn->papco_RT.rt_New;
			AtalkCalculateNewRT(&pPapConn->papco_RT);
		}

		pPapConn->papco_Flags 		|= PAPCO_READDATA_WAITING;
		if (pPapConn->papco_Flags & PAPCO_RECVD_DISCONNECT)
		{
			// AFD gets awfully upset when a read is indicated after a disconnect
			recvHandler 				 = NULL;
		}
		pPapConn->papco_NbReadLen 	 = ReadLen;
		pPapConn->papco_NbReadFlags	 = readFlags;

		//	Get the system address for the mdl
		pReadBuf = (PBYTE)MmGetSystemAddressForMdlSafe(
				pActReq->ar_pAMdl,
				NormalPagePriority);

		if (pReadBuf == NULL)
		{
			pPapConn->papco_Flags 		&= ~PAPCO_NONBLOCKING_READ;
			pPapConn->papco_NbReadActReq = NULL;
			pPapConn->papco_NbReadLen 	 = 0;
		
			//	Do not indicate a receive
			recvHandler 				 = NULL;
		
			//	Complete the read
			completeRead = TRUE;
		}
	}
	else
	{
		pPapConn->papco_Flags 		&= ~PAPCO_NONBLOCKING_READ;
		pPapConn->papco_NbReadActReq = NULL;
		pPapConn->papco_NbReadLen 	 = 0;

		pReadBuf					 = NULL;

		//	Do not indicate a receive
		recvHandler 				 = NULL;

		//	Complete the read
		completeRead = TRUE;
	}

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Call the indication routine on the address object..
	if (*recvHandler != NULL)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
				("atalkPapPrimedReadComplete: Indicating when disconnecting!\n"));

		ntStatus = (*recvHandler)(recvHandlerCtx,
								  pPapConn->papco_ConnCtx,
								  readFlags,
								  pPapConn->papco_NbReadLen,
								  pPapConn->papco_NbReadLen,
								  &bytesTaken,
								  pReadBuf,
								  &recvIrp);

		ASSERT((bytesTaken == 0) || (bytesTaken == ReadLen));
		if (ntStatus == STATUS_MORE_PROCESSING_REQUIRED)
		{
			if (recvIrp != NULL)
			{
				//  Post the receive as if it came from the io system
				ntStatus = AtalkDispatchInternalDeviceControl(
								(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_PAP],
								recvIrp);

				ASSERT(ntStatus == STATUS_PENDING);
			}
			else
			{
				ASSERTMSG("atalkPapPrimedReadComplete: No receive irp!\n", 0);
				KeBugCheck(0);
			}
		}
		else if (ntStatus == STATUS_SUCCESS)
		{
			//	!!!NOTE!!!
			//	Its possible that a disconnect happened and completed
			//	the pending read already. And so AFD is returning us this
			//	for the indication as the connection is already disconnected.
			if (bytesTaken != 0)
			{
				//	Assume all of the data was read.
				ASSERT(bytesTaken == ReadLen);
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapPrimedReadComplete: All bytes read %lx\n",
							bytesTaken));

				//	We are done with the primed read.
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
				if (pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ)
				{
					pPapConn->papco_Flags 		&= ~(PAPCO_NONBLOCKING_READ |
													 PAPCO_READDATA_WAITING);

					pPapConn->papco_NbReadActReq = NULL;
					pPapConn->papco_NbReadLen 	 = 0;

					//	Complete the read
					completeRead = TRUE;
				}
				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
			}
		}
		else if (ntStatus == STATUS_DATA_NOT_ACCEPTED)
		{
			//	Client may have posted a receive in the indication. Or
			//	it will post a receive later on. Do nothing here.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapPrimedReadComplete: Indication status %lx\n", ntStatus));
		}
	}

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	if (pPapConn->papco_Flags & PAPCO_DELAYED_DISCONNECT)
	{
		delayedDisConn = TRUE;
		pPapConn->papco_Flags &= ~PAPCO_DELAYED_DISCONNECT;
	}

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Complete the action request.
	if (completeRead)
	{
		//	Call the action completion routine for the prime read.
		(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
	}

	// Finally if we have a delayed disconnect, complete the stuff
	if (delayedDisConn)
	{
		AtalkPapDisconnect(pPapConn,
						   ATALK_REMOTE_DISCONNECT,
						   NULL,
						   NULL);
	}

	//	Deref the connection object.
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID
atalkPapIncomingStatus(
	IN	ATALK_ERROR		ErrorCode,
	IN	PACTREQ			pActReq,		// Our Ctx
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pStatusAmdl,
	IN	USHORT			StatusLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Call the action completion routine
	(*pActReq->ar_Completion)(ErrorCode, pActReq);
}




LOCAL VOID FASTCALL
atalkPapSendDataRel(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PAMDL						pWriteBuf;
	SHORT						writeLen;
	GENERIC_WRITE_COMPLETION	writeCompletion;
	PVOID						writeCtx;
	PATP_RESP					pAtpResp;
	KIRQL						OldIrql;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapSendDataRel: Error %lx for pPapConn %lx\n", ErrorCode, pPapConn));

	//	If this was cancelled, then we turn the error into a no-error.
	if (ErrorCode == ATALK_ATP_RESP_CANCELLED)
		ErrorCode = ATALK_NO_ERROR;

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	pPapConn->papco_Flags  &= ~(PAPCO_WRITEDATA_WAITING		|
								PAPCO_SENDDATA_RECD			|
								PAPCO_SEND_EOF_WRITE);

	pWriteBuf		= pPapConn->papco_pWriteBuf;
	writeLen		= pPapConn->papco_WriteLen;
	writeCompletion	= pPapConn->papco_WriteCompletion;
	writeCtx		= pPapConn->papco_WriteCtx;
	pAtpResp		= pPapConn->papco_pAtpResp;
	pPapConn->papco_pAtpResp = NULL;

	ASSERT (pAtpResp != NULL);

	//	Reinitialize all the variables.
	pPapConn->papco_WriteLen	= 0;
	pPapConn->papco_pWriteBuf	= NULL;
	pPapConn->papco_WriteCtx	= NULL;
	pPapConn->papco_WriteCompletion	= NULL;
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	(*writeCompletion)(ErrorCode, pWriteBuf, writeLen, writeCtx);

	// Dereference the atp response structure now, but not if a response was never posted
	if (ErrorCode != ATALK_ATP_RESP_CLOSING)
	{
		AtalkAtpRespDereference(pAtpResp);
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapSendDataRel: Resp cancelled before post %lx\n", pPapConn));
	}

	//	Dereference the connection
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID
atalkPapSlsHandler(
	IN	ATALK_ERROR			ErrorCode,
	IN	PPAP_ADDROBJ		pPapAddr,		// Listener (our context)
	IN	PATP_RESP			pAtpResp,
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

 	Handler for incoming requests on the Sls. It handles session opens and get
 	status on the session.

Arguments:


Return Value:


--*/
{
	BYTE					connId, cmdType;
	BYTE					userBytes[ATP_USERBYTES_SIZE];
	PBYTE					pRespPkt;
	PAMDL					pRespAmdl;
	SHORT					respLen;
	PPAP_SEND_STATUS_REL	pSendSts;

	BOOLEAN					DerefAddr	= FALSE;
	ATALK_ERROR				error 		= ATALK_NO_ERROR;

	if (!ATALK_SUCCESS(ErrorCode))
	{
		//	Remove the reference on the address object since atp socket is closing
		if (ErrorCode == ATALK_ATP_CLOSING)
		{
			//	Remove reference on the connection since socket is closing
			AtalkPapAddrDereference(pPapAddr);
		}
		return;
	}

	//	Try to reference the address. If we fail, its probably closing, so
	//	get out. This reference will stay around for the duration of this call.
	AtalkPapAddrReference(pPapAddr, &error);
	if (!ATALK_SUCCESS(error))
	{
		if (pAtpResp != NULL)
		{
			AtalkAtpCancelResp(pAtpResp);
		}
		return;
	}

	//	If we have a send status request, and we manage to
	//	successfully post it, we reset this. And then it goes away in
	//	the release routine.
	DerefAddr		= TRUE;

	connId 	= pUserBytes[PAP_CONNECTIONID_OFF];
	cmdType	= pUserBytes[PAP_CMDTYPE_OFF];

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapSlsHandler: Received request %x, tid %x\n",
			cmdType, (pAtpResp != NULL) ? pAtpResp->resp_Tid : 0));

	switch(cmdType)
	{
	  case PAP_OPEN_CONN:
		//	Ensure packet length is ok.
		// Accept the connection. This will send any error replies as appropriate.
		if ((PktLen < PAP_STATUS_OFF) ||
			!atalkPapConnAccept(pPapAddr,
								pSrcAddr,
								pPkt,
								connId,
								pAtpResp))
		{
			AtalkAtpCancelResp(pAtpResp);
		}
		break;

	  case PAP_SEND_STATUS:
		userBytes[PAP_CONNECTIONID_OFF] = 0;
		userBytes[PAP_CMDTYPE_OFF] 		= PAP_STATUS_REPLY;
		PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

		//	We need to put in the status with the spinlock of the
		//	address object held.
		ACQUIRE_SPIN_LOCK_DPC(&pPapAddr->papao_Lock);
		do
		{
			//	Get a buffer we can send the response with.
			ASSERTMSG("atalkPapSlsHandler: Status size incorrec\n",
					 (pPapAddr->papao_StatusSize >= 0));

			if ((pSendSts = AtalkAllocMemory(sizeof(PAP_SEND_STATUS_REL) +
											 pPapAddr->papao_StatusSize))== NULL)
			{
				error = ATALK_RESR_MEM;
				break;
			}

			respLen		= PAP_STATUS_OFF + 1;
			ASSERT(pPapAddr->papao_StatusSize <= PAP_MAX_STATUS_SIZE);

			pRespPkt = pSendSts->papss_StatusBuf;
			pRespPkt[PAP_STATUS_OFF]	= (BYTE)pPapAddr->papao_StatusSize;

			// Zero out the unused portion of the buffer
			PUTDWORD2DWORD(pRespPkt, 0);

			if (pPapAddr->papao_StatusSize > 0)
			{
				RtlCopyMemory(pRespPkt + 1 + PAP_STATUS_OFF,
							  pPapAddr->papao_pStatusBuf,
							  pPapAddr->papao_StatusSize);

				respLen += pPapAddr->papao_StatusSize;
				ASSERT(respLen <= PAP_MAX_DATA_PACKET_SIZE);
			}

			//	Build an mdl for the length that we are using.
			if ((pRespAmdl = AtalkAllocAMdl(pRespPkt, respLen)) == NULL)
			{
				error = ATALK_RESR_MEM;
				AtalkFreeMemory(pSendSts);
				break;
			}

			pSendSts->papss_pAmdl		= pRespAmdl;
			pSendSts->papss_pPapAddr	= pPapAddr;
			pSendSts->papss_pAtpResp	= pAtpResp;
		} while (FALSE);

		RELEASE_SPIN_LOCK_DPC(&pPapAddr->papao_Lock);

		if (!ATALK_SUCCESS(error))
		{
			AtalkAtpCancelResp(pAtpResp);
			break;
		}

		ASSERT(pSendSts != NULL);
		ASSERT((pRespAmdl != NULL) && (respLen > 0));

		error = AtalkAtpPostResp(pAtpResp,
								 pSrcAddr,
								 pRespAmdl,
								 respLen,
								 userBytes,
								 atalkPapStatusRel,
								 pSendSts);

		//	atalkPapStatusRel Dereferences the address.
		DerefAddr = FALSE;
		if (!ATALK_SUCCESS(error))
		{
			atalkPapStatusRel(error, pSendSts);
		}
		break;

	  default:
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapSlsHandler: Invalid request %x\n", cmdType));
		AtalkAtpCancelResp(pAtpResp);
		break;
	}

	//	Remove reference added at the beginning.
	if (DerefAddr)
	{
		AtalkPapAddrDereference(pPapAddr);
	}
}




LOCAL VOID
atalkPapIncomingReq(
	IN	ATALK_ERROR			ErrorCode,
	IN	PPAP_CONNOBJ		pPapConn,		// Connection (our context)
	IN	PATP_RESP			pAtpResp,
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

	This handles requests on a connection, SendData, Tickles, and Close.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	BYTE					connId, cmdType;
	USHORT					seqNum;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;
	BOOLEAN					DerefConn = FALSE;
	BOOLEAN					cancelResp = TRUE;

	ASSERT(VALID_PAPCO(pPapConn));

	do
	{
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
					("atalkPapIncomingReq: pPapConn %lx, ErrorCode %ld, exit.\n",
					pPapConn, ErrorCode));

			if (ErrorCode == ATALK_ATP_CLOSING)
			{
				//	Remove reference on the connection since socket is closing
				AtalkPapConnDereference(pPapConn);
				break;
			}
		}

		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		if ((pPapConn->papco_Flags & (PAPCO_ACTIVE			|
									  PAPCO_STOPPING		|
									  PAPCO_LOCAL_DISCONNECT|
									  PAPCO_DISCONNECTING	|
									  PAPCO_CLOSING)) == PAPCO_ACTIVE)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		}
		else
		{
			error = ATALK_INVALID_CONNECTION;
		}
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReq: Ref FAILED/DISC %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));
			break;
		}

		//	Remember to remove connection referenced above
		DerefConn = TRUE;

		connId 	= pUserBytes[PAP_CONNECTIONID_OFF];
		cmdType	= pUserBytes[PAP_CMDTYPE_OFF];

		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("atalkPapIncomingReq: Received request %x, tid %x\n",
				cmdType, (pAtpResp != NULL) ? pAtpResp->resp_Tid : 0));

		if (connId != pPapConn->papco_ConnId)
		{
			//	Just drop this packet. Cancel response though in case this is
			//	a xo request
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: ConnId %lx recd %lx\n",
					pPapConn->papco_ConnId, connId));
			break;
		}

		pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

		switch (cmdType)
		{
		  case PAP_SEND_DATA:

			GETSHORT2SHORT(&seqNum, &pUserBytes[PAP_SEQNUM_OFF]);

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: send data %lx recd %lx\n",
					seqNum, pPapConn->papco_ConnId));

			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			if ((seqNum == 0) &&
				(pPapConn->papco_Flags & PAPCO_SENDDATA_RECD))
			{
			   //	We have an unsequenced incoming sendData request before we've
			   //	finished with the previous one (i.e gotten a release for it).
			   //	We don't clear the PAPCO_SENDDATA_RECD flag until we receive
			   //	a release or time out. Also, we cannot assume an implied
			   //	release as we can with sequenced requests. So we just cancel
			   //	the response  so we can be notified of a retry of the send
			   //	data request again
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapIncomingReq: Dropping unseq send data %lx\n", pAtpResp));
				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				break;
			}

			if (seqNum != 0)
			{
				//	Sequenced send data. Verify the seq num.
				if (seqNum != (USHORT)(pPapConn->papco_NextIncomingSeqNum))
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
							("atalkPapIncomingReq: Out of Seq - current %lx, incoming %lx on %lx\n",
							pPapConn->papco_NextIncomingSeqNum, seqNum, pPapConn));

					//	Cancel our response.
					RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
					break;
				}

				if (pPapConn->papco_Flags & PAPCO_SENDDATA_RECD)
				{
					USHORT	tid;

					//	We have a send data before the previous one has completed.
					//	As PAP is a one-request-at-a-time protocol, we can assume
					//	that the release for previous transaction is lost. This
					//	gets rid of the 30 second pauses when a release is dropped.
					//	Cancel our response. Note this implies that a response
					//	had been posted by the pap client. In SendRel then, we
					//	convert the response cancelled error to no error.

					ASSERT (pPapConn->papco_pAtpResp != NULL);

					tid = pPapConn->papco_pAtpResp->resp_Tid;

					RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
							("atalkPapIncomingReq: Cancelling response tid %x\n", tid));

					// CAUTION: We cannot use AtalkAtpCancelResp() since we have no
					//			reference to the resp structure and involves a potential
					//			race condition. Play safe and cancel by tid instead.
					error = AtalkAtpCancelRespByTid(pPapConn->papco_pAtpAddr,
													&pPapConn->papco_SendDataSrc,
													tid);

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("atalkPapIncomingReq: Cancel error %lx\n", error));

					//	If we were unable to cancel the response that means that
					//	it already timed out or got a release. We dont want to
					//	get into a situation where we would be messing with variables
					//	accessed both in the SendDataRel and here. So we just
					//	cancel this response and hope to get it again.
					if (!ATALK_SUCCESS(error))
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
								("atalkPapIncomingReq: Cancel old resp tid %x (%ld)\n",
								tid, error));
						break;
					}

					ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
					pPapConn->papco_pAtpResp = NULL;
					pPapConn->papco_Flags &= ~(PAPCO_SENDDATA_RECD | PAPCO_WRITEDATA_WAITING);
				}

				//	Increment the sequence number. If we loop to 0, set to 1.
				if (++pPapConn->papco_NextIncomingSeqNum == 0)
				{
					pPapConn->papco_NextIncomingSeqNum = 1;
				}

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: Recd %lx Next %lx\n",
						seqNum, pPapConn->papco_NextIncomingSeqNum));
			}
			else
			{
				//	Unsequenced send data received. Handle it.
				ASSERT (seqNum != 0);
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: Unsequenced  send data recd!\n"));
			}

			cancelResp	= FALSE;
			ASSERT((pPapConn->papco_Flags & PAPCO_SENDDATA_RECD) == 0);
			pPapConn->papco_Flags 			|= PAPCO_SENDDATA_RECD;

			pPapConn->papco_pAtpResp		 = pAtpResp;

			//	The mac may not send its 'SendData' from its responding socket
			//	(the one we are tickling and have noted as papco_RemoteAddr), we need
			//	to address the response to the socket that the request originated on.
			pPapConn->papco_SendDataSrc		 = *pSrcAddr;

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: send data src %lx.%lx.%lx\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));

			//	remember send possible handler/context.
			sendPossibleHandler	= pPapConn->papco_pAssocAddr->papao_SendPossibleHandler;
			sendPossibleHandlerCtx = pPapConn->papco_pAssocAddr->papao_SendPossibleHandlerCtx;

			if (pPapConn->papco_Flags & PAPCO_WRITEDATA_WAITING)
			{
				// RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: Posting send data resp\n"));

				// atalkPostSendDataResp() will release the conn lock
				atalkPapPostSendDataResp(pPapConn);
			}
			else
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: No WriteData waiting\n"));

				if (sendPossibleHandler != NULL)
				{
					(*sendPossibleHandler)(sendPossibleHandlerCtx,
										   pPapConn->papco_ConnCtx,
										   pPapConn->papco_SendFlowQuantum*PAP_MAX_DATA_PACKET_SIZE);
				}

				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			}
			break;

		  case PAP_CLOSE_CONN:
  			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: Close conn recvd. for connection %lx\n",
					pPapConn));

			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			pPapConn->papco_Flags |= (PAPCO_REMOTE_DISCONNECT | PAPCO_RECVD_DISCONNECT);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			//	Post the close connection reply.
			cancelResp	= FALSE;
			pUserBytes[PAP_CMDTYPE_OFF]	= PAP_CLOSE_CONN_REPLY;
			AtalkAtpPostResp(pAtpResp,
							 pSrcAddr,
							 NULL,		// Response buffer
							 0,
							 pUserBytes,
							 AtalkAtpGenericRespComplete,
							 pAtpResp);

			//	PapDisconnect will call the disconnect indication routine if set.
			AtalkPapDisconnect(pPapConn,
							   ATALK_REMOTE_DISCONNECT,
							   NULL,
							   NULL);
			break;

		  case PAP_TICKLE:
			//	We've already registered contact.
			// Cancel this response since we never respond to it and we want this to go away
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: Recvd. tickle - resp %lx\n", pAtpResp));
			cancelResp = TRUE;
			break;

		  default:
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReq: Invalid command %x\n", cmdType));
			cancelResp = TRUE;
			break;
		}
	} while (FALSE);

	if (cancelResp & (pAtpResp != NULL))
	{
		AtalkAtpCancelResp(pAtpResp);
	}

	if (DerefConn)
	{
		//	Remove reference added at the beginning.
		AtalkPapConnDereference(pPapConn);
	}
}




LOCAL VOID
atalkPapIncomingOpenReply(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn,		// Our context
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pReadAmdl,
	IN	USHORT			ReadLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG					index;
	KIRQL					OldIrql;
	ATALK_ERROR				error;
	USHORT					statusLen, i, connectStatus;
	BYTE					userBytes[ATP_USERBYTES_SIZE];
	PBYTE					pRespPkt, pOpenPkt;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;
	PPAP_ADDROBJ			pPapAddr = pPapConn->papco_pAssocAddr;

	ASSERT(VALID_PAPCO(pPapConn));
	pRespPkt = pPapConn->papco_pConnectRespBuf;
	pOpenPkt = pPapConn->papco_pConnectOpenBuf;

	ASSERT(pRespPkt != NULL);
	ASSERT(pOpenPkt != NULL);

	if (ATALK_SUCCESS(ErrorCode))
	{
		//	Well, lets see what kind of response we got; take a look at both the
		//	response user-bytes and the response buffer.  Note that we now allow
		//	the LaserWriter IIg to leave the status string off altogether,
		//	rather than the [correct] zero-sized string.
		do
		{
			//	The reply length should be atleast the minimum and it should be
			// an open-reply we are looking at.
			if ((ReadLen < PAP_STATUS_OFF) ||
                (ReadUserBytes[PAP_CMDTYPE_OFF] != PAP_OPEN_CONNREPLY))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapIncomingOpenReply: Invalid read len or cmd %x/%x\n",
						ReadLen, ReadUserBytes[PAP_CMDTYPE_OFF]));

				ErrorCode = ATALK_REMOTE_CLOSE;
				break;
			}

			if (ReadLen == PAP_STATUS_OFF)
			{
				statusLen = 0;	//	Missing, from the LaserWriter IIg
			}
			else
			{
				//	Verify length.
				statusLen = pRespPkt[PAP_STATUS_OFF];
				if ((statusLen != 0) &&
					((statusLen + 1 + PAP_STATUS_OFF) > ReadLen))
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
							("atalkPapIncomingOpenReply: Invalid status len %lx\n", ReadLen));

					ErrorCode = ATALK_REMOTE_CLOSE;
					break;
				}
			}

			//	Check for connect result.
			GETSHORT2SHORT(&connectStatus, &pRespPkt[PAP_RESULT_OFF]);

			//	Check for open reply code in packet. Do not check the
			//	connectionid unless the response is success. Some rips
			//	are known to send a bogus connectionid if the return
			//	code is 'busy'.
			if ((connectStatus == 0) &&
				(ReadUserBytes[PAP_CONNECTIONID_OFF] != pPapConn->papco_ConnId))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapIncomingOpenReply: Invalid connid %x, expected %x\n",
						ReadUserBytes[PAP_CONNECTIONID_OFF], pPapConn->papco_ConnId));

				ErrorCode = ATALK_REMOTE_CLOSE;
				break;
			}

			if (connectStatus != 0)
			{
				ATALK_ERROR	ReconnectError;

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
						("atalkPapIncomingOpenReply: server busy %lx\n", connectStatus));

				ErrorCode = ATALK_PAP_SERVER_BUSY;

				// If we have not yet reached the max. timeout, retry
				if (pPapConn->papco_WaitTimeOut < PAP_MAX_WAIT_TIMEOUT)
				{
					pPapConn->papco_WaitTimeOut ++;
					ReconnectError = atalkPapRepostConnect(pPapConn, pReqAmdl, pReadAmdl);
                    if (ATALK_SUCCESS(ReconnectError))
						return;		// Exit now
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
							("atalkPapIncomingOpenReply: Post reconnect failed %lx\n", ReconnectError));
				}
				break;
			}

			//	Switch the socket of the remote address to be the one specified
			//	by the remote end.
			pPapConn->papco_RemoteAddr.ata_Socket 	= pRespPkt[PAP_RESP_SOCKET_OFF];
			pPapConn->papco_SendFlowQuantum			= pRespPkt[PAP_FLOWQUANTUM_OFF];
			if (pPapConn->papco_SendFlowQuantum > PAP_MAX_FLOW_QUANTUM)
			{
				pPapConn->papco_SendFlowQuantum = PAP_MAX_FLOW_QUANTUM;
			}

		} while (FALSE);

		if (ATALK_SUCCESS(ErrorCode))
		{
			//	Build up userBytes to start tickling the other end.
			userBytes[PAP_CONNECTIONID_OFF] = pPapConn->papco_ConnId;
			userBytes[PAP_CMDTYPE_OFF] 		= PAP_TICKLE;
			PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingOpenReply: id %lx Rem %lx.%lx.%lx RespSkt %lx\n",
					pPapConn->papco_ConnId, pPapConn->papco_RemoteAddr.ata_Network,
					pPapConn->papco_RemoteAddr.ata_Node, pPapConn->papco_RemoteAddr.ata_Socket,
					PAPCONN_DDPSOCKET(pPapConn)));

			error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
									&pPapConn->papco_RemoteAddr,
									&pPapConn->papco_TickleTid,
									0,						// ALO transaction
									NULL,
									0,
									userBytes,
									NULL,
									0,
									ATP_INFINITE_RETRIES,
									PAP_TICKLE_INTERVAL,
									THIRTY_SEC_TIMER,
									NULL,
									NULL);

			ASSERT(ATALK_SUCCESS(error));

			index = PAP_HASH_ID_ADDR(pPapConn->papco_ConnId, &pPapConn->papco_RemoteAddr);

			//	Move the connection from the connect list to the active list.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			//	Make sure flags are clean.
			pPapConn->papco_Flags			   &= ~(PAPCO_SENDDATA_RECD		|
													PAPCO_WRITEDATA_WAITING	|
													PAPCO_SEND_EOF_WRITE   	|
													PAPCO_READDATA_PENDING 	|
													PAPCO_REMOTE_CLOSE	 	|
													PAPCO_NONBLOCKING_READ 	|
													PAPCO_READDATA_WAITING);

			pPapConn->papco_Flags &= ~PAPCO_CONNECTING;
			pPapConn->papco_Flags |= PAPCO_ACTIVE;
			atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);

			//	Thread the connection object into addr lookup by session id.
			pPapConn->papco_pNextActive	 = pPapAddr->papao_pActiveHash[index];
			pPapAddr->papao_pActiveHash[index]	= pPapConn;

			//	Reference for the request handler
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);

			//	Call the send data event handler on the associated address with
			//	0 to turn off selects on writes. We do this before we post any
			//	get requests, so there is no race condition.
			//	remember send possible handler/context.
			sendPossibleHandler	= pPapAddr->papao_SendPossibleHandler;
			sendPossibleHandlerCtx = pPapAddr->papao_SendPossibleHandlerCtx;

			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

			if (sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pPapConn->papco_ConnCtx,
									   0);
			}

			//	Set the request handler on this connection.
			//	It will handle tickle's, close's and sendData's.

			AtalkAtpSetReqHandler(pPapConn->papco_pAtpAddr,
								  atalkPapIncomingReq,
								  pPapConn);

			pPapConn->papco_LastContactTime	= AtalkGetCurrentTick();
		}
		else
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingOpenReply: Incoming connect fail %lx\n", ErrorCode));

			//	Move the connection out of the connect list.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			pPapConn->papco_Flags &= ~PAPCO_CONNECTING;
			atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
		}
	}
	else
	{
		//	Move the connection out of the connect list.
		ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);
		pPapConn->papco_Flags &= ~PAPCO_CONNECTING;
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
	}

	//	Free the buffers.
	AtalkFreeMemory(pRespPkt);
	AtalkFreeMemory(pOpenPkt);
	AtalkFreeAMdl(pReadAmdl);
	AtalkFreeAMdl(pReqAmdl);

	//	Call the completion routine.
	(*pPapConn->papco_ConnectCompletion)(ErrorCode, pPapConn->papco_ConnectCtx);

	//	Remove reference for this handler.
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID FASTCALL
atalkPapIncomingRel(
	IN	ATALK_ERROR			ErrorCode,
	IN	PPAP_OPEN_REPLY_REL	pOpenReply
	)
/*++

Routine Description:

 	Handler for incoming release for reply

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapIncomingRel: Called %lx for pOpenReply %lx\n",
			ErrorCode, pOpenReply));

	ASSERT(pOpenReply != NULL);
	ASSERT(pOpenReply->papor_pRespAmdl != NULL);

	// Dereference the atp response structure now
	AtalkAtpRespDereference(pOpenReply->papor_pAtpResp);

	AtalkFreeAMdl(pOpenReply->papor_pRespAmdl);
	AtalkFreeMemory(pOpenReply);
}




LOCAL VOID FASTCALL
atalkPapStatusRel(
	IN	ATALK_ERROR				ErrorCode,
	IN	PPAP_SEND_STATUS_REL	pSendSts
	)
/*++

Routine Description:

 	Handler for incoming release for reply

Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;

	UNREFERENCED_PARAMETER(ErrorCode);

	ASSERT(pSendSts != NULL);
	ASSERT(pSendSts->papss_pAmdl != NULL);

	// Dereference the atp response structure now
	AtalkAtpRespDereference(pSendSts->papss_pAtpResp);

	AtalkPapAddrDereference(pSendSts->papss_pPapAddr);
	AtalkFreeAMdl(pSendSts->papss_pAmdl);
	AtalkFreeMemory(pSendSts);
}



#define		SLS_OPEN_RESP_SOCKET		0x0001
#define		SLS_OPEN_RESP_PKT			0x0002
#define		SLS_OPEN_RESP_MDL			0x0004
#define		SLS_OPEN_CONN_REF			0x0008
#define		SLS_ACCEPT_IRP				0x0010
#define		SLS_CONN_REQ_REFS			0x0020
#define		SLS_CONN_TIMER_REF			0x0040
#define		SLS_LISTEN_DEQUEUED			0x0080

BOOLEAN
atalkPapConnAccept(
	IN	PPAP_ADDROBJ		pPapAddr,		// Listener
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	PBYTE				pPkt,
	IN	BYTE				ConnId,
	IN	PATP_RESP			pAtpResp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				tmpError;
	BYTE					userBytes[ATP_USERBYTES_SIZE];
	PBYTE					pRespPkt;
	PAMDL					pRespAmdl;
	PATP_ADDROBJ			pRespondingAtpAddr;
	PPAP_CONNOBJ			pPapConn;
	ULONG					index;
	SHORT					respLen, i;
	PPAP_OPEN_REPLY_REL		pOpenReply;
	GENERIC_COMPLETION		listenCompletion;
	PVOID					listenCtx;
	KIRQL					OldIrql;
	PIRP					acceptIrp;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;

	USHORT					openResr	= 0;
	ATALK_ERROR				error 		= ATALK_NO_ERROR;
	BOOLEAN					indicate  	= FALSE;
	BOOLEAN					relAddrLock	= FALSE;
	BOOLEAN					DerefAddr	= FALSE;
	BOOLEAN					sendOpenErr	= FALSE;

	//	Get a buffer we can send the response with.
	if ((pOpenReply = (PPAP_OPEN_REPLY_REL)
						AtalkAllocMemory(sizeof(PAP_OPEN_REPLY_REL))) == NULL)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapConnAccept: Could not allocate resp packet\n"));
		return FALSE;
	}

	//	NOTE! pOpenReply contains a max sized packet. Get a ptr to work with.
	pRespPkt 	 = pOpenReply->papor_pRespPkt;
	openResr	|= SLS_OPEN_RESP_PKT;

	//	Build up the response packet. If we encounter an error later on,
	//	just set the error code in packet.
	userBytes[PAP_CONNECTIONID_OFF] = ConnId;
	userBytes[PAP_CMDTYPE_OFF] 		= PAP_OPEN_CONNREPLY;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], PAP_NO_ERROR);

	//	!!!NOTE!!!
	//	The socket will be set after the connection is determined.
	//	This will only happen in the non-error case.

	pRespPkt[PAP_FLOWQUANTUM_OFF]	= PAP_MAX_FLOW_QUANTUM;
	PUTSHORT2SHORT(&pRespPkt[PAP_RESULT_OFF], 0);

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	relAddrLock = TRUE;

	do
	{
		//	We need to put in the status with the spinlock of the
		//	address object held.
		pRespPkt[PAP_STATUS_OFF] = (BYTE)pPapAddr->papao_StatusSize;
		ASSERT((pPapAddr->papao_StatusSize  >= 0) &&
			   (pPapAddr->papao_StatusSize <= PAP_MAX_STATUS_SIZE));

		if (pPapAddr->papao_StatusSize > 0)
		{
			ASSERT(pPapAddr->papao_pStatusBuf != NULL);
			RtlCopyMemory(pRespPkt+PAP_STATUS_OFF+1,
						  pPapAddr->papao_pStatusBuf,
						  pPapAddr->papao_StatusSize);
		}

		respLen = PAP_STATUS_OFF + pPapAddr->papao_StatusSize + 1;
		ASSERT(respLen <= PAP_MAX_DATA_PACKET_SIZE);

		//	Build an mdl for the length that we are using.
		if ((pRespAmdl = AtalkAllocAMdl(pRespPkt, respLen)) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		pOpenReply->papor_pRespAmdl = pRespAmdl;
		pOpenReply->papor_pAtpResp = pAtpResp;
		openResr	|= SLS_OPEN_RESP_MDL;

		//	Send an open status whatever happens now. If ATALK_SUCCESS(error)
		//	we send out a connection accept packets. Assume blocked. If
		//	unblocked and we are able to get a connection object, error will
		//	be set to success.
		sendOpenErr  = TRUE;
		error 		 = ATALK_RESR_MEM;

		//	If PapUnblockedState - either there is a GetNextJob posted, or
		//	an incoming event handler is set on the listener.
		if (pPapAddr->papao_Flags & PAPAO_UNBLOCKED)
		{
			PTDI_IND_CONNECT		indicationRoutine;
			PVOID					indicationCtx;
			NTSTATUS				status;
			CONNECTION_CONTEXT  	ConnCtx;
			TA_APPLETALK_ADDRESS	tdiAddr;

			//	either a getnextjob() or a listener is set.
			//	depending on which one it is, dequeue or remember the listener.
			if (pPapAddr->papao_pListenConn != NULL)
			{
				//	There a connection with a pending listen. use it.
				pPapConn = pPapAddr->papao_pListenConn;
				if (((pPapAddr->papao_pListenConn = pPapConn->papco_pNextListen) == NULL) &&
					(pPapAddr->papao_ConnHandler == NULL))
				{
					//	We have no more listens pending! No event handler either.
					pPapAddr->papao_Flags &= ~PAPAO_UNBLOCKED;
#if DBG
					pPapAddr->papao_Flags |= PAPAO_BLOCKING;
#endif
				}

				ASSERT(VALID_PAPCO(pPapConn));

				//	Reference the connection object with a listen posted on it.
				AtalkPapConnReferenceByPtrDpc(pPapConn, &error);
				if (!ATALK_SUCCESS(error))
				{
					break;
				}

				//	Get the listen completion information
				listenCompletion 	= pPapConn->papco_ListenCompletion;
				listenCtx			= pPapConn->papco_ListenCtx;

				openResr	|= (SLS_OPEN_CONN_REF | SLS_LISTEN_DEQUEUED);
			}
			else if ((indicationRoutine = pPapAddr->papao_ConnHandler) != NULL)
			{
				indicationCtx	= pPapAddr->papao_ConnHandlerCtx;
				indicate 		= TRUE;

				//	Convert remote atalk address to tdi address
				ATALKADDR_TO_TDI(&tdiAddr, pSrcAddr);

				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				relAddrLock = FALSE;

				acceptIrp = NULL;
				status = (*indicationRoutine)(indicationCtx,
											  sizeof(tdiAddr),
											  (PVOID)&tdiAddr,
											  0,			// User data length
											  NULL,			// User data
											  0,			// Option length
											  NULL,			// Options
											  &ConnCtx,
											  &acceptIrp);

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnAccept: indicate status %lx\n", status));

				if (status == STATUS_MORE_PROCESSING_REQUIRED)
				{
				    ASSERT(acceptIrp != NULL);

					if (acceptIrp != NULL)
					{
						openResr	|= SLS_ACCEPT_IRP;
					}

					//  Find the connection and accept the connection using that
					//	connection object.
					ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
					relAddrLock = TRUE;

					AtalkPapConnReferenceByCtxNonInterlock(pPapAddr,
														   ConnCtx,
														   &pPapConn,
														   &error);
					if (!ATALK_SUCCESS(error))
					{
						break;
					}
					openResr	|= SLS_OPEN_CONN_REF;
				}
				else
				{
					ASSERT(acceptIrp == NULL);
					error 	= ATALK_RESR_MEM;
					break;
				}
			}
			else
			{
				//	The UNBLOCKED bit was set.
				ASSERT(0);
				KeBugCheck(0);
			}
		}

		if (openResr & SLS_OPEN_CONN_REF)
		{
			if (relAddrLock)
			{
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				relAddrLock = FALSE;
			}

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnAccept: Creating an Atp address\n"));

			//	Now on NT, we will mostly (always) be using the indication, as PAP
			//	will be exposed only through winsock.
			error = AtalkAtpOpenAddress(AtalkDefaultPort,
										0,
										NULL,
										PAP_MAX_DATA_PACKET_SIZE,
										PAP_SEND_USER_BYTES_ALL,
										NULL,
										TRUE,		// CACHE address
										&pRespondingAtpAddr);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapConnAccept: Error open atp resp socket %lx\n", error));
				break;
			}
			openResr	|= SLS_OPEN_RESP_SOCKET;

			//	Common for both listen and indicate. The connection object
			//	should be referenced.

			//	Store the information in the connection structure given by
			//	the connection object thats passed back in the indication
			//	or is part of the getnextjob structure.

			pPapConn->papco_Flags	   	   |= PAPCO_SERVER_JOB;
			pPapConn->papco_RemoteAddr   	= *pSrcAddr;
			pPapConn->papco_RemoteAddr.ata_Socket = pPkt[PAP_RESP_SOCKET_OFF];
			pPapConn->papco_ConnId			= ConnId;
			pPapConn->papco_SendFlowQuantum	= pPkt[PAP_FLOWQUANTUM_OFF];
			pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnAccept: ConnId %lx Rem %lx.%lx.%lx\n",
					ConnId, pSrcAddr->ata_Network, pSrcAddr->ata_Node,
					pPkt[PAP_RESP_SOCKET_OFF]));

			ASSERT(pPapConn->papco_SendFlowQuantum > 0);

			if (pPapConn->papco_SendFlowQuantum > PAP_MAX_FLOW_QUANTUM)
				pPapConn->papco_SendFlowQuantum = PAP_MAX_FLOW_QUANTUM;

			//	Thread the connection object into addr lookup by session id.
			index = PAP_HASH_ID_ADDR(ConnId, &pPapConn->papco_RemoteAddr);

			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			relAddrLock = TRUE;

			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			//	Try to reference the connection for the request handler that we
			//	are going to set
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);

			if (!ATALK_SUCCESS(error))
			{
				ASSERT(0);

				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				break;
			}

			openResr	|= (SLS_CONN_REQ_REFS | SLS_CONN_TIMER_REF);

			// The connection object could be re-used by AFD. Make sure it is
			// in the right state
			pPapConn->papco_NextOutgoingSeqNum = 1;				// Set to 1, not 0.
			pPapConn->papco_NextIncomingSeqNum = 1;				// Next expected incoming.
			AtalkInitializeRT(&pPapConn->papco_RT,
							  PAP_INIT_SENDDATA_REQ_INTERVAL,
							  PAP_MIN_SENDDATA_REQ_INTERVAL,
							  PAP_MAX_SENDDATA_REQ_INTERVAL);
			pPapConn->papco_Flags &= ~(PAPCO_LISTENING			|
									   PAPCO_DELAYED_DISCONNECT |
                                       PAPCO_DISCONNECTING		|
									   PAPCO_RECVD_DISCONNECT	|
									   PAPCO_LOCAL_DISCONNECT	|
									   PAPCO_REMOTE_DISCONNECT	|
									   PAPCO_SENDDATA_RECD		|
									   PAPCO_WRITEDATA_WAITING	|
									   PAPCO_SEND_EOF_WRITE		|
									   PAPCO_READDATA_PENDING	|
                                       PAPCO_NONBLOCKING_READ	|
                                       PAPCO_READDATA_WAITING	|
#if DBG
                                       PAPCO_CLEANUP			|
                                       PAPCO_INDICATE_AFD_DISC	|
#endif
                                       PAPCO_REMOTE_CLOSE);

			pPapConn->papco_Flags |= PAPCO_ACTIVE;
			pPapConn->papco_pNextActive = pPapAddr->papao_pActiveHash[index];
			pPapAddr->papao_pActiveHash[index] = pPapConn;

			//	Remember the responding socket.
			pPapConn->papco_pAtpAddr = pRespondingAtpAddr;

			//	Set the socket in the packet we'll be sending.
			pRespPkt[PAP_RESP_SOCKET_OFF]	= PAPCONN_DDPSOCKET(pPapConn);

			//	Call the send data event handler on the associated address with
			//	0 to turn off selects on writes. We do this before we post any
			//	get requests, so there is no race condition.
			//	remember send possible handler/context.
			sendPossibleHandler	= pPapAddr->papao_SendPossibleHandler;
			sendPossibleHandlerCtx = pPapAddr->papao_SendPossibleHandlerCtx;

			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		}
	} while (FALSE);

	if (relAddrLock)
	{
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
	}

	//	This reference needs to go regardless.
	if (openResr & SLS_OPEN_CONN_REF)
	{
		//	Remove the reference for the listen dequeued/indication accept.
		AtalkPapConnDereference(pPapConn);
	}

	if (sendOpenErr)
	{
		if (!ATALK_SUCCESS(error))
		{
			//	Send error status.
			PUTSHORT2SHORT(&pRespPkt[PAP_RESULT_OFF], PAP_PRINTER_BUSY);
		}
		else
		{
			//	Set the request handler on this connection. It will handle
			//	tickle's, close's and sendData's. Do this before we send
			//	the open reply so that we dont miss the first send data.
			openResr 	&= ~SLS_CONN_REQ_REFS;
			AtalkAtpSetReqHandler(pPapConn->papco_pAtpAddr,
								  atalkPapIncomingReq,
								  pPapConn);
		}

		if (ATALK_SUCCESS(AtalkAtpPostResp(pAtpResp,
										   pSrcAddr,
										   pRespAmdl,
										   respLen,
										   userBytes,
										   atalkPapIncomingRel,
										   pOpenReply)))
		{
			//	We want the completion to free up the buffer/mdl.
			openResr   &= ~(SLS_OPEN_RESP_PKT | SLS_OPEN_RESP_MDL);
		}
	}


	if (ATALK_SUCCESS(error))
	{
		//	We better have sent the open reply.
		ASSERT(sendOpenErr);
		ASSERT(VALID_ATPAO(pPapConn->papco_pAtpAddr));

		if ((openResr & (SLS_ACCEPT_IRP & SLS_OPEN_CONN_REF)) ==
						(SLS_ACCEPT_IRP & SLS_OPEN_CONN_REF))
		{
			//	Only if we got a referenced connection through an accept
			//	do we call the send possible.
			if (sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pPapConn->papco_ConnCtx,
									   0);
			}
		}

		//	Build up userBytes to start tickling the other end.
		userBytes[PAP_CONNECTIONID_OFF] = ConnId;
		userBytes[PAP_CMDTYPE_OFF] 		= PAP_TICKLE;
		PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

		tmpError = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
									&pPapConn->papco_RemoteAddr,
									&pPapConn->papco_TickleTid,
									0,						// AtLeastOnce
									NULL,
									0,
									userBytes,
									NULL,
									0,
									ATP_INFINITE_RETRIES,
									PAP_TICKLE_INTERVAL,
									THIRTY_SEC_TIMER,
									NULL,
									NULL);

		ASSERT(ATALK_SUCCESS(tmpError));

		pPapConn->papco_LastContactTime	= AtalkGetCurrentTick();
	}
	else
	{
		//	Release all resources
		if (openResr & SLS_OPEN_RESP_SOCKET)
		{
			AtalkAtpCloseAddress(pRespondingAtpAddr, NULL, NULL);
		}

		if (openResr & SLS_OPEN_RESP_MDL)
		{
			AtalkFreeAMdl(pOpenReply->papor_pRespAmdl);
		}

		if (openResr & SLS_OPEN_RESP_PKT)
		{
			AtalkFreeMemory(pOpenReply);
		}

		if (openResr & SLS_CONN_TIMER_REF)
		{
			AtalkPapConnDereference(pPapConn);
		}
	}

	if (openResr & SLS_LISTEN_DEQUEUED)
	{
		ASSERT(!indicate);
		ASSERT(listenCompletion != NULL);
		(*listenCompletion)(error, listenCtx);
	}

	if (openResr & SLS_ACCEPT_IRP)
	{
		acceptIrp->IoStatus.Information = 0;
		ASSERT (error != ATALK_PENDING);

		TdiCompleteRequest(acceptIrp, AtalkErrorToNtStatus(error));
	}

	return sendOpenErr;
}




LOCAL LONG FASTCALL
atalkPapConnMaintenanceTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn;
	ATALK_ERROR		error;
	BOOLEAN			Close;

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapConnMaintenanceTimer: Entered \n"));

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	ACQUIRE_SPIN_LOCK_DPC(&atalkPapLock);

	// Walk the list of connections on the global list and shut down
	// ones that have not tickle'd for a while
	for (pPapConn = atalkPapConnList; pPapConn != NULL; NOTHING)
	{
		ASSERT(VALID_PAPCO(pPapConn));
		Close = FALSE;

		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

		if (((pPapConn->papco_Flags & (PAPCO_ACTIVE				|
									   PAPCO_CLOSING			|
									   PAPCO_STOPPING			|
									   PAPCO_DELAYED_DISCONNECT	|
									   PAPCO_DISCONNECTING)) == PAPCO_ACTIVE) &&
			((AtalkGetCurrentTick() - pPapConn->papco_LastContactTime) > PAP_CONNECTION_INTERVAL))
		{
			//	Connection has expired.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapConnMaintenanceTimer: Connection %lx.%lx expired\n",
					pPapConn, pPapConn->papco_ConnId));
			Close = TRUE;
		}

		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

		if (Close)
		{
			AtalkPapConnReferenceByPtrDpc(pPapConn, &error);
			if (ATALK_SUCCESS(error))
			{
				RELEASE_SPIN_LOCK_DPC(&atalkPapLock);
				AtalkPapDisconnect(pPapConn,
								   ATALK_TIMER_DISCONNECT,
								   NULL,
								   NULL);
				AtalkPapConnDereference(pPapConn);
				ACQUIRE_SPIN_LOCK_DPC(&atalkPapLock);
				pPapConn = atalkPapConnList;
			}
		}

		if (!Close)
		{
			pPapConn = pPapConn->papco_Next;
		}
	}

	RELEASE_SPIN_LOCK_DPC(&atalkPapLock);

	return ATALK_TIMER_REQUEUE;
}



LOCAL BYTE
atalkPapGetNextConnId(
	IN	PPAP_ADDROBJ	pPapAddr,
	OUT	PATALK_ERROR	pError
	)
/*++

Routine Description:

	CALLED WITH THE ADDRESS SPIN LOCK HELD!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn;
	USHORT			i;
	BYTE			startConnId, connId;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	startConnId = connId = ++pPapAddr->papao_NextConnId;
	while (TRUE)
	{
		for (i = 0; i < PAP_CONN_HASH_SIZE; i++)
		{
			for (pPapConn = pPapAddr->papao_pActiveHash[i];
				 ((pPapConn != NULL) && (pPapConn->papco_ConnId != connId));
				 pPapConn = pPapConn->papco_pNextActive)
				 NOTHING;

			if (pPapConn != NULL)
				break;
		}

		if (pPapConn == NULL)
		{
			pPapAddr->papao_NextConnId = connId+1;
			break;
		}
		else
		{
			if (connId == (startConnId - 1))
			{
				ASSERT(0);

				//	We wrapped around and there are no more conn ids.
				error = ATALK_RESR_MEM;
				break;
			}
			connId++;
		}
	}

	*pError = error;

	return(ATALK_SUCCESS(error) ? connId : 0);
}




LOCAL	VOID
atalkPapQueueAddrGlobalList(
	IN	PPAP_ADDROBJ	pPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkPapAddrList, pPapAddr, papao_Next, papao_Prev);
	RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);
}


LOCAL	VOID
atalkPapConnDeQueueAssocList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;

	for (ppPapRemConn = &pPapAddr->papao_pAssocConn;
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			*ppPapRemConn = pPapConn->papco_pNextAssoc;
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextAssoc;
	}
}




LOCAL	VOID
atalkPapConnDeQueueConnectList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;

	ASSERT(pPapAddr->papao_Flags & PAPAO_CONNECT);

	for (ppPapRemConn = &pPapAddr->papao_pConnectConn;
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			*ppPapRemConn = pPapConn->papco_pNextConnect;

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeQueueConnectList: Removed connect conn %lx\n", pPapConn));
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextConnect;
	}
}




LOCAL	BOOLEAN
atalkPapConnDeQueueListenList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH PAP ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;
	BOOLEAN			removed = FALSE;

	ASSERT(pPapAddr->papao_Flags & PAPAO_LISTENER);

	for (ppPapRemConn = &pPapAddr->papao_pListenConn;
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			removed = TRUE;
			*ppPapRemConn = pPapConn->papco_pNextListen;

			//	If no more listens, then we set the address object to blocked
			//	state.
			if ((pPapAddr->papao_pListenConn == NULL) &&
				(pPapAddr->papao_ConnHandler == NULL))
			{
				pPapAddr->papao_Flags	&= ~PAPAO_UNBLOCKED;
#if DBG
				pPapAddr->papao_Flags |= PAPAO_BLOCKING;
#endif
			}

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeQueueListenList: Removed listen conn %lx\n", pPapConn));
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextListen;
	}

	return removed;
}




LOCAL	VOID
atalkPapConnDeQueueActiveList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;
	ULONG			index;

	index = PAP_HASH_ID_ADDR(pPapConn->papco_ConnId, &pPapConn->papco_RemoteAddr);

	for (ppPapRemConn = &pPapAddr->papao_pActiveHash[index];
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			*ppPapRemConn = pPapConn->papco_pNextActive;

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeQueueActiveList: Removed active conn %lx\n", pPapConn));
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextActive;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\pap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pap.h

Abstract:

	This module contains definitions for the PAP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_PAP_
#define	_PAP_

// PAP command type bytes:

#define PAP_OPEN_CONN					1
#define PAP_OPEN_CONNREPLY				2
#define PAP_SEND_DATA			 		3
#define PAP_DATA				 		4
#define PAP_TICKLE						5
#define PAP_CLOSE_CONN					6
#define PAP_CLOSE_CONN_REPLY 			7
#define PAP_SEND_STATUS					8
#define PAP_STATUS_REPLY				9

// Error codes for OpenConnectionReply:

#define PAP_NO_ERROR					0x0000
#define PAP_PRINTER_BUSY				0xFFFF

// PAP sizes:

#define PAP_MAX_DATA_PACKET_SIZE		512
#define	PAP_SEND_USER_BYTES_ALL			TRUE
#define PAP_MAX_STATUS_SIZE				255

#define PAP_MAX_FLOW_QUANTUM			8

#define PAP_MAX_ATP_BYTES_TO_SL	 		4

// PAP timer values:

#define PAP_OPENCONN_REQ_RETRYCOUNT		5
#define PAP_OPENCONN_INTERVAL	 		20		// In 100ms units
#define PAP_TICKLE_INTERVAL				600		// In 100ms units
#define PAP_CONNECTION_INTERVAL			1200	// In 100ms units
#define PAP_MIN_SENDDATA_REQ_INTERVAL	10		// In 100ms units
#define PAP_MAX_SENDDATA_REQ_INTERVAL	150		// In 100ms units
#define PAP_INIT_SENDDATA_REQ_INTERVAL	10		// In 100ms units

// The following aren't documented... so we'll take a wild guess...

#define PAP_GETSTATUS_REQ_RETRYCOUNT	5
#define PAP_GETSTATUS_ATP_INTERVAL 		20		// In 100ms units

// Offsets within ATP userBytes and data buffer for the various fields of the
// PAP header:

#define PAP_CONNECTIONID_OFF			0
#define PAP_CMDTYPE_OFF					1
#define PAP_EOFFLAG_OFF					2
#define PAP_SEQNUM_OFF					2

#define PAP_RESP_SOCKET_OFF 			0
#define PAP_FLOWQUANTUM_OFF				1
#define PAP_WAITTIME_OFF				2
#define PAP_RESULT_OFF					2
#define PAP_STATUS_OFF					4

#define	PAP_MAX_WAIT_TIMEOUT			0x80	// Pretty randomly chosen

// For resolving forward references
struct _PAP_ADDROBJ;
struct _PAP_CONNOBJ;

// PAP Address Object
// This is created whenever an address object is created on the Pap device.
// This represents either a client or a server side pap address. The server
// side address is represented by PAPAO_LISTENER flag.

#define	PAP_CONN_HASH_SIZE				7


// PAP ADDRESS OBJECT STATES
#define	PAPAO_LISTENER					0x00000001
#define	PAPAO_CONNECT					0x00000002
#define	PAPAO_UNBLOCKED					0x00000004
#define	PAPAO_SLS_QUEUED				0x00000008
#define	PAPAO_CLEANUP					0x01000000
#define	PAPAO_BLOCKING					0x02000000
#define	PAPAO_BLOCKING					0x02000000
#define	PAPAO_CLOSING					0x80000000

#define	PAPAO_SIGNATURE			(*(PULONG)"PAAO")
#define	VALID_PAPAO(pPapAddr)	(((pPapAddr) != NULL) && \
		(((struct _PAP_ADDROBJ *)(pPapAddr))->papao_Signature == PAPAO_SIGNATURE))

typedef struct _PAP_ADDROBJ
{
	ULONG					papao_Signature;

	//	Global list of address objects.
	struct _PAP_ADDROBJ	 *	papao_Next;
	struct _PAP_ADDROBJ	 **	papao_Prev;

	ULONG					papao_Flags;
	ULONG					papao_RefCount;

	//	List of connections associated with this address object.
	//	Potentially greater than one if this address object is a listener.
	struct	_PAP_CONNOBJ *	papao_pAssocConn;

	//	List of connections that are associated, but also have a listen/connect
	//	posted on them.
	union
	{
		struct	_PAP_CONNOBJ *	papao_pListenConn;
		struct	_PAP_CONNOBJ *	papao_pConnectConn;
	};

	//	Lookup list of all active connections hashed by connId and remote
	//	address.
	struct	_PAP_CONNOBJ *	papao_pActiveHash[PAP_CONN_HASH_SIZE];

	//	Next connection to use.
	BYTE					papao_NextConnId;

	//	The following are valid only if this is a listener.
	SHORT					papao_SrvQuantum;
	SHORT					papao_StatusSize;
	PBYTE					papao_pStatusBuf;

	//	Event support routines.
    //
    // This function pointer points to a connection indication handler for this
    // Address. Any time a connect request is received on the address, this
    // routine is invoked.
    PTDI_IND_CONNECT 		papao_ConnHandler;
    PVOID 					papao_ConnHandlerCtx;

    // The following function pointer always points to a TDI_IND_DISCONNECT
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    PTDI_IND_DISCONNECT 	papao_DisconnectHandler;
    PVOID 					papao_DisconnectHandlerCtx;

    // The following function pointer always points to a TDI_IND_RECEIVE
    // event handler for connections on this address.  If the NULL handler
    // is specified in a TdiSetEventHandler, then this points to an internal
    // routine which does not accept the incoming data.
    PTDI_IND_RECEIVE 		papao_RecvHandler;
    PVOID 					papao_RecvHandlerCtx;

    // The following function pointer always points to a TDI_IND_SEND_POSSIBLE
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    PTDI_IND_SEND_POSSIBLE  papao_SendPossibleHandler;
    PVOID   				papao_SendPossibleHandlerCtx;

	//	ATP Address for this pap address. If this is a listener, then the ATP
	//	address will be what the listens effectively will be posted on, if this
	//	is a connect address object, then this atp address will be what the
	//	associated connection be active over.
	PATP_ADDROBJ			papao_pAtpAddr;

	// Completion routine to be called when address is closed
	GENERIC_COMPLETION		papao_CloseComp;
	PVOID					papao_CloseCtx;

	PATALK_DEV_CTX			papao_pDevCtx;
	ATALK_SPIN_LOCK			papao_Lock;
} PAP_ADDROBJ, *PPAP_ADDROBJ;


#define	PAPCO_ASSOCIATED			0x00000001
#define	PAPCO_LISTENING				0x00000002
#define	PAPCO_CONNECTING			0x00000004
#define	PAPCO_ACTIVE				0x00000008
#define	PAPCO_SENDDATA_RECD			0x00000010
#define	PAPCO_WRITEDATA_WAITING		0x00000020
#define	PAPCO_SEND_EOF_WRITE		0x00000040
#define	PAPCO_READDATA_PENDING		0x00000080
#define	PAPCO_DISCONNECTING			0x00000100
#define	PAPCO_LOCAL_DISCONNECT		0x00000200
#define	PAPCO_REMOTE_DISCONNECT		0x00000400
#define	PAPCO_SERVER_JOB			0x00000800
#define	PAPCO_REMOTE_CLOSE			0x00001000
#define	PAPCO_NONBLOCKING_READ		0x00002000
#define	PAPCO_READDATA_WAITING		0x00004000
#define	PAPCO_DELAYED_DISCONNECT	0x00008000
#define	PAPCO_RECVD_DISCONNECT		0x00010000
#define PAPCO_ADDR_ACTIVE           0x00020000
#define PAPCO_REJECT_READS          0x00040000
#if DBG
#define	PAPCO_CLEANUP				0x01000000
#define	PAPCO_INDICATE_AFD_DISC		0x02000000
#endif
#define	PAPCO_STOPPING				0x40000000
#define	PAPCO_CLOSING				0x80000000

#define	PAPCO_SIGNATURE				(*(PULONG)"PACO")

#define	VALID_PAPCO(pPapConn)	(((pPapConn) != NULL) && \
		(((struct _PAP_CONNOBJ *)(pPapConn))->papco_Signature == PAPCO_SIGNATURE))

// This will represent a 'job' on the Pap address. This could either be a
// workstation job or a server job. In the latter case it could either
// be in a 'listen' state or active state. In the former case it is either
// active or 'waiting'
typedef struct _PAP_CONNOBJ
{
	ULONG					papco_Signature;

	//	Global list of connection objects.
	struct _PAP_CONNOBJ	 *	papco_Next;
	struct _PAP_CONNOBJ	**	papco_Prev;

	ULONG					papco_Flags;
	ULONG					papco_RefCount;

	//	Backpointer to the associated address
	struct _PAP_ADDROBJ	*	papco_pAssocAddr;

	//	The address this connection uses for itself. In the case of a connect
	//	this will be the same as the address object's ATP address.
	PATP_ADDROBJ			papco_pAtpAddr;

	//	Used to queue into the address object's associated list.
	struct	_PAP_CONNOBJ *	papco_pNextAssoc;

	//	Used to queue into the address object's listen/connect list. When it
	//	is removed from the listen/connect, it goes into the active list of the
	//	address object. When active, pNextActive will be the overflow list.
	union
	{
		struct	_PAP_CONNOBJ *	papco_pNextListen;
		struct	_PAP_CONNOBJ *	papco_pNextConnect;
		struct	_PAP_CONNOBJ *	papco_pNextActive;
	};

	//	Address of remote end of the connection
	ATALK_ADDR				papco_RemoteAddr;

	//	Connection id
	BYTE					papco_ConnId;

	// WaitTime value for PapConnect call. We start with 0 and increment by 2
	// till we either succeed or reach PAP_MAX_WAIT_TIMEOUT
	BYTE					papco_WaitTimeOut;

	//	Max size we can write to the remote end. This is dictated by the
	//	remote end. Our recv flow quantum will always be PAP_MAX_FLOW_QUANTUM.
	SHORT					papco_SendFlowQuantum;

	LONG					papco_LastContactTime;
	USHORT					papco_TickleTid;

	// Adaptive Retry time support
	RT						papco_RT;

	//	Connection context
	PVOID					papco_ConnCtx;

	//	PAP handles only one read and one write per job at a time. So we
	//	explicitly have the relevant information for the two cases in here.

	//	PAPWRITE():
	//	If the remote end did a papread() and we are waiting for our client
	//	to do a papwrite(), then the PAPCO_SENDDATA_RECD will be true and the
	//	following will be used for our papwrite() response. Note
	//	that we will assume all send data responses to be exactly-once.
	PATP_RESP				papco_pAtpResp;

	//	Next expected sequence number of send data.
	USHORT					papco_NextIncomingSeqNum;

	//	Where did the senddata request come from. NOTE this may not be the
	//	same as papco_RemoteAddr!!!
	ATALK_ADDR				papco_SendDataSrc;

	//	If the remote end has not done a send data, then our write will pend
	//	and the	PAPCO_WRITEDATA_WAITING will be set. Even if send credit is
	//	available the write will pend until all the data is sent out. But in
	//	that case both the PAPCO_WRITEDATA_WAITING and the PAPCO_SENDDATA_RECD will
	//	be set. Note that whenever PAPCO_WRITEDATA_WAITING is set, no new writes
	//	will be accepted by PAP for this job.
	PAMDL					papco_pWriteBuf;
	SHORT					papco_WriteLen;

	GENERIC_WRITE_COMPLETION papco_WriteCompletion;
	PVOID					papco_WriteCtx;

	//	PAPREAD():
	//	In the case where we are doing a PapRead(). Pap only allows one read
	//	at a time per connection. The last seq num we used for an outgoing senddata.
	//	While a PAPREAD() is active, the PAPCO_READDATA_PENDING will be set.
	//	NOTE: The user's buffer is passed on to ATP as a response buffer. For
	//	nonblocking reads we prime with the users buffers which are stored here.
	ULONG					papco_NbReadFlags;
	PACTREQ					papco_NbReadActReq;
	USHORT					papco_NbReadLen;		//	Number of bytes read

	USHORT					papco_ReadDataTid;
	USHORT					papco_NextOutgoingSeqNum;
	GENERIC_READ_COMPLETION	papco_ReadCompletion;
	PVOID					papco_ReadCtx;

	//	The connection object can have either a CONNECT or a LISTEN posted
	//	on it, but not both.
	union
	{
	  struct
	  {
		//	Pending Listen routine.
		GENERIC_COMPLETION	papco_ListenCompletion;
		PVOID				papco_ListenCtx;
	  };

	  struct
	  {
		//	Pending Connect routine. The status buffer is remembered and
		//	returned via socket options. The pConnectRespBuf is remembered
		//	to avoid having to get the system address for it. It is freed
		//	when connection is taken off the connectlist.
		GENERIC_COMPLETION	papco_ConnectCompletion;
		PVOID				papco_ConnectCtx;
        PBYTE				papco_pConnectRespBuf;
		PBYTE				papco_pConnectOpenBuf;
		USHORT				papco_ConnectRespLen;
		USHORT				papco_ConnectTid;
	  };
	};

	//	Disconnect inform routine
	GENERIC_COMPLETION		papco_DisconnectInform;
	PVOID					papco_DisconnectInformCtx;

	//	Disconnect request completion
	ATALK_ERROR				papco_DisconnectStatus;
	GENERIC_COMPLETION		papco_DisconnectCompletion;
	PVOID					papco_DisconnectCtx;

	// Completion routine to be called when socket cleanup is called
	GENERIC_COMPLETION		papco_CleanupComp;
	PVOID					papco_CleanupCtx;

	// Completion routine to be called when socket is closed
	GENERIC_COMPLETION		papco_CloseComp;
	PVOID					papco_CloseCtx;

	PATALK_DEV_CTX			papco_pDevCtx;
	ATALK_SPIN_LOCK			papco_Lock;
} PAP_CONNOBJ, *PPAP_CONNOBJ;

//	Used for sending a status reply to a send status command.
typedef	struct _PAP_SEND_STATUS_REL
{
	PPAP_ADDROBJ			papss_pPapAddr;
	PATP_RESP				papss_pAtpResp;
	PAMDL					papss_pAmdl;
	BYTE					papss_StatusBuf[PAP_STATUS_OFF + 1];
	//	This will be followed by the actual status.
} PAP_SEND_STATUS_REL, *PPAP_SEND_STATUS_REL;


//	Used for sending a open reply
typedef	struct _PAP_OPEN_REPLY_REL
{
	PAMDL					papor_pRespAmdl;
	PATP_RESP				papor_pAtpResp;
	BYTE					papor_pRespPkt[PAP_MAX_DATA_PACKET_SIZE];
} PAP_OPEN_REPLY_REL, *PPAP_OPEN_REPLY_REL;

//	Routine prototypes
VOID
AtalkInitPapInitialize(
	VOID);

ATALK_ERROR
AtalkPapCreateAddress(
	IN	PATALK_DEV_CTX				pDevCtx	OPTIONAL,
	OUT	PPAP_ADDROBJ	*			ppPapAddr);

ATALK_ERROR
AtalkPapCleanupAddress(
	IN	PPAP_ADDROBJ				pPapAddr);

ATALK_ERROR
AtalkPapCloseAddress(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	GENERIC_COMPLETION			CompletionRoutine,
	IN	PVOID						pCloseCtx);

ATALK_ERROR
AtalkPapCreateConnection(
	IN	PVOID						pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX				pDevCtx		OPTIONAL,
	OUT	PPAP_CONNOBJ 	*			ppPapConn);

ATALK_ERROR
AtalkPapCleanupConnection(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapCloseConnection(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	GENERIC_COMPLETION			CompletionRoutine,
	IN	PVOID						pCloseCtx);

ATALK_ERROR
AtalkPapConnStop(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapAssociateAddress(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapDissociateAddress(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapPostListen(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PVOID						pListenCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine);

ATALK_ERROR
AtalkPapPrimeListener(
	IN	PPAP_ADDROBJ				pPapAddr);

ATALK_ERROR
AtalkPapCancelListen(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapPostConnect(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PATALK_ADDR					pRemoteAddr,
	IN	PVOID						pConnectCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine);

ATALK_ERROR
AtalkPapDisconnect(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	ATALK_DISCONNECT_TYPE		DisconnectType,
	IN	PVOID						pDisconnectCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine);

ATALK_ERROR
AtalkPapRead(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pReadBuf,
	IN	USHORT						ReadBufLen,
	IN	ULONG						ReadFlags,
	IN	PVOID						pReadCtx,
	IN	GENERIC_READ_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkPapPrimeRead(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PACTREQ						pActReq);

ATALK_ERROR
AtalkPapWrite(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine);

ATALK_ERROR
AtalkPapSetStatus(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PAMDL						pStatusMdl,
	IN	PACTREQ						pActReq);

ATALK_ERROR
AtalkPapGetStatus(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PATALK_ADDR					pRemoteAddr,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						AmdlSize,
	IN	PACTREQ						pActReq);

VOID
AtalkPapQuery(
	IN	PVOID						pObject,
	IN	ULONG						ObjectType,
	IN	PAMDL						pAmdl,
	OUT	PULONG						BytesWritten);

VOID FASTCALL
atalkPapAddrDeref(
	IN	PPAP_ADDROBJ				pPapAddr);

VOID FASTCALL
atalkPapConnRefByPtrNonInterlock(
	IN	PPAP_CONNOBJ				pPapConn,
	OUT	PATALK_ERROR				pError);

VOID
atalkPapConnRefNextNc(
	IN		PPAP_CONNOBJ			pPapConn,
	IN		PPAP_CONNOBJ	*		ppPapConnNext,
	OUT		PATALK_ERROR			pError);

VOID
atalkPapConnRefByCtx(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	CONNECTION_CONTEXT			pCtx,
	OUT	PPAP_CONNOBJ	*			pPapConn,
	OUT	PATALK_ERROR				pError);

VOID FASTCALL
atalkPapConnDeref(
	IN	PPAP_CONNOBJ				pPapConn);

//	MACROS
#define	AtalkPapAddrReferenceNonInterlock(_pPapAddr, _pError)			\
		{																\
			if (((_pPapAddr)->papao_Flags & PAPAO_CLOSING) == 0)        \
			{                                                           \
				ASSERT((_pPapAddr)->papao_RefCount >= 1);               \
				(_pPapAddr)->papao_RefCount++;                          \
				*(_pError) = ATALK_NO_ERROR;                            \
			}                                                           \
			else                                                        \
			{                                                           \
				*(_pError) = ATALK_PAP_ADDR_CLOSING;                    \
			}                                                           \
			if (ATALK_SUCCESS(*(_pError)))								\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPADDR,			\
						("RefAddr %lx at %s(%d) = %d\n",				\
						_pPapAddr, __FILE__, __LINE__,					\
						((_pPapAddr)->papao_RefCount)));				\
			}															\
		}

#define	AtalkPapAddrReference(pPapAddr, pError)							\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pPapAddr)->papao_Lock, &OldIrql);		\
			AtalkPapAddrReferenceNonInterlock(pPapAddr, pError);		\
			RELEASE_SPIN_LOCK(&(pPapAddr)->papao_Lock, OldIrql);		\
		}

#define	AtalkPapAddrDereference(pPapAddr)								\
		{																\
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPADDR,				\
					("DerefAddr %lx at %s %d = %d\n",					\
					pPapAddr, __FILE__, __LINE__,						\
					((pPapAddr)->papao_RefCount-1)));					\
			atalkPapAddrDeref(pPapAddr);								\
		}

#define	AtalkPapConnReferenceByPtr(pPapConn, pError)					\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pPapConn)->papco_Lock, &OldIrql);		\
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, pError);	\
			RELEASE_SPIN_LOCK(&(pPapConn)->papco_Lock, OldIrql);		\
		}

#define	AtalkPapConnReferenceByPtrDpc(pPapConn, pError)					\
		{																\
			ACQUIRE_SPIN_LOCK_DPC(&(pPapConn)->papco_Lock);				\
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, pError);	\
			RELEASE_SPIN_LOCK_DPC(&(pPapConn)->papco_Lock);				\
		}

#define	AtalkPapConnReferenceByPtrNonInterlock(pPapConn, pError)		\
		{																\
			atalkPapConnRefByPtrNonInterlock(pPapConn, pError);			\
			if (ATALK_SUCCESS(*pError))									\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,			\
						("RefConn %lx at %s (%ld): + 1 = %ld\n", 		\
						pPapConn, __FILE__, __LINE__,					\
						(pPapConn)->papco_RefCount));					\
			}															\
			else														\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,			\
						("RefConn %lx at %s (%ld): FAILED, Flags %lx\n",\
						pPapConn, __FILE__, __LINE__,					\
						(pPapConn)->papco_Flags));						\
			}															\
		}

#define	AtalkPapConnReferenceByCtxNonInterlock(pPapAddr, Ctx, ppPapConn, pError) \
		{																\
			atalkPapConnRefByCtxNonInterlock(pPapAddr, Ctx, ppPapConn, pError);	\
			if (ATALK_SUCCESS(*pError))									\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,			\
						("RefConnByCtx %lx at %s(%ld) = %ld\n", 		\
						*ppPapConn, __FILE__, __LINE__,					\
						((*ppPapConn)->papco_RefCount)));				\
			}															\
		}

#define	AtalkPapConnDereference(pPapConn)								\
		{																\
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,				\
					("DerefConn %lx at %s(%ld) = %ld\n",				\
					pPapConn, __FILE__, __LINE__,						\
					(pPapConn)->papco_RefCount-1));						\
			atalkPapConnDeref(pPapConn);								\
		}

#define	AtalkPapGetDdpAddress(pPapAddr)									\
		AtalkAtpGetDdpAddress((pPapAddr)->papao_pAtpAddr)

#define	PAPCONN_DDPSOCKET(pPapConn)										\
		AtalkAtpGetDdpAddress((pPapConn)->papco_pAtpAddr)->ddpao_Addr.ata_Socket

#define	PAPADDR_DDPSOCKET(pPapAddr)										\
		AtalkAtpGetDdpAddress((pPapAddr)->papao_pAtpAddr)->ddpao_Addr.ata_Socket

//	List of all pap address/connection objects.
extern	PPAP_ADDROBJ	atalkPapAddrList;
extern	PPAP_CONNOBJ	atalkPapConnList;
extern	TIMERLIST		atalkPapCMTTimer;
extern	ATALK_SPIN_LOCK	atalkPapLock;

#define	PAP_HASH_ID_ADDR(_id, _pAddr)			\
			(((_pAddr)->ata_Node+((_pAddr)->ata_Network & 0xFF)+_id)%PAP_CONN_HASH_SIZE)

LOCAL	ATALK_ERROR
atalkPapRepostConnect(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pOpenAmdl,
	IN	PAMDL						pRespAmdl
);

LOCAL VOID
atalkPapSlsHandler(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_ADDROBJ				pPapAddr,		// Listener (our context)
	IN	PVOID						RespContext,	// CancelResp/PostResp will need this
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	USHORT						PktLen,
	IN	PBYTE						pPkt,
	IN	PBYTE						pUserBytes);

LOCAL VOID
atalkPapIncomingReadComplete(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID
atalkPapPrimedReadComplete(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID
atalkPapIncomingStatus(
	IN	ATALK_ERROR					ErrorCode,
	IN	PACTREQ						pActReq,		// Our Ctx
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						StatusLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID
atalkPapIncomingReq(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Connection (our context)
	IN	PVOID						RespContext,	// CancelResp/PostResp will need this
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	USHORT						PktLen,
	IN	PBYTE						pPkt,
	IN	PBYTE						pUserBytes);

LOCAL VOID
atalkPapIncomingOpenReply(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID FASTCALL
atalkPapIncomingRel(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_OPEN_REPLY_REL			pOpenReply);

LOCAL VOID FASTCALL
atalkPapStatusRel(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_SEND_STATUS_REL		pSendSts);

LOCAL ATALK_ERROR FASTCALL
atalkPapPostSendDataResp(
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL BOOLEAN
atalkPapConnAccept(
	IN	PPAP_ADDROBJ				pPapAddr,		// Listener
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	PBYTE						pPkt,
	IN	BYTE						ConnId,
	IN	PATP_RESP					pAtpResp);

LOCAL LONG FASTCALL
atalkPapConnMaintenanceTimer(
	IN	PTIMERLIST					pTimer,
	IN	BOOLEAN						TimerShuttingDown);

LOCAL VOID FASTCALL
atalkPapSendDataRel(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL BYTE
atalkPapGetNextConnId(
	IN	PPAP_ADDROBJ				pPapAddr,
	OUT	PATALK_ERROR				pError);

LOCAL	VOID
atalkPapQueueAddrGlobalList(
	IN	PPAP_ADDROBJ	pPapAddr);

LOCAL	VOID
atalkPapConnDeQueueAssocList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	VOID
atalkPapConnDeQueueConnectList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	BOOLEAN
atalkPapConnDeQueueListenList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	VOID
atalkPapConnDeQueueActiveList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	VOID
atalkPapConnRefByCtxNonInterlock(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	CONNECTION_CONTEXT			Ctx,
	OUT	PPAP_CONNOBJ	*			pPapConn,
	OUT	PATALK_ERROR				pError);

#endif	// _PAP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\ppp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ppp.c

Abstract:

	This module implements routines that are used for PPP functionality

Author:

	Shirish Koti

Revision History:
	11 Mar 1998		Initial Version

--*/

#define		ARAP_LOCALS
#include 	<atalk.h>
#pragma hdrstop

#define	FILENUM		PPP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_PPP, AllocPPPConn)
#pragma alloc_text(PAGE_PPP, PPPProcessIoctl)
#pragma alloc_text(PAGE_PPP, PPPRoutePacketToWan)
#pragma alloc_text(PAGE_PPP, PPPTransmit)
#pragma alloc_text(PAGE_PPP, PPPTransmitCompletion)
#pragma alloc_text(PAGE_PPP, DerefPPPConn)
#pragma alloc_text(PAGE_PPP, PPPGetDynamicAddr)
#endif

//***
//
// Function: AllocPPPConn
//              Allocate a connection element and initialize fields
//
// Parameters:  none
//
// Return:      pointer to a newly allocated connection element
//
//***$

PATCPCONN
AllocPPPConn(
    IN VOID
)
{

    PATCPCONN   pAtcpConn;
    KIRQL       OldIrql;


    DBG_PPP_CHECK_PAGED_CODE();

    if ( (pAtcpConn = AtalkAllocZeroedMemory(sizeof(ATCPCONN))) == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("AllocPPPConn: alloc failed\n"));

        return(NULL);
    }

#if DBG
    pAtcpConn->Signature = ATCPCONN_SIGNATURE;
#endif

    // RAS refcount
    pAtcpConn->RefCount = 1;
    pAtcpConn->Flags |= ATCP_DLL_SETUP_DONE;

    INITIALIZE_SPIN_LOCK(&pAtcpConn->SpinLock);

    KeInitializeEvent(&pAtcpConn->NodeAcquireEvent, NotificationEvent, FALSE);

    // and insert it in the list
    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
    InsertTailList(&RasPortDesc->pd_PPPConnHead, &pAtcpConn->Linkage);
    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    PPPConnections++;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    return( pAtcpConn );
}


//***
//
// Function: PPPProcessIoctl
//              This routine gets called in to process ioclts coming from ATCP
//              For SETUP, we allocate a connection context, get an address for
//                the client, get the zone and router info.
//              For CLOSE, we mark and dereference our connection context
//
// Parameters:  pIrp - irp from ATCP
//              pSndRcvInfo - buffer from ATCP that contains all the info
//              IoControlCode - what does ATCP want to do
//
// Return:      none
//
//***$

NTSTATUS FASTCALL
PPPProcessIoctl(
	IN     PIRP 			    pIrp,
    IN OUT PARAP_SEND_RECV_INFO pSndRcvInfo,
    IN     ULONG                IoControlCode,
    IN     PATCPCONN            pIncomingAtcpConn
)
{
    KIRQL                   OldIrql;
    PATCPINFO               pAtcpInfo;
    PATCPCONN               pAtcpConn;
    DWORD                   dwRetCode=ARAPERR_NO_ERROR;
    PATCP_SUPPRESS_INFO     pSupprInfo;
    ATALK_NODEADDR          ClientNode;
    DWORD                   DataLen=0;
    DWORD                   ErrCode;
    BOOLEAN                 fDerefPort=FALSE;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    DBG_PPP_CHECK_PAGED_CODE();

    pAtcpConn = pIncomingAtcpConn;

    switch (IoControlCode)
    {
        case IOCTL_ATCP_SETUP_CONNECTION:

            ErrCode = ATALK_PORT_INVALID;

            // put a IrpProcess refcount, so AtalkDefaultPort doesn't go away in PnP
            if (!AtalkReferenceDefaultPort())
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: Default port gone, or going %lx not accepted (%lx)\n", pIrp,IoControlCode));

                dwRetCode = ARAPERR_STACK_IS_NOT_ACTIVE;

                break;
            }

            fDerefPort = TRUE;

            // allocate connection context
            pAtcpConn = AllocPPPConn();
            if (!pAtcpConn)
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: alloc failed\n"));
                pSndRcvInfo->StatusCode = ARAPERR_OUT_OF_RESOURCES;
                break;
            }

            pAtcpConn->pDllContext = pSndRcvInfo->pDllContext;

            dwRetCode = PPPGetDynamicAddr(pAtcpConn);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: couldn't get network addr %ld (%lx)\n",
                    dwRetCode,pAtcpConn));

                dwRetCode = ARAPERR_NO_NETWORK_ADDR;

                // remove the creation refcount
                DerefPPPConn(pAtcpConn);
                break;
            }

            pAtcpInfo = (PATCPINFO)&pSndRcvInfo->Data[0];


            ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

            ACQUIRE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);

            if ((AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE) ||
            (AtalkDefaultPort->pd_Flags & PD_CLOSING))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: PnP is ine progress\n"));

                dwRetCode = ARAPERR_STACK_IS_NOT_ACTIVE;
                RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
                RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

                // remove the creation refcount
                DerefPPPConn(pAtcpConn);
                break;
            }

            // we will be returning server's address and router's address
            DataLen += (2*sizeof(NET_ADDR));

            // copy server's net address
            pAtcpInfo->ServerAddr.ata_Network =
                        AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network;
            pAtcpInfo->ServerAddr.ata_Node =
                        AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Node;

            // if we are a router, copy our own address
            if (AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING)
            {
                pAtcpInfo->DefaultRouterAddr.ata_Network =
                                AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Network;
                pAtcpInfo->DefaultRouterAddr.ata_Network =
                                AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Node;
            }

            // if we know who the router on the net is, copy his address
            else if (AtalkDefaultPort->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
            {
                pAtcpInfo->DefaultRouterAddr.ata_Network =
                                AtalkDefaultPort->pd_ARouter.atn_Network;
                pAtcpInfo->DefaultRouterAddr.ata_Node =
                                AtalkDefaultPort->pd_ARouter.atn_Node;
            }

            // hmmm: no router!
            else
            {
                pAtcpInfo->DefaultRouterAddr.ata_Network = 0;
                pAtcpInfo->DefaultRouterAddr.ata_Node = 0;
            }

            //
            // copy the name of the zone on which this server lives
            //
            if (AtalkDesiredZone)
            {
                pAtcpInfo->ServerZoneName[0] = AtalkDesiredZone->zn_ZoneLen;
                RtlCopyMemory( &pAtcpInfo->ServerZoneName[1],
                               &AtalkDesiredZone->zn_Zone[0],
                               AtalkDesiredZone->zn_ZoneLen );
            }
            else if (AtalkDefaultPort->pd_DefaultZone)
            {
                pAtcpInfo->ServerZoneName[0] =
                                AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen;
                RtlCopyMemory( &pAtcpInfo->ServerZoneName[1],
                               &AtalkDefaultPort->pd_DefaultZone->zn_Zone[0],
                               AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen );
            }
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: Server not in any zone!!\n"));
                pAtcpInfo->ServerZoneName[0] = 0;
            }

            RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
            RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

            DataLen += pAtcpInfo->ServerZoneName[0];

            // return our context and the network addr to the dll
            pSndRcvInfo->AtalkContext = pAtcpConn;

            pSndRcvInfo->ClientAddr.ata_Network = pAtcpConn->NetAddr.atn_Network;
            pSndRcvInfo->ClientAddr.ata_Node = pAtcpConn->NetAddr.atn_Node;

		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: PPP conn %lx created, addr = %x.%x\n",
                    pAtcpConn,pSndRcvInfo->ClientAddr.ata_Network,pSndRcvInfo->ClientAddr.ata_Node));
            break;

        case IOCTL_ATCP_SUPPRESS_BCAST:

            pSupprInfo = (PATCP_SUPPRESS_INFO)&pSndRcvInfo->Data[0];

            //
            // see what flags need to be set: suppress only RTMP only or all bcast
            //
            ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

            if (pSupprInfo->SuppressRtmp)
            {
                pAtcpConn->Flags |= ATCP_SUPPRESS_RTMP;
            }

            if (pSupprInfo->SuppressAllBcast)
            {
                pAtcpConn->Flags |= ATCP_SUPPRESS_ALLBCAST;
            }

            RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

            break;

        case IOCTL_ATCP_CLOSE_CONNECTION:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("PPPProcessIoctl: close connection received on %lx (refcount %d)\n",
                pAtcpConn,pAtcpConn->RefCount));

            ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);
            pAtcpConn->Flags &= ~(ATCP_CONNECTION_UP | ATCP_DLL_SETUP_DONE);
            RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

            // PPP wants to close connection: take away the RAS refcount
            DerefPPPConn(pAtcpConn);

            break;

        default:
            ASSERT(0);
            break;
    }

    pSndRcvInfo->DataLen = DataLen;
    pSndRcvInfo->StatusCode = dwRetCode;

    // complete that irp
    ARAP_COMPLETE_IRP(pIrp, (sizeof(ARAP_SEND_RECV_INFO)+DataLen), STATUS_SUCCESS, &ReturnStatus);

    if (fDerefPort)
    {
        // remove that IrpProcess refcount
        AtalkPortDereference(AtalkDefaultPort);
    }

    return ReturnStatus;
}



//***
//
// Function: DerefPPPConn
//              Decrements the refcount of the connection element by 1.  If the
//              refcount goes to 0, releases network addr and frees it
//
// Parameters:  pAtcpConn - connection element in question
//
// Return:      none
//
//***$

VOID
DerefPPPConn(
	IN	PATCPCONN    pAtcpConn
)
{

    KIRQL       OldIrql;
    BOOLEAN     fKill = FALSE;


    DBG_PPP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

    ASSERT(pAtcpConn->RefCount > 0);

    pAtcpConn->RefCount--;

    if (pAtcpConn->RefCount == 0)
    {
        fKill = TRUE;
        pAtcpConn->Flags |= ATCP_CONNECTION_CLOSING;
    }

    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

    if (!fKill)
    {
        return;
    }

    // and remove from the list
    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
    RemoveEntryList(&pAtcpConn->Linkage);
    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    // free that memory
    AtalkFreeMemory(pAtcpConn);

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("DerefPPPConn: PPP connection %lx freed\n",pAtcpConn));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    PPPConnections--;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    // if possible (i.e. if this was the last connection), unlock PPP pages
    AtalkUnlockPPPIfNecessary();
}

//***
//
// Function: FindAndRefPPPConnByAddr
//              Finds the corresponding connection element, given the network
//              address (of the remote client)
//
// Parameters:  destNode - network addr of the destination (remote client)
//              pdwFlags - pointer to a dword to return Flags field
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PATCPCONN
FindAndRefPPPConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD               *pdwFlags
)
{
    PATCPCONN    pAtcpConn=NULL;
    PATCPCONN    pAtcpWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;


    // RAS not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    if (!(RasPortDesc->pd_Flags & PD_ACTIVE))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("FindAndRefPPPConnByAddr: RAS not active, ignoring\n"));
			
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
        return(NULL);
    }

    pList = RasPortDesc->pd_PPPConnHead.Flink;

    //
    // walk through all the PPP clients to see if we find ours
    //
    while (pList != &RasPortDesc->pd_PPPConnHead)
    {
        pAtcpWalker = CONTAINING_RECORD(pList, ATCPCONN, Linkage);

        pList = pAtcpWalker->Linkage.Flink;

        ACQUIRE_SPIN_LOCK_DPC(&pAtcpWalker->SpinLock);

        if (ATALK_NODES_EQUAL(&pAtcpWalker->NetAddr, &destNode))
        {
            pAtcpConn = pAtcpWalker;
            pAtcpConn->RefCount++;

            *pdwFlags = pAtcpWalker->Flags;

            RELEASE_SPIN_LOCK_DPC(&pAtcpWalker->SpinLock);
            break;
        }

        RELEASE_SPIN_LOCK_DPC(&pAtcpWalker->SpinLock);
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return( pAtcpConn );
}



//***
//
// Function: PPPRoutePacketToWan
//              This routine picks up a packet from the lan, checks to see if
//              it must be forwarded to any of the PPP clients and does the
//              good deed.
//
// Parameters:  pDestAddr - who is this packet addressed to? (potentially bcast)
//              pSrcAddr  - who sent this packet
//              Protocol  - what packet is it? (ATP, NBP, etc.)
//              packet    - buffer containing the packet
//              PktLen    - how big is the packet
//              broadcast - is this a broadcast packet?
//              pDelivered - set on return: did we forward it to any dial-in
//                           client (set to TRUE only for directed dgrams)
//
// Return:      none
//
//***$

VOID
PPPRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
)
{

    KIRQL           OldIrql;
    PATCPCONN       pAtcpConn;
    PATCPCONN       pPrevAtcpConn;
    PLIST_ENTRY     pConnList;
    ATALK_NODEADDR  DestNode;
    ATALK_NODEADDR  SourceNode;
    DWORD           StatusCode;
    DWORD           dwFlags;
    BOOLEAN         fRtmpPacket=FALSE;


    DBG_PPP_CHECK_PAGED_CODE();

    // assume for now
    *pDelivered = FALSE;

    //
    // if this is a unicast, see if a PPP client with this dest address exists
    //
    if (!broadcast)
    {

        DestNode.atn_Network = pDestAddr->ata_Network;
        DestNode.atn_Node    = pDestAddr->ata_Node;

        // first and foremost, let's find the puppy
        pAtcpConn = FindAndRefPPPConnByAddr(DestNode, &dwFlags);

        if (pAtcpConn == NULL)
        {
            return;
        }

        // let the caller know that we found who this data was meant for
        *pDelivered = TRUE;

        // if this dude isn't ready to route data, drop this packet!
        if (!(dwFlags & ATCP_CONNECTION_UP))
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		        ("PPPRoutePacketToWan: dropping pkt on %lx, line-up not done\n",pAtcpConn));

            // remove the refcount put in by FindAndRefPPPConnByAddr
            DerefPPPConn(pAtcpConn);

            return;
        }


        // send the packet out
        PPPTransmit(pAtcpConn,
                    pDestAddr,
                    pSrcAddr,
                    Protocol,
                    packet,
                    PktLen,
                    HopCount);

        // remove the refcount put in by FindAndRefPPPConnByAddr
        DerefPPPConn(pAtcpConn);

        return;
    }



    //
    // it's a broadcast packet: must send it to all the PPP guys
    //

    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPRESPONSEORDATA)
    {
        fRtmpPacket = TRUE;
    }

    pAtcpConn = NULL;
    pPrevAtcpConn = NULL;

    SourceNode.atn_Network = pSrcAddr->ata_Network;
    SourceNode.atn_Node    = pSrcAddr->ata_Node;

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        //
        // first, let's find the right connection to work on
        //
        while (1)
        {
            // if we're in the middle of the list, get to the next guy
            if (pAtcpConn != NULL)
            {
                pConnList = pAtcpConn->Linkage.Flink;
            }
            // we're just starting: get the guy at the head of the list
            else
            {
                pConnList = RasPortDesc->pd_PPPConnHead.Flink;
            }

            // finished all?
            if (pConnList == &RasPortDesc->pd_PPPConnHead)
            {
                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                if (pPrevAtcpConn)
                {
                    DerefPPPConn(pPrevAtcpConn);
                }
                return;
            }

            pAtcpConn = CONTAINING_RECORD(pConnList, ATCPCONN, Linkage);

            ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

            // if this guy sent out the broadcast, don't send it back to him!
            if (ATALK_NODES_EQUAL(&pAtcpConn->NetAddr, &SourceNode))
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping bcast from source\n"));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            // if this dude isn't ready to route data, skip
            if (!(pAtcpConn->Flags & ATCP_CONNECTION_UP))
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping %lx because line-up not done\n",pAtcpConn));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            //
            // if this is an RTMP packet and the client doesn't want those
            // packets, don't send
            //
            if (fRtmpPacket && (pAtcpConn->Flags & ATCP_SUPPRESS_RTMP))
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping %lx because RTMP data to be suppressed\n",pAtcpConn));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            // if this dude wants all broadcasts suppressed, skip it
            if (pAtcpConn->Flags & ATCP_SUPPRESS_ALLBCAST)
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping %lx because all bcast to be suppressed\n",pAtcpConn));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            // let's make sure this connection stays around till we finish
            pAtcpConn->RefCount++;

            RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

            break;
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        //
        // remove the refcount on the previous connection we put in earlier
        //
        if (pPrevAtcpConn)
        {
            DerefPPPConn(pPrevAtcpConn);
        }

        ASSERT(pPrevAtcpConn != pAtcpConn);

        pPrevAtcpConn = pAtcpConn;

        PPPTransmit(pAtcpConn,
                    pDestAddr,
                    pSrcAddr,
                    Protocol,
                    packet,
                    PktLen,
                    HopCount);
    }

}


//***
//
// Function: PPPTransmit
//              This routine sends the packet out to a PPP destination
//
// Parameters:  pAtcpConn - PPP connection to send to
//              pDestAddr - who is this packet addressed to? (potentially bcast)
//              pSrcAddr  - who sent this packet
//              Protocol  - what packet is it? (ATP, NBP, etc.)
//              packet    - buffer containing the packet
//              PktLen    - how big is the packet
//              HopCount  - hopcount in the DDP pkt as received
//
// Return:      none
//
//***$

VOID FASTCALL
PPPTransmit(
    IN  PATCPCONN    pAtcpConn,
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount
)
{

    PBUFFER_DESC        pBufCopy;
    PBUFFER_DESC        pPktDesc;
    SEND_COMPL_INFO     SendInfo;
    PBYTE               pLinkDdpOptHdr;
    PBYTE               pDgram;
    ATALK_ERROR         error;


    DBG_PPP_CHECK_PAGED_CODE();

    // allocate a buffer and bufdesc to copy the incoming packet (data portion)
	pBufCopy = AtalkAllocBuffDesc(NULL,PktLen,(BD_FREE_BUFFER | BD_CHAR_BUFFER));

	if (pBufCopy == NULL)
	{
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("PPPTransmit: alloc BufDesc failed\n"));
		return;
	}

    // copy the data in
	AtalkCopyBufferToBuffDesc(packet, PktLen, pBufCopy, 0);

    // allocate a buffdesc to hold headers
	AtalkNdisAllocBuf(&pPktDesc);
	if (pPktDesc == NULL)
	{
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("PPPTransmit: couldn't alloc ndis bufdesc\n"));

        AtalkFreeBuffDesc(pBufCopy);
		return;
	}

    // put in the Mac header (NdisWan's header)
	pLinkDdpOptHdr = pPktDesc->bd_CharBuffer;

    AtalkNdisBuildPPPPHdr(pLinkDdpOptHdr, pAtcpConn);

    // make up the DDP header
	pDgram = pLinkDdpOptHdr + WAN_LINKHDR_LEN;

	*pDgram++ = (DDP_HOP_COUNT(HopCount) + DDP_MSB_LEN(PktLen + LDDP_HDR_LEN));
	
	PUTSHORT2BYTE(pDgram, (PktLen + LDDP_HDR_LEN));
	pDgram++;
	
	PUTSHORT2SHORT(pDgram, 0);        
	pDgram += sizeof(USHORT);
	
	PUTSHORT2SHORT(pDgram, pDestAddr->ata_Network);
	pDgram += sizeof(USHORT);
	
	PUTSHORT2SHORT(pDgram, pSrcAddr->ata_Network);
	pDgram += sizeof(USHORT);
	
	*pDgram++ = pDestAddr->ata_Node;
	*pDgram++ = pSrcAddr->ata_Node;
	*pDgram++ = pDestAddr->ata_Socket;
	*pDgram++ = pSrcAddr->ata_Socket;
	*pDgram++ = Protocol;
	
	//	Set length in the buffer descriptor.
	AtalkSetSizeOfBuffDescData(pPktDesc, WAN_LINKHDR_LEN + LDDP_HDR_LEN);

    // chain in this bufdesc
	AtalkPrependBuffDesc(pPktDesc, pBufCopy);

	INTERLOCKED_ADD_STATISTICS(&RasPortDesc->pd_PortStats.prtst_DataOut,
							   AtalkSizeBuffDesc(pPktDesc),
							   &AtalkStatsLock.SpinLock);

    // set up our completion info
    SendInfo.sc_TransmitCompletion = PPPTransmitCompletion;
    SendInfo.sc_Ctx1 = RasPortDesc;
    SendInfo.sc_Ctx2 = pBufCopy;
    SendInfo.sc_Ctx3 = pAtcpConn;

	//	send the packet
	error = AtalkNdisSendPacket(RasPortDesc,
	    						pPktDesc,
		    					AtalkDdpSendComplete,
			    				&SendInfo);
	
	if (!ATALK_SUCCESS(error))
	{
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("PPPTransmit: AtalkNdisSendPacket failed %ld\n",error));

	    AtalkDdpSendComplete(NDIS_STATUS_FAILURE,
		    				 pPktDesc,
			    			 &SendInfo);
	}

}


//***
//
// Function: PPPTransmitCompletion
//              This is the completion routine for PPPTransmit, and is called
//              by NDIS after the packet is sent out (or failure occurs)
//
// Parameters:  Status - how did the send go
//              pSendInfo - completion info
//
// Return:      none
//
//***$

VOID FASTCALL
PPPTransmitCompletion(
    IN  NDIS_STATUS         Status,
    IN  PSEND_COMPL_INFO    pSendInfo
)
{
    PBUFFER_DESC    pBuffDesc;

    DBG_PPP_CHECK_PAGED_CODE();

    pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx2);

    ASSERT(pBuffDesc != NULL);
    ASSERT(pBuffDesc->bd_Flags & (BD_CHAR_BUFFER | BD_FREE_BUFFER));

    if (Status != 0)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("PPPTransmitCompletion: send failed, %lx on %lx\n",
            Status,pSendInfo->sc_Ctx3));
    }

    AtalkFreeBuffDesc(pBuffDesc);
}


//***
//
// Function: PPPGetDynamicAddr
//              This routine gets a network address for a PPP dial-in client.
//              It does the same AARP logic as if it were acquiring a
//              node-address for the host itself.
//
// Parameters:  pAtcpConn - the connection for which we need a network addr
//
// Return:      ARAPERR_NO_ERROR if all went well.
//
//***$

DWORD
PPPGetDynamicAddr(
    IN PATCPCONN       pAtcpConn
)
{
    ATALK_NODEADDR      NetAddr;
    ATALK_NETWORKRANGE  NetRange;
    BOOLEAN             fFound=FALSE;
    KIRQL               OldIrql;
    DWORD               StatusCode=ARAPERR_STACK_NOT_UP;



    DBG_PPP_CHECK_PAGED_CODE();

    ASSERT(AtalkDefaultPort != NULL);

    //
    // go find a node address on the default port (we'll never get this far if
    // default port isn't up yet)
    //
    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

    ASSERT(!(pAtcpConn->Flags & ATCP_FINDING_NODE));

    pAtcpConn->Flags |= ATCP_FINDING_NODE;

    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

    AtalkLockInitIfNecessary();

    // if we are stuck in the startup range, use that range for dial-in guys, too
    if (WITHIN_NETWORK_RANGE(AtalkDefaultPort->pd_NetworkRange.anr_LastNetwork,
                             &AtalkStartupNetworkRange))
    {
        NetRange = AtalkStartupNetworkRange;
    }
    else
    {
        NetRange = AtalkDefaultPort->pd_NetworkRange;
    }
    fFound = AtalkInitAarpForNodeInRange(AtalkDefaultPort,
                                         (PVOID)pAtcpConn,
                                         TRUE,
                                         NetRange,
                                         &NetAddr);


    AtalkUnlockInitIfNecessary();

    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

    pAtcpConn->Flags &= ~ATCP_FINDING_NODE;

    if (fFound)
    {
        // store that adddr!
        pAtcpConn->NetAddr.atn_Network = NetAddr.atn_Network;
        pAtcpConn->NetAddr.atn_Node = NetAddr.atn_Node;

        pAtcpConn->Flags |= ATCP_NODE_IN_USE;
        StatusCode = ARAPERR_NO_ERROR;

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
    	    ("PPPGetDynamicAddr: found addr for PPP client = %lx %lx\n",
                NetAddr.atn_Network,NetAddr.atn_Node));
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("ArapGetDynamicAddr: PPP: no more network addr left?\n"));

        pAtcpConn->Flags &= ~ATCP_NODE_IN_USE;
        pAtcpConn->NetAddr.atn_Network = 0;
        pAtcpConn->NetAddr.atn_Node = 0;
        StatusCode = ARAPERR_NO_NETWORK_ADDR;
    }

    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

    return(StatusCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\ports.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ports.h

Abstract:

	This module contains the structures for ports.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_PORTS_
#define	_PORTS_

#define	PORT_AMT_HASH_SIZE			64
#define	PORT_BRC_HASH_SIZE			16

#define MAX_ENTITY_LENGTH			32
#define	MAX_HW_ADDR_LEN				6
#define	MAX_ROUTING_BYTES			18
#define	MAX_ROUTING_SPACE			0x1F		// This much space is allocated
												// for routing info

typedef VOID (*REQ_COMPLETION)(
						NDIS_STATUS 			Status,
						PVOID					Ctx
);

// Prototypes for handlers
typedef	ATALK_ERROR	(*ADDMULTICASTADDR)(
						struct _PORT_DESCRIPTOR *pPortDesc,
						PBYTE					Addr,
						BOOLEAN					ExecuteSync,
						REQ_COMPLETION			AddCompletion,
						PVOID					AddContext);

typedef	ATALK_ERROR	(*REMOVEMULTICASTADDR)(
						struct _PORT_DESCRIPTOR *pPortDesc,
						PBYTE					Addr,
						BOOLEAN					ExecuteSync,
						REQ_COMPLETION			RemoveCompletion,
						PVOID					RemoveContext);
// Address mapping table
// Each port that the stack or router is communicating on must have an
// address mapping table [except non-extended ports]. The mapping table
// holds the association between Appletalk node addresses (network/node),
// and the actual hardware (ethernet/tokenring) addresses. Hash on the
// network/node value.

#define	AMT_SIGNATURE		(*(ULONG *)"AMT ")
#if	DBG
#define	VALID_AMT(pAmt)		(((pAmt) != NULL) &&	\
							 ((pAmt)->amt_Signature == AMT_SIGNATURE))
#else
#define	VALID_AMT(pAmt)		((pAmt) != NULL)
#endif
typedef	struct _AMT_NODE
{
#if	DBG
	DWORD				amt_Signature;
#endif
	struct _AMT_NODE *	amt_Next;
	ATALK_NODEADDR		amt_Target;
	BYTE				amt_HardwareAddr[MAX_HW_ADDR_LEN];
	BYTE				amt_Age;
	BYTE				amt_RouteInfoLen;
	// BYTE				amt_RouteInfo[MAX_ROUTING_SPACE];
} AMT, *PAMT;

#define AMT_AGE_TIME	 			600		// In 100ms units
#define AMT_MAX_AGE					3



// Best Router Entry Table
// Maintained only for extended networks. This must age more quickly than the
// "SeenARouter" timer (50 seconds). To avoid allocations/frees for this structure,
// we use statically allocated data in the port descriptor.

typedef struct _BRE
{
	struct _BRE *		bre_Next;
	USHORT				bre_Network;
	BYTE				bre_Age;
	BYTE				bre_RouterAddr[MAX_HW_ADDR_LEN];
	BYTE				bre_RouteInfoLen;
	// BYTE				bre_RouteInfo[MAX_ROUTING_SPACE];
} BRE, *PBRE;

#define BRC_AGE_TIME				40		// In 100ms units
#define BRC_MAX_AGE					3

//
// Types of ports currently supported by stack. This is kept different
// from the NDIS medium types for two reasons. One is we use these as
// an index into the port handler array, and the second is if we decide
// to implement half-ports etc., which ndis might not be able to deal with.
// WARNING: THIS IS INTEGRATED WITH THE PORT HANDLER ARRAY IN GLOBALS.

typedef enum
{
	ELAP_PORT = 0,
	FDDI_PORT,
	TLAP_PORT,
	ALAP_PORT,
	ARAP_PORT,

	LAST_PORT,

	LAST_PORTTYPE = LAST_PORT

} ATALK_PORT_TYPE;


//
// PORT DESCRIPTORS
// Descriptor for each active port:
//

#define	PD_ACTIVE				0x00000001	// State after packets recv enabled
#define	PD_BOUND	 			0x00000002	// State it goes in before ACTIVE
#define	PD_EXT_NET				0x00000004	// For now, non-localtalk
#define	PD_DEF_PORT				0x00000008	// Is this the default port
#define	PD_SEND_CHECKSUMS		0x00000010	// Send ddp checksums?
#define	PD_SEED_ROUTER			0x00000020	// seeding on this port?
#define	PD_ROUTER_STARTING		0x00000040	// Temporary state when router is starting
#define	PD_ROUTER_RUNNING		0x00000080	// Is the router running?
#define	PD_SEEN_ROUTER_RECENTLY	0x00000100	// Seen router recently?
#define	PD_VALID_DESIRED_ZONE	0x00000200	// Desired Zone is valid
#define	PD_VALID_DEFAULT_ZONE	0x00000400	// Default zone is valid
#define	PD_FINDING_DEFAULT_ZONE	0x00000800	// searching for default zone?
#define	PD_FINDING_DESIRED_ZONE	0x00001000	// searching for desired zone?
#define	PD_FINDING_NODE			0x00002000	// In the process of acquiring a
								 			// new node on this port
#define	PD_NODE_IN_USE			0x00004000	// Tentative node is already in
								 			// use.
#define	PD_ROUTER_NODE			0x00008000 	// Router node is allocated
#define PD_USER_NODE_1			0x00010000 	// First user node is allocated
#define PD_USER_NODE_2			0x00020000 	// Second user node is allocated
#define PD_RAS_PORT             0x00040000  // this port for RAS clients
#define PD_PNP_RECONFIGURE      0x00080000  // this port is currently being reconfigured
#define PD_CONFIGURED_ONCE      0x00100000  // this port has been configured once
#define	PD_CLOSING				0x80000000	// State when unbinding/shutting down

#define	PD_SIGNATURE			(*(ULONG *)"PDES")
#if	DBG
#define	VALID_PORT(pPortDesc)	(((pPortDesc) != NULL) &&	\
								 ((pPortDesc)->pd_Signature == PD_SIGNATURE))
#else
#define	VALID_PORT(pPortDesc)	((pPortDesc) != NULL)
#endif
typedef struct _PORT_DESCRIPTOR
{
#if DBG
	ULONG					pd_Signature;
#endif

	// Link to next - for now to help debugging
	struct _PORT_DESCRIPTOR	*pd_Next;

	// Number of references to this port
	ULONG					pd_RefCount;

	// State of the port
	ULONG					pd_Flags;

    // if this is a Ras port, all ARAP connetions hang on this list
	LIST_ENTRY				pd_ArapConnHead;

    // if this is a Ras port, all PPP connetions hang on this list
	LIST_ENTRY				pd_PPPConnHead;

    // if this is a Ras port, how many lines do we have on this port?
    ULONG                   pd_RasLines;

	// Overide the default number of aarp probes when looking for a
	// node on this port
	SHORT					pd_AarpProbes;

	// Node # of the localtalk node
	USHORT					pd_LtNetwork;

	// Nodes that are being managed on this port. We have a maximum
	// of 2 nodes (3 if the router is started).
	struct _ATALK_NODE	*	pd_Nodes;

	struct _ATALK_NODE	*	pd_RouterNode;

	// Following are used only during node acquisition process.
	// PD_FINDINGNODE is set. Keep this separate from the ndis
	// request event. Both could happen at the same time.
	ATALK_NODEADDR			pd_TentativeNodeAddr;
	KEVENT					pd_NodeAcquireEvent;

	// Port type as defined above
	ATALK_PORT_TYPE 		pd_PortType;

	// NdisMedium type for this port
	NDIS_MEDIUM				pd_NdisPortType;

	// Used during OpenAdapter to block
	KEVENT					pd_RequestEvent;
	NDIS_STATUS		 		pd_RequestStatus;

	// 	Binding handle to the mac associated with this port
	// 	Options associated with the mac.
	// 	MAC Options - 	these are things that we can and cannot do with
	// 					specific macs. Is the value of OID_GEN_MAC_OPTIONS.
	NDIS_HANDLE		 		pd_NdisBindingHandle;
	ULONG					pd_MacOptions;

	// 	This is the spin lock used to protect all requests that need exclusion
	// 	over requests per port.
	ATALK_SPIN_LOCK			pd_Lock;

	// 	All the packets received on this port are linked in here. When the
	// 	receive complete indication is called, all of them are passed to DDP.
	LIST_ENTRY				pd_ReceiveQueue;

	// ASCII port name to be registered on the router node for this port
	// This will be an NBP object name and hence is limited to 32 characters.
	CHAR					pd_PortName[MAX_ENTITY_LENGTH + 1];

	// 	AdapterName is of the form \Device\<adaptername>. It is used
	// 	to bind to the NDIS macs, and then during ZIP requests by setup
	// 	to get the zonelist for a particular adapter. AdapterKey
	// 	contains the adapterName only- this is useful both for getting
	// 	per-port parameters and during errorlogging to specify the adapter
	// 	name without the '\Device\' prefix.
	UNICODE_STRING			pd_AdapterKey;
	UNICODE_STRING			pd_AdapterName;

    UNICODE_STRING          pd_FriendlyAdapterName;

	ATALK_NODEADDR	 		pd_RoutersPramNode;
	ATALK_NODEADDR	 		pd_UsersPramNode1;
	ATALK_NODEADDR	 		pd_UsersPramNode2;
	HANDLE					pd_AdapterInfoHandle;	// Valid during initialization only

	// Initial values from the registry
	ATALK_NETWORKRANGE		pd_InitialNetworkRange;
	struct _ZONE_LIST	*	pd_InitialZoneList;
	struct _ZONE		*	pd_InitialDefaultZone;
	struct _ZONE		*	pd_InitialDesiredZone;

	// True cable range of connected network. Initial/aged values for
	// extended ports: 1:FFFE; Initial value for non-extended ports:
	// 0:0 (does not age).
	ATALK_NETWORKRANGE		pd_NetworkRange;

	// If we are routing, this is the default zone for the network
	// on this port, and the zone list for the same.
	struct _ZONE_LIST	*	pd_ZoneList;
	struct _ZONE		*	pd_DefaultZone;
	struct _ZONE		*	pd_DesiredZone;

	// When did we hear from a router?
	LONG 					pd_LastRouterTime;

	// Address of last router seen. If we are a routing port, this will
	// always be the node that "our" router is operating on!
	ATALK_NODEADDR	 		pd_ARouter;
	KEVENT					pd_SeenRouterEvent;

	// Zone in which all nodes on this port reside and the multicast
	// address for it.
	CHAR					pd_ZoneMulticastAddr[MAX_HW_ADDR_LEN];

	union
	{
		struct
		{
			//
			// FOR ETHERNET PORTS:
			//
			// We add multicast addresses during ZIP packet reception at non-init
			// time. We need to do a GET followed by a SET with the new address
			// list. But there could be two zip packets coming in and doing the
			// same thing effectively overwriting the effects of the first one to
			// set the multicast list. So we need to maintain our own copy of the
			// multicast list.
			//

			// Size of the list
			ULONG			pd_MulticastListSize;
			PCHAR			pd_MulticastList;
		};

		struct
		{

			//
			// FOR TOKENRING PORTS:
			//
			// Just like for ethernet, we need to store the value for
			// the current functional address. We only modify the last
			// four bytes of this address, as the first two always remain
			// constant. So we use a ULONG for it.
			//

			UCHAR			pd_FunctionalAddr[4];	// TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN
		};
	};

	// Hardware address for the port
	union
	{
		UCHAR				pd_PortAddr[MAX_HW_ADDR_LEN];
		USHORT				pd_AlapNode;
	};

	// Mapping table for best route to "off cable" addresses.
	TIMERLIST				pd_BrcTimer;
	PBRE				 	pd_Brc[PORT_BRC_HASH_SIZE];

	// Logical/physical address mappings for the nodes on the network that
	// this port is connected to.
	ULONG					pd_AmtCount;	// # of entries in the Amt
	TIMERLIST				pd_AmtTimer;
	PAMT 					pd_Amt[PORT_AMT_HASH_SIZE];

	union
	{
		TIMERLIST			pd_RtmpSendTimer;	// If router is configured
		TIMERLIST			pd_RtmpAgingTimer;	// else
	};
	// Per port statistics
    ATALK_PORT_STATS		pd_PortStats;

	// Port handler stuff
	ADDMULTICASTADDR		pd_AddMulticastAddr;

	REMOVEMULTICASTADDR		pd_RemoveMulticastAddr;

	BYTE					pd_BroadcastAddr[MAX_HW_ADDR_LEN];
	USHORT					pd_BroadcastAddrLen;
	USHORT					pd_AarpHardwareType;
	USHORT					pd_AarpProtocolType;

	PKEVENT					pd_ShutDownEvent;
} PORT_DESCRIPTOR, *PPORT_DESCRIPTOR;

#define	INDICATE_ATP		0x01
#define	INDICATE_ADSP		0x02

#define	ATALK_CACHE_SKTMAX	8

#define	ATALK_CACHE_ADSPSKT		((BYTE)0x01)
#define	ATALK_CACHE_ATPSKT		((BYTE)0x02)
#define	ATALK_CACHE_INUSE	    ((BYTE)0x10)
#define	ATALK_CACHE_NOTINUSE	((BYTE)0)

typedef	struct _ATALK_SKT_CACHE
{
	USHORT					ac_Network;
	BYTE					ac_Node;

	struct ATALK_CACHED_SKT
	{
		BYTE				Type;
		BYTE				Socket;

		union
		{
			//	For ATP
			struct _ATP_ADDROBJ * pAtpAddr;
		} u;

	} ac_Cache[ATALK_CACHE_SKTMAX];

} ATALK_SKT_CACHE, *PATALK_SKT_CACHE;

extern		ATALK_SKT_CACHE	AtalkSktCache;
extern		ATALK_SPIN_LOCK	AtalkSktCacheLock;

// externS

extern	PPORT_DESCRIPTOR 	AtalkPortList;		 	// Head of the port list
extern	PPORT_DESCRIPTOR	AtalkDefaultPort;		// Ptr to the def port
extern	KEVENT				AtalkDefaultPortEvent;	// Signalled when default port is available
extern	UNICODE_STRING		AtalkDefaultPortName;	// Name of the default port
extern	ATALK_SPIN_LOCK		AtalkPortLock;			// Lock for AtalkPortList
extern	ATALK_NODEADDR		AtalkUserNode1;			// Node address of user node
extern	ATALK_NODEADDR		AtalkUserNode2;			// Node address of user node
extern	SHORT	 			AtalkNumberOfPorts; 	// Determine dynamically
extern	SHORT				AtalkNumberOfActivePorts;// Number of ports active
extern	BOOLEAN				AtalkRouter;			// Are we a router?
extern	BOOLEAN				AtalkFilterOurNames;	// If TRUE, Nbplookup fails on names on this machine
extern	KEVENT				AtalkUnloadEvent;		// Event for unloading
extern	NDIS_HANDLE			AtalkNdisPacketPoolHandle;
extern	NDIS_HANDLE			AtalkNdisBufferPoolHandle;
extern	LONG				AtalkHandleCount;
extern	UNICODE_STRING		AtalkRegPath;

extern  HANDLE				TdiRegistrationHandle;
extern 	BOOLEAN				AtalkNoDefPortPrinted;

// Exported prototypes
extern
VOID FASTCALL
AtalkPortDeref(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				AtDpc);

extern
BOOLEAN
AtalkReferenceDefaultPort(
    IN VOID
);

extern
ATALK_ERROR
AtalkPortShutdown(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc);

VOID FASTCALL
AtalkPortSetResetFlag(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	BOOLEAN				fRemoveBit,
    IN  DWORD               dwBit);


// Macros
#define	AtalkPortReferenceByPtr(Port, pErr)						\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortRefByPtr((Port), (pErr));					\
		}

#define	AtalkPortReferenceByPtrDpc(Port, pErr)					\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref (Dpc) at %s %d\n",					\
					__FILE__, __LINE__));						\
			AtalkPortRefByPtrDpc((Port), (pErr));				\
		}

#define	AtalkPortReferenceByPtrNonInterlock(Port, pErr)			\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortRefByPtrNonInterlock((Port), (pErr));		\
		}

#define	AtalkPortReferenceByDdpAddr(DdpAddr, Port, pErr)		\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortRefByDdpAddr((DdpAddr), (Port), (pErr));	\
		}

#define	AtalkPortDereference(Port)								\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Deref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortDeref(Port, FALSE);						\
		}

#define	AtalkPortDereferenceDpc(Port)							\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Deref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortDeref(Port, TRUE);							\
		}

#define	EXT_NET(_pPortDesc)				((_pPortDesc)->pd_Flags & PD_EXT_NET)
#define	DEF_PORT(_pPortDesc)			((_pPortDesc)->pd_Flags & PD_DEF_PORT)
#define	PORT_BOUND(_pPortDesc)			((_pPortDesc)->pd_Flags & PD_BOUND)
#define PORT_CLOSING(_pPortDesc)		((_pPortDesc)->pd_Flags & PD_CLOSING)

#define	AtalkPortRefByPtr(pPortDesc, pErr)						\
		{														\
			KIRQL	OldIrql;									\
																\
			ACQUIRE_SPIN_LOCK(&((pPortDesc)->pd_Lock),&OldIrql);\
			AtalkPortRefByPtrNonInterlock((pPortDesc), (pErr));	\
			RELEASE_SPIN_LOCK(&((pPortDesc)->pd_Lock),OldIrql);	\
		}

#define	AtalkPortRefByPtrDpc(pPortDesc, pErr)					\
		{														\
			ACQUIRE_SPIN_LOCK_DPC(&((pPortDesc)->pd_Lock));		\
			AtalkPortRefByPtrNonInterlock((pPortDesc), (pErr));	\
			RELEASE_SPIN_LOCK_DPC(&((pPortDesc)->pd_Lock));		\
		}

#define	AtalkPortRefByPtrNonInterlock(pPortDesc, pErr)			\
		{														\
			if (((pPortDesc)->pd_Flags & PD_CLOSING) == 0)		\
			{													\
				ASSERT((pPortDesc)->pd_RefCount > 0);			\
				(pPortDesc)->pd_RefCount++;						\
				*(pErr) = ATALK_NO_ERROR;						\
			}													\
			else												\
			{													\
				*(pErr) = ATALK_PORT_CLOSING;					\
			}													\
		}

#define	AtalkPortRefByDdpAddr(pDdpAddr, ppPortDesc,	pErr)		\
		{														\
			ASSERT(VALID_ATALK_NODE((pDdpAddr)->ddpao_Node));	\
																\
			*(ppPortDesc) = (pDdpAddr)->ddpao_Node->an_Port;	\
			AtalkPortRefByPtr(*(ppPortDesc), (pErr));			\
		}

VOID
atalkPortFreeZones(
	IN	PPORT_DESCRIPTOR	pPortDesc
);

#endif	// _PORTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\router.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	router.h

Abstract:

	This module contains the router associated definitions.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ROUTER_
#define	_ROUTER_


VOID
AtalkDdpRouteInPkt(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pSrc,
	IN	PATALK_ADDR					pDest,
	IN	BYTE						ProtoType,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
	IN	USHORT						HopCnt
);

VOID FASTCALL
atalkDdpRouteComplete(
	IN	NDIS_STATUS					Status,
	IN	PSEND_COMPL_INFO			pSendInfo
);

#endif	// _ROUTER_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\ports.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ports.c

Abstract:

	This module contains the port management code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	PORTS

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkPortShutdown)
#pragma alloc_text(PAGEINIT, atalkPortFreeZones)
#endif

VOID FASTCALL
AtalkPortDeref(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN	BOOLEAN					AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN				portDone	= FALSE;
    BOOLEAN             fPnPInProgress;
    BOOLEAN             fRasPort;
	KIRQL				OldIrql;

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	}

	ASSERT(pPortDesc->pd_RefCount > 0);
	pPortDesc->pd_RefCount--;
	if (pPortDesc->pd_RefCount == 0)
	{
		portDone	= TRUE;

		ASSERT((pPortDesc->pd_Flags & PD_CLOSING) != 0);
	}

    fPnPInProgress = (pPortDesc->pd_Flags & PD_PNP_RECONFIGURE)? TRUE : FALSE;

	//	We hold the lock while freeing up all the stuff, this should
	//	only happen during unload.
	if (portDone)
	{
		DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
				("AtalkPortDeref: Freeing zones and such ...\n"));
	
		//	Free up zonelist
		atalkPortFreeZones(pPortDesc);
	
		DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
				("AtalkPortDeref: Releasing Amt tables ...\n"));

		// We do need to free up the AMT.
		AtalkAarpReleaseAmt(pPortDesc);

		// Free the BRC
		AtalkAarpReleaseBrc(pPortDesc);
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	}

	if (portDone)
	{
		PPORT_DESCRIPTOR	*ppTmp;

		// Unlink the portdesc from the list and free its memory
		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

		for (ppTmp = &AtalkPortList;
			 *ppTmp != NULL;
			 ppTmp = &((*ppTmp)->pd_Next))
		{
			if (*ppTmp == pPortDesc)
			{
				*ppTmp = pPortDesc->pd_Next;
				break;
			}
		}

		ASSERT (*ppTmp == pPortDesc->pd_Next);

		// Is the default-port going away ?
		if (AtalkDefaultPort == pPortDesc)
		{
			AtalkDefaultPort = NULL;
			KeResetEvent(&AtalkDefaultPortEvent);
		}

		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

        //
        // if we are here becaue of PnP Reconfigure then don't free the memory
        // (we haven't closed the adapter with ndis, and we have other useful
        // stuff that we must retain).  Put the creation refcount and the
        // binding refcount back that got taken away when we first got the
        // PnP Reconfigure event.
        // (no need for spinlock: this was ready for a free!!)
        //
        if (fPnPInProgress)
        {
            // 1 binding refcount + 1 creation refcount
            pPortDesc->pd_RefCount = 2;

            if (pPortDesc->pd_Flags & PD_RAS_PORT)
            {
                fRasPort = TRUE;
            }
            else
            {
                fRasPort = FALSE;
            }

            // blow away everything on the flag, except these
			pPortDesc->pd_Flags = (PD_PNP_RECONFIGURE | PD_BOUND);

            if (fRasPort)
            {
                pPortDesc->pd_Flags |= PD_RAS_PORT;
            }

            // restore EXT_NET flag if applicable
            if (pPortDesc->pd_PortType != ALAP_PORT)
            {
                pPortDesc->pd_Flags |= PD_EXT_NET;
            }

            // reset all pointers and other gunk to 0
            pPortDesc->pd_Next = NULL;
            pPortDesc->pd_Nodes = NULL;
            pPortDesc->pd_RouterNode = NULL;
            pPortDesc->pd_TentativeNodeAddr.atn_Network = 0;
            pPortDesc->pd_TentativeNodeAddr.atn_Node = 0;
            pPortDesc->pd_RoutersPramNode.atn_Network = 0;
            pPortDesc->pd_RoutersPramNode.atn_Node = 0;
            pPortDesc->pd_UsersPramNode1.atn_Network = 0;
            pPortDesc->pd_UsersPramNode1.atn_Node = 0;
            pPortDesc->pd_UsersPramNode2.atn_Network = 0;
            pPortDesc->pd_UsersPramNode2.atn_Node = 0;
            pPortDesc->pd_InitialZoneList = NULL;
            pPortDesc->pd_InitialDefaultZone = NULL;
            pPortDesc->pd_InitialDesiredZone = NULL;
            pPortDesc->pd_ZoneList = NULL;
            pPortDesc->pd_DefaultZone = NULL;
            pPortDesc->pd_DesiredZone = NULL;
            pPortDesc->pd_AmtCount = 0;
            RtlZeroMemory(&pPortDesc->pd_PortStats, sizeof(ATALK_PORT_STATS));

		    // Unblock caller now that we are done
		    KeSetEvent(pPortDesc->pd_ShutDownEvent, IO_NETWORK_INCREMENT, FALSE);

            pPortDesc->pd_ShutDownEvent = NULL;
        }
        else
        {
            // is the Arap port going away?
            if (RasPortDesc == pPortDesc)
            {
                RasPortDesc = NULL;
            }

		    if (pPortDesc->pd_MulticastList != NULL)
            {
			    AtalkFreeMemory(pPortDesc->pd_MulticastList);
			    pPortDesc->pd_MulticastList = NULL;
            }
	
		    // Unblock caller now that we are done
		    KeSetEvent(pPortDesc->pd_ShutDownEvent, IO_NETWORK_INCREMENT, FALSE);

            if (pPortDesc->pd_FriendlyAdapterName.Buffer)
            {
                AtalkFreeMemory(pPortDesc->pd_FriendlyAdapterName.Buffer);
            }

		    AtalkFreeMemory(pPortDesc);

		    ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
		    AtalkNumberOfPorts --;
		    RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
        }
	}
}



BOOLEAN
AtalkReferenceDefaultPort(
    IN VOID
)
{

    KIRQL       OldIrql;
    BOOLEAN     fReferenced = FALSE;


    ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
    if (AtalkDefaultPort)
    {
        ACQUIRE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
        if ( !(AtalkDefaultPort->pd_Flags & (PD_PNP_RECONFIGURE | PD_CLOSING)) )
        {
            AtalkDefaultPort->pd_RefCount++;
            fReferenced = TRUE;
        }
        RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
    }
    RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

    return(fReferenced);
}


VOID
atalkPortFreeZones(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	// Dereference initial default and desired zones, and the zone list
	if (pPortDesc->pd_InitialDefaultZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_InitialDefaultZone);
	if (pPortDesc->pd_InitialDesiredZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_InitialDesiredZone);
	if (pPortDesc->pd_InitialZoneList != NULL)
		AtalkZoneFreeList(pPortDesc->pd_InitialZoneList);

	// and the current versions of the zones
	if (pPortDesc->pd_DefaultZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_DefaultZone);
	if (pPortDesc->pd_DesiredZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_DesiredZone);
	if (pPortDesc->pd_ZoneList != NULL)
		AtalkZoneFreeList(pPortDesc->pd_ZoneList);
}


VOID FASTCALL
AtalkPortSetResetFlag(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	BOOLEAN				fRemoveBit,
    IN  DWORD               dwBit
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    KIRQL           OldIrql;


    ASSERT(VALID_PORT(pPortDesc));

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
    if (fRemoveBit)
    {
	    pPortDesc->pd_Flags &= ~(dwBit);
    }
    else
    {
	    pPortDesc->pd_Flags |= dwBit;
    }
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
}


ATALK_ERROR
AtalkPortShutdown(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pAtalkNode;
	ATALK_ERROR		error = ATALK_NO_ERROR;
	BOOLEAN			fActive;
	BOOLEAN			fRasPort=FALSE;
    BOOLEAN         fPnpReconfigure;
	KEVENT			ShutdownEvent;
	KIRQL			OldIrql;



	DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
			("AtalkPortShutdown: Shutting down port %Z...\n", &pPortDesc->pd_AdapterKey));

	KeInitializeEvent(&ShutdownEvent, NotificationEvent, FALSE);

    // if this is the default port, tell TDI that we are leaving so server finds out
    if (pPortDesc->pd_Flags & PD_DEF_PORT)
    {
        if (TdiRegistrationHandle)
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			    ("AtalkPortShutdown: deregistering device!!\n"));

            TdiDeregisterDeviceObject(TdiRegistrationHandle);
            TdiRegistrationHandle = NULL;
        }
    }

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

    // we have already taken care of the Arap port separately: just say done
    if (pPortDesc->pd_Flags & PD_RAS_PORT)
    {
	    fRasPort = TRUE;
    }

	pPortDesc->pd_Flags |= PD_CLOSING;

	fActive = (pPortDesc->pd_Flags & PD_BOUND) ? TRUE : FALSE;
    fPnpReconfigure = (pPortDesc->pd_Flags & PD_PNP_RECONFIGURE)? TRUE : FALSE;

	//	Switch off the active flag just in case the unbind fails.
	//	We arent going to accept any packets anymore.
	pPortDesc->pd_Flags &= ~PD_ACTIVE;
	pPortDesc->pd_ShutDownEvent = &ShutdownEvent;

	DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
		("AtalkPortShutdown: Freeing nodes on port ....\n"));

	//	Release any nodes on this port that are not already closing.
    if (!fRasPort)
    {
	    do
	    {
		    //	Ref the next node.
		    //	ASSERT!! error does not get changed after this statement.
		    AtalkNodeReferenceNextNc(pPortDesc->pd_Nodes, &pAtalkNode, &error);

		    if (!ATALK_SUCCESS(error))
            {
			    break;
            }

		    RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		    DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_ERR,
			    	("AtalkPortShutdown: Releasing Node\n"));

		    AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);

		    AtalkNodeDereference(pAtalkNode);

		    ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	    } while (TRUE);
    }

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	// If we are routing, remove the RTEs for this port since each has a reference
	// to this port.
	if (AtalkRouter & !fRasPort)
	{
		AtalkRtmpKillPortRtes(pPortDesc);
	}

    if (EXT_NET(pPortDesc))
    {
        // cancel the Amt timer and take away the refcount for it
        if (AtalkTimerCancelEvent(&pPortDesc->pd_AmtTimer, NULL))
        {
		    AtalkPortDereference(pPortDesc);
        }

        // cancel the Brc timer and take away the refcount for it
        if (AtalkTimerCancelEvent(&pPortDesc->pd_BrcTimer, NULL))
        {
		    AtalkPortDereference(pPortDesc);
        }
    }

    if (!AtalkRouter)
    {
        // cancel the RtmpAging timer and take away the refcount for it
        if (AtalkTimerCancelEvent(&pPortDesc->pd_RtmpAgingTimer, NULL))
        {
		    AtalkPortDereference(pPortDesc);
        }
    }

    //
    // if we are currently bound, *and* we are not here because of
    // PnPReconfigure, go ahead and unbind from ndis
    //
	if (fActive && !fPnpReconfigure)
	{
		//	Unbind from the mac
		AtalkNdisUnbind(pPortDesc);
	}

    //
    // if are here because of PnpReconfigure, we didn't unbind.  But fake
    // that we did (from refcount perspective) so that we can proceed!
    // (in the PnPReconfigure code path, we don't free this memory when refcount
    // goes to 0: we merely use it to trigger some pnp work)
    //
    if (fPnpReconfigure)
    {
		AtalkPortDereference(pPortDesc);
    }

	//	Remove the creation reference
	AtalkPortDereference(pPortDesc);	

	//  Make sure we are not at or above dispatch level
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	//	Wait for the last reference to go away
	KeWaitForSingleObject(&ShutdownEvent,
						  Executive,
						  KernelMode,
						  FALSE,
						  NULL);

	if (fActive)
	{
		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
		AtalkNumberOfActivePorts--;
		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

        ASSERT(AtalkStatistics.stat_NumActivePorts > 0);

        AtalkStatistics.stat_NumActivePorts--;
	}

	DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_ERR,
			("AtalkPortShutdown: shutdown for port %lx completed\n",pPortDesc));

	return ATALK_NO_ERROR;
}


#if DBG

VOID
AtalkPortDumpInfo(
	VOID
)
{
	int					i, j;
	KIRQL				OldIrql;
	PPORT_DESCRIPTOR	pPortDesc;
	PZONE_LIST			pZoneList;

	ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
	for (pPortDesc = AtalkPortList;
		 pPortDesc != NULL;
		 pPortDesc = pPortDesc->pd_Next)
	{
		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("Port info for port %Z\n", &pPortDesc->pd_AdapterKey));

		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  Flags               -> %d\n", pPortDesc->pd_Flags));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  PortType            -> %d\n", pPortDesc->pd_PortType));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  PortName            -> %s\n", pPortDesc->pd_PortName));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  AARP Probes         -> %d\n", pPortDesc->pd_AarpProbes));

		if (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != 0)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("  InitialNwRange      -> %lx-%lx\n",
					pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork,
					pPortDesc->pd_InitialNetworkRange.anr_LastNetwork))
		}

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  NetworkRange        -> %x-%x\n",
				pPortDesc->pd_NetworkRange.anr_FirstNetwork,
				pPortDesc->pd_NetworkRange.anr_LastNetwork))

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  ARouter Address     -> %x.%x\n",
				pPortDesc->pd_ARouter.atn_Network,
				pPortDesc->pd_ARouter.atn_Node));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  Multicast Addr      -> "));
		for (j = 0; j < MAX_HW_ADDR_LEN; j++)
			DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
							("%02x", (BYTE)pPortDesc->pd_ZoneMulticastAddr[j]));
		DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
							("\n"));

		if (pPortDesc->pd_InitialZoneList != NULL)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("  Initial zone list:\n"));
	
			for (pZoneList = pPortDesc->pd_InitialZoneList;
				 pZoneList != NULL; pZoneList = pZoneList->zl_Next)
			{
				DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
						("    %s\n", pZoneList->zl_pZone->zn_Zone));
			}
		}

		if (pPortDesc->pd_InitialDefaultZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  InitialDefZone      -> %s\n",
				pPortDesc->pd_InitialDefaultZone->zn_Zone));

		if (pPortDesc->pd_InitialDesiredZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  InitialDesZone      -> %s\n",
				pPortDesc->pd_InitialDesiredZone->zn_Zone));

		if (pPortDesc->pd_ZoneList)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("  Current zone list:\n"));
	
			for (pZoneList = pPortDesc->pd_ZoneList;
				 pZoneList != NULL; pZoneList = pZoneList->zl_Next)
			{
				DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
						("    %s\n", pZoneList->zl_pZone->zn_Zone));
			}
		}

		if (pPortDesc->pd_DefaultZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  CurrentDefZone      -> %s\n",
				pPortDesc->pd_DefaultZone->zn_Zone));

		if (pPortDesc->pd_DesiredZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  CurrentDesZone      -> %s\n",
				pPortDesc->pd_DesiredZone->zn_Zone));

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
	RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\rasproto.h ===
// prototypes

NTSTATUS
ArapProcessIoctl(
	IN PIRP 			pIrp
);


BOOLEAN
ArapAcceptIrp(
    IN PIRP     pIrp,
    IN ULONG    IoControlCode,
    IN BOOLEAN  *pfDerefDefPort
);


VOID
ArapCancelIrp(
    IN  PIRP    pIrp
);


VOID
ArapGetSelectIrp(
    IN  PIRP    *ppIrp
);


NTSTATUS
ArapExchangeParms(
    IN PIRP         pIrp
);


NTSTATUS
ArapConnect(
    IN PIRP                 pIrp,
    IN ULONG                IoControlCode
);


NTSTATUS
ArapDisconnect(
    IN PIRP                 pIrp
);


NTSTATUS
ArapGetStats(
    IN PIRP                 pIrp
);


NTSTATUS
ArapGetAddr(
    IN PIRP                 pIrp
);


NTSTATUS
ArapProcessSelect(
    IN  PIRP  pIrp
);


PARAPCONN
FindArapConnByContx(
    IN  PVOID   pDllContext
);


PARAPCONN
FindAndRefArapConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD               *pdwFlags
);


PVOID
FindAndRefRasConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD              *pdwFlags,
    OUT BOOLEAN            *pfThisIsPPP
);


BOOLEAN
ArapConnIsValid(
    IN  PARAPCONN  pArapConn
);


VOID
DerefArapConn(
	IN	PARAPCONN    pArapConn
);


VOID
DerefMnpSendBuf(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN BOOLEAN       fNdisSendComplete
);


VOID
ArapReleaseAddr(
    IN PARAPCONN    pArapConn
);


NTSTATUS
ArapIoctlSend(
    IN PIRP                    pIrp
);


NTSTATUS
ArapIoctlRecv(
    IN PIRP                 pIrp
);


VOID
ArapDelayedNotify(
    OUT PARAPCONN   *ppDiscArapConn,
    OUT PARAPCONN   *ppRecvArapConn
);


DWORD
ArapSendPrepare(
    IN  PARAPCONN       pArapConn,
    IN  PBUFFER_DESC    pOrgBuffDesc,
    IN  DWORD           Priority
);

VOID
ArapIoctlSendComplete(
	IN  DWORD               StatusCode,
    IN  PARAPCONN           pArapConn
);


VOID
ArapRcvIndication(
    IN PARAPCONN    pArapConn,
    IN PVOID        LkBuf,
    IN UINT         LkBufSize
);


VOID
ArapRcvComplete(
    IN VOID
);


VOID
ArapPerConnRcvProcess(
    IN  PARAPCONN   pArapConn
);


VOID
ArapNdisSend(
    IN  PARAPCONN       pArapConn,
    IN  PLIST_ENTRY     pSendHead
);


DWORD
ArapGetNdisPacket(
    IN PMNPSENDBUF     pMnpSendBuf
);


BOOLEAN
ArapRefillSendQ(
    IN PARAPCONN    pArapConn
);


VOID
ArapNdisSendComplete(
	IN NDIS_STATUS		    Status,
	IN PBUFFER_DESC         pBufferDesc,
    IN PSEND_COMPL_INFO     pSendInfo
);


VOID
RasStatusIndication(
	IN	NDIS_STATUS 	GeneralStatus,
	IN	PVOID			StatusBuf,
	IN	UINT 			StatusBufLen
);


VOID
ArapRetransmitComplete(
	NDIS_STATUS				Status,
	PBUFFER_DESC			pBuffDesc,
	PSEND_COMPL_INFO		pArapSendInfo
);


VOID ArapMnpSendComplete(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN DWORD         Status
);


PARAPBUF
ArapExtractAtalkSRP(
    IN PARAPCONN    pArapConn
);


PBYTE
ArapAllocDecompMemory(
    IN DWORD    BufferSize
);


VOID
ArapFreeDecompMemory(
    IN PBYTE    pDecompMemory
);


DWORD
ArapQueueSendBytes(
    IN PARAPCONN    pArapConn,
    IN PBYTE        pCompressedDataBuffer,
    IN DWORD        CompressedDataLen,
    IN  DWORD       Priority
);


PMNPSENDBUF
ArapGetSendBuf(
    IN PARAPCONN pArapConn,
    IN DWORD     Priority
);


DWORD
PrepareConnectionResponse(
    IN PARAPCONN  pArapConn,
    IN PBYTE      pReq,
    IN  DWORD     ReqLen,
    IN PBYTE      pFrame,
    IN USHORT   * pMnpLen
);


NTSTATUS
ArapMarkConnectionForCallback(
    IN PIRP                 pIrp,
    IN ULONG                IoControlCode
);


NTSTATUS
ArapMarkConnectionUp(
    IN PIRP                 pIrp
);


PLIST_ENTRY
ArapRearrangePackets(
    IN PARAPCONN    pArapConn,
    IN PLIST_ENTRY  pRcvList
);


VOID
MnpSendAckIfReqd(
    IN PARAPCONN pArapConn,
    IN BOOLEAN   fForceAck
);


VOID
MnpSendLNAck(
    IN  PARAPCONN    pArapConn,
    IN  BYTE         LnSeqToAck
);


DWORD
ArapSendLDPacket(
    IN PARAPCONN    pArapConn,
    IN BYTE         UserCode
);


VOID
ArapConnectComplete(
    IN PMNPSENDBUF  pMnpSendBuf,
    IN DWORD        Status
);


VOID
ArapCleanup(
    IN PARAPCONN    pArapConn
);


DWORD
ArapDataToDll(
	IN	PARAPCONN    pArapConn
);


VOID
MnpSendAckComplete(
    IN NDIS_STATUS          Status,
    IN PBUFFER_DESC         pBuffDesc,
    IN PSEND_COMPL_INFO     pInfo
);


DWORD
ArapGetStaticAddr(
    IN PARAPCONN  pArapConn
);


DWORD
ArapGetDynamicAddr(
    IN PARAPCONN       pArapConn
);


PARAPCONN
AllocArapConn(
    IN ULONG    LinkSpeed
);


DWORD
ArapUnblockSelect(
    IN  VOID
);


DWORD
ArapReleaseResources(
    IN  VOID
);


BOOLEAN
AtalkReferenceRasDefPort(
    IN  VOID
);


VOID
AtalkPnPInformRas(
    IN  BOOLEAN     fEnableRas
);


DWORD
ArapScheduleWorkerEvent(
    IN DWORD Action,
    IN PVOID Context1,
    IN PVOID Context2
);


VOID
ArapDelayedEventHandler(
    IN PARAPQITEM  pArapQItem
);


LONG FASTCALL
ArapRetryTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
);


VOID
ArapRoutePacketFromWan(
    IN  PARAPCONN    pArapConn,
    IN  PARAPBUF     pArapBuf
);


VOID
ArapRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
);


BOOLEAN
ArapOkToForward(
    IN  PARAPCONN   pArapConn,
    IN  PBYTE       packet,
    IN  USHORT      packetLen,
    OUT DWORD      *pPriority
);


VOID
ArapAddArapRoute(
    IN VOID
);


VOID
ArapDeleteArapRoute(
    IN VOID
);



VOID
ArapZipGetZoneStat(
    IN OUT PZONESTAT pZoneStat
);


VOID
ArapZipGetZoneStatCompletion(
    IN ATALK_ERROR  ErrorCode,
    IN PACTREQ      pActReq
);


BOOLEAN
ArapValidNetrange(
    IN NETWORKRANGE NetRange
);

BOOLEAN
v42bisInit(
  IN  PARAPCONN  pArapConn,
  IN  PBYTE      pReq,
  OUT DWORD     *dwReqToSkip,
  OUT PBYTE      pFrame,
  OUT DWORD     *dwFrameToSkip
);


DWORD
v42bisCompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pUncompressedData,
  IN  DWORD      UnCompressedDataLen,
  OUT PUCHAR     pCompressedData,
  OUT DWORD      CompressedDataBufSize,
  OUT DWORD     *pCompressedDataLen
);


DWORD
v42bisDecompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pCompressedData,
  IN  DWORD      CompressedDataLen,
  OUT PUCHAR     pDecompressedData,
  OUT DWORD      DecompressedDataBufSize,
  OUT DWORD     *pByteStillToDecompress,
  OUT DWORD     *pDecompressedDataLen
);


VOID
ArapCaptureSniff(
    IN  PARAPCONN       pArapConn,
    IN  PBUFFER_DESC    pBufferDescr,
    IN  BYTE            FirstSeq,
    IN  BYTE            LastSeq
);


//
// PPP specific routines
//

PATCPCONN
AllocPPPConn(
    IN VOID
);


NTSTATUS FASTCALL
PPPProcessIoctl(
	IN     PIRP 			    pIrp,
    IN OUT PARAP_SEND_RECV_INFO pSndRcvInfo,
    IN     ULONG                IoControlCode,
    IN     PATCPCONN            pIncomingAtcpConn
);


VOID
DerefPPPConn(
	IN	PATCPCONN    pAtcpConn
);


PATCPCONN
FindAndRefPPPConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD               *pdwFlags
);



VOID
PPPRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
);


VOID FASTCALL
PPPTransmit(
    IN  PATCPCONN    pAtcpConn,
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount
);


VOID FASTCALL
PPPTransmitCompletion(
    IN  NDIS_STATUS         Status,
    IN  PSEND_COMPL_INFO    pSendInfo
);


DWORD
PPPGetDynamicAddr(
    IN PATCPCONN       pAtcpConn
);


//
// Debug-only routines
//

#if DBG

NTSTATUS
ArapProcessSniff(
    IN  PIRP  pIrp
);


BOOLEAN
DbgChkRcvQIntegrity(
    IN  PARAPCONN       pArapConn
);

VOID
DbgDumpBytes(
    IN PBYTE  pDbgMsg,
    IN PBYTE  pBuffer,
    IN DWORD  BufLen,
    IN DWORD  DumpLevel
);

VOID
DbgDumpBytesPart2(
    IN  PBYTE  pBuffer,
    OUT PBYTE  OutBuf,
    IN  DWORD  BufLen,
    OUT DWORD *NextIndex
);

VOID
DbgDumpNetworkNumbers(
    IN VOID
);


VOID
ArapDbgTrace(
    IN PARAPCONN    pArapConn,
    IN DWORD        Location,
    IN PVOID        Context,
    IN DWORD        dwInfo1,
    IN DWORD        dwInfo2,
    IN DWORD        dwInfo3
);


VOID
ArapDbgMnpHist(
    IN PARAPCONN    pArapConn,
    IN BYTE         Seq,
    IN BYTE         FrameType
);

VOID
ArapDbgDumpMnpHist(
    IN PARAPCONN    pArapConn
);


BOOLEAN
ArapDumpSniffInfo(
    IN PARAPCONN    pArapConn
);


DWORD
ArapFillIrpWithSniffInfo(
    IN PARAPCONN    pArapConn,
    IN PIRP         pIrp
);


VOID
DbgTrackInfo(
    IN PARAPCONN    pArapConn,
    IN DWORD        Size,
    IN DWORD        TrackingWhat
);


VOID
ArapDumpNdisPktInfo(
    IN VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\rtmp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	rtmp.c

Abstract:

	This module implements the rtmp.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	26 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		RTMP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AtalkRtmpInit)
#pragma alloc_text(PAGEINIT, AtalkInitRtmpStartProcessingOnPort)
#pragma alloc_text(PAGEINIT, atalkRtmpGetOrSetNetworkNumber)
#pragma alloc_text(PAGEINIT, AtalkRtmpKillPortRtes)
#pragma alloc_text(PAGE_RTR, AtalkRtmpPacketInRouter)
#pragma alloc_text(PAGE_RTR, AtalkRtmpReferenceRte)
#pragma alloc_text(PAGE_RTR, AtalkRtmpDereferenceRte)
#pragma alloc_text(PAGE_RTR, atalkRtmpCreateRte)
#pragma alloc_text(PAGE_RTR, atalkRtmpRemoveRte)
#pragma alloc_text(PAGE_RTR, atalkRtmpSendTimer)
#pragma alloc_text(PAGE_RTR, atalkRtmpValidityTimer)
#pragma alloc_text(PAGE_RTR, atalkRtmpSendRoutingData)
#endif


/***	AtalkRtmpInit
 *
 */
ATALK_ERROR
AtalkRtmpInit(
	IN	BOOLEAN	Init
)
{
	if (Init)
	{
		// Allocate space for routing tables and recent routes
		AtalkRoutingTable =
				(PRTE *)AtalkAllocZeroedMemory(sizeof(PRTE) * NUM_RTMP_HASH_BUCKETS);
		AtalkRecentRoutes =
				(PRTE *)AtalkAllocZeroedMemory(sizeof(PRTE) * NUM_RECENT_ROUTES);
		if ((AtalkRecentRoutes == NULL) || (AtalkRoutingTable == NULL))
		{
			if (AtalkRoutingTable != NULL)
            {
				AtalkFreeMemory(AtalkRoutingTable);
                AtalkRoutingTable = NULL;
            }
			return ATALK_RESR_MEM;
		}

		INITIALIZE_SPIN_LOCK(&AtalkRteLock);
	}
	else
	{
		// At this point, we are unloading and there are no race conditions
		// or lock contentions. Do not bother locking down the rtmp tables
		if (AtalkRoutingTable != NULL)
		{
			int		i;
			PRTE	pRte;

			for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
			{
				ASSERT(AtalkRoutingTable[i] == NULL);
			}
			AtalkFreeMemory(AtalkRoutingTable);
			AtalkRoutingTable = NULL;
		}
		if (AtalkRecentRoutes != NULL)
		{
			AtalkFreeMemory(AtalkRecentRoutes);
			AtalkRecentRoutes = NULL;
		}
	}
	return ATALK_NO_ERROR;
}

BOOLEAN
AtalkInitRtmpStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 	pPortDesc,
	IN	PATALK_NODEADDR		pRouterNode
)
{
	ATALK_ADDR		closeAddr;
	ATALK_ERROR		Status;
	PRTE			pRte;
	KIRQL			OldIrql;
	BOOLEAN			rc = FALSE;
    PDDP_ADDROBJ    pRtDdpAddr=NULL;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	// For extended networks, the process of acquiring the node has done most of the work
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	do
	{
		if (EXT_NET(pPortDesc))
		{
			if ((pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				(pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK))
			{
				if (!NW_RANGE_EQUAL(&pPortDesc->pd_InitialNetworkRange,
									&pPortDesc->pd_NetworkRange))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
							("AtalkRtmpStartProcessingOnPort: Initial range %d-%d, Actual %d-%d\n",
							pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork,
							pPortDesc->pd_InitialNetworkRange.anr_LastNetwork,
							pPortDesc->pd_NetworkRange.anr_FirstNetwork,
							pPortDesc->pd_NetworkRange.anr_LastNetwork));
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INVALID_NETRANGE,
									0,
									NULL,
									0);
	
					// Change InitialNetwork range so that it matches the net
					pPortDesc->pd_InitialNetworkRange = pPortDesc->pd_NetworkRange;
				}
			}
	
			// We are the seed router, so seed if possible
			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				!(pPortDesc->pd_Flags & PD_SEED_ROUTER))
			{
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				break;
			}
			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
			{
				pPortDesc->pd_NetworkRange = pPortDesc->pd_InitialNetworkRange;
			}
		}
	
		// For non-extended network either seed or find our network number
		else
		{
			PATALK_NODE		pNode;
			USHORT			SuggestedNetwork;
			int				i;
	
			SuggestedNetwork = UNKNOWN_NETWORK;
			if (pPortDesc->pd_Flags & PD_SEED_ROUTER)
				SuggestedNetwork = pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			if (!atalkRtmpGetOrSetNetworkNumber(pPortDesc, SuggestedNetwork))
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpStartProcessingOnPort: atalkRtmpGetOrSetNetworkNumber failed\n"));
				break;
			}
	
			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
			{
				pPortDesc->pd_NetworkRange.anr_FirstNetwork =
				pPortDesc->pd_NetworkRange.anr_LastNetwork =
								pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork;
			}
	
			// We'd have allocated a node with network 0, fix it up. Alas the fixup
			// also involves all the sockets so far created on this node.
			pNode = pPortDesc->pd_Nodes;
			ASSERT((pNode != NULL) && (pPortDesc->pd_RouterNode == pNode));
	
			pNode->an_NodeAddr.atn_Network =
			pPortDesc->pd_LtNetwork =
			pPortDesc->pd_ARouter.atn_Network =
			pRouterNode->atn_Network = pPortDesc->pd_NetworkRange.anr_FirstNetwork;
	
			ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);
			for (i = 0; i < NODE_DDPAO_HASH_SIZE; i ++)
			{
				PDDP_ADDROBJ	pDdpAddr;
	
				for (pDdpAddr = pNode->an_DdpAoHash[i];
					 pDdpAddr != NULL;
					 pDdpAddr = pDdpAddr->ddpao_Next)
				{
					ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
					pDdpAddr->ddpao_Addr.ata_Network =
								pPortDesc->pd_NetworkRange.anr_FirstNetwork;
					RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
				}
			}
			RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);
		}
	
		// We're the router now. Mark it appropriately
		pPortDesc->pd_Flags |= (PD_ROUTER_RUNNING | PD_SEEN_ROUTER_RECENTLY);
		KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
		pPortDesc->pd_ARouter = *pRouterNode;
	
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
		// Before creating a Rte for ourselves, check if there is an Rte with
		// the same network range already. This will happen, for instance, when
		// we are routing on ports which other routers are also seeding and we
		// got to know of our port from the other router on another port !!!
		do
		{
			pRte = AtalkRtmpReferenceRte(pPortDesc->pd_NetworkRange.anr_FirstNetwork);
			if (pRte != NULL)
			{
				ACQUIRE_SPIN_LOCK(&pRte->rte_Lock, &OldIrql);
				pRte->rte_RefCount --;		// Take away creation reference
				pRte->rte_Flags |= RTE_DELETE;
				RELEASE_SPIN_LOCK(&pRte->rte_Lock, OldIrql);
		
				AtalkRtmpDereferenceRte(pRte, FALSE);
		
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpStartProcessing: Invalid Rte for port %Z's range found\n",
						&pPortDesc->pd_AdapterKey));
			}
		} while (pRte != NULL);
	
		// Now we get to really, really create our own Rte !!!
		if (!atalkRtmpCreateRte(pPortDesc->pd_NetworkRange,
								pPortDesc,
								pRouterNode,
								0))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpStartProcessingOnPort: Could not create Rte\n"));
			break;
		}
	
		// Switch the incoming rtmp handler to the router version
		closeAddr.ata_Network = pRouterNode->atn_Network;
		closeAddr.ata_Node = pRouterNode->atn_Node;
		closeAddr.ata_Socket = RTMP_SOCKET;
	
		ASSERT (KeGetCurrentIrql() == LOW_LEVEL);
	
		AtalkDdpInitCloseAddress(pPortDesc, &closeAddr);
		Status = AtalkDdpOpenAddress(pPortDesc,
								RTMP_SOCKET,
								pRouterNode,
								AtalkRtmpPacketInRouter,
								NULL,
								DDPPROTO_ANY,
								NULL,
								&pRtDdpAddr);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpStartProcessingOnPort: AtalkDdpOpenAddress failed %ld\n",
					Status));
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpStartProcessingOnPort: Unable to open the routers rtmp socket %ld\n",
					Status));
			
			break;
		}

        // mark the fact that this is an "internal" socket
        pRtDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;
	
		// Start the timers now. Reference the port for each timer.
		AtalkPortReferenceByPtr(pPortDesc, &Status);
		if (!ATALK_SUCCESS(Status))
		{
			break;
		}
		AtalkTimerInitialize(&pPortDesc->pd_RtmpSendTimer,
							 atalkRtmpSendTimer,
							 RTMP_SEND_TIMER);
		AtalkTimerScheduleEvent(&pPortDesc->pd_RtmpSendTimer);
	
		if (!atalkRtmpVdtTmrRunning)
		{
			AtalkTimerInitialize(&atalkRtmpVTimer,
								 atalkRtmpValidityTimer,
								 RTMP_VALIDITY_TIMER);
			AtalkTimerScheduleEvent(&atalkRtmpVTimer);

            atalkRtmpVdtTmrRunning = TRUE;
		}
		rc = TRUE;
	} while (FALSE);

	return rc;
}


// Private data structure used between AtalkRtmpPacketIn and atalkRtmpGetNwInfo
typedef struct _QueuedGetNwInfo
{
	WORK_QUEUE_ITEM		qgni_WorkQItem;
	PPORT_DESCRIPTOR	qgni_pPortDesc;
	PDDP_ADDROBJ		qgni_pDdpAddr;
	ATALK_NODEADDR		qgni_SenderNode;
	ATALK_NETWORKRANGE	qgni_CableRange;
	BOOLEAN				qgni_FreeThis;
} QGNI, *PQGNI;


VOID
atalkRtmpGetNwInfo(
	IN	PQGNI	pQgni
)
{
	PPORT_DESCRIPTOR	pPortDesc = pQgni->qgni_pPortDesc;
	PDDP_ADDROBJ		pDdpAddr = pQgni->qgni_pDdpAddr;
	KIRQL				OldIrql;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	AtalkZipGetNetworkInfoForNode(pPortDesc,
									&pDdpAddr->ddpao_Node->an_NodeAddr,
									FALSE);

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	
	if (!(pPortDesc->pd_Flags & PD_ROUTER_RUNNING))
	{
		// Well, we heard from a router. Copy the information. Don't do it
		// if we're a router [maybe a proxy node on arouting port] -- we don't
		// want "aRouter" to shift away from "us."
		pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
		KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
		pPortDesc->pd_LastRouterTime = AtalkGetCurrentTick();
		pPortDesc->pd_ARouter = pQgni->qgni_SenderNode;
		pPortDesc->pd_NetworkRange = pQgni->qgni_CableRange;
	}
	
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	if (pQgni->qgni_FreeThis)
	{
		AtalkDdpDereference(pDdpAddr);
		AtalkFreeMemory(pQgni);
	}
}

VOID
AtalkRtmpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)			
{
	ATALK_NODEADDR		SenderNode;
	ATALK_NETWORKRANGE	CableRange;
	ATALK_ERROR			Status;
	TIME				TimeS, TimeE, TimeD;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);
	do
	{
		if (ErrorCode == ATALK_SOCKET_CLOSED)
			break;

		else if (ErrorCode != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (DdpType != DDPPROTO_RTMPRESPONSEORDATA)
			break;

		// we do not care about non-ext tuples on an extended network
		if ((EXT_NET(pPortDesc)) && (PktLen < (RTMP_RANGE_END_OFF+2)))
		{
			break;
		}

		GETSHORT2SHORT(&SenderNode.atn_Network, pPkt+RTMP_SENDER_NW_OFF);
		if (pPkt[RTMP_SENDER_IDLEN_OFF] != 8)
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		SenderNode.atn_Node = pPkt[RTMP_SENDER_ID_OFF];

		if (EXT_NET(pPortDesc))
		{
			GETSHORT2SHORT(&CableRange.anr_FirstNetwork, pPkt+RTMP_RANGE_START_OFF);
			GETSHORT2SHORT(&CableRange.anr_LastNetwork, pPkt+RTMP_RANGE_END_OFF);
			if (!AtalkCheckNetworkRange(&CableRange))
				break;
		}

		// On a non-extended network, we do not have to do any checking.
		// Just copy the information into A-ROUTER and THIS-NET
		if (!EXT_NET(pPortDesc))
		{
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
			KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
			pPortDesc->pd_LastRouterTime = AtalkGetCurrentTick();
			pPortDesc->pd_ARouter = SenderNode;
			if (pPortDesc->pd_NetworkRange.anr_FirstNetwork == UNKNOWN_NETWORK)
			{
				PATALK_NODE	pNode;
				LONG		i;

				pDdpAddr->ddpao_Node->an_NodeAddr.atn_Network =
					pPortDesc->pd_NetworkRange.anr_FirstNetwork =
					pPortDesc->pd_NetworkRange.anr_LastNetwork = SenderNode.atn_Network;

				pNode = pPortDesc->pd_Nodes;
				ASSERT (pNode != NULL);
		
				// Fixup all sockets to have the correct network numbers.
				ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);
				for (i = 0; i < NODE_DDPAO_HASH_SIZE; i ++)
				{
					PDDP_ADDROBJ	pDdpAddr;
		
					for (pDdpAddr = pNode->an_DdpAoHash[i];
						 pDdpAddr != NULL;
						 pDdpAddr = pDdpAddr->ddpao_Next)
					{
						PREGD_NAME	pRegdName;
						PPEND_NAME	pPendName;

						ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
						DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
								("Setting socket %d to network %d\n",
								pDdpAddr->ddpao_Addr.ata_Socket, SenderNode.atn_Network));
						pDdpAddr->ddpao_Addr.ata_Network = SenderNode.atn_Network;

						// Now all regd/pend name tuples as well
						for (pRegdName = pDdpAddr->ddpao_RegNames;
							 pRegdName != NULL;
							 pRegdName = pRegdName->rdn_Next)
						{
							pRegdName->rdn_Tuple.tpl_Address.ata_Network = SenderNode.atn_Network;
						}

						for (pPendName = pDdpAddr->ddpao_PendNames;
							 pPendName != NULL;
							 pPendName = pPendName->pdn_Next)
						{
							ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
							pPendName->pdn_pRegdName->rdn_Tuple.tpl_Address.ata_Network = SenderNode.atn_Network;
							RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
						}

						RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
					}
				}
				RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);
			}
			else if (pPortDesc->pd_NetworkRange.anr_FirstNetwork != SenderNode.atn_Network)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}

		// On extended networks, we may want to reject the information: If we
		// already know about a router, the cable ranges must exacly match; If
		// we don't know about a router, our node's network number must be
		// within the cable range specified by the first tuple. The latter
		// test will discard the information if our node is in the startup
		// range (which is the right thing to do).
		if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
		{
			if (!NW_RANGE_EQUAL(&CableRange, &pPortDesc->pd_NetworkRange))
				break;
		}

		// Okay, we've seen a valid Rtmp data, this should allow us to find the
		// zone name for the port. We do this outside of the
		// "PD_SEEN_ROUTER_RECENTLY" case because the first time a router
		// send out an Rtmp data it may not know everything yet, or
		// AtalkZipGetNetworkInfoForNode() may really do a
		// hard wait and we may need to try it a second time (due to not
		// repsonding to Aarp LocateNode's the first time through... the
		// second time our addresses should be cached by the remote router
		// and he won't need to do a LocateNode again).

		if (!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
		{
			if (!WITHIN_NETWORK_RANGE(pDdpAddr->ddpao_Addr.ata_Network,
									  &CableRange))
				break;

			// MAKE THIS ASYNCHRONOUS CONDITIONALLY BASED ON THE CURRENT IRQL
			// A new router, see if it will tell us our zone name.
			if (KeGetCurrentIrql() == LOW_LEVEL)
			{
				QGNI	Qgni;

				Qgni.qgni_pPortDesc = pPortDesc;
				Qgni.qgni_pDdpAddr = pDdpAddr;
				Qgni.qgni_SenderNode = SenderNode;
				Qgni.qgni_CableRange = CableRange;
				Qgni.qgni_FreeThis = FALSE;
				atalkRtmpGetNwInfo(&Qgni);
			}
			else
			{
				PQGNI	pQgni;

				if ((pQgni = AtalkAllocMemory(sizeof(QGNI))) != NULL)
				{
					pQgni->qgni_pPortDesc = pPortDesc;
					pQgni->qgni_pDdpAddr = pDdpAddr;
					pQgni->qgni_SenderNode = SenderNode;
					pQgni->qgni_CableRange = CableRange;
					pQgni->qgni_FreeThis = TRUE;
					AtalkDdpReferenceByPtr(pDdpAddr, &Status);
					ASSERT (ATALK_SUCCESS(Status));
					ExInitializeWorkItem(&pQgni->qgni_WorkQItem,
										 (PWORKER_THREAD_ROUTINE)atalkRtmpGetNwInfo,
										 pQgni);
					ExQueueWorkItem(&pQgni->qgni_WorkQItem, CriticalWorkQueue);
				}
			}
			break;
		}

		// Update the fact that we heard from a router
		if ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING) == 0)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
			KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
			pPortDesc->pd_LastRouterTime = AtalkGetCurrentTick();
			pPortDesc->pd_ARouter = SenderNode;
			pPortDesc->pd_NetworkRange = CableRange;
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		}
	} while (FALSE);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_RtmpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumRtmpPacketsIn,
		&AtalkStatsLock.SpinLock);
}



VOID
AtalkRtmpPacketInRouter(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)
{
	PBUFFER_DESC		pBuffDesc = NULL;
	ATALK_NETWORKRANGE	CableRange;
	ATALK_ERROR			Status;
	TIME				TimeS, TimeE, TimeD;
	PRTE				pRte = NULL;
	BYTE				RtmpCmd, NumHops;
	PBYTE				Datagram;
	int					i, index;
	USHORT				RespSize;
	BOOLEAN				RteLocked;
	SEND_COMPL_INFO	 	SendInfo;

	TimeS = KeQueryPerformanceCounter(NULL);

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	do
	{
		if (ErrorCode == ATALK_SOCKET_CLOSED)
			break;

		if (ErrorCode != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (DdpType == DDPPROTO_RTMPREQUEST)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: RtmpRequest\n"));

			if (PktLen < RTMP_REQ_DATAGRAM_SIZE)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			RtmpCmd = pPkt[RTMP_REQ_CMD_OFF];

			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: RtmpRequest %d\n", RtmpCmd));

			if ((RtmpCmd == RTMP_DATA_REQUEST) ||
				(RtmpCmd == RTMP_ENTIRE_DATA_REQUEST))
			{
				atalkRtmpSendRoutingData(pPortDesc, pSrcAddr,
									 (BOOLEAN)(RtmpCmd == RTMP_DATA_REQUEST));
				break;
			}
			else if (RtmpCmd != RTMP_REQUEST)
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("atalkRtmpPacketInRouter: RtmpCmd %d\n", RtmpCmd));
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}

			// This is a standard Rtmp Request. Do the needfull
			// Send an Rtmp response to this guy. Start off by allocating
			// a buffer descriptor
			pBuffDesc = AtalkAllocBuffDesc(NULL,
											RTMP_RESPONSE_MAX_SIZE,
											BD_CHAR_BUFFER | BD_FREE_BUFFER);
			if (pBuffDesc == NULL)
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpPacketInRouter: AtalkAllocBuffDesc failed\n"));
				break;
			}

			Datagram = pBuffDesc->bd_CharBuffer;
			PUTSHORT2SHORT(Datagram + RTMP_SENDER_NW_OFF,
							pPortDesc->pd_ARouter.atn_Network);
			Datagram[RTMP_SENDER_IDLEN_OFF] = 8;
			Datagram[RTMP_SENDER_ID_OFF] = pPortDesc->pd_ARouter.atn_Node;

			// On extended port, we also want to add the initial network
			// range tuple
			RespSize = RTMP_SENDER_ID_OFF + sizeof(BYTE);
			if (EXT_NET(pPortDesc))
			{
				PUTSHORT2SHORT(Datagram+RTMP_RANGE_START_OFF,
								pPortDesc->pd_NetworkRange.anr_FirstNetwork);
				PUTSHORT2SHORT(Datagram+RTMP_RANGE_END_OFF,
								pPortDesc->pd_NetworkRange.anr_LastNetwork);
				Datagram[RTMP_TUPLE_TYPE_OFF] = RTMP_TUPLE_WITHRANGE;
				RespSize = RTMP_RANGE_END_OFF + sizeof(USHORT);
			}

			//	Set the length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pBuffDesc, RespSize);
	
			// Send the response
			ASSERT(pBuffDesc->bd_Length > 0);
			SendInfo.sc_TransmitCompletion = atalkRtmpSendComplete;
			SendInfo.sc_Ctx1 = pBuffDesc;
			// SendInfo.sc_Ctx2 = NULL;
			// SendInfo.sc_Ctx3 = NULL;
			if (!ATALK_SUCCESS(Status = AtalkDdpSend(pDdpAddr,
													 pSrcAddr,
													 (BYTE)DDPPROTO_RTMPRESPONSEORDATA,
													 FALSE,
													 pBuffDesc,
													 NULL,
													 0,
													 NULL,
													 &SendInfo)))
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpPacketInRouter: DdpSend failed %ld\n", ErrorCode));
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpPacketInRouter: AtalkDdpSend Failed %ld\n", Status));
				AtalkFreeBuffDesc(pBuffDesc);
			}
			pBuffDesc = NULL;
			break;
		}
		else if (DdpType != DDPPROTO_RTMPRESPONSEORDATA)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: Not ours !!!\n"));
			break;
		}

		ASSERT (DdpType == DDPPROTO_RTMPRESPONSEORDATA);

		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
				("AtalkRtmpPacketInRouter: RtmpResponse\n"));

		if ((PktLen < (RTMP_SENDER_IDLEN_OFF + 1)) ||
			(pPkt[RTMP_SENDER_IDLEN_OFF] != 8))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpPacketInRouter: %sExt net, PktLen %d, SenderId %d\n",
					EXT_NET(pPortDesc) ? "" : "Non", PktLen, pPkt[RTMP_SENDER_IDLEN_OFF]));
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		// For non-extended networks, we should have a leading version stamp
		if (EXT_NET(pPortDesc))
		{
			// Source could be bad (coming in from a half port) so in this
			// case use the source from the rtmp packet
			if (pSrcAddr->ata_Network == UNKNOWN_NETWORK)
			{
                if (PktLen < RTMP_SENDER_ID_OFF + 1)
                {
                    ASSERT(0);
                    break;
                }

				GETSHORT2SHORT(&pSrcAddr->ata_Network, pPkt+RTMP_SENDER_NW_OFF);
				pSrcAddr->ata_Node = pPkt[RTMP_SENDER_ID_OFF];
			}
			index = RTMP_SENDER_ID_OFF + 1;
		}
		else
		{
			USHORT	SenderId;

            if (PktLen < RTMP_TUPLE_TYPE_OFF+1)
            {
                ASSERT(0);
                break;
            }
			GETSHORT2SHORT(&SenderId, pPkt + RTMP_SENDER_ID_OFF + 1);
			if ((SenderId != 0) ||
				(pPkt[RTMP_TUPLE_TYPE_OFF] != RTMP_VERSION))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			index = RTMP_SENDER_ID_OFF + 4;
		}

		// Walk though the routing tuples. Ensure we atleast have a
		// non-extended tuple
		RteLocked = FALSE;
		while ((index + sizeof(USHORT) + sizeof(BYTE)) <= PktLen)
		{
			BOOLEAN	FoundOverlap;

			// Dereference the previous RTE, if any
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}

			GETSHORT2SHORT(&CableRange.anr_FirstNetwork, pPkt+index);
			index += sizeof(USHORT);
			NumHops = pPkt[index++];
			CableRange.anr_LastNetwork = CableRange.anr_FirstNetwork;
			if (NumHops & RTMP_EXT_TUPLE_MASK)
			{
				if ((index + sizeof(USHORT) + sizeof(BYTE)) > PktLen)
				{
                    ASSERT(0);
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}

				GETSHORT2SHORT(&CableRange.anr_LastNetwork, pPkt+index);
				index += sizeof(USHORT);
				if (pPkt[index++] != RTMP_VERSION)
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
			}
			NumHops &= RTMP_NUM_HOPS_MASK;

			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: Response - Port %Z, Hops %d, CableRange %d,%d\n",
					&pPortDesc->pd_AdapterKey,  NumHops,
					CableRange.anr_FirstNetwork, CableRange.anr_LastNetwork));

			if (!AtalkCheckNetworkRange(&CableRange))
				continue;

			// Check if this tuple concerns a network range that we
			// already know about
			pRte = AtalkRtmpReferenceRte(CableRange.anr_FirstNetwork);
			if ((pRte != NULL) &&
				NW_RANGE_EQUAL(&pRte->rte_NwRange, &CableRange))
			{
				ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
				RteLocked = TRUE;

				// Check for "notify neighbor" telling us that an entry is bad
				if ((NumHops == RTMP_NUM_HOPS_MASK) &&
					(pRte->rte_NextRouter.atn_Network == pSrcAddr->ata_Network) &&
					(pRte->rte_NextRouter.atn_Node == pSrcAddr->ata_Node))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
							("AtalkRtmpPacketInRouter: Notify Neighbor State %d\n",
							pRte->rte_State));

					if (pRte->rte_State != UGLY)
						pRte->rte_State = BAD;

					continue;
				}

				// If we are hearing about one of our directly connected
				// nets, we know best. Ignore the information.
				if (pRte->rte_NumHops == 0)
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
							("AtalkRtmpPacketInRouter: Ignoring - hop count 0\n",
							pRte->rte_State));
					continue;
				}

				// Check for previously bad entry, and a short enough
				// path with this tuple. Also if it shorter or equi-
				// distant path to target network. If so, replace the entry

				if ((NumHops < RTMP_MAX_HOPS) &&
					((pRte->rte_NumHops >= (NumHops + 1)) ||
					 (pRte->rte_State >= BAD)))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
							("AtalkRtmpPacketInRouter: Updating Rte from:\n\tRange %d,%d Hops %d Port %Z NextRouter %d.%d\n",
							pRte->rte_NwRange.anr_FirstNetwork,
							pRte->rte_NwRange.anr_LastNetwork,
							pRte->rte_NumHops,
							&pRte->rte_PortDesc->pd_AdapterKey,
							pRte->rte_NextRouter.atn_Node,
							pRte->rte_NextRouter.atn_Network));
					pRte->rte_NumHops = NumHops + 1;
					pRte->rte_NextRouter.atn_Network = pSrcAddr->ata_Network;
					pRte->rte_NextRouter.atn_Node = pSrcAddr->ata_Node;
					if (pRte->rte_PortDesc != pPortDesc)
					{
						ATALK_ERROR	Error;

						AtalkPortDereference(pRte->rte_PortDesc);
						AtalkPortReferenceByPtrDpc(pPortDesc, &Error);
						ASSERT (ATALK_SUCCESS(Error));
						pRte->rte_PortDesc = pPortDesc;
					}
					pRte->rte_State = GOOD;
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
							("to:\tRange %d,%d Hops %d NextRouter %d.%d\n",
							pRte->rte_NwRange.anr_FirstNetwork,
							pRte->rte_NwRange.anr_LastNetwork,
							pRte->rte_NumHops,
							pRte->rte_NextRouter.atn_Node,
							pRte->rte_NextRouter.atn_Network));
					continue;
				}

				// Check for the same router still thinking it has a path
				// to the network, but it is further away now. If so
				// update the entry
				if ((pRte->rte_PortDesc == pPortDesc) &&
					(pRte->rte_NextRouter.atn_Network == pSrcAddr->ata_Network) &&
					(pRte->rte_NextRouter.atn_Node == pSrcAddr->ata_Node))
				{
					pRte->rte_NumHops = NumHops + 1;
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
							("AtalkRtmpPacketInRouter: NumHops for Rte %lx changed to %d\n",
							pRte, pRte->rte_NumHops));

					if (pRte->rte_NumHops < 16)
						 pRte->rte_State = GOOD;
					else
					{
						// atalkRtmpRemoveRte(pRte);
						DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
								("AtalkRtmpPacketInRouter: Removing Rte\n"));
						pRte->rte_Flags |= RTE_DELETE;
						pRte->rte_RefCount --;
					}
				}
				continue;
			}

			// Dereference any previous RTEs
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}

			// Walk thru the entire routing table making sure the current
			// tuple does not overlap with anything we already have (since
			// it did not match. If we find an overlap, ignore the tuple
			// (a network configuration error, no doubt), else add it as
			// a new network range !!

			ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);

			FoundOverlap = FALSE;
			for (i = 0; !FoundOverlap && (i < NUM_RTMP_HASH_BUCKETS); i++)
			{
				for (pRte = AtalkRoutingTable[i];
					 pRte != NULL; pRte = pRte->rte_Next)
				{
					if (AtalkRangesOverlap(&pRte->rte_NwRange, &CableRange))
					{
						FoundOverlap = TRUE;
						DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
								("AtalkRtmpPacketInRouter: Overlapped ranges %d,%d & %d,%d\n",
								pRte->rte_NwRange.anr_FirstNetwork,
								pRte->rte_NwRange.anr_LastNetwork,
								CableRange.anr_FirstNetwork,
								CableRange.anr_LastNetwork));
						break;
					}
				}
			}

			RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

			pRte = NULL;		// We do not want to Dereference this !!!

			if (FoundOverlap)
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpPacketInRouter: Found overlapped ranges\n"));
				continue;
			}

			// Enter this new network range
			if (NumHops < RTMP_MAX_HOPS)
			{
				ATALK_NODEADDR	NextRouter;

				NextRouter.atn_Network = pSrcAddr->ata_Network;
				NextRouter.atn_Node = pSrcAddr->ata_Node;
				atalkRtmpCreateRte(CableRange,
								   pPortDesc,
								   &NextRouter,
								   NumHops + 1);
			}
		}
	} while (FALSE);

	if (pRte != NULL)
	{
		if (RteLocked)
		{
			RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
			// RteLocked = FALSE;
		}
		AtalkRtmpDereferenceRte(pRte, FALSE);
		// pRte = NULL;
	}

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_RtmpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumRtmpPacketsIn,
		&AtalkStatsLock.SpinLock);
}



/***	AtalkReferenceRte
 *
 */
PRTE
AtalkRtmpReferenceRte(
	IN	USHORT	Network
)
{
	int		i, index, rindex;
	PRTE	pRte;
	KIRQL	OldIrql;

	index = (int)((Network >> 4) % NUM_RTMP_HASH_BUCKETS);
	rindex = (int)((Network >> 6) % NUM_RECENT_ROUTES);

	// First try the recent route cache
	ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

	if (((pRte = AtalkRecentRoutes[rindex]) == NULL) ||
		!IN_NETWORK_RANGE(Network, pRte))
	{
		// We did not find it in the recent routes cache,
		// check in the real table
		for (pRte = AtalkRoutingTable[index];
			 pRte != NULL;
			 pRte = pRte->rte_Next)
		{
			if (IN_NETWORK_RANGE(Network, pRte))
				break;
		}

		// If we did not find here. Check all routing tables.
		// If we do, cache the info
		if (pRte == NULL)
		{
			for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
			{
				for (pRte = AtalkRoutingTable[i];
					 pRte != NULL;
					 pRte = pRte->rte_Next)
				{
					if (IN_NETWORK_RANGE(Network, pRte))
					{
						AtalkRecentRoutes[rindex] = pRte;
						break;
					}
				}

				//	if we found an entry, search no further.
				if (pRte != NULL)
					break;
			}
		}
	}

	if (pRte != NULL)
	{
		ASSERT(VALID_RTE(pRte));

		ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

		pRte->rte_RefCount ++;
		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
				("AtalkRtmpReferenceRte: Rte %lx, PostCount %d\n",
				pRte, pRte->rte_RefCount));

		RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
	}

	RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);

	return (pRte);
}


/***	AtalkRtmpDereferenceRte
 *
 */
VOID
AtalkRtmpDereferenceRte(
	IN	PRTE	pRte,
	IN	BOOLEAN	LockHeld
)
{
	PRTE *				ppRte;
	int					Index;
	BOOLEAN				KillCache = FALSE, Kill = FALSE;
	KIRQL				OldIrql;
	PPORT_DESCRIPTOR	pPortDesc;

	ASSERT(VALID_RTE(pRte));

	ASSERT(pRte->rte_RefCount > 0);

	DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
			("AtalkRtmpDereferenceRte: Rte %lx, PreCount %d\n",
			pRte, pRte->rte_RefCount));

	ACQUIRE_SPIN_LOCK(&pRte->rte_Lock, &OldIrql);

	pRte->rte_RefCount --;
	KillCache = (pRte->rte_Flags & RTE_DELETE) ? TRUE : FALSE;
	if (pRte->rte_RefCount == 0)
	{
		ASSERT (pRte->rte_Flags & RTE_DELETE);
		KillCache = Kill = TRUE;
	}

	RELEASE_SPIN_LOCK(&pRte->rte_Lock, OldIrql);

	if (KillCache)
	{
		pPortDesc = pRte->rte_PortDesc;

		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
			("atalkRtmpDereferenceRte: Removing from cache for port %Z, Range %d, %d\n",
			&pRte->rte_PortDesc->pd_AdapterKey,
			pRte->rte_NwRange.anr_FirstNetwork,
			pRte->rte_NwRange.anr_LastNetwork));

		if (!LockHeld)
			ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

		// Walk through the recent routes cache and kill All found
		for (Index = 0; Index < NUM_RECENT_ROUTES; Index ++)
		{
			if (AtalkRecentRoutes[Index] == pRte)
			{
				AtalkRecentRoutes[Index] = NULL;
			}
		}

		if (Kill)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
					("atalkRtmpDereferenceRte: Removing for port %Z, Range %d, %d\n",
					&pRte->rte_PortDesc->pd_AdapterKey,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork));

			Index = (pRte->rte_NwRange.anr_FirstNetwork >> 4) % NUM_RTMP_HASH_BUCKETS;
	
			for (ppRte = &AtalkRoutingTable[Index];
				 *ppRte != NULL;
				 ppRte = &(*ppRte)->rte_Next)
			{
				if (pRte == *ppRte)
				{
					*ppRte = pRte->rte_Next;
					AtalkZoneFreeList(pRte->rte_ZoneList);
					AtalkFreeMemory(pRte);
					break;
				}
			}
			AtalkPortDereference(pPortDesc);
		}

		if (!LockHeld)
			RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
	}
}


/***	atalkCreateRte
 *
 */
BOOLEAN
atalkRtmpCreateRte(
	IN	ATALK_NETWORKRANGE	NwRange,
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		pNextRouter,
	IN	int					NumHops
)
{
	ATALK_ERROR	Error;
	PRTE		pRte;
	int			index, rindex;
	KIRQL		OldIrql;
	BOOLEAN		Success = FALSE;

	index = (int)((NwRange.anr_FirstNetwork >> 4) % NUM_RTMP_HASH_BUCKETS);
	rindex = (int)((NwRange.anr_FirstNetwork >> 6) % NUM_RECENT_ROUTES);

	// First reference the port
	AtalkPortReferenceByPtr(pPortDesc, &Error);

	if (ATALK_SUCCESS(Error))
	{
		if ((pRte = AtalkAllocMemory(sizeof(RTE))) != NULL)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("atalkRtmpCreateRte: Creating for port %Z, Range %d,%d Hops %d index %d\n",
					&pPortDesc->pd_AdapterKey,
					NwRange.anr_FirstNetwork,
					NwRange.anr_LastNetwork,
					NumHops,
					index));
#if	DBG
			pRte->rte_Signature = RTE_SIGNATURE;
#endif
			INITIALIZE_SPIN_LOCK(&pRte->rte_Lock);
			pRte->rte_RefCount = 1;		// Creation Reference
			pRte->rte_State = GOOD;
			pRte->rte_Flags = 0;
			pRte->rte_NwRange = NwRange;
			pRte->rte_NumHops = (BYTE)NumHops;
			pRte->rte_PortDesc = pPortDesc;
			pRte->rte_NextRouter = *pNextRouter;
			pRte->rte_ZoneList = NULL;
	
			// Link this in the global table
			ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);
	
			pRte->rte_Next = AtalkRoutingTable[index];
			AtalkRoutingTable[index] = pRte;
			AtalkRecentRoutes[rindex] = pRte;
	
			RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
	
			Success = TRUE;
		}
		else
		{
			AtalkPortDereference(pPortDesc);
		}
	}

	return Success;
}


/***	atalkRtmpRemoveRte
 *
 */
BOOLEAN
atalkRtmpRemoveRte(
	IN	USHORT	Network
)
{
	PRTE	pRte;
	KIRQL	OldIrql;

	if ((pRte = AtalkRtmpReferenceRte(Network)) != NULL)
	{
		ACQUIRE_SPIN_LOCK(&pRte->rte_Lock, &OldIrql);
		pRte->rte_RefCount --;		// Take away creation reference
		pRte->rte_Flags |= RTE_DELETE;
		RELEASE_SPIN_LOCK(&pRte->rte_Lock, OldIrql);

		AtalkRtmpDereferenceRte(pRte, FALSE);
	}

	return (pRte != NULL);
}


/***	AtalkRtmpKillPortRtes
 *
 */
VOID FASTCALL
AtalkRtmpKillPortRtes(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{
	// At this point, we are unloading and there are no race conditions
	// or lock contentions. Do not bother locking down the rtmp tables
	if (AtalkRoutingTable != NULL)
	{
		int		i;
		PRTE	pRte, pTmp;
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

		for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
		{
			for (pRte = AtalkRoutingTable[i];
				 pRte != NULL;
				 pRte = pTmp)
			{
				pTmp = pRte->rte_Next;
				if (pRte->rte_PortDesc == pPortDesc)
				{
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					pRte->rte_Flags |= RTE_DELETE;
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					AtalkRtmpDereferenceRte(pRte, TRUE);
				}
			}
		}

		RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
	}
}


/***	AtalkRtmpAgingTimer
 *
 */
LONG FASTCALL
AtalkRtmpAgingTimer(
	IN	PTIMERLIST	pContext,
	IN	BOOLEAN		TimerShuttingDown
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ERROR			error;
	LONG				Now;

	pPortDesc = CONTAINING_RECORD(pContext, PORT_DESCRIPTOR, pd_RtmpAgingTimer);

	if (TimerShuttingDown ||
		(pPortDesc->pd_Flags & PD_CLOSING))
	{
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	Now = AtalkGetCurrentTick();

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	if (((pPortDesc->pd_Flags &
		  (PD_ACTIVE | PD_ROUTER_RUNNING | PD_SEEN_ROUTER_RECENTLY)) ==
			 (PD_ACTIVE | PD_SEEN_ROUTER_RECENTLY)) &&
		((pPortDesc->pd_LastRouterTime + RTMP_AGING_TIMER) < Now))
	{
		// Age out A-ROUTER. On extended networks age out THIS-CABLE-RANGE
		// and THIS-ZONE too
		KeClearEvent(&pPortDesc->pd_SeenRouterEvent);
		pPortDesc->pd_Flags &= ~PD_SEEN_ROUTER_RECENTLY;
		if (EXT_NET(pPortDesc))
		{
			pPortDesc->pd_Flags &= ~PD_VALID_DESIRED_ZONE;
			pPortDesc->pd_NetworkRange.anr_FirstNetwork = FIRST_VALID_NETWORK;
			pPortDesc->pd_NetworkRange.anr_LastNetwork = LAST_STARTUP_NETWORK;

			// If we have a zone multicast address that is not broadcast, age it out
			if (!AtalkFixedCompareCaseSensitive(pPortDesc->pd_ZoneMulticastAddr,
												MAX_HW_ADDR_LEN,
												pPortDesc->pd_BroadcastAddr,
												MAX_HW_ADDR_LEN))
			{
				// Release lock before calling in to remove multicast address
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	
				(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
													 pPortDesc->pd_ZoneMulticastAddr,
													 FALSE,
													 NULL,
													 NULL);
	
				// Re-acquire the lock now
				ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			}

			RtlZeroMemory(pPortDesc->pd_ZoneMulticastAddr, MAX_HW_ADDR_LEN);
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return ATALK_TIMER_REQUEUE;
}


/***	atalkRtmpSendTimer
 *
 */
LOCAL LONG FASTCALL
atalkRtmpSendTimer(
	IN	PTIMERLIST	pContext,
	IN	BOOLEAN		TimerShuttingDown
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ADDR			Destination;
	ATALK_ERROR			error;

	pPortDesc = CONTAINING_RECORD(pContext, PORT_DESCRIPTOR, pd_RtmpSendTimer);

	if (TimerShuttingDown ||
		(pPortDesc->pd_Flags & PD_CLOSING))
	{
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	Destination.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
	Destination.ata_Node = ATALK_BROADCAST_NODE;
	Destination.ata_Socket = RTMP_SOCKET;

	if (((pPortDesc->pd_Flags &
		  (PD_ACTIVE | PD_ROUTER_RUNNING)) == (PD_ACTIVE | PD_ROUTER_RUNNING)))
	{
		atalkRtmpSendRoutingData(pPortDesc, &Destination, TRUE);
	}

	return ATALK_TIMER_REQUEUE;
}


/***	atalkValidityTimer
 *
 */
LOCAL LONG FASTCALL
atalkRtmpValidityTimer(
	IN	PTIMERLIST	pContext,
	IN	BOOLEAN		TimerShuttingDown
)
{
	PRTE	pRte, pNext;
	int		i;

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pNext)
		{
			BOOLEAN	Deref;

			pNext = pRte->rte_Next;
			if (pRte->rte_NumHops == 0)
				continue;

			Deref = FALSE;
			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

			switch (pRte->rte_State)
			{
			  case GOOD:
			  case SUSPECT:
			  case BAD:
				pRte->rte_State++;
				break;

			  case UGLY:
				Deref = TRUE;
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
						("atalkRtmpValidityTimer: Killing pRte %lx\n"));
  				pRte->rte_Flags |= RTE_DELETE;
				break;

			  default:
				// How did we get here ?
				ASSERT(0);
				KeBugCheck(0);
			}

			RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);

			if (Deref)
				AtalkRtmpDereferenceRte(pRte, TRUE);
		}
	}
	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

	return ATALK_TIMER_REQUEUE;
}


/***	atalkRtmpSendRoutingData
 *
 */
LOCAL VOID
atalkRtmpSendRoutingData(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pDstAddr,
	IN	BOOLEAN				fSplitHorizon
)
{
	int				i, index;
	PRTE			pRte;
	PBYTE			Datagram;
	PDDP_ADDROBJ	pDdpAddr;
	ATALK_ADDR		SrcAddr;
	PBUFFER_DESC	pBuffDesc,
					pBuffDescStart = NULL,
					*ppBuffDesc = &pBuffDescStart;
	SEND_COMPL_INFO	SendInfo;
	ATALK_ERROR		Status;
	BOOLEAN			AllocNewBuffDesc = TRUE;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	// Compute the source socket: Rtmp socket on our routers node
	SrcAddr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
	SrcAddr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
	SrcAddr.ata_Socket = RTMP_SOCKET;

	AtalkDdpReferenceByAddr(pPortDesc, &SrcAddr, &pDdpAddr, &Status);
	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
				("atalkRtmpSendRoutingData: AtalkDdpRefByAddr failed %ld for %d.%d\n",
				Status, SrcAddr.ata_Network, SrcAddr.ata_Node));
		return;
	}

	// Walk through the rtmp table building a tuple for each network.
	// Note: We may have to send multiple-packets. Each packet needs
	//		 to be allocated afresh. The completion routine will free
	//		 it up.
	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i];
			 pRte != NULL;
			 pRte = pRte->rte_Next)
		{
			if (AllocNewBuffDesc)
			{
				if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
									MAX_DGRAM_SIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
					break;
				Datagram = pBuffDesc->bd_CharBuffer;
				*ppBuffDesc = pBuffDesc;
				pBuffDesc->bd_Next = NULL;
				ppBuffDesc = &pBuffDesc->bd_Next;
				AllocNewBuffDesc = FALSE;

				// Build the static part of the rtmp data packet
				PUTSHORT2SHORT(Datagram+RTMP_SENDER_NW_OFF,
								pPortDesc->pd_ARouter.atn_Network);
				Datagram[RTMP_SENDER_IDLEN_OFF] = 8;
				Datagram[RTMP_SENDER_ID_OFF] = pPortDesc->pd_ARouter.atn_Node;

				// For non-extended network, we also need the version stamp.
				// For extended network, include a initial network range tuple
				// as part of the header
				if (EXT_NET(pPortDesc))
				{
					PUTSHORT2SHORT(Datagram + RTMP_RANGE_START_OFF,
								pPortDesc->pd_NetworkRange.anr_FirstNetwork);
					PUTSHORT2SHORT(Datagram + RTMP_RANGE_END_OFF,
								pPortDesc->pd_NetworkRange.anr_LastNetwork);
					Datagram[RTMP_TUPLE_TYPE_OFF] = RTMP_TUPLE_WITHRANGE;
					Datagram[RTMP_VERSION_OFF_EXT] = RTMP_VERSION;

					index = RTMP_VERSION_OFF_EXT + 1; // Beyond version
				}
				else
				{
					PUTSHORT2SHORT(Datagram + RTMP_SENDER_ID_OFF + 1, 0);
					Datagram[RTMP_VERSION_OFF_NE] = RTMP_VERSION;
					index = RTMP_VERSION_OFF_NE + 1; // Beyond version
				}
			}

			// See if we should skip the current tuple due to split horizon
			if (fSplitHorizon && (pRte->rte_NumHops != 0) &&
				(pPortDesc == pRte->rte_PortDesc))
				continue;

			// Skip the ports range since we already copied it as the
			// first tuple, but only if extended port
			if (EXT_NET(pPortDesc) &&
				(pPortDesc->pd_NetworkRange.anr_FirstNetwork ==
									pRte->rte_NwRange.anr_FirstNetwork) &&
				(pPortDesc->pd_NetworkRange.anr_FirstNetwork ==
									pRte->rte_NwRange.anr_FirstNetwork))
				continue;

			// Place the tuple in the packet
			PUTSHORT2SHORT(Datagram+index, pRte->rte_NwRange.anr_FirstNetwork);
			index += sizeof(SHORT);

			// Do 'notify neighbor' if our current state is bad
			if (pRte->rte_State >= BAD)
			{
				Datagram[index++] = RTMP_NUM_HOPS_MASK;
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("atalkRtmpSendRoutingData: Notifying neighbor of bad Rte - port %Z, Range %d.%d\n",
						&pRte->rte_PortDesc->pd_AdapterKey,
						pRte->rte_NwRange.anr_FirstNetwork,
						pRte->rte_NwRange.anr_LastNetwork));
			}
			else
			{
				Datagram[index++] = pRte->rte_NumHops;
			}

			// Send an extended tuple, if the network range isn't ONE or the
			// target port is an extended network.
			// JH - Changed this so that an extended tuple is sent IFF the range
			//		isn't ONE
#if EXT_TUPLES_FOR_NON_EXTENDED_RANGE
			if ((EXT_NET(pPortDesc)) &&
				(pRte->rte_NwRange.anr_FirstNetwork != pRte->rte_NwRange.anr_LastNetwork))
#else
			if (pRte->rte_NwRange.anr_FirstNetwork != pRte->rte_NwRange.anr_LastNetwork)
#endif
			{
				Datagram[index-1] |= RTMP_EXT_TUPLE_MASK;
				PUTSHORT2SHORT(Datagram+index, pRte->rte_NwRange.anr_LastNetwork);
				index += sizeof(SHORT);
				Datagram[index++] = RTMP_VERSION;
			}
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("atalkRtmpSendRoutingData: Port %Z, Net '%d:%d', Distance %d\n",
					&pPortDesc->pd_AdapterKey,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork,
					pRte->rte_NumHops));

			// Check if this datagram is full.
			if ((index + RTMP_EXT_TUPLE_SIZE) >= MAX_DGRAM_SIZE)
			{
				pBuffDesc->bd_Length = (SHORT)index;
				AllocNewBuffDesc = TRUE;
			}
		}
	}
	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

	// Close the current buffdesc
	if (!AllocNewBuffDesc)
	{
		pBuffDesc->bd_Length = (SHORT)index;
	}

	// We have a bunch of datagrams ready to be fired off. Make it so.
	SendInfo.sc_TransmitCompletion = atalkRtmpSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	for (pBuffDesc = pBuffDescStart;
		 pBuffDesc != NULL;
		 pBuffDesc = pBuffDescStart)
	{
		ATALK_ERROR	ErrorCode;

		pBuffDescStart = pBuffDesc->bd_Next;

		//	Reset next pointer to be null, length is already correctly set.
		pBuffDesc->bd_Next = NULL;
		ASSERT(pBuffDesc->bd_Length > 0);
		SendInfo.sc_Ctx1 = pBuffDesc;
		if (!ATALK_SUCCESS(ErrorCode = AtalkDdpSend(pDdpAddr,
													pDstAddr,
													DDPPROTO_RTMPRESPONSEORDATA,
													FALSE,
													pBuffDesc,
													NULL,
													0,
													NULL,
													&SendInfo)))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("atalkRtmpSendRoutingData: DdpSend failed %ld\n", ErrorCode));
			AtalkFreeBuffDesc(pBuffDesc);
		}
	}
	AtalkDdpDereference(pDdpAddr);
}


/***	atalkRtmpGetOrSetNetworkNumber
 *
 */
BOOLEAN
atalkRtmpGetOrSetNetworkNumber(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	USHORT				SuggestedNetwork
)
{
	int				i;
	ATALK_ERROR		ErrorCode;
	ATALK_ADDR		SrcAddr, DstAddr;
	PBUFFER_DESC	pBuffDesc;
	KIRQL			OldIrql;
	BOOLEAN			RetCode = TRUE;
	SEND_COMPL_INFO	SendInfo;

	// If we find the network number of the network, use that and ignore the
	// one passed in. Otherwise use the one passed in, unless it is UNKOWN (0)
	// in which case it is an error case. This is used only for non-extended
	// networks

	ASSERT (!EXT_NET(pPortDesc));

	SrcAddr.ata_Network = UNKNOWN_NETWORK;
	SrcAddr.ata_Node = pPortDesc->pd_RouterNode->an_NodeAddr.atn_Node;
	SrcAddr.ata_Socket = RTMP_SOCKET;

	DstAddr.ata_Network = UNKNOWN_NETWORK;
	DstAddr.ata_Node = ATALK_BROADCAST_NODE;
	DstAddr.ata_Socket = RTMP_SOCKET;

	// Send off a bunch of broadcasts and see if we get to know the network #
	KeClearEvent(&pPortDesc->pd_SeenRouterEvent);
	SendInfo.sc_TransmitCompletion = atalkRtmpSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;

	for (i = 0;
		 (i < RTMP_NUM_REQUESTS) && !(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY);
		 i++)
	{
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
								RTMP_REQ_DATAGRAM_SIZE,
								BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			RetCode = FALSE;
			break;
		}

		//	Set buffer/size
		pBuffDesc->bd_CharBuffer[0] = RTMP_REQUEST;
		AtalkSetSizeOfBuffDescData(pBuffDesc, RTMP_REQ_DATAGRAM_SIZE);

		SendInfo.sc_Ctx1 = pBuffDesc;
		ErrorCode = AtalkDdpTransmit(pPortDesc,
									 &SrcAddr,
									 &DstAddr,
									 DDPPROTO_RTMPREQUEST,
									 pBuffDesc,
									 NULL,
									 0,
									 0,
									 NULL,
									 NULL,
									 &SendInfo);
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("atalkRtmpGetOrSetNetworkNumber: DdpTransmit failed %ld\n", ErrorCode));
			AtalkFreeBuffDesc(pBuffDesc);
			RetCode = FALSE;
			break;
		}

		if (AtalkWaitTE(&pPortDesc->pd_SeenRouterEvent, RTMP_REQUEST_WAIT))
			break;
	}

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	// If we get an answer, we are done
	if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
	{
		if ((SuggestedNetwork != UNKNOWN_NETWORK) &&
			(pPortDesc->pd_NetworkRange.anr_FirstNetwork != SuggestedNetwork))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NETNUMBERCONFLICT,
							0,
							NULL,
							0);
		}
	}

	// If we did not get an answer, then we better have a good suggested
	// network passed in
	else if (SuggestedNetwork == UNKNOWN_NETWORK)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALID_NETRANGE,
						0,
						NULL,
						0);
		RetCode = FALSE;
	}

	else
	{
		pPortDesc->pd_NetworkRange.anr_FirstNetwork =
			pPortDesc->pd_NetworkRange.anr_LastNetwork = SuggestedNetwork;
	}

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	return RetCode;
}


/***	atalkRtmpComplete
 *
 */
VOID FASTCALL
atalkRtmpSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
)
{
	AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx1));
}


#if	DBG

PCHAR	atalkRteStates[] = { "Eh ?", "GOOD", "SUSPECT", "BAD", "UGLY" };

VOID
AtalkRtmpDumpTable(
	VOID
)
{
	int		i;
	PRTE	pRte;

	if (AtalkRoutingTable == NULL)
		return;

	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("RECENT ROUTE CACHE:\n"));
	for (i = 0; (AtalkRecentRoutes != NULL) && (i < NUM_RECENT_ROUTES); i ++)
	{
		if ((pRte = AtalkRecentRoutes[i]) != NULL)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("Port %Z Hops %d Range %4d.%4d Router %4d.%3d Flags %x Ref %2d %s\n",
					&pRte->rte_PortDesc->pd_AdapterKey,
					pRte->rte_NumHops,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork,
					pRte->rte_NextRouter.atn_Network,
					pRte->rte_NextRouter.atn_Node,
					pRte->rte_Flags,
					pRte->rte_RefCount,
					atalkRteStates[pRte->rte_State]));
		}
	}

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("ROUTINGTABLE:\n"));
	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i ++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pRte->rte_Next)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("Port %Z Hops %d Range %4d.%4d Router %4d.%3d Flags %x Ref %2d %s\n",
					&pRte->rte_PortDesc->pd_AdapterKey,
					pRte->rte_NumHops,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork,
					pRte->rte_NextRouter.atn_Network,
					pRte->rte_NextRouter.atn_Node,
					pRte->rte_Flags,
					pRte->rte_RefCount,
					atalkRteStates[pRte->rte_State]));
		}
	}

	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\router.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	router.c

Abstract:

	This module contains

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ROUTER

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_RTR, AtalkDdpRouteInPkt)
#endif

VOID
AtalkDdpRouteInPkt(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pSrc,
	IN	PATALK_ADDR			pDest,
	IN	BYTE				ProtoType,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	USHORT				HopCnt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ		pDdpAddr;
	PRTE				pRte;
	PPORT_DESCRIPTOR	pDestPort;
	PATALK_NODE			pRouterNode;
	ATALK_ADDR			actualDest;
	BUFFER_DESC			BufDesc;

	PBUFFER_DESC		pBufCopy	= NULL;
	USHORT				bufLen		= 0;
	BOOLEAN				delivered 	= FALSE;
	ATALK_ERROR			error 		= ATALK_NO_ERROR;
	SEND_COMPL_INFO	 	SendInfo;

	//	AtalkDdpRouteOutBufDesc() will have already passed us a
	//	copy if bcast is going to be TRUE, and AtalkDdpRouteInPkt() will
	//	never call AtalkDdpRouter() for a bcast packet. They will also set
	//	the completion routines to be different if they passed us a copy.
	//	Those will free up the buffer descriptors.
	//
	//	The completion routines are optional in the sense that the buffer
	//	will never be freed if they are not set!

	//	This algorithm is taken from the "Appletalk Phase 2 Specification".

	//	If the destination network number is within the range of the reception
	//	port's network range and the destination node number is broadcast, then
	//	we can drop the packet on the floor -- it is a network specific broadcast
	//	not for this router.  Note that we've already delivered the packet, and
	//	thus not gotten here, if it was really addressed to the network of any
	//	node owned by the reception port (in AtalkDdpPacketIn).
	//	Also:
	//	Try to find an entry in the routing table that contains the target
	//	network.  If not found, discard the packet.

	if (((WITHIN_NETWORK_RANGE(pDest->ata_Network,
							   &pPortDesc->pd_NetworkRange)) &&
		(pDest->ata_Node == ATALK_BROADCAST_NODE))			 ||
		((pRte = AtalkRtmpReferenceRte(pDest->ata_Network)) == NULL))
	{
		DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_FATAL,
				("AtalkDdpRouter: %lx RtmpRte/Not in ThisCableRange\n",
				pDest->ata_Network));
		return;
	}

	do
	{
		//	Get the port descriptor for this port number.
		pDestPort = pRte->rte_PortDesc;

		ASSERT(VALID_PORT(pDestPort));

		DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_WARN,
				("ROUTER: Routing pkt from port %Z.%lx to %Z.%lx\n",
				&pPortDesc->pd_AdapterKey, pSrc->ata_Network,
				&pDestPort->pd_AdapterKey, pDest->ata_Network));

        SendInfo.sc_TransmitCompletion = atalkDdpRouteComplete;
		SendInfo.sc_Ctx1 = pDestPort;
		// SendInfo.sc_Ctx3 = NULL;

		//	If the target network's hop count is non-zero, we really need to send
		//	the beast, so, just do it!
		if (pRte->rte_NumHops != 0)
		{
			//	Too many hops?
			error = ATALK_FAILURE;
			if (HopCnt < RTMP_MAX_HOPS)
			{
				//	We own the data. Call AtalkTransmitDdp() with the buffer descriptor.
				//	Make a copy! Caller will free our current packet.
				//	Alloc a buffer descriptor, copy data from packet to buffdesc.

				if ((pBufCopy = AtalkAllocBuffDesc(NULL,
												   PktLen,
												   (BD_FREE_BUFFER | BD_CHAR_BUFFER))) == NULL)
				{
					error = ATALK_RESR_MEM;
					break;
				}

				AtalkCopyBufferToBuffDesc(pPkt, PktLen, pBufCopy, 0);
				SendInfo.sc_Ctx2 = pBufCopy;

				error = AtalkDdpTransmit(pDestPort,
										 pSrc,
										 pDest,
										 ProtoType,
										 pBufCopy,
										 NULL,
										 0,
										 (USHORT)(HopCnt+1),
										 NULL,					//	pZoneMcastAddr,
										 &pRte->rte_NextRouter,
										 &SendInfo);
			}
			INTERLOCKED_INCREMENT_LONG_DPC(
					&pDestPort->pd_PortStats.prtst_NumPktRoutedOut,
					&AtalkStatsLock.SpinLock);
		
			break;
		}
		
		//	If the destination node is zero, the packet is really destined for the
		//	router's node on this port.
		if (pDest->ata_Node == ANY_ROUTER_NODE)
		{
			//	Grab the port lock and read the router node address.
			//	No need to reference, just ensure its not null.
			ACQUIRE_SPIN_LOCK_DPC(&pDestPort->pd_Lock);
			pRouterNode = pDestPort->pd_RouterNode;
			if (pRouterNode != NULL)
			{
				actualDest.ata_Network = pRouterNode->an_NodeAddr.atn_Network;
				actualDest.ata_Node    = pRouterNode->an_NodeAddr.atn_Node;

				//	Set the actual destination socket.
				actualDest.ata_Socket  = pDest->ata_Socket;
			}
			else
			{
				ASSERTMSG("AtalkDdpRouter: pRouter node is null!\n", 0);
				error = ATALK_DDP_NOTFOUND;
			}

			if (ATALK_SUCCESS(error))
			{
				AtalkDdpRefByAddrNode(pDestPort,
									  &actualDest,
									  pRouterNode,
									  &pDdpAddr,
									  &error);
			}

			RELEASE_SPIN_LOCK_DPC(&pDestPort->pd_Lock);

			if (ATALK_SUCCESS(error))
			{
				AtalkDdpInvokeHandler(pDestPort,
									  pDdpAddr,
									  pSrc,
									  pDest,		// Pass in the actual destination
									  ProtoType,
									  pPkt,
									  PktLen);

				//	Remove the reference on the socket
				AtalkDdpDereferenceDpc(pDdpAddr);
			}
			else
			{
				ASSERTMSG("AtalkDdpRouter: pSocket on router node is null!\n", 0);
			}

			break;
		}


		//	Okay, now walk through the nodes on the target port, looking for a
		//	home for this packet.
		BufDesc.bd_Next			= NULL;
		BufDesc.bd_Flags		= BD_CHAR_BUFFER;
		BufDesc.bd_Length		= PktLen;
		BufDesc.bd_CharBuffer	= pPkt;

		AtalkDdpOutBufToNodesOnPort(pDestPort,
									pSrc,
									pDest,
									ProtoType,
									&BufDesc,
									NULL,
									0,
									&delivered);
	
		error = ATALK_NO_ERROR;
		if (!delivered)
		{
			//	We need to deliver this packet to a local ports network.
			//	delivered would have been set true *EVEN* if broadcast
			//	were set, so we need to ensure it was delivered to a specific
			//	socket by making sure broadcast was not true.
			if (HopCnt < RTMP_MAX_HOPS)
			{
				//	We own the data. Call AtalkTransmitDdp() with the buffer descriptor.
				//	Make a copy! Caller will free our current packet.
				//	Alloc a buffer descriptor, copy data from packet to buffdesc.

				if ((pBufCopy = AtalkAllocBuffDesc(NULL,
												   PktLen,
												   (BD_FREE_BUFFER | BD_CHAR_BUFFER))) == NULL)
				{
					error = ATALK_RESR_MEM;
					break;
				}

				AtalkCopyBufferToBuffDesc(pPkt, PktLen, pBufCopy, 0);
				SendInfo.sc_Ctx2 = pBufCopy;

				error = AtalkDdpTransmit(pDestPort,
										 pSrc,
										 pDest,
										 ProtoType,
										 pBufCopy,
										 NULL,
										 0,
										 (USHORT)(HopCnt+1),
										 NULL,					//	pZoneMcastAddr
										 NULL,
										 &SendInfo);
				INTERLOCKED_INCREMENT_LONG_DPC(
						&pDestPort->pd_PortStats.prtst_NumPktRoutedOut,
						&AtalkStatsLock.SpinLock);
			
			}
			else error	= ATALK_FAILURE;

			break;
		}
		
	} while (FALSE);

	if ((error != ATALK_PENDING) && (pBufCopy != NULL))
	{
		//	Free the copied buffer descriptor if a copy was made.
		AtalkFreeBuffDesc(pBufCopy);
	}

	AtalkRtmpDereferenceRte(pRte, FALSE);				// Lock held?

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumPktRoutedIn,
		&AtalkStatsLock.SpinLock);
}




VOID FASTCALL
atalkDdpRouteComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)(pSendInfo->sc_Ctx1);
	PBUFFER_DESC		pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx2);

	if (pBuffDesc != NULL)
	{
		ASSERT(pBuffDesc->bd_Flags & (BD_CHAR_BUFFER | BD_FREE_BUFFER));
		AtalkFreeBuffDesc(pBuffDesc);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\rtmp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	rtmp.h

Abstract:

	This module contains information for the Routing Table Maintainance Protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_RTMP_
#define	_RTMP_

// RTMP specific data.

#define RTMP_REQUEST					1
#define RTMP_DATA_REQUEST				2
#define RTMP_ENTIRE_DATA_REQUEST		3

#define RTMP_REQ_DATAGRAM_SIZE			1
#define RTMP_DATA_MIN_SIZE_EXT			10
#define RTMP_DATA_MIN_SIZE_NON_EXT		7

#define RTMP_RESPONSE_MAX_SIZE			10

#define RTMP_VERSION				    (BYTE)0x82

#define RTMP_TUPLE_WITHRANGE			(BYTE)0x80
#define RTMP_TUPLE_WITHOUTRANGE		    (BYTE)0x00
#define RTMP_EXT_TUPLE_MASK		    	0x80
#define RTMP_MAX_HOPS			    	0x0F
#define RTMP_NUM_HOPS_MASK		    	0x1F

#define RTMP_EXT_TUPLE_SIZE		    	6

// When trying to find our network number on a non-extended port.

#define RTMP_REQUEST_WAIT				100		// MilliSeconds
#define RTMP_NUM_REQUESTS	    		30

// The actual RTMP routing table. Entries are hashed by target network number
// and contain the port number used to get to the target network, next bridge
// used to get to the target network, the number of hops to that network,
// and entry state (Good, Suspect, or Bad).  Note that with AppleTalk phase II,
// it takes two Validity timers to get from Suspect to Bad, so we let an entry
// go through a PrettyBad state (we won't send these guys when the Send timer goes off).

#define	GOOD				1
#define	SUSPECT				2
#define BAD					3
#define UGLY				4

extern	ATALK_SPIN_LOCK		AtalkRteLock;

#define	RTE_ZONELIST_VALID	0x01
#define	RTE_DELETE			0x80

#define	RTE_SIGNATURE		*(PULONG)"RTMP"
#if	DBG
#define	VALID_RTE(pRte)		((pRte != NULL) && (pRte->rte_Signature == RTE_SIGNATURE))
#else
#define	VALID_RTE(pRte)		(pRte != NULL)
#endif

typedef struct _RoutingTableEntry
{
#if	DBG
	ULONG					rte_Signature;
#endif
	struct _RoutingTableEntry *	rte_Next;
											// Hashed by first network number,
											// overflow buckets.
	PPORT_DESCRIPTOR		rte_PortDesc;	// Port used to access this network range
	LONG					rte_RefCount;	// Reference count
	BYTE					rte_Flags;
	BYTE					rte_State;		// State of the rtmp entry
	BYTE					rte_NumHops;	// Hops to get to net
	ATALK_NETWORKRANGE		rte_NwRange;	// The network range that we represent
	ATALK_NODEADDR 			rte_NextRouter;	// Node number of next router on
											// the way to this net range
	struct _ZONE_LIST	*	rte_ZoneList;	// Valid zones for this net
	ATALK_SPIN_LOCK			rte_Lock;
} RTE, *PRTE;

#define NUM_RTMP_HASH_BUCKETS		15
extern	PRTE *	AtalkRoutingTable;

// To decrease the odds of having to do a scan of the routing tables to
// find where to route a packet, we keep a cache of "recently used routes".
// This cache is checked before we use the "first network number" hash and
// before we resort of a full scan of the routing tables.  The size of this
// cache may want to be increased to get a proportional increase in
// "hit rate".

#define NUM_RECENT_ROUTES		63
extern	PRTE *	AtalkRecentRoutes;

// RTMP timer values:
#define RTMP_SEND_TIMER			100			// In 100ms units
#define RTMP_VALIDITY_TIMER		200			// In 100ms units
#define RTMP_AGING_TIMER		500			// In 100ms units

// RTMP Offsets into the Datagram
#define	RTMP_REQ_CMD_OFF		0
#define	RTMP_SENDER_NW_OFF		0
#define	RTMP_SENDER_IDLEN_OFF	2
#define	RTMP_SENDER_ID_OFF		3
#define	RTMP_VERSION_OFF_NE		6
#define	RTMP_RANGE_START_OFF	4
#define	RTMP_TUPLE_TYPE_OFF		6
#define	RTMP_RANGE_END_OFF		7
#define	RTMP_VERSION_OFF_EXT	9

ATALK_ERROR
AtalkRtmpInit(
	IN	BOOLEAN	Init
);

BOOLEAN
AtalkInitRtmpStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 	pPortDesc,
	IN	PATALK_NODEADDR		RouterNode
);

extern
VOID
AtalkRtmpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizePath,
	IN	PVOID				OptimizeCtx
);

extern
VOID
AtalkRtmpPacketInRouter(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT              PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizePath,
	IN	PVOID				OptimizeCtx
);

extern
PRTE
AtalkRtmpReferenceRte(
	IN	USHORT				Network
);

extern
BOOLEAN
atalkRtmpRemoveRte(
	IN	USHORT				Network
);

extern
VOID
AtalkRtmpDereferenceRte(
	IN	PRTE				pRte,
	IN	BOOLEAN				LockHeld
);

extern
BOOLEAN
atalkRtmpCreateRte(
	IN	ATALK_NETWORKRANGE	NwRange,
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		pNextRouter,
	IN	int					NumHops
);

LONG FASTCALL
AtalkRtmpAgingTimer(
	IN	PTIMERLIST			pContext,
	IN	BOOLEAN				TimerShuttingDown
);

VOID FASTCALL
AtalkRtmpKillPortRtes(
	IN	PPORT_DESCRIPTOR	pPortDesc
);

typedef	struct _RtmpSendDataHdr
{
	BYTE	rsd_RouterNetwork[2];
	BYTE	rsd_IdLength;
} *PRTMPSENDDATAHDR;

typedef	struct _RtmpTupleNonExt
{
	BYTE	rtne_Network[2];
	BYTE	rtne_RangenDist;
} *PRTMPTUPLE;

typedef	struct _RtmpTupleExt
{
	BYTE	rtne_NetworkStart[2];
	BYTE	rtne_RangenDist;
	BYTE	rtne_NetworkEnd[2];
	BYTE	rtne_Version;
} *PRTMPTUPLEEXT;

extern	TIMERLIST	atalkRtmpVTimer;

extern  BOOLEAN     atalkRtmpVdtTmrRunning;

LOCAL VOID
atalkRtmpSendRoutingData(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pDstAddr,
	IN	BOOLEAN				fSplitHorizon
);

LOCAL BOOLEAN
atalkRtmpGetOrSetNetworkNumber(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	USHORT				SuggestedNetwork
);

LOCAL LONG FASTCALL
atalkRtmpSendTimer(
	IN	PTIMERLIST			pContext,
	IN	BOOLEAN				TimerShuttingDown
);

LOCAL LONG FASTCALL
atalkRtmpValidityTimer(
	IN	PTIMERLIST			pContext,
	IN	BOOLEAN				TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkRtmpSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
);

#endif	// _RTMP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\zip.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	zip.h

Abstract:

	This module contains information for the Zone Information Protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ZIP_
#define	_ZIP_

#define MAX_ZONE_LENGTH			32

#define MAX_ZONES_PER_NET	    255	// AppleTalk phase 2

// ZIP specific data:

#define ZIP_QUERY						1
#define ZIP_REPLY						2
#define ZIP_TAKEDOWN					3
#define ZIP_BRINGUP						4
#define ZIP_GET_NETINFO					5
#define ZIP_NETINFO_REPLY				6
#define ZIP_NOTIFY						7
#define ZIP_EXT_REPLY					8

#define ZIP_ONEZONEQUERY_DDPSIZE		4
#define ZIP_GETZONELIST_DDPSIZE			8

// For GetZoneList and GetMyZone we're handling simple ATP packets:

#define ATP_ZIP_CMD_OFF				(ATP_USER_BYTES_OFF + 0)
#define ATP_ZIP_LAST_FLAG_OFF		(ATP_USER_BYTES_OFF + 0)
#define ATP_ZIP_START_INDEX_OFF		(ATP_USER_BYTES_OFF + 2)
#define ATP_ZIP_ZONE_CNT_OFF		(ATP_USER_BYTES_OFF + 2)
#define ATP_ZIP_FIRST_ZONE_OFF		(ATP_USER_BYTES_OFF + 4)

// Offsets into the datagram
#define	ZIP_CMD_OFF						0
#define	ZIP_NW_CNT_OFF					1
#define	ZIP_FLAGS_OFF					1
#define	ZIP_FIRST_NET_OFF				2	// Zip Query/Reply
#define	ZIP_FIRST_ZONELEN_OFF			4
#define	ZIP_LAST_NET_OFF				4	// Zip Query/Reply
#define	ZIP_FIRST_ZONENAME_OFF			5
#define	ZIP_REQ_ZONELEN_OFF				6	// Zip Query/Reply
#define	ZIP_REQ_ZONENAME_OFF			7	// Zip Query/Reply

#define	ZIP_CABLE_RANGE_START_OFF		2	// Phase II Values
#define	ZIP_CABLE_RANGE_END_OFF			4
#define	ZIP_ZONELEN_OFF					6
#define	ZIP_OLD_ZONELEN_OFF				6
#define	ZIP_ZONENAME_OFF				7
#define	ZIP_OLD_ZONENAME_OFF			7


// The three ZIP ATP commands:

#define ZIP_GET_MY_ZONE					7
#define ZIP_GET_ZONE_LIST				8
#define ZIP_GET_LOCAL_ZONES				9

// The ZIP NetInfoReply and Notify flags.

#define ZIP_ZONE_INVALID_FLAG			0x80
#define ZIP_USE_BROADCAST_FLAG			0x40
#define ZIP_ONLYONE_ZONE_FLAG			0x20

// When we're starting up (on extended networks) we send out a few NetGetInfo's
// to try to find out our zone name.  This seems to be what phase II Macintosh
// nodes do (timing wise):

#define ZIP_GET_NETINFO_WAIT			500		// In Ms
#define ZIP_NUM_GETNET_INFOS	  		3

// When nodes are doing either GetMyZone (non-extended only) or GetZoneList
// (both flavours) the request is sent to A-ROUTER a few times:

#define ZIP_GET_ZONEINFO_TIMER			10		// In 100ms units
#define ZIP_GET_ZONEINFO_RETRIES		3

// The ZIP specific timer values:

#define ZIP_QUERY_TIMER					100		// In 100ms units

// When we're looking for the zone list of a network, when starting the
// router, how many zip queries?  how fast?

#define ZIP_QUERY_WAIT					10		// In Ms
#define ZIP_NUM_QUERIES					30
#define	ZIP_NUM_RETRIES					10

#define ZONE_NAMES                      1
#define ZONE_NUM                        2


//	Zone structure
typedef	struct _ZONE
{
	struct _ZONE *		zn_Next;		// Next zone in the table
	struct _ZONE **		zn_Prev;		// Next zone in the table
	LONG				zn_RefCount;	// Reference count
	BYTE				zn_ZoneLen;		// Length of the zone name string
	BYTE				zn_Zone[1];		// Zone string, not null-terminated

} ZONE, *PZONE;

#define	ZONES_EQUAL(pZ1, pZ2)	AtalkFixedCompareCaseInsensitive(	\
									(pZ1)->zn_Zone,					\
									(pZ1)->zn_ZoneLen,				\
									(pZ2)->zn_Zone,					\
									(pZ1)->zn_ZoneLen)				\

typedef	struct _ZONE_LIST
{
	struct _ZONE_LIST *	zl_Next;		// Next zone on the list
	PZONE				zl_pZone;		// The zone itself
} ZONE_LIST, *PZONE_LIST;

#define	NUM_ZONES_HASH_BUCKETS	23
extern	ATALK_SPIN_LOCK			AtalkZoneLock;
extern	PZONE *					AtalkZonesTable;
extern	PZONE					AtalkDesiredZone;

extern
ATALK_ERROR
AtalkZipInit(
	IN	BOOLEAN	Init
);

extern
VOID
AtalkZipMulticastAddrForZone(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PBYTE					pZone,
	IN	BYTE					ZoneLen,
	IN	PBYTE					MulticastAddr
);

extern
BOOLEAN
AtalkZipGetNetworkInfoForNode(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PATALK_NODEADDR			pNode,
	IN	BOOLEAN					FindDefZone
);

extern
VOID
AtalkZipPacketIn(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PVOID					pHandlerCtx,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

extern
VOID
AtalkZipPacketInRouter(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PVOID					pHandlerCtx,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

BOOLEAN
AtalkInitZipStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 		pPortDesc,
	IN	PATALK_NODEADDR			RouterNode
);

extern
ATALK_ERROR
AtalkZipGetMyZone(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fDesired,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		struct _ActionReq *	pActReq
);

extern
ATALK_ERROR
AtalkZipGetZoneList(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fLocalZones,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		struct _ActionReq *	pActReq
);

extern
PZONE
AtalkZoneReferenceByName(
	IN	PBYTE					ZoneName,
	IN	BYTE					ZoneLen
);

extern
VOID
AtalkZoneReferenceByPtr(
	IN	PZONE					pZone
);

VOID
AtalkZoneDereference(
	IN	PZONE					pZone
);

extern
VOID
AtalkZoneFreeList(
	IN	PZONE_LIST				pZoneList
);

extern
ULONG
AtalkZoneNumOnList(
	IN	PZONE_LIST				ZoneList
);

extern
PZONE_LIST
AtalkZoneAddToList(
	IN	PZONE_LIST				ZoneList,
	IN	PBYTE					Zone,
	IN	BYTE					ZoneLen
);

extern
PZONE_LIST
AtalkZoneCopyList(
	IN	PZONE_LIST				ZoneList
);

extern
BOOLEAN
AtalkZoneNameOnList(
	IN	PBYTE					ZoneName,
	IN	BYTE					ZoneLen,
	IN	PZONE_LIST				pZoneList
);

extern
BOOLEAN
AtalkZoneOnList(
	IN	PZONE					pZone,
	IN	PZONE_LIST				pZoneList
);

extern	TIMERLIST				atalkZipQTimer;
extern  BOOLEAN                 atalkZipQryTmrRunning;

LOCAL VOID
atalkZipHandleNetInfo(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen
);

LOCAL VOID
atalkZipHandleReply(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen
);

LOCAL VOID
atalkZipHandleQuery(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen
);

LOCAL VOID
atalkZipHandleAtpRequest(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	BYTE					CmdType,
	IN	USHORT					TrId,
	IN	USHORT					StartIndex
);

LOCAL LONG FASTCALL
atalkZipQueryTimer(
	IN	PTIMERLIST				pContext,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL BOOLEAN
atalkZipGetZoneListForPort(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

// Control blocks from processing GetMyZone and GetZoneList calls
#define		ZCI_SIGNATURE			(*(PULONG)"ZCI")
#if	DBG
#define	VALID_ZCI(pZci)	(((pZci) != NULL) &&	\
						 ((pZci)->zci_Signature == ZCI_SIGNATURE))
#else
#define	VALID_ZCI(pZci)	((pZci) != NULL)
#endif
typedef struct _ZipCompletionInfo
{
#if	DBG
	ULONG						zci_Signature;
#endif
	LONG						zci_RefCount;
	PPORT_DESCRIPTOR			zci_pPortDesc;
	PDDP_ADDROBJ				zci_pDdpAddr;
	DDPAO_HANDLER				zci_Handler;
	PAMDL						zci_pAMdl;
	INT							zci_BufLen;
	PACTREQ						zci_pActReq;
	ATALK_ADDR					zci_Router;
	TIMERLIST					zci_Timer;
	USHORT						zci_NextZoneOff;
	SHORT						zci_ZoneCount;
	SHORT						zci_ExpirationCount;
	SHORT						zci_AtpRequestType;
	ATALK_ERROR					zci_FinalStatus;
	BYTE						zci_Datagram[ZIP_GETZONELIST_DDPSIZE];
	ATALK_SPIN_LOCK				zci_Lock;
} ZIPCOMPLETIONINFO, *PZIPCOMPLETIONINFO;

LOCAL VOID
atalkZipGetMyZoneReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

LOCAL VOID
atalkZipGetZoneListReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

LOCAL ATALK_ERROR
atalkZipSendPacket(
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					TimerEnqueue
);

LOCAL VOID
atalkZipDereferenceZci(
	IN	PZIPCOMPLETIONINFO		pZci
);

LOCAL LONG FASTCALL
atalkZipZoneInfoTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkZipSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo
);

#endif	// _ZIP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\winsock\nspatalk.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nspatalk.h

Abstract:

    Contains support for the winsock 1.x Name Space Provider for Appletalk.

Author:

    Sue Adams (suea)    10-Mar-1995

Revision History:

--*/
#define UNICODE

//
// MappingTriple structures and associated data for Appletalk
//
#define PMDL    PVOID       // AtalkTdi.h uses PMDL

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <tdi.h>
#include <winsock.h>
#include <atalkwsh.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsahelp.h>
#include <wshatalk.h>

#define DLL_VERSION        1
#define WSOCK_VER_REQD     0x0101

#define ZIP_NAME        L"ZIP"
#define RTMP_NAME       L"RTMP"
#define PAP_NAME        L"PAP"
#define ADSP_NAME       L"ADSP"

INT
NbpGetAddressByName(
    IN LPGUID      lpServiceType,
    IN LPWSTR      lpServiceName,
    IN LPDWORD     lpdwProtocols,
    IN DWORD       dwResolution,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPWSTR  lpAliasBuffer,
    IN OUT LPDWORD lpdwAliasBufferLength,
    IN HANDLE      hCancellationEvent
);


NTSTATUS
NbpSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
);

NTSTATUS
GetNameInNbpFormat(
        IN              LPGUID                          pType,
        IN              LPWSTR                          pObject,
        IN OUT  PWSH_NBP_NAME           pNbpName
);


NTSTATUS
NbpLookupAddress(
    IN          PWSH_NBP_NAME           pNbpLookupName,
        IN              DWORD                           nProt,
        IN OUT  LPVOID                          lpCsAddrBuffer,
    IN OUT      LPDWORD                         lpdwBufferLength,
    OUT         LPDWORD                         lpcAddress
);


DWORD
FillBufferWithCsAddr(
    IN PSOCKADDR_AT pAddress,
    IN DWORD        nProt,
    IN OUT LPVOID   lpCsAddrBuffer,
    IN OUT LPDWORD  lpdwBufferLength,
    OUT LPDWORD     pcAddress
);

DWORD
NbpRegDeregService(
        IN DWORD                        dwOperation,
        IN PWSH_NBP_NAME        pNbpName,
        IN PSOCKADDR_AT         pSockAddr
);



//
// Macros
//


#if DBG
#define DBGPRINT(Fmt)                                                                                   \
        {                                                                                                               \
                        DbgPrint("WSHATALK: ");                                                         \
                        DbgPrint Fmt;                                                                           \
                }

#define DBGBRK()                                                                                \
                {                                                                                                               \
                                DbgBreakPoint();                                                                \
                }
#else

#define DBGPRINT(Fmt)
#define DBGBRK()

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\winsock\nspatalk.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nspatalk.c

Abstract:

    Contains support for the winsock 1.x Name Space Provider for Appletalk.

Author:

    Sue Adams (suea)    10-Mar-1995

Revision History:

--*/

#include "nspatalk.h"

#define ADSP_BIT    0x0001  // Bitmask used internally to store the
#define PAP_BIT		0x0002	// protocols requested by the caller


INT
APIENTRY
NPLoadNameSpaces(
    IN OUT LPDWORD      lpdwVersion,
    IN OUT LPNS_ROUTINE nsrBuffer,
    IN OUT LPDWORD      lpdwBufferLength
    )
/*++

Routine Description:

    This routine returns name space info and functions supported in this
    dll.

Arguments:

    lpdwVersion - dll version

    nsrBuffer - on return, this will be filled with an array of
        NS_ROUTINE structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by nsrBuffer. On output, the minimum number of bytes
        to pass for the nsrBuffer to retrieve all the requested info

Return Value:

    The number of NS_ROUTINE structures returned, or SOCKET_ERROR (-1) if
    the nsrBuffer is too small. Use GetLastError() to retrieve the
    error code.

--*/
{
    DWORD err;
    DWORD dwLengthNeeded;

    *lpdwVersion = DLL_VERSION;

    //
    // Check to see if the buffer is large enough
    //
    dwLengthNeeded = sizeof(NS_ROUTINE) + 4 * sizeof(LPFN_NSPAPI);

    if (  ( *lpdwBufferLength < dwLengthNeeded )
       || ( nsrBuffer == NULL )
       )
    {
        *lpdwBufferLength = dwLengthNeeded;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return (DWORD) SOCKET_ERROR;
    }

    //
    // We only support 1 name space, so fill in the NS_ROUTINE.
    //
    nsrBuffer->dwFunctionCount = 3;
    nsrBuffer->alpfnFunctions = (LPFN_NSPAPI *)
        ((BYTE *) nsrBuffer + sizeof(NS_ROUTINE));
    (nsrBuffer->alpfnFunctions)[NSPAPI_GET_ADDRESS_BY_NAME] =
        (LPFN_NSPAPI) NbpGetAddressByName;
    (nsrBuffer->alpfnFunctions)[NSPAPI_GET_SERVICE] = NULL;
    (nsrBuffer->alpfnFunctions)[NSPAPI_SET_SERVICE] =
        (LPFN_NSPAPI) NbpSetService;
    (nsrBuffer->alpfnFunctions)[3] = NULL;

    nsrBuffer->dwNameSpace = NS_NBP;
    nsrBuffer->dwPriority  = NS_STANDARD_PRIORITY;

    return 1;  // number of namespaces
}


INT
NbpGetAddressByName(
    IN LPGUID      lpServiceType,
    IN LPWSTR      lpServiceName,
    IN LPDWORD     lpdwProtocols,
    IN DWORD       dwResolution,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPWSTR  lpAliasBuffer,
    IN OUT LPDWORD lpdwAliasBufferLength,
    IN HANDLE      hCancellationEvent
)
/*++

Routine Description:

    This routine returns address information about a specific service.

Arguments:

    lpServiceType - pointer to the GUID for the service type

    lpServiceName - unique string representing the service name.

    lpdwProtocols - a zero terminated array of protocol ids. This parameter
        is optional; if lpdwProtocols is NULL, information on all available
        Protocols is returned

    dwResolution - can be one of the following values:RES_SERVICE

    lpCsAddrBuffer - on return, will be filled with CSADDR_INFO structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by lpCsAddrBuffer. On output, the minimum number of bytes
        to pass for the lpCsAddrBuffer to retrieve all the requested info

    lpAliasBuffer - not used

    lpdwAliasBufferLength - not used

    hCancellationEvent - the event which signals us to cancel the request

Return Value:

    The number of CSADDR_INFO structures returned, or SOCKET_ERROR (-1) if
    the lpCsAddrBuffer is too small. Use GetLastError() to retrieve the
    error code.

--*/
{
    DWORD err;
	WSH_NBP_NAME NbpLookupName;
    DWORD cAddress = 0;   // Count of the number of address returned
                          // in lpCsAddrBuffer
    DWORD cProtocols = 0; // Count of the number of protocols contained
                          // in lpdwProtocols + 1 ( for zero terminate )
    DWORD nProt = ADSP_BIT | PAP_BIT;

    if (  ARGUMENT_PRESENT( lpdwAliasBufferLength )
       && ARGUMENT_PRESENT( lpAliasBuffer )
       )
    {
        if ( *lpdwAliasBufferLength >= sizeof(WCHAR) )
           *lpAliasBuffer = 0;
    }

//DebugBreak();

    //
    // Check for invalid parameters
    //
    if (  ( lpServiceType == NULL )
       || ( (lpServiceName == NULL) && (dwResolution != RES_SERVICE) )
       || ( lpdwBufferLength == NULL )
       )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return SOCKET_ERROR;
    }

    // The size of the user's buffer will dictate also how many
	// tuples can be returned from the NBP lookup in case they
    // are querying using wildcards.
	if ( *lpdwBufferLength < (sizeof(WSH_LOOKUP_NAME) + sizeof(WSH_NBP_TUPLE)) )
	{
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return SOCKET_ERROR;
	}

	//
    // If an array of protocol ids is passed in, check to see if
    // the ADSP or PAP protocol is requested. If not, return 0 since
    // we only support these 2.
    //
    if ( lpdwProtocols != NULL )
    {
        INT i = -1;

        nProt = 0;
        while ( lpdwProtocols[++i] != 0 )
        {
            if ( lpdwProtocols[i] == ATPROTO_ADSP )
                nProt |= ADSP_BIT;

            if ( lpdwProtocols[i] == ATPROTO_PAP )
                nProt |= PAP_BIT;
        }

        if ( nProt == 0 )
			return 0;  // No address found

    }


	//
	// If this is a service asking what local address to use when
	// bind()-ing its appletalk socket, return the generic Appletalk
	// socket address.
	//
    if ((dwResolution & RES_SERVICE) != 0)
    {
        err = FillBufferWithCsAddr( NULL,
                                    nProt,
                                    lpCsAddrBuffer,
                                    lpdwBufferLength,
                                    &cAddress );

        if ( err )
        {
            SetLastError( err );
            return SOCKET_ERROR;
        }

        return cAddress;
    }

    //
	// This is a client trying to do an NBP lookup on an Appletalk
	// named entity to find out what remote address to connect() to.
	//
	err = GetNameInNbpFormat(lpServiceType,
							 lpServiceName,
							 &NbpLookupName);
	if (err)
	{
		KdPrint(("GetNameInNbpFormat failed with error %d for name %ws\n", err, lpServiceName ));
		SetLastError(err);
		return SOCKET_ERROR;
	}

    err = NbpLookupAddress( &NbpLookupName,
							nProt,
							lpCsAddrBuffer,
							lpdwBufferLength,
							&cAddress );
#if DBG
   if ( err == NO_ERROR )
    {
        KdPrint(("NbpGetAddrByName:Successfully got %d address for %ws from NBP.\n",
                cAddress, lpServiceName ));
    }
    else
    {
        KdPrint(("NbpGetAddrByName:Failed with err %d when getting address for %ws from NBP.\n", err, lpServiceName ));
    }
#endif

    if ( err )
    {
        SetLastError( err );
        return SOCKET_ERROR;
    }

    return cAddress;

}


NTSTATUS
GetNameInNbpFormat(
	IN		LPGUID				pServiceType,
	IN		LPWSTR				pServiceName,
	IN OUT 	PWSH_NBP_NAME		pNbpName
)
/*++

	Routine description:

		Convert pServiceType and pServiceName to system ANSI strings in
		the pLookupName structure so they can be used to do NBP lookup.

    Arguments:


	Return value:
	
--*/
{
	INT		err;
	WCHAR	wtypeBuf[MAX_ENTITY + 1];
	CHAR	entityBuf[(MAX_ENTITY + 1) * 2];	// potentially all multibyte
	PWCHAR  pColon, pAtSign, pType = wtypeBuf, pObject = pServiceName, pZone = L"*";

	// Parse the service name for "object:type@zone" form.  If we find a
	// ':' there must also be a '@' (and vice-versa).
	// If there is a type in the servicename string, we will still convert
	// the LPGUID to a string.  If the types don't match return an error.
	// So, we will accept the following forms for the service name:
	// object OR object:type@zone.  If just object is given, then the zone
	// used will be the default zone "*". Wildcards are acceptible for
	// NBP Lookup, but not for NBP (De)Register. No checking is done for that.
	//
	pColon  = wcschr(pServiceName, L':');
	pAtSign = wcschr(pServiceName, L'@');

	if ( ((pColon != NULL) && (pAtSign == NULL)) ||
		 ((pAtSign != NULL) && (pColon == NULL)) ||
		 (pColon > pAtSign) )
	{
		return(ERROR_INVALID_PARAMETER);
	}

	//
	// By default we only use our own local zone
	//
	if (pAtSign != NULL)
	{
		pZone = pAtSign + 1;
		if ((wcslen(pZone) == 0) ||
			(wcslen(pZone) > MAX_ENTITY))
		{
			return ERROR_INVALID_PARAMETER;
		}
	}
	if (WideCharToMultiByte(CP_ACP,
							0,
							pZone,
							-1,				// says that wchar string is null terminated
							entityBuf,
							sizeof(entityBuf),
							NULL,
							NULL) == 0)
	{
		DBGPRINT(("GetNameInNbpFormat FAILED wctomb %ws\n", pZone));

		return GetLastError();
	}
	pNbpName->ZoneNameLen = strlen( entityBuf );
    memcpy( pNbpName->ZoneName,
			entityBuf,
			pNbpName->ZoneNameLen );

	if (pAtSign != NULL)
	{
		// change the @ to a null so the type will be null terminated
		*pAtSign = 0;
	}

	//
	// Convert the Type string
	//

	err = GetNameByType(pServiceType, wtypeBuf, sizeof(wtypeBuf));
	if (err != NO_ERROR)
	{
		// Appletalk type can be 32 chars max, so if this
		// fails with buffer too small error it couldn't be
		// used on appletalk anyway
		return err;
	}

	// If there was a type name in the ServiceName, then it better match
	// what the LPGUID resolved to.
	if (pColon != NULL)
	{
		pType = pColon + 1;
		if ((wcslen(pType) == 0) ||
//			(wcscmp(pType, wtypeBuf) != 0) ||
			(wcslen(pType) > MAX_ENTITY))
		{
			return ERROR_INVALID_PARAMETER;
		}
	}

	if (WideCharToMultiByte(CP_ACP,
							0,
							pType,
							-1,				// says that wchar string is null terminated
							entityBuf,
							sizeof(entityBuf),
							NULL,
							NULL) == 0)
	{
		DBGPRINT(("GetNameInNbpFormat FAILED wctomb %ws\n", pType));

		return GetLastError();
	}
	pNbpName->TypeNameLen = strlen( entityBuf );
	memcpy( pNbpName->TypeName,
			entityBuf,
			pNbpName->TypeNameLen );

    if (pColon != NULL)
	{
		// change the colon to a null so the object will be null terminated
		*pColon = 0;
	}

	//
	// Convert the Object string
	//
	if ((wcslen(pObject) == 0) ||
		(wcslen(pObject) > MAX_ENTITY))
	{
		return ERROR_INVALID_PARAMETER;
	}
	if (WideCharToMultiByte(CP_ACP,
							0,
							pServiceName,
							-1,				// says that wchar string is null terminated
							entityBuf,
							sizeof(entityBuf),
							NULL,
							NULL) == 0)
	{
		DBGPRINT(("GetNameInNbpFormat FAILED wctomb %ws\n", pServiceName));

		return GetLastError();
	}
	pNbpName->ObjectNameLen = strlen( entityBuf );
    memcpy( pNbpName->ObjectName,
			entityBuf,
			pNbpName->ObjectNameLen );


	return STATUS_SUCCESS;

} // GetNameInNbpFormat

NTSTATUS
NbpLookupAddress(
    IN		PWSH_NBP_NAME 		pNbpLookupName,
	IN		DWORD				nProt,
	IN OUT	LPVOID				lpCsAddrBuffer,
    IN OUT	LPDWORD				lpdwBufferLength,
    OUT 	LPDWORD				lpcAddress
)
/*++

Routine Description:

    This routine uses NBP requests to find the address of the given service
    name/type.

Arguments:

	pNbpLookupName - NBP name to lookup

	nProt - ADSP_BIT | PAP_BIT

    lpCsAddrBuffer - on return, will be filled with CSADDR_INFO structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by lpCsAddrBuffer. On output, the minimum number of bytes
        to pass for the lpCsAddrBuffer to retrieve all the requested info

    hCancellationEvent - the event which signals us to cancel the request???

    lpcAddress - on output, the number of CSADDR_INFO structures returned

Return Value:

    Win32 error code.

--*/
{
    DWORD err = NO_ERROR;
    NTSTATUS ntstatus;

	WSADATA wsaData;
    SOCKET socketNbp;
    SOCKADDR_AT socketAddr = {AF_APPLETALK, 0, 0, 0};
	PWSH_LOOKUP_NAME   pWshLookupName;
	PWSH_ATALK_ADDRESS pWshATAddr;
	PBYTE	pTmp = lpCsAddrBuffer;
	DWORD	templen = *lpdwBufferLength;
	DWORD	bufsize;
	PBYTE	buf = NULL;

	int i;

    *lpcAddress = 0;

    //
    // Initialize the socket interface
    //
    err = WSAStartup( WSOCK_VER_REQD, &wsaData );
    if ( err )
    {
        return err;
    }

    //
    // Open an Appletalk datagram socket
	// ISSUE: should we use DDPPROTO_NBP, or just a random
	// dynamic DDP socket? Or an ADSP socket since we know
	// that works and has been tested...Does it really matter
	// since this only defines what devicename will be opened
	// in the appletalk driver i.e. \\device\\atalkddp\2 .
    //
    socketNbp = socket( AF_APPLETALK, SOCK_DGRAM, DDPPROTO_NBP);
    if ( socketNbp == INVALID_SOCKET )
    {
        err = WSAGetLastError();
        (VOID) WSACleanup();
        return err;
    }

	do
	{
		//
		// Bind the socket (this does not actually go thru
		// the WSHAtalk helper dll, it goes thru AFD which
		// Ioctls appletalk directly.  The node and net values
		// are ignored, and socket 0 means give me a dynamic
		// socket number)
		//
		if ( bind( socketNbp,
				   (PSOCKADDR) &socketAddr,
				   sizeof( SOCKADDR_AT)) == SOCKET_ERROR )
		{
			err = WSAGetLastError();
			break;
		}

		//
		// Determine how many CSADDR_INFO structures could fit
		// into this buffer, then allocate a buffer to use for
		// the NBP lookup that can hold this many returned tuples
		//

		bufsize = sizeof(WSH_LOOKUP_NAME) +
			( (*lpdwBufferLength / (sizeof(CSADDR_INFO) + (2*sizeof(SOCKADDR_AT)))) *
				sizeof(WSH_NBP_TUPLE) );

        if ((buf = LocalAlloc(LMEM_ZEROINIT, bufsize)) == NULL)
		{
			err = GetLastError();
			break;
		}

		// copy the NBP name to look for into the buffer
		pWshLookupName = (PWSH_LOOKUP_NAME)buf;
		pWshLookupName->LookupTuple.NbpName = *pNbpLookupName;

		//
		// Send the Nbp lookup request
		//
		if (getsockopt( socketNbp,
			 		    SOL_APPLETALK,
						SO_LOOKUP_NAME,
						buf,
						&bufsize) != NO_ERROR)
		{
			err = WSAGetLastError();
			if (err == WSAENOBUFS)
			{
	            // this assumes that getsockopt will	NOT
				// put the required number of bytes into the
				// bufsize parameter on error
				*lpdwBufferLength = 2 * *lpdwBufferLength;
			}
			break;
		}

		if (pWshLookupName->NoTuples == 0)
		{
			// didn't find anything matching this NBP entity name
			*lpdwBufferLength = 0;
			break;
		}

		// point to the returned tuples
		pWshATAddr = (PWSH_ATALK_ADDRESS)(pWshLookupName + 1);
		for ( i = 0; i < (INT)pWshLookupName->NoTuples; i++ )
		{
			DWORD cAddr, bytesWritten;

			socketAddr.sat_net    = pWshATAddr->Network;
			socketAddr.sat_node   = pWshATAddr->Node;
			socketAddr.sat_socket = pWshATAddr->Socket;
			err = FillBufferWithCsAddr( &socketAddr,
										nProt,
										// USE LOCALS TO KEEP TRACK OF BUF POSITION AND COUNT LEFT
										pTmp,
										&templen,
										&cAddr);
	
			if (err != NO_ERROR)
			{
				// Fill in how many bytes the buffer should have been to
				// hold all the returned addresses
				*lpdwBufferLength = templen * pWshLookupName->NoTuples;
				break; // from for and then from while
			}
			else
			{
				pTmp += sizeof(CSADDR_INFO) * cAddr;
				templen -= (sizeof(CSADDR_INFO) + (2 * sizeof(SOCKADDR_AT))) * cAddr;
				*lpcAddress += cAddr;	// running count of CSADDR_INFOs in buffer
				(PWSH_NBP_TUPLE)pWshATAddr ++; // get next NBP tuple
			}
		}
	} while (FALSE);

    //
    // Clean up the socket interface
    //

	if (buf != NULL)
	{
		LocalFree(buf);
	}
    closesocket( socketNbp );
    (VOID) WSACleanup();

    return err;
}


DWORD
FillBufferWithCsAddr(
    IN PSOCKADDR_AT pAddress,  		// if NULL, then return generic appletalk socket address for RemoteAddr
    IN DWORD        nProt,
    IN OUT LPVOID   lpCsAddrBuffer,
    IN OUT LPDWORD  lpdwBufferLength,
    OUT LPDWORD     pcAddress		
)
{
    DWORD nAddrCount = 0;
    CSADDR_INFO  *pCsAddr;
    SOCKADDR_AT *pAddrLocal, *pAddrRemote;
    DWORD i;
    LPBYTE pBuffer;

    if ( nProt & ADSP_BIT )
        nAddrCount ++;

    if ( nProt & PAP_BIT )
        nAddrCount++;


    if ( *lpdwBufferLength <
         nAddrCount * ( sizeof( CSADDR_INFO) + 2*sizeof( SOCKADDR_AT)))
    {
        *lpdwBufferLength = nAddrCount *
                            ( sizeof( CSADDR_INFO) + 2*sizeof( SOCKADDR_AT));
        return ERROR_INSUFFICIENT_BUFFER;
    }


    pBuffer = ((LPBYTE) lpCsAddrBuffer) + *lpdwBufferLength -
			(2*sizeof( SOCKADDR_AT) * nAddrCount);

    for ( i = 0, pCsAddr = (CSADDR_INFO *)lpCsAddrBuffer;
          (i < nAddrCount) && ( nProt != 0 );
          i++, pCsAddr++ )
    {
		if ( nProt & ADSP_BIT )
        {
			pCsAddr->iSocketType = SOCK_RDM;
            pCsAddr->iProtocol   = ATPROTO_ADSP;
            nProt &= ~ADSP_BIT;
        }
        else if ( nProt & PAP_BIT )
        {
            pCsAddr->iSocketType = SOCK_RDM;
            pCsAddr->iProtocol   = ATPROTO_PAP;
            nProt &= ~PAP_BIT;
        }
        else
        {
            break;
        }

        pCsAddr->LocalAddr.iSockaddrLength  = sizeof( SOCKADDR_AT );
        pCsAddr->RemoteAddr.iSockaddrLength = sizeof( SOCKADDR_AT );
        pCsAddr->LocalAddr.lpSockaddr = (LPSOCKADDR) pBuffer;
        pCsAddr->RemoteAddr.lpSockaddr =
            (LPSOCKADDR) ( pBuffer + sizeof(SOCKADDR_AT));
        pBuffer += 2 * sizeof( SOCKADDR_AT );

        pAddrLocal  = (SOCKADDR_AT *) pCsAddr->LocalAddr.lpSockaddr;
        pAddrRemote = (SOCKADDR_AT *) pCsAddr->RemoteAddr.lpSockaddr;

        pAddrLocal->sat_family  = AF_APPLETALK;
        pAddrRemote->sat_family = AF_APPLETALK;

        //
        // The default local sockaddr for ADSP and PAP is
        // sa_family = AF_APPLETALK and all other bytes = 0.
        //

        pAddrLocal->sat_net    = 0;
		pAddrLocal->sat_node   = 0;
		pAddrLocal->sat_socket = 0;

        //
        // If pAddress is NULL, i.e. we are doing RES_SERVICE,
        // just make all bytes in remote address zero.
        //

        if ( pAddress == NULL )
        {
			pAddrRemote->sat_net    = 0;
			pAddrRemote->sat_node   = 0;
			pAddrRemote->sat_socket = 0;
		}
        else
        {
			pAddrRemote->sat_net    = pAddress->sat_net;
			pAddrRemote->sat_node   = pAddress->sat_node;
			pAddrRemote->sat_socket = pAddress->sat_socket;
        }
    }

    *pcAddress = nAddrCount;
    return NO_ERROR;
} // FillBufferWithCSAddr


NTSTATUS
NbpSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
)
/*++

Routine Description:

    This routine registers or deregisters the given service type/name on NBP.

Arguments:

    dwOperation - Either SERVICE_REGISTER or SERVICE_DEREGISTER

    dwFlags - ignored

	fUnicodeBlob - ignored

    lpServiceInfo - Pointer to a SERVICE_INFO structure containing all info
                    about the service.

Return Value:

    Win32 error code.

--*/
{
    NTSTATUS		err = STATUS_SUCCESS;
	SOCKADDR_AT		sockAddr;
	WSH_NBP_NAME	nbpName;
    DWORD 			i;
    INT 			nNBP = -1;

    UNREFERENCED_PARAMETER( dwFlags );
    UNREFERENCED_PARAMETER( fUnicodeBlob );

	DBGPRINT(("NbpSetService entered...\n"));

	//
    // Check for invalid parameters
    //
    if (  ( lpServiceInfo == NULL )
       || ( lpServiceInfo->lpServiceType == NULL )
       || ( lpServiceInfo->lpServiceName == NULL )  )
    {
        return ERROR_INVALID_PARAMETER;
    }

	if ( lpServiceInfo->lpServiceAddress == NULL )
        return ERROR_INCORRECT_ADDRESS;

	switch (dwOperation)
    {
		case SERVICE_REGISTER:
		case SERVICE_DEREGISTER:
		{
			//
			// Check to see if the service address array contains NBP address,
			// we will only use the first NBP address contained in the array.
			//
		
			for ( i = 0; i < lpServiceInfo->lpServiceAddress->dwAddressCount; i++)
			{
				if ( lpServiceInfo->lpServiceAddress->Addresses[i].dwAddressType == AF_APPLETALK )
				{
					sockAddr = *(PSOCKADDR_AT)(lpServiceInfo->lpServiceAddress->Addresses[i].lpAddress);
					nNBP = (INT) i;
					break;
				}
			}
		
			//
			// If we cannot find a atalk address in the user's array, return error
			//
			if ( nNBP == -1 )
			{
				DBGPRINT(("NbpSetService: no Appletalk addresses in lpServiceInfo!\n"));
				return ERROR_INCORRECT_ADDRESS;
			}

			//
			// Convert the service type and name into NBP form
			//
			err = GetNameInNbpFormat(lpServiceInfo->lpServiceType,
									 lpServiceInfo->lpServiceName,
									 &nbpName);
			if (err != NO_ERROR)
			{
				break;
			}

			err = NbpRegDeregService(dwOperation, &nbpName, &sockAddr);
			break;
		}
        case SERVICE_FLUSH:
        case SERVICE_ADD_TYPE:
        case SERVICE_DELETE_TYPE:
            //
            // This is a no-op in our provider, so just return success
            //
            return NO_ERROR;

        default:
            //
            // We can probably say all other operations which we have no
            // knowledge of are ignored by us. So, just return success.
            //
            return NO_ERROR;
    }

	return err;
}


DWORD
NbpRegDeregService(
	IN DWORD			dwOperation,
	IN PWSH_NBP_NAME	pNbpName,
	IN PSOCKADDR_AT		pSockAddr
)
/*++

Routine Description:

    This routine registers or deregisters the given service on NBP.

Arguments:

	dwOperation - either SERVICE_REGISTER or SERVICE_DEREGISTER

	pNbpName - points to NBP name to register (zone should be "*")

	pSockAddr - socket address on which to register name


Return Value:

    Win32 error.

--*/
{
	int							status;
	BYTE						EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
										TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
										sizeof(TA_APPLETALK_ADDRESS)];
	PFILE_FULL_EA_INFORMATION	pEaBuf = (PFILE_FULL_EA_INFORMATION)EaBuffer;
	TA_APPLETALK_ADDRESS		Ta;
	OBJECT_ATTRIBUTES			ObjAttr;
	UNICODE_STRING				DeviceName;
	IO_STATUS_BLOCK				IoStsBlk;

	NBP_TUPLE					nbpTuple;
	SOCKET						bogusSocket = 0;
	HANDLE						AtalkAddressHandle = NULL, eventHandle = NULL;
	PTDI_ACTION_HEADER			tdiAction;
	ULONG						tdiActionLength;
	BOOLEAN						freeTdiAction = FALSE, closeEventHandle = FALSE;
	PNBP_REGDEREG_ACTION		nbpAction;
	PVOID 						completionApc = NULL;
	PVOID 						apcContext = NULL;

	DBGPRINT(("NbpRegDeregService entered...\n"));
DebugBreak();	

	// Dosn't matter what protocol or socket we open, we just want a
	// device handle into the stack.
	RtlInitUnicodeString(&DeviceName, WSH_ATALK_ADSPRDM);

	InitializeObjectAttributes(&ObjAttr, &DeviceName, 0, NULL, NULL);

	// Initialize the EA Buffer
	pEaBuf->NextEntryOffset = 0;
	pEaBuf->Flags = 0;
	pEaBuf->EaValueLength = sizeof(TA_APPLETALK_ADDRESS);
	pEaBuf->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
	RtlCopyMemory(pEaBuf->EaName,TdiTransportAddress,
											TDI_TRANSPORT_ADDRESS_LENGTH + 1);
	Ta.TAAddressCount = 1;
	Ta.Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;
	Ta.Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);

	// Open dynamic socket - note we will be using up one extra socket for the
	// duration we have the device handle open in this routine.
	Ta.Address[0].Address[0].Socket = 0;
	Ta.Address[0].Address[0].Network = 0;
	Ta.Address[0].Address[0].Node = 0;

	RtlCopyMemory(&pEaBuf->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1], &Ta, sizeof(Ta));

	// Open a handle to appletalk stack DDP device
	status = NtCreateFile(
					&AtalkAddressHandle,
					GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
					&ObjAttr,
					&IoStsBlk,
					NULL,								// Don't Care
					0,									// Don't Care
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					FILE_CREATE,
					0,
					&EaBuffer,
					sizeof(EaBuffer));

	if (!NT_SUCCESS(status))
	{
		DBGPRINT(("NbpRegDeregService: NtCreateFile failed (0x%x)\n", status));
		return WSHNtStatusToWinsockErr(status);
	}

	do
	{
		status = NtCreateEvent(
					 &eventHandle,
					 EVENT_ALL_ACCESS,
					 NULL,
					 SynchronizationEvent,
					 FALSE
					 );
	
		if ( !NT_SUCCESS(status) )
		{
			DBGPRINT(("NbpRegDeregService: Create event failed (%d)\n", status));
			break;
		}
		else
			closeEventHandle = TRUE;

		tdiActionLength = sizeof(NBP_REGDEREG_ACTION);
		tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
		if ( tdiAction == NULL )
		{
			status = STATUS_NO_MEMORY;
			DBGPRINT(("NbpRegDeregService: Could not allocate tdiAction\n"));
			break;
		}
		else
			freeTdiAction = TRUE;

		tdiAction->TransportId = MATK;

		tdiAction->ActionCode = (dwOperation == SERVICE_REGISTER) ?
									COMMON_ACTION_NBPREGISTER_BY_ADDR :
									COMMON_ACTION_NBPREMOVE_BY_ADDR;

		nbpAction = (PNBP_REGDEREG_ACTION)tdiAction;

		//
		// Copy the nbp tuple info to the proper place
		//

		nbpAction->Params.RegisterTuple.Address.Network = pSockAddr->sat_net;
		nbpAction->Params.RegisterTuple.Address.Node    = pSockAddr->sat_node;
		nbpAction->Params.RegisterTuple.Address.Socket  = pSockAddr->sat_socket;
		nbpAction->Params.RegisterTuple.Enumerator = 0; 	
		nbpAction->Params.RegisterTuple.NbpName = *((PNBP_NAME)pNbpName);

		//
		// Convert the tuple to MAC code page
		//

		if (!WshNbpNameToMacCodePage(
				(PWSH_NBP_NAME)&nbpAction->Params.RegisterTuple.NbpName))
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		status = NtDeviceIoControlFile(
					 AtalkAddressHandle,
					 eventHandle,
					 completionApc,
					 apcContext,
					 &IoStsBlk,
					 IOCTL_TDI_ACTION,
					 NULL,				 // Input buffer
					 0,					 // Length of input buffer
					 tdiAction,
					 tdiActionLength
					 );
	
		if ( status == STATUS_PENDING )
		{
			status = NtWaitForSingleObject( eventHandle, FALSE, NULL );
			ASSERT( NT_SUCCESS(status) );
			status = IoStsBlk.Status;
		}
	
        if (status != NO_ERROR)
		{
			DBGPRINT(("NbpRegDeregService: DevIoctl SO_(DE)REGISTER_NAME failed (0x%x)\n", status));
		}


	} while (0);

	if (closeEventHandle)
		NtClose(eventHandle);

	if (freeTdiAction)
		RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );

	NtClose(AtalkAddressHandle);

	return WSHNtStatusToWinsockErr(status);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\v42bis.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	This module implements the v42bis compression/decompression routines
    used by ARAP (adapted from fcr's code)

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#include "atalk.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, v42bis_init_dictionary)
#pragma alloc_text(PAGE_ARAP, v42bis_init)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_codeword)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_codeword_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_codeword)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_codeword_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_value)
#pragma alloc_text(PAGE_ARAP, v42bis_apply_compression_test)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_buffer)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_transition_to_compressed)
#pragma alloc_text(PAGE_ARAP, v42bis_transition_to_transparent)
#pragma alloc_text(PAGE_ARAP, v42bis_signal_reset)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_match)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_buffer)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_init_buffer)
#pragma alloc_text(PAGE_ARAP, v42bis_connection_init)
#pragma alloc_text(PAGE_ARAP, v42bis_connection_init_buffers)
#pragma alloc_text(PAGE_ARAP, v42bis_connection_init_push)
#pragma alloc_text(PAGE_ARAP, v42bisInit)
#pragma alloc_text(PAGE_ARAP, v42bisCompress)
#pragma alloc_text(PAGE_ARAP, v42bisDecompress)
#endif

//
// bitmaps[# of bits]
//
USHORT bit_masks[16] =
{
    0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f,
    0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff
};


static PCHAR
show_char(
    IN  UCHAR ch
)
{
    static char dec[20];

    if (' ' <= ch && ch <= '~')
    {
	    dec[0] = ch;
	    dec[1] = 0;
	    return dec;
    }

    // BUGV42BUG: do we need this?
    //sprintf(dec, "0x%02x", ch);
    return dec;
}

/*
  decode_xid_params()

  decode compression negotiation packet as per V42bis spec.

  note: this is not used (there is code in the mnp LR routines to do
  this), but is included for completeness.
*/


/*
  v42bis_push()

  perform PUSH on output stream.  accumlated bytes are pushed
  out.
*/


/*
  v42bis_init_dictionary()

  init dictionary in accordance with section 6.2 and 7.2

  this is used at init time and in response to a CCW_RESET
*/

DWORD
v42bis_init_dictionary(state)
v42bis_t *state;
{
    int i;
    node_t *n;

    /* initialize dictionary tree */
    for (i = 0, n = state->dictionary; i < state->n2; i++, n++)
    {
    	n->byte = 0;
	    n->parent = 0;
	    n->node = 0;
	    n->leaf = 0;
    }

    /* section 6.2 */
    state->c1 = N5;	/* next codeword */
    state->c2 = N3 + 1;	/* codeword size (bits) */
    state->c3 = N4 * 2;	/* threshold */

    state->transparent = TRUE;
    state->escape = 0;
    state->escaped = FALSE;
    state->exception_next = FALSE;

    /* initialize searching  */
    state->last_match = 0;
    state->last_new = 0;
    state->string_size = 0;

	return ARAPERR_NO_ERROR;
}

/*
  v42bis_init()

  implements C-INIT semantics
*/

DWORD
v42bis_init(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    V_FLOW(("v42bis_init()"));

    /* our defaults */
    state->n1 = LOG2_CODES;		/* max codeword size (bits) */
    state->n2 = CONN(state)->neg_p1;	/* total # of codewords */
    state->n7 = CONN(state)->neg_p2;	/* max string length */

    /* init dictionary */
    v42bis_init_dictionary(state);

    /* initialize encode/decode */
    state->bits_acc = 0;
    state->bits_used = 0;
    state->word_size = 8*sizeof(unsigned short);

    state->bits_waiting = 0;
    state->bits_remaining = 0;

	return ARAPERR_NO_ERROR;
}

#ifdef DEBUG_ENABLED
/*
  itobits()

  turn an integer bitfield into an ascii representation (i.e. "01010101")
*/

char *
itobits(word, bits)
USHORT word;
int bits;
{
    static char buf[33];
    int i;

    if (bits > 32) bits = 32;

    for (i = bits-1; i >= 0; i--)
	buf[(bits-1)-i] = word & (1 << i) ? '1' : '0';

    buf[bits] = 0;
    return buf;
}
#endif



/*
  v42bis_decode_codeword()

  decode n-bit codewords from a bytesteam.
*/

USHORT
v42bis_decode_codeword(state, value)
v42bis_t *state;
UCHAR value;
{
    register UCHAR bits_free, bits_new, bits_residual;
    register USHORT codeword;

    V_FLOW(("v42bis_decode_codeword(%x) c2=%d", value, state->c2));

    /* simple case */
    if (state->c2 == 8 || state->transparent)
	return value;

    /* not-so-simple case */
    D_DEBUG(("before: waiting %06x, bits_remaining %d",
	     state->bits_waiting, state->bits_remaining));

    /* add in these 8 bits */
    state->bits_waiting |= ((DWORD)value) << state->bits_remaining;
    state->bits_remaining += 8;

    /* do we have a codeword ? */
    if (state->bits_remaining >= state->c2) {
	D_DEBUG(("input %04x %s",
		 state->bits_waiting & bit_masks[state->c2],
		 itobits(state->bits_waiting & bit_masks[state->c2],
			 state->c2)));

	codeword = (USHORT)(state->bits_waiting & bit_masks[state->c2]);

	state->bits_waiting >>= state->c2;
	state->bits_remaining -= state->c2;

	D_DEBUG(("after: waiting %04x, bits_remaining %d (data)",
		 state->bits_waiting, state->bits_remaining));

	return codeword;
    }

    D_DEBUG(("after: waiting %04x, bits_remaining %d (no data)",
	     state->bits_waiting, state->bits_remaining));

    return ((USHORT)-1);
}

/*
  v42bis_decode_codeword_flush()

  "flush" decoding of codewords, returning the last codeword
*/

USHORT
v42bis_decode_codeword_flush(state)
v42bis_t *state;
{
    USHORT codeword = (USHORT)-1;

    if (state->bits_remaining)
	codeword = (USHORT)(state->bits_waiting & bit_masks[state->c2]);

    state->bits_waiting = 0;
    state->bits_remaining = 0;

    return codeword;
}

/*
  v42bis_encode_codeword()

  encode n-bit codewords into a bytesteam.

  This routine makes use of the fact that the code words will be always
  be smaller than 16 bits.  An "accumulator" is used with several state
  variables to keep track of how much of the accumulator is in use at
  any given time.

  The code works for wordsizes of 8 and 16 bits.  It is assumed that the
  output is a byte stream.  No assumptions are made about alignment of
  data.

  note: this routine needs to be "flushed" to get out the value left
  in the accumulator.

  jbp@fcr.com 09/13/92, 19:52
*/

DWORD
v42bis_encode_codeword(state, value)
v42bis_t *state;
USHORT value;
{
    register UCHAR bits_free, bits_new, bits_residual;

    EN_DEBUG(("v42bis_encode_codeword(%d 0x%x) c2=%d",
	      value, value, state->c2));

    /* simple case */
    if (state->c2 == 8 || state->transparent)
    {
	    E_DEBUG(("put acc %02x %s", value & 0xff, itobits(value & 0xff, 8)));

	    PUT((UCHAR)value);

	    if (state->transparent)
        {
	        state->bits_out_while_transparent += N3;
        }
	    else
        {
	        state->bits_out_while_compressed += N3;
        }

	    return ARAPERR_NO_ERROR;
    }

    state->bits_out_while_compressed += state->c2;

    /* not-so-simple case */
    E_DEBUG(("before: acc %04x, bits_used %d",
	     state->bits_acc, state->bits_used));

    /* place new value in appropriate bit positions */
    state->bits_acc |= ((DWORD)value) << state->bits_used;

    /* housekeeping */
    bits_free = state->word_size - state->bits_used;
    bits_new = bits_free < state->c2 ? bits_free : state->c2;
    bits_residual = state->c2 - bits_new;

    E_DEBUG(("bits_free %d, bits_new %d, bits_residual %d",
	     bits_free, bits_new, bits_residual));

#ifdef DEBUG
    if (state->bits_used + bits_new >= 31)
	logf("acc oflo, size %d", state->bits_used + bits_new);
#endif

    /* do we have a full codeword in the accumulator? */
    if (state->bits_used + bits_new == state->word_size)
    {

	    if (state->word_size == 16)
        {
	        E_DEBUG(("put acc %06x %s",
		         state->bits_acc, itobits(state->bits_acc, 24)));

	        PUT((UCHAR)(state->bits_acc));

	        PUT((UCHAR)(state->bits_acc >> 8));

	    }
        else
        {
    	    E_DEBUG(("put acc %02x %s",
	    	     state->bits_acc & 0xff,
		         itobits(state->bits_acc & 0xff, 8)));

	        PUT((UCHAR)(state->bits_acc));
	    }

	    E_DEBUG(("value 0x%x, bits_used %d, acc 0x%x",
		     value, state->bits_used, value >> state->bits_used));

	    /* account for left over bits */
	    state->bits_acc = value >> (state->c2 - bits_residual);

        state->bits_used = bits_residual;
    }
    else
    {
	    state->bits_used += bits_new;
    }

    E_DEBUG(("after: acc %06x, bits_used %d",
	     state->bits_acc, state->bits_used));

	return ARAPERR_NO_ERROR;
}

/*
  v42bis_encode_codeword_flush()

  flush partial assembly of codeword into 16 bit accumulator
*/

DWORD
v42bis_encode_codeword_flush(state)
v42bis_t *state;
{
    V_FLOW(("v42bis_encode_codeword_flush() bits_used %d", state->bits_used));

    if (state->bits_used) {
	E_DEBUG(("put acc (flush) %02x %s",
		 state->bits_acc & 0xff,
		 itobits(state->bits_acc & 0xff, 8)));

	PUT((UCHAR)(state->bits_acc));
    }

    if (state->bits_used > 8) {
	E_DEBUG(("put acc (flush2) %02x %s",
		 (state->bits_acc>>8) & 0xff,
		 itobits((state->bits_acc>>8) & 0xff, 8)));

	PUT((UCHAR)(state->bits_acc >> 8));
    }

#ifdef DEBUG
    if (state->bits_used > 16)
	logf("flush: bits_used %d", state->bits_used);
#endif

    state->bits_used = 0;
    state->bits_acc = 0;

	return ARAPERR_NO_ERROR;
}

/*
  v42bis_encode_value()

  encode a codeword value, noting if it's size exceeds C3, and
  doing any required STEPUPs
*/

DWORD
v42bis_encode_value(state, value)
v42bis_t *state;
USHORT value;
{
    DWORD   dwRetCode;

    V_FLOW(("v42bis_encode_value(%lx, 0x%x)", state, value));

#ifdef DEBUG
    /* sanity check */
    if (value >= 8192) {
	logf("encode_value() value too big, %d", value);
	exit(1);
    }
#endif

    /* section 7.4 */

    /* check codeword size */
    while (value >= state->c3)
    {
	    EN_DEBUG(("stepup: value %d, max %d", value, state->c3));

	    dwRetCode = v42bis_encode_codeword(state, CCW_STEPUP);
	    if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }
	    state->c2++;
	    state->c3 *= 2;
    }

    dwRetCode = v42bis_encode_codeword(state, value);

	return(dwRetCode);
}

/*
  decide if we should transition from tranparent to compressed or
  visa versa.
*/

DWORD
v42bis_apply_compression_test(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    if (state->just_flushed || state->exception_next)
    {
	    return ARAPERR_NO_ERROR;
    }

#ifdef UNIT_TEST_PROGRESS
    {
	    static int times = 0;
	    if (++times == 1000)
        {
	        times = 0;
	        dwRetCode = v42bis_comp_test_report(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
	    }
    }
#endif

#ifdef UNIT_TEST_FORCE
    /* force consistant behavior across all input */
    if (!state->transparent)
    {
    	state->bits_out_while_transparent = 0;
	    return ARAPERR_NO_ERROR;
    }
    else
    {
	    state->bits_out_if_transparent = 0;
#undef WINDOW_CHECK_BYTES
#define WINDOW_CHECK_BYTES 0
	    if (state->bits_out_while_transparent > 64*N3)
        {
	        dwRetCode = v42bis_transition_to_compressed(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
        }
	    return ARAPERR_NO_ERROR;
    }
#endif

    /* bound check to recent history */
    if (WINDOW_FULL(state->bits_out_this_mode))
    {
	    state->bits_out_this_mode = 0;
	    state->bits_out_other_mode = 0;
    }

    if (!state->transparent)
    {
	    /* compressing */
	    if ((state->bits_out_while_compressed -
	         state->bits_out_if_transparent) > WINDOW_MIN_BITS)
        {
	        dwRetCode = v42bis_transition_to_transparent(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
        }
    }
    else
    {
	/* transparent */
#ifdef NEVER_SEND_COMPRESSED
	    return ARAPERR_NO_ERROR;
#endif
	/* transparent */
	    if ((state->bits_out_while_transparent -
	         state->bits_out_if_compressed) > WINDOW_MIN_BITS)
        {
	        dwRetCode = v42bis_transition_to_compressed(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
        }
    }


	return ARAPERR_NO_ERROR;
}

/*
  v42bis_encode_buffer()

  implements C-DATA semantics on encode side

  encode a buffer full of data...
*/

DWORD
v42bis_encode_buffer(state, string, insize)
v42bis_t *state;
PUCHAR string;
int insize;
{
    UCHAR ch;
    BOOLEAN hit, duplicate;
    USHORT root_value, hit_node;
    node_t *n, *dead, *p;
    DWORD   dwRetCode;


    V_FLOW(("v42bis_encode_buffer(%lx, %lx, %d)", state, string, insize));

    if (insize == 0)
    {
	    return ARAPERR_NO_ERROR;
    }

    V_FLOW(("v42bis_encode: input %*s", insize, string));

    state->bytes_in += insize;

    /* section 6.3 */

    while (insize > 0)
    {
	    /* "search" dictionary for string + character */
	    ch = string[0];

	    hit = FALSE;
	    duplicate = FALSE;
	    hit_node = state->last_match;
	    p = DICT(state->last_match);

	    EN_S_DEBUG(("last_match %d, string_size %d, insize %d, ch %d '%s'",
		        state->last_match, state->string_size, insize,
		        ch, show_char(ch)));

	    if (state->last_match == 0)
        {
	        /*
	        * "the code word associated with each root node shall be N6 (the
	        * number of control codewords) plus the ordinal value of the
	        * character represented by the node"
	        */

	        state->last_match = ch + N6;
	        state->string_size = 1;

	        EN_S_DEBUG(("codeword for root %d, '%s' = %d",
			    ch + N6, show_char(ch), CODE(DICT(ch + N6))));

	        p = DICT(ch + N6);
	        p->byte = ch;

	        hit = TRUE;
 	        hit_node = state->last_match;

	        /* consume input */
	        goto consume_input;
	    }

	    /* we're at a node; search it's leaves */
	    for (n = DICT(DICT(state->last_match)->leaf);
	         CODE(n) && insize > 0;)
	    {
	        EN_S_DEBUG(("  checking leaf node %d", CODE(n)));

	        if (n->byte == *string)
            {
		        /* hit - check leafs */
		        EN_S_DEBUG(("  hit: "));

		        hit_node = (USHORT)CODE(n);
		        p = n;
		        state->last_match = (USHORT)CODE(n);

		        if (state->just_flushed || hit_node == state->last_new)
		        {
		            EN_S_DEBUG(("leaving search, node == last created"));
		            hit = FALSE;
		            duplicate = TRUE;

		            /* backup to previous node */
		            hit_node = n->parent;
		            state->last_match = n->parent;
		            break;
		        }

		        hit = TRUE;
		        state->string_size++;

#ifdef never
		        string++;
		        insize--;

		        /* if no leafs, exit now - we're at the end */
		        if (n->leaf == 0)
                {
		            EN_S_DEBUG(("leaving search, no leaf"));
		            break;
		        }

		        n = DICT(n->leaf);
		        EN_S_DEBUG(("continuing search, leaf %d", CODE(n)));
		        continue;
#else
        		EN_S_DEBUG(("exiting search, leaf %d", CODE(n)));
		        goto consume_input;
#endif
	        }
            else
            {
		        EN_S_DEBUG(("  miss: "));
		        hit = FALSE;
	        }

	        if (n->node == 0)
            {
		        EN_S_DEBUG(("leaving search, no node"));
		        break;
	        }

	        n = DICT(n->node);
	        EN_S_DEBUG(("continuing search, node %d", CODE(n)));
	    }

	    EN_S_DEBUG(("search done, n %d, insize %d, next %d '%s' %s %s",
		        CODE(n), insize, string[0], show_char(string[0]),
		        hit ? "hit" : "miss", duplicate ? "duplicate" : ""));

#ifdef never
	    /* we're matching but we ran out of characters */
	    if (hit && insize == 0)
        {
	        return ARAPERR_NO_ERROR;
        }
#endif

	    if (!hit && duplicate)
        {
	        BOOLEAN ok_to_output;

	        EN_S_DEBUG(("duplicate"));

	        ok_to_output =
		        !state->just_flushed &&
		        !state->exception_next &&
			    !state->decode_only;

	        state->exception_next = FALSE;

	        if (ok_to_output)
	        {
		        if (!state->transparent)
                {
		            dwRetCode = v42bis_encode_value(state, hit_node);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
                }
		        else
                {
		            state->bits_out_if_compressed += state->c2;

		            /* check if we should go compressed */
		            if (state->bytes_since_last_check > WINDOW_CHECK_BYTES)
                    {
			            state->bytes_since_last_check = 0;

                        dwRetCode = v42bis_apply_compression_test(state);
                        if (dwRetCode != ARAPERR_NO_ERROR)
                        {
                            return(dwRetCode);
                        }
		            }
		        }
	        }

	        /* string = string + character */
	        state->string_size++;

	        /* reset match to unmatched character */
	        state->last_match = 0;
	        state->string_size = 0;
	        state->last_new = 0;

	        state->just_flushed = 0;

	        /* don't advance, "string = unmatched character" */
	        continue;
	    }

	    /* last char did not match or already in dictionary */
	    if (!hit && !duplicate)
	    {
	        BOOLEAN ok_to_output;

	        EN_S_DEBUG(("update dictionary"));

	        ok_to_output =
		        !state->just_flushed &&
		        !state->exception_next &&
			    !state->decode_only;

	        state->exception_next = FALSE;

	        if (ok_to_output)
	        {
		        if (!state->transparent)
                {
    		        dwRetCode = v42bis_encode_value(state, hit_node);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
                }
		        else
                {
    		        state->bits_out_if_compressed += state->c2;

	    	        /* check if we should go compressed */
		            if (state->bytes_since_last_check > WINDOW_CHECK_BYTES)
                    {
			            state->bytes_since_last_check = 0;
			            dwRetCode = v42bis_apply_compression_test(state);
                        if (dwRetCode != ARAPERR_NO_ERROR)
                        {
                            return(dwRetCode);
                        }
		            }
		        }
	        }

	        state->just_flushed = 0;

	        /* "add string + character to dictionary" */

	        /* section 6.4a */

	        /* string too big? */
	        if (state->string_size >= state->n7)
            {
		        EN_DEBUG(("string size (%d) > n7 (%d)",
			    state->string_size, state->n7));

		        /* reset match */
		        state->last_match = 0;
		        state->string_size = 0;

		        /* we were in the match routine, reset last new */
		        state->last_new = 0;

                continue;
	        }

	        /* pick a new code word */
	        n = DICT(state->c1);
	        state->last_new = (USHORT)CODE(n);

	        EN_DEBUG(("adding new node %d = %d '%s', parent %d",
		          CODE(n), string[0], show_char(string[0]), CODE(p)));

	        /* attach "string + character" */
	        n->byte = string[0];
	        n->parent = hit_node;
#ifdef DEBUG
	        if (CODE(n) == hit_node)
            {
		        logf("creating loop! node %d", CODE(n));
            }
#endif
	        n->node = 0;

	        /* XXX should be in ord(ch) order to allow faster search */
	        n->node = p->leaf;
	        p->leaf = (USHORT)CODE(n);

	        /* section 6.5 */

    	    /* recover dictionary entries */
	        do
            {
		        state->c1++;

		        if (state->c1 > (state->n2 - 1))
                {
		            state->c1 = N5;
		            state->dict_full = TRUE;
		        }

		        dead = DICT(state->c1);

		        /* find terminal nodes (i.e. leaf == 0) */
	        } while (/*dead->parent != 0 &&*/ dead->leaf != 0);

	        /* terminal nodes with parents are eligible */
	        if (CODE(dead) && /* <- I think this is not needed */
		        /*dead->parent && */dead->leaf == 0 &&
		        state->dict_full)
	        {
		        /* go to parent, disconnect from chain */
		        node_t *parent = DICT(dead->parent);

		        EN_DEBUG(("recovering dead node %d", CODE(dead)));

		        /* if first on parents list, fix parent */
		        if (DICT(parent->leaf) == dead)
                {
		            parent->leaf = dead->node;
                }
		        else
                {
		            /* else search parents list, fix sibling */
		            for (parent = DICT(DICT(dead->parent)->leaf);
			            CODE(parent); parent = DICT(parent->node))
		            {
			            if (DICT(parent->node) == dead)
                        {
    			            parent->node = dead->node;
			                break;
			            }
		            }
                }

		        /* mark node free */
		        dead->parent = 0;
		        dead->leaf = 0;
	        } /* dead node */

	        /* if we added a node, reset "string" */
//reset_match:
	        state->last_match = 0;
	        state->string_size = 0;
	        state->just_flushed = 0;

	        /*
	        * this is a "safe time" to do compression test, as we've just
	        * done an update...
	        */
	        if (!state->decode_only)
            {
		        if (state->bytes_since_last_check > WINDOW_CHECK_BYTES)
                {
		            state->bytes_since_last_check = 0;
		            dwRetCode = v42bis_apply_compression_test(state);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
		        }
	        }

	        /* don't advance, "string = unmatched character" */
	        continue;
	    } /* (!hit && !duplicate) */

consume_input:
	    string++;
	    insize--;
	    state->bytes_since_last_check++;

	/* section 9.2 */
//check_escape:
	/* escape processing */
	    if (state->transparent)
        {
	        if (!state->decode_only)
            {
		        dwRetCode = v42bis_encode_value(state, ch);
                if (dwRetCode != ARAPERR_NO_ERROR)
                {
                    return(dwRetCode);
                }
            }

	        if (ch == state->escape)
            {
		        if (!state->decode_only)
                {
		            dwRetCode = v42bis_encode_value(state, CCW_EID);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
		            state->escape += ESCAPE_CYCLE;
		        }
	        }
	    }
        else
        {
    	    /* compressed, cycle escape character */
	        if (ch == state->escape && !state->decode_only)
            {
		        state->escape += ESCAPE_CYCLE;
            }

	        state->bits_out_if_transparent += N3;
	    }

	    state->just_flushed = 0;
    }

	return ARAPERR_NO_ERROR;
}

/*
  implements C-FLUSH semantics
*/

DWORD
v42bis_encode_flush(state)
v42bis_t *state;
{

    DWORD   dwRetCode=ARAPERR_NO_ERROR;


    V_FLOW(("v42bis_encode_flush() string_size %d, last_match %d",
	  state->string_size, state->last_match));

    if (state->just_flushed)
    {
	    return ARAPERR_NO_ERROR;
    }

    if (state->transparent)
    {
	    /* transparent, send any buffered characters */
    }
    else
    {
	    /* compressed */

	    /* section 7.9a */
	    /* output partial match, if any */
	    if (state->string_size)
        {
	        /* section 7.8.2 */
	        dwRetCode = v42bis_encode_value(state, state->last_match);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
	    }

	    state->just_flushed = 1;

	    dwRetCode = v42bis_encode_value(state, CCW_FLUSH);

        if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    dwRetCode = v42bis_encode_codeword_flush(state);
    }

	return dwRetCode;
}

DWORD
v42bis_transition_to_compressed(state)
v42bis_t *state;
{

    DWORD   dwRetCode=ARAPERR_NO_ERROR;


    V_FLOW(("v42bis_transition_to_compressed()"));

#ifdef UNIT_TEST_VERBOSE
    logf("v42bis_transition_to_compressed()");
    v42bis_comp_test_report(state);
#endif

    if (state->transparent)
    {
	    /* section 7.8.1a */
	    dwRetCode = v42bis_encode_value(state, state->escape);
	    if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* section 7.8.1b */
	    if ((dwRetCode = v42bis_encode_value(state, CCW_ECM)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    if ((dwRetCode = v42bis_encode_codeword_flush(state)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* enter compressed mode */
	    state->transparent = FALSE;

	    state->bits_out_if_transparent = 0;
	    state->bits_out_while_compressed = 0;
    }

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_transition_to_transparent(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    V_FLOW(("v42bis_transition_to_transparent()"));

#ifdef UNIT_TEST_VERBOSE
    logf("v42bis_transition_to_transparent()");
    v42bis_comp_test_report(state);
#endif

    /* check counters for overflow */

    if (!state->transparent)
    {
	    /* output partial match, if any */
	    if (state->string_size)
        {
    	    /* section 7.8.2 */
	        dwRetCode = v42bis_encode_value(state, state->last_match);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
	    }

	    /* section 7.8.2c */
	    if ((dwRetCode = v42bis_encode_value(state, CCW_ETM)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* section 7.8.2d */
	    if ((dwRetCode = v42bis_encode_codeword_flush(state)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* section 7.8.2e */
	    /* enter transparent mode */
	    state->transparent = TRUE;

	    /* reset compressibility test */
	    state->bits_out_if_compressed = 0;
	    state->bits_out_while_transparent = 0;
    }

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_signal_reset(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    if (!state->transparent)
    {
	    /* change to transparent */
	    dwRetCode = v42bis_transition_to_transparent(state);
        if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* counteract side effect */
	    state->exception_next = FALSE;
    }

    dwRetCode = v42bis_encode_value(state, state->escape);
    if (dwRetCode != ARAPERR_NO_ERROR)
    {
        return(dwRetCode);
    }

    dwRetCode = v42bis_encode_value(state, CCW_RESET);

	return(dwRetCode);
}

/*
  expand a codeword into it's string

  follow chain of "parent" to root and then expand the node characters
  one by one.
*/

DWORD
v42bis_decode_match(state, codeword, psize, pRetChar)
v42bis_t *state;
USHORT codeword;
UCHAR   *pRetChar;
int *psize;
{
    node_t *path[256];
    int path_size = 0;
    node_t *base;
    int i;

    V_FLOW(("v42bis_decode_match(%d)", codeword));

    for (base = DICT(codeword); CODE(base); base = DICT(base->parent))
    {
	    path[path_size++] = base;
	    if (path_size >= 256)
        {
	        v42bis_c_error(state, "path_size exceeds 256!");
	        break;
	    }
#ifdef DEBUG
	    if (base == DICT(base->parent))
        {
	        logf("loop! node %d", CODE(base));
	        break;
	    }
#endif
    }

    /* XXX this should not be done here! */
    if (codeword < N5 && DICT(codeword)->byte == 0)
    {
	    DICT(codeword)->byte = codeword - N6;
    }

    D_DEBUG(("path_size %d", path_size));

    for (i = path_size - 1; i >= 0; i--)
    {
	    D_DEBUG(("put byte %02x '%s'",
		     path[i]->byte, show_char(path[i]->byte)));

	    if (path[i]->byte == state->escape)
        {
    	    state->escape += ESCAPE_CYCLE;
        }

    	PUT(path[i]->byte);
    }

    *psize = path_size;

    /* return first (prefix) char of string */
    *pRetChar = path[path_size-1]->byte;

    return ARAPERR_NO_ERROR;
}

/*
  decode L-DATA semantics on the decode side

  decode a buffer full of data...
*/

DWORD
v42bis_decode_buffer(state, data, pDataSize)
v42bis_t *state;
PUCHAR data;
int *pDataSize;
{
    USHORT codeword;
    UCHAR  ch;
    DWORD   dwRetCode;


    V_FLOW(("v42bis_decode_buffer() %d bytes", *pDataSize));

    while (*pDataSize)
    {
        //
        // did we have an overflow?  if so, stop right here
        //
        if (state->OverFlowBytes && data)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("Arap v42bis: %d bytes overflowed, suspending decomp\n",
                    state->OverFlowBytes));

            return(ARAPERR_BUF_TOO_SMALL);
        }

#if DBG
        if (state->OverFlowBytes && !data)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("Arap v42bis: ALERT! ALERT: (%d)\n",state->OverFlowBytes));

            ASSERT(0);
        }
#endif

        (*pDataSize)--;

	    if (data)
        {
	        /* we have a buffer */
    	    D_DEBUG(("pull 0x%x", *data & 0xff));
    	    codeword = v42bis_decode_codeword(state, *data++);
	    }
        else
        {
	        /* no input buffer, flush */
	        codeword = v42bis_decode_codeword_flush(state);
	        *pDataSize = 0;
	    }

	    DE_DEBUG(("codeword %d (0x%x)", codeword, codeword));

	    /* if decode did not return a value, return */
	    if (codeword == 0xffff)
        {
    	    /* no data */
	        D_DEBUG(("no data"));

	        continue;
	    }

	    if (state->transparent)
        {
    	    /* transparent mode */

	        /* escaped - look at next codeword */
	        if (state->escaped)
            {
		        state->escaped = FALSE;

		        DE_DEBUG(("escape codeword"));

		        /* section 5.8d */
		        if (codeword >= 3 && codeword <= 255)
                {
                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		                ("v42: received reserved code word (%d)", codeword));
		            v42bis_c_error(state, "received reserved code word");
		            break;
		        }

		        switch (codeword)
                {
		            case CCW_ECM:
		                DE_DEBUG(("enter compression mode"));
		                state->transparent = FALSE;

		                /* set up for decode */
		                state->last_decode = state->last_match;
		                state->last_decode_size = state->string_size;

        		        state->exception_next = TRUE;
		                break;

		            case CCW_EID:
		                DE_DEBUG(("escape id"));

		                codeword = state->escape;
		                state->escape += ESCAPE_CYCLE;
		                goto decode_encode;
		                break;

		            case CCW_RESET:
		                DE_DEBUG(("reset"));

		                v42bis_init_dictionary(state);
		                break;
		        }
	        }

            else
            {
		        /* escape? */
		        if (codeword == state->escape)
                {
		            DE_DEBUG(("escape prefix"));
		            state->escaped = TRUE;
		            continue;
		        }

	            decode_encode:
		        /* save data in output buffer */
		        PUT((UCHAR)codeword);

		        /* encode to build dictionary */
		        ch = (UCHAR)codeword;

		        dwRetCode = v42bis_encode_buffer(state, &ch, 1);
                if (dwRetCode != ARAPERR_NO_ERROR)
                {
                    return(dwRetCode);
                }
	        }
	    }
        else
        {
	        int size;

	        /* compression mode */
	        switch (codeword)
            {
	            case CCW_ETM:
		            DE_DEBUG(("enter transparent mode"));

		            v42bis_decode_codeword_flush(state);
		            state->transparent = TRUE;
		            state->last_match = state->last_decode;
		            state->string_size = state->last_decode_size;
		            state->last_new = 0;

            		state->just_flushed = 1;
		            break;

	            case CCW_FLUSH:
		            DE_DEBUG(("flush"));

		            /* terminate search */
		            state->last_match = 0;
		            state->string_size = 0;
		            state->last_match = state->last_decode;
		            state->string_size = state->last_decode_size;
		            state->last_new = 0;

		            /* reset codeword decode machine */
		            state->bits_waiting = 0;
		            state->bits_remaining = 0;
		            break;

                case CCW_STEPUP:
		            DE_DEBUG(("stepup"));

		            /* section 5.8a */;
		            if (state->c2 + 1 > state->n1)
                    {
		                v42bis_c_error(state, "received STEPUP; c2 exceeds max");
                    }
		            else
                    {
		                state->c2++;
                    }
		        break;

	            default:
		            /* regular codeword */

		            /* section 5.8b */
		            if (codeword == state->c1)
                    {
#ifdef DEBUG
		                logf(state, "received codeword equal to c1");
#endif
		                continue;
		            }

		            /* section 5.8c */
		            if (codeword >= N5 && state->dictionary[codeword].parent == 0)
		            {
#ifdef DEBUG
		                logf("received unused codeword %d, full %d, c1 %d",
			            codeword, state->dict_full, state->c1);
#endif
		                v42bis_c_error(state, "received unused codeword");
		            }

		            dwRetCode = v42bis_decode_match(state, codeword, &size, &ch);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }

		            /*
		            * umm... "New dictionary entries shall be created using
		            * the proceedure defined in section 6.4, with the first
		            * (prefix) character of the most recently decoded string
		            * being appended to the previously decoded string."
		            *
		            * what a pain this was to get right!
		            */

		            /* section 8 */
		            state->last_match = state->last_decode;
		            state->string_size = state->last_decode_size;

		            dwRetCode = v42bis_encode_buffer(state, &ch, 1);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }

		            state->last_decode = codeword;
		            state->last_decode_size = (UCHAR)size;
	        }
	    }
    }

    dwRetCode = (state->OverFlowBytes) ?
                    ARAPERR_BUF_TOO_SMALL : ARAPERR_NO_ERROR;

    return(dwRetCode);
}

/*
  v42bis_decode_flush()

  flush codeword decoder and push out data
*/

DWORD
v42bis_decode_flush(state)
v42bis_t *state;
{
    DWORD   dwRetCode;
    int     one;

    V_FLOW(("v42bis_decode_flush()"));

    one = 1;

    dwRetCode = v42bis_decode_buffer(state, (PUCHAR )0, &one);

	return(dwRetCode);
}

/*
  v42bis_c_error()

  implements C-ERROR semantics
*/

DWORD
v42bis_c_error(state, reason_string)
v42bis_t *state;
char *reason_string;
{
    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("v42bis: C-ERROR with '%s' on %s",reason_string,
	    state == &((v42bis_connection_t *)state->connection)->encode ?
	    "encode" : "decode"));

    ASSERT(0);

	return ARAPERR_NO_ERROR;
}



DWORD
v42bis_init_buffer(state, buf, size)
v42bis_t *state;
PUCHAR buf;
int size;
{
    state->output_buffer = buf;
    state->output_ptr = buf;
    state->output_size = 0;
    state->output_max = (USHORT)size;

	return ARAPERR_NO_ERROR;
}

/*
*/
DWORD
v42bis_connection_init(conn)
v42bis_connection_t *conn;
{
    conn->default_p0 = 3;
    conn->default_p1 = DEF_P1;	/* total # of codewords */
    conn->default_p2 = DEF_P2;	/* max string length */

    conn->neg_p0 = conn->default_p0;	/* direction of compression */
    conn->neg_p1 = conn->default_p1;	/* total # of codewords */
    conn->neg_p2 = (UCHAR)conn->default_p2;	/* max string length */

    /* encode side */
    conn->encode.connection = (void *)conn;
    conn->encode.decode_only = FALSE;

    v42bis_init(&conn->encode);

    /* decode side */
    conn->decode.connection = (void *)conn;
    conn->decode.decode_only = TRUE;

    v42bis_init(&conn->decode);

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_connection_init_buffers(conn, e_buf, e_size, d_buf, d_size)
v42bis_connection_t *conn;
PUCHAR e_buf;
int e_size;
PUCHAR d_buf;
int d_size;
{
    v42bis_init_buffer(&conn->encode, e_buf, e_size);
    v42bis_init_buffer(&conn->decode, d_buf, d_size);

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_connection_init_push(conn, context, e_push, d_push)
v42bis_connection_t *conn;
void *context;
void (*e_push)();
void (*d_push)();
{
    conn->encode.push_func = e_push;
    conn->encode.push_context = context;
    conn->decode.push_func = d_push;
    conn->decode.push_context = context;

	return ARAPERR_NO_ERROR;
}

/* ------------- debug -------------- */

#ifdef DEBUG

DWORD
v42bis_dumptree_follownode(state, node)
v42bis_t *state;
USHORT node;
{
    int i;
    node_t *n = DICT(node);

    for (i = 0; i < state->dump_indent; i++)
	fprintf(stderr, "  ");

    fprintf(stderr, "code %d; char %d '%s' parent %d, node %d, leaf %d\n",
	   node, n->byte, show_char(n->byte), n->parent, n->node, n->leaf);

    if (n->node)
	v42bis_dumptree_follownode(state, n->node);

    state->dump_indent++;

    if (n->leaf)
	v42bis_dumptree_follownode(state, n->leaf);

    state->dump_indent--;

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_dumptree(state, name)
v42bis_t *state;
char *name;
{
    int i;

    fprintf(stderr, "%s codewords:\n", name);
    for (i = 0; i < CODES; i++)
	if (state->dictionary[i].byte) {
	    node_t *n = &state->dictionary[i];

	    fprintf(stderr, "code %d; char %d '%s' parent %d, node %d, leaf %d\n",
		   i, n->byte, show_char(n->byte),
		   n->parent, n->node, n->leaf);
	}

    state->dump_indent = 0;

    fprintf(stderr, "%s tree:\n", name);
    for (i = 0; i < N5; i++)
	if (state->dictionary[i].byte) {
	    node_t *n = &state->dictionary[i];

	    fprintf(stderr, "code %d; root node, %d '%s', leaf %d:\n",
		   i, n->byte, show_char(n->byte), n->leaf);

	    if (state->dictionary[i].leaf) {
		state->dump_indent = 1;
		v42bis_dumptree_follownode(state, n->leaf);
	    }
	}

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_connection_dumptree(conn)
v42bis_connection_t *conn;
{
    int i;

    fprintf(stderr, "\nv42bis_connection_dumptree()\n");

    v42bis_dumptree(&conn->encode, "encode");
    v42bis_dumptree(&conn->decode, "decode");

	return ARAPERR_NO_ERROR;
}

#endif	/* DEBUG */


/* ------------- external interface -------------- */

DWORD
v42bis_mnp_set_debug(pArapConn)
PARAPCONN pArapConn;
{
#if DEBUG
    pArapConn->v42bis.decode.debug_decode = 0;
    pArapConn->v42bis.decode.debug_encode = 0;

    switch (pArapConn->debug_v42) {
      case 3:
	    pArapConn->v42bis.decode.debug_flow = TRUE;
    	pArapConn->v42bis.encode.debug_flow = TRUE;
	    /* fall through */

      case 2:
	    pArapConn->v42bis.decode.debug_decode_bytes = TRUE;
	    pArapConn->v42bis.decode.debug_encode_bytes = TRUE;

	    pArapConn->v42bis.encode.debug_encode_bytes = TRUE;

	    pArapConn->v42bis.decode.debug_decode++;
	    pArapConn->v42bis.decode.debug_encode++;

	    /* fall through */

      case 1:
	    pArapConn->v42bis.decode.debug_decode++;
	    pArapConn->v42bis.decode.debug_encode++;

	    pArapConn->v42bis.encode.debug_encode = TRUE;
	    break;

      case 0:
	    break;
    }
#endif

	return ARAPERR_NO_ERROR;
}



/*
  v42bis_send()

  send data to V.42bis connection

  input:	unsigned char *buffer; 	pointer to user data buffer
	     	int buflen;		length of user data buffer

  output:	int retcode - if positive, the number of data bytes
		              copied from the user data buffer;
			      if negative, link error code
*/


/*
  v42bis_receive()

  receive data from V.42bis connection

  input:	unsigned char *buffer;	pointer to user buffer
		int buflen;		length of user buffer

  output:	int retcode;	if positive, the number of data bytes
				copied into the user data buffer;
				if negative, link error code
*/



//-----------------------------------------------------------------------------
//
// Interface functions
//
//-----------------------------------------------------------------------------

BOOLEAN
v42bisInit(
  IN  PARAPCONN  pArapConn,
  IN  PBYTE      pReq,
  OUT DWORD     *dwReqToSkip,
  OUT PBYTE      pFrame,
  OUT DWORD     *dwFrameToSkip
)
{

    BYTE        VarLen;
    BOOLEAN     fV42Bis=TRUE;


    DBG_ARAP_CHECK_PAGED_CODE();

    if (ArapGlobs.V42bisEnabled)
    {
        *pFrame++ = MNP_LR_V42BIS;
        VarLen = *pReq;
        *pFrame++ = *pReq++;

        RtlCopyMemory(pFrame, pReq, VarLen);

        fV42Bis = TRUE;

        *dwReqToSkip = (VarLen+1);
        *dwFrameToSkip = (VarLen+2);

        /* init the connection (both encode and decode */
        v42bis_connection_init(pArapConn->pV42bis);

    }
    else
    {
        // send the v42bis type, but 0 for all parms
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("v42bisInit: no v42bis (type 1: i.e. 0 for all parms) on %lx\n",pArapConn));

        *pFrame++ = MNP_LR_V42BIS;
        VarLen = *pReq;
        *pFrame++ = *pReq++;

        *pFrame++ = 0;
        *pFrame++ = 0;
        *pFrame++ = 0;
        *pFrame++ = 0;

        fV42Bis = FALSE;

        *dwReqToSkip = (VarLen+1);
        *dwFrameToSkip = (VarLen+2);

    //
    // the other two possibilities to indicate no compression: the one above works,
    // the following two retained just in case we need later
    //
#if 0
        // send the v42bis type, but 0 for the direction flags: other parms valid
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("v42bisInit: no v42bis (type 2: i.e. 0 only for direction) on %lx\n",pArapConn));

            *pFrame++ = MNP_LR_V42BIS;
            VarLen = *pReq;
            *pFrame++ = *pReq++;

            *pFrame++ = 0;
            *pFrame++ = 0;
            *pFrame++ = 0x8;
            *pFrame++ = 0xfa;

            fV42Bis = FALSE;

            *dwReqToSkip = (VarLen+1);
            *dwFrameToSkip = (VarLen+2);
        }

        // skip the v42bis type altogether
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("v42bisInit: no v42bis (type 3: i.e. not sending v42bis type) on %lx\n",pArapConn));

            VarLen = *pReq;

            fV42Bis = FALSE;

            *dwReqToSkip = (VarLen+1);
            *dwFrameToSkip = 0;
        }
#endif

    }

    return(fV42Bis);
}

DWORD
v42bisCompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pUncompressedData,
  IN  DWORD      UnCompressedDataLen,
  OUT PUCHAR     pCompressedData,
  OUT DWORD      CompressedDataBufSize,
  OUT DWORD     *pCompressedDataLen
)
{
    DWORD   dwRetCode;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,("v42bisCompress (%lx, %lx, %ld)\n",
        pArapConn, pUncompressedData, UnCompressedDataLen));

#ifdef V42_DUMP_ENABLED
    if (pArapConn->v42_dump) {
	pArapConn->v42_size = buflen;
	pArapConn->v42_type = 2;
	write(pArapConn->v42_dump, &pArapConn->v42_esize, 4);
	write(pArapConn->v42_dump, bufptr, buflen);
    }
#endif

    v42bis_init_buffer(&pArapConn->pV42bis->encode,
                       pCompressedData,
                       CompressedDataBufSize);

    dwRetCode = v42bis_encode_buffer(&pArapConn->pV42bis->encode,
                                     pUncompressedData,
                                     UnCompressedDataLen);

    if (dwRetCode != ARAPERR_NO_ERROR)
    {
        return(dwRetCode);
    }

    dwRetCode = v42bis_encode_flush(&pArapConn->pV42bis->encode);

    // set the length of compressed data
    *pCompressedDataLen = pArapConn->pV42bis->encode.output_size;

    return(dwRetCode);
}

DWORD
v42bisDecompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pCompressedData,
  IN  DWORD      CompressedDataLen,
  OUT PUCHAR     pDecompressedData,
  OUT DWORD      DecompressedDataBufSize,
  OUT DWORD     *pByteStillToDecompress,
  OUT DWORD     *pDecompressedDataLen
)
{

    DWORD   dwRetCode;
    DWORD   dwRemaingDataSize;
    DWORD   dwOverFlow;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,("v42bisDecompress (%lx, %lx, %ld)\n",
        pArapConn, pCompressedData, CompressedDataLen));


    *pDecompressedDataLen = 0;

    dwRemaingDataSize = CompressedDataLen;

    *pByteStillToDecompress = CompressedDataLen;



#ifdef V42_DUMP_ENABLED
    if (pArapConn->v42_dump) {
	pArapConn->v42_size = mnp_size;
	pArapConn->v42_type = 2;
	write(pArapConn->v42_dump, &pArapConn->v42_size, 4 + mnp_size);
    }
#endif

    //
    // if we had an overflow in the previous decomp effort, we have bytes in
    // the overflow buffer: copy those in first.
    //
    if ( (dwOverFlow = pArapConn->pV42bis->decode.OverFlowBytes) > 0)
    {
        if (DecompressedDataBufSize <= dwOverFlow)
        {
            return(ARAPERR_BUF_TOO_SMALL);
        }


        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
            ("Arap v42bis: (%lx) copying %d overflow bytes first\n",
                pArapConn, dwOverFlow));

        RtlCopyMemory(pDecompressedData,
                      pArapConn->pV42bis->decode.OverFlowBuf,
                      dwOverFlow);

        pDecompressedData += dwOverFlow;

        DecompressedDataBufSize -= dwOverFlow;

        pArapConn->pV42bis->decode.OverFlowBytes = 0;

        *pDecompressedDataLen += dwOverFlow;
    }


    //
    // this can happen if we got called because we told in a previous call that
    // there was buffer overflow and there was nothing more left to decompress
    //
    if (CompressedDataLen == 0)
    {
        return(ARAPERR_NO_ERROR);
    }

    //
    // set decomp buffer to the buffer supplied
    //
    v42bis_init_buffer(&pArapConn->pV42bis->decode,
                       pDecompressedData,
                       DecompressedDataBufSize);

    /* decode everything we got */
    dwRetCode = v42bis_decode_buffer(&pArapConn->pV42bis->decode,
                                     pCompressedData,
                                     &dwRemaingDataSize);


    *pByteStillToDecompress = dwRemaingDataSize;


    //
    // how big is the decompressed data?
    //
    *pDecompressedDataLen += pArapConn->pV42bis->decode.output_size;

    return(dwRetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\v42bis.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	Header file for all the v42bis stuff useed by ARAP (adapted from fcr's code)

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/


// v42bis stuff begin

// #define PRIVATE  static

// v42bis stuff end


/* negotiated parameters in XID */
#define PARM_GROUP_ID		0xf0	/* ISB 8885, Addendum 3 */
#define PARM_PARM_ID_V42	0x00
#define PARM_PARM_ID_P0		0x01
#define PARM_PARM_ID_P1		0x02
#define PARM_PARM_ID_P2		0x03

/* control code words (compression mode) */
#define	CCW_ETM		0x00	/* enter transparent mode */
#define	CCW_FLUSH	0x01	/* flush data */
#define	CCW_STEPUP	0x02	/* stepup code word size */

/* command code words (transparent mode) */
#define	CCW_ECM		0x00	/* enter compression mode */
#define	CCW_EID		0x01	/* escape character in data */
#define	CCW_RESET	0x02	/* force reinitialization */

/* escape char cycling */
#define	ESCAPE_CYCLE	51

/*
 * v.42bis dictionary node
 */
typedef struct {
    UCHAR	byte;		/* character */
    USHORT	parent;		/* ptr to parent node */
    USHORT	node;		/* chain of nodes w/same parent */
    USHORT	leaf;		/* chain of leafs w/same parent */
} node_t;

/*
 * v.42bis state block
 */
typedef struct {
    /* connection */
    void	*connection;

    /* values from spec */
    SHORT	n1;		/* maximum codeword size (bits) */
    SHORT	n2;		/* total number of codewords */
#define	N3	8		/* character size (bits) */
#define	N4	256		/* characters in alphabet (2^n3) */
#define	N5	(N4+N6)		/* index # of 1st entry to store a string */
#define	N6	3		/* # of control words */
    UCHAR	n7;		/* maximum string length */

    /* dictionary */
#define	CODES		2048	/* max # of codewords */
#define	LOG2_CODES	11	/* log2(CODES) (max # of codeword bits) */
    node_t	dictionary[CODES];
#define DICT(i) (&state->dictionary[i])
#define CODE(n) ((n) - state->dictionary)

    USHORT	c1;		/* next dictionary entry */
    UCHAR	c2;		/* current codeword size */
    USHORT	c3;		/* threshhold for codeword size change */

    UCHAR	string_size;		/* # bytes in string so far */
    USHORT	last_match;		/* index of last match of "string" */
    USHORT	last_new;		/* index of last new node */
    USHORT	last_decode;
    UCHAR	last_decode_size;

    UCHAR	escape;			/* escape character */
    BOOLEAN	transparent;		/* are we in transparent mode? */
    BOOLEAN	decode_only;		/* are we decode side ? */

#if DEBUG
    UCHAR	dump_indent;		/* indentation dumping dict. tree */
    BOOLEAN	debug_encode_bytes;
    BOOLEAN	debug_encode;
    BOOLEAN	debug_decode_bytes;
    BOOLEAN	debug_decode;
    BOOLEAN	debug_flow;
#endif

    UCHAR	word_size;    		/* local # bits to decode into */
    BOOLEAN	exception_next;		/* do exception processing; next ch */
    BOOLEAN	escaped;		/* have we just gotten an escape? */
    BOOLEAN	just_flushed;		/* did we just flush? */
    BOOLEAN	dict_full;		/* is dictionary full? */

    /* decode bytes->codeword state */
    DWORD	bits_waiting;		/* decode holder */
    UCHAR	bits_remaining;		/* # bits waiting in holder now */

    UCHAR	*input_ptr;
    USHORT	input_size;

    /* encode codeword->bytes state */
    DWORD	bits_acc;		/* encode accumulator */
    UCHAR	bits_used;		/* # bits packed in acc now */

    UCHAR	*output_buffer;		/* ptr to work buffer */
    UCHAR	*output_ptr;		/* current ptr into buffer */
    USHORT	output_size;		/* current work size */
    USHORT	output_max;		/* size of work buffer */

    /* i/o */
    void	*push_context;
    //void	(*push_func)(void *a, u_char *b, int c, int d);
    void	(*push_func)();

    /* statistics for compressibility */
    DWORD	bytes_in;		/* total bytes input to compress */
    DWORD	bytes_out;		/* total bytes output from compress */
    long	bits_out_other_mode;	/* output if we were in other mode */
    long	bits_out_this_mode; 	/* since last transition */
    USHORT	bytes_since_last_check;	/* since last compression test */

    UCHAR  *OverFlowBuf;
    UCHAR  OverFlowBytes;
#define bits_out_if_compressed		bits_out_other_mode
#define bits_out_while_compressed	bits_out_this_mode
#define bits_out_if_transparent		bits_out_other_mode
#define bits_out_while_transparent	bits_out_this_mode
} v42bis_t;

/*
  define hysteresis for compressed/transparent mode switch

  WINDOW_FULL defines how many bits we look at
  WINDOW_MIN_BITS is the min bits of difference required for a change
*/
#define WINDOW_FULL(n)		(n & 0xfffffc00)	/* 1024 bits */
#define WINDOW_MIN_BITS		16*N3			/* 128 bits */
#define WINDOW_CHECK_BYTES	32			/* check every 32 */


#ifdef DEBUG
# define V_FLOW(s)	if (state->debug_flow) logf s;

# define EN_DEBUG(s)	\
    if (state->debug_encode) { \
	logf_prefix(state->decode_only ? "decode: " : "encode: "); \
	logf s; }

//# define EN_S_DEBUG(s)	\
//    if (state->debug_encode > 1) { \
//	logf_prefix(state->decode_only ? "decode: " : "encode: "); \
//	logf s; }
# define EN_S_DEBUG(s)	\
    if (state->debug_encode > 1) { \
	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,s);
# define EN_DEBUG_ON	(state->debug_encode)

# define DE_DEBUG(s)	\
    if (state->debug_decode) { logf_prefix("decode: "); logf s; }
# define DE_DEBUG_ON	(state->debug_decode)

# define E_DEBUG(s)	if (state->debug_encode_bytes) logf s;
# define D_DEBUG(s)	if (state->debug_decode_bytes) logf s;
#else
# define V_FLOW(s)	/* #s */
# define EN_DEBUG(s)	/* #s */
# define DE_DEBUG(s)	/* #s */
# define E_DEBUG(s)	/* #s */
# define D_DEBUG(s)	/* #s */
# define EN_S_DEBUG(s)
# define EN_DEBUG_ON	FALSE
# define DE_DEBUG_ON	FALSE
#endif

/*
 * v42bis connection type
 */
typedef struct {
    /* negotiated options */
    UCHAR	neg_p0;		/* negotiated value of p0 */
    USHORT	neg_p1;		/* negotiated value of p1 */
    UCHAR	neg_p2;		/* negotiated value of p2 */

    UCHAR	default_p0;	/* default value of p0 */
    USHORT	default_p1;	/* default value of p1 */
#define MIN_P1	512
#define DEF_P1	2048
    USHORT	default_p2;	/* default value of p2 */
#define MIN_P2	6
/*#define DEF_P2	8 */
#define DEF_P2	250
#define MAX_P2	250

    BOOLEAN	compress_init_resp;	/* comp. in initiator->responder dir */
    BOOLEAN	compress_resp_init;	/* comp. in responder->initiator dir */
    BOOLEAN	got_p0;			/* got negitated XID options */
    BOOLEAN	got_p1;
    BOOLEAN	got_p2;
    BOOLEAN	got_unknown_p;		/* got unknown option */

    v42bis_t	encode;			/* encode state */
    v42bis_t	decode;			/* decode state */
} v42bis_connection_t;

/* turn a "state" into a connection */
#define CONN(s)	((v42bis_connection_t *)(s)->connection)

#define PUT(ch)                                                             \
{                                                                           \
    if (state->output_size < state->output_max)                             \
    {                                                                       \
        *state->output_ptr++ = (ch);                                        \
        state->output_size++;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        /* put this byte in the overflow buffer: we'll recover later */     \
	    if (state == &((v42bis_connection_t *)state->connection)->decode)   \
        {                                                                   \
            *(state->OverFlowBuf + state->OverFlowBytes) = (ch);            \
            state->OverFlowBytes++;                                         \
                                                                            \
            ASSERT(state->OverFlowBytes <= MAX_P2);                         \
        }                                                                   \
                                                                            \
        /* we don't have overflow buffer for encode side!!  */              \
        else                                                                \
        {                                                                   \
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                           \
                ("Arap v42bis: buf overflow on encode!! (%ld)\n",           \
                    state->output_size));                                   \
                                                                            \
            ASSERT(0);                                                      \
        }                                                                   \
    }                                                                       \
}


/* local routines */
int decode_xid_params (v42bis_t *state, PUCHAR params, int len);
DWORD v42bis_encode_codeword (v42bis_t *state, USHORT value);
DWORD v42bis_c_error (v42bis_t *state, char *msg);
DWORD v42bis_transition_to_compressed (v42bis_t *state);
DWORD v42bis_transition_to_transparent (v42bis_t *state);
DWORD v42bis_disconnect(v42bis_t *state, char *reason_string);
DWORD v42bis_init_dictionary(v42bis_t *state);
DWORD exit_handler( void );
DWORD v42bis_init(v42bis_t *state);
USHORT v42bis_decode_codeword(v42bis_t *state, UCHAR value);
USHORT v42bis_decode_codeword_flush(v42bis_t *state);
DWORD v42bis_encode_codeword_flush(v42bis_t *state);
DWORD v42bis_encode_codeword_flush(v42bis_t *state);
DWORD v42bis_encode_value(v42bis_t *state, USHORT value);
DWORD v42bis_apply_compression_test(v42bis_t *state);
DWORD v42bis_encode_buffer(v42bis_t *state, PUCHAR string, int insize);
DWORD v42bis_encode_flush(v42bis_t *state);
DWORD v42bis_signal_reset(v42bis_t *state);
DWORD v42bis_decode_match(v42bis_t *state, USHORT codeword, int *psize, UCHAR *pRetChar);
DWORD v42bis_decode_buffer(v42bis_t *state, PUCHAR data, int *pDataSize);
DWORD v42bis_decode_flush(v42bis_t *state);
DWORD v42bis_init_buffer(v42bis_t *state, PUCHAR buf, int size);
DWORD v42bis_connection_init(v42bis_connection_t *conn);
DWORD v42bis_connection_init_buffers(v42bis_connection_t *conn, PUCHAR e_buf,
                                     int e_size, PUCHAR d_buf, int d_size);
DWORD v42bis_connection_init_push(v42bis_connection_t *conn, void *context,
                                  void (*e_push)(), void (*d_push)());
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\winsock\wshatalk.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    wshatalk.c

Abstract:

    This module contains necessary routines for the Appletalk Windows Sockets
    Helper DLL. This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use Appletalk as a transport.

Author:

    David Treadwell (davidtr)   19-Jul-1992 - TCP/IP version
    Nikhil Kamkolkar (nikhilk)  17-Nov- 1992 - Appletalk version

Revision History:

--*/

#include "nspatalk.h"
#include "wshdata.h"


//  GLOBAL - get the mac code page value from the registry.
int WshMacCodePage  = 0;

#if 0

VOID
PrintByteString(
    PUCHAR  pSrcOemString,
    USHORT  SrcStringLen
    )
{
    DbgPrint("%x - ", SrcStringLen);
    while (SrcStringLen-- > 0)
    {
        DbgPrint("%x", *pSrcOemString++);
    }
    DbgPrint("\n");
}

#define DBGPRINT0   DBGPRINT
#else
#define DBGPRINT0
#endif

INT
WSHGetSockaddrType (
    IN      PSOCKADDR Sockaddr,
    IN      DWORD SockaddrLength,
    OUT     PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    UNALIGNED SOCKADDR_AT *sockaddr = (PSOCKADDR_AT)Sockaddr;

    DBGPRINT0(("WSHGetSockAddrType: Entered\n"));

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sat_family != AF_APPLETALK )
    {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_AT) )
    {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sat_socket == ATADDR_ANY )
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    }
    else if ( sockaddr->sat_node == ATADDR_BROADCAST )
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoBroadcast;
    }
    else
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sat_socket == 0 )
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    }
    else
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    return NO_ERROR;

} // WSHGetSockaddrType


// Fix for bug 262107
INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For AppleTalk, we just blank out the address with zeros.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    if ( *SockaddrLength < sizeof(SOCKADDR_AT) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_AT);

    //
    // Just zero out the address and set the family to AF_APPLETALK--this is
    // a wildcard address for AppleTalk.
    //

    RtlZeroMemory( Sockaddr, sizeof(SOCKADDR_AT) );

    Sockaddr->sa_family = AF_APPLETALK;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


INT
WSHGetSocketInformation (
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  INT     Level,
    IN  INT     OptionName,
    OUT PCHAR   OptionValue,
    OUT PINT    OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL. The options supported here
    are SO_LOOKUPNAME/SO_LOOKUPZONES.
    This routine is called by the winsock DLL when a level/option name
    combination is passed to getsockopt() that the winsock DLL does not
    understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any. If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any. If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    NTSTATUS            status;
    ULONG               tdiActionLength;
    IO_STATUS_BLOCK     ioStatusBlock;
    HANDLE              eventHandle;
    PTDI_ACTION_HEADER  tdiAction;
    INT                 error = NO_ERROR;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    DBGPRINT0(("WSHGetSocketInformation: Entered, OptionName %ld\n", OptionName));

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT )
    {

        PWSHATALK_SOCKET_CONTEXT    context = HelperDllSocketContext;

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) )
            {
                *OptionLength = sizeof(*context);
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }


    //
    // The only level we support here is SOL_APPLETALK.
    //

    if ( Level != SOL_APPLETALK )
    {
        return WSAEINVAL;
    }

    //
    // Fill in the result based on the option name.
    //

    switch ( OptionName )
    {
      case SO_LOOKUP_NAME:
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_NAME)))
        {
            //  Due to the 'greater than' check we are guaranteed atleast
            //  one byte after the parameters.
            tdiActionLength =   sizeof(NBP_LOOKUP_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_NAME);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

      case SO_CONFIRM_NAME:
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength >= sizeof(WSH_NBP_TUPLE)))
        {
            tdiActionLength =   sizeof(NBP_CONFIRM_ACTION);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

      case SO_LOOKUP_MYZONE :
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength > 0))
        {
            //  Due to the 'greater than' check we are guaranteed atleast
            //  one byte after the parameters.
            tdiActionLength =   sizeof(ZIP_GETMYZONE_ACTION) +
                                *OptionLength;
        }
        else
        {
            error = WSAEINVAL;
        }

        break;

      case SO_LOOKUP_ZONES :
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_ZONES)))
        {
            //  Due to the 'greater than' check we are guaranteed atleast
            //  one byte after the parameters.
            tdiActionLength =   sizeof(ZIP_GETZONELIST_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_ZONES);
        }
        else
        {
            error = WSAEINVAL;
        }

        break;

      case SO_LOOKUP_ZONES_ON_ADAPTER:
        if ((TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_ZONES)))
        {
            tdiActionLength =   sizeof(ZIP_GETZONELIST_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_ZONES);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

      case SO_LOOKUP_NETDEF_ON_ADAPTER:
        if ((TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)))
        {
            tdiActionLength =   sizeof(ZIP_GETPORTDEF_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);
        }
        else
        {
            error = WSAEINVAL;
        }

        break;

      case SO_PAP_GET_SERVER_STATUS:
        if (( TdiAddressObjectHandle != NULL ) &&
            ( *OptionLength >= sizeof(WSH_PAP_GET_SERVER_STATUS)))
        {
            tdiActionLength =   sizeof(PAP_GETSTATUSSRV_ACTION) +
                                *OptionLength -
                                sizeof(SOCKADDR_AT);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

    default:

        error = WSAENOPROTOOPT;
        break;
    }

    if (error != NO_ERROR)
    {
        return(error);
    }


    tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
    if ( tdiAction == NULL )
    {
        return WSAENOBUFS;
    }

    tdiAction->TransportId = MATK;
    status = NtCreateEvent(
                 &eventHandle,
                 EVENT_ALL_ACCESS,
                 NULL,
                 SynchronizationEvent,
                 FALSE);

    if ( !NT_SUCCESS(status) )
    {
        RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
        return WSAENOBUFS;
    }

    switch ( OptionName )
    {
      case SO_LOOKUP_NAME:
        {
            PNBP_LOOKUP_ACTION nbpAction;

            nbpAction = (PNBP_LOOKUP_ACTION)tdiAction;
            nbpAction->ActionHeader.ActionCode = COMMON_ACTION_NBPLOOKUP;

            //
            // Copy the nbp name for lookup in the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.LookupTuple,
                (PCHAR)(&((PWSH_LOOKUP_NAME)OptionValue)->LookupTuple),
                sizeof(((PWSH_LOOKUP_NAME)OptionValue)->LookupTuple));

            if (!WshNbpNameToMacCodePage(
                    &((PWSH_LOOKUP_NAME)OptionValue)->LookupTuple.NbpName))
            {
                error = WSAEINVAL;
                break;
            }
        }

        break;

      case SO_CONFIRM_NAME:
        {
            PNBP_CONFIRM_ACTION nbpAction;

            nbpAction = (PNBP_CONFIRM_ACTION)tdiAction;
            nbpAction->ActionHeader.ActionCode = COMMON_ACTION_NBPCONFIRM;

            //
            // Copy the nbp name for confirm in the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.ConfirmTuple,
                (PCHAR)OptionValue,
                sizeof(WSH_NBP_TUPLE));

            if (!WshNbpNameToMacCodePage(
                    &((PWSH_NBP_TUPLE)OptionValue)->NbpName))
            {
                error = WSAEINVAL;
                break;
            }
        }

        break;

      case SO_LOOKUP_ZONES :
        {
            PZIP_GETZONELIST_ACTION zipAction;

            zipAction = (PZIP_GETZONELIST_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETZONELIST;

            //
            // No parameters need to be passed
            //
        }

        break;

      case SO_LOOKUP_NETDEF_ON_ADAPTER:
        {
            PZIP_GETPORTDEF_ACTION  zipAction;

            zipAction = (PZIP_GETPORTDEF_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETADAPTERDEFAULTS;

            //  If the string is not null-terminated, the calling process will *DIE*.
            wcsncpy(
                (PWCHAR)((PUCHAR)zipAction + sizeof(ZIP_GETPORTDEF_ACTION)),
                (PWCHAR)((PUCHAR)OptionValue + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)),
                ((tdiActionLength - sizeof(ZIP_GETPORTDEF_ACTION))/sizeof(WCHAR)));
        }

        break;

      case SO_LOOKUP_ZONES_ON_ADAPTER:
        {
            PZIP_GETZONELIST_ACTION zipAction;

            zipAction = (PZIP_GETZONELIST_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETLZONESONADAPTER;

            //  If the string is not null-terminated, the calling process will *DIE*.
            wcsncpy(
                (PWCHAR)((PUCHAR)zipAction + sizeof(ZIP_GETZONELIST_ACTION)),
                (PWCHAR)((PUCHAR)OptionValue + sizeof(WSH_LOOKUP_ZONES)),
                ((tdiActionLength - sizeof(ZIP_GETZONELIST_ACTION))/sizeof(WCHAR)));
        }

        break;

      case SO_LOOKUP_MYZONE :
        {
            PZIP_GETMYZONE_ACTION   zipAction;

            zipAction = (PZIP_GETMYZONE_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETMYZONE;
        }

        break;

      case SO_PAP_GET_SERVER_STATUS:
        {
            PPAP_GETSTATUSSRV_ACTION papAction;

            papAction = (PPAP_GETSTATUSSRV_ACTION)tdiAction;
            papAction->ActionHeader.ActionCode = ACTION_PAPGETSTATUSSRV;

            // Set the server address.
            SOCK_TO_TDI_ATALKADDR(
                &papAction->Params.ServerAddr,
                &((PWSH_PAP_GET_SERVER_STATUS)OptionValue)->ServerAddr);
        }

        break;

    default:

        //
        // Should have returned in the first switch statement
        //

        error = WSAENOPROTOOPT;
        break;
    }

    if (error != NO_ERROR)
    {
        RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
        NtClose( eventHandle );
        return (error);
    }

    status = NtDeviceIoControlFile(
                 TdiAddressObjectHandle,
                 eventHandle,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,               // Input buffer
                 0,                  // Length of input buffer
                 tdiAction,
                 tdiActionLength);

    if ( status == STATUS_PENDING )
    {
        status = NtWaitForSingleObject( eventHandle, FALSE, NULL );
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    error = WSHNtStatusToWinsockErr(status);

    //  Only copy data over if the error code is no-error or buffer too small.
    //  For a confirm, a new socket could be returned for the lookup.
    if ((error == NO_ERROR) || (error == WSAENOBUFS) ||
        ((error == WSAEADDRNOTAVAIL) && (OptionName == SO_CONFIRM_NAME)))
    {
        switch ( OptionName )
        {
          case SO_LOOKUP_NAME:
            //
            // We are guaranteed by checks in the beginning atleast one byte
            // following the buffer
            //
            {
                PNBP_LOOKUP_ACTION  nbpAction;
                PWSH_NBP_TUPLE      pNbpTuple;
                PUCHAR tdiBuffer = (PCHAR)tdiAction+sizeof(NBP_LOOKUP_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue+sizeof(WSH_LOOKUP_NAME);
                INT copySize = *OptionLength - sizeof(WSH_LOOKUP_NAME);

                nbpAction = (PNBP_LOOKUP_ACTION)tdiAction;
                ((PWSH_LOOKUP_NAME)OptionValue)->NoTuples =
                                        nbpAction->Params.NoTuplesRead;

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                //
                //  Convert all tuples from MAC to OEM code page
                //

                pNbpTuple   = (PWSH_NBP_TUPLE)userBuffer;
                while (nbpAction->Params.NoTuplesRead-- > 0)
                {
                    if (!WshNbpNameToOemCodePage(
                            &pNbpTuple->NbpName))
                    {
                        DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                                (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                        error = WSAEINVAL;
                        break;
                    }

                    pNbpTuple++;
                }
            }
            break;

          case SO_CONFIRM_NAME:
            {
                PNBP_CONFIRM_ACTION nbpAction;

                nbpAction = (PNBP_CONFIRM_ACTION)tdiAction;

                //
                // Copy the nbp name for confirm back into the option buffer
                //

                RtlCopyMemory(
                    (PCHAR)OptionValue,
                    (PCHAR)&nbpAction->Params.ConfirmTuple,
                    sizeof(WSH_NBP_TUPLE));

                //
                //  Convert NbpName from MAC to OEM code page
                //

                if (!WshNbpNameToOemCodePage(
                        &((PWSH_NBP_TUPLE)OptionValue)->NbpName))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }

            }
            break;

          case SO_LOOKUP_ZONES:
          case SO_LOOKUP_ZONES_ON_ADAPTER:
            //
            // We are guaranteed by checks in the beginning atleast one byte
            // following the buffer
            //
            {
                PZIP_GETZONELIST_ACTION zipAction;
                PUCHAR tdiBuffer = (PCHAR)tdiAction + sizeof(ZIP_GETZONELIST_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue + sizeof(WSH_LOOKUP_ZONES);
                INT copySize = *OptionLength - sizeof(WSH_LOOKUP_ZONES);

                zipAction = (PZIP_GETZONELIST_ACTION)tdiAction;
                ((PWSH_LOOKUP_ZONES)OptionValue)->NoZones=
                                            zipAction->Params.ZonesAvailable;

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                if (!WshZoneListToOemCodePage(
                        userBuffer,
                        (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }
            }
            break;

          case SO_LOOKUP_NETDEF_ON_ADAPTER:
            {
                PZIP_GETPORTDEF_ACTION  zipAction;
                PUCHAR tdiBuffer = (PCHAR)tdiAction + sizeof(ZIP_GETPORTDEF_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue +
                                    sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

                INT copySize = *OptionLength - sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

                zipAction = (PZIP_GETPORTDEF_ACTION)tdiAction;
                ((PWSH_LOOKUP_NETDEF_ON_ADAPTER)OptionValue)->NetworkRangeLowerEnd =
                    zipAction->Params.NwRangeLowEnd;

                ((PWSH_LOOKUP_NETDEF_ON_ADAPTER)OptionValue)->NetworkRangeUpperEnd =
                    zipAction->Params.NwRangeHighEnd;

                //  Copy the rest of the buffer
                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                if (!WshZoneListToOemCodePage(
                        userBuffer,
                        1))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }
            }
            break;

          case SO_LOOKUP_MYZONE :
            {
                PUCHAR tdiBuffer = (PCHAR)tdiAction+sizeof(ZIP_GETMYZONE_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue;
                INT copySize = *OptionLength;

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                if (!WshZoneListToOemCodePage(
                        userBuffer,
                        1))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }
            }
            break;

          case SO_PAP_GET_SERVER_STATUS:
            {
                PUCHAR tdiBuffer = (PCHAR)tdiAction+sizeof(PAP_GETSTATUSSRV_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue+sizeof(SOCKADDR_AT);
                INT copySize = *OptionLength - sizeof(SOCKADDR_AT);

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);
            }
            break;

          default:
            error = WSAENOPROTOOPT;
            break;
        }
    }

    RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
    NtClose( eventHandle );
    return error;

} // WSHGetSocketInformation




INT
WSHSetSocketInformation (
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  INT     Level,
    IN  INT     OptionName,
    IN  PCHAR   OptionValue,
    IN  INT     OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL. The options supported here
    are SO_REGISTERNAME/SO_DEREGISTERNAME. This routine is called by the
    winsock DLL when a level/option name combination is passed to
    setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any. If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any. If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    NTSTATUS            status;
    ULONG               tdiActionLength;
    HANDLE              objectHandle;
    PIO_STATUS_BLOCK    pIoStatusBlock;
    PTDI_ACTION_HEADER  tdiAction;

    PWSHATALK_SOCKET_CONTEXT    context = HelperDllSocketContext;
    HANDLE                      eventHandle = NULL;
    PVOID                       completionApc = NULL;
    PVOID                       apcContext = NULL;
    BOOLEAN                     freeTdiAction = FALSE;
    INT                         error = NO_ERROR;
    BOOLEAN                     waitForCompletion =(OptionName != SO_PAP_PRIME_READ);


    UNREFERENCED_PARAMETER( SocketHandle );

    DBGPRINT0(("WSHSetSocketInformation: Entered, OptionName %ld\n", OptionName));

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHATALK_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;
        }
        else
        {
            return NO_ERROR;
        }
    }

    //
    // The only level we support here is SOL_APPLETALK.
    //

    if ( Level != SOL_APPLETALK )
    {
        DBGPRINT0(("WSHSetSocketInformation: Level incorrect %d\n", Level));
        return WSAEINVAL;
    }

    //
    // Fill in the result based on the option name.
    // We support SO_REGISTERNAME/SO_DEREGISTERNAME only
    //

    pIoStatusBlock = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(IO_STATUS_BLOCK));
    if (pIoStatusBlock == NULL)
    {
        return(WSAENOBUFS);
    }


    if (waitForCompletion)
    {
        status = NtCreateEvent(
                     &eventHandle,
                     EVENT_ALL_ACCESS,
                     NULL,
                     SynchronizationEvent,
                     FALSE
                     );

        if ( !NT_SUCCESS(status) )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, pIoStatusBlock);
            DBGPRINT(("WSHSetSocketInformation: Create event failed\n"));
            return WSAENOBUFS;
        }
    }
    else
    {
        completionApc = CompleteTdiActionApc;
        apcContext = pIoStatusBlock;
    }

    switch (OptionName)
    {
      case SO_REGISTER_NAME:
        {
            PNBP_REGDEREG_ACTION    nbpAction;

            if (( TdiAddressObjectHandle == NULL) ||
                (OptionLength != sizeof(WSH_REGISTER_NAME)))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the address handle
            objectHandle = TdiAddressObjectHandle;

            tdiActionLength = sizeof(NBP_REGDEREG_ACTION);
            tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
            if ( tdiAction == NULL )
            {
                error = WSAENOBUFS;
                break;
            }

            freeTdiAction = TRUE;

            tdiAction->TransportId = MATK;
            tdiAction->ActionCode = COMMON_ACTION_NBPREGISTER;
            nbpAction = (PNBP_REGDEREG_ACTION)tdiAction;

            //
            // Copy the nbp name to the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.RegisterTuple.NbpName,
                OptionValue,
                OptionLength);

            //
            // Convert the tuple to MAC code page
            //

            if (!WshNbpNameToMacCodePage(
                    (PWSH_REGISTER_NAME)OptionValue))
            {
                error = WSAEINVAL;
                break;
            }
        }
        break;

      case SO_DEREGISTER_NAME:
        {
            PNBP_REGDEREG_ACTION    nbpAction;

            if (( TdiAddressObjectHandle == NULL) ||
                (OptionLength != sizeof(WSH_DEREGISTER_NAME)))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the address handle
            objectHandle = TdiAddressObjectHandle;

            tdiActionLength = sizeof(NBP_REGDEREG_ACTION);
            tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
            if ( tdiAction == NULL )
            {
                error = WSAENOBUFS;
                break;
            }

            freeTdiAction = TRUE;

            tdiAction->TransportId = MATK;
            tdiAction->ActionCode = COMMON_ACTION_NBPREMOVE;
            nbpAction = (PNBP_REGDEREG_ACTION)tdiAction;

            //
            // Copy the nbp name to the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.RegisteredTuple.NbpName,
                OptionValue,
                OptionLength);

            //
            // Convert the tuple to MAC code page
            //

            if (!WshNbpNameToMacCodePage(
                    (PWSH_DEREGISTER_NAME)OptionValue))
            {
                error = WSAEINVAL;
                break;
            }
        }
        break;

      case SO_PAP_SET_SERVER_STATUS:
        {
            PPAP_SETSTATUS_ACTION   papAction;

            if (( TdiAddressObjectHandle == NULL) ||
                (OptionLength < 0))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the address handle
            objectHandle = TdiAddressObjectHandle;

            tdiActionLength = (ULONG)OptionLength +
                                (ULONG)(sizeof(PAP_SETSTATUS_ACTION));

            DBGPRINT0(("ActionLen %lx\n", tdiActionLength));

            tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
            if ( tdiAction == NULL )
            {
                error = WSAENOBUFS;
                break;
            }

            freeTdiAction = TRUE;

            tdiAction->TransportId = MATK;
            tdiAction->ActionCode = ACTION_PAPSETSTATUS;
            papAction = (PPAP_SETSTATUS_ACTION)tdiAction;

            DBGPRINT0(("Setting Status len %lx\n", OptionLength));

            //
            // Copy the passed status into our buffer
            //

            if (OptionLength > 0)
            {
                RtlCopyMemory(
                    (PCHAR)papAction + sizeof(PAP_SETSTATUS_ACTION),
                    OptionValue,
                    OptionLength);
            }
        }
        break;

      case SO_PAP_PRIME_READ :
        {
            tdiAction = (PTDI_ACTION_HEADER)OptionValue;
            tdiActionLength = OptionLength;

            ASSERT(waitForCompletion == FALSE);

            if ((TdiConnectionObjectHandle == NULL) ||
                (OptionLength < MIN_PAP_READ_BUF_SIZE))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the connection handle
            objectHandle = TdiConnectionObjectHandle;

            //  These will get overwritten by the incoming data.
            tdiAction->TransportId  = MATK;
            tdiAction->ActionCode   = ACTION_PAPPRIMEREAD;

            //  This is the caller's buffer! Dont free it! Also, we dont wait
            //  for this to complete.
            freeTdiAction = FALSE;

            // We potentially have an APC waiting to be delivered from a
            // previous setsockopt(). Give it a chance
            NtTestAlert();
        }
        break;

    default:
        error = WSAENOPROTOOPT;
        break;
    }

    if (error != NO_ERROR)
    {
        if (freeTdiAction)
        {
            RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
        }

        if (waitForCompletion)
        {
            NtClose(eventHandle);
        }

        RtlFreeHeap( RtlProcessHeap(), 0, pIoStatusBlock);
        return(error);
    }

    status = NtDeviceIoControlFile(
                 objectHandle,
                 eventHandle,
                 completionApc,
                 apcContext,
                 pIoStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,               // Input buffer
                 0,                  // Length of input buffer
                 tdiAction,
                 tdiActionLength
                 );

    if ( status == STATUS_PENDING )
    {
        if (waitForCompletion)
        {
            status = NtWaitForSingleObject( eventHandle, FALSE, NULL );
            ASSERT( NT_SUCCESS(status) );
            status = pIoStatusBlock->Status;
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }

    if (freeTdiAction)
    {
        RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
    }

    //  Close the event
    if (waitForCompletion)
    {
        NtClose(eventHandle);
        RtlFreeHeap( RtlProcessHeap( ), 0, pIoStatusBlock );
    }

    return (WSHNtStatusToWinsockErr(status));

} // WSHSetSocketInformation




DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING    Mapping,
    IN  DWORD               MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL. If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD   mappingLength;
    ULONG   offset;

    DBGPRINT0(("WSHGetWinsockMapping: Entered\n"));

    mappingLength = sizeof(WINSOCK_MAPPING) -
                    sizeof(MAPPING_TRIPLE) +
                    sizeof(AdspStreamMappingTriples) +
                    sizeof(AdspMsgMappingTriples) +
                    sizeof(PapMsgMappingTriples) +
                    sizeof(DdpMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer. The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength )
    {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows =
        sizeof(AdspStreamMappingTriples) / sizeof(AdspStreamMappingTriples[0]) +
        sizeof(AdspMsgMappingTriples) / sizeof(AdspMsgMappingTriples[0]) +
        sizeof(PapMsgMappingTriples) / sizeof(PapMsgMappingTriples[0]) +
        sizeof(DdpMappingTriples) / sizeof(DdpMappingTriples[0]);

    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);

    offset = 0;
    RtlCopyMemory(
        Mapping->Mapping,
        AdspStreamMappingTriples,
        sizeof(AdspStreamMappingTriples));

    offset += sizeof(AdspStreamMappingTriples);
    RtlCopyMemory(
        (PCHAR)Mapping->Mapping + offset,
        AdspMsgMappingTriples,
        sizeof(AdspMsgMappingTriples));

    offset += sizeof(AdspMsgMappingTriples);
    RtlCopyMemory(
        (PCHAR)Mapping->Mapping + offset,
        PapMsgMappingTriples,
        sizeof(PapMsgMappingTriples));

    offset += sizeof(PapMsgMappingTriples);
    RtlCopyMemory(
        (PCHAR)Mapping->Mapping + offset,
        DdpMappingTriples,
        sizeof(DdpMappingTriples));

    //
    // Return the number of bytes we wrote.
    //

    DBGPRINT0(("WSHGetWinsockMapping: Mapping Length = %d\n", mappingLength));

    return mappingLength;

} // WSHGetWinsockMapping




INT
WSHOpenSocket (
    IN  OUT PINT        AddressFamily,
    IN  OUT PINT        SocketType,
    IN  OUT PINT        Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID   *       HelperDllSocketContext,
    OUT PDWORD          NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine. This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call. On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call. On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATALK_SOCKET_CONTEXT    context;

    DBGPRINT0(("WSHOpenSocket: Entered\n"));

    //
    // Determine whether this is to be a TCP or UDP socket.
    //

    if ( IsTripleInList(
             AdspStreamMappingTriples,
             sizeof(AdspStreamMappingTriples) / sizeof(AdspStreamMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) )
    {
        //
        // Indicate the name of the TDI device that will service
        // SOCK_STREAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, WSH_ATALK_ADSPRDM );

    }
    else if ( IsTripleInList(
                    AdspMsgMappingTriples,
                    sizeof(AdspMsgMappingTriples) / sizeof(AdspMsgMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        //
        // Indicate the name of the TDI device that will service
        // SOCK_RDM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, WSH_ATALK_ADSPRDM );

    }
    else if ( IsTripleInList(
                    PapMsgMappingTriples,
                    sizeof(PapMsgMappingTriples) / sizeof(PapMsgMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        //
        // Indicate the name of the TDI device that will service
        // SOCK_RDM sockets in the appletalk address family.
        //

        RtlInitUnicodeString( TransportDeviceName, WSH_ATALK_PAPRDM );

    }
    else
    {
        BOOLEAN tripleFound = FALSE;

        //
        // Check the DDP triples
        //

        if ( IsTripleInList(
                    DdpMappingTriples,
                    sizeof(DdpMappingTriples) / sizeof(DdpMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
        {
            tripleFound = TRUE;

            //
            // Indicate the name of the TDI device that will service
            // SOCK_DGRAM sockets in the appletalk address family.
            //

            RtlInitUnicodeString(
                TransportDeviceName,
                WSH_ATALK_DGRAMDDP[(*Protocol) - ATPROTO_BASE - 1] );

            DBGPRINT0(("WSHOpenSocket: Protocol number %d index %d\n",
                        (*Protocol) , (*Protocol) - ATPROTO_BASE - 1));
        }

        //
        // This should never happen if the registry information about this
        // helper DLL is correct. If somehow this did happen, just return
        // an error.
        //

        if (!tripleFound)
        {
            return WSAEINVAL;
        }
    }

    //
    // Allocate context for this socket. The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL )
    {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.
    //

    *NotificationEvents = WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE;

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket




INT
WSHNotify (
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  DWORD   NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket. Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any. If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any. If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    PWSHATALK_SOCKET_CONTEXT context = HelperDllSocketContext;

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CONNECT )
    {
        //
        // Just for debugging right now
        //

        DBGPRINT0(("WSHNotify: Connect completed, notify called!\n"));
    }
    else if ( NotifyEvent == WSH_NOTIFY_CLOSE )
    {
        //
        // Just free the socket context.
        //

        DBGPRINT0(("WSHNotify: Close notify called!\n"));

        RtlFreeHeap( RtlProcessHeap( ), 0, HelperDllSocketContext );
    }
    else
    {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify




INT
WSHNtStatusToWinsockErr(
    IN  NTSTATUS    Status
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    INT error;

    switch (Status)
    {
        case STATUS_SUCCESS:            error = NO_ERROR;
                                        break;

        case STATUS_BUFFER_OVERFLOW:
        case STATUS_BUFFER_TOO_SMALL:   error = WSAENOBUFS;
                                        break;

        case STATUS_INVALID_ADDRESS:    error = WSAEADDRNOTAVAIL;
                                        break;
        case STATUS_SHARING_VIOLATION:  error = WSAEADDRINUSE;
                                        break;

        default:                        error = WSAEINVAL;
                                        break;
    }

    DBGPRINT0(("WSHNtStatusToWinsockErr: Converting %lx to %lx\n", Status, error));
    return(error);
}




BOOLEAN
IsTripleInList (
    IN  PMAPPING_TRIPLE List,
    IN  ULONG           ListLength,
    IN  INT             AddressFamily,
    IN  INT             SocketType,
    IN  INT             Protocol
    )
/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/
{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ )
    {
        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             Protocol == List[i].Protocol )
        {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList




VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    //
    // Just free the heap we allovcated to hold the IO status block and
    // the TDI action buffer.  There is nothing we can do if the call
    // failed.
    //

    RtlFreeHeap( RtlProcessHeap( ), 0, ApcContext );

} // CompleteTdiActionApc




BOOLEAN
WshNbpNameToMacCodePage(
    IN  OUT PWSH_NBP_NAME   pNbpName
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    USHORT  destLen;
    BOOLEAN retVal  = FALSE;

    do
    {
        destLen = MAX_ENTITY;
        if (!WshConvertStringOemToMac(
                pNbpName->ObjectName,
                pNbpName->ObjectNameLen,
                pNbpName->ObjectName,
                &destLen))
        {
            break;
        }

        pNbpName->ObjectNameLen = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringOemToMac(
                pNbpName->TypeName,
                pNbpName->TypeNameLen,
                pNbpName->TypeName,
                &destLen))
        {
            break;
        }

        pNbpName->TypeNameLen   = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringOemToMac(
                pNbpName->ZoneName,
                pNbpName->ZoneNameLen,
                pNbpName->ZoneName,
                &destLen))
        {
            break;
        }

        pNbpName->ZoneNameLen   = (CHAR)destLen;
        retVal                  = TRUE;

    } while (FALSE);

    return(retVal);
}




BOOLEAN
WshNbpNameToOemCodePage(
    IN  OUT PWSH_NBP_NAME   pNbpName
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    USHORT  destLen;
    BOOLEAN retVal  = FALSE;

    do
    {
        destLen = MAX_ENTITY;
        if (!WshConvertStringMacToOem(
                pNbpName->ObjectName,
                pNbpName->ObjectNameLen,
                pNbpName->ObjectName,
                &destLen))
        {
            break;
        }

        pNbpName->ObjectNameLen = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringMacToOem(
                pNbpName->TypeName,
                pNbpName->TypeNameLen,
                pNbpName->TypeName,
                &destLen))
        {
            break;
        }

        pNbpName->TypeNameLen   = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringMacToOem(
                pNbpName->ZoneName,
                pNbpName->ZoneNameLen,
                pNbpName->ZoneName,
                &destLen))
        {
            break;
        }

        pNbpName->ZoneNameLen   = (CHAR)destLen;
        retVal                  = TRUE;

    } while (FALSE);

    return(retVal);
}




BOOLEAN
WshZoneListToOemCodePage(
    IN  OUT PUCHAR      pZoneList,
    IN      USHORT      NumZones
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    USHORT  zoneLen;
    BOOLEAN retVal  = TRUE;
    PUCHAR  pCurZone = pZoneList, pNextZone = NULL, pCopyZone = pZoneList;

    while (NumZones-- > 0)
    {
        zoneLen     = strlen(pCurZone) + 1;
        pNextZone   = pCurZone + zoneLen;

        //  Modify current zone. This could decrease its length
        if (!WshConvertStringMacToOem(
                pCurZone,
                zoneLen,
                pCopyZone,
                &zoneLen))
        {
            DBGPRINT(("WshZoneListToOemCodePage: FAILED %s-%d\n",
                        pCurZone, zoneLen));

            retVal  = FALSE;
            break;
        }

        pCopyZone   += zoneLen;
        pCurZone     = pNextZone;
    }

    return(retVal);
}




BOOLEAN
WshConvertStringOemToMac(
    IN  PUCHAR  pSrcOemString,
    IN  USHORT  SrcStringLen,
    OUT PUCHAR  pDestMacString,
    IN  PUSHORT pDestStringLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    WCHAR           wcharBuf[MAX_ENTITY + 1];
    INT             wcharLen, destLen;
    BOOLEAN         retCode = TRUE;

    do
    {
        if ((SrcStringLen > (MAX_ENTITY+1)) ||
            (*pDestStringLen < SrcStringLen))
        {
            DBGPRINT(("WshConvertStringOemToMac: Invalid len %d.%d\n",
                        SrcStringLen, *pDestStringLen));

            retCode = FALSE;
            break;
        }

        //  Convert the src string using the OEM codepage.
        if ((wcharLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            pSrcOemString,
                            SrcStringLen,
                            wcharBuf,
                            MAX_ENTITY + 1)) == FALSE)
        {
            DBGPRINT(("WshConvertStringOemToMac: FAILED mbtowcs %s-%d\n",
                        pSrcOemString, SrcStringLen));

            retCode = FALSE;
            break;
        }

        DBGPRINT0(("WshConvertStringOemToMac: Converting mbtowcs %s-%d\n",
                    pSrcOemString, SrcStringLen));
        //  Convert the wide char string to mac ansi string.
        if ((destLen = WideCharToMultiByte(
                            WshMacCodePage,
                            0,
                            wcharBuf,
                            wcharLen,
                            pDestMacString,
                            *pDestStringLen,
                            NULL,
                            NULL)) == FALSE)
        {
            DBGPRINT(("WshConvertStringOemToMac: FAILED wctomb %s-%d\n",
                        pDestMacString, *pDestStringLen));

            retCode = FALSE;
            break;
        }

        *pDestStringLen = (USHORT)destLen;

        DBGPRINT0(("WshConvertStringOemToMac: Converted mbtowcs %s-%d\n",
                    pDestMacString, *pDestStringLen));


    } while (FALSE);

    return(retCode);
}




BOOLEAN
WshConvertStringMacToOem(
    IN  PUCHAR  pSrcMacString,
    IN  USHORT  SrcStringLen,
    OUT PUCHAR  pDestOemString,
    IN  PUSHORT pDestStringLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    WCHAR           wcharBuf[MAX_ENTITY + 1];
    INT             wcharLen, destLen;
    BOOLEAN         retCode = TRUE;

    do
    {
        if ((SrcStringLen > (MAX_ENTITY+1)) ||
            (*pDestStringLen < SrcStringLen))
        {
            retCode = FALSE;
            break;
        }

        //  Convert the src string using the MAC codepage.
        if ((wcharLen = MultiByteToWideChar(
                            WshMacCodePage,
                            MB_PRECOMPOSED,
                            pSrcMacString,
                            SrcStringLen,
                            wcharBuf,
                            MAX_ENTITY + 1)) == FALSE)
        {
            DBGPRINT(("WshConvertStringMacToOem: FAILED mbtowcs %s-%d\n",
                        pSrcMacString, SrcStringLen));

            retCode = FALSE;
            break;
        }

        DBGPRINT0(("WshConvertStringMacToOem: Converting mbtowcs %s-%d\n",
                    pSrcMacString, SrcStringLen));

        //  Convert the wide char string to mac ansi string.
        if ((destLen = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            wcharBuf,
                            wcharLen,
                            pDestOemString,
                            *pDestStringLen,
                            NULL,
                            NULL)) == FALSE)
        {
            DBGPRINT(("WshConvertStringMacToOem: FAILED wctomb %s-%d\n",
                        pDestOemString, *pDestStringLen));

            retCode = FALSE;
            break;
        }

        *pDestStringLen = (USHORT)destLen;

        DBGPRINT0(("WshConvertStringMacToOem: Converted mbtowcs %s-%d\n",
                    pDestOemString, *pDestStringLen));
    } while (FALSE);

    return(retCode);
}




BOOLEAN
WshRegGetCodePage(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD           dwRetCode;
    HKEY            hkeyCodepagePath;
    DWORD           dwType;
    DWORD           dwBufSize;
    WCHAR           wchCodepageNum[60];
    UNICODE_STRING  wchUnicodeCodePage;
    NTSTATUS        status;

    // Open the key
    if (dwRetCode = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        WSH_KEYPATH_CODEPAGE,
                        0,
                        KEY_QUERY_VALUE,
                        &hkeyCodepagePath))
        return(FALSE);


    // Get the Code page number value for the Mac
    dwBufSize = sizeof(wchCodepageNum);
    if (dwRetCode = RegQueryValueEx(
                        hkeyCodepagePath,
                        WSHREG_VALNAME_CODEPAGE,
                        NULL,
                        &dwType,
                        (LPBYTE)wchCodepageNum,
                        &dwBufSize))
        return(FALSE);

    // Close the key
    RegCloseKey(hkeyCodepagePath);

    //  Convert the code page to a numerical value
    RtlInitUnicodeString(&wchUnicodeCodePage, wchCodepageNum);
    status  = RtlUnicodeStringToInteger(
                &wchUnicodeCodePage,
                DECIMAL_BASE,
                &WshMacCodePage);

    DBGPRINT0(("WSHGetCodePage %lx.%d\n", WshMacCodePage, WshMacCodePage));

    return(NT_SUCCESS(status));
}


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,       // unused
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    This routine returns information about the protocols active on the local host.
Arguments:

    lpiProtocols - a NULL terminated array of protocol ids.  This parameter
        is optional; if NULL, information on all available protocols is returned.

    lpTransportKeyName -  unused

    lpProtocolBuffer - a buffer which is filled with PROTOCOL_INFO structures.

    lpdwBufferLength - on input, the count of bytes in the lpProtocolBuffer passed
        to EnumProtocols.  On output, the minimum buffersize that can be passed to
        EnumProtocols to retrieve all the requested information.  This routine has
        no ability to enumerate over multiple calls; the passed in buffer must be
        large enough to hold all entries in order for the routine to succeed.

Return Value:
    If no error occurs, it returns the number of PROTOCOL_INFO structures written to
    the lpProtocolBuffer buffer.  If there is an error, returns SOCKET_ERROR (-1) and
    a specific error code is retrieved with the GetLastError() API.


--*/
{
    DWORD bytesRequired;
    PPROTOCOL_INFO NextProtocolInfo;
    LPWSTR NextName;
    BOOL usePap = FALSE;
    BOOL useAdsp = FALSE;
    BOOL useRtmp = FALSE;
    BOOL useZip = FALSE;
    DWORD i, numRequested = 0;

    lpTransportKeyName;         // Avoid compiler warnings for unused parm

    //
    // Make sure that the caller cares about PAP and/or ADSP
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) )
    {
        for ( i = 0; lpiProtocols[i] != 0; i++ )
        {
            if ( lpiProtocols[i] == ATPROTO_ADSP )
            {
                useAdsp = TRUE;
                numRequested += 1;
            }
            if ( lpiProtocols[i] == ATPROTO_PAP )
            {
                usePap = TRUE;
                numRequested += 1;
            }
            if ( lpiProtocols[i] == DDPPROTO_RTMP )
            {
                useRtmp = TRUE;
                numRequested += 1;
            }
            if ( lpiProtocols[i] == DDPPROTO_ZIP )
            {
                useZip = TRUE;
                numRequested += 1;
            }
        }

    } else
    {
        usePap = TRUE;
        useAdsp = TRUE;
        useRtmp = TRUE;
        useZip = TRUE;
        numRequested = 4;
    }

    if ( !usePap && !useAdsp && !useRtmp && !useZip)
    {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (sizeof(PROTOCOL_INFO) * numRequested);
    if (useAdsp)
    {
        bytesRequired += sizeof( ADSP_NAME );
    }
    if (usePap)
    {
        bytesRequired += sizeof( PAP_NAME );
    }
    if (useRtmp)
    {
        bytesRequired += sizeof( RTMP_NAME );
    }
    if (useZip)
    {
        bytesRequired += sizeof( ZIP_NAME );
    }

    if ( bytesRequired > *lpdwBufferLength )
    {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    NextProtocolInfo = lpProtocolBuffer;
    NextName = (LPWSTR)( (LPBYTE)lpProtocolBuffer + *lpdwBufferLength );

    //
    // Fill in ADSP info, if requested.
    //

    if ( useAdsp ) {

        // Adsp - note that even though we return iSocketType of SOCK_RDM, the
        // fact that the XP_PSUEDO_STREAM service flag is set tells the caller
        // they can actually open a adsp socket in SOCK_STREAM mode as well.
        NextName -= sizeof( ADSP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_EXPEDITED_DATA |
                                           XP_GUARANTEED_ORDER |
                                           XP_GUARANTEED_DELIVERY |
                                           XP_MESSAGE_ORIENTED |
                                           XP_PSEUDO_STREAM |
                                           XP_GRACEFUL_CLOSE;

        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_RDM;
        NextProtocolInfo->iProtocol = ATPROTO_ADSP;
        NextProtocolInfo->dwMessageSize = 65535;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, ADSP_NAME );

        NextProtocolInfo++;
    }

    //
    // Fill in PAP info, if requested.
    //

    if ( usePap ) {

        NextName -= sizeof( PAP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_MESSAGE_ORIENTED |
                                          XP_GUARANTEED_DELIVERY |
                                          XP_GUARANTEED_ORDER |
                                          XP_GRACEFUL_CLOSE;
        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_RDM;
        NextProtocolInfo->iProtocol = ATPROTO_PAP;
        NextProtocolInfo->dwMessageSize = 4096;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, PAP_NAME );

        NextProtocolInfo++;
    }

    if ( useRtmp ) {

        NextName -= sizeof( RTMP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS;
        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_DGRAM;
        NextProtocolInfo->iProtocol = DDPPROTO_RTMP;
        NextProtocolInfo->dwMessageSize = 0;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, RTMP_NAME );

        NextProtocolInfo++;

    }

    if ( useZip ) {

        NextName -= sizeof( ZIP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS;
        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_DGRAM;
        NextProtocolInfo->iProtocol = DDPPROTO_ZIP;
        NextProtocolInfo->dwMessageSize = 0;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, ZIP_NAME );

        NextProtocolInfo++;

    }

    *lpdwBufferLength = bytesRequired;

    return numRequested;

} // WSHEnumProtocols


BOOL FAR PASCAL
WshDllInitialize(
    HINSTANCE   hInstance,
    DWORD       nReason,
    LPVOID      pReserved
    )
/*++

Routine Description:

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

Arguments:

    ENTRY:    hInstance             - A handle to the DLL.

                nReason              - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

Return Value:

    RETURNS:    BOOL                    - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:    The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

--*/
{
    BOOL fResult = TRUE;

    UNREFERENCED_PARAMETER( pReserved );

    switch( nReason  )
    {
      case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = WshRegGetCodePage();
        break;

      case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        break;

      case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

      case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\zip.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	zip.c

Abstract:

	This module contains

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ZIP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AtalkZipInit)
#pragma alloc_text(PAGEINIT, AtalkInitZipStartProcessingOnPort)
#pragma alloc_text(PAGEINIT, atalkZipGetZoneListForPort)
#pragma alloc_text(PAGE_RTR, AtalkZipPacketInRouter)
#pragma alloc_text(PAGE_RTR, atalkZipHandleNetInfo)
#pragma alloc_text(PAGE_RTR, atalkZipHandleReply)
#pragma alloc_text(PAGE_RTR, atalkZipHandleQuery)
#pragma alloc_text(PAGE_RTR, atalkZipHandleAtpRequest)
#pragma alloc_text(PAGE_RTR, atalkZipQueryTimer)
#pragma alloc_text(PAGE_NZ, AtalkZipGetMyZone)
#pragma alloc_text(PAGE_NZ, atalkZipGetMyZoneReply)
#pragma alloc_text(PAGE_NZ, AtalkZipGetZoneList)
#pragma alloc_text(PAGE_NZ, atalkZipGetZoneListReply)
#pragma alloc_text(PAGE_NZ, atalkZipZoneInfoTimer)
#pragma alloc_text(PAGE_NZ, atalkZipSendPacket)
#endif


/***	AtalkZipInit
 *
 */
ATALK_ERROR
AtalkZipInit(
	IN	BOOLEAN	Init
)
{
	if (Init)
	{
		// Allocate space for zones
		AtalkZonesTable = (PZONE *)AtalkAllocZeroedMemory(sizeof(PZONE) * NUM_ZONES_HASH_BUCKETS);
		if (AtalkZonesTable == NULL)
		{
			return ATALK_RESR_MEM;
		}

		INITIALIZE_SPIN_LOCK(&AtalkZoneLock);
	}
	else
	{
		// At this point, we are unloading and there are no race conditions
		// or lock contentions. Do not bother locking down the zones table
		if (AtalkDesiredZone != NULL)
			AtalkZoneDereference(AtalkDesiredZone);
		if (AtalkZonesTable != NULL)
		{
			AtalkFreeMemory(AtalkZonesTable);
			AtalkZonesTable = NULL;
		}
	}
	return ATALK_NO_ERROR;
}


/***	AtalkZipStartProcessingOnPort
 *
 */
BOOLEAN
AtalkInitZipStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 	pPortDesc,
	IN	PATALK_NODEADDR		pRouterNode
)
{
	ATALK_ADDR		closeAddr;
	ATALK_ERROR		Status;
	KIRQL			OldIrql;
	BOOLEAN			RetCode = FALSE;
    PDDP_ADDROBJ    pZpDdpAddr=NULL;

	// Switch the incoming zip handler to the router version
	closeAddr.ata_Network = pRouterNode->atn_Network;
	closeAddr.ata_Node = pRouterNode->atn_Node;
	closeAddr.ata_Socket  = ZONESINFORMATION_SOCKET;

	do
	{
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags |= PD_ROUTER_STARTING;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
		// Close the non-router version of the handler and start the router version
		AtalkDdpInitCloseAddress(pPortDesc, &closeAddr);
		if (!ATALK_SUCCESS(Status = AtalkDdpOpenAddress(pPortDesc,
														ZONESINFORMATION_SOCKET,
														pRouterNode,
														AtalkZipPacketInRouter,
														NULL,
														DDPPROTO_ANY,
														NULL,
														&pZpDdpAddr)))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkZipStartProcessingOnPort: AtalkDdpOpenAddress failed %ld\n",
					Status));
			break;
		}

        // mark the fact that this is an "internal" socket
        pZpDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;
	
		// Try to get or set the zone information
		if (!atalkZipGetZoneListForPort(pPortDesc))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("AtalkZipStartProcessingOnPort: Failed to get zone list for port\n"));
			break;
		}

		if (!atalkZipQryTmrRunning)
		{
			AtalkTimerInitialize(&atalkZipQTimer,
								 atalkZipQueryTimer,
								 ZIP_QUERY_TIMER);
			AtalkTimerScheduleEvent(&atalkZipQTimer);

            atalkZipQryTmrRunning = TRUE;
		}
	
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags &= ~PD_ROUTER_STARTING;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		RetCode = TRUE;
	} while (FALSE);

	return RetCode;
}


/***	AtalkZipPacketIn
 *
 */
VOID
AtalkZipPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			Status,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)
{
	BYTE			CmdType, Flags;
	BYTE			ZoneLen, DefZoneLen, MulticastAddrLen;
	PBYTE			pZone, pDefZone, pMulticastAddr;
	TIME			TimeS, TimeE, TimeD;
	ULONG			Index;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);
	do
	{
		if ((Status == ATALK_SOCKET_CLOSED) ||
			(DdpType != DDPPROTO_ZIP))
			break;

		else if (Status != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (!EXT_NET(pPortDesc))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

        if (PktLen < ZIP_CMD_OFF+1)
        {
            break;
        }

		CmdType = pPkt[ZIP_CMD_OFF];

		// We only care about Zip Notifies and NetInfo replies
		if (((CmdType != ZIP_NOTIFY) && (CmdType != ZIP_NETINFO_REPLY)) ||
			(PktLen < (ZIP_ZONELEN_OFF + 1)))
		{
			break;
		}

		// If it is a NetInfoReply, then we should be looking for either the
		// default or the desired zone
		if ((CmdType != ZIP_NETINFO_REPLY) &&
			(pPortDesc->pd_Flags & (PD_FINDING_DEFAULT_ZONE | PD_FINDING_DESIRED_ZONE)))
			break;

		if ((CmdType == ZIP_NETINFO_REPLY) &&
			!(pPortDesc->pd_Flags & (PD_FINDING_DEFAULT_ZONE | PD_FINDING_DESIRED_ZONE)))
			break;

		// If it is a Notify then the desired zone must be valid
		if ((CmdType == ZIP_NOTIFY) &&
			!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
			break;

		// We have a NetInfoReply or a Notify. Handle it
		Flags = pPkt[ZIP_FLAGS_OFF];
		Index = ZIP_ZONELEN_OFF;

		ZoneLen = pPkt[ZIP_ZONELEN_OFF];
		Index ++;

		if ((ZoneLen > MAX_ZONE_LENGTH) || (PktLen < (Index + ZoneLen)))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		pZone = pPkt+Index;
		Index += ZoneLen;

        // If we are looking for a desired zone and we get a late default zone
        // response then toss this packet
        if ((CmdType == ZIP_NETINFO_REPLY) && (ZoneLen == 0) &&
			(pPortDesc->pd_Flags & (PD_FINDING_DESIRED_ZONE)) &&
            (pPortDesc->pd_InitialDesiredZone != NULL))
        {
            DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
                ("AtalkZipPacketIn: dropping a NetInfoReply packet\n"));
			break;
        }


		// If we're requesting the zone name, make sure the response matches
		// our request. ZoneLen will be zero when we're looking for the def
		// zone, so we won't do this test
		if ((CmdType == ZIP_NETINFO_REPLY) &&
			(ZoneLen != 0) &&
			(pPortDesc->pd_InitialDesiredZone != NULL))
		{
			BOOLEAN NoMatch = FALSE;

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			ASSERT(!(pPortDesc->pd_Flags & PD_ROUTER_RUNNING) ||
					(pPortDesc->pd_Flags & PD_FINDING_DESIRED_ZONE));
			if (!AtalkFixedCompareCaseInsensitive(pZone,
												  ZoneLen,
												  pPortDesc->pd_InitialDesiredZone->zn_Zone,
												  pPortDesc->pd_InitialDesiredZone->zn_ZoneLen))
			{
				NoMatch = TRUE;
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (NoMatch)
				break;
		}
		
		// If its a Notify, make sure we're in the zone that is being changed
		if (CmdType == ZIP_NOTIFY)
		{
			BOOLEAN NoMatch = FALSE;

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (!AtalkFixedCompareCaseInsensitive(pZone, ZoneLen,
								pPortDesc->pd_DesiredZone->zn_Zone,
								pPortDesc->pd_DesiredZone->zn_ZoneLen))
			{
				NoMatch = TRUE;
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (NoMatch)
				break;
		}

		if (PktLen < (Index + 1))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		MulticastAddrLen = pPkt[Index++];
		if (MulticastAddrLen != pPortDesc->pd_BroadcastAddrLen)
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		if (PktLen < (Index + MulticastAddrLen))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}
		pMulticastAddr = pPkt + Index;
		Index += MulticastAddrLen;
#if 0
		if (Flags & ZIP_USE_BROADCAST_FLAG)
			pMulticastAddr = pPortDesc->pd_BroadcastAddr;
#endif
		// Grab second name, if needed or present
		DefZoneLen = 0;
		if ((CmdType == ZIP_NOTIFY) || (PktLen  > Index))
		{
			if (PktLen < (Index+1))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			DefZoneLen = pPkt[Index++];
			if ((DefZoneLen == 0) ||
				(DefZoneLen > MAX_ZONE_LENGTH) ||
				(PktLen < (Index+DefZoneLen)))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			pDefZone = pPkt+Index;
			Index += DefZoneLen;
		}

		// Make default zone be the new one. We may not have a default/new
		// zone in netinfo reply case and we requested for the correct zone
		if (DefZoneLen == 0)
		{
			pDefZone = pZone;
			DefZoneLen = ZoneLen;
		}

		//	Make sure the port lock is released before calling any depend/ddp
		//	etc. routines.
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		// If we're just looking for the default zone, set here and note
		// our mission completed
		if ((pPortDesc->pd_Flags & PD_FINDING_DEFAULT_ZONE) &&
			(ZoneLen == 0))
		{
            if (pPortDesc->pd_DefaultZone != NULL)
				AtalkZoneDereference(pPortDesc->pd_DefaultZone);
			pPortDesc->pd_DefaultZone = AtalkZoneReferenceByName(pDefZone, DefZoneLen);
			if (pPortDesc->pd_DefaultZone == NULL)
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				RES_LOG_ERROR();
				break;
			}
			pPortDesc->pd_Flags |= PD_VALID_DEFAULT_ZONE;
			pPortDesc->pd_Flags &= ~PD_FINDING_DEFAULT_ZONE;
		}

		// Now we want to accept all of the information about 'thiszone'
		// for the nodes on the current port
		// If the new multicast address is different, remove the old and
		// set the new. Don't allow changes to the 'broadcast' multicast
		// address.
		if (pPortDesc->pd_Flags & PD_FINDING_DESIRED_ZONE)
		{
			if (!AtalkFixedCompareCaseSensitive(pMulticastAddr,
												MulticastAddrLen,
												pPortDesc->pd_ZoneMulticastAddr,
												MulticastAddrLen))
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
													 pMulticastAddr,
													 FALSE,
													 NULL,
													 NULL);
				ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			}
	
			if (!AtalkFixedCompareCaseSensitive(pMulticastAddr,
												MulticastAddrLen,
												pPortDesc->pd_BroadcastAddr,
												MulticastAddrLen))
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				(*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
												  pMulticastAddr,
												  FALSE,
												  NULL,
												  NULL);
				ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			}
	
			RtlCopyMemory(pPortDesc->pd_ZoneMulticastAddr,
						  pMulticastAddr,
						  MulticastAddrLen);
		}

		// Finally set this cable range if this is a net info reply
		if (CmdType == ZIP_NETINFO_REPLY)
		{
			GETSHORT2SHORT(&pPortDesc->pd_NetworkRange.anr_FirstNetwork,
						   pPkt+ZIP_CABLE_RANGE_START_OFF);
			GETSHORT2SHORT(&pPortDesc->pd_NetworkRange.anr_LastNetwork,
						   pPkt+ZIP_CABLE_RANGE_END_OFF);
			if (!(pPortDesc->pd_Flags & PD_ROUTER_STARTING))
			{
				pPortDesc->pd_ARouter.atn_Network = pSrcAddr->ata_Network;
				pPortDesc->pd_ARouter.atn_Node = pSrcAddr->ata_Node;
			}
			pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
			KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
		}
		
		// Now that we know the zone
		if (pPortDesc->pd_Flags & PD_FINDING_DESIRED_ZONE)
		{
			pPortDesc->pd_Flags &= ~PD_FINDING_DESIRED_ZONE;
			pPortDesc->pd_Flags |= PD_VALID_DESIRED_ZONE;
			if (pPortDesc->pd_DesiredZone != NULL)
				AtalkZoneDereference(pPortDesc->pd_DesiredZone);
			pPortDesc->pd_DesiredZone = AtalkZoneReferenceByName(pDefZone, DefZoneLen);
			if (pPortDesc->pd_DesiredZone == NULL)
			{
				pPortDesc->pd_Flags &= ~PD_VALID_DESIRED_ZONE;
				RES_LOG_ERROR();
			}
		}

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		TimeE = KeQueryPerformanceCounter(NULL);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	
		INTERLOCKED_ADD_LARGE_INTGR_DPC(
			&pPortDesc->pd_PortStats.prtst_ZipPacketInProcessTime,
			TimeD,
			&AtalkStatsLock.SpinLock);
	
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumZipPacketsIn,
			&AtalkStatsLock.SpinLock);
	} while (FALSE);
}


/***	AtalkZipPacketInRouter
 *
 */
VOID
AtalkZipPacketInRouter(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			Status,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)
{
	BYTE			CmdType;
	TIME			TimeS, TimeE, TimeD;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);
	do
	{
		if (Status == ATALK_SOCKET_CLOSED)
			break;

		else if (Status != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (DdpType == DDPPROTO_ZIP)
		{
			if (PktLen < ZIP_FIRST_NET_OFF)
			{
				break;
			}
			CmdType = pPkt[ZIP_CMD_OFF];

			switch (CmdType)
			{
			  case ZIP_NETINFO_REPLY:
			  case ZIP_NOTIFY:
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: Ignoring %s\n",
						(CmdType == ZIP_NOTIFY) ? "Notify" : "NetInfoReply"));
				break;

			  case ZIP_GET_NETINFO:
  				// We do not want to do a thing if we're starting up
				if (pPortDesc->pd_Flags & PD_ROUTER_STARTING)
					break;

				if (!EXT_NET(pPortDesc))
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
				if (pPortDesc->pd_ZoneList == NULL)
					break;			// Not fully up yet !

				if (PktLen < ZIP_REQ_ZONENAME_OFF)
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: GetNetInfo Port %Z\n",
						&pPortDesc->pd_AdapterKey));
				atalkZipHandleNetInfo(pPortDesc,
									  pDdpAddr,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
				break;

			  case ZIP_EXT_REPLY:
			  case ZIP_REPLY:
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: %sReply Port %Z\n",
						(CmdType == ZIP_REPLY) ? "" : "Extended",
						&pPortDesc->pd_AdapterKey));
				atalkZipHandleReply(pDdpAddr, pSrcAddr, pPkt, PktLen);
				break;

			  case ZIP_QUERY:
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: Query Port %Z\n",
						&pPortDesc->pd_AdapterKey));

  				// We do not want to do a thing if we're starting up
				if (pPortDesc->pd_Flags & PD_ROUTER_STARTING)
					break;

  				atalkZipHandleQuery(pPortDesc, pDdpAddr, pSrcAddr, pPkt, PktLen);
				break;

			  default:
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
		}
		else if (DdpType == DDPPROTO_ATP)
		{
			USHORT	TrId, StartIndex;

			if (PktLen < ATP_ZIP_START_INDEX_OFF+1)
			{
                ASSERT(0);
				break;
			}

			// We do not want to do a thing if we're starting up
			if (pPortDesc->pd_Flags & PD_ROUTER_STARTING)
				break;

			// This had better be a GetZoneList, a GetMyZone ATP request
			if ((pPkt[ATP_CMD_CONTROL_OFF] & ATP_FUNC_MASK) != ATP_REQUEST)
				break;
		
			if (pPkt[ATP_BITMAP_OFF] != 1)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
		
			GETSHORT2SHORT(&TrId, pPkt + ATP_TRANS_ID_OFF);
			CmdType = pPkt[ATP_ZIP_CMD_OFF];

			if ((CmdType != ZIP_GET_ZONE_LIST) &&
				(CmdType != ZIP_GET_MY_ZONE) &&
				(CmdType != ZIP_GET_LOCAL_ZONES))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}

			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("ZIP: Received atp type command %d\n", CmdType));

			// Get start index. Not meaningful for GetMyZone
			GETSHORT2SHORT(&StartIndex, pPkt+ATP_ZIP_START_INDEX_OFF);

			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("AtalkZipPacketInRouter: AtpRequest %d, Port %Z\n",
						CmdType, &pPortDesc->pd_AdapterKey));
			atalkZipHandleAtpRequest(pPortDesc, pDdpAddr, pSrcAddr,
									CmdType, TrId, StartIndex);
		}
	} while (FALSE);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_ZipPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumZipPacketsIn,
		&AtalkStatsLock.SpinLock);
}


/***	atalkZipHandleNetInfo
 *
 */
VOID
atalkZipHandleNetInfo(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen
)
{
	PBUFFER_DESC	pBuffDesc;
	BYTE			ZoneLen;
	PBYTE			Datagram, pZoneName;
	ATALK_ADDR		SrcAddr = *pSrcAddr;
	ATALK_ERROR		error;
	BOOLEAN			UseDefZone = FALSE;
	USHORT			index;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	do
	{
		// Get the zone name out of the request
		ZoneLen = pPkt[ZIP_REQ_ZONELEN_OFF];
		if ((ZoneLen > MAX_ZONE_LENGTH) ||
			(PktLen < (USHORT)(ZoneLen + ZIP_REQ_ZONENAME_OFF)))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		pZoneName =  pPkt+ZIP_REQ_ZONENAME_OFF;
		
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
								MAX_DGRAM_SIZE,
								BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			break;
		}
		Datagram = pBuffDesc->bd_CharBuffer;
		
		// Format a GetNetInfo reply command
		Datagram[ZIP_CMD_OFF] = ZIP_NETINFO_REPLY;
		Datagram[ZIP_FLAGS_OFF] = 0;
		
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		if ((ZoneLen == 0) ||
			!AtalkZoneNameOnList(pZoneName, ZoneLen, pPortDesc->pd_ZoneList))
		{
			Datagram[ZIP_FLAGS_OFF] |= ZIP_ZONE_INVALID_FLAG;
			UseDefZone = TRUE;
		}
		
		if (AtalkZoneNumOnList(pPortDesc->pd_ZoneList) == 1)
			Datagram[ZIP_FLAGS_OFF] |= ZIP_ONLYONE_ZONE_FLAG;
		
		// Add our cable range
		PUTSHORT2SHORT(&Datagram[ZIP_FIRST_NET_OFF],
						pPortDesc->pd_NetworkRange.anr_FirstNetwork);
		PUTSHORT2SHORT(Datagram +ZIP_LAST_NET_OFF,
						pPortDesc->pd_NetworkRange.anr_LastNetwork);
		
		// Echo back the requested zone name
		Datagram[ZIP_REQ_ZONELEN_OFF] = ZoneLen;
		RtlCopyMemory(Datagram+ZIP_REQ_ZONENAME_OFF, pZoneName, ZoneLen);
		index = ZIP_REQ_ZONENAME_OFF + ZoneLen;
		
		// Place in the correct zone multicast address
		Datagram[index++] = (BYTE)(pPortDesc->pd_BroadcastAddrLen);
		if (UseDefZone)
		{
			pZoneName = pPortDesc->pd_DefaultZone->zn_Zone;
			ZoneLen = pPortDesc->pd_DefaultZone->zn_ZoneLen;
		}
		AtalkZipMulticastAddrForZone(pPortDesc, pZoneName, ZoneLen, Datagram + index);
		
		index += pPortDesc->pd_BroadcastAddrLen;
		
		// If we need it, add in the default zone
		if (UseDefZone)
		{
			Datagram[index++] = ZoneLen = pPortDesc->pd_DefaultZone->zn_ZoneLen;
			RtlCopyMemory(Datagram + index, pPortDesc->pd_DefaultZone->zn_Zone, ZoneLen);
			index += ZoneLen;
		}
		
		// If the request came as a cable-wide broadcast and its
		// source network is not valid for this port, then we want
		// to respond to cable-wide broadcast rather than the source
		if ((pDstAddr->ata_Network == CABLEWIDE_BROADCAST_NETWORK) &&
			(pDstAddr->ata_Node == ATALK_BROADCAST_NODE) &&
			!WITHIN_NETWORK_RANGE(pSrcAddr->ata_Network,
									&pPortDesc->pd_NetworkRange) &&
			!WITHIN_NETWORK_RANGE(pSrcAddr->ata_Network,
									&AtalkStartupNetworkRange))
		{
			SrcAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
			SrcAddr.ata_Node = ATALK_BROADCAST_NODE;
		}
		
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		
		//	Set the length in the buffer descriptor.
        AtalkSetSizeOfBuffDescData(pBuffDesc, index);

		// Finally, send this out
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipHandleNetInfo: Sending Reply to %d.%d.%d\n",
				SrcAddr.ata_Network, SrcAddr.ata_Node, SrcAddr.ata_Socket));
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
		error = AtalkDdpSend(pDdpAddr,
							 &SrcAddr,
							 DDPPROTO_ZIP,
							 FALSE,
							 pBuffDesc,
							 NULL,
							 0,
							 NULL,
							 &SendInfo);
		if (!ATALK_SUCCESS(error))
		{
			AtalkFreeBuffDesc(pBuffDesc);
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipHandleNetInfo: AtalkDdpSend %ld\n", error));
		}
	} while (FALSE);
}


/***	atalkZipHandleReply
 *
 */
VOID
atalkZipHandleReply(
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen
)
{
	ULONG			index, TotalNetCnt;
	PRTE			pRte = NULL;
	PBYTE			ZoneName;
	USHORT			NetNum;
	BYTE			CmdType, NwCnt, NumZonesOnNet, ZoneLen;
	BOOLEAN			RteLocked = FALSE;
	BOOLEAN			ExtReply = FALSE;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipHandleReply: Enetered\n"));

	// For a zip extended reply, the network count is really not
	// the # of networks contained in the packet. It is the total #
	// of zones on the single network that is described by the reply
	NwCnt = NumZonesOnNet = pPkt[ZIP_NW_CNT_OFF];
	CmdType = pPkt[ZIP_CMD_OFF];

	do
	{
		// Walk through the reply packet (assuming we asked for the
		// contained information). We're still using NwCnt when
		// processing an extended reply, but that's okay 'cause it
		// will certainly be at least the # of zones contained in
		// this packet. The '+3' guarantees that we really have
		// network # and node
		for (index = ZIP_FIRST_NET_OFF, TotalNetCnt = 0;
			 (TotalNetCnt < NwCnt) && ((index + 3 ) <= PktLen);
			 TotalNetCnt ++)
		{
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}
	
			// Get the next netwotk #, if it's not in our routing
			// table (or not the start of a range), then we certainly
			// don't care about its zone name
			GETSHORT2SHORT(&NetNum, pPkt+index);
			index += sizeof(USHORT);
			ZoneLen = pPkt[index++];
			if (((pRte = AtalkRtmpReferenceRte(NetNum)) == NULL) ||
				(pRte->rte_NwRange.anr_FirstNetwork != NetNum))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleReply: Don't know about this range %d\n",
						NetNum));
				index += ZoneLen;
				continue;
			}
	
			// Validate the zone name
			if ((ZoneLen == 0) || (ZoneLen > MAX_ZONE_LENGTH) ||
				((index + ZoneLen) > PktLen))
			{
				AtalkLogBadPacket(pDdpAddr->ddpao_Node->an_Port,
								  pSrcAddr,
								  NULL,
								  pPkt,
								  PktLen);
				break;
			}
	
			// Conditionally move the zone name into the routing table
			ZoneName = pPkt+index;
			index += ZoneLen;
			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
			RteLocked = TRUE;
	
			if (AtalkZoneNameOnList(ZoneName, ZoneLen, pRte->rte_ZoneList))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("atalkZipHandleReply: Already have this zone\n"));
				continue;
			}

			// Check for somebody out there trying to add another zone to
			// our directly connected non-extended network and we already
			// know its zone.
			if ((pRte->rte_NumHops == 0) &&
				!EXT_NET(pRte->rte_PortDesc) &&
				(AtalkZoneNumOnList(pRte->rte_ZoneList) == 1))
			{
				AtalkLogBadPacket(pDdpAddr->ddpao_Node->an_Port,
								  pSrcAddr,
								  NULL,
								  pPkt,
								  PktLen);
				continue;
			}
	
			// Add to the list now
			pRte->rte_ZoneList = AtalkZoneAddToList(pRte->rte_ZoneList,
													ZoneName,
													ZoneLen);
			if (pRte->rte_ZoneList == NULL)
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleReply: Failed to add zone to list\n"));
				pRte->rte_Flags &= ~RTE_ZONELIST_VALID;
				continue;
			}

			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipHandleReply: # of zones known so far %d\n",
					AtalkZoneNumOnList(pRte->rte_ZoneList)));

			// If not an extended reply, we know that we have all
			// of the information about a given network contained
			// in this packet, so we can go ahead and mark the zone
			// list valid now
			if (!ExtReply)
				pRte->rte_Flags |= RTE_ZONELIST_VALID;
		}
	
		// If we just handled an extended reply, do we now know all
		// that we should know about the specified network ?
	
		if (pRte != NULL)
		{
			if (ExtReply)
			{
				if (!RteLocked)
				{
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = TRUE;
				}
				if (AtalkZoneNumOnList(pRte->rte_ZoneList) >= NumZonesOnNet)
					pRte->rte_Flags |= RTE_ZONELIST_VALID;
			}
			if (RteLocked)
			{
				RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
				// RteLocked = FALSE;
			}
			AtalkRtmpDereferenceRte(pRte, FALSE);
			// pRte = NULL;
		}
	} while (FALSE);
}

/***	atalkZipHandleQuery
 *
 */
VOID
atalkZipHandleQuery(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen
)
{
	PRTE			pRte = NULL;
	PBUFFER_DESC	pBuffDesc,
					pBuffDescStart = NULL,
					*ppBuffDesc = &pBuffDescStart;
	PZONE_LIST		pZoneList;
	PBYTE			Datagram;
	ATALK_ERROR		error;
    ULONG           i, CurrNumZones, PrevNumZones, TotalNetCnt;
	ULONG			NwCnt, NetCntInPkt;
	USHORT			NetNum, Size;
    BOOLEAN			AllocNewBuffDesc = TRUE, NewPkt = TRUE;
	BOOLEAN			PortLocked = FALSE,  RteLocked = FALSE;
	BYTE			CurrReply, NextReply;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    CurrNumZones = 0;
	do
	{
		// Walk through the query packet building reply packets that
		// have as much information as we know.
		// When sending replies, we will always send a reply about a
		// network that has more than one zone as an extended reply.
		// As were walking the query list, and we encounter a couple of
		// networks that have only one zone, we'll pack as many of
		// these as we can into a non-extended reply
		NwCnt = pPkt[ZIP_NW_CNT_OFF];

		for (NetCntInPkt = 0, TotalNetCnt = 0, i = ZIP_FIRST_NET_OFF;
			 (TotalNetCnt < NwCnt) && ((i + sizeof(SHORT)) <= PktLen);
			 i += sizeof(USHORT), TotalNetCnt++)
		{
			// Dereference any previous Rtes
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}
			if (PortLocked)
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				PortLocked = FALSE;
			}

			// Grab the next network number from the query packet,
			// if we don't know about the network, or we don't know
			// the zone name, continue with the next network number
			GETSHORT2SHORT(&NetNum, pPkt+i);
	
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			if ((WITHIN_NETWORK_RANGE(NetNum,&pPortDesc->pd_NetworkRange)) &&
				(pPortDesc->pd_ZoneList != NULL))
			{
				pZoneList = pPortDesc->pd_ZoneList;
				PortLocked = TRUE;
			}
			else
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				if (((pRte = AtalkRtmpReferenceRte(NetNum)) == NULL) ||
						 (!WITHIN_NETWORK_RANGE(NetNum, &pRte->rte_NwRange)) ||
						 !(pRte->rte_Flags & RTE_ZONELIST_VALID))
				{
					continue;
				}
				else
				{
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					pZoneList = pRte->rte_ZoneList;
					RteLocked = TRUE;
				}
			}

		next_reply:

			if (AllocNewBuffDesc)
			{
				if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
									MAX_DGRAM_SIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
                {
                    DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
	                    ("\natalkZipHandleQuery:  AtalkAllocBuffDesc @1 failed\n"));
					break;
                }

				Size = 0;
				Datagram = pBuffDesc->bd_CharBuffer;
				*ppBuffDesc = pBuffDesc;
                pBuffDesc->bd_Next = NULL;
				ppBuffDesc = &pBuffDesc->bd_Next;
				AllocNewBuffDesc = FALSE;
			}

			// What type of response does this network want ?
			// Copy the previous network's zone count. In case of the first
			// pass, make it same.
            PrevNumZones = CurrNumZones;
			CurrNumZones = AtalkZoneNumOnList(pZoneList);
			if (i == ZIP_FIRST_NET_OFF)
				PrevNumZones = CurrNumZones;

			ASSERT (CurrNumZones != 0);

			NextReply = ZIP_REPLY;
			if (CurrNumZones > 1)
			{
				// We start a new packet for each extended network
				NewPkt = TRUE;
				NextReply = ZIP_EXT_REPLY;
				if (NetCntInPkt > 0)
				{
					Datagram[ZIP_CMD_OFF] = CurrReply;
					if (CurrReply == ZIP_REPLY)
						Datagram[ZIP_NW_CNT_OFF] = (BYTE)NetCntInPkt;
					else Datagram[ZIP_NW_CNT_OFF] = (BYTE)PrevNumZones;
					AllocNewBuffDesc = TRUE;

					pBuffDesc->bd_Length = Size;
					NetCntInPkt = 0;
					goto next_reply;
				}
			}
	
			// Walk the zone list
			for (; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
			{
				PZONE	pZone = pZoneList->zl_pZone;

				// If we're starting to build a new reply packet due to
				// either:
				//
				//	1. first time through
				//	2. packet full
				//	3. switching reply types
				//
				// set the index to the first tuple position.
				if (NewPkt || (CurrReply != NextReply))
				{
					if (NetCntInPkt > 0)
					{
						// Close the current buffdesc and open a new one
						// Careful here with the CurrNumZones vs. PrevNumZones
						// If we are going from ExtReply to a Reply, we need
						// to get PrevNumZones. If we are continuing the
						// same ExtReply then we need CurrNumZones.
						Datagram[ZIP_CMD_OFF] = CurrReply;
						if (CurrReply == ZIP_REPLY)
							Datagram[ZIP_NW_CNT_OFF] = (BYTE)NetCntInPkt;
						else
						{
							Datagram[ZIP_NW_CNT_OFF] = (BYTE)CurrNumZones;
							if (CurrReply != NextReply)
								Datagram[ZIP_NW_CNT_OFF] = (BYTE)PrevNumZones;
						}
						pBuffDesc->bd_Length = Size;

						if ((pBuffDesc = AtalkAllocBuffDesc(NULL,MAX_DGRAM_SIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
                        {
                            DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
	                            ("\natalkZipHandleQuery:  AtalkAllocBuffDesc @2 failed\n"));
							break;
                        }

						Size = 0;
						Datagram = pBuffDesc->bd_CharBuffer;

						*ppBuffDesc = pBuffDesc;
						pBuffDesc->bd_Next = NULL;
						ppBuffDesc = &pBuffDesc->bd_Next;
						NetCntInPkt = 0;
					}
					Size = ZIP_FIRST_NET_OFF;
					CurrReply = NextReply;
					NewPkt = FALSE;
				}
				// We know the answer to the question. Pack a new
				// network/zone tuple into the reply packet.
				
				PUTSHORT2SHORT(Datagram+Size, NetNum);
				Size += sizeof(USHORT);
				Datagram[Size++] = pZone->zn_ZoneLen;
				RtlCopyMemory(Datagram + Size,
							  pZone->zn_Zone,
							  pZone->zn_ZoneLen);
				Size += pZone->zn_ZoneLen;
				NetCntInPkt ++;
				
				// If we can't hold another big tuple, signal that we
				// should send on the next pass.
				if ((Size + sizeof(USHORT) + sizeof(char) + MAX_ZONE_LENGTH)
															>= MAX_DGRAM_SIZE)
				{
				   NewPkt = TRUE;
				}
			}

            if (pBuffDesc == NULL)
            {
                break;
            }
		}

		// Dereference an rte if we broke out the loop above
		if (pRte != NULL)
		{
			ASSERT(!PortLocked);
			if (RteLocked)
			{
				RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
				// RteLocked = FALSE;
			}
			AtalkRtmpDereferenceRte(pRte, FALSE);
			// pRte = NULL;
		}
		if (PortLocked)
		{
			ASSERT(!RteLocked);
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
            PortLocked = FALSE;
		}

		// Close the current buffdesc
		if ((!AllocNewBuffDesc) && (pBuffDesc != NULL))
		{
			pBuffDesc->bd_Length = Size;
			if (NetCntInPkt > 0)
			{
				Datagram[ZIP_CMD_OFF] = CurrReply;
				if (CurrReply == ZIP_REPLY)
					Datagram[ZIP_NW_CNT_OFF] = (BYTE)NetCntInPkt;
				else Datagram[ZIP_NW_CNT_OFF] = (BYTE)CurrNumZones;
			}
		}

		// We have a bunch of datagrams ready to be fired off.
		// Make it so. Do not send any with zero lengths, however.
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
		for (pBuffDesc = pBuffDescStart;
			 pBuffDesc != NULL;
			 pBuffDesc = pBuffDescStart)
		{
			pBuffDescStart = pBuffDesc->bd_Next;
	
			if (pBuffDesc->bd_Length == 0)
			{
				ASSERT(pBuffDescStart == NULL);
				AtalkFreeBuffDesc(pBuffDesc);
				break;
			}

			//	Set the next ptr to be null. Length already set correctly.
			pBuffDesc->bd_Next = NULL;
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipHandleQuery: Sending Reply to %d.%d.%d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));
			SendInfo.sc_Ctx1 = pBuffDesc;
			error = AtalkDdpSend(pDdpAddr,
								 pSrcAddr,
								 DDPPROTO_ZIP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);
			if (!ATALK_SUCCESS(error))
			{
				AtalkFreeBuffDesc(pBuffDesc);
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleQuery: AtalkDdpSend %ld\n", error));
			}
		}
	} while (FALSE);

	if (PortLocked)
	{
		ASSERT(!RteLocked);
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
}


/***	atalkZipHandleAtpRequest
 *
 */
VOID
atalkZipHandleAtpRequest(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	BYTE				CmdType,
	IN	USHORT				TrId,
	IN	USHORT				StartIndex
)
{
	PBUFFER_DESC	pBuffDesc;
	PBYTE			Datagram, ZoneName;
	PZONE			pZone;
	ATALK_ERROR		error;
	int				i, ZoneLen, ZoneCnt, CurrZoneIndex, index;
	BYTE			LastFlag = 0;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	do
	{
		// Allocate a buffer descriptor and initialize the header
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL, MAX_DGRAM_SIZE,
								BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			break;
		}

		Datagram = pBuffDesc->bd_CharBuffer;
		Datagram[ATP_CMD_CONTROL_OFF] = ATP_RESPONSE + ATP_EOM_MASK;
		Datagram[ATP_SEQ_NUM_OFF] = 0;
		PUTSHORT2SHORT(Datagram + ATP_TRANS_ID_OFF, TrId);
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
	
		if (CmdType == ZIP_GET_MY_ZONE)
		{
			// We really shouldn't be getting this request on an
			// extended network, but go ahead and reply with the
			// "default zone" in this case, of course, reply with
			// "desired zone" for non-extended nets.  We are a router,
			// so "desired zone" will always be valid -- as will the
			// default zone for extended net.
		
			PUTSHORT2SHORT(Datagram+ATP_ZIP_LAST_FLAG_OFF, 0);
			PUTSHORT2SHORT(Datagram+ATP_ZIP_START_INDEX_OFF, 1);
	
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			if (EXT_NET(pPortDesc))
			{
				ZoneName = pPortDesc->pd_DefaultZone->zn_Zone;
				ZoneLen = pPortDesc->pd_DefaultZone->zn_ZoneLen;
			}
			else
			{
				ZoneName = pPortDesc->pd_DesiredZone->zn_Zone;
				ZoneLen = pPortDesc->pd_DesiredZone->zn_ZoneLen;
			}
			RtlCopyMemory(Datagram+ATP_DATA_OFF+1, ZoneName, ZoneLen);
			Datagram[ATP_DATA_OFF] = (BYTE)ZoneLen;

			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			//	Set the length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)(ATP_DATA_OFF + 1 + ZoneLen));
	
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipHandleAtpReq: Sending GetMyZone Reply to %d.%d.%d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));
			error = AtalkDdpSend(pDdpAddr,
								 pSrcAddr,
								 DDPPROTO_ATP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);
			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleAtpRequest: AtalkDdpSend %ld\n", error));
			}
			break;
		}
	
		// Either a GetLocalZones or a GetZoneList. Fill the reply packet
		// with as many zones as it'll hold starting at the requested
		// start index
		index = ATP_DATA_OFF;
	
		if (CmdType == ZIP_GET_LOCAL_ZONES)
		{
			PZONE_LIST	pZoneList;

			// For GetLocalZones, we only want to count zones
			// that are on the network that is directly connected
			// to the port on which the request originated. Use the
			// zone list on the port.
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			for (pZoneList = pPortDesc->pd_ZoneList, ZoneCnt = 0, CurrZoneIndex = 0;
				 pZoneList != NULL;
				 pZoneList = pZoneList->zl_Next)
			{
				// If we have not seen StartIndex zones yet, keep going
				if (++CurrZoneIndex < StartIndex)
					continue;

				pZone = pZoneList->zl_pZone;
	
				// If this packet cannot hold more, we're done (for now)
				// Fill in the zone count and the last flag
				if ((index + pZone->zn_ZoneLen + 1) >= MAX_DGRAM_SIZE)
				{
					break;
				}

				// Place zone name in the packet
				ASSERT(pZone != NULL);
				Datagram[index] = pZone->zn_ZoneLen;
				RtlCopyMemory(Datagram+index+1,
							  pZone->zn_Zone,
							  pZone->zn_ZoneLen);
				index += (pZone->zn_ZoneLen + 1);
				ZoneCnt ++;
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			// We've build a packet, set the last flag, if applicable
			LastFlag = (pZoneList == NULL) ? 1 : 0;
		}

		else	// This is a ZIP_GET_ZONE_LIST
		{
			BOOLEAN	PktFull = FALSE;

			ASSERT (CmdType == ZIP_GET_ZONE_LIST);

			// For GetZoneList, we want all the zones that we know
			// of, so use the AtalkZoneTable.
			ACQUIRE_SPIN_LOCK_DPC(&AtalkZoneLock);
			for (i = 0, ZoneCnt = 0, CurrZoneIndex = 0;
				 (i < NUM_ZONES_HASH_BUCKETS) && !PktFull; i++)
			{
				for (pZone = AtalkZonesTable[i];
					 pZone != NULL;
					 pZone = pZone->zn_Next)
				{
					// If we have not seen StartIndex zones yet, keep going
					if (++CurrZoneIndex < StartIndex)
						continue;
		
					// If this packet cannot hold more, we're done (for now)
					// Fill in the zone count and the last flag
					if ((index + pZone->zn_ZoneLen + 1) >= MAX_DGRAM_SIZE)
					{
						PktFull = TRUE;
						break;
					}

					// Place zone name in the packet
					Datagram[index] = pZone->zn_ZoneLen;
					RtlCopyMemory(Datagram+index+1,
								  pZone->zn_Zone,
								  pZone->zn_ZoneLen);
					index += (pZone->zn_ZoneLen + 1);
					ZoneCnt ++;
				}
			}
			RELEASE_SPIN_LOCK_DPC(&AtalkZoneLock);

			// We've build a packet, set the last flag, if applicable
			LastFlag = ((i == NUM_ZONES_HASH_BUCKETS) && (pZone == NULL)) ? 1 : 0;
		}

		// We've build a packet, set the last flag and # of zones in packet
		Datagram[ATP_ZIP_LAST_FLAG_OFF] = LastFlag;
		Datagram[ATP_ZIP_LAST_FLAG_OFF + 1] = 0;
		PUTSHORT2SHORT(Datagram + ATP_ZIP_ZONE_CNT_OFF, ZoneCnt);

		//	Set the length in the buffer descriptor.
        AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)index);

		// Finally, send this out
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipHandleAtpReq: Sending LocalZones Reply to %d.%d.%d\n",
				pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));
		error = AtalkDdpSend(pDdpAddr,
							 pSrcAddr,
							 DDPPROTO_ATP,
							 FALSE,
							 pBuffDesc,
							 NULL,
							 0,
							 NULL,
							 &SendInfo);
		if (!ATALK_SUCCESS(error))
		{
			AtalkFreeBuffDesc(pBuffDesc);
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipHandleAtpRequest: AtalkDdpSend %ld\n", error));
		}
	} while (FALSE);
}


/***	AtalkZipMulticastAddrForZone
 *
 */
VOID
AtalkZipMulticastAddrForZone(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PBYTE				pZone,
	IN	BYTE				ZoneLen,
	IN	PBYTE				MulticastAddr
)
{
	USHORT	CheckSum;
	BYTE	UpCasedZone[MAX_ZONE_LENGTH];

	AtalkUpCase(pZone, ZoneLen, UpCasedZone);

	// Caculate the checksum for the zone
	CheckSum = AtalkDdpCheckSumBuffer(UpCasedZone, ZoneLen, 0);

	switch (pPortDesc->pd_PortType)
	{
		case ELAP_PORT:
		case FDDI_PORT:
			RtlCopyMemory(MulticastAddr,
						  AtalkEthernetZoneMulticastAddrsHdr,
						  ELAP_MCAST_HDR_LEN);

			MulticastAddr[ELAP_MCAST_HDR_LEN] =
						  AtalkEthernetZoneMulticastAddrs[CheckSum % ELAP_ZONE_MULTICAST_ADDRS];
			break;
		case TLAP_PORT:
			RtlCopyMemory(MulticastAddr,
						  AtalkTokenRingZoneMulticastAddrsHdr,
						  TLAP_MCAST_HDR_LEN);

			RtlCopyMemory(&MulticastAddr[TLAP_MCAST_HDR_LEN],
						  AtalkTokenRingZoneMulticastAddrs[CheckSum % TLAP_ZONE_MULTICAST_ADDRS],
						  TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN);
			break;
		default:
			DBGBRK(DBG_LEVEL_FATAL);
			KeBugCheck(0);
	}
}


/***	AtalkZipGetNetworkInfoForNode
 *
 */
BOOLEAN
AtalkZipGetNetworkInfoForNode(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		pNode,
	IN	BOOLEAN				FindDefZone
)
{
	PBUFFER_DESC		pBuffDesc = NULL;
	ATALK_ADDR			SrcAddr, DstAddr;
	ATALK_ERROR			error;
	USHORT				NumReqs, DgLen;
	BYTE				DgCopy[ZIP_ZONENAME_OFF + MAX_ZONE_LENGTH];
	KIRQL				OldIrql;
	BOOLEAN				RetCode, Done;
	SEND_COMPL_INFO		SendInfo;

	ASSERT(EXT_NET(pPortDesc));

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	if (FindDefZone)
	{
		pPortDesc->pd_Flags &= ~PD_VALID_DEFAULT_ZONE;
		pPortDesc->pd_Flags |= PD_FINDING_DEFAULT_ZONE;
	}
	else
	{
		pPortDesc->pd_Flags &= ~PD_VALID_DESIRED_ZONE;
		pPortDesc->pd_Flags |= PD_FINDING_DESIRED_ZONE;
	}

	// Get source and destination addresses
	SrcAddr.ata_Network = pNode->atn_Network;
	SrcAddr.ata_Node = pNode->atn_Node;
	SrcAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	DstAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
	DstAddr.ata_Node = ATALK_BROADCAST_NODE;
	DstAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	// Build a ZipNetGetInfo datagram
	DgCopy[ZIP_CMD_OFF] = ZIP_GET_NETINFO;
	DgCopy[ZIP_FLAGS_OFF] = 0;
	PUTSHORT2SHORT(DgCopy + ZIP_CABLE_RANGE_START_OFF, 0);
	PUTSHORT2SHORT(DgCopy + ZIP_CABLE_RANGE_END_OFF, 0);

	DgLen = ZIP_ZONENAME_OFF;
	DgCopy[ZIP_ZONELEN_OFF] = 0;
	if (!FindDefZone &&
		(pPortDesc->pd_InitialDesiredZone != NULL))
	{
		DgCopy[ZIP_ZONELEN_OFF] = pPortDesc->pd_InitialDesiredZone->zn_ZoneLen;
		RtlCopyMemory(DgCopy + ZIP_ZONENAME_OFF,
					  pPortDesc->pd_InitialDesiredZone->zn_Zone,
					  pPortDesc->pd_InitialDesiredZone->zn_ZoneLen);
		DgLen += DgCopy[ZIP_ZONELEN_OFF];
	}

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	for (NumReqs = 0;
		 NumReqs < ZIP_NUM_GETNET_INFOS;
		 NumReqs++)
	{
		Done = FindDefZone ?
				((pPortDesc->pd_Flags & PD_VALID_DEFAULT_ZONE) != 0) :
				((pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) != 0);

		if (Done)
        {
			break;
        }

		if ((pBuffDesc = AtalkAllocBuffDesc(NULL, DgLen,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			break;
		}
		RtlCopyMemory(pBuffDesc->bd_CharBuffer, DgCopy, DgLen);

		//	Set the length in the buffer descriptor.
		AtalkSetSizeOfBuffDescData(pBuffDesc, DgLen);
	
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;

		error = AtalkDdpTransmit(pPortDesc,
								 &SrcAddr,
								 &DstAddr,
								 DDPPROTO_ZIP,
								 pBuffDesc,
								 NULL,
								 0,
								 0,
								 NULL,
								 NULL,
								 &SendInfo);
		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("AtalkZipGetNetworkInfoForNode: AtalkDdpTransmit %ld\n", error));
			break;
		}
		pBuffDesc = NULL;
		AtalkSleep(ZIP_GET_NETINFO_WAIT);
	}

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	if (FindDefZone)
	{
		pPortDesc->pd_Flags &= ~PD_FINDING_DEFAULT_ZONE;
	}
	else
	{
		pPortDesc->pd_Flags &= ~PD_FINDING_DESIRED_ZONE;
	}

	RetCode = FindDefZone ?
				((pPortDesc->pd_Flags & PD_VALID_DEFAULT_ZONE) == PD_VALID_DEFAULT_ZONE) :
				((pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) == PD_VALID_DESIRED_ZONE);

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

    return RetCode;
}


/***	AtalkZipGetMyZone
 *
 */
ATALK_ERROR
AtalkZipGetMyZone(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fDesired,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		PACTREQ				pActReq
)
{
	PZIPCOMPLETIONINFO	pZci = NULL;
	ATALK_ERROR			Status = ATALK_NO_ERROR;
	ULONG				BytesCopied;
	PZONE				pZone;
	KIRQL				OldIrql;
	BOOLEAN				Done = FALSE;

	ASSERT (VALID_ACTREQ(pActReq));

	if (Size < (MAX_ZONE_LENGTH + 1))
		return ATALK_BUFFER_TOO_SMALL;

	do
	{
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

		// For extended network, we either know or cannot find out
		if (EXT_NET(pPortDesc))
		{
			BOOLEAN	Yes = FALSE;

			if (fDesired && (pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
			{
				pZone = pPortDesc->pd_DesiredZone;
				Yes = TRUE;
			}
			else if (!fDesired && (pPortDesc->pd_Flags & PD_VALID_DEFAULT_ZONE))
			{
				pZone = pPortDesc->pd_DefaultZone;
				Yes = TRUE;
			}
			if (Yes)
			{
				TdiCopyBufferToMdl( pZone->zn_Zone,
									0,
									pZone->zn_ZoneLen,
									pAMdl,
									0,
									&BytesCopied);
				ASSERT (BytesCopied == pZone->zn_ZoneLen);
	
				TdiCopyBufferToMdl( "",
									0,
									1,
									pAMdl,
									pZone->zn_ZoneLen,
									&BytesCopied);
				ASSERT (BytesCopied == 1);
				Done = TRUE;
			}
		}

		// For non-extended networks, we need to ask a router. If we don't
		// know about a router, return.
		if (!Done &&
			(EXT_NET(pPortDesc) ||
			 !(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)))
		{
			TdiCopyBufferToMdl( "*",
								0,
								sizeof("*"),
								pAMdl,
								0,
								&BytesCopied);
			ASSERT (BytesCopied == sizeof("*"));
			Done = TRUE;
		}

		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		if (Done)
		{
			(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
			break;
		}

		ASSERT (!EXT_NET(pPortDesc));

		// Allocate a Completion info structure
		if ((pZci = AtalkAllocMemory(sizeof(ZIPCOMPLETIONINFO))) == NULL)
		{
			Status = ATALK_RESR_MEM;
			break;
		}

		// Initialize completion info
#if	DBG
		pZci->zci_Signature = ZCI_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pZci->zci_Lock);
		pZci->zci_RefCount = 1;
		pZci->zci_pPortDesc = pPortDesc;
        pZci->zci_pDdpAddr = NULL;
		pZci->zci_pAMdl = pAMdl;
		pZci->zci_BufLen = Size;
		pZci->zci_pActReq = pActReq;
		pZci->zci_Router.ata_Network = pPortDesc->pd_ARouter.atn_Network;
		pZci->zci_Router.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		pZci->zci_Router.ata_Socket = ZONESINFORMATION_SOCKET;
		pZci->zci_ExpirationCount = ZIP_GET_ZONEINFO_RETRIES;
		pZci->zci_NextZoneOff = 0;
		pZci->zci_ZoneCount = -1;
		pZci->zci_AtpRequestType = ZIP_GET_MY_ZONE;
		pZci->zci_Handler = atalkZipGetMyZoneReply;
		AtalkTimerInitialize(&pZci->zci_Timer,
							 atalkZipZoneInfoTimer,
							 ZIP_GET_ZONEINFO_TIMER);

		Status = atalkZipSendPacket(pZci, TRUE);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("AtalkZipGetMyZone: atalkZipSendPacket %ld\n",
					Status));
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			Status = ATALK_PENDING;		// atalkZipDereferenceZci completes the req
		}
	} while (FALSE);

	return(Status);
}


/***	atalkZipGetMyZoneReply
 *
 */
VOID
atalkZipGetMyZoneReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				Status,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
)
{
	ULONG			BytesCopied;
	KIRQL			OldIrql;
	USHORT			ZoneCnt;
	BYTE			ZoneLen;

	do
	{
		if (Status == ATALK_SOCKET_CLOSED)
		{
			pZci->zci_pDdpAddr = NULL;
			if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
				atalkZipDereferenceZci(pZci);
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			break;
		}

		if ((Status != ATALK_NO_ERROR) ||
			(DdpType != DDPPROTO_ATP) ||
			(PktLen <= ATP_ZIP_FIRST_ZONE_OFF))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		// We should have one zone
		GETSHORT2SHORT(&ZoneCnt, pPkt + ATP_ZIP_ZONE_CNT_OFF);
		ZoneLen = pPkt[ATP_ZIP_FIRST_ZONE_OFF];
		if ((ZoneCnt != 1) ||
			(ZoneLen == 0) || (ZoneLen > MAX_ZONE_LENGTH))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipGetMyZoneReply: Bad reply\n"));
			break;
		}

		if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
		{
			atalkZipDereferenceZci(pZci);
		}

		ACQUIRE_SPIN_LOCK(&pZci->zci_Lock, &OldIrql);

		TdiCopyBufferToMdl( pPkt + ATP_ZIP_FIRST_ZONE_OFF + 1,
							0,
							ZoneLen,
							pZci->zci_pAMdl,
							0,
							&BytesCopied);
		ASSERT (BytesCopied == ZoneLen);

		TdiCopyBufferToMdl( "",
							0,
							1,
							pZci->zci_pAMdl,
							ZoneLen,
							&BytesCopied);
		ASSERT (BytesCopied == 1);
		pZci->zci_FinalStatus = ATALK_NO_ERROR;
		RELEASE_SPIN_LOCK(&pZci->zci_Lock, OldIrql);
		atalkZipDereferenceZci(pZci);
	} while (FALSE);
}


/***	AtalkZipGetZoneList
 *
 */
ATALK_ERROR
AtalkZipGetZoneList(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fLocalZones,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		PACTREQ				pActReq
)
{
	PZIPCOMPLETIONINFO	pZci = NULL;
	ATALK_ERROR			Status = ATALK_NO_ERROR;
	ULONG				BytesCopied, index, NumZones;
	KIRQL				OldIrql;
	BOOLEAN				Done = FALSE, PortLocked = TRUE;

	ASSERT (VALID_ACTREQ(pActReq));

	if (Size < (MAX_ZONE_LENGTH + 1))
		return ATALK_BUFFER_TOO_SMALL;

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	do
	{
		// If we don't know about a router, return.
		if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_WARN,
					("AtalkZipGetZoneList: Don't know a router !!!\n"));
			TdiCopyBufferToMdl( "*",
								0,
								sizeof("*"),
								pAMdl,
								0,
								&BytesCopied);
			ASSERT (BytesCopied == sizeof("*"));
			Done = TRUE;
		}

		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
		PortLocked = FALSE;

		if (Done)
		{
            ((PZIP_GETZONELIST_PARAMS)(pActReq->ar_pParms))->ZonesAvailable = 1;
			(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
			break;
		}

		// If we are a router, then simply copy the zones. Else send a
		// a request to the router. DO NOT SEND A REQUEST IF WE ARE A
		// ROUTER SINCE THAT WILL RESULT IN A HORRIBLE RECURSION RESULTING
		// IN A DOUBLE FAULT (OUT OF STACK SPACE).
		if (pPortDesc->pd_Flags & PD_ROUTER_RUNNING)
		{
			PZONE		pZone;

			NumZones = 0;
			if (fLocalZones)
			{
				PZONE_LIST	pZoneList;
	
				// For GetLocalZones, we only want to count zones
				// that are on the network that is directly connected
				// to the port on which the request originated
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
				for (index = 0, pZoneList = pPortDesc->pd_ZoneList;
					 pZoneList != NULL;
					 pZoneList = pZoneList->zl_Next)
				{
					pZone = pZoneList->zl_pZone;

					ASSERT (pZone != NULL);

					// If this packet cannot hold more, we're done
					if ((INT)(index + pZone->zn_ZoneLen + 1) >= Size)
					{
						break;
					}

					// Place zone name in the packet
					TdiCopyBufferToMdl( pZone->zn_Zone,
										0,
										pZone->zn_ZoneLen + 1,
										pAMdl,
										index,
										&BytesCopied);
					ASSERT (BytesCopied == (ULONG)(pZone->zn_ZoneLen + 1));
			
					NumZones ++;
					index += (pZone->zn_ZoneLen + 1);
				}
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				Status = (pZoneList != NULL) ?
								ATALK_BUFFER_TOO_SMALL : ATALK_NO_ERROR;
			}
			else
			{
				BOOLEAN	PktFull = FALSE;
				INT		i;
	
				ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);
				for (i = 0, index = 0, PktFull = FALSE;
					 (i < NUM_ZONES_HASH_BUCKETS) && !PktFull;
					 i++)
				{
					for (pZone = AtalkZonesTable[i];
						 pZone != NULL;
						 pZone = pZone->zn_Next)
					{
						// If this packet cannot hold more, we're done
						if ((INT)(index + pZone->zn_ZoneLen + 1) >= Size)
						{
							PktFull = TRUE;
							break;
						}

						// Place zone name in the packet
						TdiCopyBufferToMdl( pZone->zn_Zone,
											0,
											pZone->zn_ZoneLen + 1,
											pAMdl,
											index,
											&BytesCopied);
						ASSERT (BytesCopied == (ULONG)(pZone->zn_ZoneLen + 1));
				
						NumZones ++;
						index += (pZone->zn_ZoneLen + 1);
					}
				}
				RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
				Status = ((pZone != NULL) || ( i < NUM_ZONES_HASH_BUCKETS)) ?
								ATALK_BUFFER_TOO_SMALL : ATALK_NO_ERROR;
			}
            ((PZIP_GETZONELIST_PARAMS)
							(pActReq->ar_pParms))->ZonesAvailable = NumZones;
			if (ATALK_SUCCESS(Status))
			{
				(*pActReq->ar_Completion)(Status, pActReq);
			}
			break;
		}

		ASSERT ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING) == 0);

		// Allocate a Completion info structure
		if ((pZci = AtalkAllocMemory(sizeof(ZIPCOMPLETIONINFO))) == NULL)
		{
			Status = ATALK_RESR_MEM;
			break;
		}
	
		// Initialize completion info
#if	DBG
		pZci->zci_Signature = ZCI_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pZci->zci_Lock);
		pZci->zci_RefCount = 1;
		pZci->zci_pPortDesc = pPortDesc;
		pZci->zci_pDdpAddr = NULL;
		pZci->zci_pAMdl = pAMdl;
		pZci->zci_BufLen = Size;
		pZci->zci_pActReq = pActReq;
		pZci->zci_Router.ata_Network = pPortDesc->pd_ARouter.atn_Network;
		pZci->zci_Router.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		pZci->zci_Router.ata_Socket = ZONESINFORMATION_SOCKET;
		pZci->zci_ExpirationCount = ZIP_GET_ZONEINFO_RETRIES;
		pZci->zci_NextZoneOff = 0;
		pZci->zci_ZoneCount = 0;
		pZci->zci_AtpRequestType = ZIP_GET_ZONE_LIST;
		AtalkTimerInitialize(&pZci->zci_Timer,
							 atalkZipZoneInfoTimer,
							 ZIP_GET_ZONEINFO_TIMER);
		if (fLocalZones)
			pZci->zci_AtpRequestType = ZIP_GET_LOCAL_ZONES;
		pZci->zci_Handler = atalkZipGetZoneListReply;
	
		Status = atalkZipSendPacket(pZci, TRUE);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("AtalkZipGetZoneList: atalkZipSendPacket %ld\n", Status));
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			Status = ATALK_PENDING;		// atalkZipDereferenceZci completes the req
		}
	} while (FALSE);

	if (PortLocked)
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	return(Status);
}



/***	atalkZipGetZoneListReply
 *
 */
VOID
atalkZipGetZoneListReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				Status,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
)
{
	PBYTE				pZone;
	ULONG				dindex;
	ULONG				BytesCopied;
	USHORT				ZoneCnt;
	BYTE				ZoneLen;
	BOOLEAN				LastFlag, Overflow = FALSE;

	ASSERT(VALID_ZCI(pZci));

	do
	{
		if (Status == ATALK_SOCKET_CLOSED)
		{
			pZci->zci_pDdpAddr = NULL;
			if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
			{
				atalkZipDereferenceZci(pZci);
			}
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			break;
		}

		if ((Status != ATALK_NO_ERROR) ||
			(DdpType != DDPPROTO_ATP) ||
			(PktLen <= ATP_ZIP_FIRST_ZONE_OFF))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		// We should have a zone list.
		// Cancel the timer. Start it again if we have not got all the zones
		if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
		{
			atalkZipDereferenceZci(pZci);
		}

		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipGetZoneListReply: More zones. Index %d, SizeLeft %d\n",
				pZci->zci_ZoneCount, pZci->zci_BufLen - pZci->zci_NextZoneOff));

		ACQUIRE_SPIN_LOCK_DPC(&pZci->zci_Lock);

		GETSHORT2SHORT(&ZoneCnt, pPkt + ATP_ZIP_ZONE_CNT_OFF);
		LastFlag = FALSE;
		if ((pPkt[ATP_ZIP_LAST_FLAG_OFF] != 0) ||
			(ZoneCnt == 0))
			LastFlag = TRUE;
		dindex = ATP_ZIP_FIRST_ZONE_OFF;

		while (ZoneCnt != 0)
		{
			// Pull out the next zone
			ZoneLen = pPkt[dindex++];
			if ((ZoneLen == 0) ||
				(ZoneLen > MAX_ZONE_LENGTH) ||
				(PktLen < (dindex + ZoneLen)))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipGetZoneListReply: Bad Zip reply\n"));
				break;
			}
			pZone = pPkt + dindex;
			dindex += ZoneLen;
			if ((pZci->zci_NextZoneOff + ZoneLen + 1) > pZci->zci_BufLen)
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipGetZoneList: Overflow\n"));
				Overflow = TRUE;
				break;
			}
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("AtalkZipGetZoneList: Copying a zone (%d, %d)\n",
					pZci->zci_ZoneCount,
					pZci->zci_BufLen - pZci->zci_NextZoneOff));
			TdiCopyBufferToMdl( pZone,
								0,
								ZoneLen,
								pZci->zci_pAMdl,
								pZci->zci_NextZoneOff,
								&BytesCopied);
			ASSERT (BytesCopied == ZoneLen);
	
			TdiCopyBufferToMdl( "",
								0,
								1,
								pZci->zci_pAMdl,
								pZci->zci_NextZoneOff + ZoneLen,
								&BytesCopied);
			pZci->zci_NextZoneOff += (ZoneLen + 1);
            pZci->zci_ZoneCount ++;
			ZoneCnt --;
		}

		RELEASE_SPIN_LOCK_DPC(&pZci->zci_Lock);

		if (Overflow || LastFlag)
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipGetZoneListReply: All that we wanted\n"));

			pZci->zci_FinalStatus = ATALK_NO_ERROR;
			if (Overflow)
				pZci->zci_FinalStatus = ATALK_BUFFER_TOO_SMALL;
            ((PZIP_GETZONELIST_PARAMS)
					(pZci->zci_pActReq->ar_pParms))->ZonesAvailable =
														pZci->zci_ZoneCount;
			atalkZipDereferenceZci(pZci);
		}
		else
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipGetZoneListReply: Sending another packet\n"));

			Status = atalkZipSendPacket(pZci, TRUE);
			if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("AtalkZipGetZoneListReply: atalkZipSendPacket %ld\n", Status));
				pZci->zci_FinalStatus = Status;
				atalkZipDereferenceZci(pZci);
			}
		}
	} while (FALSE);
}


/***	atalkZipZoneInfoTimer
 *
 */
LOCAL LONG FASTCALL
atalkZipZoneInfoTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
)
{
	PZIPCOMPLETIONINFO	pZci;
	ATALK_ERROR			Status;
	ULONG				BytesCopied;
	BOOLEAN				Done = FALSE, RestartTimer = FALSE;

	pZci = (PZIPCOMPLETIONINFO)CONTAINING_RECORD(pTimer, ZIPCOMPLETIONINFO, zci_Timer);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipZoneInfoTimer: Entered for pZci = %lx\n", pZci));

	ASSERT(VALID_ZCI(pZci));

	do
	{
		ACQUIRE_SPIN_LOCK_DPC(&pZci->zci_Lock);
		if (--(pZci->zci_ExpirationCount) != 0)
		{
			RestartTimer = TRUE;
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipZoneInfoTimer: Sending another packet\n", pZci));

			RELEASE_SPIN_LOCK_DPC(&pZci->zci_Lock);
			Status = atalkZipSendPacket(pZci, FALSE);
			if (!ATALK_SUCCESS(Status))
			{
				RestartTimer = FALSE;
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("atalkZipZoneInfoTimer: atalkZipSendPacket %ld\n",
						Status));

				pZci->zci_FinalStatus = Status;
				atalkZipDereferenceZci(pZci);
			}
			break;
		}

		if (pZci->zci_AtpRequestType == ZIP_GET_MY_ZONE)
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipZoneInfoTimer: Completing GetMyZone\n"));

			TdiCopyBufferToMdl("*",
								0,
								sizeof("*"),
								pZci->zci_pAMdl,
								0,
								&BytesCopied);
		}
		else	// GET_ZONE_LIST
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipZoneInfoTimer: Completing GetZoneList\n"));

			if ((pZci->zci_ZoneCount == 0) &&
				 ((SHORT)(pZci->zci_NextZoneOff + sizeof("*")) < pZci->zci_BufLen))
			{
				pZci->zci_ZoneCount++;
				TdiCopyBufferToMdl("*",
									0,
									sizeof("*"),
									pZci->zci_pAMdl,
									pZci->zci_NextZoneOff,
									&BytesCopied);
				ASSERT (BytesCopied == sizeof("*"));
			}
            ((PZIP_GETZONELIST_PARAMS)
				(pZci->zci_pActReq->ar_pParms))->ZonesAvailable =
														pZci->zci_ZoneCount;
		}

		RELEASE_SPIN_LOCK_DPC(&pZci->zci_Lock);
		atalkZipDereferenceZci(pZci);	// Timer reference

		pZci->zci_FinalStatus = ATALK_NO_ERROR;
		atalkZipDereferenceZci(pZci);
		ASSERT(!RestartTimer);

	} while (FALSE);

	return (RestartTimer ? ATALK_TIMER_REQUEUE : ATALK_TIMER_NO_REQUEUE);
}


/***	atalkZipSendPacket
 *
 */
ATALK_ERROR
atalkZipSendPacket(
	IN	PZIPCOMPLETIONINFO	pZci,
	IN	BOOLEAN				EnqueueTimer
)
{
	PBUFFER_DESC	pBuffDesc;
	ATALK_ERROR		Status;
	ATALK_ADDR		DestAddr;
	PBYTE			Datagram;
	SEND_COMPL_INFO	SendInfo;

	ASSERT (VALID_ZCI(pZci));

	if (pZci->zci_pDdpAddr == NULL)
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipSendPacket: Opening Ddp Socket\n"));

		// Open a socket for handling replies
		Status = AtalkDdpOpenAddress(pZci->zci_pPortDesc,
										UNKNOWN_SOCKET,
										NULL,
										pZci->zci_Handler,
										pZci,
										0,
										NULL,
										&pZci->zci_pDdpAddr);
	
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipSendPacket: AtalkDdpOpenAddress %ld\n", Status));
			return Status;
		}

        // mark the fact that this is an "internal" socket
        pZci->zci_pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

	}

	ASSERT (VALID_DDP_ADDROBJ(pZci->zci_pDdpAddr));

	// Alloc a buffer desciptor for the atp request
	if ((pBuffDesc = AtalkAllocBuffDesc(pZci->zci_Datagram,
										ZIP_GETZONELIST_DDPSIZE,
										BD_CHAR_BUFFER)) == NULL)
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipSendPacket: Couldn't allocate a buffdesc\n"));
		AtalkDdpCloseAddress(pZci->zci_pDdpAddr, NULL, NULL);
		return ATALK_RESR_MEM;
	}

	// Start the zone info timer
	if (EnqueueTimer)
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&pZci->zci_Lock, &OldIrql);
		pZci->zci_RefCount ++;			// For the timer
		AtalkTimerScheduleEvent(&pZci->zci_Timer);
		RELEASE_SPIN_LOCK(&pZci->zci_Lock, OldIrql);
	}

	// Build the Atp request and send it along
	Datagram = pBuffDesc->bd_CharBuffer;
	Datagram[ATP_CMD_CONTROL_OFF] = ATP_REQUEST;
	Datagram[ATP_BITMAP_OFF] = 1;
	Datagram[ATP_TRANS_ID_OFF] =  0;
	Datagram[ATP_TRANS_ID_OFF+1] =  0;
	Datagram[ATP_ZIP_CMD_OFF] = (BYTE)pZci->zci_AtpRequestType;
	Datagram[ATP_ZIP_CMD_OFF+1] = 0;

	PUTSHORT2SHORT(Datagram + ATP_ZIP_START_INDEX_OFF, pZci->zci_ZoneCount+1);

	//	Set the length in the buffer descriptor.
	AtalkSetSizeOfBuffDescData(pBuffDesc, ZIP_GETZONELIST_DDPSIZE);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipSendPacket: Sending the packet along\n"));

	DestAddr = pZci->zci_Router;
	SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
	SendInfo.sc_Ctx1 = pBuffDesc;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	if (!ATALK_SUCCESS(Status = AtalkDdpSend(pZci->zci_pDdpAddr,
											&DestAddr,
											DDPPROTO_ATP,
											FALSE,
											pBuffDesc,
											NULL,
											0,
											NULL,
											&SendInfo)))
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipSendPacket: AtalkDdpSend %ld\n", Status));

		AtalkFreeBuffDesc(pBuffDesc);
		if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
		{
			atalkZipDereferenceZci(pZci);
		}
	}
	else Status = ATALK_PENDING;
	return Status;
}


/***	atalkZipDereferenceZci
 *
 */
LOCAL VOID
atalkZipDereferenceZci(
	IN	PZIPCOMPLETIONINFO		pZci
)
{
	BOOLEAN	Done;
	KIRQL	OldIrql;

	ASSERT(VALID_ZCI(pZci));

	ACQUIRE_SPIN_LOCK(&pZci->zci_Lock, &OldIrql);
	Done  = (--(pZci->zci_RefCount) == 0);
	RELEASE_SPIN_LOCK(&pZci->zci_Lock, OldIrql);

	if (Done)
	{
		if (pZci->zci_pDdpAddr != NULL)
			AtalkDdpCloseAddress(pZci->zci_pDdpAddr, NULL, NULL);
		(*pZci->zci_pActReq->ar_Completion)(pZci->zci_FinalStatus, pZci->zci_pActReq);

		// Unlock the Zip stuff back again, if there are no more pending zip operations
		AtalkUnlockZipIfNecessary();
		AtalkFreeMemory(pZci);
	}
}


// We do not want to send too many queries per invocation of the timer. This is to avoid
// spending too much time within the timer Dpc and also using up all of the Ndis packets
// and buffers during this.
#define	MAX_QUERIES_PER_INVOCATION	75

// Structure used by the atalkZipQueryTimer routine
typedef struct	_QueryTimerData
{
	struct	_QueryTimerData *	qtd_Next;
	BOOLEAN						qtd_SkipThis;
	PBUFFER_DESC				qtd_pBuffDesc;
	ATALK_ADDR					qtd_DstAddr;
	PDDP_ADDROBJ				qtd_pDdpAddr;
} QTD, *PQTD;

/***	atalkZipQueryTimer
 *
 *	When we are a router and if any of our RTEs do not have a valid zone list, we send
 *	out queries to other routers who do.
 */
LOCAL LONG FASTCALL
atalkZipQueryTimer(
	IN	PTIMERLIST		pContext,
	IN	BOOLEAN			TimerShuttingDown
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ADDR			SrcAddr;
	PRTE				pRte;
	PBYTE				Datagram;
	PQTD				pQtd, pQtdStart = NULL, *ppQtd = &pQtdStart;
	ATALK_ERROR			Status;
	int					i, j;
	SEND_COMPL_INFO		SendInfo;

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	// Go through the routing tables and send out a query to any network
	// that we do not know the zone name of
	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock)
	for (i = 0, j = 0;
		 (i < NUM_RTMP_HASH_BUCKETS) && (j <= MAX_QUERIES_PER_INVOCATION);
		 i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pRte->rte_Next)
		{
			if (pRte->rte_Flags & RTE_ZONELIST_VALID)
            {
				continue;
            }

			// If login is to restrict access to zones over dial up connection
			// put restrictions here
            if (pRte->rte_PortDesc == RasPortDesc)
            {
                continue;
            }

			// Up the count of # of datagrams used. Do need exceed max.
			if (++j >= MAX_QUERIES_PER_INVOCATION)
				break;

			if (((pQtd = AtalkAllocMemory(sizeof(QTD))) == NULL) ||
				((pQtd->qtd_pBuffDesc = AtalkAllocBuffDesc(NULL,
									ZIP_ONEZONEQUERY_DDPSIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL))
			{
				if (pQtd != NULL)
					AtalkFreeMemory(pQtd);
				break;
			}
			*ppQtd = pQtd;
			pQtd->qtd_Next = NULL;
			ppQtd = &pQtd->qtd_Next;
			pQtd->qtd_SkipThis = FALSE;
			Datagram = pQtd->qtd_pBuffDesc->bd_CharBuffer;

			// Build the datagram and send it on its way
			Datagram[ZIP_CMD_OFF] = ZIP_QUERY;
			Datagram[ZIP_NW_CNT_OFF] = 1;
			PUTSHORT2SHORT(Datagram+ZIP_FIRST_NET_OFF,
						   pRte->rte_NwRange.anr_FirstNetwork);

			// Compute the source and destination
			SrcAddr.ata_Network = pRte->rte_PortDesc->pd_ARouter.atn_Network;
			SrcAddr.ata_Node = pRte->rte_PortDesc->pd_ARouter.atn_Node;
			SrcAddr.ata_Socket = ZONESINFORMATION_SOCKET;
			pQtd->qtd_DstAddr.ata_Socket = ZONESINFORMATION_SOCKET;

			if (pRte->rte_NumHops == 0)
			{
				pQtd->qtd_DstAddr = SrcAddr;
			}
			else
			{
				pQtd->qtd_DstAddr.ata_Network = pRte->rte_NextRouter.atn_Network;
				pQtd->qtd_DstAddr.ata_Node = pRte->rte_NextRouter.atn_Node;
			}

			// Map source address to the ddp address object (open socket)
			AtalkDdpReferenceByAddr(pRte->rte_PortDesc,
									&SrcAddr,
									&pQtd->qtd_pDdpAddr,
									&Status);

			if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipQueryTimer: DdpRefByAddr failed for %d.%d\n",
						SrcAddr.ata_Network, SrcAddr.ata_Node));
				pQtd->qtd_pDdpAddr = NULL;
				pQtd->qtd_SkipThis = TRUE;
			}
		}
	}
	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

	// We have a bunch of datagrams ready to be fired off.
	// Make it so.
	SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	for (pQtd = pQtdStart; pQtd != NULL; pQtd = pQtdStart)
	{
		pQtdStart = pQtd->qtd_Next;
	
		//	Set the length in the buffer descriptor.
        AtalkSetSizeOfBuffDescData(pQtd->qtd_pBuffDesc, ZIP_ONEZONEQUERY_DDPSIZE);

		SendInfo.sc_Ctx1 = pQtd->qtd_pBuffDesc;
		if (pQtd->qtd_SkipThis ||
			!ATALK_SUCCESS(AtalkDdpSend(pQtd->qtd_pDdpAddr,
										&pQtd->qtd_DstAddr,
										DDPPROTO_ZIP,
										FALSE,
										pQtd->qtd_pBuffDesc,
										NULL,
										0,
										NULL,
										&SendInfo)))
		{
			AtalkFreeBuffDesc(pQtd->qtd_pBuffDesc);
		}

		if (pQtd->qtd_pDdpAddr != NULL)
			AtalkDdpDereferenceDpc(pQtd->qtd_pDdpAddr);
		AtalkFreeMemory(pQtd);
	}

	return ATALK_TIMER_REQUEUE;
}


/***	atalkZipGetZoneListForPort
 *
 */
LOCAL BOOLEAN
atalkZipGetZoneListForPort(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{
	PRTE					pRte;
	PBUFFER_DESC			pBuffDesc = NULL;
	ATALK_ADDR				SrcAddr, DstAddr;
	ATALK_ERROR				Status;
	KIRQL					OldIrql;
	int						NumReqs = 0;
	BOOLEAN					RetCode = FALSE;
	BYTE					MulticastAddr[ELAP_ADDR_LEN];
	SEND_COMPL_INFO			SendInfo;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	// Similar to RTMP finding out the network number attached to port, our
	// task is to find out the zone list of the network attached to a
	// particular port.  We too don't want to mess up a working AppleTalk
	// internet.  So, spend a little while doing zone queries to see if the
	// network already has a zone list -- if we find one, use it; else, we
	// had better be a seed router.

	// Set source and destination address
	SrcAddr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
	SrcAddr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
	SrcAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	DstAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
	DstAddr.ata_Node = ATALK_BROADCAST_NODE;
	DstAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	if ((pRte = AtalkRtmpReferenceRte(pPortDesc->pd_NetworkRange.anr_FirstNetwork)) == NULL)
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipGetZoneListForPort: Could not reference Rte for nwrange on port\n"));
		return FALSE;
	}

	// Blast a few queries and see if anybody knows our zone-name
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	pPortDesc->pd_Flags |= PD_FINDING_DEFAULT_ZONE;
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;

	while ((NumReqs < (ZIP_NUM_QUERIES * ZIP_NUM_RETRIES)) &&
		   !(pRte->rte_Flags & RTE_ZONELIST_VALID))
	{
		if ((NumReqs % ZIP_NUM_RETRIES) == 0)
		{
			if ((pBuffDesc = AtalkAllocBuffDesc(NULL, ZIP_ONEZONEQUERY_DDPSIZE,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
			{
				break;
			}
	
			pBuffDesc->bd_CharBuffer[ZIP_CMD_OFF] = ZIP_QUERY;
			pBuffDesc->bd_CharBuffer[ZIP_NW_CNT_OFF] = 1;
			PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ZIP_FIRST_NET_OFF,
						   pPortDesc->pd_NetworkRange.anr_FirstNetwork);
	
			//	Set the length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pBuffDesc, ZIP_ONEZONEQUERY_DDPSIZE);

			SendInfo.sc_Ctx1 = pBuffDesc;
			Status = AtalkDdpTransmit(pPortDesc,
									  &SrcAddr,
									  &DstAddr,
									  DDPPROTO_ZIP,
									  pBuffDesc,
									  NULL,
									  0,
									  0,
									  NULL,
									  NULL,
									  &SendInfo);
            if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipGetZoneListForPort: AtalkDdpTransmit %ld\n", Status));
				break;
			}
			pBuffDesc = NULL;
		}
		NumReqs++;
		AtalkSleep(ZIP_QUERY_WAIT);
	}

	// We either got an answer or we did not. In the latter case we should
	// be seeding.
	do
	{
		if (pRte->rte_Flags &  RTE_ZONELIST_VALID)
		{
			// We got an answer. The valid zone list is in the routing table
			// Move it to the port descriptor
			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
	
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipGetZoneListForPort: Moving ZoneList from Rte to Port %Z\n",
					&pPortDesc->pd_AdapterKey));

			pPortDesc->pd_ZoneList = AtalkZoneCopyList(pRte->rte_ZoneList);

			RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			if (pPortDesc->pd_ZoneList == NULL)
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("atalkZipGetZoneListForPort: Failed to Move ZoneList from Rte to Port\n"));
				break;
			}

			// If this is an extended network, we should already have "ThisZone"
			// set (due to GetNetInfo's when we allocated this node), if not
			// find out the true default zone

			if (EXT_NET(pPortDesc))
			{
				PDDP_ADDROBJ	pDdpAddr = NULL;
				ATALK_ADDR		Addr;
				ATALK_ERROR		Status;

				// The router's Zip packet handler doesn't want to be told
				// about zones (it thinks it knows), so it ignores
				// NetInfoReplies. Switch back to the non-router Zip handler
				// while we do a GetNetworkInfoForNode
				Addr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
				Addr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
				Addr.ata_Socket = ZONESINFORMATION_SOCKET;
				AtalkDdpReferenceByAddr(pPortDesc, &Addr, &pDdpAddr, &Status);

				if (!ATALK_SUCCESS(Status))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
							("atalkZipGetZoneListForPort: AtalkDdpRefByAddr %ld for %d.%d\n",
							Status, Addr.ata_Network, Addr.ata_Node));
					break;
				}

				AtalkDdpNewHandlerForSocket(pDdpAddr,
											AtalkZipPacketIn,
											pPortDesc);
				if ((!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) &&
					 !AtalkZipGetNetworkInfoForNode(pPortDesc,
												   &pPortDesc->pd_ARouter,
												   FALSE)) ||
					!AtalkZipGetNetworkInfoForNode(pPortDesc,
												   &pPortDesc->pd_ARouter,
												   TRUE))
				{
					AtalkDdpDereference(pDdpAddr);
					break;
				}

				// Switch back the handler to the router's version
				AtalkDdpNewHandlerForSocket(pDdpAddr,
											AtalkZipPacketInRouter,
											pPortDesc);

				AtalkDdpDereference(pDdpAddr);

				// The default zone had better be on the list we just
				// received
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
				if (!AtalkZoneOnList(pPortDesc->pd_DefaultZone,
									 pPortDesc->pd_ZoneList) ||
					!AtalkZoneOnList(pPortDesc->pd_DesiredZone,
									 pPortDesc->pd_ZoneList))
				{
					DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
							("atalkZipGetZoneListForPort: Ext port, Default/Desired zone not on list\n"));

				}
				else RetCode = TRUE;
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			}
			else
			{
				// On non-extended network, the one entry on the zone list
				// should also be "ThisZone"
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
				if (pPortDesc->pd_DesiredZone != NULL)
					AtalkZoneDereference(pPortDesc->pd_DesiredZone);
				AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
										pPortDesc->pd_ZoneList->zl_pZone);
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
                RetCode = TRUE;
			}
			break;
		}

		// We did not get an answer. We had better be able to seed. There is
		// a chance that we got "ThisZone" set when allocating our node and
		// whatever router told us that went down before we could ask for the
		// zone list - so de-allocate the multicast address, if any first
		if ((pPortDesc->pd_Flags & (PD_EXT_NET | PD_VALID_DESIRED_ZONE)) ==
										(PD_EXT_NET | PD_VALID_DESIRED_ZONE))
		{
			if (!AtalkFixedCompareCaseSensitive(pPortDesc->pd_ZoneMulticastAddr,
												pPortDesc->pd_BroadcastAddrLen,
                                                pPortDesc->pd_BroadcastAddr,
												pPortDesc->pd_BroadcastAddrLen))
				(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
														pPortDesc->pd_ZoneMulticastAddr,
														FALSE,
														NULL,
														NULL);
		}

		// Now we better know enough to seed
		if (pPortDesc->pd_InitialZoneList == NULL)
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipGetZoneListForPort: %sExt port, NULL InitialZoneList\n",
					EXT_NET(pPortDesc) ? "" : "Non"));
			break;
		}

		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipGetZoneListForPort: Moving Initial ZoneList to Current on port %Z\n",
				&pPortDesc->pd_AdapterKey));

		pPortDesc->pd_ZoneList = AtalkZoneCopyList(pPortDesc->pd_InitialZoneList);

		if (EXT_NET(pPortDesc))
		{
			// We need to seed the default zone too
			AtalkZoneReferenceByPtr(pPortDesc->pd_DefaultZone =
											pPortDesc->pd_InitialDefaultZone);
			pPortDesc->pd_Flags |= PD_VALID_DEFAULT_ZONE;
			if (pPortDesc->pd_InitialDesiredZone != NULL)
			{
				AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
											pPortDesc->pd_InitialDesiredZone);
			}
			else
			{
				AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
										pPortDesc->pd_InitialDefaultZone);
			}

			// Finally set the zone multicast address
			AtalkZipMulticastAddrForZone(pPortDesc,
										pPortDesc->pd_DesiredZone->zn_Zone,
										pPortDesc->pd_DesiredZone->zn_ZoneLen,
										MulticastAddr);

			if (!AtalkFixedCompareCaseSensitive(MulticastAddr,
												pPortDesc->pd_BroadcastAddrLen,
                                                pPortDesc->pd_BroadcastAddr,
												pPortDesc->pd_BroadcastAddrLen))
			{
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				(*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
													 MulticastAddr,
													 FALSE,
													 NULL,
													 NULL);
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			}
			RtlCopyMemory(pPortDesc->pd_ZoneMulticastAddr,
						  MulticastAddr,
						  pPortDesc->pd_BroadcastAddrLen);
		}
		else
		{
			// On non-extended networks, this (desired/default)should be the
			// only one on zone-list
			AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
									pPortDesc->pd_ZoneList->zl_pZone);
		}
		pPortDesc->pd_Flags |= PD_VALID_DESIRED_ZONE;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
		RetCode = TRUE;
	} while (FALSE);

	AtalkRtmpDereferenceRte(pRte, FALSE);
	if (pBuffDesc != NULL)
	{
		AtalkFreeBuffDesc(pBuffDesc);
	}
	return(RetCode);
}




/***	AtalkZipZoneReferenceByName
 *
 */
PZONE
AtalkZoneReferenceByName(
	IN	PBYTE	ZoneName,
	IN	BYTE	ZoneLen
)
{
	PZONE	pZone;
	BYTE	Len;
	KIRQL	OldIrql;
	ULONG	i, Hash;

	for (i = 0, Hash = 0, Len = ZoneLen;
		 Len > 0;
		 Len --, i++)
	{
		Hash <<= 1;
		Hash += AtalkUpCaseTable[ZoneName[i]];
	}

	Hash %= NUM_ZONES_HASH_BUCKETS;

	ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

	for (pZone = AtalkZonesTable[Hash];
		 pZone != NULL;
		 pZone = pZone->zn_Next)
	{
		if (AtalkFixedCompareCaseInsensitive(ZoneName,
											 ZoneLen,
											 pZone->zn_Zone,
											 pZone->zn_ZoneLen))
		{
			pZone->zn_RefCount ++;
			break;
		}
	}

	if (pZone == NULL)
	{
		if ((pZone = (PZONE)AtalkAllocMemory(sizeof(ZONE) + ZoneLen)) != NULL)
		{
			pZone->zn_RefCount = 1;
			pZone->zn_ZoneLen = ZoneLen;
			RtlCopyMemory(pZone->zn_Zone, ZoneName, ZoneLen);
			pZone->zn_Zone[ZoneLen] = 0;
			AtalkLinkDoubleAtHead(AtalkZonesTable[Hash],
								  pZone,
								  zn_Next,
								  zn_Prev);
		}
	}

	RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
	return(pZone);
}


/***	AtalkZipZoneReferenceByPtr
 *
 */
VOID
AtalkZoneReferenceByPtr(
	IN	PZONE	pZone
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

	pZone->zn_RefCount++;

	RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
}


/***	AtalkZoneDereference
 *
 */
VOID
AtalkZoneDereference(
	IN	PZONE	pZone
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

	if (--pZone->zn_RefCount == 0)
	{
		AtalkUnlinkDouble(pZone, zn_Next, zn_Prev);
		AtalkFreeMemory(pZone);
	}

	RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
}


/***	AtalkZipZoneFreeList
 *
 */
VOID
AtalkZoneFreeList(
	IN	PZONE_LIST	pZoneList
)
{
	PZONE_LIST	pNextZone;

	for (; pZoneList != NULL; pZoneList = pNextZone)
	{
		pNextZone = pZoneList->zl_Next;
		AtalkZoneDereference(pZoneList->zl_pZone);
		AtalkFreeMemory(pZoneList);
	}
}


/***	AtalkZoneNameOnList
 *
 */
BOOLEAN
AtalkZoneNameOnList(
	IN	PBYTE		ZoneName,
	IN	BYTE		ZoneLen,
	IN	PZONE_LIST	pZoneList
)
{
	 for ( ; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
		if (AtalkFixedCompareCaseInsensitive(pZoneList->zl_pZone->zn_Zone,
											 pZoneList->zl_pZone->zn_ZoneLen,
											 ZoneName, ZoneLen))
			return(TRUE);

	return(FALSE);
}

/***	AtalkZipZoneOnList
 *
 */
BOOLEAN
AtalkZoneOnList(
	IN	PZONE		pZone,
	IN	PZONE_LIST	pZoneList
)
{
	 for ( ; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
		if (pZoneList->zl_pZone == pZone)
			return(TRUE);

	return(FALSE);
}

/***	AtalkZipZone
 *
 */
ULONG
AtalkZoneNumOnList(
	IN	PZONE_LIST	pZoneList
)
{
	ULONG	Cnt;

	for (Cnt = 0; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
		Cnt++;
	return Cnt;
}


/***	AtalkZipZoneAddToList
 *
 */
PZONE_LIST
AtalkZoneAddToList(
	IN	PZONE_LIST	pZoneList,
	IN	PBYTE		ZoneName,
	IN	BYTE		ZoneLen
)
{
	PZONE_LIST		pNewZoneList;
	PZONE			pZone;

	// Get memory for a new ZoneList node.
	pNewZoneList = (PZONE_LIST)AtalkAllocMemory(sizeof(ZONE_LIST));

	if (pNewZoneList != NULL)
	{
		if ((pZone = AtalkZoneReferenceByName(ZoneName, ZoneLen)) != NULL)
		{
		    pNewZoneList->zl_Next = pZoneList;
			pNewZoneList->zl_pZone = pZone;
		}
		else
		{
			AtalkZoneFreeList(pNewZoneList);
			pNewZoneList = NULL;
		}
	}
	else
	{
		AtalkZoneFreeList(pZoneList);
	}

	return(pNewZoneList);
}


/***	AtalkZipZoneCopyList
 *
 */
PZONE_LIST
AtalkZoneCopyList(
	IN	PZONE_LIST	pZoneList
)
{
	PZONE_LIST	pNewZoneList,
				pZoneListStart = NULL,
				*ppZoneList = &pZoneListStart;

	for (; pZoneList != NULL; pZoneList = pZoneList = pZoneList->zl_Next)
	{
		pNewZoneList = AtalkAllocMemory(sizeof(ZONE_LIST));
		if (pNewZoneList == NULL)
		{
			break;
		}
		pNewZoneList->zl_Next = NULL;
		pNewZoneList->zl_pZone = pZoneList->zl_pZone;
		*ppZoneList = pNewZoneList;
		ppZoneList = &pNewZoneList->zl_Next;
		AtalkZoneReferenceByPtr(pNewZoneList->zl_pZone);
	}
	if (pNewZoneList == NULL)
	{
		AtalkZoneFreeList(pZoneListStart);
	}
	return(pZoneListStart);
}


/***	atalkZipSendComplete
 *
 */
VOID FASTCALL
atalkZipSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
)
{
	PBUFFER_DESC	pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx1);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipSendComplete: Freeing BuffDesc %lx\n", pBuffDesc));
	if (!ATALK_SUCCESS(Status))
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipSendComplete: Failed %lx, pBuffDesc %lx\n",
				Status, pBuffDesc));

	AtalkFreeBuffDesc(pBuffDesc);
}

#if DBG
VOID
AtalkZoneDumpTable(
	VOID
)
{
	int		i;
	PZONE	pZone;

	ACQUIRE_SPIN_LOCK_DPC(&AtalkZoneLock);

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("ZONETABLE: \n"));
	for (i = 0; i < NUM_ZONES_HASH_BUCKETS; i ++)
	{
		for (pZone = AtalkZonesTable[i]; pZone != NULL; pZone = pZone->zn_Next)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("\t\t%s\n", pZone->zn_Zone));
		}
	}

	RELEASE_SPIN_LOCK_DPC(&AtalkZoneLock);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\winsock\wshatalk.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	wshatalk.h

Abstract:


Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	10 Jul 1992	 Initial Version

--*/

#include	"atalktdi.h"
#include	"atalkwsh.h"		// winsock header file for appletalk

#define WSH_ATALK_ADSPSTREAM	L"\\Device\\AtalkAdsp\\Stream"
#define WSH_ATALK_ADSPRDM		L"\\Device\\AtalkAdsp"
#define WSH_ATALK_PAPRDM		L"\\Device\\AtalkPap"

#define WSH_KEYPATH_CODEPAGE  \
		TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Codepage")

#define	WSHREG_VALNAME_CODEPAGE  			TEXT("MACCP")

//
// Device names for DDP need protocol field at the end - defined in wshdata.h
//

//
// Structure and variables to define the triples supported by Appletalk. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
	INT AddressFamily;
	INT SocketType;
	INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;


//
// The socket context structure for this DLL. Each open Appletalk socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHATALK_SOCKET_CONTEXT
{
	INT		AddressFamily;
	INT		SocketType;
	INT		Protocol;
} WSHATALK_SOCKET_CONTEXT, *PWSHATALK_SOCKET_CONTEXT;




//
// Forward declarations of internal routines.
//

BOOL FAR PASCAL
WshDllInitialize(
	HINSTANCE 	hInstance,
    DWORD  		nReason,
    LPVOID 		pReserved);

BOOLEAN
WshRegGetCodePage(
	VOID);

BOOLEAN
WshNbpNameToMacCodePage(
	IN	OUT	PWSH_NBP_NAME	pNbpName);

BOOLEAN
WshNbpNameToOemCodePage(
	IN	OUT	PWSH_NBP_NAME	pNbpName);

BOOLEAN
WshZoneListToOemCodePage(
	IN	OUT	PUCHAR		pZoneList,
	IN		USHORT		NumZones);

BOOLEAN
WshConvertStringMacToOem(
	IN	PUCHAR	pSrcMacString,
	IN	USHORT	SrcStringLen,
	OUT	PUCHAR	pDestOemString,
	IN	PUSHORT	pDestStringLen);

BOOLEAN
WshConvertStringOemToMac(
	IN	PUCHAR	pSrcOemString,
	IN	USHORT	SrcStringLen,
	OUT	PUCHAR	pDestMacString,
	IN	PUSHORT	pDestStringLen);

INT
WSHNtStatusToWinsockErr(
	IN	NTSTATUS	Status);

BOOLEAN
IsTripleInList (
	IN PMAPPING_TRIPLE	List,
	IN ULONG			ListLength,
	IN INT				AddressFamily,
	IN INT				SocketType,
	IN INT				Protocol);

VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock);

//
// Macros
//


#if DBG
#define DBGPRINT(Fmt)											\
        {														\
			DbgPrint("WSHATALK: ");								\
			DbgPrint Fmt;										\
		}

#define DBGBRK()               									\
		{														\
				DbgBreakPoint();								\
		}
#else

#define DBGPRINT(Fmt)
#define DBGBRK()

#endif

#define	SOCK_TO_TDI_ATALKADDR(tdiAddr, sockAddr)								\
		{																		\
			(tdiAddr)->TAAddressCount	= 1;										\
			(tdiAddr)->Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);	\
			(tdiAddr)->Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;		\
			(tdiAddr)->Address[0].Address[0].Network = (sockAddr)->sat_net;			\
			(tdiAddr)->Address[0].Address[0].Node = (sockAddr)->sat_node;			\
			(tdiAddr)->Address[0].Address[0].Socket = (sockAddr)->sat_socket;		\
		}


#define	TDI_TO_SOCK_ATALKADDR(sockAddr, tdiAddr)				\
		{																		\
			(sockAddr)->sat_family	= AF_APPLETALK;								\
			(sockAddr)->sat_net		= (tdiAddr)->Address[0].Address[0].Network;	\
			(sockAddr)->sat_node	= (tdiAddr)->Address[0].Address[0].Node;	\
			(sockAddr)->sat_socket	= (tdiAddr)->Address[0].Address[0].Socket;	\
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\inc\atalktdi.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	atalktdi.h

Abstract:

	This file defines the interface that will be offered to the layers of the
	stack

Author:

	Nikhil Kamkolkar (NikhilK)	8-Jun-1992

Revision History:

--*/

#ifndef	_ATALKTDI_H
#define	_ATALKTDI_H

//
// The provider names supported by the Appletalk stack
//

#define ATALKDDP_DEVICENAME		L"\\Device\\AtalkDdp"
#define ATALKADSP_DEVICENAME	L"\\Device\\AtalkAdsp"
#define ATALKASPS_DEVICENAME	L"\\Device\\AtalkAspServer"
#define ATALKASPC_DEVICENAME	L"\\Device\\AtalkAspClient"
#define ATALKPAP_DEVICENAME		L"\\Device\\AtalkPap"
#define ATALKARAP_DEVICENAME	L"\\Device\\AtalkArap"

//
// The following is passed in the TdiAction calls to reaffirm that
// the request is meant for the Appletalk transport.
//

#define MATK	(*(ULONG *)"MATK")

//
// Options buffer for all the calls
//

typedef struct _OPTIONS_CONNINF
{
	union
	{
		int ProtocolType;
		TRANSPORT_ADDRESS	Address;

		struct
		{
			TRANSPORT_ADDRESS	RemoteAddress;
			USHORT	WorkstationQuantum;
			USHORT	ServerQuantum;
		} PapInfo;
	};
} OPTIONS_CONNINF, *POPTIONS_CONNINF;
#define OPTIONS_LENGTH	sizeof(OPTIONS_CONNINF)

typedef	union
{
	struct
	{
		USHORT		Network;
		UCHAR		Node;
		UCHAR       Socket;
	};
	ULONG			Address;
} ATALK_ADDRESS, *PATALK_ADDRESS;

//
// ACTION CODES:
// The NBP/ZIP primitives are available to all the providers. The action
// codes for those are defined first. Following this are the action
// codes specific to each provider. To insert a new action code, just
// tag it at the end of the action codes for a particular block (common/
// provider specific), and increment the max for that block.
//
// *IMPORTANT*
// These are tightly integrated with the dispatch table for the action
// routines in ATKINIT.C
//


#define COMMON_ACTIONBASE					0
#define MIN_COMMON_ACTIONCODE				(COMMON_ACTIONBASE)

#define COMMON_ACTION_NBPLOOKUP				(COMMON_ACTIONBASE)
#define COMMON_ACTION_NBPCONFIRM			(COMMON_ACTIONBASE+0x01)
#define COMMON_ACTION_NBPREGISTER			(COMMON_ACTIONBASE+0x02)
#define COMMON_ACTION_NBPREMOVE				(COMMON_ACTIONBASE+0x03)

#define COMMON_ACTION_ZIPGETMYZONE			(COMMON_ACTIONBASE+0x04)
#define COMMON_ACTION_ZIPGETZONELIST		(COMMON_ACTIONBASE+0x05)
#define COMMON_ACTION_ZIPGETLZONES			(COMMON_ACTIONBASE+0x06)
#define COMMON_ACTION_ZIPGETLZONESONADAPTER (COMMON_ACTIONBASE+0x07)
#define	COMMON_ACTION_ZIPGETADAPTERDEFAULTS	(COMMON_ACTIONBASE+0x08)

#define	COMMON_ACTION_GETSTATISTICS			(COMMON_ACTIONBASE+0x09)
#define MAX_COMMON_ACTIONCODE				(COMMON_ACTIONBASE+0x09)
#define COMMON_ACTIONCODES					(MAX_COMMON_ACTIONCODE - MIN_COMMON_ACTIONCODE + 1)

//
// Provider specific action codes
//

//
// DDP
//
// NONE
//

//
// ADSP
//

#define ADSP_ACTIONBASE					(MAX_COMMON_ACTIONCODE + 0x01)
#define MIN_ADSPACTIONCODE				(ADSP_ACTIONBASE)
	
#define ACTION_ADSPFORWARDRESET			(ADSP_ACTIONBASE)
	
#define MAX_ADSPACTIONCODE				(ADSP_ACTIONBASE)
#define ADSP_SPECIFIC_ACTIONCODES		(MAX_ADSPACTIONCODE - MIN_ADSPACTIONCODE + 1)

//
// ASP Client
//

#define ASPC_ACTIONBASE					(MAX_ADSPACTIONCODE + 0x01)
#define MIN_ASPCACTIONCODE				(ATP_ACTIONBASE)

#define ACTION_ASPCGETSTATUS			(ASPC_ACTIONBASE)
#define ACTION_ASPCCOMMAND				(ASPC_ACTIONBASE+0x01)
#define ACTION_ASPCWRITE				(ASPC_ACTIONBASE+0x02)

// The following 2 are for NBP, stole 2 slots here that were reserved
#define COMMON_ACTION_NBPREGISTER_BY_ADDR	(ASPC_ACTIONBASE+0x03)
#define COMMON_ACTION_NBPREMOVE_BY_ADDR		(ASPC_ACTIONBASE+0x04)
#define ACTION_ASPCRESERVED3			(ASPC_ACTIONBASE+0x05)

#define MAX_ASPCACTIONCODE				(ASPC_ACTIONBASE+0x05)
#define ASPC_SPECIFIC_ACTIONCODES		(MAX_ASPCACTIONCODE - MIN_ASPCACTIONCODE + 1)


//
// ASP Server
//

#define ASP_ACTIONBASE					(MAX_ASPCACTIONCODE + 0x01)
#define MIN_ASPACTIONCODE				(ASP_ACTIONBASE)
	
#define	ACTION_ASP_BIND					(ASP_ACTIONBASE)
	
#define MAX_ASPACTIONCODE				(ASP_ACTIONBASE)
#define ASP_SPECIFIC_ACTIONCODES		(MAX_ASPACTIONCODE - MIN_ASPACTIONCODE + 1)
	
//                                  	
// PAP                              	
//                                  	
	
#define PAP_ACTIONBASE					(MAX_ASPACTIONCODE + 0x01)
#define MIN_PAPACTIONCODE				(PAP_ACTIONBASE)
	
#define ACTION_PAPGETSTATUSSRV			(PAP_ACTIONBASE)
#define ACTION_PAPSETSTATUS				(PAP_ACTIONBASE+0x01)
#define	ACTION_PAPPRIMEREAD				(PAP_ACTIONBASE+0x02)
	
#define MAX_PAPACTIONCODE				(PAP_ACTIONBASE+0x02)
#define PAP_SPECIFIC_ACTIONCODES		(MAX_PAPACTIONCODE - MIN_PAPACTIONCODE + 1)
	
#define MAX_ALLACTIONCODES				(MAX_PAPACTIONCODE)

//
// STRUCTURE Definitions for the ACTION routines for all the providers
//




//
// NBP Interface
//

//
// **WARNING**
// The structure WSH_NBP_NAME is defined to be exactly like this in atalkwsh.h
// Change both if they ever need to be changed
//

#define MAX_ENTITY	32

typedef struct
{
	UCHAR					ObjectNameLen;
	UCHAR					ObjectName[MAX_ENTITY];
	UCHAR					TypeNameLen;
	UCHAR					TypeName[MAX_ENTITY];
	UCHAR					ZoneNameLen;
	UCHAR					ZoneName[MAX_ENTITY];
} NBP_NAME, *PNBP_NAME;

typedef struct
{
	ATALK_ADDRESS			Address;
	USHORT					Enumerator;
	NBP_NAME				NbpName;
} NBP_TUPLE, *PNBP_TUPLE;

//
// NBP Lookup
//

typedef struct
{
	NBP_TUPLE				LookupTuple;
	USHORT					NoTuplesRead;

} NBP_LOOKUP_PARAMS, *PNBP_LOOKUP_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	NBP_LOOKUP_PARAMS		Params;

	//
	// NBP_TUPLE			NbpTuples[]
	//

} NBP_LOOKUP_ACTION, *PNBP_LOOKUP_ACTION;

//
// NBP Confirm
//

typedef struct
{
	NBP_TUPLE				ConfirmTuple;

} NBP_CONFIRM_PARAMS, *PNBP_CONFIRM_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	NBP_CONFIRM_PARAMS		Params;

} NBP_CONFIRM_ACTION, *PNBP_CONFIRM_ACTION;

//
// NBP Register/Deregister- Address Object
// Use the following for both register/deregister on their
// respective objects
//

typedef struct
{
	union
	{
		NBP_TUPLE			RegisterTuple;
		NBP_TUPLE			RegisteredTuple;
	};

} NBP_REGDEREG_PARAMS, *PNBP_REGDEREG_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	NBP_REGDEREG_PARAMS		Params;

} NBP_REGDEREG_ACTION, *PNBP_REGDEREG_ACTION;




//
// ZIP Interface
//

//
// ZIP GetMyZone
//

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

	//
	// CHAR	ZoneName[]
	// Maximum of MAX_ENTITYNAME+1
	//

} ZIP_GETMYZONE_ACTION, *PZIP_GETMYZONE_ACTION;

//
// ZIP GetZoneList
//

typedef struct
{
	LONG					ZonesAvailable;

} ZIP_GETZONELIST_PARAMS, *PZIP_GETZONELIST_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	ZIP_GETZONELIST_PARAMS	Params;

	//
	// CHAR					ZoneListBuffer[];
	//

} ZIP_GETZONELIST_ACTION, *PZIP_GETZONELIST_ACTION;

//
// ZIP GetLocalZones
// This uses the same structure as that for the GetZoneList command
//

//
// ZIP GetLocalZonesOnAdapter
// This uses the same structure as for the GetZoneList command, with the
// condition that the adapter name follows the structure as a null
// terminated double-byte string. It will be overwritten upon return
// by the zone names.
//

//
// ZIP GetAdaptorDefaults (Network Range & Default Zone)
//
// The adapter name follows the structure as a null terminated double-byte
// string. This is replaced by the zone name.

typedef struct
{
	USHORT					NwRangeLowEnd;
	USHORT					NwRangeHighEnd;

} ZIP_GETPORTDEF_PARAMS, *PZIP_GETPORTDEF_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	ZIP_GETPORTDEF_PARAMS	Params;

	// INPUT:
	// WCHAR				AdaptorName
	// Maximum of MAX_ENTITYNAME+1
	//
	// OUTPUT:
	// BYTE					DefZone[MAX_ENTITY+1];
} ZIP_GETPORTDEF_ACTION, *PZIP_GETPORTDEF_ACTION;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

	// OUTPUT:
	// Appletalk statistics structure
} GET_STATISTICS_ACTION, *PGET_STATISTICS_ACTION;

//
// DDP Interface
// NONE
//


//
// ADSP Interface- specific action routines for ADSP
//

//
// ADSP Forward Reset
//

typedef struct _ADSP_FORWARDRESET_ACTION
{
	TDI_ACTION_HEADER		ActionHeader;
} ADSP_FORWARDRESET_ACTION, *PADSP_FORWARDRESET_ACTION;




//
// ASP Client Interface- specific action routines for ASP Client
//

//
// ASP GetStatus
//
typedef struct
{
	TA_APPLETALK_ADDRESS		ServerAddr;

} ASPC_GETSTATUS_PARAMS, *PASPC_GETSTATUS_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER			ActionHeader;
	ASPC_GETSTATUS_PARAMS		Params;

} ASPC_GETSTATUS_ACTION, *PASPC_GETSTATUS_ACTION;

//
// ASP Command or Write
//
typedef struct
{
	USHORT						CmdSize;
	USHORT						WriteAndReplySize;
	// BYTE						CmdBuff[CmdSize];
	// BYTE						WriteAndReplyBuf[ReplySize];

} ASPC_COMMAND_OR_WRITE_PARAMS, *PASPC_COMMAND_OR_WRITE_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER			ActionHeader;
	ASPC_COMMAND_OR_WRITE_PARAMS Params;

} ASPC_COMMAND_OR_WRITE_ACTION, *PASPC_COMMAND_OR_WRITE_ACTION;

typedef struct
{
	TDI_ACTION_HEADER			ActionHeader;

} ASPC_RESERVED_ACTION, *PASPC_RESERVED_ACTION;

//
// ASP Server Interface- action routines specific to ASP Server
//

typedef	PVOID	CONNCTXT;

typedef struct
{
	PUCHAR		rq_RequestBuf;
	LONG		rq_RequestSize;
	union
	{
		PMDL	rq_WriteMdl;
		PMDL	rq_ReplyMdl;
	};
    PVOID       rq_CacheMgrContext;

} REQUEST, *PREQUEST;

typedef	VOID		(FASTCALL *CLIENT_CLOSE_COMPLETION)(
					IN	NTSTATUS				Status,
					IN	PVOID					pCloseCtxt);

typedef	VOID        (FASTCALL *CLIENT_REPLY_COMPLETION)(
					IN	NTSTATUS				Status,
					IN	PVOID					pReplyCtxt,
					IN  PREQUEST                Request);

                    // Returns context to associate for this session
typedef	CONNCTXT	(FASTCALL *CLIENT_SESSION_NOTIFY)(	
					IN	PVOID					pConnection,
                    IN  BOOLEAN                 fOverTcp);

typedef	NTSTATUS    (FASTCALL *CLIENT_REQUEST_NOTIFY)(
					IN	NTSTATUS				Status,
					IN	PVOID					ConnCtxt,
					IN	PREQUEST				Request);

                    // Returns MDL describing the buffer
typedef	NTSTATUS    (FASTCALL *CLIENT_GET_WRITEBUFFER)(
                    IN  PVOID                   pSda,
					IN	PREQUEST			    pRequest);

typedef	VOID		(FASTCALL *CLIENT_ATTN_COMPLETION)(
					IN	PVOID					pContext);

typedef	NTSTATUS	(*ASP_CLOSE_CONN)(
					IN	PVOID					pConnection);

typedef	NTSTATUS	(*ASP_FREE_CONN)(
					IN	PVOID					pConnection);

typedef	NTSTATUS	(FASTCALL *ASP_LISTEN_CONTROL)(		// Synchronous
					IN	PVOID					pAspCtxt,
					IN	BOOLEAN					Active);

typedef	NTSTATUS	(*ASP_SET_STATUS)(			// Synchronous
					IN	PVOID					pAspCtxt,
					IN	PUCHAR					pStatus,
					IN	USHORT					StatusSize);

typedef NTSTATUS    (FASTCALL *ASP_WRITE_CONTINUE)(
                    IN  PVOID   PREQUEST);

typedef	NTSTATUS	(FASTCALL *ASP_REPLY)(
					IN	PREQUEST				pRequest,
					IN	PUCHAR					ResultCode);

typedef	NTSTATUS	(*ASP_SEND_ATTENTION)(
					IN	PVOID					pConnection,
					IN	USHORT					AttentionCode,
					IN	PVOID					pContext);

typedef	struct
{
	CLIENT_SESSION_NOTIFY	clt_SessionNotify;		// When a new session is established
	CLIENT_REQUEST_NOTIFY	clt_RequestNotify;		// When a new request comes in
													// Also on remote closes
	CLIENT_GET_WRITEBUFFER	clt_GetWriteBuffer;		// For ASP Write command.
	CLIENT_REPLY_COMPLETION	clt_ReplyCompletion;	// Completion routine for a reply
    CLIENT_ATTN_COMPLETION	clt_AttnCompletion;		// Completion routine for send attention
	CLIENT_CLOSE_COMPLETION	clt_CloseCompletion;	// Completion routine for a session close request
} ASP_CLIENT_ENTRIES, *PASP_CLIENT_ENTRIES;

typedef	struct
{
    ATALK_ADDRESS           asp_AtalkAddr;          // net addr of default adapter
	PVOID					asp_AspCtxt;
	ASP_SET_STATUS			asp_SetStatus;
	ASP_CLOSE_CONN			asp_CloseConn;
	ASP_FREE_CONN			asp_FreeConn;
	ASP_LISTEN_CONTROL		asp_ListenControl;
    ASP_WRITE_CONTINUE      asp_WriteContinue;
	ASP_REPLY				asp_Reply;
	ASP_SEND_ATTENTION		asp_SendAttention;
} ASP_XPORT_ENTRIES, *PASP_XPORT_ENTRIES;

//
// ASP Exchange entries
//

typedef	struct
{
	PASP_XPORT_ENTRIES		pXportEntries;
    ASP_CLIENT_ENTRIES		ClientEntries;
} ASP_BIND_PARAMS, *PASP_BIND_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	ASP_BIND_PARAMS			Params;
} ASP_BIND_ACTION, *PASP_BIND_ACTION;




//
// PAP Interface
//

//
// PAP GetStatus Using Server Address
//

typedef struct
{
	TA_APPLETALK_ADDRESS	ServerAddr;

} PAP_GETSTATUSSRV_PARAMS, *PPAP_GETSTATUSSRV_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	PAP_GETSTATUSSRV_PARAMS Params;

} PAP_GETSTATUSSRV_ACTION, *PPAP_GETSTATUSSRV_ACTION;


//
// PAP SetStatus
//

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

} PAP_SETSTATUS_ACTION, *PPAP_SETSTATUS_ACTION;

//
// PAP PrimeRead
//

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

} PAP_PRIMEREAD_ACTION, *PPAP_PRIMEREAD_ACTION;

#else
	;
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\setup\resource\sfmres.h ===
/*
**	PushButton Control IDs
*/
_dt_public
#define IDC_A        401
_dt_public
#define IDC_B        402
_dt_public
#define IDC_C        403
_dt_public
#define IDC_D        404
_dt_public
#define IDC_E        405
_dt_public
#define IDC_F        406
_dt_public
#define IDC_G        407
_dt_public
#define IDC_H        408
_dt_public
#define IDC_I        409
_dt_public
#define IDC_J        410
_dt_public
#define IDC_K        411
_dt_public
#define IDC_L        412
_dt_public
#define IDC_M        413
_dt_public
#define IDC_N        414
_dt_public
#define IDC_O        415
_dt_public
#define IDC_P        416
_dt_public
#define IDC_Q        417
_dt_public
#define IDC_R        418
_dt_public
#define IDC_S        419
_dt_public
#define IDC_T        420
_dt_public
#define IDC_U        421
_dt_public
#define IDC_V        422
_dt_public
#define IDC_W        423
_dt_public
#define IDC_X        424
_dt_public
#define IDC_Y        425
_dt_public
#define IDC_Z        426


/*
**	Text Control IDs
*/
_dt_public
#define IDC_TEXT1    431
_dt_public
#define IDC_TEXT2    432
_dt_public
#define IDC_TEXT3    433
_dt_public
#define IDC_TEXT4    434
_dt_public
#define IDC_TEXT5    435
_dt_public
#define IDC_TEXT6    436
_dt_public
#define IDC_TEXT7    437
_dt_public
#define IDC_TEXT8    438
_dt_public
#define IDC_TEXT9    439
_dt_public
#define IDC_TEXT10   440
_dt_public
#define IDC_TEXT11   441


/*
**	Radio and Checkbox Button Control IDs
*/
_dt_public
#define IDC_B0       450
_dt_public
#define IDC_B1       451
_dt_public
#define IDC_B2       452
_dt_public
#define IDC_B3       453
_dt_public
#define IDC_B4       454
_dt_public
#define IDC_B5       455
_dt_public
#define IDC_B6       456
_dt_public
#define IDC_B7       457
_dt_public
#define IDC_B8       458
_dt_public
#define IDC_B9       459
_dt_public
#define IDC_B10      460

_dt_public
#define IDC_RB0       610
_dt_public
#define IDC_RB1       611
_dt_public
#define IDC_RB2       612
_dt_public
#define IDC_RB3       613
_dt_public
#define IDC_RB4       614
_dt_public
#define IDC_RB5       615
_dt_public
#define IDC_RB6       616
_dt_public
#define IDC_RB7       617
_dt_public
#define IDC_RB8       618
_dt_public
#define IDC_RB9       619
_dt_public
#define IDC_RB10      620


/*
**	Combo box IDs
*/
_dt_public
#define IDC_COMBO0   480
_dt_public
#define IDC_COMBO1   481
_dt_public
#define IDC_COMBO2   482
_dt_public
#define IDC_COMBO3   483
_dt_public
#define IDC_COMBO4   484
_dt_public
#define IDC_COMBO5   485
_dt_public
#define IDC_COMBO6   486
_dt_public
#define IDC_COMBO7   487
_dt_public
#define IDC_COMBO8   488
_dt_public
#define IDC_COMBO9   489

/*
**	ICON IDs
*/
_dt_public
#define IDC_ICON0    500
_dt_public
#define IDC_ICON1    501
_dt_public
#define IDC_ICON2    502
_dt_public
#define IDC_ICON3    503
_dt_public
#define IDC_ICON4    504
_dt_public
#define IDC_ICON5    505
_dt_public
#define IDC_ICON6    506
_dt_public
#define IDC_ICON7    507
_dt_public
#define IDC_ICON8    508
_dt_public
#define IDC_ICON9    509

/*
** SPECIAL PUSHBUTTONS
*/

_dt_public
#define IDC_SP1    521
_dt_public
#define IDC_SP2    522
_dt_public
#define IDC_SP3    523
_dt_public
#define IDC_SP4    524
_dt_public
#define IDC_SP5    525
_dt_public
#define IDC_SP6    526
_dt_public
#define IDC_SP7    527
_dt_public
#define IDC_SP8    528
_dt_public
#define IDC_SP9    529
_dt_public
#define IDC_SP10   530

/*
** STATUS TEXT FIELDS
*/

_dt_public
#define IDC_STATUS1    541
_dt_public
#define IDC_STATUS2    542
_dt_public
#define IDC_STATUS3    543
_dt_public
#define IDC_STATUS4    544
_dt_public
#define IDC_STATUS5    545
_dt_public
#define IDC_STATUS6    546
_dt_public
#define IDC_STATUS7    547
_dt_public
#define IDC_STATUS8    548
_dt_public
#define IDC_STATUS9    549
_dt_public
#define IDC_STATUS10   550



/*
** SIZE FIELDS ASSOCIATED WITH CHECK OPTIONAL COMPONENTS
*/

_dt_public
#define IDC_SIZE1    551
_dt_public
#define IDC_SIZE2    552
_dt_public
#define IDC_SIZE3    553
_dt_public
#define IDC_SIZE4    554
_dt_public
#define IDC_SIZE5    555
_dt_public
#define IDC_SIZE6    556
_dt_public
#define IDC_SIZE7    557
_dt_public
#define IDC_SIZE8    558
_dt_public
#define IDC_SIZE9    559
_dt_public
#define IDC_SIZE10   560



/*
** TOTALS OF SIZES
*/

_dt_public
#define IDC_TOTAL1    561
_dt_public
#define IDC_TOTAL2    562
_dt_public
#define IDC_TOTAL3    563
_dt_public
#define IDC_TOTAL4    564
_dt_public
#define IDC_TOTAL5    565
_dt_public
#define IDC_TOTAL6    566
_dt_public
#define IDC_TOTAL7    567
_dt_public
#define IDC_TOTAL8    568
_dt_public
#define IDC_TOTAL9    569
_dt_public
#define IDC_TOTAL10   570

/*
** MAXIMUM SIZES
*/

_dt_public
#define IDC_MAX1    571
_dt_public
#define IDC_MAX2    572
_dt_public
#define IDC_MAX3    573
_dt_public
#define IDC_MAX4    574
_dt_public
#define IDC_MAX5    575
_dt_public
#define IDC_MAX6    576
_dt_public
#define IDC_MAX7    577
_dt_public
#define IDC_MAX8    578
_dt_public
#define IDC_MAX9    579
_dt_public
#define IDC_MAX10   580

/*
**	Edit Control IDs
*/

#define IDC_EDIT1   581
#define IDC_EDIT2   582
#define IDC_EDIT3   583
#define IDC_EDIT4   584
#define IDC_EDIT5   585
#define IDC_EDIT6   586
#define IDC_EDIT7   587
#define IDC_EDIT8   588
#define IDC_EDIT9   589
#define IDC_EDIT10  590

/*
**	ListBox Control IDs
*/

#define IDC_LIST1   591
#define IDC_LIST2   592
#define IDC_LIST3   593
#define IDC_LIST4   594
#define IDC_LIST5   595
#define IDC_LIST6   596
#define IDC_LIST7   597
#define IDC_LIST8   598
#define IDC_LIST9   599
#define IDC_LIST10  600


/*
** MENU IDS
*/

#define ID_MAINTAIN  651
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\setup\util\access.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <windows.h>
#include <winspool.h>
#include <stdlib.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include "sfmutil.h"

extern TCHAR ReturnTextBuffer[512];


#define	AFP_MIN_ACCESS		(FILE_READ_ATTRIBUTES | \
							 READ_CONTROL)

#define	AFP_READ_ACCESS		(READ_CONTROL		 |	\
							FILE_READ_ATTRIBUTES |	\
							FILE_TRAVERSE		 |	\
							FILE_LIST_DIRECTORY	 |	\
							FILE_READ_EA)

#define	AFP_WRITE_ACCESS	(FILE_ADD_FILE		 |	\
							FILE_ADD_SUBDIRECTORY|	\
							FILE_WRITE_ATTRIBUTES|	\
							FILE_WRITE_EA		 |	\
							DELETE)

#define	AFP_OWNER_ACCESS	(WRITE_DAC			  | \
							 WRITE_OWNER)



SID	AfpSidWorld	= { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
SID	AfpSidNull	= { 1, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };
SID	AfpSidSystem = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
SID	AfpSidCrtrOwner = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_OWNER_RID };
SID	AfpSidCrtrGroup = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_GROUP_RID };

/***	afpAddAceToAcl
 *
 *	Build an Ace corres. to the Sid(s) and mask and add these to the Acl. It is
 *	assumed that the Acl has space for the Aces. If the Mask is 0 (i.e. no access)
 *	the Ace added is a DENY Ace, else a ALLOWED ACE is added.
 */
PACCESS_ALLOWED_ACE
afpAddAceToAcl(
	IN  PACL				pAcl,
	IN  PACCESS_ALLOWED_ACE	pAce,
	IN  ACCESS_MASK			Mask,
	IN  PSID				pSid,
	IN  PSID				pSidInherit OPTIONAL
)
{
	// Add a vanilla ace
	pAcl->AceCount ++;
	pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
	pAce->Header.AceFlags = 0;
	pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
	pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
							RtlLengthSid(pSid));
	RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);

	// Now add an inherit ace
	if (1)
	{
		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
		pAcl->AceCount ++;
		pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
								OBJECT_INHERIT_ACE |
								INHERIT_ONLY_ACE;
		pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
		pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
								RtlLengthSid(pSid));
		RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);
	
		// Now add an inherit ace for the CreatorOwner/CreatorGroup
		if (ARGUMENT_PRESENT(pSidInherit))
		{
			pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
			pAcl->AceCount ++;
			pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
			pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
									OBJECT_INHERIT_ACE |
									INHERIT_ONLY_ACE;
			pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
			pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
									RtlLengthSid(pSidInherit));
			RtlCopySid(RtlLengthSid(pSidInherit), (PSID)(&pAce->SidStart), pSidInherit);
		}
	}

	return ((PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize));
}

/***	afpMoveAces
 *
 *	Move a bunch of aces from the old security descriptor to the new security
 *	descriptor.
 */
PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL				pOldDacl,
	IN	PACCESS_ALLOWED_ACE	pAceStart,
	IN	PSID				pSidOldOwner,
	IN	PSID				pSidNewOwner,
	IN	PSID				pSidOldGroup,
	IN	PSID				pSidNewGroup,
	IN	BOOLEAN				DenyAces,
	IN	OUT PACL			pNewDacl
)
{
	USHORT				i;
	PACCESS_ALLOWED_ACE	pAceOld;
	PSID				pSidAce;

	for (i = 0, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pOldDacl + sizeof(ACL));
		 i < pOldDacl->AceCount;
		 i++, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pAceOld + pAceOld->Header.AceSize))
	{
		// Note: All deny aces are ahead of the grant aces.
		if (DenyAces && (pAceOld->Header.AceType != ACCESS_DENIED_ACE_TYPE))
			break;

		if (!DenyAces && (pAceOld->Header.AceType == ACCESS_DENIED_ACE_TYPE))
			continue;

		pSidAce = (PSID)(&pAceOld->SidStart);
		if (!(RtlEqualSid(pSidAce, &AfpSidWorld)		||
			  RtlEqualSid(pSidAce, pSidOldOwner)		||
			  RtlEqualSid(pSidAce, pSidNewOwner)		||
			  RtlEqualSid(pSidAce, &AfpSidCrtrOwner)	||
			  RtlEqualSid(pSidAce, pSidOldGroup)		||
			  RtlEqualSid(pSidAce, pSidNewGroup)		||
			  RtlEqualSid(pSidAce, &AfpSidCrtrGroup)))
		{
			RtlCopyMemory(pAceStart, pAceOld, pAceOld->Header.AceSize);
			pAceStart = (PACCESS_ALLOWED_ACE)((PBYTE)pAceStart +
													pAceStart->Header.AceSize);
			pNewDacl->AceCount ++;
		}
	}
	return (pAceStart);
}


/***	AfpSetAfpPermissions
 *
 *	Set the permissions on this directory. Also optionally set the owner and
 *	group ids. For setting the owner and group ids verify if the user has the
 *	needed access. This access is however not good enough. We check for this
 *	access but do the actual setting of the permissions in the special server
 *	context (RESTORE privilege is needed).
 */
BOOL
SfmSetUamSecurity(
	 DWORD cArgs,
	 LPTSTR Args[],
	 LPTSTR *TextOut
	 )

{
	NTSTATUS				Status;
	DWORD					SizeNeeded;
	PBYTE					pBuffer = NULL;
	PISECURITY_DESCRIPTOR	pSecDesc;
	SECURITY_INFORMATION	SecInfo = DACL_SECURITY_INFORMATION;
	PACL					pDaclNew = NULL;
	PACCESS_ALLOWED_ACE		pAce;
	LONG					SizeNewDacl;
	HANDLE					DirHandle;
	LPWSTR					lpwsDirPath = NULL;
	LPTSTR					pDirPath = NULL;
	UNICODE_STRING			DirectoryName;
	IO_STATUS_BLOCK			IoStatusBlock;
	DWORD					cbDirPath;
	OBJECT_ATTRIBUTES		ObjectAttributes;
	UINT					Size;


	//
	// Convert the DIR Path to UNICODE
	//

	*TextOut = ReturnTextBuffer;

    lstrcpy(ReturnTextBuffer, TEXT("FAILED"));

	if(cArgs != 1) {

	  return FALSE;

	}
	cbDirPath = (strlen((LPSTR)Args[0]) + 1) * sizeof(WCHAR);

	if((lpwsDirPath  = (LPWSTR)LocalAlloc(LPTR,cbDirPath)) == NULL)
	  return(FALSE);
	
    if(!MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            (LPSTR)Args[0],
                            -1,
                             lpwsDirPath,
                             cbDirPath
                            ))
   {

	  LocalFree(lpwsDirPath);
	  return(FALSE);

   }
#ifdef DEBUG
   DbgPrint("UAM: Directory = %ws\n",lpwsDirPath);
#endif

   pDirPath =  (LPTSTR)LocalAlloc(LPTR,
	           (wcslen(lpwsDirPath) + wcslen(TEXT("\\DOSDEVICES\\"))+1)
			   * sizeof(WCHAR));				

   if(pDirPath == NULL) {
#ifdef DEBUG
	  DbgPrint("UAMSETSECURITY: malloc for dir path failed\n");
#endif
	  LocalFree(lpwsDirPath);
	  return(FALSE);
   }

   wcscpy(pDirPath, TEXT("\\DOSDEVICES\\"));
   wcscat(pDirPath, lpwsDirPath);

   LocalFree(lpwsDirPath);

	
   RtlInitUnicodeString(&DirectoryName, pDirPath);


   InitializeObjectAttributes(&ObjectAttributes,
				 	 &DirectoryName,
					 OBJ_CASE_INSENSITIVE,
					 NULL,
					 NULL);

   Status = NtOpenFile(&DirHandle,
			   WRITE_DAC | READ_CONTROL | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,
			   FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);


   LocalFree(pDirPath);

   if(!NT_SUCCESS(Status)) {

#ifdef DEBUG

	  DbgPrint("UAMSETSECURITY: NtOpen File Failed\n");
#endif
	  return(FALSE);
   }


   do
   {
	  //
	  // Read the security descriptor for this directory
	  //

	  SizeNeeded = 256;
	
	  do
	  {
	      if (pBuffer != NULL)
				LocalFree(pBuffer);
	
			if ((pBuffer = (PBYTE)LocalAlloc(LPTR,SizeNewDacl = SizeNeeded)) == NULL)
			{

				Status = STATUS_NO_MEMORY;
				break;
			}
	
			Status = NtQuerySecurityObject(DirHandle,
										OWNER_SECURITY_INFORMATION |
										GROUP_SECURITY_INFORMATION |
										DACL_SECURITY_INFORMATION,
										(PSECURITY_DESCRIPTOR)pBuffer,
										SizeNeeded, &SizeNeeded);
	
	  } while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));
	
		if (!NT_SUCCESS(Status)) {

			break;
		}
	
		pSecDesc = (PSECURITY_DESCRIPTOR)pBuffer;
	
		// If the security descriptor is in self-relative form, convert to absolute
		if (pSecDesc->Control & SE_SELF_RELATIVE)
		{
			pSecDesc->Control &= ~SE_SELF_RELATIVE;
	
			if (pSecDesc->Owner != NULL)
				pSecDesc->Owner = (PSID)RtlOffsetToPointer(pSecDesc, pSecDesc->Owner);
			if (pSecDesc->Group != NULL)
				pSecDesc->Group = (PSID)RtlOffsetToPointer(pSecDesc, pSecDesc->Group);
			if (pSecDesc->Dacl  != NULL)
				pSecDesc->Dacl  = (PACL)RtlOffsetToPointer(pSecDesc, pSecDesc->Dacl);
		}
	
		// Construct the new Dacl. This consists of Aces for World, Owner and Group
		// followed by Old Aces for everybody else, but with Aces for World, OldOwner
		// and OldGroup stripped out. First determine space for the new Dacl and
		// allocated space for the new Dacl. Lets be exteremely conservative. We
		// have two aces each for owner/group/world.
	
		SizeNewDacl +=
				(RtlLengthSid(pSecDesc->Owner) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(pSecDesc->Group) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(&AfpSidSystem) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(&AfpSidWorld) + sizeof(ACCESS_ALLOWED_ACE)) * 3;
	
		if ((pDaclNew = (PACL)LocalAlloc(LPTR,SizeNewDacl)) == NULL)
		{

			Status = STATUS_NO_MEMORY;
			break;
		}
	
		RtlCreateAcl(pDaclNew, SizeNewDacl, ACL_REVISION);
		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pDaclNew + sizeof(ACL));
	
		// At this time the Acl list is empty, i.e. no access for anybody
		// Start off by copying the Deny Aces from the original Dacl list
		// weeding out the Aces for World, old and new owner, new and old
		// group, creator owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
							pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
							TRUE, pDaclNew);

		}

		// Now add Aces for System, World, Group & Owner - in that order
		pAce = afpAddAceToAcl(pDaclNew,
					   pAce,
					   AFP_READ_ACCESS,
					   &AfpSidSystem,
					   &AfpSidSystem);
	
		pAce = afpAddAceToAcl(pDaclNew,
					   pAce,
					   AFP_READ_ACCESS,
					   &AfpSidWorld,
					   NULL);
	
		pAce = afpAddAceToAcl(pDaclNew,
					 pAce,
					 AFP_READ_ACCESS ,
					 pSecDesc->Group,
					 &AfpSidCrtrGroup);

		pAce = afpAddAceToAcl(pDaclNew,
						pAce,
						AFP_READ_ACCESS |  AFP_WRITE_ACCESS,
						pSecDesc->Owner,
						&AfpSidCrtrOwner);


		// Now add in the Grant Aces from the original Dacl list weeding out
		// the Aces for World, old and new owner, new and old group, creator
		// owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
							pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
							FALSE, pDaclNew);

		}

		// Now set the new security descriptor
		pSecDesc->Dacl = pDaclNew;
	
		Status = NtSetSecurityObject(DirHandle, SecInfo, pSecDesc);


	} while (FALSE);

	// Free the allocated buffers before we return
	if (pBuffer != NULL)
		LocalFree(pBuffer);
	if (pDaclNew != NULL)
		LocalFree(pDaclNew);

   if(NT_SUCCESS(Status)) {

	  lstrcpy(ReturnTextBuffer, TEXT("SUCCESS"));

	  return(TRUE);
   }

   return FALSE;
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\setup\util\sfmutil.h ===
#define UAMRESOURCEFILE  uamres
#define UAMINFOFILE 	 uaminf
#define UAMDESTRESFILE	 "UAM:Afp_Resource"
#define UAMDESTINFOFILE  "UAM:Afp_AfpInfo"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\setup\resource\sfmres.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    atresdll.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    the AppleTalk Setup resource DLL.

Author:

    Ted Miller (tedm) July-1990

Revision History:

--*/
/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
*/
#include <windows.h>

HANDLE ThisDLLHandle;

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\setup\sfmreg\sfmreg.c ===
/*
 * This util is used by the batch file that a user uses to copy
 * admin tools from the NT Server CD to a NT Workstation.
 * This tool is used to add the File Manager and Server Manager
 * extensions for MacFile.
 *
 * Usage: sfmreg.reg SMAddons sfmmgr.dll ntnet.ini
 *        sfmreg.reg Addons   sfmmgr.dll winfile.ini
 *
 * Author: Ram Cherala Feb 24th 95  Copied from test\util\afpini
 *
 */

#define DOSWIN32

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmerr.h>

extern BOOL FAR PASCAL WriteAfpMgrIniStrings (
	DWORD	nArgs,
	LPSTR	apszArgs[],
	LPSTR   *ppszResult
);

extern int CDECL main(int argc, char *argv[]);

int CDECL
main (int argc, char *argv[])
{
    TCHAR   ResultBuffer[1024];

    // go past the file name argument

	 argc--;
	 ++argv;


	if(WriteAfpMgrIniStrings(argc, argv , (LPSTR*) &ResultBuffer))
   {
      return(0);
   }
   else
   {
      return(1);
   }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\dummy.c ===
/* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\setup\util\sfmutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	sfmutil.c

Author:

	Krishg

Revision History:

--*/

#if DBG==1 && DEVL==1
#define DEBUG
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <stdlib.h>
#include "sfmutil.h"

#ifdef DBCS
#include "locale.h"
#endif // DBCS
HANDLE ThisDLLHandle;

CHAR ReturnTextBuffer[512];


BOOL
UtilDLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
#ifdef DBCS // UtilDLLInit()
    // we want to have the Unicode <-> Ansi conversion based on System locale.
        setlocale(LC_ALL,"");
#endif // DBCS
        break;

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}

/* Delete the file. If Unable to delete the file return failed */

BOOL
DelFile (
	 DWORD cArgs,
	 LPTSTR Args[],
	 LPTSTR *TextOut
	 )
{
   BOOL  	Status = FALSE;
   LPTSTR 	pSrcFile = NULL;
   INT 		cbAscii;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs!=1)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pSrcFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pSrcFile == NULL)
		 break;

	  if(mbstowcs(pSrcFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;

      Status = DeleteFile(pSrcFile);

    } while (FALSE);

	if(pSrcFile != NULL)
	   LocalFree(pSrcFile);

    strcpy(ReturnTextBuffer, Status ? (LPSTR)"SUCCESS" : (LPSTR)"FAILED");
    return Status;
}

/*
 * Copy Uam Files :
 * Copies the UAM Files to the NTFS Volume
*/

BOOL
CopyUamFiles (
	 DWORD cArgs,
	 LPTSTR Args[],
	 LPTSTR *TextOut
	 )
{
   BOOL Status = FALSE;
   INT cbAscii;

   LPTSTR pSrcFile = NULL;
   LPTSTR  pDestFile = NULL;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs!=2)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pSrcFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pSrcFile == NULL)
		 break;

	  if(mbstowcs(pSrcFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;

	  cbAscii = strlen((LPSTR)Args[1]) +1;

	  pDestFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pDestFile == NULL)
		 break;

	  if(mbstowcs(pDestFile, (LPSTR)Args[1],cbAscii) == -1)
		 break;

#ifdef DEBUG
	DbgPrint("Source File  %ws\n",pSrcFile);
	DbgPrint("Destination File %ws\n",pDestFile);
#endif

	  Status = CopyFile(pSrcFile,pDestFile,FALSE);

    } while (FALSE);

	if(pSrcFile != NULL)
	   LocalFree(pSrcFile);

	if(pDestFile != NULL)
	   LocalFree(pDestFile);

	strcpy(ReturnTextBuffer, Status ? (LPSTR)"SUCCESS" : (LPSTR)"FAILED");

    return Status;

}

#define AFPMGRKEY		TEXT("Afp Manager")

BOOL
WriteAfpMgrIniStrings (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL 	Status = FALSE;
   BOOL    	KeyDelete = FALSE;
   INT 		cbAscii;
   LPTSTR  	pSectionName = NULL;
   LPTSTR 	pString = NULL;
   LPTSTR	pIniFile = NULL;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs != 3)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pSectionName = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pSectionName == NULL)
		 break;

	  if(mbstowcs(pSectionName, (LPSTR)Args[0],cbAscii) == -1)
		 break;
	  //
	  // If the String is NULL, set String to NULL, otherwise
	  // convert the string to unicode
	  //

	  if(!strcmp((LPSTR)Args[1],(LPSTR)"NULL")) {
		 KeyDelete = TRUE;
	  }
      else
	  {
		 cbAscii = strlen((LPSTR)Args[1]) +1;
		 pString = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);
		 if(pString == NULL)
			break;
		 if(mbstowcs(pString, (LPSTR)Args[1],cbAscii) == -1)
			break;
      }

	  cbAscii = strlen((LPSTR)Args[2]) +1;
	  pIniFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);
	  if(pIniFile == NULL)
		 break;
	  if(mbstowcs(pIniFile, (LPSTR)Args[2],cbAscii) == -1)
		 break;

#ifdef DEBUG
	DbgPrint("File:%ws\n",pIniFile);
	DbgPrint("String: 	%ws\n",pString);
	DbgPrint("Section: 	%ws\n",pSectionName);
#endif

	  Status = WritePrivateProfileString (pSectionName,
						AFPMGRKEY,
                        (KeyDelete == TRUE) ?  (LPCTSTR)NULL : pString,
						pIniFile);

   } while (FALSE);

   if(pIniFile != NULL)
	  LocalFree(pIniFile);

   if(pSectionName != NULL)
	  LocalFree(pSectionName);

   if(pString != NULL)
	  LocalFree(pString);

   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");

   return Status;

}
BOOL
GetPrintProcDir (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL		Status = FALSE;
   DWORD  	BytesCopied;
   LPTSTR  	wpProcFile = NULL;
   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  wpProcFile = (LPTSTR)LocalAlloc(LPTR, 512);

	  if(wpProcFile == NULL)
		 break;

	  Status = GetPrintProcessorDirectory(NULL,
						   NULL,
                           1,
						   (LPBYTE)wpProcFile,
                           512,
                           &BytesCopied
                           );

	  if(Status) {

		 if(wcstombs(ReturnTextBuffer,wpProcFile,512) ==-1) {
			Status = FALSE;
			break;
		 }

	  }

    } while (FALSE);

	if(wpProcFile != NULL)
	   LocalFree(wpProcFile);

    if(!Status)
      strcpy(ReturnTextBuffer ,(LPSTR)"FAILED");

    return Status;
}


BOOL
AddPrintProc (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL		Status = FALSE;
   LPTSTR  	pPrintProcessorFile = NULL;
   LPTSTR   	pPrintProcessor  = NULL;
   INT     	cbAscii;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs != 2)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pPrintProcessorFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessorFile == NULL)
		 break;

	  if(mbstowcs(pPrintProcessorFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;
	

	  cbAscii = strlen((LPSTR)Args[1]) +1;

	  pPrintProcessor = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessor == NULL)
		 break;

	  if(mbstowcs(pPrintProcessor, (LPSTR)Args[1],cbAscii) == -1)
		 break;

	  Status =  AddPrintProcessor(NULL,	  // Do local stuff only
	                              NULL,     // Use Current Environment
	                              pPrintProcessorFile, // PSPRINT.DLL
	                              pPrintProcessor
								 );

   } while (FALSE);

   if(pPrintProcessorFile != NULL)
	  LocalFree(pPrintProcessorFile);

   if(pPrintProcessor != NULL)
	  LocalFree(pPrintProcessor);

   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");
   return Status;

}

/* Delete  the PSTODIB PSPRINT PrintProcessor
 *
 *
 */

BOOL
DeletePrintProc (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL		Status = FALSE;
   LPTSTR  	pPrintProcessorFile = NULL;
   LPTSTR   	pPrintProcessor  = NULL;
   INT     	cbAscii;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs != 2)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pPrintProcessorFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessorFile == NULL)
		 break;

	  if(mbstowcs(pPrintProcessorFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;
	

	  cbAscii = strlen((LPSTR)Args[1]) +1;

	  pPrintProcessor = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessor == NULL)
		 break;

	  if(mbstowcs(pPrintProcessor, (LPSTR)Args[1],cbAscii) == -1)
		 break;

	  Status =  DeletePrintProcessor(	pPrintProcessorFile,
								   		NULL,		// Use Current Environment
								   		pPrintProcessor
							   		  );

   } while (FALSE);

   if(pPrintProcessorFile != NULL)
	  LocalFree(pPrintProcessorFile);

   if(pPrintProcessor != NULL)
	  LocalFree(pPrintProcessor);


   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");
   return Status;

}

BOOL
SfmAddPrintMonitor (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL 	Status = FALSE;
   LPTSTR 	wpMonName = NULL;
   INT		cbAscii = 0;
   LPSTR 	pMonInfoBuffer = NULL;
   TCHAR 	MonDllName[] = L"sfmmon.dll";
   PMONITOR_INFO_2 pmoninfo;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do {

	  if(cArgs != 1)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) + 1;

	  wpMonName = (LPTSTR)LocalAlloc(LPTR,sizeof(WCHAR) * cbAscii);

	  if(wpMonName == NULL)
		 break;

	  if(mbstowcs(wpMonName, (LPSTR)Args[0], cbAscii) == -1)
		 break;

	  pMonInfoBuffer = (LPSTR) LocalAlloc(LPTR, 512);

	  if(pMonInfoBuffer == NULL)
		 break;

	  pmoninfo = (PMONITOR_INFO_2)pMonInfoBuffer;
	  pmoninfo->pName = wpMonName;
	  pmoninfo->pEnvironment = NULL;
	  pmoninfo->pDLLName = MonDllName;

#ifdef DEBUG
	DbgPrint("ADDPRINTMONITOR Name : %ws\n", pmoninfo->pName);
    DbgPrint("ADDPRINTMONITOR Dll Name : %ws\n", pmoninfo->pDLLName);
#endif

	  Status = AddMonitor( NULL,
						   2,
						   (LPSTR)pMonInfoBuffer
						   );

	}while(FALSE);

	if(wpMonName != NULL)
	   LocalFree(wpMonName);

	if(pMonInfoBuffer != NULL)
	   LocalFree(pMonInfoBuffer);

	strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");

	return Status;

}

BOOL
SfmDeletePrintMonitor (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

    BOOL Status = FALSE;
    LPTSTR wpMonName = NULL;
	INT cbAscii;
    *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {

	  if(cArgs !=1)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) + 1;

	  wpMonName = (LPTSTR)LocalAlloc(LPTR,sizeof(WCHAR) * cbAscii);

	  if(wpMonName == NULL)
		 break;

	  if(mbstowcs(wpMonName, (LPSTR)Args[0], cbAscii) == -1)
		 break;

	  Status = DeleteMonitor( NULL,
							  NULL,
							  wpMonName
                           	);
   }while(FALSE);

   if(wpMonName != NULL)
	  LocalFree(wpMonName);

   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");

   return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\makefile.inc ===
make_uam:
    binplace uaminst.ifo
    binplace uaminst.rsc
    binplace sfmuam5.ifo
    binplace sfmuam5.rsc
    binplace sfmuam.ifo
    binplace sfmuam.rsc
    binplace sfmuam.txt
    binplace sfmicon.vol

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\winsock\wshdata.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	wshdata.h

Abstract:


Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	10 Jul 1992	Initial Version

--*/




MAPPING_TRIPLE AdspStreamMappingTriples[] =
		{
			AF_APPLETALK,	SOCK_STREAM,	ATPROTO_ADSP
		};

MAPPING_TRIPLE AdspMsgMappingTriples[] =
		{
			AF_APPLETALK,	SOCK_RDM,		ATPROTO_ADSP
		};

MAPPING_TRIPLE PapMsgMappingTriples[] =
		{
			AF_APPLETALK,	SOCK_RDM,		ATPROTO_PAP
		};

//	This will handle protocol types from 1 to 255. Note the actual numberical
//	values are (ATPROTO_BASE + desired protocol number).
//	NOTE: Protocol 0 is not valid.

MAPPING_TRIPLE	DdpMappingTriples[] =
	{
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_RTMP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_NBP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_ATP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_AEP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_RTMPRQ),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_ZIP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_ADSP),

		//
		//	Now the other protocol types that are not
		//	defined yet - what about aurp? It runs on
		//	top of ddp and is the appletalk update
		//	based routing protocol
		//

		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 8),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 9),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 10),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 11),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 12),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 13),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 14),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 15),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 16),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 17),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 18),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 19),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 20),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 21),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 22),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 23),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 24),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 25),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 26),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 27),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 28),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 29),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 30),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 31),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 32),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 33),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 34),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 35),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 36),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 37),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 38),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 39),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 40),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 41),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 42),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 43),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 44),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 45),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 46),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 47),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 48),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 49),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 50),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 51),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 52),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 53),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 54),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 55),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 56),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 57),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 58),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 59),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 60),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 61),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 62),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 63),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 64),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 65),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 66),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 67),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 68),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 69),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 70),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 71),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 72),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 73),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 74),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 75),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 76),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 77),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 78),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 79),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 80),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 81),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 82),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 83),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 84),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 85),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 86),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 87),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 88),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 89),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 90),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 91),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 92),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 93),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 94),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 95),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 96),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 97),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 98),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 99),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 100),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 101),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 102),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 103),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 104),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 105),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 106),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 107),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 108),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 109),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 110),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 111),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 112),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 113),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 114),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 115),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 116),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 117),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 118),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 119),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 120),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 121),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 122),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 123),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 124),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 125),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 126),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 127),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 128),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 129),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 130),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 131),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 132),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 133),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 134),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 135),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 136),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 137),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 138),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 139),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 140),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 141),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 142),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 143),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 144),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 145),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 146),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 147),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 148),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 149),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 150),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 151),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 152),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 153),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 154),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 155),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 156),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 157),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 158),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 159),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 160),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 161),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 162),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 163),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 164),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 165),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 166),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 167),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 168),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 169),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 170),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 171),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 172),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 173),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 174),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 175),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 176),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 177),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 178),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 179),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 180),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 181),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 182),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 183),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 184),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 185),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 186),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 187),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 188),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 189),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 190),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 191),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 192),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 193),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 194),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 195),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 196),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 197),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 198),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 199),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 200),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 201),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 202),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 203),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 204),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 205),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 206),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 207),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 208),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 209),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 210),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 211),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 212),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 213),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 214),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 215),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 216),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 217),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 218),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 219),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 220),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 221),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 222),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 223),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 224),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 225),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 226),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 227),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 228),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 229),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 230),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 231),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 232),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 233),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 234),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 235),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 236),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 237),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 238),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 239),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 240),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 241),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 242),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 243),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 244),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 245),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 246),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 247),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 248),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 249),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 250),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 251),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 252),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 253),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 254),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 255),
};


// Protocol type should be at the end - we cannot dynamically do this,	due to the
// assumption that this memory will never need to be freed by the Winsock dll.
//
// Protocol type 0 is not valid.

PWCHAR		WSH_ATALK_DGRAMDDP[DDPPROTO_MAX] =
	{
		L"\\Device\\AtalkDdp\\1",
		L"\\Device\\AtalkDdp\\2",
		L"\\Device\\AtalkDdp\\3",
		L"\\Device\\AtalkDdp\\4",
		L"\\Device\\AtalkDdp\\5",
		L"\\Device\\AtalkDdp\\6",
		L"\\Device\\AtalkDdp\\7",
		L"\\Device\\AtalkDdp\\8",
		L"\\Device\\AtalkDdp\\9",
		L"\\Device\\AtalkDdp\\10",
		L"\\Device\\AtalkDdp\\11",
		L"\\Device\\AtalkDdp\\12",
		L"\\Device\\AtalkDdp\\13",
		L"\\Device\\AtalkDdp\\14",
		L"\\Device\\AtalkDdp\\15",
		L"\\Device\\AtalkDdp\\16",
		L"\\Device\\AtalkDdp\\17",
		L"\\Device\\AtalkDdp\\18",
		L"\\Device\\AtalkDdp\\19",
		L"\\Device\\AtalkDdp\\20",
		L"\\Device\\AtalkDdp\\21",
		L"\\Device\\AtalkDdp\\22",
		L"\\Device\\AtalkDdp\\23",
		L"\\Device\\AtalkDdp\\24",
		L"\\Device\\AtalkDdp\\25",
		L"\\Device\\AtalkDdp\\26",
		L"\\Device\\AtalkDdp\\27",
		L"\\Device\\AtalkDdp\\28",
		L"\\Device\\AtalkDdp\\29",
		L"\\Device\\AtalkDdp\\30",
		L"\\Device\\AtalkDdp\\31",
		L"\\Device\\AtalkDdp\\32",
		L"\\Device\\AtalkDdp\\33",
		L"\\Device\\AtalkDdp\\34",
		L"\\Device\\AtalkDdp\\35",
		L"\\Device\\AtalkDdp\\36",
		L"\\Device\\AtalkDdp\\37",
		L"\\Device\\AtalkDdp\\38",
		L"\\Device\\AtalkDdp\\39",
		L"\\Device\\AtalkDdp\\40",
		L"\\Device\\AtalkDdp\\41",
		L"\\Device\\AtalkDdp\\42",
		L"\\Device\\AtalkDdp\\43",
		L"\\Device\\AtalkDdp\\44",
		L"\\Device\\AtalkDdp\\45",
		L"\\Device\\AtalkDdp\\46",
		L"\\Device\\AtalkDdp\\47",
		L"\\Device\\AtalkDdp\\48",
		L"\\Device\\AtalkDdp\\49",
		L"\\Device\\AtalkDdp\\50",
		L"\\Device\\AtalkDdp\\51",
		L"\\Device\\AtalkDdp\\52",
		L"\\Device\\AtalkDdp\\53",
		L"\\Device\\AtalkDdp\\54",
		L"\\Device\\AtalkDdp\\55",
		L"\\Device\\AtalkDdp\\56",
		L"\\Device\\AtalkDdp\\57",
		L"\\Device\\AtalkDdp\\58",
		L"\\Device\\AtalkDdp\\59",
		L"\\Device\\AtalkDdp\\60",
		L"\\Device\\AtalkDdp\\61",
		L"\\Device\\AtalkDdp\\62",
		L"\\Device\\AtalkDdp\\63",
		L"\\Device\\AtalkDdp\\64",
		L"\\Device\\AtalkDdp\\65",
		L"\\Device\\AtalkDdp\\66",
		L"\\Device\\AtalkDdp\\67",
		L"\\Device\\AtalkDdp\\68",
		L"\\Device\\AtalkDdp\\69",
		L"\\Device\\AtalkDdp\\70",
		L"\\Device\\AtalkDdp\\71",
		L"\\Device\\AtalkDdp\\72",
		L"\\Device\\AtalkDdp\\73",
		L"\\Device\\AtalkDdp\\74",
		L"\\Device\\AtalkDdp\\75",
		L"\\Device\\AtalkDdp\\76",
		L"\\Device\\AtalkDdp\\77",
		L"\\Device\\AtalkDdp\\78",
		L"\\Device\\AtalkDdp\\79",
		L"\\Device\\AtalkDdp\\80",
		L"\\Device\\AtalkDdp\\81",
		L"\\Device\\AtalkDdp\\82",
		L"\\Device\\AtalkDdp\\83",
		L"\\Device\\AtalkDdp\\84",
		L"\\Device\\AtalkDdp\\85",
		L"\\Device\\AtalkDdp\\86",
		L"\\Device\\AtalkDdp\\87",
		L"\\Device\\AtalkDdp\\88",
		L"\\Device\\AtalkDdp\\89",
		L"\\Device\\AtalkDdp\\90",
		L"\\Device\\AtalkDdp\\91",
		L"\\Device\\AtalkDdp\\92",
		L"\\Device\\AtalkDdp\\93",
		L"\\Device\\AtalkDdp\\94",
		L"\\Device\\AtalkDdp\\95",
		L"\\Device\\AtalkDdp\\96",
		L"\\Device\\AtalkDdp\\97",
		L"\\Device\\AtalkDdp\\98",
		L"\\Device\\AtalkDdp\\99",
		L"\\Device\\AtalkDdp\\100",
		L"\\Device\\AtalkDdp\\101",
		L"\\Device\\AtalkDdp\\102",
		L"\\Device\\AtalkDdp\\103",
		L"\\Device\\AtalkDdp\\104",
		L"\\Device\\AtalkDdp\\105",
		L"\\Device\\AtalkDdp\\106",
		L"\\Device\\AtalkDdp\\107",
		L"\\Device\\AtalkDdp\\108",
		L"\\Device\\AtalkDdp\\109",
		L"\\Device\\AtalkDdp\\110",
		L"\\Device\\AtalkDdp\\111",
		L"\\Device\\AtalkDdp\\112",
		L"\\Device\\AtalkDdp\\113",
		L"\\Device\\AtalkDdp\\114",
		L"\\Device\\AtalkDdp\\115",
		L"\\Device\\AtalkDdp\\116",
		L"\\Device\\AtalkDdp\\117",
		L"\\Device\\AtalkDdp\\118",
		L"\\Device\\AtalkDdp\\119",
		L"\\Device\\AtalkDdp\\120",
		L"\\Device\\AtalkDdp\\121",
		L"\\Device\\AtalkDdp\\122",
		L"\\Device\\AtalkDdp\\123",
		L"\\Device\\AtalkDdp\\124",
		L"\\Device\\AtalkDdp\\125",
		L"\\Device\\AtalkDdp\\126",
		L"\\Device\\AtalkDdp\\127",
		L"\\Device\\AtalkDdp\\128",
		L"\\Device\\AtalkDdp\\129",
		L"\\Device\\AtalkDdp\\130",
		L"\\Device\\AtalkDdp\\131",
		L"\\Device\\AtalkDdp\\132",
		L"\\Device\\AtalkDdp\\133",
		L"\\Device\\AtalkDdp\\134",
		L"\\Device\\AtalkDdp\\135",
		L"\\Device\\AtalkDdp\\136",
		L"\\Device\\AtalkDdp\\137",
		L"\\Device\\AtalkDdp\\138",
		L"\\Device\\AtalkDdp\\139",
		L"\\Device\\AtalkDdp\\140",
		L"\\Device\\AtalkDdp\\141",
		L"\\Device\\AtalkDdp\\142",
		L"\\Device\\AtalkDdp\\143",
		L"\\Device\\AtalkDdp\\144",
		L"\\Device\\AtalkDdp\\145",
		L"\\Device\\AtalkDdp\\146",
		L"\\Device\\AtalkDdp\\147",
		L"\\Device\\AtalkDdp\\148",
		L"\\Device\\AtalkDdp\\149",
		L"\\Device\\AtalkDdp\\150",
		L"\\Device\\AtalkDdp\\151",
		L"\\Device\\AtalkDdp\\152",
		L"\\Device\\AtalkDdp\\153",
		L"\\Device\\AtalkDdp\\154",
		L"\\Device\\AtalkDdp\\155",
		L"\\Device\\AtalkDdp\\156",
		L"\\Device\\AtalkDdp\\157",
		L"\\Device\\AtalkDdp\\158",
		L"\\Device\\AtalkDdp\\159",
		L"\\Device\\AtalkDdp\\160",
		L"\\Device\\AtalkDdp\\161",
		L"\\Device\\AtalkDdp\\162",
		L"\\Device\\AtalkDdp\\163",
		L"\\Device\\AtalkDdp\\164",
		L"\\Device\\AtalkDdp\\165",
		L"\\Device\\AtalkDdp\\166",
		L"\\Device\\AtalkDdp\\167",
		L"\\Device\\AtalkDdp\\168",
		L"\\Device\\AtalkDdp\\169",
		L"\\Device\\AtalkDdp\\170",
		L"\\Device\\AtalkDdp\\171",
		L"\\Device\\AtalkDdp\\172",
		L"\\Device\\AtalkDdp\\173",
		L"\\Device\\AtalkDdp\\174",
		L"\\Device\\AtalkDdp\\175",
		L"\\Device\\AtalkDdp\\176",
		L"\\Device\\AtalkDdp\\177",
		L"\\Device\\AtalkDdp\\178",
		L"\\Device\\AtalkDdp\\179",
		L"\\Device\\AtalkDdp\\180",
		L"\\Device\\AtalkDdp\\181",
		L"\\Device\\AtalkDdp\\182",
		L"\\Device\\AtalkDdp\\183",
		L"\\Device\\AtalkDdp\\184",
		L"\\Device\\AtalkDdp\\185",
		L"\\Device\\AtalkDdp\\186",
		L"\\Device\\AtalkDdp\\187",
		L"\\Device\\AtalkDdp\\188",
		L"\\Device\\AtalkDdp\\189",
		L"\\Device\\AtalkDdp\\190",
		L"\\Device\\AtalkDdp\\191",
		L"\\Device\\AtalkDdp\\192",
		L"\\Device\\AtalkDdp\\193",
		L"\\Device\\AtalkDdp\\194",
		L"\\Device\\AtalkDdp\\195",
		L"\\Device\\AtalkDdp\\196",
		L"\\Device\\AtalkDdp\\197",
		L"\\Device\\AtalkDdp\\198",
		L"\\Device\\AtalkDdp\\199",
		L"\\Device\\AtalkDdp\\200",
		L"\\Device\\AtalkDdp\\201",
		L"\\Device\\AtalkDdp\\202",
		L"\\Device\\AtalkDdp\\203",
		L"\\Device\\AtalkDdp\\204",
		L"\\Device\\AtalkDdp\\205",
		L"\\Device\\AtalkDdp\\206",
		L"\\Device\\AtalkDdp\\207",
		L"\\Device\\AtalkDdp\\208",
		L"\\Device\\AtalkDdp\\209",
		L"\\Device\\AtalkDdp\\210",
		L"\\Device\\AtalkDdp\\211",
		L"\\Device\\AtalkDdp\\212",
		L"\\Device\\AtalkDdp\\213",
		L"\\Device\\AtalkDdp\\214",
		L"\\Device\\AtalkDdp\\215",
		L"\\Device\\AtalkDdp\\216",
		L"\\Device\\AtalkDdp\\217",
		L"\\Device\\AtalkDdp\\218",
		L"\\Device\\AtalkDdp\\219",
		L"\\Device\\AtalkDdp\\220",
		L"\\Device\\AtalkDdp\\221",
		L"\\Device\\AtalkDdp\\222",
		L"\\Device\\AtalkDdp\\223",
		L"\\Device\\AtalkDdp\\224",
		L"\\Device\\AtalkDdp\\225",
		L"\\Device\\AtalkDdp\\226",
		L"\\Device\\AtalkDdp\\227",
		L"\\Device\\AtalkDdp\\228",
		L"\\Device\\AtalkDdp\\229",
		L"\\Device\\AtalkDdp\\230",
		L"\\Device\\AtalkDdp\\231",
		L"\\Device\\AtalkDdp\\232",
		L"\\Device\\AtalkDdp\\233",
		L"\\Device\\AtalkDdp\\234",
		L"\\Device\\AtalkDdp\\235",
		L"\\Device\\AtalkDdp\\236",
		L"\\Device\\AtalkDdp\\237",
		L"\\Device\\AtalkDdp\\238",
		L"\\Device\\AtalkDdp\\239",
		L"\\Device\\AtalkDdp\\240",
		L"\\Device\\AtalkDdp\\241",
		L"\\Device\\AtalkDdp\\242",
		L"\\Device\\AtalkDdp\\243",
		L"\\Device\\AtalkDdp\\244",
		L"\\Device\\AtalkDdp\\245",
		L"\\Device\\AtalkDdp\\246",
		L"\\Device\\AtalkDdp\\247",
		L"\\Device\\AtalkDdp\\248",
		L"\\Device\\AtalkDdp\\249",
		L"\\Device\\AtalkDdp\\250",
		L"\\Device\\AtalkDdp\\251",
		L"\\Device\\AtalkDdp\\252",
		L"\\Device\\AtalkDdp\\253",
		L"\\Device\\AtalkDdp\\254",
		L"\\Device\\AtalkDdp\\255"
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\descrypt.h ===
#include "ntlmsspi.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ENCRYPT   0
#define DECRYPT   1

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0

unsigned //FAR
DES_CBC(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);


unsigned FAR
DES_CBC_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * IV,
            unsigned char FAR * Source,
            unsigned char FAR * Dest,
            unsigned            Size);

unsigned FAR
DES_ECB(    unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

unsigned FAR
DES_ECB_LM( DWORD /* unsigned */ Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);
            
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\crypto.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypto.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

//#include "UAMUtils.h"

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    char    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;


#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    char    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;


#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    char    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    DWORD   Length;         // Number of valid bytes in buffer
    DWORD   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef char *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef DWORD                       CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////




#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////



#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\encrypt.c ===
// encrypt.c
// contains all encryption code necessary for MSUAM encryption

#include <string.h>
#include "encrypt.h"
#include "UAMDebug.h"

/*-------------------------------------------------------------------*\
		DES defines.
\*-------------------------------------------------------------------*/
unsigned char *IP;
unsigned char *FP;
unsigned char *PC1_C;
unsigned char *PC1_D;
unsigned char *PC2_C;
unsigned char *PC2_D;
unsigned char *SHIFTS;
unsigned char *E;
unsigned char S[8][64];
unsigned char *P;

/*-------------------------------------------------------------------*\
		DES structure.
\*-------------------------------------------------------------------*/
typedef struct _desdata {
	char header[4];
	unsigned char IP[64];
	unsigned char FP[64];
	unsigned char PC1_C[28];
	unsigned char PC1_D[28];
	unsigned char SHIFTS[16];
	unsigned char PC2_C[24];
	unsigned char PC2_D[24];
	 
	unsigned char E[48];
	unsigned char S[8][64];
	unsigned char P[32];
} desdata, *PDesData, **HDesData;

static Handle ghMSUAMDesData = NULL; // static global handle (e.g. this file global only)


// ---------------------------------------------------------------------------
//		 SetupUAMEncrypt()
// ---------------------------------------------------------------------------
// Setup the table.
//
// Returns TRUE if the data resource was successfully read into memory, FALSE
// otherwise.

Boolean SetupUAMEncrypt( void )
{
	PDesData pdd;
	
	ghMSUAMDesData = GetResource('data', 2);
	if (ghMSUAMDesData == NULL)
	{
		DbgPrint_((DBGBUFF, "Couldn't get 'data' resource"));
		return(false);
	}
	
	HLock(ghMSUAMDesData);
	HNoPurge(ghMSUAMDesData);
	
	pdd 	= *(HDesData)ghMSUAMDesData;
	IP 		= pdd->IP;
	FP 		= pdd->FP;
	PC1_C 	= pdd->PC1_C;
	PC1_D 	= pdd->PC1_D;
	SHIFTS 	= pdd->SHIFTS;
	PC2_C 	= pdd->PC2_C;
	PC2_D 	= pdd->PC2_D;
	E 		= pdd->E;
	
	BlockMove(pdd->S, S, 8*64);
	
	P = pdd->P;
	
	return(true);
}


// ---------------------------------------------------------------------------
//		 CleanupUAMEncrypt()
// ---------------------------------------------------------------------------
void CleanupUAMEncrypt( void )
{
	if (ghMSUAMDesData)
	{
		HUnlock(ghMSUAMDesData);
		HPurge(ghMSUAMDesData);
		
		ReleaseResource(ghMSUAMDesData);
	}
}


// ---------------------------------------------------------------------------
//		 UprCString()
// ---------------------------------------------------------------------------
void UprCString(char* psz)
{
	c2pstr(psz);
	UpperString(*(Str255 *)psz, true); // really a pstr right now
	p2cstr((StringPtr)psz);
}


// ---------------------------------------------------------------------------
//		 OneWayFunction()
// ---------------------------------------------------------------------------
//     Inputs  - P14
//     Outputs - P22
//
//     Let P14 be the plain text password obtained at logon time, *passed in as a
//	 zero-terminated string and null padded herein to max length*.
//
//     P14 is used to encrypt the standard text, S8, and get P21.
//	 Encryption of standard text is accomplished with an option (ENCR_STD)
//	 to CryptIOCTL_2.
//
//     P21[0..7] = E(P14[0..6], S8)
//     P21[8..15] = E(P14[7..13], S8)
//     P21[16..20] = 0

unsigned char *OneWayFunction(unsigned char *pucPwd, unsigned char *pucDest, short scb)
{
	SInt16 len = strlen((char *)pucPwd);
	
	Assert_(pucPwd != NULL);
	Assert_(pucDest != NULL);
	
	if (len > scb)
	{
		Assert_(0);
		return (pucDest);
	}
	
	memset((char *)pucPwd+len, '\0', scb-len);
	
	CryptIOCTL2(ENCR_STD, pucPwd, nil, pucDest);
	CryptIOCTL2(ENCR_STD, pucPwd+7, nil, pucDest+8);
	
	memset((char *)pucDest + 16, '\0', 5);
	return(pucDest);
}


// ---------------------------------------------------------------------------
//		 Encrypt()
// ---------------------------------------------------------------------------
//     Inputs  - P21 (from OneWayChallenge())
//     Outputs - P24
//
//     P21 is used to encrypt the challenge, C8 sent by the server, to
//     get P24, which is the response sent back  to the server.
//
//     P24[0..7] = E(P21[0..6], C8)
//     P24[8..15] = E(P21[7..13], C8)
//     P24[16..23] = E(P21[14..20], C8)

unsigned char *Encrypt(unsigned char *key, unsigned char *source, unsigned char *dest)
{
	Assert_(key != NULL);
	Assert_(source != NULL);
	Assert_(dest != NULL);
	
	CryptIOCTL2(ENCR_KEY, source, key, dest);
	CryptIOCTL2(ENCR_KEY, source+7, key, dest+8);
	CryptIOCTL2(ENCR_KEY, source+14, key, dest+16);
	
	return(dest);
}

/************* Macintosh RDEV-environment version hacked by Wayne F. Tackabury, Pacer Software. 
			  Adapted from OS/2 version by Narendra Gidwani.
			  
			  Primary modifications: 
			  		--  StdEncrPwd turned into #define
					--  Allocation of a large table for underlying DES code to store its
						encryption tables. 
						
					Primary motivation:  in this environment, we have no global data 
					context to work with. 

			Copyright (c) 1992 Microsoft Corp.

************/

/*  Standard text for the ENCR_STD operation   */

// ---------------------------------------------------------------------------
//		 CryptIOCTL2()
// ---------------------------------------------------------------------------

unsigned pascal CryptIOCTL2(
			unsigned 		Option,
			unsigned char* 	Key,
			unsigned char*	Src,
			unsigned char*	Dst
)
{
	unsigned char	Buffer[8];
	unsigned char	CBuffer[8];
	KeyTbl*			allocatedKeyTable;


	if (Dst == NULL)
	{
		Assert_(0);
		return 1;
	}
	
	Dst[0] = 0;
	Dst[7] = 0;
	
	if (!Src && Option != ENCR_STD)
	{
		Assert_(0);
		return(1);
	}

	//
	//Allocate the key table which the underlying routines will need to generate
	//their de/en-cryption tables
	//
	if ((allocatedKeyTable = (KeyTbl *) NewPtrClear(sizeof(KeyTbl))) == nil)
		return(1);

	if (Option == ENCR_STD)
		memcpy(Buffer, StdEncrPwd, 8);
	else
		memcpy(Buffer, Src, 8);

	InitKey(Key, allocatedKeyTable);
	
	switch (Option)
	{
		case ENCR_KEY:
		case ENCR_STD:
			des( Buffer, CBuffer, allocatedKeyTable, ENCRYPT );
			break;
		case DECR_KEY:
			des( Buffer, CBuffer, allocatedKeyTable, DECRYPT );
			break;
		default:
			Assert_(0);
			DisposePtr((Ptr) allocatedKeyTable);
			return(1);
	}
	
	//
	//We have results.  Copy them across, deallocate our key table heap, and return.
	//
	
	memcpy(Dst, CBuffer, 8);
	DisposePtr((Ptr) allocatedKeyTable);
	
	return(0);
}

/*
** This file contains all the routines necessary for implementation of
** Federal Information Processing Data Encryption Standard (DES).
** Sytek Inc., Linden S. Feldman
**
** This file contains the following high level DES routines:
**
**     setkey(key);        set an 8 byte key for subsequent encrypt/decrypt.
**     encrypt(buf);       encrypt an 8 byte binary buffer.
**     decrypt(buf);       decrypt an 8 byte binary buffer.
**     ede( buf, l, r );   encrypt buf with key encrypting key parts l and r.
**     ded( buf, l, r );   decrypt buf with key encrypting key parts l and r.
**
**
** Also in this file are the following low level DES routines:
**
**     key_table(key)                   called by setkey() to init key table.
**     des(buf,crypt_mode)              called by encrypt() and decrypt().
**     des_cipher(buf,crypt_mode)       called by des().
*/

/**			Macintosh rdev/Chooser environment version hacked by Wayne Tackabury,
			Pacer Software, Inc. Sunday, August 9, 1992.

	Copyright (c) 1992 Pacer Software, Inc.,La Jolla, CA  92037
	Copyright (c) 1992 Microsoft Corp.
			
			PRIMARY MODIFICATIONS:
			
			In this environment, we have no global data context, and certainly no capa-
			bility for autoinitialization of same.  What we must do instead is to either
			externally reference constant tablular/heap information which can be stored
			in the outermost assembly-code storage of this containing module, or dynamically
			allocate what we actually need to modify.  I cheated even further, stuffing some
			tables into automatic storage of routines herein, since in this envrionment, we 
			are considerably more blessed with stack space than we are with static heap.
			
		->	the following arrays previously declared globally are now in the routines
			indicated
			
			C[], D[]				key_table()
			L[], tempL[], f[]		des_cipher();
			
			
		->	The key selector table, previously just known as KS[][], is now defined in 
			typedef KeyTbl.  A pointer to an allocated KeyTbl is now an input parameter to
			InitKey(), Key_table(), des(), and des_cipher.
			
		->	Also, SetKey() was deleted since it didn't seem to get called and I would like to
			save some code resource space here where I can.
			
		->	Also, function desf(), which was just dealing with far/near insecurities for 
			data addressing was removed since we don't worry about that in this environment.
			
		->	last, various PC/Microsoft C-centric typedefs (e.g., "_cdecl") were axed.		**/
		

// ---------------------------------------------------------------------------
//		 key_table()
// ---------------------------------------------------------------------------
// Set up the key table (schedule) from the key.

void key_table(unsigned char  *key, KeyTbl *generatedKeyTable)
{
        register int i, j;
        unsigned short k, t;
	/*
	** The C and D arrays used to calculate the key schedule.
	*/
	unsigned char   C[28];
	unsigned char   D[28];


    /*
    ** First, generate C and D by permuting
    ** the key.  The low order bit of each
    ** 8-bit unsigned char is not used, so C and D are only 28
    ** bits apiece.
    */
    for (i=0; i<28; i++)
    {
        C[i] = key[PC1_C[i]];
        D[i] = key[PC1_D[i]];
    }
    
    /*
    ** To generate Ki, rotate C and D according
    ** to schedule and pick up a permutation
    ** using PC2.
    */
    for (i=0; i<16; i++)
    {
        /*
        ** rotate.
        */
        for (k=0; k<SHIFTS[i]; k++)
        {
            t = C[0];
            for (j=0; j<28-1; j++)
            	C[j] = C[j+1];
            C[27] = (unsigned char) t;
            t = D[0];
            for (j=0; j<28-1; j++)
            	D[j] = D[j+1];
            D[27] = (unsigned char) t;
        }
        
        /*
        ** get Ki. Note C and D are concatenated.
        */
        for (j=0; j<24; j++)
        {
        	generatedKeyTable->KS[i][j] = C[PC2_C[j]];
			generatedKeyTable->KS[i][j+24] = D[PC2_D[j]];
        }
    }
}


// ---------------------------------------------------------------------------
//		 des_cipher()
// ---------------------------------------------------------------------------
// The payoff: encrypt or decrypt a block depending on crypt_mode = 0 or 1
// respectively.

void des_cipher(unsigned char  *block, KeyTbl *keySchedule, int crypt_mode)
{
	register int i, j;
	int ii, v, t, k, tblIndex;

	/*
	** The current block, divided into 2 halves.
	*/
	unsigned char   L[64];

	// unsigned char   R[32];

	/*
	** R[32] not used.
	** Normally L[64] would be set to L[32] and R[32] is not accessed directly
	** but indirectly through extended access of L[32+j] where j is 0 - 32.
	** Due to INTEL byte swapping some C compilers align arrays on even
	** boundaries, some worse yet on paragraph boundaries, so L[32] was
	** modified to be L[64] in order to correctly handle the extended accessing.
	*/
	unsigned char   tempL[32];
	unsigned char   f[32];

	/*
	** The combination of the key and the input, before selection.
	*/
	unsigned char   preS[48];


        /*
        ** First, permute the bits in the input
        */
        for (j=0; j<64; j++)
				{
				tblIndex = (int)IP[j];
                L[j] = block[tblIndex];
				}
        /*
        ** Perform an encryption operation 16 times.
        */
        for (ii=0; ii<16; ii++) {
                /*
                ** Set direction
                */
                if (crypt_mode)
                        i = 15-ii;
                else
                        i = ii;
                /*
                ** Save the R array,
                ** which will be the new L.
                */
                for (j=0; j<32; j++)
                        tempL[j] = L[j+32];
                /*
                ** Expand R to 48 bits using the E selector;
                ** exclusive-or with the current key bits.
                */
                for (j=0; j<48; j++)
                        preS[j] = L[E[j]+32] ^ keySchedule->KS[i][j];
                /*
                ** The pre-select bits are now considered
                ** in 8 groups of 6 bits each.
                ** The 8 selection functions map these
                ** 6-bit quantities into 4-bit quantities
                ** and the results permuted to make an f(R, K).
                ** The indexing into the selection functions
                ** is peculiar; it could be simplified by
                ** rewriting the tables.
                */
                for (j=0; j<8; j++) {
                        t = 6*j;
                        v = j;
                        k = S[v][(preS[t+0]<<5)+
                                (preS[t+1]<<3)+
                                (preS[t+2]<<2)+
                                (preS[t+3]<<1)+
                                (preS[t+4]<<0)+
                                (preS[t+5]<<4)];
                        t = 4*j;
                        f[t+0] = (unsigned char) ((k>>3)&01);
                        f[t+1] = (unsigned char) ((k>>2)&01);
                        f[t+2] = (unsigned char) ((k>>1)&01);
                        f[t+3] = (unsigned char) ((k>>0)&01);
                }       /* end of for loop doing the 8 groups of pre-select bits */
                /*
                ** The new R is L ^ f(R, K).
                ** The f here has to be permuted first, though.
                */
                for (j=0; j<32; j++)
                        L[j+32] = L[j] ^ f[P[j]];
                /*
                ** Finally, the new L (the original R)
                ** is copied back.
                */
                for (j=0; j<32; j++)
                        L[j] = tempL[j];
        } /* end of encrypted operation (16 times) */

        /*
        ** The output L and R are reversed.
        */
        for (j=0; j<32; j++) {
                t = L[j];
                L[j] = L[j+32];
                L[j+32] = (unsigned char) t;
        }
        /*
        ** The final output
        ** gets the inverse permutation of the very original.
        */
        for (j=0; j<64; j++)
                block[j] = L[FP[j]];
}

// ---------------------------------------------------------------------------
//		 des()
// ---------------------------------------------------------------------------

void des(unsigned char *inbuf, unsigned char *outbuf, KeyTbl *keySchedule, int crypt_mode)
{
    register int i, j;
    unsigned char block[64];

        for(i=0; i<64; i++)
                block[i] = 0;

        /*
        ** expand the bytes into a bit table.
        */
        for(i=0; i<8; i++)
                for(j=0; j<8; j++)
                        block[8*i+j]=(unsigned char)((inbuf[i] >> (7-j)) & 01);

        des_cipher( block, keySchedule, crypt_mode );

        for(i=0; i<8; i++) {            /* compress */
                outbuf[i] = 0;
                for(j=0; j<8; j++) {
                        outbuf[i] <<= 1;
                        outbuf[i] |= block[8*i+j];
                }
        }
}

// ---------------------------------------------------------------------------
//		 InitKey()
// ---------------------------------------------------------------------------

void InitKey(unsigned  char  *Key, KeyTbl *generatedKeyTable)
{
   register int   i, j, k;
   unsigned char  block[64];

   k = 0;
   memset((char *)block, 0, 64);
   for (i = 0; i < 8 ; i++ ) {
      for (j = 0 ; j < 7 ; j++ ) {
         block[8*i + j] = GETBIT(Key, k);
         k++;
      }
   }
   key_table(block, generatedKeyTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\ntlmsspi.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmsspi.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NTLMSSPI_INCLUDED_
#define _NTLMSSPI_INCLUDED_

#include <cwchar>

//#ifdef TARGET_OS_MAC
#define SEC_FAR
#define FAR
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fmemset memset
#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrncmp strncmp
//#endif

#ifdef DOS
#ifndef FAR
#define FAR far
#endif
#ifndef SEC_FAR
#define SEC_FAR FAR
#endif
#endif

//#include <sysinc.h>

#define MSV1_0_CHALLENGE_LENGTH 8

#ifndef IN
#define IN
#define OUT
#define OPTIONAL
#endif

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#define UNREFERENCED_PARAMETER(P)

#ifdef MAC
#define swaplong(Value) \
      	  Value =  (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8) \
             | (((Value) & 0x0000FF00) << 8) \
             | (((Value) & 0x000000FF) << 24))
#else
#define swaplong(Value)
#endif

#ifdef TARGET_OS_MAC
#define swapshort(Value) \
   Value = (  (((Value) & 0x00FF) << 8) \
             | (((Value) & 0xFF00) >> 8))
#else
#define swapshort(Value)
#endif

#ifndef TRUE
typedef bool BOOL;
#define FALSE 0
#define TRUE 1
#endif

#ifndef SEC_FAR
#define SEC_FAR
#endif

typedef unsigned long ULONG, DWORD, *PULONG;
typedef unsigned long SEC_FAR *LPULONG;
typedef unsigned short USHORT, WORD;
typedef char CHAR, *PCHAR;
typedef unsigned char UCHAR, *PUCHAR;
typedef unsigned char SEC_FAR *LPUCHAR;
typedef void SEC_FAR *PVOID, *LPVOID;
typedef unsigned char BOOLEAN;
typedef long LUID, *PLUID;
typedef wchar_t WCHAR;
typedef PCHAR LPSTR;

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))

//
// Counted String
//

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, *PSTRING;

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY;

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))


//
// Maximum lifetime of a context
//
//#define NTLMSSP_MAX_LIFETIME (2*60*1000)L    // 2 minutes
#define NTLMSSP_MAX_LIFETIME 120000L    // 2 minutes


////////////////////////////////////////////////////////////////////////
//
// Opaque Messages passed between client and server
//
////////////////////////////////////////////////////////////////////////

#define NTLMSSP_SIGNATURE "NTLMSSP"

//
// MessageType for the following messages.
//

typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate
} NTLM_MESSAGE_TYPE;

//
// Valid values of NegotiateFlags
//

#define NTLMSSP_NEGOTIATE_UNICODE 0x01      // Text strings are in unicode
#define NTLMSSP_NEGOTIATE_OEM     0x02      // Text strings are in OEM
#define NTLMSSP_REQUEST_TARGET    0x04      // Server should return its
                                            // authentication realm

#define NTLMSSP_NEGOTIATE_SIGN    0x10      // request message signing
#define NTLMSSP_NEGOTIATE_SEAL    0x20      // request message encrypting
#define NTLMSSP_RESERVED          0x40      // reserved for past use
#define NTLMSSP_NEGOTIATE_LM_KEY  0x80      // use LM session key

#define NTLMSSP_NEGOTIATE_NETWARE 0x100     // NetWare authentication
#define NTLMSSP_NEGOTIATE_NTLM    0x200     // NTLM authentication

#define NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED   0x1000  // Domain name supplied
#define NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED 0x2000 // Workstation name supplied
#define NTLMSSP_NEGOTIATE_LOCAL_CALL  0x4000 // Indicates client/server are same machine
#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN 0x8000 // Sign for all security leveles

//
// Valid target types returned by the server in Negotiate Flags
//

#define NTLMSSP_TARGET_TYPE_DOMAIN 0x10000  // TargetName is a domain name
#define NTLMSSP_TARGET_TYPE_SERVER 0x20000  // TargetName is a server name
#define NTLMSSP_TARGET_TYPE_SHARE  0x40000  // TargetName is a share name

//
// Opaque message returned from first call to InitializeSecurityContext
//
typedef struct _NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    ULONG MessageType;
    ULONG NegotiateFlags;
} NEGOTIATE_MESSAGE, *PNEGOTIATE_MESSAGE;

//
// Opaque message returned from first call to AcceptSecurityContext
//
typedef struct _CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    ULONG MessageType;
    STRING TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
} CHALLENGE_MESSAGE, *PCHALLENGE_MESSAGE;

//
// Opaque message returned from second call to InitializeSecurityContext
//
typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    ULONG MessageType;
    STRING LmChallengeResponse;
    STRING NtChallengeResponse;
    STRING DomainName;
    STRING UserName;
    STRING Workstation;
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

//
// Size of the largest message
//  (The largest message is the AUTHENTICATE_MESSAGE)
//

#define NTLMSSP_MAX_MESSAGE_SIZE (sizeof(AUTHENTICATE_MESSAGE) + \
                                  8 + \
                                  (15 + 1) + \
                                  (20 + 1) + \
                                  (15 + 1) )

//
// Signature structure
//

typedef struct _NTLMSSP_MESSAGE_SIGNATURE {
    ULONG   Version;
    ULONG   RandomPad;
    ULONG   CheckSum;
    ULONG   Nonce;
} NTLMSSP_MESSAGE_SIGNATURE, * PNTLMSSP_MESSAGE_SIGNATURE;

#define NTLMSSP_MESSAGE_SIGNATURE_SIZE sizeof(NTLMSSP_MESSAGE_SIGNATURE)

#define NTLMSSP_SIGN_VERSION 1

#define NTLMSSP_KEY_SALT 0xbd

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

PVOID
SspAlloc(
    int Size
    );

void
SspFree(
    PVOID Buffer
    );

PSTRING
SspAllocateString(
    PVOID Value
    );

PSTRING
SspAllocateStringBlock(
    PVOID Value,
    int Length
    );

void
SspFreeString(
    PSTRING * String
    );

void
SspCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where,
    IN BOOLEAN Absolute
    );

void
SspCopyStringFromRaw(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PCHAR InString,
    IN int InStringLength,
    IN OUT PCHAR *Where
    );

DWORD
SspTicks(
    );

#endif // ifndef _NTLMSSPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdebug.c ===
// ===========================================================================
//	UAMDebug.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Debugging routines for MS UAM.
// 	===========================================================================

#include "UAMDebug.h"
#ifdef UAMDebug

// ---------------------------------------------------------------------------
//		 UAM_DebugAlert()
// ---------------------------------------------------------------------------
//	Put up a debug alert box.

void UAM_DebugAlert(Str255 inErrStr, Str255 inFileName, long inLineNum)
{
	Str15	theLineStr;
	short	theIgnore;
	
	#ifdef UAMDebug
	Handle	theAlertResource = Get1Resource('ALRT', ALRT_Debug);
	Assert_(theAlertResource != NULL);
	#endif
	
	NumToString(inLineNum, theLineStr);
		
	ParamText(inErrStr, inFileName, theLineStr, "\p");
	theIgnore = StopAlert(ALRT_Debug, NULL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\rc4.h ===
#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
};

void rc4_key(struct RC4_KEYSTRUCT SEC_FAR *, DWORD /*unsigned int */ , unsigned char SEC_FAR *);
void rc4(struct RC4_KEYSTRUCT *, DWORD /*unsigned int */ , unsigned char *);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdebug.h ===
// ===========================================================================
//	UAMDebug.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Debugging routines for MS UAM.
// 	===========================================================================

#pragma once

#include <stdio.h>
#include <String.h>

#define ALRT_Debug	133

#ifdef UAMDebug

#define DBGBUFF				_buff
#define DbgPrint_(x)		do {																	\
								char	_buff[256];													\
								sprintf x;															\
								DebugStr(c2pstr(_buff));											\
							}while(false)
						
#define Assert_(test) 		do {																	\
								if (!(test)) {														\
									DbgPrint_((DBGBUFF, "Assertion failed: (%s) file: %s line: %d", \
														#test, __FILE__, __LINE__)); 				\
								}																	\
							}while(false)
							
#define DBGPrintIfOSErr_(err)	if (err != noErr) { 												\
									DbgPrint_((DBGBUFF, "OSErr: %d, line: %d  file: %s;g", 			\
														err, __LINE__, __FILE__)); 					\
								}

void UAM_DebugAlert(Str255 inErrStr, Str255 inFileName, long inLineNum);

#else
#define DbgPrint_(x)
#define Assert_(test)
#define DBGPrintIfOSErr_(err)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\encrypt.h ===
/*
 *
 * Encryption Header. Function prototypes and defines for encrypted MSUAM authentication
 *
 */
 
#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif
#define ENCR_RESULT_LENGTH  24
#define ENCRYPT 0
#define DECRYPT 1
#define LOCK_CRYPT()       0
#define UNLOCK_CRYPT()     0

#define StdEncrPwd "KGS!@#$%"

#define GETBIT(p, bit)     (unsigned char) ((p[bit >> 3] >> (7 - (bit & 07))) & 01)

void 			UprCString(char* psz);
unsigned char 	*OneWayFunction(unsigned char *pucPwd, unsigned char *pucDest, short scb);
unsigned char 	*Encrypt(unsigned char *key, unsigned char *source, unsigned char *dest);
unsigned pascal CryptIOCTL2(unsigned, unsigned char *, unsigned char *, unsigned char *);
//short pascal 	DES_CBC( unsigned, unsigned char *, unsigned char *, unsigned char *, unsigned char *, unsigned);
//void  			setkey(unsigned char *key);
Boolean			SetupUAMEncrypt( void );
void 			CleanupUAMEncrypt( void );

/*-------------------------------------------------------------------*\
		The DES key table (schedule). Generated from the key.
\*-------------------------------------------------------------------*/
typedef struct _KeyTbl
{
 	unsigned char   KS[16][48];
} KeyTbl;

void  			InitKey( unsigned char *Key, KeyTbl * );
void  			des(unsigned char *inbuf, unsigned char *outbuf, KeyTbl *, int crypt_mode);
void 			key_table(unsigned char  *key, KeyTbl *generatedKeyTable);
void 			des_cipher(unsigned char  *block, KeyTbl *keySchedule, int crypt_mode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdialogs.c ===
// ===========================================================================
//	UAMDialogs.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// General dialog utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#include <Sound.h>

#include "UAMDebug.h"
#include "UAMDialogs.h"
#include "UAMUtils.h"
#include "UAMMain.h"
#include "UAMNetwork.h"
#include "UAMDSNetwork.h"
#include "UAMListBox.h"
#include "UAMDLOGUtils.h"
#include "UAMKeychain.h"

extern Str32 			gServerName;
extern ModalFilterUPP	gDialogFilter;
extern UserItemUPP		gLineItem;
extern long				gSupportedUAMs;


// ---------------------------------------------------------------------------
//		 UAM_ReportError()
// ---------------------------------------------------------------------------
//	Reports an error to the user by displaying an alert box. This routine looks
//	in the resource file for a resource of type 'ESTR' with the same res ID as
//	the error code. If found, the message contained in the resource is displayed
//	to the user.
//
//	Note that we go out our way here by putting up and maintaining our own error
//	alert box instead of using one of the Alert routines. This is because other
//	dialogs in the UAM use ParamText() to set string information. If we have
//	an error, then the strings will be replaced by the alert strings. Not a
//	good scenario...

#define DITEM_MsgText	3

void UAM_ReportError(OSStatus inError)
{
	Str255			theMsg;
	short			theItem;
	StringHandle	theString;
	DialogPtr		theDialog	= NULL;
	GrafPtr			theSavePort	= NULL;
	
	Assert_(gDialogFilter != NULL);
		
	if (inError != noErr)
	{	
		GetPort(&theSavePort);
		
		InitCursor();
		
		UAM_PStrCopy("\p", theMsg);

		theString = (StringHandle)Get1Resource('STR ', inError);
		if (theString)
		{
			HLock((Handle)theString);
			UAM_PStrCopy(*theString, theMsg);
			HUnlock((Handle)theString);
			
			ReleaseResource((Handle)theString);
		}
				
		theDialog = UAM_NewDialog(DLOG_GeneralError, true);
		
		Assert_(theDialog != NULL);
		
		if (theDialog != NULL)
		{
			SysBeep(1);
		
			UAM_SetText(theDialog, DITEM_MsgText, theMsg);
			
			do
			{
				ModalDialog(gDialogFilter, &theItem);
			}while(theItem != 1);
			
			UAM_DisposeDialog(theDialog);
			SetPort(theSavePort);
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePwd()
// ---------------------------------------------------------------------------
//	Puts up and handles the change password dialog and calls the appropriate
//	routines to change the password.
//
//	Unless there is an error, we'll usually return one of:
//
//	#define CHNGPSWD_UPDATE_KEYCHAIN	1000
//	#define CHNGPSWD_USER_CANCELED		1001
//	#define CHNGPSWD_NOERR				noErr

#define DITEM_Icon			3
#define DITEM_OldPassword	6
#define DITEM_NewPassword	8
#define DITEM_VerifyPwd		10
#define DITEM_LineItem		11


OSStatus UAM_ChangePwd(UAMArgs *inUAMArgs)
{
	GrafPtr		theSavePort;
	short		theItem;
	OSStatus	theError;
	Str255		theNewPwd, theVerPwd;
	CursHandle	theCursor;
	DialogPtr	theDialog 		= NULL;
	Boolean		theDoLoop 		= true;
	KCItemRef	theKCItemRef	= NULL;
	
	Assert_(gDialogFilter != NULL);
	Assert_(gLineItem != NULL);
	
	GetPort(&theSavePort);
	
	ParamText(inUAMArgs->Opt.pwDlg.userName, gServerName, NULL, NULL);
	
	theDialog = UAM_NewDialog(DLOG_ChangePwd, true);
	if (theDialog == NULL)
	{
		UAM_ReportError(resNotFound);
		return(resNotFound);
	}
		
	//
	//Set up the line at the top of the dialog.
	//
	
	UAM_SetUpUserItem(theDialog, DITEM_LineItem, gLineItem, userItem);
	
	//
	//All three fields in this dialog are bullet protected.
	//
	
	UAM_SetBulletItem(theDialog, DITEM_OldPassword, UAM_CLRTXTPWDLEN);
	UAM_SetBulletItem(theDialog, DITEM_NewPassword, UAM_CLRTXTPWDLEN);
	UAM_SetBulletItem(theDialog, DITEM_VerifyPwd,   UAM_CLRTXTPWDLEN);
		
	if (inUAMArgs->Opt.pwDlg.password[0] != 0)
	{
		UAM_SetBulletText(
					theDialog,
					DITEM_OldPassword,
					inUAMArgs->Opt.pwDlg.password	);
					
		SelectDialogItemText(theDialog, DITEM_NewPassword, 0, 0);
	}
	else {
		SelectDialogItemText(theDialog, DITEM_OldPassword, 0, 0);
	}
	
	UAM_SupportCmdKeys(theDialog, false);
		
	do
	{
		ModalDialog(gDialogFilter, &theItem);
		
		switch(theItem)
		{
			case 1:
				UAM_GetBulletBuffer(theDialog, DITEM_NewPassword, theNewPwd);
				UAM_GetBulletBuffer(theDialog, DITEM_VerifyPwd,   theVerPwd);
				UAM_GetBulletBuffer(theDialog, DITEM_OldPassword, inUAMArgs->Opt.pwDlg.password);
				
				//
				//Ensure the new and verified password are equal. If not, present an
				//error to the user and give 'em a chance to correct the problem.
				//
				
				if (!EqualString(theNewPwd, theVerPwd, true, true))
				{
					UAM_ReportError(afpNTNewPasswordMismatchErr);
					
					UAM_ClearBulletText(theDialog, DITEM_NewPassword);
					UAM_ClearBulletText(theDialog, DITEM_VerifyPwd);
					SelectDialogItemText(theDialog, DITEM_NewPassword, 0, 0);
					break;
				}
				
				theCursor = GetCursor(watchCursor);
				if (theCursor) {
					SetCursor(*theCursor);
				}
				
				if (gSupportedUAMs & kMSUAM_V2_Supported)
				{
					//
					//If kMSUAM_V2_Supported, then we change the password a
					//different way.
					//
					
					theError = UAM_ChangePasswordV2(inUAMArgs, theNewPwd);
				}
				else {
					theError = UAM_ChangePassword(inUAMArgs, theNewPwd);
				}
				
				if (theError == noErr)
				{
					if (UAM_KCAvailable())
					{
						//
						//See if a keychain existed for the user name.
						//If so, delete it.
						//
						if (UAM_KCFindAppleSharePassword(
									inUAMArgs->Opt.pwDlg.userName,
									inUAMArgs->Opt.pwDlg.password,
									gServerName,
									&theKCItemRef) == noErr)
						{
							theError = KCDeleteItem(theKCItemRef);
							
							if ((theError != noErr) && (theError != userCanceledErr))
							{
								DbgPrint_((DBGBUFF, "KCDeleteItem() failed (%d)", theError));
								UAM_ReportError(theError);
							}
							else if (theError == noErr)
							{
								//
								//This is how we tell the main login routine to
								//re-enter the password into the keychain.
								//
								theError = CHNGPSWD_UPDATE_KEYCHAIN;
							}
							
							KCReleaseItem(&theKCItemRef);
						}
					}
					
					//
					//If we changed the password successfully, then store the
					//new password in the arguments struct.
					//
					
					UAM_PStrCopy(theNewPwd, inUAMArgs->Opt.pwDlg.password);
				}
								
				theDoLoop = false;
				break;
			
			case 2:
				theError  = CHNGPSWD_USER_CANCELED;
				theDoLoop = false;
				break;
			
			default:
				break;
		}
		
	}while(theDoLoop);
	
	UAM_DisposeDialog(theDialog);
	SetPort(theSavePort);
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePasswordNotificationDlg()
// ---------------------------------------------------------------------------
//	Put up an about dialog.

void UAM_ChangePasswordNotificationDlg(Int16 inDaysTillExpiration)
{
	const Int16		theLine 	= 4;
	const Int16		theTextBox	= 5;
	
	GrafPtr			theSavePort;
	DialogPtr		theDialog = NULL;
	short			theItem;
	Str255			theDaysStr;
	
	Assert_(gDialogFilter != NULL);
	Assert_(gLineItem != NULL);
	
	GetPort(&theSavePort);
	
	if (inDaysTillExpiration > 0)
	{
		NumToString(inDaysTillExpiration, theDaysStr);
		ParamText(theDaysStr, NULL, NULL, NULL);
	}

	theDialog = UAM_NewDialog(DLOG_ChangePwdNotification, true);
	
	Assert_(theDialog != NULL);
	
	if (theDialog == NULL) 
	{
		//
		//We could not get our dialog from the resource, something real
		//bad has happened, try to exit gracefully.
		//
		
		return;
	}
		
	if (inDaysTillExpiration <= 0)
	{
		StringHandle theString = GetString(uamPasswordExpiresInOneDay);
		
		Assert_(theString != NULL);
		
		if (theString != NULL) {
			UAM_SetText(theDialog, theTextBox, *theString);
		}
	}

	UAM_SetUpUserItem(theDialog, theLine, gLineItem, userItem);
	
	do
	{
		ModalDialog(gDialogFilter, &theItem);
		
	}while(theItem != DITEM_OK);
	
	UAM_DisposeDialog(theDialog);
	SetPort(theSavePort);
}


// ---------------------------------------------------------------------------
//		 UAM_AskQuestion()
// ---------------------------------------------------------------------------
// Asks a "yes" or "no" question. You supply the ID of the STR resource the
// question resides in.
//
// Returns: 1 (ALRT_YES) for yes, 2 (ALRT_NO) for no.

Int16 UAM_AskQuestion(Int16 inStrID)
{
	Int16			theResponse	= ALRT_NO;
	StringHandle	theString	= NULL;
	
	theString = GetString(inStrID);
	
	Assert_(theString != NULL);
	
	if (theString != NULL)
	{
		InitCursor();
		
		ParamText(*theString, NULL, NULL, NULL);
		theResponse = Alert(ALRT_ReplaceKey, NULL);
		
		ReleaseResource((Handle)theString);
	}
	
	return(theResponse);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdialogs.h ===
// ===========================================================================
//	UAMDialogs.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "ClientUAM.h"
#include "UAMUtils.h"

#define DLOG_ChangePwd				12129
#define DLOG_GeneralError			12130
#define DLOG_ChangePwdNotification	12134

#define ALRT_WrongClientVers		132
#define ALRT_ReplaceKey				134

#define ALRT_YES					1
#define ALRT_NO						2

//
//Standard dialog items throughout all our dialogs.
//

#define DITEM_OK		1
#define DITEM_Cancel	2

//
//Codes that UAM_ChangePswd return
//
#define CHNGPSWD_UPDATE_KEYCHAIN	1000
#define CHNGPSWD_USER_CANCELED		1001
#define CHNGPSWD_NOERR				noErr

//
//These are our UAM specific error codes.
//
enum
{
	uamErr_InternalErr				= 1000,
	uamErr_NoAFPVersion,
	uamErr_WrongClientErr
};

//
//The following struct is used to map error codes to resource id's
//containing message strings.
//
typedef struct 
{
	OSErr	errorCode;
	short	errorString;
}ErrorDescription;	

//
//Prototypes for dialog routines live here.
//

void 		UAM_ReportError(OSStatus inError);
OSStatus	UAM_ChangePwd(UAMArgs *inUAMArgs);
void 		UAM_ChangePasswordNotificationDlg(Int16 inDaysTillExpiration);
Int16 		UAM_AskQuestion(Int16 inStrID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdlogtext.c ===
// ===========================================================================
//	UAMDLOGText.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// Utilities for maintaining a scrolling text field in a dialog.
//
// ===========================================================================

#include <ControlDefinitions.h>

#include "UAMDLOGUtils.h"
#include "UAMDLOGText.h"

// ---------------------------------------------------------------------------
//		 UAM_AdjustText()
// ---------------------------------------------------------------------------

void UAM_AdjustText(ControlHandle theScrollBar)
{
	DialogPtr	dialog;
	TEHandle	dTE;
	short		scrollValue;
	char		saveState;
	
	dialog = (*theScrollBar)->contrlOwner;
	dTE = UAM_DLOG(dialog).dialogTE;

	saveState = HGetState((Handle)dTE);
	HLock((Handle)dTE);
	
	scrollValue = GetControlValue( theScrollBar);
	UAM_DLOG(dialog).deltaV = Abs(UAM_DLOG(dialog).vOffset) - scrollValue;
	UAM_DLOG(dialog).vOffset = scrollValue;
	
	if (UAM_DLOG(dialog).deltaV)
		TEScroll(0, UAM_DLOG(dialog).deltaV, dTE);
	
	UAM_DLOG(dialog).deltaV = 0;
	
	HSetState((Handle)dTE, saveState);
}


// ---------------------------------------------------------------------------
//		 UAM_ScrollText()
// ---------------------------------------------------------------------------

pascal void UAM_ScrollText(ControlHandle theControl, short thePart)
{
	short		delta, newValue;
	short		ctlMin, ctlMax;
	UInt32		tix;
	DialogPtr	dialog;
	Rect		r;
	
	dialog = (*theControl)->contrlOwner;
	r = (*(UAM_DLOG(dialog).dialogTE))->viewRect;
	
	switch(thePart)
	{
		case kControlUpButtonPart:
			delta = -16;
			break;
		case kControlDownButtonPart:
			delta = 16;
			break;
		case kControlPageUpPart:
			delta = Min(-(r.bottom - r.top) / 2, -1);
			Delay(10, &tix);
			break;
		case kControlPageDownPart:
			delta = Max((r.bottom - r.top) / 2, 1);
			Delay(10, &tix);
			break;
		default:
			return;
			break;
	}
	
	newValue = GetControlValue( theControl) + delta;
	
	ctlMax = GetControlMaximum( theControl);
	ctlMin = GetControlMinimum( theControl);
	
	if (newValue > ctlMax)
		newValue = ctlMax;
	else if (newValue < ctlMin)
		newValue = ctlMin;
	
	SetControlValue( theControl, newValue);
	UAM_AdjustText( theControl);
}


// ---------------------------------------------------------------------------
//		 UAM_SetScrollBar()
// ---------------------------------------------------------------------------

void UAM_SetScrollBar(ControlHandle theScrollBar)
{
	short		theHeight;
	DialogPtr	dialog;
	Rect		winRect;
	TEHandle	dTE;	
	
	dialog = (*theScrollBar)->contrlOwner;
	dTE = UAM_DLOG(dialog).dialogTE;
	winRect = UAM_DLOG(dialog).dialogTERect;
	
	theHeight = TEGetHeight( (*dTE)->nLines, 0, dTE);
	
	if (theHeight > (winRect.bottom - winRect.top))
		SetControlMaximum( theScrollBar, (theHeight - (winRect.bottom - winRect.top)));
	else {
		SetControlValue( theScrollBar, 0);
		SetControlMaximum( theScrollBar, 0);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_UpdateText()
// ---------------------------------------------------------------------------

void UAM_UpdateText(DialogPtr dialog)
{
	Rect 		r;
	
	r = UAM_DLOG(dialog).dialogTERect;
	InsetRect(&r, textMargin, textMargin);
	TEUpdate(&r, UAM_DLOG(dialog).dialogTE);
	FrameRect(&UAM_DLOG(dialog).dialogTERect);
}
			

// ---------------------------------------------------------------------------
//		 UAM_FixText()
// ---------------------------------------------------------------------------

void UAM_FixText(DialogPtr dialog)
{
	TEHandle	dTE;
	char		saveState;
	
	dTE = UAM_DLOG(dialog).dialogTE;
	
	saveState = HGetState((Handle)dTE);
	HLock((Handle)dTE);
	
	(*dTE)->viewRect = UAM_DLOG(dialog).dialogTERect;
	
	(*dTE)->viewRect.right = (*dTE)->viewRect.right;
	(*dTE)->viewRect.bottom = (*dTE)->viewRect.bottom;
	
	InsetRect( &((*dTE)->viewRect), textMargin, textMargin);
	(*dTE)->destRect = (*dTE)->viewRect;
	
	TECalText( dTE);

	HSetState((Handle)dTE, saveState);
}


// ---------------------------------------------------------------------------
//		 UAM_SetSText()
// ---------------------------------------------------------------------------

void UAM_SetSText(DialogPtr dialog, short textID)
{
	Handle			textHndl;
	Rect			r;
	StScrpHandle	hST;
	
	textHndl = Get1Resource('TEXT', textID);

	if (textHndl != NULL)
	{
		HLock((Handle)UAM_DLOG(dialog).dialogTE);
		HLock(textHndl);
				
		r = UAM_DLOG(dialog).dialogTERect;
		InsetRect(&r, textMargin, textMargin);
		EraseRect(&r);
		InvalRect(&r);
	
		TESetText(*textHndl, GetHandleSize(textHndl), UAM_DLOG(dialog).dialogTE);
		
		hST = (StScrpHandle)Get1Resource('styl', textID);
		if (hST != NULL) {
			HidePen();
			TEUseStyleScrap( 0, 32767, hST, TRUE, UAM_DLOG(dialog).dialogTE);
			ShowPen();
		}

		UAM_DLOG(dialog).vOffset = 0;
		UAM_DLOG(dialog).deltaV  = 0;
		
		SetControlValue(UAM_DLOG(dialog).scrollBar, 0);
		UAM_FixText(dialog);
		UAM_AdjustText(UAM_DLOG(dialog).scrollBar);
		
		UAM_SetScrollBar( UAM_DLOG(dialog).scrollBar);
		
		HUnlock((Handle)UAM_DLOG(dialog).dialogTE);
		HUnlock(textHndl);
		
		ReleaseResource(textHndl);
		ReleaseResource((Handle)hST);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_MakeText()
// ---------------------------------------------------------------------------

void UAM_MakeText(DialogPtr dialog, short textItem, short scrollItem, short textID)
{
	Rect	textRect, r;
		
	UAM_DLOG(dialog).dialogTERect = UAM_GetItemRect(dialog, textItem);
	textRect = UAM_DLOG(dialog).dialogTERect;
	
	UAM_DLOG(dialog).hasScrollBar = TRUE;
	
	InsetRect(&textRect, textMargin, textMargin);
	UAM_DLOG(dialog).dialogTE = TEStyleNew(&textRect, &textRect);
	
	r = UAM_GetItemRect(dialog, scrollItem);
	UAM_DLOG(dialog).scrollBar = NewControl(dialog, &r, "\p", TRUE, 0, 0, 0, 16, 0);
	UAM_SetUpUserItem(dialog, scrollItem, (UserItemUPP)UAM_DLOG(dialog).scrollBar, ctrlItem);
	
	UAM_SetSText(dialog, textID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdlogtext.h ===
// ===========================================================================
//	UAMDLOGText.h 			 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once


void				UAM_AdjustText			( ControlHandle );
void				UAM_DoScrolling			( ControlHandle, short );
pascal void			UAM_ScrollText			( ControlHandle, short );
void				UAM_SetScrollBar		( ControlHandle );
void				UAM_UpdateText			( DialogPtr );
void				UAM_SetSText			( DialogPtr, short );
void				UAM_MakeText			( DialogPtr, short, short, short );
void 				UAM_FixText				(DialogPtr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdlogutils.c ===
// ===========================================================================
//	UAMDLOGUtils.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// General dialog utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#include <Dialogs.h>
#include <Events.h>
#include <Controls.h>
#include <Sound.h>
#include <ControlDefinitions.h>

#include <ctype.h>

#include "UAMUtils.h"
#include "UAMListBox.h"
#include "UAMDLOGText.h"
#include "UAMDLOGUtils.h"
#include "UAMDebug.h"
	

// ---------------------------------------------------------------------------
//		 UAM_GetScreenBounds()
// ---------------------------------------------------------------------------

Rect UAM_GetScreenBounds()
{
	GrafPtr		savePort,p;
	Rect		screenBounds;
	
	GetPort(&savePort);
	
	p = (GrafPtr)NewPtr(sizeof(GrafPort));
	OpenPort(p);
	
	screenBounds = p->portBits.bounds;
	
	ClosePort(p);
	DisposePtr((Ptr)p);
	
	return(screenBounds);
}


// ---------------------------------------------------------------------------
//		 UAM_GetCHandle()
// ---------------------------------------------------------------------------

ControlHandle UAM_GetCHandle(DialogPtr inDialog, short item)
{
	short	itype;
	Rect	irect;
	Handle	ihan;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	return((ControlHandle)ihan);
}


// ---------------------------------------------------------------------------
//		 UAM_GetItemRect()
// ---------------------------------------------------------------------------

Rect UAM_GetItemRect(DialogPtr inDialog, short item)
{
	short	itype;
	Rect	irect;
	Handle	ihan;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	return(irect);
}


// ---------------------------------------------------------------------------
//		 UAM_ToggleControl()
// ---------------------------------------------------------------------------

void UAM_ToggleControl(DialogPtr inDialog, short item)
{
	UAM_SetCValue(inDialog, item, UAM_GetCValue(inDialog, item) == 0);
}


// ---------------------------------------------------------------------------
//		 UAM_GetText()
// ---------------------------------------------------------------------------

void UAM_GetText(DialogPtr inDialog, short item, Str255 *theText)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
		
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	
	if ((itype == editText)||(itype == editText + itemDisable))
		GetDialogItemText(ihan, *theText);
}


// ---------------------------------------------------------------------------
//		 UAM_SetText()
// ---------------------------------------------------------------------------

void UAM_SetText(DialogPtr inDialog, short item, Str255 theText)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	if ((itype == editText)
		||(itype == editText+itemDisable)
		||(itype == statText)
		||(itype == statText+itemDisable))
		
		SetDialogItemText(ihan, theText);
}


// ---------------------------------------------------------------------------
//		 UAM_HiliteItem()
// ---------------------------------------------------------------------------

void UAM_HiliteItem(DialogPtr inDialog, short item, short value)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	HiliteControl((ControlHandle)ihan, value);
}


// ---------------------------------------------------------------------------
//		 UAM_IsActive()
// ---------------------------------------------------------------------------

Boolean UAM_IsActive(DialogPtr inDialog, short item)
{
	ControlHandle	theHandle;
	
	theHandle = UAM_GetCHandle(inDialog, item);
	if (theHandle)
	{
		return(((*theHandle)->contrlHilite != 255));
	}
	
	return(false);
}


// ---------------------------------------------------------------------------
//		 UAM_GetCValue()
// ---------------------------------------------------------------------------

short UAM_GetCValue(DialogPtr inDialog, short item)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	short	result;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	result = GetControlValue((ControlHandle)ihan);
			
	return(result);
}


// ---------------------------------------------------------------------------
//		 UAM_SetCValue()
// ---------------------------------------------------------------------------

void UAM_SetCValue(DialogPtr inDialog, short item, short value)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
	SetControlValue((ControlHandle)ihan, value);
}


// ---------------------------------------------------------------------------
//		 UAM_PositionDialog()
// ---------------------------------------------------------------------------

void UAM_PositionDialog(ResType theType, short theID)
{
	Rect	*theRect;
	Rect	screenBounds;
	Handle	theTemplate;
	short	left,top;
	
	screenBounds = UAM_GetScreenBounds();
	
	theTemplate = GetResource(theType, theID);
	theRect = (Rect *)*theTemplate;
	
	left = (screenBounds.right - (theRect->right - theRect->left)) / 2;
	top = (screenBounds.bottom - (theRect->bottom - theRect->top)) / 3;
	
	if (top < LMGetMBarHeight())
		top = LMGetMBarHeight() + 7;
	
	theRect->right = theRect->right + left - theRect->left;
	theRect->left = left;
	theRect->bottom = theRect->bottom + top - theRect->top;
	theRect->top = top;
}


// ---------------------------------------------------------------------------
//		 UAM_GetItemType()
// ---------------------------------------------------------------------------

short UAM_GetItemType(DialogPtr inDialog, short item)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, item, &itype, &ihan, &irect);
			
	return(itype);
}


// ---------------------------------------------------------------------------
//		 UAM_NewDialog()
// ---------------------------------------------------------------------------

DialogPtr UAM_NewDialog(short id, Boolean show)
{
	Ptr			storage;
	DialogPtr	dialog;
	short		x;
		
	storage = NewPtrClear(sizeof(UAMDialogRec));
	if (storage == NULL) {
		return(NULL);
	}
			
	dialog = GetNewDialog(id, storage, (WindowPtr) -1);
	if (dialog == NULL) {
		return(NULL);
	}
	
	SetPort(dialog);
	
	if (UAM_GetItemType(dialog, kStdOkItemIndex) == kButtonDialogItem) {
		SetDialogDefaultItem(dialog, kStdOkItemIndex);
	}
	
	if (UAM_GetItemType(dialog, kStdCancelItemIndex) == kButtonDialogItem) {
		SetDialogCancelItem(dialog, kStdCancelItemIndex);
	}

	SetDialogTracksCursor(dialog, true);

	if (show) {
		ShowWindow(dialog);
	}
		
	UAM_DLOG(dialog).hasScrollBar 	= FALSE;
	UAM_DLOG(dialog).supportCmdKeys	= TRUE;
	UAM_DLOG(dialog).customFilter	= NULL;
	UAM_DLOG(dialog).hasList		= false;
	
	for (x = 0; x < kMaxGatedItems; x++)
	{
		UAM_DLOG(dialog).gateItems[x].controlID		= 0;
		UAM_DLOG(dialog).gateItems[x].textID		= 0;
	}
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		UAM_DLOG(dialog).bulletItems[x].editID		= 0;
		UAM_DLOG(dialog).bulletItems[x].maxLength	= 0;
		UAM_DLOG(dialog).bulletItems[x].hTE			= NULL;
	}
	
	UAM_DLOG(dialog).scrollActionProc = NewControlActionProc(&UAM_ScrollText);
		
	InitCursor();
	return(dialog);
}
		

// ---------------------------------------------------------------------------
//		 UAM_Update()
// ---------------------------------------------------------------------------

void UAM_Update(DialogPtr inDialog)
{
	GrafPtr	savePort;
	
	GetPort(&savePort);
	SetPort(inDialog);
	
	BeginUpdate(inDialog);
		
	if (UAM_DLOG(inDialog).hasScrollBar) {
		UAM_UpdateText(inDialog);
	}
		
	if (UAM_DLOG(inDialog).hasList) {
		UAM_ListUpdate(inDialog);
	}
		
	DrawDialog(inDialog);
	DrawControls(inDialog);

	EndUpdate(inDialog);
	
	SetPort(savePort);
}


// ---------------------------------------------------------------------------
//		 UAM_DialogFilter()
// ---------------------------------------------------------------------------

pascal Boolean UAM_DialogFilter(DialogPtr inDialog, EventRecord *e, short *itemHit)
{
	Boolean 		result;
	short			thePart, temp;
	Point			pt;
	ControlHandle	theControl;
	ModalFilterUPP	theStdProc;
			
	result = FALSE;
	
	if (GetStdFilterProc(&theStdProc) == noErr)
	{
		if (CallModalFilterProc(theStdProc, inDialog, e, itemHit))
		{
			//
			//The standard proc handled everything for us, so exit.
			//
			return(TRUE);
		}
	}
	
	if (UAM_DLOG(inDialog).customFilter != NULL)
	{
		if (CallModalFilterProc(UAM_DLOG(inDialog).customFilter, inDialog, e, itemHit))
		{
			return(TRUE);
		}
	}
	
	switch(e->what)
	{
		case updateEvt:
			if ((DialogPtr)e->message == inDialog)
				UAM_Update(inDialog);
			break;
			
		case mouseDown:
			pt = e->where;
			GlobalToLocal(&pt);
			
			if (UAM_DLOG(inDialog).hasScrollBar)
			{
				thePart = FindControl(pt, inDialog, &theControl);
				if (theControl == UAM_DLOG(inDialog).scrollBar)
				{
					if (thePart == kControlIndicatorPart)
					{
						temp = TrackControl(theControl, pt, 0L);
						UAM_AdjustText(theControl);
						result = TRUE;
					}
					else if (thePart >= kControlUpButtonPart)
					{
						temp = TrackControl(theControl, pt, UAM_DLOG(inDialog).scrollActionProc);
						result = TRUE;
					}
				}
			}
			
			if ((!result) && (UAM_DLOG(inDialog).hasList)) {
				result = UAM_ListDialogFilter(inDialog, e, itemHit);
			}
			break;
			
		case keyDown:
		case autoKey:
			result = UAM_ProcessKeydown(inDialog, e, itemHit);
			break;
			
		default:
			break;
	}
			
	return(result);
}


// ---------------------------------------------------------------------------
//		 UAM_CheckGatedControls()
// ---------------------------------------------------------------------------

void UAM_CheckGatedControls(DialogPtr inDialog)
{
	short			x,i;
	Str255			s2;
		
	//
	//Flip through each of the gated controls and check to see if their associated
	//text box has text of not.
	//
	for (x = 0; x < kMaxGatedItems; x++)
	{
		if (	(UAM_DLOG(inDialog).gateItems[x].controlID != 0)	&&
				(UAM_DLOG(inDialog).gateItems[x].textID != 0)		)
		{
			UAM_GetText(
					inDialog,
					UAM_DLOG(inDialog).gateItems[x].textID,
					(Str255 *)&s2
			);
			
			//
			//Do we have text in the associated text box? And, is the first character
			//a non-white space?
			//
			if ((s2[0] == 0) || (isspace(s2[1])))
			{
				if (UAM_DLOG(inDialog).gateItems[x].state != 255)
				{
					//
					//No, so set the state of the box to 255 which grays it out.
					//
					UAM_DLOG(inDialog).gateItems[x].state = 255;
					
					UAM_HiliteItem(
							inDialog,
							UAM_DLOG(inDialog).gateItems[x].controlID,
							UAM_DLOG(inDialog).gateItems[x].state
					);
					
					//
					//Now see if any other controls are gated to this text box. If so, then
					//set the state to grayed also at this point.
					//
					for (i = 0; i < kMaxGatedItems; i++)
					{
						if ((i != x) && (UAM_DLOG(inDialog).gateItems[i].controlID != 0))
						{
							if (UAM_DLOG(inDialog).gateItems[i].textID == UAM_DLOG(inDialog).gateItems[x].textID)
							{
								UAM_DLOG(inDialog).gateItems[i].state = 255;
								
								UAM_HiliteItem(
										inDialog,
										UAM_DLOG(inDialog).gateItems[i].controlID,
										UAM_DLOG(inDialog).gateItems[i].state
								);
							}
						}
					}
				}
			}
			else
			{
				UAM_DLOG(inDialog).gateItems[x].state = 0;
				
				UAM_HiliteItem(
						inDialog,
						UAM_DLOG(inDialog).gateItems[x].controlID,
						UAM_DLOG(inDialog).gateItems[x].state
				);
			}
		}
	}
}
	

// ---------------------------------------------------------------------------
//		 UAM_FrameItem()
// ---------------------------------------------------------------------------

pascal void UAM_FrameItem(DialogPtr inDialog, short i)
{
	GrafPtr	savePort;
	Rect	r;
	
	GetPort(&savePort);
	SetPort(inDialog);
	
	r = UAM_GetItemRect( inDialog, i);
	if ((r.bottom - r.top <= 1) || (r.right - r.left <= 1))
	{
		if (r.bottom - r.top <= 1) {
			MoveTo(r.left, r.top);
			LineTo(r.right, r.top);
		} else {
			MoveTo(r.left, r.top);
			LineTo(r.left, r.bottom);
		}
	}
	else
		FrameRect(&r);
	
	SetPort(savePort);
}


// ---------------------------------------------------------------------------
//		 UAM_GetDRect()
// ---------------------------------------------------------------------------

Rect UAM_GetDRect( short id )
{
	DialogTHndl	dTh;
	Rect		r;
	
	dTh = (DialogTHndl)Get1Resource('DLOG', id);
	r = (**dTh).boundsRect;
	
	ReleaseResource((Handle)dTh);
	
	return(r);
}
	

// ---------------------------------------------------------------------------
//		 UAM_SetUpUserItem()
// ---------------------------------------------------------------------------

void UAM_SetUpUserItem(DialogPtr inDialog, short i, UserItemUPP userProc, short type)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, i, &itype, &ihan, &irect);
	SetDialogItem(inDialog, i, type, (Handle)userProc, &irect);
}


// ---------------------------------------------------------------------------
//		 UAM_DisposeDialog()
// ---------------------------------------------------------------------------

void UAM_DisposeDialog(DialogPtr inDialog)
{
	SInt16	x;
	
	if (UAM_DLOG(inDialog).hasScrollBar)
	{
		if (UAM_DLOG(inDialog).dialogTE)
			TEDispose(UAM_DLOG(inDialog).dialogTE);
		if (UAM_DLOG(inDialog).scrollBar)
			DisposeControl(UAM_DLOG(inDialog).scrollBar);
	}
	
	DisposeRoutineDescriptor(UAM_DLOG(inDialog).scrollActionProc);
	
	if (UAM_DLOG(inDialog).hasList) {
		LDispose(UAM_DLOG(inDialog).dialogList);
	}
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].hTE != NULL)
		{
			TEDispose(UAM_DLOG(inDialog).bulletItems[x].hTE);
			UAM_DLOG(inDialog).bulletItems[x].hTE = NULL;
		}
	}	
	
	DisposeDialog(inDialog);
}


// ---------------------------------------------------------------------------
//		 UAM_GateControl()
// ---------------------------------------------------------------------------

void UAM_GateControl(DialogPtr inDialog, short controlID, short textID)
{
	short	x;
	Boolean	found = false;
	
	//
	//Find the next available gate slot.
	//
	
	for (x = 0; x < kMaxGatedItems; x++)
	{
		if (UAM_DLOG(inDialog).gateItems[x].controlID == 0)
		{
			found = true;
			break;
		}
	}
	
	if (found)
	{
		UAM_DLOG(inDialog).gateItems[x].controlID	= controlID;
		UAM_DLOG(inDialog).gateItems[x].textID		= textID;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_StopGate()
// ---------------------------------------------------------------------------

void UAM_StopGate(DialogPtr inDialog, short controlID)
{
	SInt16	x;
	
	for (x = 0; x < kMaxGatedItems; x++)
	{
		if (UAM_DLOG(inDialog).gateItems[x].controlID == controlID)
		{
			UAM_DLOG(inDialog).gateItems[x].controlID	= 0;
			UAM_DLOG(inDialog).gateItems[x].textID		= 0;
			UAM_DLOG(inDialog).gateItems[x].state		= 0;
			
			UAM_HiliteItem(inDialog, controlID, 0);
			
			break;
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SetBulletItem()
// ---------------------------------------------------------------------------

void UAM_SetBulletItem(DialogPtr inDialog, short item, short maxLen)
{
	short 		x;
	Boolean		found = false;
	Rect		rDest;
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == 0)
		{
			found = true;
			break;
		}
	}
	
	if (found)
	{
		UAM_DLOG(inDialog).bulletItems[x].editID	= item;
		UAM_DLOG(inDialog).bulletItems[x].maxLength	= maxLen;
		
		SetRect(&rDest, -1001, -1001, -1000, -1000);
		UAM_DLOG(inDialog).bulletItems[x].hTE = TENew(&rDest, &rDest);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SetBulletText()
// ---------------------------------------------------------------------------

void UAM_SetBulletText(DialogPtr inDialog, short item, Str255 text)
{
	short		x, i;
	Str255		s;
	TEHandle	hTE = NULL;
		
	//
	//Flip through all the bullet items till we find the one to set
	//
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)
		{
			SelectDialogItemText(inDialog, item, 0, 0);
			
			s[0] = 0;
				
			for (i = 1; i <= text[0]; i++) 
			{
				s[i] = kPasswordBulletText;
				s[0]++;
			}
			
			UAM_SetText(inDialog, item, s);			
			TESetText(&text[1], text[0], UAM_DLOG(inDialog).bulletItems[x].hTE);
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ClearBulletText()
// ---------------------------------------------------------------------------

void UAM_ClearBulletText(DialogPtr inDialog, short item)
{
	short	x;
	TEPtr	pTE;
		
	//
	//Flip through all the bullet items till we find the one to set
	//
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)
		{
			UAM_SetText(inDialog, item, "\p");
			
			HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
			
			pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);
			pTE->selStart	= 0;
			pTE->selEnd		= pTE->teLength;
			
			HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
			
			TEDelete(UAM_DLOG(inDialog).bulletItems[x].hTE);
			break;
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ProcessKeydown()
// ---------------------------------------------------------------------------

Boolean UAM_ProcessKeydown(DialogPtr inDialog, EventRecord *event, short *item)
{
	Boolean		result 		= false;
	short		chCode		= (event->message & charCodeMask);
	Cell		theCell		= {0,0};
	Cell		tempCell	= {0,0};
	short		x;
	TEHandle	hTE;
	TEPtr		pTE;
	
	//
	//See if we want to support the edit command keys. If not, then
	//kill the event and act like nothing happend. Also checkd for
	//the unsupported Forward Delete key.
	//
	
	if (	((!UAM_DLOG(inDialog).supportCmdKeys) && (event->modifiers & cmdKey)) ||
			(chCode == UAMKey_FwdDel)									)
	{
		event->what		= nullEvent;
		event->message	= 0;
		
		return(true);
	}
	
	//
	//If we have a list box, then we want to process the arrow keys for up
	//and down movement only. We can't process the keys directly here because
	//we can't call LGetSelect() from this callback routine.
	//
	
	if (UAM_DLOG(inDialog).hasList)
	{
		switch(chCode)
		{
			case UAMKey_Up:
			case UAMKey_Down:
			case UAMKey_PageUp:
			case UAMKey_PageDown:
			case UAMKey_Home:
			case UAMKey_End:
				*item = DITEM_ListNavigationKey;
				
				UAM_DLOG(inDialog).lastKeyCode	= chCode;
				UAM_DLOG(inDialog).modifiers	= event->modifiers;
				
				result = true;
				break;
				
			default:
				*item = DITEM_ListMoveToKey;

				UAM_DLOG(inDialog).lastKeyCode	= chCode;
				UAM_DLOG(inDialog).modifiers	= event->modifiers;
				
				GetDateTime(&UAM_DLOG(inDialog).lastKeyTime);
				
				result = true;
				break;
		}
	}
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if ((UAM_DLOG(inDialog).standardDialog.editField + 1) == UAM_DLOG(inDialog).bulletItems[x].editID)
		{
			switch(chCode)
			{
				case UAMKey_PageUp:
				case UAMKey_PageDown:
				case UAMKey_Home:
				case UAMKey_End:
				case UAMKey_Tab:
				case UAMKey_Left:
				case UAMKey_Right:
				case UAMKey_Up:
				case UAMKey_Down:
					//
					//We don't want to process these keys so just break here and continue.
					//
					break;
				
				case UAMKey_FwdDel:
					break;
				
				default:
					hTE = UAM_DLOG(inDialog).standardDialog.textH;
					if (hTE == NULL) {
						break;
					}
										
					if (chCode != UAMKey_BackDel)
					{
						event->message -= chCode;
						event->message += kPasswordBulletText;
					}
					
					HLock((Handle)hTE);
					HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
					
					pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);
					pTE->selStart	= (*hTE)->selStart;
					pTE->selEnd		= (*hTE)->selEnd;
					
					if ((pTE->selStart == pTE->selEnd) && (chCode != UAMKey_BackDel))
					{
						if (pTE->teLength >= UAM_DLOG(inDialog).bulletItems[x].maxLength)
						{
							SysBeep(1);

							HUnlock((Handle)hTE);
							HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
							
							event->what		= nullEvent;
							event->message	= 0;
							
							break;
						}
					}
					
					HUnlock((Handle)hTE);
					HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
					
					TEKey(chCode, UAM_DLOG(inDialog).bulletItems[x].hTE);
					break;
			}
			
			break;
		}
	}
	
	return(result);
}


// ---------------------------------------------------------------------------
//		 UAM_GetBulletBuffer()
// ---------------------------------------------------------------------------

void UAM_GetBulletBuffer(DialogPtr inDialog, short item, StringPtr outBuffer)
{
	short 		x;
	Boolean		found = false;
	TEPtr		pTE;
	
	for (x = 0; x < kMaxBulletItems; x++)
	{
		if (UAM_DLOG(inDialog).bulletItems[x].editID == item)
		{
			found = true;
			break;
		}
	}
	
	if (found)
	{
		HLock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
				
		pTE 			= *(UAM_DLOG(inDialog).bulletItems[x].hTE);
		outBuffer[0] 	= pTE->teLength;
		
		HLock(pTE->hText);
		
		BlockMove(*pTE->hText, &outBuffer[1], pTE->teLength);
		
		HUnlock(pTE->hText);
		HUnlock((Handle)UAM_DLOG(inDialog).bulletItems[x].hTE);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SupportCmdKeys()
// ---------------------------------------------------------------------------

void UAM_SupportCmdKeys(DialogPtr inDialog, Boolean support)
{
	UAM_DLOG(inDialog).supportCmdKeys = support;
}


// ---------------------------------------------------------------------------
//		 UAM_SetCustomFilterProc()
// ---------------------------------------------------------------------------

void UAM_SetCustomFilterProc(DialogPtr inDialog, ModalFilterUPP proc)
{
	if (UAM_DLOG(inDialog).customFilter == NULL)
	{
		UAM_DLOG(inDialog).customFilter = proc;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamkeychain.h ===
// ===========================================================================
//	UAMKeychain.h 				 1999 Microsoft Corp. All rights reserved.
// ===========================================================================

#include "Keychain.h"

#define UAM_KC_DESCRIPTION		"\pMicrosoft Windows Server"

typedef unsigned char Str8[9];

//
//The volume mount info structure must be aligned for 68K
//as the Mac AFP Client as of MacOS 9.0 is still 68K code!
//
#pragma options align=mac68k

typedef struct
{
	SInt16 		length;					/* length of this record */
	VolumeType 	media;					/* type of media, always AppleShareMediaType */
	SInt16 		flags;					/* bits for no messages, no reconnect, etc */
	char 		nbpInterval;			/* NBP interval parameter; 7 is a good choice */
	char 		nbpCount;				/* NBP count parameter; 5 is a good choice */
	SInt16 		uamType;				/* User Authentication Method */
	SInt16 		zoneNameOffset;			/* offset from start of record to zoneName */
	SInt16 		serverNameOffset;		/* offset from start of record to serverName */
	SInt16 		volNameOffset;			/* offset from start of record to volName */
	SInt16 		userNameOffset;			/* offset from start of record to userName */
	SInt16 		userPasswordOffset;		/* offset from start of record to userPassword */
	SInt16 		volPasswordOffset;		/* offset from start of record to volPassword */
	SInt16 		extendedFlags;			/* extended flags word */
	SInt16 		uamNameOffset;			/* offset to a pascal UAM name string */
	SInt16 		alternateAddressOffset; /* offset to Alternate Addresses in tagged format */
	Str32 		zoneName;				/* server's AppleTalk zone name */					
	char 		filler1;				/* to word align volPassword */
	Str32 		serverName;				/* server name */					
	char 		filler2;				/* to word align volPassword */
	Str27 		volName;				/* volume name */					
	Str31 		userName;				/* user name (zero length Pascal string for guest) */
	Str8 		userPassword;			/* user password (zero length Pascal string if no user password) */					
	char 		filler3;				/* to word align volPassword */
	Str8 		volPassword;			/* volume password (zero length Pascal string if no volume password) */					
	char 		filler4;				/* to word align uamNameOffset */
	Str32 		uamName;				/* UAM name */
	char 		filler5;				/* to word align alternateAddress */
	char 		alternateAddress[kVariableLengthArray];	/* AFPAlternateAddress */
}UAM_AFPXVolMountInfo, *PUAM_AFPXVolMountInfo;

#pragma options align=reset

//
//This macro helps us get offsets into the struct above.
//
#define uamx_member_offset(member)	((size_t) &((UAM_AFPXVolMountInfo *) 0)->member)

OSStatus 	UAM_KCDeleteItem(
				StringPtr 	inUserName,
				Str255 		inServerName
);
void 		UAM_KCInitialize(UAMArgs* inUAMArgs);
Boolean 	UAM_KCAvailable(void);
OSStatus	UAM_KCSavePassword(
				StringPtr 	inUserName,
				StringPtr 	inPassword,
				Str255 		inServerName
);
OSStatus 	UAM_KCFindAppleSharePassword(
				StringPtr	inUserName,
				StringPtr	inPassword,
				StringPtr	inServerName,
				KCItemRef	*outItemRef
);
OSStatus 	UAM_BuildAFPXVolMountInfo(
				StringPtr 				inUserName,
				StringPtr 				inPassword,
				Str255 					inServerName,
				const Str32				inUAMString,
				PUAM_AFPXVolMountInfo*	outVolInfo
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamlistbox.c ===
// ===========================================================================
//	UAMListBox.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// List box routines for maintaining a list in a dialog. This unit is required
// for the custom volume list dialog.
//
// ===========================================================================

#include <Lists.h>
#include <stdlib.h>

#include "UAMUtils.h"
#include "UAMListBox.h"

ListHandle	gList;

// ---------------------------------------------------------------------------
//		 UAM_MakeList()
// ---------------------------------------------------------------------------
//	Create a new list in the dialog window.

void UAM_MakeList(DialogPtr inDialog, short inItem, short inFont, short inSize, short inProc, Boolean inHasScroll)
{
	Rect	theListRect;
			
	UAM_DLOG(inDialog).listID 			= inItem;
	UAM_DLOG(inDialog).listRect 		= UAM_GetItemRect(inDialog, inItem);
	UAM_DLOG(inDialog).listFont 		= inFont;
	UAM_DLOG(inDialog).listSize 		= inSize;
	UAM_DLOG(inDialog).listHasScrollBar = inHasScroll;
	
	UAM_DLOG(inDialog).hasList			= true;
	
	//
	//If the list has a scrollbar, leave room for it on the right.
	//
	
	theListRect = UAM_DLOG(inDialog).listRect;
	if (UAM_DLOG(inDialog).listHasScrollBar) {
		theListRect.right -= 15;
	}
	
	SetRect(&UAM_DLOG(inDialog).dataBounds, 0, 0, 1, 0);
	UAM_DLOG(inDialog).cSize.h = theListRect.right - theListRect.left;
	UAM_DLOG(inDialog).cSize.v = 0;
	
	TextFont(UAM_DLOG(inDialog).listFont);
	TextSize(UAM_DLOG(inDialog).listSize);
	
	UAM_DLOG(inDialog).dialogList = LNew(	&theListRect, 
											&UAM_DLOG(inDialog).dataBounds,
											UAM_DLOG(inDialog).cSize,
											inProc,
											inDialog,
											TRUE, FALSE, FALSE,
											UAM_DLOG(inDialog).listHasScrollBar		);
	
	UAM_DLOG(inDialog).cSize.v = -1;

	if (UAM_DLOG(inDialog).dialogList != NULL)
	{
		(**(UAM_DLOG(inDialog).dialogList)).selFlags = lUseSense + lNoExtend;
		
		LSetDrawingMode(TRUE, UAM_DLOG(inDialog).dialogList);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ListUpdate()
// ---------------------------------------------------------------------------
//	Update (redraw) the list box, probably due to an update event.

void UAM_ListUpdate(DialogPtr inDialog)
{
	Rect			theListRect;
		
	TextFont(UAM_DLOG(inDialog).listFont);
	TextSize(UAM_DLOG(inDialog).listSize);
	
	LUpdate(inDialog->visRgn, UAM_DLOG(inDialog).dialogList);
	
	theListRect = UAM_DLOG(inDialog).listRect;
	if (UAM_DLOG(inDialog).listHasScrollBar) {
		theListRect.right -= 15;
	}
			
	InsetRect(&theListRect, -1, -1);
	FrameRect(&theListRect);
}


// ---------------------------------------------------------------------------
//		 UAM_ListMoveToItem()
// ---------------------------------------------------------------------------
//	Move to the first item of this pressed letter/combo.

void UAM_ListMoveToItem(short inCode, unsigned long inLastTime, ListHandle inList)
{
	#pragma unused(inLastTime)

	Cell		theCell 	= {0,0};
	Str32		theKey;
	Str32		theName;
	UAMListData	theData;
	short		theDataLen;
	
	theKey[0]	= 1;
	theKey[1]	= (char)inCode;
	
	//
	//We use UpperString() in this routine for strong compatibility across
	//localized of versions of the UAM.
	//
	
	UpperString(theKey, false);
	
	while(theCell.v < (*inList)->dataBounds.bottom)
	{
		theDataLen = sizeof(UAMListData);
		
		LGetCell((Ptr)&theData, &theDataLen, theCell, inList);
		
		UAM_PStrCopy(theData.volumeName, theName);
		UpperString(theName, false);
		
		if ((theName[1] == theKey[1]) && (theData.isActive))
		{
			UAM_SelectOneCell(theCell, inList);
			LAutoScroll(inList);
			break;
		}
		
		theCell.v++;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ListKeyNavigation()
// ---------------------------------------------------------------------------
//	Navigate the list box using the keyboard.

void UAM_ListKeyNavigation(short inCode, long inModifiers, ListHandle inList)
{
	Cell		theCell	= {0,0};
	UAMListData	theData;
	short		theDataLen;
	short		theRows;
	
	switch(inCode)
	{
		case UAMKey_Up:
			if (LGetSelect(true, &theCell, inList))
			{
				if (theCell.v > 0) {
					theCell.v -= 1;
				}
														
				do
				{
					theDataLen = sizeof(UAMListData);
					
					LGetCell((Ptr)&theData, &theDataLen, theCell, inList);
					
					if (theData.isActive == true) 
					{
						if (inModifiers & shiftKey) {
							LSetSelect(true, theCell, inList);
						}
						else {
							UAM_SelectOneCell(theCell, inList);
						}
					}
					else if (theCell.v > 0) {
						theCell.v -= 1;
					}
					else {
						break;
					}
						
				}while(!theData.isActive);
				
				//
				//Scroll the list to the active cell.
				//
				LAutoScroll(inList);
			}
			break;
			
		case UAMKey_Down:
			if (UAM_GetLastSelectedCell(&theCell, inList))
			{
				if (theCell.v < ((*inList)->dataBounds.bottom - 1)) {
					theCell.v += 1;
				}
				
				do
				{
					theDataLen = sizeof(UAMListData);
					
					LGetCell((Ptr)&theData, &theDataLen, theCell, inList);
					
					if (theData.isActive == true) 
					{
						if (inModifiers & shiftKey) {
							LSetSelect(true, theCell, inList);
						}
						else {
							UAM_SelectOneCell(theCell, inList);
						}
					}
					else if (theCell.v < ((*inList)->dataBounds.bottom - 1)) {
						theCell.v += 1;
					}
					else {
						break;
					}
						
				}while(!theData.isActive);
				
				//
				//Scroll the list to the active cell.
				//
				LAutoScroll(inList);
			}
			break;
			
		case UAMKey_Home:
			LScroll(-16000, -16000, inList);
			break;
		
		case UAMKey_End:
			LScroll(16000, 16000, inList);
			break;
			
		case UAMKey_PageUp:
		case UAMKey_PageDown:
			theRows = (*inList)->visible.bottom - (*inList)->visible.top - 1;
			
			if (inCode == UAMKey_PageUp) {
				theRows = -theRows;
			}
			
			LScroll(0, theRows, inList);
			break;
			
		default:
			break;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SelectOneCell()
// ---------------------------------------------------------------------------
//	Select just one cell in the list.

void UAM_SelectOneCell(Cell inCell, ListHandle inList)
{
	Cell	theCurrCell = {0,0};
	
	while(LGetSelect(true, &theCurrCell, inList))
	{
		if (*(long *)&theCurrCell == *(long *)&inCell) {
			LNextCell(true, true, &theCurrCell, inList);
		}
		else {
			LSetSelect(false, theCurrCell, inList);
		}
	}
	
	LSetSelect(true, inCell, inList);
}


// ---------------------------------------------------------------------------
//		 UAM_GetLastSelectedCell()
// ---------------------------------------------------------------------------
//	Get the last selected cell in the list.

Boolean UAM_GetLastSelectedCell(Cell *outCell, ListHandle inList)
{
	Cell	tCurrCell 		= {0,0};
	Boolean	tHasSelection	= LGetSelect(true, &tCurrCell, inList);
	
	if (tHasSelection)
	{
		do
		{
			*outCell = tCurrCell;
		}while(LNextCell(true, true, &tCurrCell, inList) && LGetSelect(true, &tCurrCell, inList));
	}
	
	return(tHasSelection);
}


// ---------------------------------------------------------------------------
//		 UAM_SortSwapProc()
// ---------------------------------------------------------------------------
//	Sorting swap routine.

void UAM_SortSwapProc(size_t inOne, size_t inTwo)
{
	Cell		theCell1, theCell2;
	UAMListData	theData1, theData2;
	short		theDataLen1 = sizeof(UAMListData);
	short		theDataLen2 = sizeof(UAMListData);

	theCell1.h		= 0;
	theCell1.v		= inOne;
	theCell2.h		= 0;
	theCell2.v		= inTwo;
	
	LGetCell((Ptr)&theData1, &theDataLen1, theCell1, gList);
	LGetCell((Ptr)&theData2, &theDataLen2, theCell2, gList);

	if ((theDataLen1 != 0) && (theDataLen2 != 0))
	{
		LSetCell((Ptr)&theData2, theDataLen2, theCell1, gList);
		LSetCell((Ptr)&theData1, theDataLen1, theCell2, gList);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_SortCompProc()
// ---------------------------------------------------------------------------
//	Sorting compare routine. We need a custom compare routine since we only
//	want to compare the volume names, not the other data in the struct.

int UAM_SortCompProc(size_t inOne, size_t inTwo)
{
	Cell		theCell1, theCell2;
	UAMListData	theData1, theData2;
	short		theDataLen = sizeof(UAMListData);
	
	theCell1.h		= 0;
	theCell1.v		= inOne;
	theCell2.h		= 0;
	theCell2.v		= inTwo;
	
	LGetCell((Ptr)&theData1, &theDataLen, theCell1, gList);
	LGetCell((Ptr)&theData2, &theDataLen, theCell2, gList);
		
	return(CompareString(theData1.volumeName,theData2.volumeName, NULL));
}


// ---------------------------------------------------------------------------
//		 UAM_SortList()
// ---------------------------------------------------------------------------
//	Sorts the volume list in alphabetical order.

void UAM_SortList(DialogPtr inDialog)
{
	gList = UAM_DLOG(inDialog).dialogList;
	
/*
	_qsort(	(*UAM_DLOG(inDialog).dialogList)->dataBounds.bottom,
			(__cmp1_func)UAM_SortCompProc,
			(__swap1_func)UAM_SortSwapProc							); */
}


// ---------------------------------------------------------------------------
//		 UAM_AddListData()
// ---------------------------------------------------------------------------
//	Add data to the list by adding a new row and inserting the data ptr into
//	the list's data field.

void UAM_AddListData(DialogPtr inDialog, Ptr inData, short inDataSize)
{
	UAM_DLOG(inDialog).cSize.h = 0;
	UAM_DLOG(inDialog).cSize.v = LAddRow(1, 32767, UAM_DLOG(inDialog).dialogList);
	
	LSetCell(inData, inDataSize, UAM_DLOG(inDialog).cSize, UAM_DLOG(inDialog).dialogList);
	LDraw(UAM_DLOG(inDialog).cSize, UAM_DLOG(inDialog).dialogList);
}


// ---------------------------------------------------------------------------
//		 UAM_GetListData()
// ---------------------------------------------------------------------------
//	Get the data associated with a cell in the list box.

Ptr	UAM_GetListData(DialogPtr inDialog, Cell inCell, short *inDataSize)
{
	Ptr theData = NULL;
		
	theData = NewPtrClear(*inDataSize);
	
	if (theData != NULL)
	{
		//
		//Get the data from the cell data handle.
		//
		
		LGetCell(theData, inDataSize, inCell, UAM_DLOG(inDialog).dialogList);
		
		//
		//Now set our new pointer size to the actual size of the data returned.
		//
		
		SetPtrSize(theData, *inDataSize);
	}
	
	return(theData);
}


// ---------------------------------------------------------------------------
//		 UAM_CalculateBoxRect()
// ---------------------------------------------------------------------------
//	Calculate the rectangle for the check box that lives in this cell. The
//	defines below much match those in the UAM LDEF.

#define kBoxWidth	11
#define kBoxHeight	11

void UAM_CalculateBoxRect(Rect *inRect)
{
	SetRect(	inRect,
				inRect->right - (kBoxWidth + 5),
				inRect->top + 3,
				inRect->right - 5,
				inRect->top + 3 + kBoxWidth			);
}


// ---------------------------------------------------------------------------
//		 UAM_GetCellCheckBox()
// ---------------------------------------------------------------------------
//	Return the rect of the checkbox for a given cell.

void UAM_GetCellCheckBox(DialogPtr inDialog, Cell inCell, Rect *outRect)
{	
	LRect(outRect, inCell, UAM_DLOG(inDialog).dialogList);
	UAM_CalculateBoxRect(outRect);
}


// ---------------------------------------------------------------------------
//		 UAM_CheckBoxClick()
// ---------------------------------------------------------------------------
//	Check for a user click inside a checkbox in our list box.

void UAM_CheckBoxClick(DialogPtr inDialog, Point inMouseLoc)
{
	Rect			theCellRect;
	Cell			theCell;
	short			theDataOffset;
	short			theDataLen;
	UAMListDataP	theData;
	ListHandle		theListH		= UAM_DLOG(inDialog).dialogList;
	Point			theClickLoc		= (*theListH)->clikLoc;
	Point			theRealLoc		= (*theListH)->mouseLoc;
	
	//
	//Obtain the rectangle of the cell that was just clicked in
	//and get the rect of the checkbox.
	//
	
	theCell = UAM_GetLastListClick(inDialog);
	UAM_GetCellCheckBox(inDialog, theCell, &theCellRect);
	
	//
	//Now determine if the click was actually in the checkbox or in another
	//part of the cell that we don't care about.
	//
	
	if (	(PtInRect(theClickLoc, &theCellRect)) 	&& 
			(PtInRect(inMouseLoc, &theCellRect)) 	&&
			(PtInRect(theRealLoc, &theCellRect))	)
	{
		//
		//The mouse click was in the checkbox of one of our cells, so
		//now we need to get the data associated with that cell.
		//
		
		LGetCellDataLocation(&theDataOffset, &theDataLen, theCell, theListH);
		
		//
		//If we get data, then determine what the current state of the checkbox
		//should be and then invalidate the checkbox rect to force a redraw.
		//
		
		if ((theDataOffset != -1) && (theDataLen != -1))
		{
			theData = (UAMListDataP)((*(*theListH)->cells) + theDataOffset);
		
			theData->isChecked = (theData->isChecked) ? FALSE : TRUE;
			InvalRect(&theCellRect);
		}
		
		//
		//We don't want double clicks in the checkbox to count
		//as a 'real' double click.
		//
		
		UAM_DLOG(inDialog).doubleClick = false;
	}
}


// ---------------------------------------------------------------------------
//		 UAM_ListDialogFilter()
// ---------------------------------------------------------------------------
//	This is called by UAM_DialogFilter(), it processes user action to our
//	dialog list box.

Boolean	UAM_ListDialogFilter(DialogPtr inDialog, EventRecord *event, short *itemHit)
{
	Point			theMouseLoc;
	Boolean			theResult	= false;
	Cell			theCell		= {0,0};
						
	theMouseLoc = event->where;
	GlobalToLocal(&theMouseLoc);

	if (PtInRect(theMouseLoc, &UAM_DLOG(inDialog).listRect))
	{
		//
		//You must always set the proper font and size!
		//
		
		TextFont(UAM_DLOG(inDialog).listFont);
		TextSize(UAM_DLOG(inDialog).listSize);
		
		//
		//Have the ListManager handle the nitty gritty of user action and
		//save the cell that the user actually clicked in.
		//
		
		UAM_DLOG(inDialog).doubleClick = LClick(theMouseLoc, event->modifiers, UAM_DLOG(inDialog).dialogList);
		theCell = LLastClick(UAM_DLOG(inDialog).dialogList);
		
		UAM_DLOG(inDialog).lastCell.h = theCell.h;
		UAM_DLOG(inDialog).lastCell.v = theCell.v;
		
		//
		//Call the click routine to handle clicks in the checkboxes.
		//
		
		UAM_CheckBoxClick(inDialog, theMouseLoc);
		
		//
		//Signal that the list box was indeed the item the user hit.
		//
		
		*itemHit 	= UAM_DLOG(inDialog).listID;
		theResult 	= true;
	}
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 UAM_ListGotDoubleClick()
// ---------------------------------------------------------------------------
//	Returns TRUE if the user doubled clicked in the list box.

Boolean	UAM_ListGotDoubleClick(DialogPtr inDialog)
{
	return(UAM_DLOG(inDialog).doubleClick);
}


// ---------------------------------------------------------------------------
//		 UAM_GetLastListClick()
// ---------------------------------------------------------------------------
//	Returns the cell that the user last clicked in.

Cell UAM_GetLastListClick(DialogPtr inDialog)
{
	return(UAM_DLOG(inDialog).lastCell);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdlogutils.h ===
// ===========================================================================
//	UAMDLOGUtils.h 			 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#define	textMargin			2

#define	Abs(x)				((x) < 0 ? -(x) : (x))

#define	HiShort(longNum)	(short)(((longNum) >> 16) & 0xFFFF)
#define	LoShort(longNum)	(short)((longNum) & 0xFFFF)

#define	Max(x, y)			((x) > (y) ? (x) : (y))
#define	Min(x, y)			((x) < (y) ? (x) : (y))

#define UAM_DLOG(d)			(*((UAMDialogRecP)d))

#define kMaxGatedItems		3
#define kMaxBulletItems		3

#define kPasswordBulletText	'*'

//
//These item defines are needed because we can't navigate a list
//box using arrow keys because we can't call LGetSelect from a
//completion or callback routine.
//

#define DITEM_ListNavigationKey	20000
#define DITEM_ListMoveToKey		20001


#define UAMKey_Home		0x01
#define UAMKey_Enter	0x03
#define UAMKey_End		0x04
#define UAMKey_PageUp	0x0B
#define UAMKey_PageDown	0x0C
#define UAMKey_BackDel	0x08
#define UAMKey_Tab		0x09
#define UAMKey_Escape	0x1b
#define UAMKey_Left		0x1c
#define UAMKey_Right	0x1d
#define UAMKey_Up		0x1e
#define UAMKey_Down		0x1f
#define UAMKey_Return	0x0d
#define UAMKey_Space	0x20
#define UAMKey_FwdDel	0x7f
#define UAMKey_Period	'.'

//
//Struct needed for maintaining gated dialog items.
//

typedef struct {
	short	controlID;
	short	textID;
	short	state;
}GatedItems;

//
//Struct needed to maintain bullet edit fields.
//

typedef struct {
	short		editID;
	short		maxLength;
	TEHandle	hTE;
}BulletEditRec;

//
//This is the main struct. It is made part of the actual dialog record and holds
//key private information for us to maintain a dialog which is capable of displaying
//several custom items such as lists, scrolling text, bullet edit fields, etc.
//

typedef struct {
	//
	//This is the standard dialog recrod, it must be first in our rec.
	//
	
	DialogRecord		standardDialog;
	
	//
	//The following is used for scrolling text fields within a dialog.
	//
	
	Boolean				hasScrollBar;
	TEHandle			dialogTE;
	Rect				dialogTERect;
	ControlHandle		scrollBar;
	short				deltaV;
	short				vOffset;
	ControlActionUPP	scrollActionProc;
	
	//
	//These are private items needed to maintain a list box in a dialog.
	//
	
	Boolean				hasList;
	short				listID;
	Boolean				doubleClick;
	ListHandle			dialogList;
	Rect				listRect;
	Rect				dataBounds;
	Point				cSize;
	Cell				lastCell;
	short				listFont;
	short				listSize;
	Boolean				listHasScrollBar;
	short				lastKeyCode;
	unsigned long		lastKeyTime;
	long				modifiers;
	
	//
	//Fields for various other tasks with our dialog.
	//
	
	Boolean				supportCmdKeys;					//Support edit command keys?
	ModalFilterUPP		customFilter;					//Custom filter provided by user
	GatedItems			gateItems[kMaxGatedItems];		//All gated controls
	BulletEditRec		bulletItems[kMaxBulletItems];	//All bullet fields
} UAMDialogRec, *UAMDialogRecP;


Rect				UAM_GetScreenBounds		( void );
void				UAM_DisposeDialog		( DialogPtr );
ControlHandle 		UAM_GetCHandle			( DialogPtr, short );
Rect				UAM_GetItemRect			( DialogPtr, short );
void				UAM_ToggleControl		( DialogPtr, short );
void 				UAM_GetText				( DialogPtr, short, Str255 * );
void 				UAM_SetText				( DialogPtr, short, Str255 );
void 				UAM_HiliteItem			( DialogPtr, short, short );
Boolean				UAM_IsActive			( DialogPtr, short );
short				UAM_GetCValue			( DialogPtr, short );
void				UAM_SetCValue			( DialogPtr, short, short );
void				UAM_PositionDialog		( ResType, short );
short 				UAM_GetItemType			( DialogPtr, short );
DialogPtr			UAM_NewDialog			( short, Boolean );
void				UAM_Update				( DialogPtr );
pascal Boolean 		UAM_DialogFilter		( DialogPtr, EventRecord *, short * );
void				UAM_CheckGatedControls	( DialogPtr );
pascal void			UAM_FrameItem			( DialogPtr, short );
Rect				UAM_GetDRect			( short );
void				UAM_SetUpUserItem		( DialogPtr, short, UserItemUPP, short );
void				UAM_GateControl			( DialogPtr, short, short );
void				UAM_StopGate			( DialogPtr, short );
void				UAM_SetBulletItem		( DialogPtr, short, short );
void				UAM_SetBulletText		( DialogPtr , short , Str255 );
void 				UAM_ClearBulletText		(DialogPtr inDialog, short item);
Boolean				UAM_ProcessKeydown		( DialogPtr, EventRecord *, short * );
void				UAM_GetBulletBuffer		( DialogPtr, short, StringPtr );
void				UAM_SupportCmdKeys		( DialogPtr, Boolean );
void				UAM_SetCustomFilterProc	( DialogPtr, ModalFilterUPP );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdsnetwork.h ===
// ===========================================================================
//	UAMNetwork.h 				 1998 Microsoft Corp. All rights reserved.
// ===========================================================================

#include "ClientUAM.h"

#define afpChangePwd		36

#define StringPush_(s, p)	do {										\
								UAM_PStrCopy(s, (StringPtr)p);			\
								p += s[0] + 1;							\
							}while(false)
							
#define DataPush_(d, s, p)	do {										\
								memcpy(p, d, s);						\
								p += s;									\
							}while(false)

OSStatus 	UAM_CloseSession(UAMArgs *inUAMArgs);
OSStatus 	UAM_OpenSession(	UAMArgs 		*inUAMArgs,
								UAMMessage		*inMessage,
								unsigned char	*inCmdBuffer,
								UInt32			inCmdBufferSize,
								unsigned char	*inReplyBuffer,
								UInt32			inReplyBufferSize	);

OSStatus 	UAM_DSLoginGuest(UAMArgs *inUAMArgs);
OSStatus 	UAM_DSLoginMSUAM(UAMArgs *inUAMArgs);
OSStatus 	UAM_DSMSUAMLoginCont(UAMArgs *inUAMArgs);
OSStatus 	UAM_ChangePassword(UAMArgs *inUAMArgs, StringPtr inNewPwd);
OSStatus 	UAM_ChangePasswordV2(UAMArgs *inUAMArgs, StringPtr inNewPwd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamlistbox.h ===
// ===========================================================================
//	UAMListBox.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include <stdlib.h>
#include "UAMDLOGUtils.h"

//
//Our custom UAM LDEF resource ID
//

#define UAM_LDEF_ID		1000


//
//Data structure for storage in the list data field. This structure
//should only be used for our UAM list.
//

typedef struct
{
	Str32		volumeName;
	Boolean		isChecked;
	Boolean		isActive;
}UAMListData, *UAMListDataP, **UAMListDataH;


void			UAM_MakeList			( DialogPtr, short, short, short, short, Boolean );
void			UAM_ListUpdate			( DialogPtr );
void 			UAM_ListKeyNavigation	( short , long , ListHandle );
void	 		UAM_ListMoveToItem		( short , unsigned long , ListHandle );
void 			UAM_SelectOneCell		( Cell , ListHandle );
Boolean 		UAM_GetLastSelectedCell	( Cell *, ListHandle );
void			UAM_SortSwapProc		( size_t, size_t );
int 			UAM_SortCompProc		( size_t, size_t );
void 			UAM_SortList			( DialogPtr );
void 			UAM_AddListData			( DialogPtr, Ptr, short );
Ptr				UAM_GetListData			( DialogPtr, Cell, short * );
void			UAM_CalculateBoxRect	( Rect * );
void 			UAM_GetCellCheckBox		( DialogPtr, Cell, Rect * );
void 			UAM_CheckBoxClick		( DialogPtr, Point );
Boolean			UAM_ListDialogFilter	( DialogPtr, EventRecord *, short * );
Boolean			UAM_ListGotDoubleClick	( DialogPtr );
Cell			UAM_GetLastListClick	( DialogPtr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamkeychain.c ===
// ===========================================================================
//	UAMKeychain.c 			 1999-2000 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Keychain support routines for the MS UAM.
//
// ===========================================================================

#include "UAMDebug.h"
#include "UAMUtils.h"
#include "UAMMain.h"
#include "UAMDialogs.h"
#include "UAMNetwork.h"
#include "UAMKeychain.h"

Boolean				gKeychainAvailable	= false;
Boolean				gAllowedToSavePswd	= false;

extern Str32 		gServerName;
extern Str32		gUserName;
extern Str32		gZoneName;
extern OTAddress*	gServerAddress;
extern long			gSupportedUAMs;


// ---------------------------------------------------------------------------
//		 UAM_KCInitialize()
// ---------------------------------------------------------------------------
// See if the keychain is supported on this machine as well as perform some
// initialization for our keychain support.

void UAM_KCInitialize(UAMArgs* inUAMArgs)
{
	UInt32	theVersion;
	SInt32	theResponse;
	OSErr	theError;
	
	gKeychainAvailable	= false;
	gAllowedToSavePswd	= false;
	
	//
	//Do a check here to make sure that we're running on a
	//system version that we support.
	//
	
	theError = Gestalt(gestaltSystemVersion, &theResponse);
	if (theError != noErr)
	{
		//
		//If there's an error calling Gestalt(), we're in real trouble.
		//
		return;
	}
	
	if (LoWord(theResponse) < 0x0900)
	{
		//
		//We don't support any OS older than MacOS 9.0. This is
		//because the old Keychain (v1.01) on older systems is
		//not stable enough and crashes often.
		//
		return;
	}
		
	//
	//Let's see if the Apple KeyChain manager is available and
	//remember it.
	//
	gKeychainAvailable = KeychainManagerAvailable();
	
	if (gKeychainAvailable)
	{
		//
		//Get the version of the keychain manager. OS9 uses
		//v2.0 and is the first shipping version. However, v1.0
		//was available to pre-OS9 macs.
		//
		KCGetKeychainManagerVersion(&theVersion);
		
		//
		//The version is kept in the hi-word of the return.
		//
		if (HiWord(theVersion) >= 0x0200)
		{
			//
			//Just in case someone else turned it off, we make sure
			//interaction is enabled. This call is only supported in
			//Keychain 2.0 or later.
			//
			KCSetInteractionAllowed(true);
		}
	}

	//
	//BIT_2 of the srvr flags tells us if the user is allowed
	//to save their passwords in the keychain.
	//
	gAllowedToSavePswd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & BIT_2) == 0);
}


// ---------------------------------------------------------------------------
//		 UAM_KCAvailable()
// ---------------------------------------------------------------------------
// Returns TRUE if the keychain is available on this machine as well as if
// the AFP server allows clients to save passwords on the workstation.

Boolean UAM_KCAvailable(void)
{
	return(((gKeychainAvailable) && (gAllowedToSavePswd)) ? true : false);
}


// ---------------------------------------------------------------------------
//		 UAM_KCDeleteItem()
// ---------------------------------------------------------------------------
// Deletes a keychain item that pertains to this username & server.

OSStatus UAM_KCDeleteItem(
			StringPtr 	inUserName,
			Str255 		inServerName
)
{
	OSStatus	theStatus;
	KCItemRef	theItem		= NULL;
	
	theStatus = UAM_KCFindAppleSharePassword(
					inUserName,
					NULL,
					inServerName,
					&theItem
	);
	
	if (theStatus != noErr)
	{
		//
		//We couldn't find an existing keychain item matching
		//the criteria. Bail.
		//
		return(theStatus);
	}
	
	Assert_(theItem != NULL);
	
	if (theItem != NULL)
	{
		//
		//We found the item, remove it from the keychain.
		//
		theStatus = KCDeleteItem(theItem);
		
		//
		//The keychain manager allocated this memory, we need to
		//free it. For free builds, we don't do anything if this
		//fails since there's nothing we or the user can do about it.
		//		
		if (KCReleaseItem(&theItem) != noErr)
		{
			DbgPrint_((DBGBUFF, "KCReleaseItem() failed"));
		}
	}
	
	return(theStatus);
}


// ---------------------------------------------------------------------------
//		 UAM_KCSavePassword()
// ---------------------------------------------------------------------------

OSStatus UAM_KCSavePassword(
			StringPtr 	inUserName,
			StringPtr 	inPassword,
			Str255 		inServerName
)
{
	OSStatus 				theStatus;
	OSType					theTypeData;
	KCAttribute				theAttribute;
	KCItemRef				theItem		= NULL;
	Boolean					theIconFlag = true;
	PUAM_AFPXVolMountInfo	theUAMInfo	= NULL;
	
	Assert_(UAM_KCAvailable() == true);
	
	//
	//Search for an item in the keychain that already matches
	//what we are about to add. Note we have to do this because
	//of a bug in the keychain manager that prevents it from
	//doing it for us.
	//
	theStatus = UAM_KCFindAppleSharePassword(
					inUserName,
					NULL,
					inServerName,
					NULL
	);
	
	if (theStatus == noErr)
	{
		//
		//If we get here, then that means there is already
		//an item in the keychain for this server and account.
		//
		return(errKCDuplicateItem);
	}
	
	//
	//Call our function that builds the AFPXVolMountInfo
	//structure that we pass to the keychain routine.
	//
	theStatus = UAM_BuildAFPXVolMountInfo(
					inUserName,
					inPassword,
					inServerName,
					(gSupportedUAMs & kMSUAM_V2_Supported) ? 
					PSTR_EncryptedLogin2_0 : PSTR_EncryptedLogin1_0,
					&theUAMInfo
	);
	
	if (theStatus != noErr)
	{
		//
		//If we failed here, it's bad news. This means we
		//don't have enough memory to allocate a small
		//buffer.
		//
		return(theStatus);
	}
		
	//
	//Have the keychain store our key information for this
	//server.
	//
	theStatus = KCAddAppleSharePassword(
					NULL,
					(PSTR_LENGTH(gZoneName)) ? gZoneName : NULL,
					inServerName,
					NULL,
					inUserName,
					sizeof(UAM_AFPXVolMountInfo),
					theUAMInfo,
					&theItem
	);
	
	if (theStatus != noErr)
	{
		//
		//Check for cancel action by the user and report error.
		//
		if (theStatus != userCanceledErr)
		{
			DbgPrint_((DBGBUFF, "KCAddAppleSharePassword() failed (%d);g", theStatus));
		}
	}
	else
	{
		do
		{
			//
			//Set the title of this keychain item so folks know
			//what it's for.
			//
			theAttribute.tag	= kDescriptionKCItemAttr;
			theAttribute.length	= PSTR_LENGTH(UAM_KC_DESCRIPTION);
			theAttribute.data	= (void*)&UAM_KC_DESCRIPTION[1];
			
			theStatus = KCSetAttribute(theItem, &theAttribute);	
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kLabelKCItemAttr) failed (%d);g", theStatus));
				break;
			}

			//
			//Tell the keychain to use our MS UAM icon when displaying
			//the keys to the user.
			//
			
			//
			//Set the creator of the MS UAM.
			//
			theTypeData			= UAM_CREATOR;
			
			theAttribute.tag	= kCreatorKCItemAttr;
			theAttribute.length	= sizeof(OSType);
			theAttribute.data	= &theTypeData;
			
			theStatus = KCSetAttribute(theItem, &theAttribute);	
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kCreatorKCItemAttr) failed (%d);g", theStatus));
				break;
			}
			
			//
			//Set the type to our code type (uams)
			//
			theTypeData			= UAM_TYPE;
			
			theAttribute.tag	= kTypeKCItemAttr;
			theAttribute.length	= sizeof(OSType);
			theAttribute.data	= &theTypeData;
			
			theStatus = KCSetAttribute(theItem, &theAttribute);
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kTypeKCItemAttr) failed (%d);g", theStatus));
				break;
			}
			
			//
			//Lastly, tell the keychain manager we have a custom icon.
			//
			theAttribute.tag	= kCustomIconKCItemAttr;
			theAttribute.length	= sizeof(Boolean);
			theAttribute.data	= &theIconFlag;
			
			theStatus = KCSetAttribute(theItem, &theAttribute);
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCSetAttribute(kCustomIconKCItemAttr) failed (%d);g", theStatus));
				break;
			}
		}while(false);
		
		//
		//Only do the update if everthing above passed. Otherwise
		//we'll loose the error code. What to do, what to do...
		//
		if (theStatus == noErr)
		{
			//
			//After setting the attributes on the item, we need to tell
			//the keychain to save our changes.
			//
			theStatus = KCUpdateItem(theItem);
			
			if (theStatus != noErr)
			{
				DbgPrint_((DBGBUFF, "KCUpdateItem() failed (%d);g", theStatus));
			}
		}
		
		//
		//The keychain manager allocated this memory, we need to
		//free it. For free builds, we don't do anything if this
		//fails since there's nothing we or the user can do about it.
		//		
		if (KCReleaseItem(&theItem) != noErr)
		{
			DbgPrint_((DBGBUFF, "KCReleaseItem() failed"));
		}
	}
	
	//
	//Free up our mount volume info structure.
	//
	if (theUAMInfo != NULL)
	{
		DisposePtr((Ptr)theUAMInfo);
	}
	
	return(theStatus);
}


// ---------------------------------------------------------------------------
//		 UAM_KCFindAppleSharePassword()
// ---------------------------------------------------------------------------
// Look for a password associated with this server and account in the
// keychain.

OSStatus UAM_KCFindAppleSharePassword(
			StringPtr	inUserName,
			StringPtr	inPassword,
			StringPtr	inServerName,
			KCItemRef*	outItemRef
)
{
	OSStatus				theStatus		= noErr;
	UInt32					theActualLen 	= 0;
	UInt32					theBuffSize		= sizeof(UAM_AFPXVolMountInfo);
	PUAM_AFPXVolMountInfo	theUamInfo		= NULL;
	
	Assert_(UAM_KCAvailable() == true);
	
	do
	{
		theUamInfo = (PUAM_AFPXVolMountInfo)NewPtrClear(theBuffSize);
		
		if (theUamInfo == NULL)
		{
			theStatus = memFullErr;
			break;
		}
		
		theStatus = KCFindAppleSharePassword(
						NULL,
						NULL,
						inServerName,
						NULL,
						inUserName,
						theBuffSize,
						theUamInfo,
						&theActualLen,
						outItemRef
		);
		
		//
		//If the buffer we supplied is too small, then reallocate the
		//buffer according to what is actually needed. NOTE: We will
		//only need to reallocate when looking at keychains that we
		//did not create ourselves.
		//
		
		if (theStatus == errKCBufferTooSmall)
		{
			DisposePtr((Ptr)theUamInfo);
			
			theUamInfo 	= NULL;
			theBuffSize = theActualLen;
			
			DbgPrint_((DBGBUFF, "Reallocating for %d bytes", theActualLen));
			continue;
		}
		
		break;
				
	}while(TRUE);
		
	if (theStatus == noErr)
	{
		//
		//Initialize expecting failure. For lack of anything
		//better we return param error.
		//
		theStatus = paramErr;
		
		//
		//First make sure we have a proper mount structure.
		//
		if ( (theUamInfo->media == AppleShareMediaType)	&&
			 (theUamInfo->userPasswordOffset != 0)		)
		{
			//
			//Copy the password into a temp buffer and make sure it's
			//not zero length. But, only if inPassword is not null.
			//
			if (inPassword != NULL)
			{
				UAM_PStrCopy(
					(StringPtr)(((UInt32)theUamInfo) + theUamInfo->userPasswordOffset),
					inPassword
				);
			}
			
			theStatus = noErr;
		}
	}
	else if (theStatus != errKCItemNotFound)
	{
		//
		//For debugging only, we print out the error code.
		//
		DbgPrint_((DBGBUFF, "KCFindAppleSharePassword() failed (%d)", theStatus));
	}
	
	//
	//We don't need this buffer anymore, free it up.
	//
	if (theUamInfo != NULL)
	{
		DisposePtr((Ptr)theUamInfo);
	}
	
	return(theStatus);
}


// ---------------------------------------------------------------------------
//		 UAM_BuildAFPXVolMountInfo()
// ---------------------------------------------------------------------------
// Builds the AFPXVolMountInfo structure that we need to send to the keychain.

OSStatus UAM_BuildAFPXVolMountInfo(
			StringPtr 				inUserName,
			StringPtr 				inPassword,
			Str255 					inServerName,
			const Str32				inUAMString,
			PUAM_AFPXVolMountInfo*	outVolInfo
)
{
	PUAM_AFPXVolMountInfo	uamInfo		= NULL;
	Size					uamInfoSize	= 0;
	
	*outVolInfo = NULL;
	uamInfoSize = sizeof(UAM_AFPXVolMountInfo);
	
	uamInfo = (PUAM_AFPXVolMountInfo)NewPtrClear(uamInfoSize);
	
	if (uamInfo != NULL)
	{
		uamInfo->length			= uamInfoSize;
		uamInfo->media			= AppleShareMediaType;
		uamInfo->flags			= 0;
		
		//
		//We're not going to pass any alternate address info. We'll
		//let the AS Client do that for us.
		//
		uamInfo->extendedFlags 			= 0;
		uamInfo->alternateAddressOffset	= 0;
		
		//
		//NBP and UAM Type stuff. Note we use our unique UAM indetifier
		//for the uam type.
		//
		uamInfo->nbpInterval	= 10;
		uamInfo->nbpCount		= 10;
		uamInfo->uamType		= UAM_TYPE_CODE;
		
		//
		//Now setup all the offsets for the parameters. Yuck!
		//
		
		//
		//We don't always get a zone name from the client, we get
		//nil if we're using IP.
		//
		if (PSTR_LENGTH(gZoneName) > 0)
		{
			uamInfo->zoneNameOffset	= uamx_member_offset(zoneName);
			UAM_PStrCopy(gZoneName, uamInfo->zoneName);
		}
		else
		{
			uamInfo->zoneNameOffset	= 0;
		}
		
		uamInfo->volNameOffset		= 0;
		uamInfo->serverNameOffset	= uamx_member_offset(serverName);
		uamInfo->userNameOffset		= uamx_member_offset(userName);
		uamInfo->userPasswordOffset	= uamx_member_offset(userPassword);
		uamInfo->uamNameOffset		= uamx_member_offset(uamNameOffset);
		
		//
		//Now actually copy the data.
		//
		UAM_PStrCopy(inServerName, uamInfo->serverName);
		UAM_PStrCopy(inUserName, uamInfo->userName);
		UAM_PStrCopy(inPassword, uamInfo->userPassword);
		UAM_PStrCopy((StringPtr)inUAMString, (StringPtr)uamInfo->uamName);
	}
	else
	{
		DbgPrint_((DBGBUFF, "Failed to allocated AFPX buffer! (%d)", MemError()));
		
		//
		//Couldn't allocate memory for structure.
		//
		return(memFullErr);
	}
	
	*outVolInfo = uamInfo;
	
	return(noErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamdsnetwork.c ===
// ===========================================================================
//	UAMDSNetwork.c 				 1998 Microsoft Corp. All rights reserved.
// ===========================================================================
// DS Networking functions for use by Microsoft User Authentication Method.
//
// ===========================================================================

#include <Errors.h>
#include <AppleTalk.h>
#include <String.h>

#include "USRPWST3.h"
#include "encrypt.h"
#include "UAMDebug.h"
#include "UAMMain.h"
#include "UAMNetwork.h"
#include "UAMDSNetwork.h"
#include "UAMUtils.h"
#include "UAMDialogs.h"

unsigned char	gCmdBuffer[kMaxAFPCommand];
unsigned char	gReplyBuffer[kMaxAFPCommand];

extern Str32 				gAFPVersion;
extern MSUAMLoginReplyBlock	gMSUAMReply;
extern OTAddress			*gServerAddress;
extern long					gSupportedUAMs;
extern UInt32				gExpirationTime;

// ---------------------------------------------------------------------------
//		 UAM_CloseSession()
// ---------------------------------------------------------------------------
//	Close a session on the AFP server.

OSStatus UAM_CloseSession(UAMArgs *inUAMArgs)
{
	OSStatus theError;
	
	#if GENERATING68K
	
	theError = inUAMArgs->callbacks->CloseSessionUPP(inUAMArgs->sessionRefNum);
	
	#else
	
	theError = CallUniversalProc(
						inUAMArgs->callbacks->CloseSessionUPP,
						kCloseSessionProcInfo,
						inUAMArgs->sessionRefNum	);
	#endif
	
	return(theError);		
}

// ---------------------------------------------------------------------------
//		 UAM_OpenSession()
// ---------------------------------------------------------------------------
//	Open a session on the AFP server.

OSStatus UAM_OpenSession(	UAMArgs 		*inUAMArgs,
							UAMMessage		*inMessage,
							unsigned char	*inCmdBuffer,
							UInt32			inCmdBufferSize,
							unsigned char	*inReplyBuffer,
							UInt32			inReplyBufferSize	)
{
	OSStatus theError;
	
	Assert_(inUAMArgs		!= NULL);
	Assert_(inMessage		!= NULL);
	Assert_(inCmdBuffer		!= NULL);
	Assert_(gServerAddress	!= NULL);
	
	//
	//Note that inReplyBuffer can be null.
	//
	
	inMessage->commandCode		= kOpenSession;
	inMessage->cmdBuffer		= inCmdBuffer;
	inMessage->cmdBufferSize	= inCmdBufferSize;
	inMessage->replyBuffer		= inReplyBuffer;
	inMessage->replyBufferSize	= inReplyBufferSize;
	inMessage->completion		= NULL;
	inMessage->contextPtr		= NULL;
	
	#if GENERATING68K
	theError = inUAMArgs->callbacks->OpenSessionUPP(
										gServerAddress,
										NULL,
										inMessage		);
	#else
	theError = CallUniversalProc(	inUAMArgs->callbacks->OpenSessionUPP,
									kOpenSessionProcInfo,
									gServerAddress,
									NULL,
									inMessage			);
	#endif
												
	//
	//Even if theError == noErr, the parameter block's result
	//param still might hold an error code!
	//

	return((theError == noErr) ? inMessage->result : theError);
}


// ---------------------------------------------------------------------------
//		 UAM_DSLoginGuest()
// ---------------------------------------------------------------------------
//	Log into an AFP server as a guest.

OSStatus UAM_DSLoginGuest(UAMArgs *inUAMArgs)
{
	Ptr				theCmdPtr;
	UInt32			theCmdSize;
	OSStatus		theError;
	UAMMessage		theMessage;
	
	Assert_(inUAMArgs != NULL);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
	
	theCmdPtr = (Ptr)&gCmdBuffer[0];
	
	*theCmdPtr	= afpLogin;
	theCmdPtr	+= sizeof(Byte);
	
	StringPush_(gAFPVersion, (StringPtr)theCmdPtr);
	StringPush_(PSTR_GuestLogin, (StringPtr)theCmdPtr);
		
	theCmdSize = theCmdPtr - ((Ptr)&gCmdBuffer);
	
	theError = UAM_OpenSession(	inUAMArgs,
								&theMessage,
								gCmdBuffer,
								theCmdSize,
								NULL,
								0				);
								
	if (theError == noErr) {
		inUAMArgs->sessionRefNum = theMessage.sessionRefNum;
	}
	
	return(theMessage.result);
}


// ---------------------------------------------------------------------------
//		 UAM_DSLoginMSUAM()
// ---------------------------------------------------------------------------
//	Log into an AFP server using the .AFPTranslator (through the UAM).

OSStatus UAM_DSLoginMSUAM(UAMArgs *inUAMArgs)
{
	OSStatus		theError;
	Ptr				theCmdPtr;
	UInt32			theCmdSize;
	Str32			theWSName;
	Str32			theUserName;
	UAMMessage		theMessage;
	
	Assert_(inUAMArgs != NULL);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
		
	//
	//11.10.99: Clear out the command buffer just to be safe.
	//
	memset(gCmdBuffer, '\0', sizeof(gCmdBuffer));

	theCmdPtr = (Ptr)gCmdBuffer;
	UAM_PStrCopy(inUAMArgs->Opt.auth.userName, theUserName);
			
	//
	//09.28.00: If the user name is blank, then we create a random user name
	//so as to attempt a login as "guest".
	//
	if (PSTR_LENGTH(theUserName) == 0)
	{
		UAM_PStrCopy("\pGst&^^", theUserName);
	}
	
	if (inUAMArgs->callbacks != NULL)
	{
		UAM_GetWorkStationName(theWSName);
		
		//
		//This can be 0, but shouldn't be, catch only for debugging.
		//
		Assert_(PSTR_LENGTH(theWSName) != 0);
		
		//
		//Build the AFP command structure for a login.
		//
		
		*theCmdPtr   = afpLogin;
		theCmdPtr	+= sizeof(Byte);
		
		//
		//Stuff the AFP command block with our info.
		//
		StringPush_(gAFPVersion, (StringPtr)theCmdPtr);
		
		//
		//Check UAM version that the server supports, use the latest...
		//
		if (gSupportedUAMs & kMSUAM_V2_Supported) {
			StringPush_(PSTR_EncryptedLogin2_0, (StringPtr)theCmdPtr);
		}
		else {
			StringPush_(PSTR_EncryptedLogin1_0, (StringPtr)theCmdPtr);
		}
		
		StringPush_(theUserName, (StringPtr)theCmdPtr);
				
		//
		//11.23.99 MJC - Only copy the workstation name if 
		//there is one. If there is no workstation name for the Mac, then
		//we pad the end of the buffer with 2 bytes of 0's for NT4 SP6.
		//
		if (theWSName[0] > 0)
		{
			StringPush_(theWSName, (StringPtr)theCmdPtr);
		}
		else if ((gSupportedUAMs & kMSUAM_V2_Supported) == 0)
		{
			*theCmdPtr++ = 0x00;
			*theCmdPtr++ = 0x00;
		}
	
		//
		//The command block must end on an even boundary!
		//
		if ((theCmdPtr - (Ptr)gCmdBuffer) % 2)
			*theCmdPtr++ = 0x00;
								
		//
		//We need to get the command buffer size so we can pass it along.
		//
		theCmdSize = theCmdPtr - ((Ptr)gCmdBuffer);
		
		//
		//Zero out the parameter block.
		//
		memset(&theMessage, '\0', sizeof(UAMMessage));
				
		theError = UAM_OpenSession(	inUAMArgs,
									&theMessage,
									gCmdBuffer,
									theCmdSize,
									gReplyBuffer,
									sizeof(gReplyBuffer)	);
		
		//
		//The error returned should always be afpAuthContinue.
		//
		Assert_(theError == afpAuthContinue);

		if (	(theError == noErr) 				||
				(theError == afpAuthContinue) 		)
		{			
			inUAMArgs->sessionRefNum = theMessage.sessionRefNum;
			
			BlockMove(gReplyBuffer, &gMSUAMReply, sizeof(MSUAMLoginReplyBlock));
			
			theError = UAM_DSMSUAMLoginCont(inUAMArgs);
		}
		#ifdef UAMDebug
		else {
			DBGPrintIfOSErr_(theError);
		}
		#endif
	}
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_DSMSUAMLoginCont()
// ---------------------------------------------------------------------------
//	Continue the login. The following command block is built.
//
//	|---------------------|
//	|     AFP Command     | <- One Byte
//	|---------------------|
//	|	    Filler        |
//	|---------------------|
//	| Encrypted Password  |
//	/                     /
//	|---------------------|

OSStatus UAM_DSMSUAMLoginCont(UAMArgs *inUAMArgs)
{
	struct commandBuffer {
		Byte	command;
		char	marker;
		char	UAMInfo[UAM_ENCRYPTEDPWLEN];
	}*theCmdPtr;
		
	Assert_(inUAMArgs != NULL);

	char			thePassT[UAM_CLRTXTPWDLEN+1];
	OSStatus		theError;
	UAMMessage		theMessage;
	Str32			thePassword;
	UInt32			theTimeTillExpiration;
	
	//
	//Make a copy of the password as we're going to munge it up.
	//
	UAM_PStrCopy(inUAMArgs->Opt.auth.password, thePassword);
	UpperString(thePassword, true);
	
	memset(thePassT, '\0', UAM_CLRTXTPWDLEN+1);
	p2cstr(thePassword);
	strcpy(thePassT, (char *)thePassword);
	
	//
	//Map extended characters to the correct values for NT.
	//
	if (!UAM_MapCharactersIntoHostSet(thePassT, gMSUAMReply.serverExtCharMapTable))
	{
		DbgPrint_((DBGBUFF, "UAM_MapCharactersIntoHostSet() failed"));
		return(afpUserNotAuth);
	}
	
	//
	//11.10.99: Clear out the command buffer just to be safe.
	//
	memset(gCmdBuffer, '\0', sizeof(gCmdBuffer));
				
	theCmdPtr			= (commandBuffer *)gCmdBuffer;
	theCmdPtr->command	= afpContLogin;
	theCmdPtr->marker	= '\0';
			
	//
	//Now do the encryption using a hash routine.
	//
	UAM_CryptEncrypt(thePassT, gMSUAMReply.serverChallenge, theCmdPtr->UAMInfo);
	
	//
	//The encrypted OWF should never be null.
	//
	Assert_(strlen(theCmdPtr->UAMInfo) > 0);
	
	//
	//We need to zero out the parameter block.
	//
	memset(&theMessage, '\0', sizeof(UAMMessage));
	
	theMessage.sessionRefNum	= inUAMArgs->sessionRefNum;
	theMessage.commandCode		= kSendRequest;
	theMessage.cmdBuffer		= gCmdBuffer;
	theMessage.cmdBufferSize	= sizeof(commandBuffer);
	theMessage.replyBuffer		= (UInt8 *)&theTimeTillExpiration;
	theMessage.replyBufferSize	= sizeof(UInt32);
	theMessage.completion		= NULL;
	theMessage.contextPtr		= NULL;
	
	#if GENERATING68K
	theError = inUAMArgs->callbacks->SendRequestUPP(&theMessage);
	#else
	theError = CallUniversalProc(	inUAMArgs->callbacks->SendRequestUPP,
									kSendRequestProcInfo,
									&theMessage							);
	#endif
	
	//
	//For debugging we do this so we know where the error came from.
	//
	//DBGSignalIfOSErr_(theError);
	//DBGSignalIfOSErr_(theMessage.result);

	//
	//The actual error code may lerk in either place
	//
	theError = (theError == noErr) ? theMessage.result : theError;
		
	//
	//The reply buffer contains the password expiration time.
	//
	if (theError == noErr)
	{
		theTimeTillExpiration = ntoh(theTimeTillExpiration);
		gExpirationTime = theTimeTillExpiration;
	}
		
	//
	//Even if theError == noErr, the parameter block's result
	//param still might hold an error code!
	//
			
	return(theError);
}

// ---------------------------------------------------------------------------
//		 UAM_ChangePassword()
// ---------------------------------------------------------------------------
//	Change the user's password on the server.
//
//	->	inUAMArgs		The UAM arguments.
//	->	inNewPwd		The new password requested by the user.
//
//	Returns: An error code or noErr.
//
//	|---------------------|
//	|     AFP Command     | <- One Byte
//	|---------------------|
//	|	  New pwd len     |
//	|---------------------|
//	|     UAM String      |
//	/                     /
//	|---------------------|
//	|      User Name      |
//	/					  /
//	|---------------------|
//  | Old Pwd (Encrypted) |
//	/					  /
//	|---------------------|
//  | New Pwd (Encrypted) |
//	/					  /
//	|---------------------|


OSStatus UAM_ChangePassword(UAMArgs *inUAMArgs, StringPtr inNewPwd)
{	
	OSStatus	theError;
	Str32		theOldPwd, theNewPwd;
	Ptr			theCmdPtr;
	short		theCmdSize;
	char		oldPassword[UAM_CLRTXTPWDLEN+1];
	char		newPassword[UAM_CLRTXTPWDLEN+1];
	char		oldPwdT[2*kServerChallengeMaxLen];
	char		newPwdT[2*kServerChallengeMaxLen];
	
	Assert_(inNewPwd != NULL);
	Assert_(inUAMArgs != NULL);
	
	theError = UAM_DSLoginMSUAM(inUAMArgs);
		
	if ((theError == noErr) || (theError == afpNTPasswordExpired) || (theError == afpPwdExpiredErr))
	{
		UAM_PStrCopy(inUAMArgs->Opt.auth.password, theOldPwd);
		UAM_PStrCopy(inNewPwd, theNewPwd);
		
		UpperString(theOldPwd, true);
		UpperString(theNewPwd, true);
		
		p2cstr(theOldPwd);
		p2cstr(theNewPwd);
		
		memset(oldPassword, '\0', UAM_CLRTXTPWDLEN+1);
		memset(newPassword, '\0', UAM_CLRTXTPWDLEN+1);
		
		strcpy(oldPassword, (char *)&theOldPwd);
		strcpy(newPassword, (char *)&theNewPwd);

		memset(gCmdBuffer, '\0', sizeof(gCmdBuffer));
		
		theCmdPtr = (Ptr)gCmdBuffer;
		
		*theCmdPtr	= afpChangePwd;
		theCmdPtr++;
		*theCmdPtr	= strlen(newPassword);
		theCmdPtr++;
		 
		StringPush_(PSTR_EncryptedLogin1_0, theCmdPtr);
		 
		if ((theCmdPtr - ((Ptr)gCmdBuffer)) & 0x01)
		{
			*theCmdPtr = 0x00;
			theCmdPtr++;
		}
		
		StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);
		
		if ((theCmdPtr - ((Ptr)gCmdBuffer)) & 0x01)
		{
			*theCmdPtr = 0x00;
			theCmdPtr++;
		}
			
		theCmdSize = theCmdPtr - ((Ptr)gCmdBuffer);

		memset(oldPwdT, '\0', kOneWayEncryptedArgSize);
		memset(newPwdT, '\0', kOneWayEncryptedArgSize);
		
		strcpy(oldPwdT, oldPassword);
		strcpy(newPwdT, newPassword);

		if ( (UAM_MapCharactersIntoHostSet(oldPwdT, gMSUAMReply.serverExtCharMapTable)) &&
			 (UAM_MapCharactersIntoHostSet(newPwdT, gMSUAMReply.serverExtCharMapTable)) 
		   )
		{		
			UAM_DoublePasswordEncrypt(oldPwdT, newPwdT, theCmdPtr);
			
			//
			//Make a couple last calculations so we can determine the size of the CB.
			//
			
			theCmdSize += (kOneWayEncryptedArgSize * 2);
			
			UAMMessage theMessage;
			
			memset(&theMessage, '\0', sizeof(UAMMessage));
				
			theMessage.sessionRefNum	= inUAMArgs->sessionRefNum;
			theMessage.commandCode		= kSendRequest;
			theMessage.cmdBuffer		= gCmdBuffer;
			theMessage.cmdBufferSize	= theCmdSize;
			theMessage.replyBuffer		= gReplyBuffer;
			theMessage.replyBufferSize	= kMaxAFPCommand;
			theMessage.completion		= NULL;
			theMessage.contextPtr		= NULL;
						
			#if GENERATING68K
			theError = inUAMArgs->callbacks->SendRequestUPP(&theMessage);
			#else
			theError = CallUniversalProc(	inUAMArgs->callbacks->SendRequestUPP,
											kSendRequestProcInfo,
											&theMessage							);
			#endif
		}
		else {
			theError = afpNTChangePasswordFailed;
		}
	}
	
	DBGPrintIfOSErr_(theError);
	
	//
	//We're done with the session, so close it out and return any error codes.
	//
	UAM_CloseSession(inUAMArgs);
	
	return(theError);
}


// ---------------------------------------------------------------------------
//		 UAM_ChangePasswordV2()
// ---------------------------------------------------------------------------
//	Change the user's password on the server using Microsoft V2.0. This new
//	function was required so we can pass the actual password encrypted
//	over the wire to the server. The server needs the password so it can
//	update the stored clear text password on the DS (Domain Controller).
//
//	->	inUAMArgs		The UAM arguments.
//	->	inNewPwd		The new password requested by the user.
//
//	Returns: An error code or noErr.
//
//	|--------------------------------|
//	|           AFP Command          | <- One Byte
//	|--------------------------------|
//	|	        New pwd len          |
//	|--------------------------------|
//	|           UAM String           | <- Always PSTR_EncryptedLogin2_0
//	/                     			 /
//	|--------------------------------|
//	|           User Name      		 | <- Variable length
//	/					  			 /
//	|--------------------------------|
//  | PENCRYPTED_NT_OWF_PASSWORD 	 | <- Variable length
//	/					             /
//	|--------------------------------|
//  | PSAMPR_ENCRYPTED_USER_PASSWORD | <- Variable length
//	/					             /
//	|--------------------------------|


OSStatus UAM_ChangePasswordV2(UAMArgs *inUAMArgs, StringPtr inNewPwd)
{	
	OSStatus	theError;
	Str32		theOldPwd, theNewPwd;
	Ptr			theCmdPtr;
	short		theCmdSize;
	UAMMessage 	theMessage;
	char		oldPassword[UAM_ENCRYPTEDPWLEN];
	char		newPassword[UAM_ENCRYPTEDPWLEN];
	char		newStdPassword[UAM_ENCRYPTEDPWLEN];
	
	SAMPR_ENCRYPTED_USER_PASSWORD	theNewEncryptedWithLm;
	ENCRYPTED_NT_OWF_PASSWORD		theOldLmOwfEncryptedWithNewLm;
	
	Assert_(inNewPwd != NULL);
	Assert_(inUAMArgs != NULL);
	
	DbgPrint_((DBGBUFF, "Using UAM_ChangePasswordV2();g"));
	
	theError = UAM_DSLoginMSUAM(inUAMArgs);
		
	if ((theError == noErr) || (theError == afpNTPasswordExpired) || (theError == afpPwdExpiredErr))
	{
		UAM_PStrCopy(inUAMArgs->Opt.auth.password, theOldPwd);
		UAM_PStrCopy(inNewPwd, theNewPwd);
		UAM_PStrCopy(inNewPwd, (StringPtr)newStdPassword);
		
		if (theOldPwd[0] != 0)
			UpperString(theOldPwd, true);
		UpperString(theNewPwd, true);
		
		p2cstr(theOldPwd);
		p2cstr(theNewPwd);
		p2cstr((StringPtr)newStdPassword);
		
		memset(oldPassword, '\0', UAM_ENCRYPTEDPWLEN);
		memset(newPassword, '\0', UAM_ENCRYPTEDPWLEN);
		
		strcpy(oldPassword, (char *)theOldPwd);
		strcpy(newPassword, (char *)theNewPwd);

		memset(gCmdBuffer, '\0', sizeof(gCmdBuffer));
		
		theCmdPtr = (Ptr)gCmdBuffer;
		
		*theCmdPtr	= afpChangePwd;
		theCmdPtr++;
		*theCmdPtr	= strlen(newPassword);
		theCmdPtr++;
		
		StringPush_(PSTR_EncryptedLogin2_0, theCmdPtr);
		StringPush_(inUAMArgs->Opt.auth.userName, theCmdPtr);
		
		//
		//Make sure the ptr is aligned on an even boundary at this point
		//
		if ((theCmdPtr - (Ptr)gCmdBuffer) % 2)
		{
			DbgPrint_((DBGBUFF, "Aligning for even boundary;g"));
			*theCmdPtr++ = 0x00;
		}
		
		
		if ( (UAM_MapCharactersIntoHostSet(oldPassword, gMSUAMReply.serverExtCharMapTable)) &&
			 (UAM_MapCharactersIntoHostSet(newPassword, gMSUAMReply.serverExtCharMapTable))	&&
			 (UAM_MapCharactersIntoHostSet(newStdPassword, gMSUAMReply.serverExtCharMapTable)) 
			 
		   )
		{
			memset(&theNewEncryptedWithLm, 0, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD));
			memset(&theOldLmOwfEncryptedWithNewLm, 0, sizeof(ENCRYPTED_NT_OWF_PASSWORD));

			//
			//Call the magic function with will encrypt the password(s) for us.
			//
			theError = SampEncryptLmPasswords(
							oldPassword,
							newPassword,
							newStdPassword,
							&theNewEncryptedWithLm,
							&theOldLmOwfEncryptedWithNewLm);
			
			DBGPrintIfOSErr_(theError);
					
			if (theError == ERROR_SUCCESS)
			{
				//
				// Copy the ENCRYPTED_NT_OWF_PASSWORD into the command buffer.
				//
				DataPush_(&theOldLmOwfEncryptedWithNewLm, sizeof(ENCRYPTED_NT_OWF_PASSWORD), theCmdPtr);
									
				//
				//Copy the SAMPR_ENCRYPTED_USER_PASSWORD into the command buffer.
				//
				//BUGBUG: How big to make the buffer???
				DataPush_(&theNewEncryptedWithLm, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD), theCmdPtr);
								
				//
				//Make a last minute calculation so we can determine the size of the CB.
				//
				theCmdSize = theCmdPtr - (Ptr)(&gCmdBuffer);
				
				Assert_(theCmdSize <= kMaxAFPCommand);
				
				memset(&theMessage, '\0', sizeof(UAMMessage));
					
				theMessage.sessionRefNum	= inUAMArgs->sessionRefNum;
				theMessage.commandCode		= kSendRequest;
				theMessage.cmdBuffer		= gCmdBuffer;
				theMessage.cmdBufferSize	= theCmdSize;
				theMessage.replyBuffer		= gReplyBuffer;
				theMessage.replyBufferSize	= kMaxAFPCommand;
				theMessage.completion		= NULL;
				theMessage.contextPtr		= NULL;
							
				#if GENERATING68K
				theError = inUAMArgs->callbacks->SendRequestUPP(&theMessage);
				#else
				theError = CallUniversalProc(	inUAMArgs->callbacks->SendRequestUPP,
												kSendRequestProcInfo,
												&theMessage							);
				#endif
			}
		}
		else {
			theError = afpNTChangePasswordFailed;
		}
	}
	
	DBGPrintIfOSErr_(theError);
	
	//
	//We're done with the session, so close it out and return any error codes.
	//
	UAM_CloseSession(inUAMArgs);
	
	return(theError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uammain.h ===
// ===========================================================================
//	UAMMain.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "ClientUAM.h"

//
//Our type and creator
//
#define UAM_CREATOR		FOUR_CHAR_CODE('NTAM')
#define UAM_TYPE		kUAMFileType
#define UAM_TYPE_CODE	139

#define UAMResourceSignatureSize 	8
#define AFP_IconSize  				128		//Currently no defined icon bigger which AFP client model can handle.

#define	DLOG_Login					12128	//Loging dialog

//
//This is needed to tell the Chooser that the user requests
//to cancel the login operation. This is not defined anywhere,
//this is what Leland Wallace (randall@apple.com) from Apple said to use.
//
#define userCanceledError			-128

//
//Our connection method names for the login dialog
//
#define PSTR_TCPConnection			"\pTCP/IP"
#define PSTR_AppleTalkConnection	"\pAppleTalk"

//
//Password expiration notices occur when within this # of days
//
#define MINIMUM_DAYS_TILL_EXPIRATION	14

//
//The following are constants for the items in the login dialog.
//
#define DITEM_FirstHideItem	9
#define DITEM_LastHideItem	14

#define DITEM_Connect		1
#define DITEM_Line			6
#define DITEM_GuestRadio	7
#define DITEM_RegRadio		8
#define	DITEM_UserName		11
#define DITEM_Password		12
#define DITEM_ChangePwd		14
#define DITEM_Method		16
#define DITEM_Version		17
#define DITEM_Keychain		18
#define DITEM_About			20

#define UAM_ReplaceKeyQuestion		1500

//
//NT specific error codes we use.
//
enum {
	afpNTNewPasswordMismatchErr		= -13000,
	afpNTChangePasswordFailed		= -13001,
	afpNTAccountDisabled			= -13002,
	afpNTInvalidWorkstation			= -13003,
	afpNTInvalidLogonHours			= -13004,
	afpNTPasswordExpired			= -13005,
	afpNTPasswordCantChange			= -13006,
	afpNTPasswordHistConflict		= -13007,
	afpNTPasswordTooShort			= -13008,
	afpNTPasswordTooRecent			= -13009,
	afpNTPasswordRestriction		= -13010,
	afpNTAccountRestriction			= -13011,
	
	uamPasswordExpiresInOneDay		= 1002
};

//
//Prototypes for the main module live here.
//

pascal OSStatus	main(UAMArgs *inUAMArgs);
OSStatus		MS_UAMOpen(UAMArgs *inUAMArgs);
void			MS_UAMClose(void);
pascal void		MS_VersionUserItem(DialogPtr inDialog, DialogItemIndex inItem);
pascal Boolean 	MS_PwdDialogFilter(DialogPtr inDialog, EventRecord *inEvent, short *inItem);
OSStatus 		MS_FindAppleSharePassword(UAMArgs *inUAMArgs);
OSStatus		MS_UAMPwdDialog(UAMArgs *inUAMArgs);
OSStatus		MS_UAMLogin(UAMArgs *inUAMArgs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamnetwork.h ===
// ===========================================================================
//	UAMNetwork.h 				 1998 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "UAMUtils.h"

#define kDDPPacketLength	576		//The size of one packet
#define kAFPIconSize		128		//Black & white icons are 128 bytes

//
//Pascal style strings used to determine supported UAMs.
//
#define PSTR_AFPVersion22		"\pAFP2.2"
#define PSTR_AFPVersionOfChoice	"\pAFPVersion 2.1"
#define PSTR_ClearTextLogin		"\pCleartxt Passwrd"
#define PSTR_GuestLogin			"\pNo User Authent"
#define PSTR_EncryptedLogin1_0	"\pMicrosoft V1.0"
#define PSTR_EncryptedLogin2_0	"\pMS2.0"

#define kOneWayEncryptedArgSize					16
#define kServerChallengeMaxLen					8
#define kServerChallengeExtCharMapTableSize		128
#define kStartingExtendedCharValue				0x80
#define kIllegalMappedExtChar					0xFF
#define UAM_USERNAMELEN							33
#define UAM_CLRTXTPWDLEN						14
#define UAM_ENCRYPTEDPWLEN						32

//
//Mac's time is based from January 1, 1904 while a server's is based on the
//year 2000. Below is the difference between the two for conversion and a
//macro to make life easier.
//
#define NUM_SECS_FROM_1904_TO_2000 	3029529600
#define LOCAL_TIME(serverTime)		(NUM_SECS_FROM_1904_TO_2000 + serverTime)


typedef unsigned char PassWord[8];

//
//Struct for accessing server info after a ASPGetStatus call. This is the
//header information provided from the call. See Inside Appletalk p. 13-95/97
//
typedef struct
{
	short		machineTypeOffset;
	short		afpVersionOffset;
	short		supportedUAMOffset;
	short		volumeIconOffset;
	short		serverFlags;
}ServerInfoReplyBlock, *ServerInfoReplyBlockP;


//FPGetSrvrInfo() server flags bit values
typedef enum {
	kSupportsCopyFile			= 0x1,
	kSupportsChngPswd			= 0x2,
	kDontAllowSavePwd			= 0x4,
	kSupportsSrvrMsgs			= 0x8,
	kSupportsSrvrSig			= 0x10,
	kSupportsTCPIP				= 0x20,
	kSupportsSrvrNotification	= 0x40
}ServerStatusReplyFlags;


//
//Enums for supported UAMs on the server.
//
enum {
	kGuestSupported				= 0x1,
	kClearTxtSupported			= 0x2,
	kMSUAMSupported				= 0x4,
	kMSUAM_V2_Supported			= 0x8
};


//
//The reply block returned when using MSUAM.
//
typedef struct _MSUAMLoginReplyBlock
{
	char	serverChallenge[kServerChallengeMaxLen];
	char 	serverExtCharMapTable[kServerChallengeExtCharMapTableSize];
}MSUAMLoginReplyBlock;

//
//Prototypes for UAMNetwork live here.
//
void 		UAM_GetSupportedUAMS(ServerInfoReplyBlockP inReplyInfo, long *ioSupported);
Boolean 	UAM_MapCharactersIntoHostSet(char *szTarg, char *mappingTbl);
void 		UAM_CryptEncrypt(char *inClearPassword, char *inServerChallenge, char *outEncryptPW);
void 		UAM_DoublePasswordEncrypt(char *inCPPassword, char *inCPKeyPass, char *outDest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uammain.c ===
// ===========================================================================
//	UAMMain.cp 				 1997-2000 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Main unit for Microsoft User Authentication Method.
//
//	Notes:
//	--------------------------------------------------------------------------
//
//
// 	Version History:
// 	===========================================================================
//	04.22.97	MJC - Begin coding version 5.0.
//	05.22.97	MJC - Completed version 5.0d5, getting close.
//	02.21.98	MJC	- Begin updating for AppleShare 3.8 and AFP/TCP.
//	03.02.98	MJC - First working version (5.0d12) with AS Client v3.8a1lawJ
//	03.26.98	MJC - Implemented change password. It works, but not when the
//					  password has expired on the server. I suspect a bug in
//					  in AppleShare Client 3.8a1LawL which doesn't open a session
//					  when the error code returned is not noErr.
//	03.31.98	MJC	- First checkin into VSS database.
//
//	Version 5.0d15:
//	04.13.98	MJC	- Changed the way supported UAM's are recorded (bitmap vice
//					  a struct of booleans).
//					- Change some error code determination code in UAM_OpenSession()
//					  and UAM_MSUAMContLogin().
//					- Added version string at bottom of dialog window.
//
//	Version 5.0d16:
//	04.30.98	MJC	- Fixed bug in UAMDSNetwork.c where the AFP login command block
//					  would not always end on an even boundary.
//					- Added some additional asserts to UAM_DSLoginMSUAM().
//					- Changed instances of astring[0] to PSTR_LENGTH(astring).
//
//	Version 5.0d17:
//	05.19.98	MJC	- Updated for new ClientUAM.h from Apple. Now the main
//					  entry returns OSStatus vice OSErr.
//
//	Version 5.0b2:
//	06.08.98	MJC	- Added new event callback routine for AS and the Chooser
//					  in the login dialog filter.
//	Version 5.0b3:
//	09.01.98	MJC	- Fixed bug where null passwords weren't allowed.
//	10.23.98	MJC	- Fixed bug where you could use cmd-g to select Guest
//					  radio even though it was disabled.
//					- Can now use cut, copy and paste in User Name field.
//					- Changed 'OK' button to 'Connect' to match Apple's UAM
//					- Clicking on 'Registered User' when it is already
//					  doesn't cause a flash anymore or select the user name.
//	11.13.98	MJC - Added support for passing the actual encrypted password
//					  over the wire for cleartxt storage updating when
//					  changing password.
//				MJC - Added support for notifying the user that their password
//					  is about to expire.
//	12.01.98	MJC	- Fixed bug were I wasn't reversing the byte order of the
//					  returned password expiration time.
//	01.22.99	MJC - CheckGatedControls() would step 1 too far in the array.
//					- Could not use escape key if username len maxed out.
//	Version 5.0.1:
//	07.12.99	MJC - More problems with UAM_CheckGatedControls(), hopefully all
//					  fixed this time.
//					  Made small change in MS_VersionUserItem() so we compile
//					  under CW Pro 5.
//	Version 5.0.2:
//	10.21.99	MJC - Fixed bug on double byte character OS's (CHX, JPN, etc)
//					  where first char in password was getting dropped.
//					- Now select all the password text after a login failure.
//	Version 5.0.3:
//	10.29.99	MJC - Fixed bug on international systems where hitting
//					  backspace would yield incorrect results (got rid of one
//					  char instead of the double byte char).
//					- Related to fix above, change password field entry diaplay
//					  character to '*' instead of ''.
//	Version 5.0.4:
//	11.17.99	MJC - Fixed bug in encrypt.c, wasn't locking resource handle,
//					  so password OWF was incorrectly generated.
//					- SetupUAMEncrypt() was not returning a fail code
//					  if loading the data table failed.
//	Version 5.0.5:
//	11.22.99	MJC - Put 2 0x00 bytes at the end of the initial login call for
//					  NT4 SP6.
//	12.01.99	MJC - Finished keychain support.
//					- NOTE: You must now compile the MS UAM with Universal
//					  headers v3.3 or later.
//					- Can finally build PPC! The MS UAM is now a safe FAT
//					  binary. So, it'll run natively on 68K and PPC.
//					- Complete rewrite of password edit field handling. Now kicks
//					  butt! You can type just like any other text and should work
//					  better with foreign languages.
//					- Made some changes to the dialog code in preparation
//					  for Carbon.
//	01.10.00	MJC - Now check for cmd key down when opening UAM so user can
//					  bypass keychain.
//	03.13.00	MJC - Removed about dialog.
//	03.15.00	MJC - Now check for MacOS 9 or > to see if keychain is available.
//					- Now week load the Keychain.lib for compatibility with
//					  older systems.
//	03.20.00	MJC - Fixed bug: When changing password, wasn't checking for existance
//					  of keychain manager (caused -2802 error).
//	Version 5.0.6:
//	06.11.00	MJC	- Now give the option to replace keychains items that
//					  already exist. This caused problems when the user changed
//					  their password on another machine, there was no way to
//					  update the keychain item without doing it manually from the
//					  KeychainAccess control panel.
//	Version 5.0.7:
//	09.06.00	MJC - Bug fix: keychain item shouldn't appear when guest selected
//					- Bug fix: Don't allow white space as first char in user name, this
//					  involved redoing the gating logic in UAMDlogUtils.c.
//	09.28.00		- Bug fix: Allow null user name and password entries when
//					  guest login is enabled on server.
// ===========================================================================

#include <A4Stuff.h>
#include <SetupA4.h>

#include "UAMMain.h"
#include "UAMDebug.h"
#include "UAMUtils.h"
#include "UAMDialogs.h"
#include "UAMNetwork.h"
#include "UAMDSNetwork.h"
#include "UAMDLOGUtils.h"
#include "UAMKeychain.h"

//
//Global variables are declared here
//
Str32				gServerName;
Str32				gUserName;
Boolean				gContextInited;
Boolean				gGuestLogon;
Boolean				gSupportsChngPwd;
Boolean				gDoingIPConnection;
DialogPtr			gDialog;
Str32				gAFPVersion;
long				gSupportedUAMs;
ModalFilterUPP		gDialogFilter;
ModalFilterUPP		gPwdDialogFilter;
UserItemUPP			gLineItem;
UserItemUPP			gVersionItem;
Str32				gUAMVersionString;
Str32				gZoneName;
UInt32				gExpirationTime		= 0;
OTAddress*			gServerAddress 		= NULL;
EventCallbackPtr	gEventCallbackUPP 	= NULL;
Boolean				gTriedKeychain		= false;

#if GENERATINGCFM
//We need to define __procinfo for Metrowerks' linker. This basically
//defines main. Without it, we'll get a link error.
ProcInfoType __procinfo = kPascalStackBased | RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))
											| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UAMArgs*)));
#endif


// ---------------------------------------------------------------------------
//		 main()
// ---------------------------------------------------------------------------
//	This is the main entry point for our UAM. This function is passed a
//	pointer to a UAMArgs struct. This struct contains the function selector,
//	call-backs, and many other things we need to do our stuff.

pascal OSStatus main(UAMArgs *inUAMArgs)
{
	OSStatus theResult = noErr;
	
	EnterCodeResource();
	PrepareCallback();
			
	switch(inUAMArgs->command)
	{
		case kUAMOpen:
			theResult = MS_UAMOpen(inUAMArgs);
			break;
			
		case kUAMClose:
			MS_UAMClose();
			break;
			
		case kUAMPWDlog:
			theResult = MS_UAMPwdDialog(inUAMArgs);
			break;
			
		case kUAMLogin:
			theResult = MS_UAMLogin(inUAMArgs);
			break;
			
		case kUAMVSDlog:
			break;
		
		case kUAMChgPass:
		case kUAMChgPassDlg:
			DbgPrint_((DBGBUFF, "Change password dialog must be implemented"));
			theResult = kNotForUs;
			break;
				
		default:
			//
			//If we get here then we were asked to handle a routine that
			//we don't support. Return the appropriate error code.
			//
						
			DbgPrint_((DBGBUFF, "Unsupported function selector in MSUAM main() (%d)", inUAMArgs->command));

			theResult = kNotForUs;
			break;
	}
	
	ExitCodeResource();
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_UAMOpen()
// ---------------------------------------------------------------------------
//	This is called by the device package. It is not a required function but
//	we use it to initialize our UAM code. Note that when we encounter an
//	error we don't make an effort to clean up. Instead we return userCanceledErr
//	in which case our UAMClose function will be called by AppleShare Client.

OSStatus MS_UAMOpen(UAMArgs *inUAMArgs)
{
	short theUAMConfig = 0;
		
	//
	//Get the name of the server we want to log into.
	//
	UAM_PStrCopy(inUAMArgs->Opt.open.objectName, gServerName);
	
	//
	//Copy the zone name for. If it's NULL, then we
	//don't have a zone name.
	//
	if (inUAMArgs->Opt.open.zoneName != NULL)
		UAM_PStrCopy(inUAMArgs->Opt.open.zoneName, gZoneName);
	else
		gZoneName[0] = 0;
							
	gContextInited 		= false;		//Been through PwdDialog before?	
	gGuestLogon 		= false;		//Is guest our logon choice?
	gDoingIPConnection	= false;		//Default to AppleTalk support.
	gDialog				= NULL;			//So we can see if we really got it.
	gDialogFilter		= NULL;	
	gPwdDialogFilter	= NULL;
	gLineItem			= NULL;
	gVersionItem		= NULL;
	gAFPVersion[0]		= 0;
	gUserName[0]		= 0;
	gServerAddress		= inUAMArgs->Opt.open.srvrAddress;
	gEventCallbackUPP	= inUAMArgs->callbacks->EventCallbackUPP;		
	gTriedKeychain		= false;
	
	UAM_KCInitialize(inUAMArgs);
					
	//
	//Under PowerPC this is a pointer allocated. Under 68K, it just
	//points to the function.
	//
	gDialogFilter = NewModalFilterProc(&UAM_DialogFilter);
	if (gDialogFilter == NULL)
	{
		//
		//We check for ptr validity. Note that we don't bother to 
		//clean up since we'll get a kUAMClose message next.
		//
		
		DbgPrint_((DBGBUFF, "Failed to allocate gDialogFilter"));
		return(userCanceledErr);
	}
	
	gPwdDialogFilter = NewModalFilterProc(&MS_PwdDialogFilter);
	if (gPwdDialogFilter == NULL)
	{
		DbgPrint_((DBGBUFF, "Failed to allocate gPwdDialogFilter"));
		return(userCanceledErr);
	}
	
	gLineItem = NewUserItemProc(&UAM_FrameItem);
	if (gLineItem == NULL)
	{
		DbgPrint_((DBGBUFF, "Failed to allocate gLineItem"));
		return(userCanceledErr);
	}
	
	gVersionItem = NewUserItemProc(&MS_VersionUserItem);
	if (gVersionItem == NULL)
	{
		DbgPrint_((DBGBUFF, "Failed to allocate gVersionItem"));
		return(userCanceledErr);
	}

	//
	//Get the AFP version and the default user name. This function finds
	//a match which is the highest AFP version supported by both the client
	//and server.
	//
	UAM_GetAFPVersionString(	
			inUAMArgs->Opt.open.srvrInfo,
			inUAMArgs->callbacks,
			gAFPVersion,
			gUserName 			);
	
	//
	//gUserName can be null, we just capture here during debugging to
	//ensure we're getting the name properly.
	//
	Assert_(PSTR_LENGTH(gUserName) != 0);
	Assert_(PSTR_LENGTH(gAFPVersion) != 0);
	
	if (PSTR_LENGTH(gAFPVersion) == 0)
	{
		//
		//No AFPVersion, no logon...
		//
		
		UAM_ReportError(uamErr_NoAFPVersion);
		return(userCanceledErr);
	}
					
	gSupportsChngPwd = ((inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsChngPswd) != 0);
	
	//
	//Determine what connection method we are using, IP or AppleTalk. Basically,
	//if the client supports IP and the address type is IP, then we have
	//a TCP connection.
	//
	if (inUAMArgs->Opt.open.srvrInfo->fFlags & kSupportsTCPIP)
	{
		if (inUAMArgs->Opt.open.srvrAddress->fAddressType == AF_INET)
		{
			gDoingIPConnection = TRUE;
		}
	}
											
	//
	//Get the list of supported UAMs from a utility routine. This data
	//is necessary in the password dialog code.
	//							
	UAM_GetSupportedUAMS(
			(ServerInfoReplyBlock *)inUAMArgs->Opt.open.srvrInfo,
			&gSupportedUAMs		);
	
	//
	//We should never get here if the following is false, but we
	//check just to be on the safe side.
	//
	if (	((gSupportedUAMs & kMSUAMSupported) 	== 0)	&&
			((gSupportedUAMs & kMSUAM_V2_Supported) == 0)	) 
	{
		Assert_((gSupportedUAMs & kMSUAMSupported) != 0);
		
		UAM_ReportError(afpBadUAM);
		return(userCanceledErr);
	}
	
	UAM_VersionString(gUAMVersionString);

	//
	//This is how we tell AppleShare what our UAM supports. We have
	//our own password dialog, we support change password, and we
	//use our own change password dialog.
	//
	
	theUAMConfig |= BIT_0;	//Custom login dialog
	theUAMConfig |= BIT_2;	//We support change password
	theUAMConfig |= BIT_3;	//Custom change password dialog
	
	inUAMArgs->result = theUAMConfig;
		
	return(noErr);
}


// ---------------------------------------------------------------------------
//		 MS_UAMClose()
// ---------------------------------------------------------------------------
//	Like UAMOpen, UAMClose has no specific purpose as defined by the device
//	manager. We use it to clean up our allocated storage and globals.

void MS_UAMClose(void)
{
	if (gDialog != NULL)
	{
		//
		//If we put up our login dialog, get rid of it.
		//
		UAM_DisposeDialog(gDialog);
	}
	
	if (gDialogFilter != NULL)		DisposeRoutineDescriptor(gDialogFilter);
	if (gLineItem != NULL)			DisposeRoutineDescriptor(gLineItem);
	if (gPwdDialogFilter != NULL)	DisposeRoutineDescriptor(gPwdDialogFilter);
	if (gVersionItem != NULL)		DisposeRoutineDescriptor(gVersionItem);
}


// ---------------------------------------------------------------------------
//		 MS_VersionUserItem()
// ---------------------------------------------------------------------------
//	Custom user item routine to display UAM version number.

pascal void MS_VersionUserItem(DialogPtr inDialog, DialogItemIndex inItem)
{
	short	theFont, theSize;
	Rect	theItemRect;
	
	EnterCallback();
			
	theFont = inDialog->txFont;
	theSize	= inDialog->txSize;
	
	TextFont(kFontIDGeneva);
	TextSize(9);
	
	theItemRect = UAM_GetItemRect(inDialog, inItem);
	
	TETextBox(	
			&gUAMVersionString[1],
			PSTR_LENGTH(gUAMVersionString),
			&theItemRect,
			teJustRight	);
			
	TextFont(theFont);
	TextSize(theSize);
	
	ExitCallback();
}


// ---------------------------------------------------------------------------
//		 MS_PwdDialogFilter()
// ---------------------------------------------------------------------------
//	Filter function for the password dialog. We have this so we can capture
//	command keys and keep length requirements for the user name in the login 
//	dialog.

pascal Boolean MS_PwdDialogFilter(DialogPtr inDialog, EventRecord *inEvent, short *inItem)
{
	short	theCode;
	Str255	theString;
	Boolean	theResult = false;
	
	EnterCallback();
		
	if (inEvent->what == keyDown)
	{
		theCode = (inEvent->message & charCodeMask);
		
		if (inEvent->modifiers & cmdKey)
		{
			switch(theCode)
			{
				case 'g':
				case 'G':
					*inItem   = DITEM_GuestRadio;
					theResult = true;
					break;
				
				case 'r':
				case 'R':
					*inItem   = DITEM_RegRadio;
					theResult = true;
					break;
					
				case 's':
				case 'S':
					*inItem	  = DITEM_ChangePwd;
					theResult = true;
					break;
									
				case 'a':
				case 'A':
					*inItem   = DITEM_Keychain;
					theResult = true;
					break;
				
				//
				//Handle edit commands from the user. We don't allow any
				//editing commands in the password field. This mimicks
				//Apple's own UAM's.
				//
					
				case 'c':
				case 'C':
					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {
						DialogCopy(inDialog);
					}
					break;
					
				case 'v':
				case 'V':
					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {
						DialogPaste(inDialog);
					}
					break;
				case 'x':
				case 'X':
					if ((((DialogPeek)inDialog)->editField + 1) != DITEM_Password) {
						DialogCut(inDialog);
					}
					break;
					
				default:
					break;
			}
		}
		else
		{
			//
			//Don't allow more than UAM_USERNAMELEN maximum characters in edit field.
			//
			
			if ((((DialogPeek)inDialog)->editField + 1) == DITEM_UserName)
			{
				UAM_GetText(inDialog, DITEM_UserName, (Str255 *)&theString);
				
				switch(theCode)
				{
					case UAMKey_BackDel:
					case UAMKey_Left:
					case UAMKey_Right:
					case UAMKey_Return:
					case UAMKey_Enter:
					case UAMKey_Escape:
						break;
						
					default:
						if (PSTR_LENGTH(theString) >= UAM_USERNAMELEN)
						{
							SysBeep(1);
						
							inEvent->what = nullEvent;
							theResult 	  = true;
						}
						break;
				}
			}
		}
	}
	else
	{
		if (gEventCallbackUPP)
		{
			//
			//If we're not handling the event ourselves, then call the
			//event callback which gives AS and the Chooser a chance
			//to update it's windows, etc.
			//
			
			#if GENERATING68K
			
			gEventCallbackUPP(inEvent);
			
			#else
			
			CallUniversalProc(gEventCallbackUPP, kEventCallbackProcInfo, inEvent);
			
			#endif	
		}
	}
	
	ExitCallback();
	
	return(theResult);
}


// ---------------------------------------------------------------------------
//		 MS_UAMPwdDialog()
// ---------------------------------------------------------------------------
//	This is where we put up our password dialog. The buffers pointed to by
//	'inUserName' and 'inPassword' end up getting passed directly to the
//	UAMLogin function.
//
//	The buffer passed for the user name and password is 64 bytes long. Don't
//	use more than that! 

OSStatus MS_UAMPwdDialog(UAMArgs *inUAMArgs)
{
	short			theItem, x;
	Str255			theStr;
	OSStatus		theError	= noErr;
	Boolean			theLoop 	= true;
	
	Assert_(gDialogFilter 		!= NULL);
	Assert_(gPwdDialogFilter 	!= NULL);
	Assert_(gLineItem 			!= NULL);
		
	//
	//Determine which user name to use, the default or the
	//one supplied by the client (if any). gUserName is filled
	//in originally during the UAMOpen call.
	//
	if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) != 0)
	{
		UAM_PStrCopy(inUAMArgs->Opt.pwDlg.userName, gUserName);
	}
	
	//
	//If we already tried the keychain and failed, we don't want
	//to try again or we'll loop forever. Give the user a chance
	//to enter the correct name and password.
	//
	//NOTE: We check to see if the cmd key is down, if it is, then
	//we bypass the keychain stuff alltogether. Maybe the user wants
	//to change his password!?!?!
	//
	if ((gTriedKeychain == false) && (UAM_KCAvailable()) && (!UAM_KeyDown(KEY_Command)))
	{
		gTriedKeychain = true;
		
		if ( (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName))	&&
			 (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.password))	)
		{
			//
			//We were supplied a username and password by the AFP
			//client. This means the user clicked a keychain entry.
			//
			goto exit;
		}
		else 
		{
			theError = UAM_KCFindAppleSharePassword(
							gUserName,
							inUAMArgs->Opt.pwDlg.password,
							gServerName,
							NULL
			);
			
			if (theError == noErr)
			{
				DbgPrint_((DBGBUFF, "Pswd found via MSUAM keychain calls;g"));
				
				//
				//Fill in the user name for the UAMArgs.
				//
				if (PSTR_LENGTH(inUAMArgs->Opt.pwDlg.userName) == 0)
				{
					UAM_PStrCopy(gUserName, inUAMArgs->Opt.pwDlg.userName);
				}

				//
				//A password was found so try to logon.
				//
				goto exit;
			}
			else if (	(theError != errKCItemNotFound)		&&
						(theError != userCanceledErr)		)
			{
				//
				//Only report "real" errors.
				//
				UAM_ReportError(theError);
			}
		}
	}
	else if ((UAM_KCAvailable()) && (UAM_KeyDown(KEY_Command)))
	{
		//
		//If the user is holding the cmd key down, then we don't want to
		//try the keychain the next time through either.
		//
		gTriedKeychain = true;
	}
			
	//
	//Display the server name in the dialog title text
	//which is located at the top of the dialog. This must be
	//done even if we've been here before.
	//
	
	ParamText(gServerName, NULL, NULL, NULL);
	
	//
	//If we haven't been through here before, then we need to do
	//all the prep work.
	//
		
	if (!gContextInited)
	{
		gDialog = UAM_NewDialog(DLOG_Login, true);
		if (gDialog == NULL)
		{
			//
			//If we couldn't get the dialog, then we're either out
			//of memory or the resource couldn't be found.
			//
			
			theError = MemError();
			if (theError == noErr)
				theError = ResError();
			if (theError == noErr)
				theError = resNotFound;
			
			UAM_ReportError(theError);
			return(userCanceledErr);
		}
						
		//
		//Set up the default user name and password (if any). If a user name
		//exists, then make the password field the active field ready for input.
		//
			
		UAM_SetUpUserItem(gDialog, DITEM_Line, gLineItem, userItem);
		UAM_SetUpUserItem(gDialog, DITEM_Version, gVersionItem, userItem);
		
		//
		//Put in some extra info in the dialog for debugging.
		//
		#ifdef UAMDebug
		Str255 theConnString;
		
		if (gDoingIPConnection)
			UAM_PStrCopy(PSTR_TCPConnection, theConnString);
		else
			UAM_PStrCopy(PSTR_AppleTalkConnection, theConnString);
		
		if (gSupportedUAMs & kMSUAM_V2_Supported)
			UAM_AppendPStr(theConnString, "\p (MS2.0)", sizeof(Str255));
		else
			UAM_AppendPStr(theConnString, "\p (MS1.0)", sizeof(Str255));
			
		#if GENERATINGCFM
		UAM_AppendPStr(theConnString, "\p[PPC]", sizeof(Str255));
		#else
		UAM_AppendPStr(theConnString, "\p[68K]", sizeof(Str255));
		#endif
		#endif
		
		//
		//Let the client know what connection method is being used to
		//connect to the server.
		//
		if (gDoingIPConnection)
		{
			#ifdef UAMDebug
			UAM_SetText(gDialog, DITEM_Method, theConnString);
			#else
			UAM_SetText(gDialog, DITEM_Method, PSTR_TCPConnection);
			#endif
		}
		else
		{
			#ifdef UAMDebug
			UAM_SetText(gDialog, DITEM_Method, theConnString);
			#else
			UAM_SetText(gDialog, DITEM_Method, PSTR_AppleTalkConnection);
			#endif
		}
		
		//
		//If we've not been here before, then we want to use the user name
		//entered in the Sharing Setup Control Panel (or Chooser).
		//
		
		if (PSTR_LENGTH(gUserName) != 0)
		{
			UAM_SetText(gDialog, DITEM_UserName, gUserName);
			SelectDialogItemText(gDialog, DITEM_Password, 0, 64);
		}
		else
		{
			UAM_HiliteItem(gDialog, 1, 255);
		}
		
		//
		//Now we set up the guest and registered user radio buttons and the
		//change password button as determined by UAM_GetServerInfo().
		//
		
		if (!gSupportsChngPwd) {
			UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);
		}
		else {
			UAM_GateControl(gDialog, DITEM_ChangePwd, DITEM_UserName);
		}
		
		if (!(gSupportedUAMs & kGuestSupported))
		{
			//
			//No guest support, we don't need the guest radio button.
			//
			UAM_HiliteItem(gDialog, DITEM_GuestRadio, 255);
			
			//
			//If guest is not supported, then we gate the connect
			//button to the username text field.
			//
			UAM_GateControl(gDialog, DITEM_Connect, DITEM_UserName);
		}
		
		//
		//Set the initial radio for the default/current login method.
		//
		
		if (gGuestLogon)
		{
			UAM_SetCValue(gDialog, DITEM_GuestRadio, 1);
			UAM_SetCValue(gDialog, DITEM_RegRadio, 	 0);
			
			UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);
			
			for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
				HideDialogItem(gDialog, x);
			}
			
			UAM_HiliteItem(gDialog, 1, 0);
		}
		else {
			UAM_SetCValue(gDialog, DITEM_RegRadio, 1);
		}
				
		UAM_SetBulletItem(gDialog, DITEM_Password, UAM_CLRTXTPWDLEN);
		UAM_SupportCmdKeys(gDialog, false);
				
		//
		//Set our custom filter function so we can handle command keys and
		//manage user name maximum string length.
		//
		UAM_SetCustomFilterProc(gDialog, gPwdDialogFilter);
		
		//
		//If the client is not allowed to save password for this server,
		//then we gray out the keychain checkbox.
		//
		if (UAM_KCAvailable() == false)
		{
			UAM_HiliteItem(gDialog, DITEM_Keychain, 255);
		}
		else if (gTriedKeychain)
		{
			UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
			SelectDialogItemText(gDialog, DITEM_Password, 0, 64);
		}
		
		//
		//This flag lets up know that we've initialized our login dialog
		//and that we don't need to do it again when/if we come here again.
		//
		
		gContextInited	= true;
	}
	else {
		UAM_SetText(gDialog, DITEM_UserName, inUAMArgs->Opt.pwDlg.userName);
		UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
		
		//
		//Hilite the password selection.
		//
		SelectDialogItemText(gDialog, DITEM_Password, 0, 64);
		
		InvalRect(&gDialog->portRect);
	}
	
	do
	{
		ModalDialog(gDialogFilter, &theItem);
		
		//
		//Check gated controls, disable them if their text item
		//counterpart has no text.
		//
			
		UAM_CheckGatedControls(gDialog);

		switch(theItem)
		{
			case DITEM_OK:				
				gGuestLogon 	= (UAM_GetCValue(gDialog, DITEM_GuestRadio) != 0);
				theError		= noErr;
				theLoop 		= false;
				
				if (gGuestLogon)
				{
					inUAMArgs->Opt.pwDlg.userName[0] = 0;
					inUAMArgs->Opt.pwDlg.password[0] = 0;
				}
				else
				{					
					UAM_GetBulletBuffer(	gDialog,
											DITEM_Password,
											inUAMArgs->Opt.pwDlg.password	);
					
					UAM_GetText(			gDialog,
											DITEM_UserName,
											(Str255 *)inUAMArgs->Opt.pwDlg.userName	);
				}
				break;
				
			case DITEM_Cancel:
				//
				//VERSION 5.0: To force cancellation, we pass userCanceledError(-128)
				//back to the Chooser. The old UAM would pass back dsForcedQuit which
				//is the wrong value. This would cause an error dialog when cancelling.
				//
				
				theError	= userCanceledError;
				theLoop 	= false;
				break;
			
			case DITEM_GuestRadio:
				//
				//Set up the controls in the dialog for guest login. We don't
				//need the user name and password items, so hide them from
				//the user. We must explicitly enable the 'OK' button since
				//it may have been disabled by the gate stuff.
				//
				
				if (UAM_IsActive(gDialog, DITEM_GuestRadio))
				{
					UAM_SetCValue(gDialog, DITEM_GuestRadio, 1);
					UAM_SetCValue(gDialog, DITEM_RegRadio, 	 0);
					
					//UAM_HiliteItem(gDialog, DITEM_ChangePwd, 255);
					
					for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
						HideDialogItem(gDialog, x);
					}
					
					//
					//Now hide the keychain checkbox
					//
					UAM_SetCValue(gDialog, DITEM_Keychain, 0);
					HideDialogItem(gDialog, DITEM_Keychain);
					
					UAM_StopGate(gDialog, DITEM_Connect);
				}
				break;
			
			case DITEM_RegRadio:
				//
				//Now we need all the items back that were hidden above, make
				//them visible.
				//
				if (UAM_GetCValue(gDialog, DITEM_RegRadio) <= 0)
				{
					UAM_SetCValue(gDialog, DITEM_GuestRadio, 0);
					UAM_SetCValue(gDialog, DITEM_RegRadio, 	 1);
					
					for (x = DITEM_FirstHideItem; x <= DITEM_LastHideItem; x++) {
						ShowDialogItem(gDialog, x);
					}
					
					//
					//Make the keychain item reaappear.
					//
					ShowDialogItem(gDialog, DITEM_Keychain);
								
					UAM_GetText(gDialog, DITEM_UserName, &theStr);
					SelectDialogItemText(gDialog, DITEM_UserName, 0, 32767);
					
					if ((gSupportsChngPwd) && (theStr[0] != 0)) {
						UAM_HiliteItem(gDialog, DITEM_ChangePwd, 0);
					}
					
					//
					//Check to see if guest is supported or not so we know if
					//we need to gate the connect button.
					//
					if (!(gSupportedUAMs & kGuestSupported))
					{
						UAM_GateControl(gDialog, DITEM_Connect, DITEM_UserName);
						UAM_CheckGatedControls(gDialog);
					}
				}
				break;
				
			case DITEM_ChangePwd:
				UAM_GetBulletBuffer(	gDialog,
										DITEM_Password,
										inUAMArgs->Opt.pwDlg.password	);
				UAM_GetText(			gDialog,
										DITEM_UserName,
										(Str255 *)inUAMArgs->Opt.pwDlg.userName	);
				
				theError = UAM_ChangePwd(inUAMArgs);
				switch(theError)
				{
					case CHNGPSWD_USER_CANCELED:
						break;
					
					case CHNGPSWD_UPDATE_KEYCHAIN:
						//
						//We need to re-add the keychain item with the
						//correct password. Flag it by checking the box.
						//
						UAM_SetCValue(gDialog, DITEM_Keychain, 1);
						
						//
						//Just fall on through and handle the normal case.
						//
						
					case CHNGPSWD_NOERR:
						//
						//Set the password field and buffer with the new password in case
						//we end back here later.
						//
						
						UAM_SetBulletText(gDialog, DITEM_Password, inUAMArgs->Opt.pwDlg.password);
						
						theError = noErr;
						theLoop  = false;
						break;
						
					default:
						UAM_ReportError(theError);
						
						//
						//Because we use ParamText() we must manually force an update
						//of the dialog or things won't redraw properly.
						//
						InvalRect(&gDialog->portRect);
						break;
				}
			
				//
				//Must reset our user's name since UAM_ChangePwd() uses ParamText()
				//to set some strings of it's own.
				//
				
				ParamText(gServerName, NULL, NULL, NULL);
				break;
							
			case DITEM_Keychain:
				UAM_ToggleControl(gDialog, DITEM_Keychain);
				break;
			
			default:
				break;
		}
		
	}while(theLoop);

exit:
	return(theError);
}


// ---------------------------------------------------------------------------
//		 MS_UAMLogin()
// ---------------------------------------------------------------------------
//	This routine does the actual logging onto the server.

OSStatus MS_UAMLogin(UAMArgs *inUAMArgs)
{
	OSStatus	theError 	= noErr;
	Boolean		theLoop		= true;
	CursHandle	theCursor;
	
	Assert_(inUAMArgs != NULL);
							
	do
	{
		theCursor = GetCursor(watchCursor);
		SetCursor(*theCursor);
				
		if (gGuestLogon) {
			theError = UAM_DSLoginGuest(inUAMArgs);
		}
		else {
			theError = UAM_DSLoginMSUAM(inUAMArgs);
		}
		
		if (theError != noErr)
		{
			//
			//For whatever reason, we couldn't log into the server, handle the most
			//basic errors and try to logon again by presenting the login dialog
			//again. Otherwise, exit...
			//
			
			UAM_ReportError(theError);
			
			switch(theError)
			{
				case afpNTPasswordExpired:
				case afpPwdExpiredErr:
					UAM_CloseSession(inUAMArgs);
				
				case afpUserNotAuth:
				case afpParmErr:
				case afpNTAccountDisabled:
				case afpNTInvalidWorkstation:
				case afpNTInvalidLogonHours:
					if (MS_UAMPwdDialog(inUAMArgs) != noErr)
						return(userCanceledErr);
					break;
												
				default:
					theLoop 	= false;
					theError	= userCanceledErr;
					break;
			}
		}
		else
		{
			if ((gSupportedUAMs & kMSUAM_V2_Supported) && (!gGuestLogon))
			{
				//
				//Check for password expiration at this point.
				//
				UInt32	theDaysTillExpiration = (((gExpirationTime / 60) / 60) / 24);
								
				if (theDaysTillExpiration <= MINIMUM_DAYS_TILL_EXPIRATION)
				{
					//
					//The password is going to expire within MINIMUM_DAYS_TILL_EXPIRATION,
					//post the nofication dialog.
					//
					
					UAM_ChangePasswordNotificationDlg(theDaysTillExpiration);
				}
			}
			
			if (UAM_KCAvailable())
			{
				//
				//If the user is allowed to save their password and
				//the keychain check box is checked, save the current
				//credentials to the keychain.
				//
				if (UAM_GetCValue(gDialog, DITEM_Keychain) > 0)
				{
					theError = UAM_KCSavePassword(
									inUAMArgs->Opt.auth.userName, 
									inUAMArgs->Opt.auth.password,
									gServerName
					);
					
					if ((theError != noErr) && (theError != userCanceledErr))
					{
						if (theError == errKCDuplicateItem)
						{
							Int16 theResponse;
							
							//
							//A duplicate item exists, see if the user wants
							//to replace it.
							//
							
							theResponse = UAM_AskQuestion(UAM_ReplaceKeyQuestion);
							
							if (theResponse == ALRT_YES)
							{
								//
								//The user asked us to replace the item. Try one
								//more time to add the keychain item.
								//
								theError = UAM_KCDeleteItem(
												inUAMArgs->Opt.auth.userName,
												gServerName
								);
								
								if (theError == noErr)
								{
									theError = UAM_KCSavePassword(
													inUAMArgs->Opt.auth.userName, 
													inUAMArgs->Opt.auth.password,
													gServerName
									);
									
									if (theError != noErr)
									{
										//
										//We errored out, nothing to do but report it.
										//
										UAM_ReportError(theError);
									}
								}
							}
						}
						else
						{
							UAM_ReportError(theError);
						}
						
						//
						//We do not want to pass back any keychain error codes to
						//the AFP client!
						//
						theError = noErr;
					}				
				}
			}
			
			theLoop = false;
		}
		
	}while(theLoop);
	
	return(theError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamutils.c ===
// ===========================================================================
//	UAMUtils.cp 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
// General utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#include <Errors.h>
#include <String.h>
#include <stdio.h>

#include "UAMDebug.h"
#include "UAMUtils.h"
#include "UAMNetwork.h"
#include "UAMDialogs.h"

// ---------------------------------------------------------------------------
//		 UAM_PStrCopy()
// ---------------------------------------------------------------------------
//	Custom routine for copying pascal style strings. Copies inSrcString into
//	inDestString. Careful here since this routine doesn't know how long a
//	string can be, don't copy a 255 byte string into a 32 byte string. BOOM!

void UAM_PStrCopy(const StringPtr inSrcString, StringPtr inDestString)
{
	Assert_(inSrcString  != NULL);
	Assert_(inDestString != NULL);
	
	BlockMove(inSrcString, inDestString, inSrcString[0] + 1);
	inDestString[0] = inSrcString[0];
}


// ---------------------------------------------------------------------------
//		 UAM_AppendPStr()
// ---------------------------------------------------------------------------
//	Custom routine for appending one pascal style string to another.
//	inAppendStr in pasted to the end of inBase. inDestSize if the maximum size
//	the new string can be.

void UAM_AppendPStr(Str255 inBase, const Str255 inAppendStr, short inDestSize)
{
	Assert_(inBase		!= NULL);
	Assert_(inAppendStr	!= NULL);
	Assert_(inDestSize 	>  0);
	
	short	charsToCopy	= inAppendStr[0];
	
	if ((inBase[0] + charsToCopy) > (inDestSize - 1)) {
		charsToCopy = inDestSize - 1 - inBase[0];
	}
	
	BlockMove(inAppendStr + 1, inBase + inBase[0] + 1, charsToCopy);
	
	inBase[0] += charsToCopy;
}

#pragma mark-
// ---------------------------------------------------------------------------
//		 UAM_FrontWindowRect()
// ---------------------------------------------------------------------------
//	Returns the rect of the front-most window is global coordinates.

void UAM_FrontWindowRect(Rect *outWindowRect)
{
	WindowPtr	theWindow = FrontWindow();
	Point		thePoint;
	Rect		theRect;
		
	theRect 		= theWindow->portRect;
	
	thePoint.h 		= theWindow->portRect.left;
	thePoint.v 		= theWindow->portRect.top;
	
	LocalToGlobal(&thePoint);
	theRect.left	= thePoint.h;
	theRect.top		= thePoint.v;
	
	thePoint.h 		= theWindow->portRect.right;
	thePoint.v 		= theWindow->portRect.bottom;
	
	LocalToGlobal(&thePoint);
	theRect.right	= thePoint.h;
	theRect.bottom	= thePoint.v;
	
	*outWindowRect = theRect;
}


// ---------------------------------------------------------------------------
//		 UAM_GetUserName()
// ---------------------------------------------------------------------------
//	Returns the default user name as set in the Sharing Setup/File Sharing
//	dialogs. This would also be considered the old 'Chooser' name.

void UAM_GetUserName(StringPtr outUserName)
{
	StringHandle	theString = NULL;
	
	outUserName[0] = 0;
		
	theString = GetString(STR_ChooserUserName);
	if (theString != NULL)
	{
		UAM_PStrCopy(*theString, outUserName);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_GetWorkStationName()
// ---------------------------------------------------------------------------
//	Returns the workstation name as set in the Sharing Setup/File Sharing
//	dialogs.

void UAM_GetWorkStationName(Str255 outWSName)
{
	StringHandle	theString = NULL;
	
	outWSName[0] = 0;
	
	theString = GetString(STR_Sys7WorkStationName);
	if (theString != NULL)
	{
		HLock((Handle)theString);
		UAM_PStrCopy(*theString, outWSName);
		HUnlock((Handle)theString);
	}
}


// ---------------------------------------------------------------------------
//		 UAM_AFPClientSupportsOurUAM
// ---------------------------------------------------------------------------
//	Returns TRUE if the client we're on is running AppleShare Client 3.8
//	or later.

Boolean UAM_AFPClientSupportsOurUAM(void)
{
	short 	theCfgWord;
	short	theVersion = UAM_AppleShareVersion(&theCfgWord);
	
	if (theVersion <= gestaltAFPClient3_7_2)
	{
		StopAlert(ALRT_WrongClientVers, NULL);
		return(false);
	}
	
	return(true);
}


#pragma mark-
// ---------------------------------------------------------------------------
//		 UAM_VersionString
// ---------------------------------------------------------------------------
//	Returns a string containing the version of this build.

void UAM_VersionString(Str32 outVersionString)
{
	Handle			theVersHandle;
	long			theVersion;
	unsigned char	theVer1, theVer2, theVer3, theRelStatus, thePrereleaseNum;
	Str32			theTempStr;
	
	outVersionString[0] = 0;
	UAM_PStrCopy("\pv", outVersionString);
	
	theVersHandle = Get1Resource('vers', 1);
	if (theVersHandle)
	{
		theVersion = *((long *)(*theVersHandle));
	
		ReleaseResource(theVersHandle);
	
		theVer1		= ((char *)&theVersion)[0];
		theVer1		= (((theVer1 & 0xF0) >> 4) * 10) + (theVer1 & 0x0F);
		theVer2		= (((char *)&theVersion)[1] & 0xF0) >> 4;
		theVer3		= (((char *)&theVersion)[1] & 0x0F);
		
		theRelStatus		= ((char *)&theVersion)[2];
		thePrereleaseNum	= ((char *)&theVersion)[3];
		
		NumToString((long)theVer1, theTempStr);
		UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
		UAM_AppendPStr(outVersionString, "\p.", sizeof(Str32));
		
		NumToString((long)theVer2, theTempStr);
		UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
	
		if (theVer3 != 0)
		{
			UAM_AppendPStr(outVersionString, "\p.", sizeof(Str32));
			
			NumToString((long)theVer3, theTempStr);
			UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
		}
		
		switch(theRelStatus)
		{
			case 0x20:
				UAM_AppendPStr(outVersionString, "\pd", sizeof(Str32));
				break;
			
			case 0x40:
				UAM_AppendPStr(outVersionString, "\pa", sizeof(Str32));
				break;
	
			case 0x60:
				UAM_AppendPStr(outVersionString, "\pb", sizeof(Str32));
				break;
				
			default:
				break;
		}
		
		if (theRelStatus != 0x80)
		{
			NumToString((long)thePrereleaseNum, theTempStr);
			UAM_AppendPStr(outVersionString, theTempStr, sizeof(Str32));
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_GetAFPInfo
// ---------------------------------------------------------------------------
//	Return the AFP version string and the default user name.

void UAM_GetAFPVersionString(	AFPSrvrInfo 			*inInfo,
								ClientUAMCallbackRec 	*inCallbacks,
								Str32					&ioAFPVersion,
								Str32					&ioDefaultUserName	)
{
	struct 		AFPClientInfo *theClientInfo = NULL;
	short		theIndex;
	StringPtr	theVersionBuf;
	UInt32		theVersionBufSize;
	Boolean		theResult;
	
	#if GENERATING68K
	OSStatus 	theError;
	#endif
	
	Assert_(inCallbacks 		!= NULL);
	Assert_(inInfo 				!= NULL);
	Assert_(ioAFPVersion		!= NULL);
	Assert_(ioDefaultUserName	!= NULL);
			
	ioAFPVersion[0]	  	 = 0;
	ioDefaultUserName[0] = 0;
	
	if ((inCallbacks) && (inInfo))
	{
		//
		//Use the UAM callback GetClientInfo() to get the client info.
		//
		#if GENERATING68K
		theError = inCallbacks->GetClientInfoUPP(kAFPClientInfo, (ClientInfo **)&theClientInfo);
		if (theError != noErr)
		{
			UAM_ReportError(theError);
			return;
		}
		#else
		CallUniversalProc(	inCallbacks->GetClientInfoUPP,
							kGetClientInfoProcInfo,
							kAFPClientInfo,
							(ClientInfo **)&theClientInfo	);
		#endif
		
		Assert_(theClientInfo != NULL);
		
		if (theClientInfo)
		{
			//
			//Stuff the default user name in the return parameter.
			//
			UAM_PStrCopy(theClientInfo->fDefaultUserName, ioDefaultUserName);
			
			//
			//Go through the list of AFP versions supported on this client
			//and try to find them in the SrvrInfoBuffer, first match
			//succeeds.
			//
			
			theVersionBuf		= (StringPtr)((UInt32)inInfo + inInfo->fVerCountOffset + 1);
			theVersionBufSize	= (inInfo->fUAMCountOffset - inInfo->fVerCountOffset) - 1;
			
			for (theIndex = 0; theIndex < theClientInfo->fNumAFPVersions; theIndex++)
			{
				theResult = UAM_FindStringInBuffer(
										theClientInfo->fAFPVersionStrs[theIndex],
										theVersionBuf,
										theVersionBufSize  );
				
				if (theResult)
				{
					UAM_PStrCopy(theClientInfo->fAFPVersionStrs[theIndex], ioAFPVersion);
					return;
				}
			}
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_FindStringInBuffer
// ---------------------------------------------------------------------------
//	Finds a pascal string within a buffer.

Boolean UAM_FindStringInBuffer(StringPtr inString, StringPtr inBuffer, short inBufferSize)
{
	short	i = 0;
	short	theLen;
	
	theLen = inBuffer[i];
	
	while(TRUE)
	{
		if (memcmp(&inBuffer[i], inString, theLen + 1) != 0)
		{
			i += theLen + 1;
			theLen = inBuffer[i];
			
			if (i >= inBufferSize)
				break;
		}
		else {
			return(TRUE);
		}
	}
	
	return(FALSE);
}


// ---------------------------------------------------------------------------
//		 UAM_AppleShareVersion()
// ---------------------------------------------------------------------------
//	Returns the version of AppleShare running on the host computer.

short UAM_AppleShareVersion(short *upperWord)
{
	long	theResult;
	OSErr	theError;
	
	theError = Gestalt(gestaltAFPClient, &theResult);
	if (!theError)
	{
		if (upperWord != NULL) {
			*upperWord = (theResult & gestaltAFPClientAttributeMask);
		}
		
		return(theResult & gestaltAFPClientVersionMask);
	}
	
	return(0);
}


// ---------------------------------------------------------------------------
//		 UAM_KeyDown()
// ---------------------------------------------------------------------------
//	Returns TRUE if the passed keycode is currently held down.

Boolean UAM_KeyDown(Int16 inKeycode)
{
	KeyMapByteArray	theKeyMap;
	
	GetKeys((UInt32*)theKeyMap);
	return((theKeyMap[inKeycode>>3] >> (inKeycode & 7)) & 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uam_headers.h ===
// ===========================================================================
//	UAM_Headers.h		   1998 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeaders.h>		// Precompiled header of Toolbox routines
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uam_debugheaders.h ===
// ===========================================================================
//	UAM_DebugHeaders.h		   1998 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeaders.h>		// Precompiled header of Toolbox routines


	// Define all debugging symbols

#define UAMDebug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamutils.h ===
// ===========================================================================
//	UAMUtils.h 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include "ClientUAM.h"

#define STR_ChooserUserName			-16096		//User name set in sharing setup
#define STR_Sys7WorkStationName		-16413		//Workstation (computer) name set in sharing setup

#define PSTR_LENGTH(s)				s[0]

//
//Help with bitmaps...
//
#define BIT_0	0x1
#define BIT_1	0x2
#define BIT_2	0x4
#define BIT_3	0x8
#define BIT_4	0x10
#define BIT_5	0x20
#define BIT_6	0x40
#define BIT_7	0x80
#define BIT_8	0x100

//
//Some keycodes in keymap form
//
#define KEY_Shift		0x38
#define KEY_Command		0x37
#define KEY_Option		0x3A
#define KEY_Control		0x3B

//
//Help with types...
//
typedef unsigned long UInt32;
typedef unsigned short UInt16;
typedef long Int32;
typedef short Int16;
typedef void* PVOID;
typedef unsigned char UChar;
typedef UChar* PUCHAR;
typedef char* PCHAR;
typedef char* LPSTR;

//
//Prototypes for utility functions live here.
//
	
void 		UAM_PStrCopy(const StringPtr inSrcString, StringPtr inDestString);
void		UAM_AppendPStr(Str255 inBase, const Str255 inAppendStr, short inDestSize);
void 		UAM_FrontWindowRect(Rect *outWindowRect);
void 		UAM_GetUserName(StringPtr outUserName);
void 		UAM_GetWorkStationName(Str255 outWSName);
Boolean 	UAM_AFPClientSupportsOurUAM(void);
void		UAM_VersionString(Str32 outVersionString);
void 		UAM_GetAFPVersionString(	AFPSrvrInfo 			*inInfo,
										ClientUAMCallbackRec 	*inCallbacks,
										Str32					&ioAFPVersion,
										Str32					&ioDefaultUserName	);
Boolean 	UAM_FindStringInBuffer(StringPtr inString, StringPtr inBuffer, short inBufferSize);
short 		UAM_AppleShareVersion(short *upperWord = NULL);
Boolean 	UAM_KeyDown(Int16 inKeycode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\uamnetwork.c ===
// ===========================================================================
//	UAMNetwork.c 				 1997 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Networking functions for use by Microsoft User Authentication Method.
// ===========================================================================

#include <Errors.h>
#include <AppleTalk.h>
#include <String.h>

#include "encrypt.h"
#include "UAMDebug.h"
#include "UAMMain.h"
#include "UAMNetwork.h"
#include "UAMUtils.h"
#include "UAMDialogs.h"

short					gSessionRefNum;
MSUAMLoginReplyBlock	gMSUAMReply;

extern Str32			gAFPVersion;


// ---------------------------------------------------------------------------
//		 UAM_GetSupportedUAMS()
// ---------------------------------------------------------------------------
//	Returns a bitmap containing the UAMs supported on the server.
//
//	->	inReplyInfo			Pointer to reply info supplied by ASPGetStatus() call.
//	<-	outSupportedUAMS	Bitmap containing supported UAMs:
//								- Clear Text Password (Apple)
//								- Guest (Apple and MS)
//								- Microsoft V1.0
//
//	As per Inside AppleTalk p.13-96, the supported UAM string variable list structure:
//
//		|-------------------|
//		|   Count of UAMs   |
//		|-------------------|
//		|					|
//							
//			 UAM Strings	
//							
//		|					|
//		|-------------------|

void UAM_GetSupportedUAMS(ServerInfoReplyBlockP inReplyInfo, long *ioSupported)
{
	char			*theString;
	register short	theIndex;
	register short	theUAMCount;
	
	Assert_(inReplyInfo != NULL);
	Assert_(ioSupported != NULL);
	
	theString 	= ((char *)inReplyInfo) + inReplyInfo->supportedUAMOffset;
	theUAMCount	= *theString;
	
	//
	//The first byte is the UAM count, so we must increment past it.
	// 
	++theString;
	
	//
	//Initialize the return struct to all false.
	//
	*ioSupported = 0L;

	for (theIndex = theUAMCount; theIndex > 0; theIndex--, theString += theString[0] + 1)
	{
		if (EqualString(PSTR_ClearTextLogin, (StringPtr)theString, false, false))
		{
			*ioSupported |= kClearTxtSupported;
			continue;
		}
		
		if (EqualString(PSTR_GuestLogin, (StringPtr)theString, false, false))
		{
			*ioSupported |= kGuestSupported;
			continue;
		}
		
		if (EqualString(PSTR_EncryptedLogin1_0, (StringPtr)theString, false, false))
		{
			*ioSupported |= kMSUAMSupported;
			continue;
		}
		
		if (EqualString(PSTR_EncryptedLogin2_0, (StringPtr)theString, false, false))
		{
			*ioSupported |= kMSUAM_V2_Supported;
			continue;
		}
	}
}


// ---------------------------------------------------------------------------
//		 UAM_MapCharactersIntoHostSet()
// ---------------------------------------------------------------------------
//	Given a counted string, and a "host mapping table", do an in-place conversion
//	of that string into the host character set.  The table is construed to be
//	of length 255 - StartingExtendedCharValue chars long, and a character for
//	character conversion will be indicated for any chars in targetStr which 
//	are equal to or in excess of StartingExtendedCharValue.

Boolean UAM_MapCharactersIntoHostSet(char *szTarg, char *mappingTbl)
{
	unsigned char c;
		
	while (*szTarg)	
	{
		if ((unsigned char)*szTarg >= (unsigned char)kStartingExtendedCharValue)
		{
			c = *(mappingTbl+ (unsigned char)*szTarg - kStartingExtendedCharValue);
			if (c == kIllegalMappedExtChar) {
				DbgPrint_((DBGBUFF, "Illegal mapping character"));
				return(false);
			}
			else {
				*szTarg = c;
			}
		}
		
		szTarg++;
	}
			
	return(true);
}


// ---------------------------------------------------------------------------
//		 UAM_CryptEncrypt()
// ---------------------------------------------------------------------------
//	Call on methods in Encrypt.c to encrypt the password.

void UAM_CryptEncrypt(char *inClearPassword, char *inServerChallenge, char *outEncryptPW)
{
	unsigned char theCP[22];
				
	if (SetupUAMEncrypt())
	{
		OneWayFunction((unsigned char *)inClearPassword, theCP, UAM_CLRTXTPWDLEN);
		Encrypt((unsigned char *)inServerChallenge, theCP, (unsigned char *)outEncryptPW);

		CleanupUAMEncrypt();
	}
}


// ---------------------------------------------------------------------------
//		 UAM_DoublePasswordEncrypt()
// ---------------------------------------------------------------------------
//	Taken from the NT RtlXXX sources, this algorithm is designed to deal with the encryption
//	of two passwords, when the OneWayFunction of one is known on the target.  Specifically,
//	
//		for passwords x, y 
//	-- do a one way encryption of x  to Owf(x) -> result(0..15)
//	-- do a one way encryption of  y to Owf(x) -> result(16..31)

void UAM_DoublePasswordEncrypt(char *inCPPassword, char *inCPKeyPass, char *outDest)
{
	if (SetupUAMEncrypt())
	{
		OneWayFunction((unsigned char *)inCPPassword, (unsigned char *)outDest, UAM_CLRTXTPWDLEN);
		OneWayFunction((unsigned char *)inCPKeyPass, (unsigned char *)(outDest + kOneWayEncryptedArgSize), UAM_CLRTXTPWDLEN);
		
		CleanupUAMEncrypt();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\usrpwst3.c ===
/*****************************************************************/
/**                  Microsoft Windows 2000                     **/
/**           Copyright (C) Microsoft Corp., 1991-1998          **/
/*****************************************************************/

/*****************************************************************/
/**                       Microsoft Windows                     **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1991          **/
/********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "USRPWST3.h"

// ---------------------------------------------------------------------------
//		 EncryptStdBlock()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes a block key encrypts the standard text block with it.
//    The resulting encrypted block is returned.
//    This is a One-Way-Function - the key cannot be recovered from the
//    encrypted data block.
//
//	Arguments:
//
//    BlockKey - The key to use to encrypt the standard text block.
//
//    CypherBlock - The encrypted data is returned here
//
//	Return Values:
//
//    TRUE - The encryption was successful.
//           The result is in CypherBlock
//
//    FALSE - Something failed. The CypherBlock is undefined.

bool EncryptStdBlock(
    		IN 	PBLOCK_KEY 		BlockKey,
    		OUT PCYPHER_BLOCK 	CypherBlock	 )
{
    unsigned 	Result;
    char 		StdEncrPwd[] = "KGS!@#$%";

    Result = DES_ECB_LM((DWORD)ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)StdEncrPwd,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


// ---------------------------------------------------------------------------
//		 CalculateLmOwfPassword()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes the passed LmPassword and performs a one-way-function on it.
//    The current implementation does this by using the password as a key
//    to encrypt a known block of text.
//
//	Arguments:
//
//    LmPassword - The password to perform the one-way-function on.
//
//    LmOwfPassword - The hashed password is returned here
//
//	Return Values:
//
//    BOOL - The function was completed successfully. The hashed
//                     password is in LmOwfPassword.
//
//    FALSE - Something failed. The LmOwfPassword is undefined.

bool CalculateLmOwfPassword(
    		IN 		PLM_PASSWORD 		LmPassword,
    		OUT 	PLM_OWF_PASSWORD 	LmOwfPassword )
{
    bool        Status;
    BLOCK_KEY   Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    // Use the keys to encrypt the standard text

    Status = EncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));

    if (!Status) {
        return(Status);
    }

	//*****************************************************
	//BUGBUG: Alignment work-around needed for 68K, may not
	//work under PowerPC!
	//*****************************************************
	PBLOCK_KEY pK = (PBLOCK_KEY)(((PUCHAR)&Key[1])-1);
    Status = EncryptStdBlock(pK /*&Key[1]*/, &(LmOwfPassword->data[1]));

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(Status);
}


// ---------------------------------------------------------------------------
//		 EncryptBlock()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes a block of data and encrypts it with a key producing
//    an encrypted block of data.
//
//	Arguments:
//
//    ClearBlock - The block of data that is to be encrypted.
//
//    BlockKey - The key to use to encrypt data
//
//    CypherBlock - Encrypted data is returned here
//
//	Return Values:
//
//    TRUE - The data was encrypted successfully. The encrypted
//                     data block is in CypherBlock
//
//    FALSE - Something failed. The CypherBlock is undefined.

bool EncryptBlock(
    	IN 	PCLEAR_BLOCK 	ClearBlock,
    	IN 	PBLOCK_KEY 		BlockKey,
    	OUT PCYPHER_BLOCK 	CypherBlock )
{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


// ---------------------------------------------------------------------------
//		 EncryptLmOwfPwdWithLmOwfPwd()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Encrypts one OwfPassword with another
//
//	Arguments:
//
//    DataLmOwfPassword - OwfPassword to be encrypted
//
//    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption
//
//    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.
//
//	Return Values:
//
//    TRUE - The function completed successfully. The encrypted
//                     OwfPassword is in EncryptedLmOwfPassword
//
//    FALSE - Something failed. The EncryptedLmOwfPassword is undefined.

bool EncryptLmOwfPwdWithLmOwfPwd(
    	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,
    	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,
   		OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword )
{
    bool    Status;

    Status = EncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]),
                            &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                            &(EncryptedLmOwfPassword->data[0]));
        
    if (!Status) {
        return(Status);
    }
    
    //
    //*****************************************
    //****WILL PROBABLY BREAK UNDER POWERPC****
    //****This is necessary on Mac68K**********
    //****WILL PROBABLY BREAK UNDER POWERPC****
    //
    PBLOCK_KEY pK = (PBLOCK_KEY)&(KeyLmOwfPassword->data[1]);
    //pK++;
    
    //
    //Notice the "-1" in the second parameter, this is necessary to position the 
    //ptr at byte 7 in the FIRST parameter of the struct.
    //
    Status = EncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]),
                            (PBLOCK_KEY)(((PUCHAR)pK)-1),
                            &(EncryptedLmOwfPassword->data[1]));
    //
    //*****************************************
    //
    
    return(Status);
}


// ---------------------------------------------------------------------------
//		 SampEncryptLmPasswords()
// ---------------------------------------------------------------------------
//Routine Description:
//
//    Encrypts the cleartext passwords into the form that is sent over
//    the network.  Before computing the OWF passwords, the cleartext forms
//    are upper cased, then OEMed (the order is significant).  The cleartext
//    password to be sent is OEMed only.
//
//Arguments:
//
//Return Value:

DWORD SampEncryptLmPasswords(
	    LPSTR OldUpcasePassword,
	    LPSTR NewUpcasePassword,
	    LPSTR NewPassword,
	    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
	    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm )
{
    LM_OWF_PASSWORD OldLmOwfPassword;
    LM_OWF_PASSWORD NewLmOwfPassword;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    bool Status;
    
    memset(&Rc4Key, 0, sizeof(RC4_KEYSTRUCT));

    //
    // Calculate the LM OWF passwords
    //
    Status = CalculateLmOwfPassword(
                OldUpcasePassword,
                &OldLmOwfPassword
                );
    
    if (Status)
    {
        Status = CalculateLmOwfPassword(
                    NewUpcasePassword,
                    &NewLmOwfPassword
                    );
    }

    //
    // Calculate the encrypted old passwords
    //
    if (Status)
    {
        Status = EncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    &NewLmOwfPassword,
                    OldLmOwfEncryptedWithNewLm
                    );
    }
    
    //
    // Calculate the encrypted new passwords
    //
    if (Status)
    {
        //
        // Compute the encrypted new password with LM key.
        //
        rc4_key(
            &Rc4Key,
            (DWORD)LM_OWF_PASSWORD_LENGTH,
            (PUCHAR)&OldLmOwfPassword
            );
            
        memcpy(
            ((PUCHAR) NewLm->Buffer) + (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) - strlen(NewPassword),
            NewPassword,
            strlen(NewPassword)
            );
    
    	//****************************************************
    	//BUGBUG: We must swap the significant bytes on Mac68K
    	//****************************************************
        NewLm->Length = strlen(NewPassword);
		NewLm->Length = ntoh(NewLm->Length);
	
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewLm->Buffer
            );
    }

    if (Status)
    {
        return(ERROR_SUCCESS);
    }
    else return(ERROR_INVALID_FUNCTION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\mem.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    Contains memory allocation routines.

        SnmpUtilMemAlloc
        SnmpUtilMemReAlloc
        SnmpUtilMemFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT g_nBytesTotal = 0;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
SnmpUtilMemFree(
    LPVOID pMem
    )

/*++

Routine Description:

    Releases memory used by SNMP entities.

Arguments:

    pMem - pointer to memory to release.

Return Values:

    None.

--*/

{
    // validate
    if (pMem != NULL) {

#if defined(DBG) && defined(_SNMPDLL_)

        // substract memory from global count
        g_nBytesTotal -= (UINT)GlobalSize((HGLOBAL)pMem);

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: MEM: releasing 0x%08lx (%d bytes, %d total).\n",
            pMem, GlobalSize((HGLOBAL)pMem), g_nBytesTotal
            ));

#endif

        // release memory
        GlobalFree((HGLOBAL)pMem);
    }
}


LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemAlloc(
    UINT nBytes
    )

/*++

Routine Description:

    Allocates memory used by SNMP entities.

Arguments:

    nBytes - number of bytes to allocate.

Return Values:

    Returns pointer to memory.

--*/

{
    LPVOID pMem;

    // attempt to allocate memory from process heap
    pMem = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, (DWORD)nBytes);

#if defined(DBG) && defined(_SNMPDLL_)

    // add allocated memory to global count if successful
    g_nBytesTotal += (UINT)((pMem != NULL) ? GlobalSize((HGLOBAL)pMem) : 0);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: MEM: allocated 0x%08lx (%d bytes, %d total).\n",
        pMem, (pMem != NULL) ? GlobalSize((HGLOBAL)pMem) : 0, g_nBytesTotal
        ));

#endif

    return pMem;
}


LPVOID
SNMP_FUNC_TYPE
SnmpUtilMemReAlloc(
    LPVOID pMem,
    UINT   nBytes
    )

/*++

Routine Description:

    Reallocates memory used by SNMP entities.

Arguments:

    pMem - pointer to memory to reallocate.

    nBytes - number of bytes to allocate.

Return Values:

    Returns pointer to memory.

--*/

{
    LPVOID pNew;

    // validate
    if (pMem == NULL) {

        // forward to alloc routine
        pNew = SnmpUtilMemAlloc(nBytes);

    } else {

#if defined(DBG) && defined(_SNMPDLL_)

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: MEM: expanding 0x%08lx (%d bytes) to %d bytes.\n",
            pMem, GlobalSize((HGLOBAL)pMem), nBytes
            ));

        // substract current memory from total
        g_nBytesTotal -= (UINT)GlobalSize((HGLOBAL)pMem);

#endif

        // reallocate memory
        pNew = GlobalReAlloc(
                    (HGLOBAL)pMem,
                    (DWORD)nBytes,
                    GMEM_MOVEABLE |
                    GMEM_ZEROINIT
                    );

#if defined(DBG) && defined(_SNMPDLL_)

        // add new memory to total count
        g_nBytesTotal += (UINT)((pNew != NULL) ? GlobalSize((HGLOBAL)pNew) : 0);

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: MEM: allocated 0x%08lx (%d bytes, %d total).\n",
            pNew, (pNew != NULL) ? GlobalSize((HGLOBAL)pNew) : 0, g_nBytesTotal
            ));

#endif

    }

    return pNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\ipx.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ipx.c

Abstract:

    Contains routines to manipulate ipx addresses.

        SnmpSvcAddrToSocket

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <winsock.h>
#include <wsipx.h>

#define bcopy(slp, dlp, size)   (void)memcpy(dlp, slp, size)

BOOL isHex(LPSTR str, int strLen)
    {
    int ii;

    for (ii=0; ii < strLen; ii++)
        if (isxdigit(*str))
            str++;
        else
            return FALSE;

    return TRUE;
    }

unsigned int toHex(unsigned char x)
    {
    if (x >= '0' && x <= '9')
        return x - '0';
    else if (x >= 'A' && x <= 'F')
        return x - 'A' + 10;
    else if (x >= 'a' && x <= 'f')
        return x - 'a' + 10;
    else
        return 0;
    }

// convert str to hex number of NumDigits (must be even) into pNum
void atohex(IN LPSTR str, IN int NumDigits, OUT unsigned char *pNum)
    {
    int i, j;

    j=0;
    for (i=0; i < (NumDigits>>1) ; i++)
        {
        pNum[i] = (toHex(str[j]) << 4) + toHex(str[j+1]);
        j+=2;
        }
    }

// return true if addrText is of the form 123456789ABC or
// 000001.123456789abc
// if pNetNum is not null, upon successful return, pNetNum = network number
// if pNodeNum is not null, upon successful return, pNodeNum = node number

BOOL 
SNMP_FUNC_TYPE 
SnmpSvcAddrIsIpx(
    IN  LPSTR addrText,
    OUT char pNetNum[4],
    OUT char pNodeNum[6])
    {
    int addrTextLen;

    addrTextLen = strlen(addrText);
    if (addrTextLen == 12 && isHex(addrText, 12))
        {
            if (pNetNum)
                *((UNALIGNED unsigned long *) pNetNum) = 0L;
            if (pNodeNum)
                atohex(addrText, 12, pNodeNum);
            return TRUE;
        }
    else if (addrTextLen == 21 && addrText[8] == '.' && isHex(addrText, 8) &&
            isHex(addrText+9, 12))
        {
            if (pNetNum)
                atohex(addrText, 8, pNetNum);
            if (pNodeNum)
                atohex(addrText+9, 12, pNodeNum);
            return TRUE;
        }
    else
        return FALSE;
    }

BOOL 
SNMP_FUNC_TYPE
SnmpSvcAddrToSocket(
    LPSTR addrText,
    struct sockaddr *addrEncoding
    )
{
    struct hostent * hp;
    struct sockaddr_in * pAddr_in = (struct sockaddr_in *)addrEncoding;
    struct sockaddr_ipx * pAddr_ipx = (struct sockaddr_ipx *)addrEncoding;
    unsigned long addr;

    // check for ipx addr
    if (SnmpSvcAddrIsIpx(
           addrText,
           pAddr_ipx->sa_netnum,
           pAddr_ipx->sa_nodenum
           )) {

        // see if ip host name which looks like ipx
        if ((hp = gethostbyname(addrText)) == NULL) {

            // host really is ipx machine
            pAddr_ipx->sa_family = AF_IPX;
            pAddr_ipx->sa_socket = htons(DEFAULT_SNMPTRAP_PORT_IPX);

            // address transferred above...

        } else {

            // host is really ip machine
            pAddr_in->sin_family = AF_INET;
            pAddr_in->sin_port = htons(DEFAULT_SNMPTRAP_PORT_UDP);
            pAddr_in->sin_addr.s_addr = *(unsigned long *)hp->h_addr;
        }

    } else if (strncmp(addrText, "255.255.255.255", 15) == 0) {

        // host is a broadcast address
        pAddr_in->sin_family = AF_INET;
        pAddr_in->sin_port = htons(DEFAULT_SNMPTRAP_PORT_UDP);
        pAddr_in->sin_addr.s_addr = 0xffffffff;

    } else if ((long)(addr = inet_addr(addrText)) != -1) {

        // host is ip machine
        struct servent * pServEnt = NULL;

        // attempt to get server information
        pServEnt = getservbyname("snmptrap","udp");
        
        pAddr_in->sin_family = AF_INET;
        pAddr_in->sin_port = (pServEnt != NULL)
                                ? (SHORT)pServEnt->s_port
                                : htons(DEFAULT_SNMPTRAP_PORT_UDP)
                                ;
        pAddr_in->sin_addr.s_addr = addr;

    } else if ((hp = gethostbyname(addrText)) != NULL) {

        // host is really ip machine
        struct servent * pServEnt = NULL;

        // attempt to get server information
        pServEnt = getservbyname("snmptrap","udp");

        pAddr_in->sin_family = AF_INET;
        pAddr_in->sin_port = (pServEnt != NULL)
                                ? (SHORT)pServEnt->s_port
                                : htons(DEFAULT_SNMPTRAP_PORT_UDP)
                                ;
        pAddr_in->sin_addr.s_addr = *(unsigned long *)hp->h_addr;

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: could not convert %s to socket.\n",
            addrText
            ));

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\any.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    any.c

Abstract:

    Contains routines to manipulate AsnAny structures.

        SnmpUtilAsnAnyCpy
        SnmpUtilAsnAnyFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilAsnAnyCpy(
    AsnAny * pAnyDst,
    AsnAny * pAnySrc
    )

/*++

Routine Description:

    Copy a variable value.

Arguments:

    pAnyDst - pointer to structure to receive value.

    pAnySrc - pointer to value to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_NOERROR;

    // determine asn type
    switch (pAnySrc->asnType) {

    case ASN_OBJECTIDENTIFIER:

        // copy object identifier
        nResult = SnmpUtilOidCpy(
                    &pAnyDst->asnValue.object, 
                    &pAnySrc->asnValue.object
                    );
        break;

    case ASN_OPAQUE:
    case ASN_IPADDRESS:
    case ASN_OCTETSTRING:
    case ASN_BITS:

        // copy octet string
        nResult = SnmpUtilOctetsCpy(
                    &pAnyDst->asnValue.string,
                    &pAnySrc->asnValue.string
                    );
        break;
        
    default:

        // simply transfer entire structure
        pAnyDst->asnValue = pAnySrc->asnValue;
        break;
    }

    // transfer type to destination
    pAnyDst->asnType = pAnySrc->asnType;

    return nResult;
}


VOID
SNMP_FUNC_TYPE
SnmpUtilAsnAnyFree(
    AsnAny * pAny
    )

/*++

Routine Description:

    Release memory associated with variable value.

Arguments:

    pAny - pointer to variable value to free.

Return Values:

    None. 

--*/

{
    // determine asn type
    switch (pAny->asnType) {

    case ASN_OBJECTIDENTIFIER:

        // free object identifier
        SnmpUtilOidFree(&pAny->asnValue.object);
        break;

    case ASN_OPAQUE:
    case ASN_IPADDRESS:
    case ASN_OCTETSTRING:
    case ASN_BITS:

        // free octet string
        if (pAny->asnValue.string.dynamic)
        {
            SnmpUtilOctetsFree(&pAny->asnValue.string);
            pAny->asnValue.string.dynamic = FALSE;
            pAny->asnValue.string.stream = NULL;
        }
        break;
        
    default:

        break;
    }

    // re-initialize
    pAny->asnType = ASN_NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\uam\uam5src\uamsrc\usrpwst3.h ===
/*****************************************************************/
/**                       Microsoft Windows                     **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

#pragma once

#include "ntlmsspi.h"
#include "crypto.h"
#include "descrypt.h"
#include "rc4.h"

#define __RPC_FAR

//
// From ntsam.h
//
#define SAM_MAX_PASSWORD_LENGTH 256

#define ERROR_SUCCESS			0
#define ERROR_INVALID_FUNCTION	-1070

#define ntoh(a)	((((a) << 24) & 0xFF000000) | (((a) << 8) & 0x00FF0000) | (((a) >> 8) & 0x0000FF00) | (((a) >> 24) & 0x000000FF))

//
// From sampass.h
//
typedef struct _SAMPR_USER_PASSWORD
{
	WCHAR 	Buffer[256];
	DWORD 	Length;
}SAMPR_USER_PASSWORD;

typedef struct _SAMPR_USER_PASSWORD __RPC_FAR *PSAMPR_USER_PASSWORD;
typedef struct  _SAMPR_ENCRYPTED_USER_PASSWORD
{
	UCHAR Buffer[516];
}SAMPR_ENCRYPTED_USER_PASSWORD;

typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD __RPC_FAR *PSAMPR_ENCRYPTED_USER_PASSWORD;


bool EncryptStdBlock(
    	IN 	PBLOCK_KEY 		BlockKey,
    	OUT PCYPHER_BLOCK 	CypherBlock	
);
bool CalculateLmOwfPassword(
    	IN 	PLM_PASSWORD 		LmPassword,
    	OUT PLM_OWF_PASSWORD 	LmOwfPassword
);
bool EncryptBlock(
    	IN 	PCLEAR_BLOCK 	ClearBlock,
    	IN 	PBLOCK_KEY 		BlockKey,
    	OUT PCYPHER_BLOCK 	CypherBlock
);
bool EncryptLmOwfPwdWithLmOwfPwd(
    	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,
    	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,
   		OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword
);
DWORD SampEncryptLmPasswords(
	    LPSTR OldUpcasePassword,
	    LPSTR NewUpcasePassword,
	    LPSTR NewPassword,
	    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
	    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\octets.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    octets.c

Abstract:

    Contains routines to manipulate octet strings.

        SnmpUtilOctetsCpy
        SnmpUtilOctetsFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE
SnmpUtilOctetsCpy(
    AsnOctetString * pOctetsDst,
    AsnOctetString * pOctetsSrc
    )

/*++

Routine Description:

    Copy an octet string.

Arguments:

    pOctetsDst - pointer to structure to receive octets.

    pOctetsSrc - pointer to octets to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointers
    if (pOctetsDst != NULL) {
        
        // initialize
        pOctetsDst->stream  = NULL;
        pOctetsDst->length  = 0;
        pOctetsDst->dynamic = FALSE;

        // make sure there are bytes
        if ((pOctetsSrc != NULL) &&
            (pOctetsSrc->stream != NULL) &&
            (pOctetsSrc->length != 0)) {

            // attempt to allocate octet string
            pOctetsDst->stream = SnmpUtilMemAlloc(pOctetsSrc->length);
            
            // validate pointer
            if (pOctetsDst->stream != NULL) {

                // denote allocated type
                pOctetsDst->dynamic = TRUE;

                // transfer octet string length
                pOctetsDst->length = pOctetsSrc->length;

                // copy
                memcpy(pOctetsDst->stream,
                       pOctetsSrc->stream,
                       pOctetsSrc->length
                       );

                nResult = SNMPAPI_NOERROR; // success...

            } else {
            
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: could not allocate octet string.\n"
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
            }

        } else {

            // copying null string
            nResult = SNMPAPI_NOERROR;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null octet string pointer.\n"
            ));

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nResult;
}


VOID
SNMP_FUNC_TYPE
SnmpUtilOctetsFree(
    AsnOctetString * pOctets
    )

/*++

Routine Description:

    Releases memory for an octet string.

Arguments:

    pOctets - pointer to octets to release.

Return Values:

    None. 

--*/

{
    // validate pointers
    if ((pOctets != NULL) &&
        (pOctets->stream != NULL) && 
        (pOctets->dynamic == TRUE)) {

        // release memory for octets
        SnmpUtilMemFree(pOctets->stream);

        // re-initialize
        pOctets->dynamic = FALSE;
        pOctets->stream  = NULL;
        pOctets->length  = 0;
    }
}


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOctetsNCmp(
    AsnOctetString * pOctets1, 
    AsnOctetString * pOctets2,
    UINT             nChars
    )

/*++

Routine Description:

    Compares two octet strings up to a certain number of characters.

Arguments:

    pOctets1 - pointer to first octet string.

    pOctets2 - pointer to second octet string.

    nChars - maximum characters to compare.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    UINT i = 0;
    INT nResult = 0;

    // validate pointers
    if ((pOctets1 != NULL) &&
        (pOctets2 != NULL)) {

        // calculate maximum number of subidentifiers to compare
        UINT nMaxChars = min(nChars, min(pOctets1->length, pOctets2->length));

        // loop through the subidentifiers
        while((nResult == 0) && (i < nMaxChars)) {

            // compare each subidentifier
            nResult = pOctets1->stream[i] - pOctets2->stream[i++];
        }

        // check for second being subset
        if ((nResult == 0) && (i < nChars)) {

            // determine order by length of oid
            nResult = pOctets1->length - pOctets2->length;
        }
    }
    
    return nResult;
} 


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOctetsCmp(
    AsnOctetString * pOctets1, 
    AsnOctetString * pOctets2
    )

/*++

Routine Description:

    Compares two octet strings.

Arguments:

    pOctets1 - pointer to first octet string.

    pOctets2 - pointer to second octet string.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    // forward request above
    return SnmpUtilOctetsNCmp(
                pOctets1,
                pOctets2,
                max(pOctets1->length,pOctets2->length)
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\ntfuncs.h ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ntfuncs.h

Abstract:

    Contains definitions for dynamically loaded NTDLL functions.

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _INC_NTFUNCS
#define _INC_NTFUNCS

typedef NTSYSAPI NTSTATUS 
(NTAPI * PFNNTQUERYSYSTEMINFORMATION)(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

typedef NTSYSAPI LARGE_INTEGER 
(NTAPI * PFNRTLEXTENDEDLARGEINTEGERDIVIDE)(
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

typedef NTSYSAPI BOOLEAN
(NTAPI * PFNRTLGETNTPRODUCTTYPE)(
    PNT_PRODUCT_TYPE    NtProductType
    );

#endif // _INC_NTFUNCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\dbg.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    dbg.c

Abstract:

    Contains common SNMP debugging routines.

        SnmpSvcSetLogLevel
        SnmpSvcSetLogType
        SnmpUtilDbgPrint

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <stdio.h>
#include <time.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MAX_LOG_ENTRY_LEN   512


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT g_nLogType  = SNMP_OUTPUT_TO_DEBUGGER;  
INT g_nLogLevel = SNMP_LOG_SILENT;    


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID 
OutputLogEntry(
    LPSTR pLogEntry
    )

/*++

Routine Description:

    Writes log entry to log types specified.

Arguments:

    pLogEntry - zero-terminated string containing log entry text.

Return Values:

    None. 

--*/

{
    // initialize descriptor
    static FILE * fd = NULL;

    // check if console output specified
    if (g_nLogType & SNMP_OUTPUT_TO_CONSOLE) {

        // output entry to stream
        fprintf(stdout, "%s", pLogEntry);

        // flush stream
        fflush(stdout);
    }

    // check if logfile output specified
    if (g_nLogType & SNMP_OUTPUT_TO_LOGFILE) {

        // validate    
        if (fd == NULL) {

            // attempt to open log file 
            fd = fopen("snmpdbg.log", "w");
        }

        // validate    
        if (fd != NULL) {

            // output entry to stream
            fprintf(fd, "%s", pLogEntry);

            // flush stream
            fflush(fd);
        }
    }

    // check if debugger output specified
    if (g_nLogType & SNMP_OUTPUT_TO_DEBUGGER) {

        // output entry to debugger
        OutputDebugStringA(pLogEntry);
    }

} 


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
SNMP_FUNC_TYPE
SnmpSvcSetLogLevel(
    INT nLogLevel
    )

/*++

Routine Description:

    Modifies the logging level of the SNMP process.

Arguments:

    nLogLevel - new logging level.

Return Values:

    None. 

--*/

{
    // update log level
    g_nLogLevel = nLogLevel; 
}


VOID 
SNMP_FUNC_TYPE
SnmpSvcSetLogType(
    INT nLogType
    )

/*++

Routine Description:

    Modifies the type of log used by the SNMP process.

Arguments:

    nLogType - type of log.

Return Values:

    None. 

--*/

{
    // update log type
    g_nLogType = nLogType;
}


VOID 
SNMP_FUNC_TYPE 
SnmpUtilDbgPrint(
    INT   nLogLevel, 
    LPSTR szFormat, 
    ...
    )

/*++

Routine Description:

    Prints debug message to current log types.

Arguments:

    nLogLevel - log level of message.

    szFormat - formatting string (see printf).

Return Values:

    None. 

--*/

{
    va_list arglist;

	// 640 octets should be enough to encode oid's of 128 sub-ids.
	// (one subid can be encoded on at most 5 octets; there can be at
	// 128 sub-ids per oid. MAX_LOG_ENTRY_LEN = 512
    char szLogEntry[4*MAX_LOG_ENTRY_LEN];

    // validate entry's level
    if (nLogLevel <= g_nLogLevel) {

        time_t now;

        // initialize variable args
        va_start(arglist, szFormat);

        time(&now);
        strftime(szLogEntry, MAX_LOG_ENTRY_LEN, "%H:%M:%S :", localtime(&now));

        // transfer variable args to buffer
        vsprintf(szLogEntry + strlen(szLogEntry), szFormat, arglist);

        // actually output entry
        OutputLogEntry(szLogEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\oid.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    oid.c

Abstract:

    Contains routines to manipulatee object identifiers.

        SnmpUtilOidCpy
        SnmpUtilOidAppend
        SnmpUtilOidNCmp
        SnmpUtilOidCmp
        SnmpUtilOidFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidCpy(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc  
    )

/*++

Routine Description:

    Copy an object identifier.

Arguments:

    pOidDst - pointer to structure to receive OID.

    pOidSrc - pointer to OID to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointers
    if (pOidDst != NULL) {

        // initialize
        pOidDst->ids = NULL;
        pOidDst->idLength = 0;    

        // check for subids
        if ((pOidSrc != NULL) &&
            (pOidSrc->ids != NULL) &&
            (pOidSrc->idLength != 0)) {

            // attempt to allocate the subids
            pOidDst->ids = (UINT *)SnmpUtilMemAlloc(
                                    pOidSrc->idLength * sizeof(UINT)
                                    );    

            // validate pointer
            if (pOidDst->ids != NULL) {

                // transfer the oid length
                pOidDst->idLength = pOidSrc->idLength;
                
                // transfer subids
                memcpy(pOidDst->ids, 
                       pOidSrc->ids, 
                       pOidSrc->idLength * sizeof(UINT) 
                       );         

                nResult = SNMPAPI_NOERROR; // success...    

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: could not allocate oid.\n"
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
            }

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: copying a null oid.\n"
                ));
            
            nResult = SNMPAPI_NOERROR; // success...
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null oid pointer during copy.\n"
            ));

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nResult;
} 


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidAppend(
    AsnObjectIdentifier * pOidDst,
    AsnObjectIdentifier * pOidSrc 
    )

/*++

Routine Description:

    Append source OID to destination OID

Arguments:

    pOidDst - pointer to structure to receive combined OID.

    pOidSrc - pointer to OID to append.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointers
    if (pOidDst != NULL) {

        // check if there are subids
        if ((pOidSrc != NULL) &&
            (pOidSrc->ids != NULL) &&
            (pOidSrc->idLength != 0)) {

            // calculate the total number of subidentifiers
            UINT nIds = pOidDst->idLength + pOidSrc->idLength;
            
            // validate number of subids    
            if (nIds <= SNMP_MAX_OID_LEN) {

                // attempt to allocate the subidentifiers
                UINT * pIds = (UINT *)SnmpUtilMemReAlloc(
                                            pOidDst->ids, 
                                            nIds * sizeof(UINT)
                                            );

                // validate pointer
                if (pIds != NULL) {

                    // transfer pointer
                    pOidDst->ids = pIds;

                    // transfer subids
                    memcpy(&pOidDst->ids[pOidDst->idLength], 
                           pOidSrc->ids, 
                           pOidSrc->idLength * sizeof(UINT) 
                           );

                    // transfer oid length
                    pOidDst->idLength = nIds;

                    nResult = SNMPAPI_NOERROR; // success...

                } else {

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "SNMP: API: could not allocate oid.\n"
                        ));

                    SetLastError(SNMP_MEM_ALLOC_ERROR);
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: combined oid too large.\n"
                    ));

                SetLastError(SNMP_BERAPI_OVERFLOW);
            }

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: appending a null oid.\n"
                ));
            
            nResult = SNMPAPI_NOERROR; // success...
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null oid pointer during copy.\n"
            ));

        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return nResult;
}


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidNCmp(
    AsnObjectIdentifier * pOid1, 
    AsnObjectIdentifier * pOid2,
    UINT                  nSubIds               
    )

/*++

Routine Description:

    Compares two OIDs up to a certain subidentifier.

Arguments:

    pOid1 - pointer to first OID.

    pOid2 - pointer to second OID.

    nSubIds - maximum subidentifiers to compare.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    UINT i = 0;
//    INT nResult = 0;

    // validate pointers
    if ((pOid1 != NULL) &&
        (pOid2 != NULL)) {

        // calculate maximum number of subidentifiers to compare
        UINT nMaxIds = min(nSubIds, min(pOid1->idLength, pOid2->idLength));

/*
        // loop through the subidentifiers
        while((nResult == 0) && (i < nMaxIds)) {

            // compare each subidentifier
            nResult = pOid1->ids[i] - pOid2->ids[i++];
        }
*/
		while(i < nMaxIds)
		{
			if (pOid1->ids[i] != pOid2->ids[i])
				break;
			i++;
		}

		// comparision length less then either OID lengths; components equals
		if (i == nSubIds)
			return 0;

		// difference encountered before either OID endings and before the
		// requested comparision length
		if (i < nMaxIds)
			return (pOid1->ids[i] < pOid2->ids[i])? -1 : 1;

		// one OID is shorter than the requested comparision length
		return pOid1->idLength - pOid2->idLength;
/*
        // check for second being subset
        if ((nResult == 0) && (i < nSubIds)) {

            // determine order by length of oid
            nResult = pOid1->idLength - pOid2->idLength;
        }
*/
    }
    
//    return nResult;
	return 0;
} 


SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilOidCmp(
    AsnObjectIdentifier * pOid1, 
    AsnObjectIdentifier * pOid2
    )

/*++

Routine Description:

    Compares two OIDs.

Arguments:

    pOid1 - pointer to first OID.

    pOid2 - pointer to second OID.

Return Values:

    < 0   first parameter is 'less than' second.
      0   first parameter is 'equal to' second.
    > 0   first parameter is 'greater than' second.

--*/

{
    // forward request to the function above
    return SnmpUtilOidNCmp(pOid1,pOid2,max(pOid1->idLength,pOid2->idLength));
}


VOID
SNMP_FUNC_TYPE 
SnmpUtilOidFree(
    AsnObjectIdentifier * pOid
    )

/*++

Routine Description:

    Releases memory associated with OID.

Arguments:

    pOid - pointer to OID to free.

Return Values:

    None.

--*/

{
    // validate 
    if (pOid != NULL) {

        // release subids memory
        SnmpUtilMemFree(pOid->ids);

        // re-initialize
        pOid->idLength = 0;
        pOid->ids      = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\print.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Contains printing support.

        SnmpUtilPrintOid
        SnmpUtilPrintAsnAny

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include <stdio.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID 
SNMP_FUNC_TYPE 
SnmpUtilPrintOid(
    AsnObjectIdentifier * pOid 
    )

/*++

Routine Description:

    Outputs object identifier to the console.

Arguments:

    pOid - pointer to OID to display.

Return Values:

    None. 

--*/

{
    UINT i;

    // validate oid
    if ((pOid != NULL) &&
        (pOid->ids != NULL) &&
        (pOid->idLength != 0)) {

        // output first subidentifier
        fprintf(stdout, "%lu", pOid->ids[0]);

        // loop through subidentifiers
        for (i = 1; i < pOid->idLength; i++) {

            // output next subidentifier
            fprintf(stdout, ".%lu", pOid->ids[i]);
        }
    }
} 


VOID
SNMP_FUNC_TYPE 
SnmpUtilPrintAsnAny(
    AsnAny * pAsnAny
    )

/*++

Routine Description:

    Outputs variable value to the console.

Arguments:

    pAsnAny - pointer to value structure from variable binding.

Return Values:

    None. 

--*/


{
    // validate
    if (pAsnAny != NULL) {

        // determine type    
        switch (pAsnAny->asnType) {

        case ASN_INTEGER32:
        fprintf(stdout, "Integer32 %ld\n", pAsnAny->asnValue.number);
        break;

        case ASN_UNSIGNED32:
        fprintf(stdout, "Unsigned32 %lu\n", pAsnAny->asnValue.unsigned32);
        break;

        case ASN_COUNTER32:
        fprintf(stdout, "Counter32 %lu\n", pAsnAny->asnValue.counter);
        break;

        case ASN_GAUGE32:
        fprintf(stdout, "Gauge32 %lu\n", pAsnAny->asnValue.gauge);
        break;

        case ASN_TIMETICKS:
        fprintf(stdout, "TimeTicks %lu\n", pAsnAny->asnValue.ticks);
        break;

        case ASN_COUNTER64:
        fprintf(stdout, "Counter64 %I64u\n", pAsnAny->asnValue.counter64.QuadPart);
        break;

        case ASN_OBJECTIDENTIFIER:
        {
            UINT i;

            fprintf(stdout, "ObjectID ");

            // simply forward to helper function
            SnmpUtilPrintOid(&pAsnAny->asnValue.object);

            putchar('\n');
        }
        break;

        case ASN_OCTETSTRING:
        {
            UINT i;
            BOOL bDisplayString = TRUE;
            LPSTR StringFormat;

            // loop through string looking for non-printable characters
            for (i = 0; i < pAsnAny->asnValue.string.length && bDisplayString; i++ ) {
                bDisplayString = isprint(pAsnAny->asnValue.string.stream[i]);
            }
    
            // determine string format based on results
            StringFormat = bDisplayString ? "%c" : "<0x%02x>" ;

            fprintf(stdout, "String ");

            for (i = 0; i < pAsnAny->asnValue.string.length; i++) {
                fprintf(stdout, StringFormat, pAsnAny->asnValue.string.stream[i]);
            }

            putchar('\n');
        }
        break;

        case ASN_IPADDRESS:
        {
            UINT i;

            fprintf(stdout, "IpAddress " );
            if (pAsnAny->asnValue.string.stream && (pAsnAny->asnValue.string.length == 4))
            {
            
                fprintf(stdout, "%d.%d.%d.%d ",
                    pAsnAny->asnValue.string.stream[0] ,
                    pAsnAny->asnValue.string.stream[1] ,
                    pAsnAny->asnValue.string.stream[2] ,
                    pAsnAny->asnValue.string.stream[3] 
                );
            }
            else
            {
                fprintf(stdout, "Invalid" );
            }
            putchar('\n');
        }
        break;

        case ASN_OPAQUE:
        {
            UINT i;

            fprintf(stdout, "Opaque ");

            for (i = 0; i < pAsnAny->asnValue.string.length; i++) {
                fprintf(stdout, "0x%x ", pAsnAny->asnValue.string.stream[i]);
            }

            putchar('\n');
        }
        break;

        case ASN_BITS:
        {
            UINT i;

            fprintf(stdout, "Bits ");

            for (i = 0; i < pAsnAny->asnValue.string.length; i++) {
                fprintf(stdout, "0x%x ", pAsnAny->asnValue.string.stream[i]);
            }

            putchar('\n');
        }
        break;

        case ASN_NULL:
            fprintf(stdout, "Null value\n");
            break;

        case SNMP_EXCEPTION_NOSUCHOBJECT:
            fprintf(stdout, "NOSUCHOBJECT\n");
            break;

        case SNMP_EXCEPTION_NOSUCHINSTANCE:
            fprintf(stdout, "NOSUCHINSTANCE\n");
            break;

        case SNMP_EXCEPTION_ENDOFMIBVIEW:
            fprintf(stdout, "ENDOFMIBVIEW\n");
            break;

        default:
            fprintf(stdout, "Invalid type %d\n", pAsnAny->asnType);
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\snmpapi.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpapi.c

Abstract:

    Contains entry point for SNMPAPI.DLL.

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include "ntfuncs.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD g_dwPlatformId = 0;
AsnObjectIdentifier * g_pEnterpriseOid = NULL;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Variables                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static UINT idsWindowsNTWorkstation[] = {1,3,6,1,4,1,311,1,1,3,1,1};
static UINT idsWindowsNTServer[]      = {1,3,6,1,4,1,311,1,1,3,1,2};
static UINT idsWindowsNTDC[]          = {1,3,6,1,4,1,311,1,1,3,1,3};
static UINT idsWindows[]              = {1,3,6,1,4,1,311,1,1,3,2};

static AsnObjectIdentifier oidWindowsNTWorkstation = { 
    sizeof(idsWindowsNTWorkstation)/sizeof(UINT), 
    idsWindowsNTWorkstation 
    };

static AsnObjectIdentifier oidWindowsNTServer = { 
    sizeof(idsWindowsNTServer)/sizeof(UINT), 
    idsWindowsNTServer 
    };

static AsnObjectIdentifier oidWindowsNTDC = { 
    sizeof(idsWindowsNTDC)/sizeof(UINT), 
    idsWindowsNTDC 
    };

static AsnObjectIdentifier oidWindows = { 
    sizeof(idsWindows)/sizeof(UINT), 
    idsWindows 
    };


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
InitializeEnterpriseOID(
    )

/*++

Routine Description:

    Determines the default enterprise object identifier.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

{
    NT_PRODUCT_TYPE NtProductType;

    // default to generic oid
    g_pEnterpriseOid = &oidWindows;

    // check to see if the platform is winnt
    if (g_dwPlatformId == VER_PLATFORM_WIN32_NT) {

        // assume this is just a workstation        
        g_pEnterpriseOid = &oidWindowsNTWorkstation;

      
            
        // let the system determine product type
        RtlGetNtProductType(&NtProductType);

        // point to the correct enterprise oid
        if (NtProductType == NtProductServer) {

            // this is a stand-alone server
            g_pEnterpriseOid = &oidWindowsNTServer;

        } else if (NtProductType == NtProductLanManNt) {

            // this is a PDC or a BDC
            g_pEnterpriseOid = &oidWindowsNTDC;
        }
        
    }

    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: INIT: enterprise is %s.\n", 
        SnmpUtilOidToA(g_pEnterpriseOid)
        ));

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
InitializeDLL(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

    Same as DllMain.

Return Values:

    Returns true if successful. 

--*/

{
    // check if new process attaching
    if (Reason == DLL_PROCESS_ATTACH) { 

        OSVERSIONINFO osInfo;    

        // initialize os info structure
        osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        // gather os info
        GetVersionEx(&osInfo);

        // save platform id for later use
        g_dwPlatformId = osInfo.dwPlatformId;

        // initialize enterprise
        InitializeEnterpriseOID();

        // turn off thread attach messages
        DisableThreadLibraryCalls(DllHandle);

    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\string.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    string.c

Abstract:

    Contains string conversion routines.

        SnmpUtilIdsToA
        SnmpUtilOidToA

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <stdio.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define MAX_STRING_LEN  512 
#define MAX_SUBIDS_LEN  16  


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

LPSTR
SNMP_FUNC_TYPE
SnmpUtilIdsToA(
    UINT * pIds, 
    UINT   nIds
    )

/*++

Routine Description:

    Converts OID subidentifiers into string.

Arguments:

    pIds - pointer to subidentifiers.

    nIds - number of subidentifiers.

Return Values:

    Returns pointer to string representation. 

--*/

{
    UINT i;
    UINT j;

    static char szBuf[MAX_STRING_LEN+MAX_SUBIDS_LEN];
	static char szId[MAX_SUBIDS_LEN];

    if ((pIds != NULL) && (nIds != 0)) {
                                     
        j = sprintf(szBuf, "%d", pIds[0]);

        for (i = 1; (i < nIds) && (j < MAX_STRING_LEN); i++) {
			j += sprintf(szId, ".%d", pIds[i]);
			if (j >= (MAX_STRING_LEN + MAX_SUBIDS_LEN)-3)
			{
				strcat(szBuf, "...");
				break;
			}
            else
				strcat(szBuf, szId);
        }

    } else {
                        
        sprintf(szBuf, "<null oid>");
    }

    return szBuf;
} 


LPSTR
SNMP_FUNC_TYPE
SnmpUtilOidToA(
    AsnObjectIdentifier * pOid
    )

/*++

Routine Description:

    Converts OID into string.

Arguments:

    pOid - pointer to object identifier.

Return Values:

    Returns pointer to string representation. 

--*/

{
    UINT * pIds = NULL;
    UINT   nIds = 0;

    if (pOid != NULL) {

        pIds = pOid->ids;
        nIds = pOid->idLength;
    }

    return SnmpUtilIdsToA(pIds, nIds); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\uptime.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    uptime.c

Abstract:

    Contains routines to calculate sysUpTime.

        SnmpSvcInitUptime
        SnmpSvcGetUptime
        SnmpSvcGetUptimeFromTime

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>
#include <ntfuncs.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD g_dwUpTimeReference = 0;
LONGLONG g_llUpTimeReference = 0;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define INVALID_UPTIME  0xFFFFFFFF


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
SNMP_FUNC_TYPE 
SnmpSvcInitUptime(
    )

/*++

Routine Description:

    Initializes sysUpTime reference for SNMP process.

Arguments:

    None.

Return Values:

    Returns sysUpTime reference to pass to subagents. 

--*/

{
    NTSTATUS NtStatus;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    // obtain reference the outdated way
    g_dwUpTimeReference = GetCurrentTime();


    // query time in spiffy new precise manner        
    NtStatus = NtQuerySystemInformation(
                        SystemTimeOfDayInformation,
                        &TimeOfDay,
                        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                        NULL
                        );
        
    // validate return code
    if (NT_SUCCESS(NtStatus)) {

        // initialize higher precision startup time         
        g_llUpTimeReference = TimeOfDay.CurrentTime.QuadPart;
    }
    

    //
    // The algorithm for subagents to calculate sysUpTime
    // is based on GetCurrentTime() which returns the time 
    // in milliseconds and therefore wraps every 49.71 days.
    // RFC1213 specifies that sysUpTime is to be returned in
    // centaseconds but we cannot break existing subagents.
    // The old value is returned to the master agent here 
    // but newer subagents should use SnmpUtilGetUpTime.
    //

    return g_dwUpTimeReference;
} 


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptime(
    )

/*++

Routine Description:

    Retrieves sysUpTime for SNMP process.

Arguments:

    None.

Return Values:

    Returns sysUpTime value for use by subagents. 

--*/

{
    DWORD dwUpTime = INVALID_UPTIME;
        
    NTSTATUS NtStatus;
    SYSTEM_TIMEOFDAY_INFORMATION TimeOfDay;

    // query time in spiffy new precise manner        
    NtStatus = NtQuerySystemInformation(
                        SystemTimeOfDayInformation,
                        &TimeOfDay,
                        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                        NULL
                        );
        
    // validate return code
    if (NT_SUCCESS(NtStatus)) {
        LARGE_INTEGER liUpTime;
        LARGE_INTEGER liUpTimeInCentaseconds;

        // calculate difference from reference
        liUpTime.QuadPart = TimeOfDay.CurrentTime.QuadPart - 
                                                    g_llUpTimeReference;
                                    
        // convert 100ns units (10^-7) into centasecond units (10^-2)
        liUpTimeInCentaseconds = RtlExtendedLargeIntegerDivide(
                                            liUpTime,
                                            100000,
                                            NULL
                                            );

        // convert large integer to dword value
        dwUpTime = (DWORD)(LONGLONG)liUpTimeInCentaseconds.QuadPart;
    
    } else if (g_dwUpTimeReference != 0) {

        // calculate difference from reference
        dwUpTime = (GetCurrentTime() - g_dwUpTimeReference) / 10;
    }

    return dwUpTime;
}

DWORD
SNMP_FUNC_TYPE
SnmpSvcGetUptimeFromTime(
    DWORD dwUpTime
    )

/*++

Routine Description:

    Retrieves sysUpTime value for a given tick count.

Arguments:

    dwUpTime - stack uptime (in centaseconds) to convert to sysUpTime

Return Values:

    Returns sysUpTime value for use by subagents.

--*/

{
    DWORD dwUpTimeReferenceInCentaseconds;

    // convert 100ns units (10^-7) into centasecond units (10^-2)
    dwUpTimeReferenceInCentaseconds = (DWORD)(g_llUpTimeReference / 100000);

    if (dwUpTime < dwUpTimeReferenceInCentaseconds) {
        return 0;
    }

    // calculate difference from reference
    return dwUpTime - dwUpTimeReferenceInCentaseconds;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\snmptfx.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    snmptfx.c

Abstract:

    Provides common varbind resolution functionality for subagents.

Environment:

    User Mode - Win32

Revision History:

    02-Oct-1996 DonRyan
        Moved from extensible agent in anticipation of SNMPv2 SPI.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>
#include <snmpexts.h>
#include <winsock.h>

#define HASH_TABLE_SIZE     101
#define HASH_TABLE_RADIX    18

#define INVALID_INDEX       ((DWORD)(-1))

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private type definitions                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SnmpVarBindXlat {

    UINT                   vlIndex;  // index into view list
    UINT                   vblIndex; // index into varbind list
    SnmpMibEntry *         mibEntry; // pointer to mib information
    struct _SnmpExtQuery * extQuery; // pointer to followup query

} SnmpVarBindXlat;

typedef struct _SnmpGenericList {

    VOID * data; // context-specific pointer
    UINT   len;  // context-specific length

} SnmpGenericList;

typedef struct _SnmpTableXlat {

    AsnObjectIdentifier txOid;   // table index oid
    SnmpMibTable *      txInfo;  // table description
    UINT                txIndex; // index into table list

} SnmpTableXlat;

typedef struct _SnmpExtQuery {

    UINT              mibAction; // type of query
    UINT              viewType;  // type of view
    UINT              vblNum;    // number of varbinds
    SnmpVarBindXlat * vblXlat;   // info to reorder varbinds
    SnmpTableXlat *   tblXlat;   // info to parse table oids
    SnmpGenericList   extData;   // context-specific buffer
    FARPROC           extFunc;   // instrumentation callback

} SnmpExtQuery;

#define INVALID_QUERY ((SnmpExtQuery*)(-1))

typedef struct _SnmpExtQueryList {

    SnmpExtQuery * query;  // list of subagent queries
    UINT           len;    // number of queries in list
    UINT           action; // original query request

} SnmpExtQueryList;

typedef struct _SnmpHashNode {

    SnmpMibEntry *         mibEntry;
    struct _SnmpHashNode * nextEntry;

} SnmpHashNode;

typedef struct _SnmpTfxView {

    SnmpMibView  *  mibView;
    SnmpHashNode ** hashTable;

} SnmpTfxView;

typedef struct _SnmpTfxInfo {

    UINT          numViews;
    SnmpTfxView * tfxViews;

} SnmpTfxInfo;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
ValidateQueryList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    UINT                 q,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

UINT
OidToHashTableIndex(
    AsnObjectIdentifier * hashOid
    )

/*++

Routine Description:

    Hash function for mib entry access.

Arguments:

    hashOid - object identifer to hash into table position.

Return Values:

    Returns hash table position.

--*/

{
    UINT i;
    UINT j;

    // process each element of the oid
    for (i=0, j=0; i < hashOid->idLength; i++) {

        // determine table position by summing oid
        j = (j * HASH_TABLE_RADIX) + hashOid->ids[i];
    }

    // adjust to within table
    return (j % HASH_TABLE_SIZE);
}


VOID
FreeHashTable(
    SnmpHashNode ** hashTable
    )

/*++

Routine Description:

    Destroys hash table used for accessing views.

Arguments:

    hashTable - table of hash nodes.

Return Values:

    None.

--*/

{
    UINT i;

    SnmpHashNode * nextNode;
    SnmpHashNode * hashNode;

    if (hashTable == NULL) {
        return;
    }

    // free hash table and nodes
    for (i=0; i < HASH_TABLE_SIZE; i++) {

        // point to first item
        hashNode = hashTable[i];

        // find end of node list
        while (hashNode) {

            // save pointer to next node
            nextNode = hashNode->nextEntry;

            // free current node
            SnmpUtilMemFree(hashNode);

            // retrieve next
            hashNode = nextNode;
        }
    }

    // release table itself
    SnmpUtilMemFree(hashTable);
}


SnmpHashNode **
AllocHashTable(
    SnmpMibView * mibView
    )

/*++

Routine Description:

    Initializes view hash table.

Arguments:

    mibView - mib view information.

Return Values:

    Returns pointer to first entry if successful.

--*/

{
    UINT i;
    UINT j;

    UINT numItems;
    BOOL fInitedOk;

    SnmpMibEntry *  mibEntry;
    SnmpHashNode *  hashNode;
    SnmpHashNode ** hashTable = NULL;

    // validate parameter
    if (mibView == NULL) {
        return NULL;
    }

    // determine how many items in view
    numItems = mibView->viewScalars.len;

    // load the first entry in the view
    mibEntry = mibView->viewScalars.list;

    // allocate hash table using predefined size
    hashTable = (SnmpHashNode **)SnmpUtilMemAlloc(
                                    HASH_TABLE_SIZE * sizeof(SnmpHashNode *)
                                    );

    // make sure table is allocated
    fInitedOk = (hashTable != NULL);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: initializing hash table 0x%08lx (%d items).\n",
        hashTable,
        numItems
        ));

    // process each item in the subagent's supported view
    for (i = 0; (i < numItems) && fInitedOk; i++, mibEntry++) {

        // hash into table index
        j = OidToHashTableIndex(&mibEntry->mibOid);

        // check if table entry taken
        if (hashTable[j] == NULL) {

            // allocate new node
            hashNode = (SnmpHashNode *)SnmpUtilMemAlloc(
                            sizeof(SnmpHashNode)
                            );

            // save hash node
            hashTable[j] = hashNode;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: adding hash node 0x%08lx to empty slot %d (0x%08lx).\n",
                hashNode, j, mibEntry
                ));

        } else {

            // point to first item
            hashNode = hashTable[j];

            // find end of node list
            while (hashNode->nextEntry) {
                hashNode = hashNode->nextEntry;
            }

            // allocate new node entry
            hashNode->nextEntry = (SnmpHashNode *)SnmpUtilMemAlloc(
                                        sizeof(SnmpHashNode)
                                        );

            // re-init node to edit below
            hashNode = hashNode->nextEntry;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: adding hash node 0x%08lx to full slot %d (0x%08lx).\n",
                hashNode, j, mibEntry
                ));
        }

        // make sure allocation succeeded
        fInitedOk = (hashNode != NULL);

        if (fInitedOk) {

            // fill in node values
            hashNode->mibEntry = mibEntry;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: %s initialized hash table 0x%08lx.\n",
        fInitedOk ? "successfully" : "unsuccessfully",
        hashTable
        ));

    if (!fInitedOk) {

        // free view hash table
        FreeHashTable(hashTable);

        // reinitialize
        hashTable = NULL;
    }

    return hashTable;
}


VOID
OidToMibEntry(
    AsnObjectIdentifier * hashOid,
    SnmpHashNode **       hashTable,
    SnmpMibEntry **       mibEntry
    )

/*++

Routine Description:

    Returns mib entry associated with given object identifier.

Arguments:

    hashOid   - oid to convert to table index.
    hashTable - table to look up entry.
    mibEntry  - pointer to mib entry information.

Return Values:

    None.

--*/

{
    UINT i;
    SnmpHashNode * hashNode;
    AsnObjectIdentifier newOid;

    // create index
    i = OidToHashTableIndex(hashOid);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: searching hash table 0x%08lx slot %d for %s.\n",
        hashTable, i, SnmpUtilOidToA(hashOid)
        ));

    // retrieve node
    hashNode = hashTable[i];

    // initialize
    *mibEntry = NULL;

    // search list
    while (hashNode) {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: searching hash node 0x%08lx (mibe=0x%08lx) - %s.\n",
            hashNode, hashNode->mibEntry,
            SnmpUtilOidToA(&hashNode->mibEntry->mibOid)
            ));

        // retrieve mib identifier
        newOid = hashNode->mibEntry->mibOid;

        // make sure that the oid matches
        if (!SnmpUtilOidCmp(&newOid, hashOid)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: returning mib entry 0x%08lx.\n",
                hashNode->mibEntry
                ));

            // return node data
            *mibEntry = hashNode->mibEntry;
            return;

        }

        // check next node
        hashNode = hashNode->nextEntry;
    }
}


int
ValidateInstanceIdentifier(
    AsnObjectIdentifier * indexOid,
    SnmpMibTable *        tableInfo
    )

/*++

Routine Description:

    Validates that oid can be successfully parsed into index entries.

Arguments:

    indexOid  - object indentifier of potential index.
    tableInfo - information describing conceptual table.

Return Values:

    Returns the comparision between the length of the indexOid
    and the cumulated lengths of all the indices of the table tableInfo.
    {-1, 0, 1}

--*/

{
    UINT i = 0;
    UINT j = 0;

    int nComp;

    BOOL fFixed;
    BOOL fLimit;
    BOOL fIndex;

    SnmpMibEntry * mibEntry;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: validating index %s via table 0x%08lx.\n",
        SnmpUtilOidToA(indexOid), tableInfo
        ));

    // see if the table indices are specified
    fIndex = (tableInfo->tableIndices != NULL);

    // scan mib entries of table indices ensuring match of given oid
    for (i = 0; (i < tableInfo->numIndices) && (j < indexOid->idLength); i++) {

        // get mib entry from table or directly
        mibEntry = fIndex ?  tableInfo->tableIndices[i]
                          : &tableInfo->tableEntry[i+1]
                          ;

        // determine type
        switch (mibEntry->mibType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:
        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // increment fixed length
                j += mibEntry->mibMaximum;

            } else if (fLimit) {

                // check whether the length of the variable is valid
                if (((INT)indexOid->ids[j] >= mibEntry->mibMinimum) &&
                    ((INT)indexOid->ids[j] <= mibEntry->mibMaximum)) {

                    // increment given length
                    j += (indexOid->ids[j] + 1);

                } else {

                    // invalidate
                    j = INVALID_INDEX;
                }

            } else {

                // increment given length
                j += (indexOid->ids[j] + 1);
            }

            break;

        // implicit fixed size
        case ASN_RFC1155_IPADDRESS:
            // increment
            j += 4;
            break;

        case ASN_RFC1155_COUNTER:
        case ASN_RFC1155_GAUGE:
        case ASN_RFC1155_TIMETICKS:
        case ASN_INTEGER:
            // increment
            j++;
            break;

        default:
            // invalidate
            j = INVALID_INDEX;
            break;
        }
    }

    if (i<tableInfo->numIndices)
        nComp = -1;
    else if (j < indexOid->idLength)
        nComp = 1;
    else if (j > indexOid->idLength)
        nComp = -1;
    else
        nComp = 0;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: ValidateInstanceIdentifier; OID %s %s table indices.\n",
        SnmpUtilOidToA(indexOid),
        nComp > 0 ? "over-covers" : nComp < 0 ? "shorter than" : "matches"
        ));

    return nComp;
}


VOID
ValidateAsnAny(
    AsnAny *       asnAny,
    SnmpMibEntry * mibEntry,
    UINT           mibAction,
    UINT *         errorStatus
    )

/*++

Routine Description:

    Validates asn value with given mib entry.

Arguments:

    asnAny      - value to set.
    mibEntry    - mib information.
    mibAction   - mib action to be taken.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    BOOL fLimit;
    BOOL fFixed;

    INT asnLen;

    BOOL fOk = TRUE;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: validating value for %s request using entry 0x%08lx.\n",
        (mibAction == MIB_ACTION_SET) ? "write" : "read", mibEntry
        ));

    // validating gets is trivial
    if (mibAction != MIB_ACTION_SET) {

        // validate instrumentation info
        if ((mibEntry->mibGetBufLen == 0) ||
            (mibEntry->mibGetFunc == NULL) ||
           !(mibEntry->mibAccess & MIB_ACCESS_READ)) {

            // variable is not available for reading
            *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: entry 0x%08lx not read-enabled.\n",
                mibEntry
                ));

            return; // bail...
        }

    } else {

        // validate instrumentation info
        if ((mibEntry->mibSetBufLen == 0) ||
            (mibEntry->mibSetFunc == NULL) ||
           !(mibEntry->mibAccess & MIB_ACCESS_WRITE)) {

            // variable is not avaiLable for writing
            *errorStatus = SNMP_ERRORSTATUS_NOTWRITABLE;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: entry 0x%08lx not write-enabled.\n",
                mibEntry
                ));

            return; // bail...
        }

        if (mibEntry->mibType != asnAny->asnType)
        {
            *errorStatus = SNMP_ERRORSTATUS_BADVALUE;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: entry 0x%08lx doesn't match the asnType",
                mibEntry));

            return; // bail...
        }

        // check whether this is a fixed length variable or not
        fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
        fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

        // determine value type
        switch (asnAny->asnType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:

            // retrieve the objects id length
            asnLen = asnAny->asnValue.object.idLength;

            // fixed?
            if (fFixed) {

                // make sure the length is correct
                fOk = (asnLen == mibEntry->mibMaximum);

            } else if (fLimit) {

                // make sure the length is correct
                fOk = ((asnLen >= mibEntry->mibMinimum) &&
                       (asnLen <= mibEntry->mibMaximum));
            }

            break;

        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // retrieve the arbitrary length
            asnLen = asnAny->asnValue.string.length;

            // fixed?
            if (fFixed) {

                // make sure the length is correct
                fOk = (asnLen == mibEntry->mibMaximum);

            } else if (fLimit) {

                // make sure the length is correct
                fOk = ((asnLen >= mibEntry->mibMinimum) &&
                       (asnLen <= mibEntry->mibMaximum));
            }

            break;

        case ASN_RFC1155_IPADDRESS:

            // make sure the length is correct
            fOk = (asnAny->asnValue.address.length == 4);
            break;

        case ASN_INTEGER:

            // limited?
            if (fLimit) {

                // make sure the value in range
                fOk = ((asnAny->asnValue.number >= mibEntry->mibMinimum) &&
                       (asnAny->asnValue.number <= mibEntry->mibMaximum));
            }

            break;

        default:
            // error...
            fOk = FALSE;
            break;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: value is %s using entry 0x%08lx.\n",
        fOk ? "valid" : "invalid", mibEntry
        ));

    // report results
    *errorStatus = fOk
                    ? SNMP_ERRORSTATUS_NOERROR
                    : SNMP_ERRORSTATUS_BADVALUE
                    ;
}


VOID
FindMibEntry(
    SnmpTfxInfo *    tfxInfo,
    RFC1157VarBind * vb,
    SnmpMibEntry **  mibEntry,
    UINT *           mibAction,
    SnmpTableXlat ** tblXlat,
    UINT             vlIndex,
    UINT *           errorStatus
    )

/*++

Routine Description:

    Locates mib entry associated with given varbind.

Arguments:

    tfxInfo     - context info.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;

    UINT newIndex;
    UINT numItems;
    UINT numTables;

    BOOL fFoundOk;
    int  indexComp;

    AsnObjectIdentifier hashOid;
    AsnObjectIdentifier indexOid;
    AsnObjectIdentifier * viewOid;

    SnmpMibTable  * viewTables;
    SnmpTfxView   * tfxView;

    SnmpMibEntry  * newEntry = NULL;
    SnmpTableXlat * newXlat  = NULL;

    // initialize
    *mibEntry = NULL;
    *tblXlat  = NULL;

    // retrieve view information
    tfxView = &tfxInfo->tfxViews[vlIndex];

    // retrieve view object identifier
    viewOid = &tfxView->mibView->viewOid;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: FindMibEntry; comp(%s, ",
        SnmpUtilOidToA(&vb->name)
        ));

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "%s).\n",
        SnmpUtilOidToA(viewOid)
        ));

    // if the prefix exactly matchs it is root oid
    if (!SnmpUtilOidCmp(&vb->name, viewOid)) {
        SNMPDBG((SNMP_LOG_VERBOSE, "SNMP: TFX: requested oid is root.\n"));
        *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
        return;
    }

    // if the prefix does not match it is not in hash table
    if (SnmpUtilOidNCmp(&vb->name, viewOid, viewOid->idLength)) {
        SNMPDBG((SNMP_LOG_TRACE, "SNMP: TFX: requested oid not in view.\n"));
        *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
        return;
    }

    // construct new oid sans root prefix
    hashOid.ids = &vb->name.ids[viewOid->idLength];
    hashOid.idLength = vb->name.idLength - viewOid->idLength;

    // retrieve mib entry and index via hash table
    OidToMibEntry(&hashOid, tfxView->hashTable, &newEntry);

    // check if mib entry found
    fFoundOk = (newEntry != NULL);

    // try mib tables
    if (!fFoundOk) {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: searching mib tables for %s.\n",
            SnmpUtilOidToA(&hashOid)
            ));

        // retrieve mib table information
        numTables  = tfxView->mibView->viewTables.len;
        viewTables = tfxView->mibView->viewTables.list;

        // scan mib tables for a match to the given oid
        for (i=0; (i < numTables) && !fFoundOk; i++, viewTables++) {

            // retrieve entry for table entry
            numItems = viewTables->numColumns;
            newEntry = viewTables->tableEntry;

            if (!SnmpUtilOidNCmp(
                    &hashOid,
                    &newEntry->mibOid,
                    newEntry->mibOid.idLength)) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: TFX: searching table 0x%08lx (%s).\n",
                    newEntry, SnmpUtilOidToA(&newEntry->mibOid)
                    ));

                // next
                ++newEntry;

                // scan mib table entries for a match
                for (j=0; j < numItems; j++, newEntry++) {

                    // compare with oid of table entry
                    if (!SnmpUtilOidNCmp(
                            &hashOid,
                            &newEntry->mibOid,
                            newEntry->mibOid.idLength)) {

                        SNMPDBG((
                            SNMP_LOG_VERBOSE,
                            "SNMP: TFX: validating mib entry 0x%08lx (%s).\n",
                            newEntry, SnmpUtilOidToA(&newEntry->mibOid)
                            ));

                         // construct new oid sans table entry prefix
                        indexOid.ids =
                            &hashOid.ids[newEntry->mibOid.idLength];
                        indexOid.idLength =
                            hashOid.idLength - newEntry->mibOid.idLength;

                        // verify rest of oid is valid index
                        indexComp = ValidateInstanceIdentifier(
                                        &indexOid,
                                        viewTables
                                        );
                        fFoundOk = (indexComp < 0 && *mibAction == MIB_ACTION_GETNEXT) ||
                                   (indexComp == 0);

                        // is index?
                        if (fFoundOk) {

                            SNMPDBG((
                                SNMP_LOG_VERBOSE,
                                "SNMP: TFX: saving index oid %s.\n",
                                SnmpUtilOidToA(&indexOid)
                                ));

                            // alloc a table traslation entry only if the object is accessible
                            if (newEntry->mibAccess != MIB_ACCESS_NONE)
                            {
                                // allocate table translation structure
                                newXlat = (SnmpTableXlat *)SnmpUtilMemAlloc(
                                                sizeof(SnmpTableXlat)
                                                );
                                // Prefix bug # 445169
                                if (newXlat != NULL)
                                {
                                    // save table information
                                    newXlat->txInfo  = viewTables;
                                    newXlat->txIndex = i;

                                    // copy index object identifier
                                    SnmpUtilOidCpy(&newXlat->txOid, &indexOid);
                                }       
                                else
                                {
                                    // report memory allocation problem
                                    SNMPDBG((
                                            SNMP_LOG_ERROR,
                                            "SNMP: TFX: unable to allocate memory.\n"
                                            ));
                                    *errorStatus = SNMP_ERRORSTATUS_GENERR;
                                    return; // bail...
                                }
                            }

                            break; // finished...
                        }
                    }
                }
            }
        }

    } else {

        UINT newOff;

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: searching mib tables for %s.\n",
            SnmpUtilOidToA(&hashOid)
            ));

        // retrieve mib table information
        numTables  = tfxView->mibView->viewTables.len;
        viewTables = tfxView->mibView->viewTables.list;

        // scan mib tables for an entry in table
        for (i=0; i < numTables; i++, viewTables++) {

            // columns are positioned after entry
            if (newEntry > viewTables->tableEntry) {

                // calculate the difference between pointers
                newOff = (UINT)((ULONG_PTR)newEntry - (ULONG_PTR)viewTables->tableEntry);

                // calculate table offset
                newOff /= sizeof(SnmpMibEntry);

                // determine if entry within region
                if (newOff <= viewTables->numColumns &&
                    newEntry->mibAccess != MIB_ACCESS_NONE) {

                    // allocate table translation structure
                    newXlat = (SnmpTableXlat *)SnmpUtilMemAlloc(
                                    sizeof(SnmpTableXlat)
                                    );
                    // Prefix bug # 445169
                    if (newXlat != NULL)
                    {
                        // save table information
                        newXlat->txInfo  = viewTables;
                        newXlat->txIndex = i;

                        // initialize index oid
                        newXlat->txOid.ids = NULL;
                        newXlat->txOid.idLength = 0;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: TFX: mib entry is in table 0x%08lx (%s).\n",
                            viewTables->tableEntry,
                            SnmpUtilOidToA(&viewTables->tableEntry->mibOid)
                            ));

                        break; // finished...
                    }
                    else
                    {
                        // report memory allocation problem
                        SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: TFX: unable to allocate memory.\n"
                                ));
                        *errorStatus = SNMP_ERRORSTATUS_GENERR;
                        return; // bail...
                    }
                }
            }
        }
    }

    // found entry?
    if (fFoundOk) {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: FindMibEntry; found %s\n",
            SnmpUtilOidToA(&newEntry->mibOid)
            ));
        // pass back results
        *mibEntry = newEntry;
        *tblXlat  = newXlat;

    } else {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: unable to exactly match varbind.\n"
            ));

        // unable to locate varbind in mib table
        *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
    }
}


VOID
FindNextMibEntry(
    SnmpTfxInfo *     tfxInfo,
    RFC1157VarBind *  vb,
    SnmpMibEntry **   mibEntry,
    UINT *            mibAction,
    SnmpTableXlat **  tblXlat,
    UINT              vlIndex,
    UINT *            errorStatus
    )

/*++

Routine Description:

    Locates next mib entry associated with given varbind.

Arguments:

    tfxInfo     - context info.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    UINT mibStatus;

    SnmpMibEntry  * newEntry = NULL;
    SnmpTableXlat * newXlat  = NULL;

    SnmpTfxView * tfxView;

    // table?
    if (*tblXlat) {
        SNMPDBG((SNMP_LOG_VERBOSE, "SNMP: TFX: querying table.\n"));
        return; // simply query table...
    }

    // retrieve view information
    tfxView = &tfxInfo->tfxViews[vlIndex];

    // retrieve entry
    newEntry = *mibEntry;

    // initialize
    *mibEntry = NULL;
    *tblXlat  = NULL;

    // continuing?
    if (newEntry) {
        // next
        ++newEntry;
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: searching mib at next entry 0x%08lx (%s).\n",
            newEntry,
            SnmpUtilOidToA(&newEntry->mibOid)
            ));
    } else {
        // retrieve first mib entry in supported view
        newEntry = tfxView->mibView->viewScalars.list;
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: searching mib at first entry 0x%08lx.\n",
            newEntry
            ));
    }

    // initialize status to start search
    mibStatus = SNMP_ERRORSTATUS_NOSUCHNAME;

    // scan
   for (;; newEntry++) {

       SNMPDBG((
           SNMP_LOG_VERBOSE,
           "SNMP: TFX: FindNextMibEntry; scanning view %s ",
           SnmpUtilOidToA(&tfxView->mibView->viewOid)
           ));

       SNMPDBG((
           SNMP_LOG_VERBOSE,
           " scalar %s.\n",
           SnmpUtilOidToA(&newEntry->mibOid)
           ));

        // if last entry then we stop looking
        if (newEntry->mibType == ASN_PRIVATE_EOM) {

            SNMPDBG((SNMP_LOG_TRACE, "SNMP: TFX: encountered end of mib.\n"));

            *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
            return; // bail...
        }

        // skip over place holder mib entries
        if (newEntry->mibType != ASN_PRIVATE_NODE) {

            // validate asn value against info in mib entry
            ValidateAsnAny(&vb->value, newEntry, *mibAction, &mibStatus);

            // bail if we found a valid entry...
            if (mibStatus == SNMP_ERRORSTATUS_NOERROR) {
                break;
            }
        }
    }

    // retrieved an entry but is it in a table?
    if (mibStatus == SNMP_ERRORSTATUS_NOERROR) {

        UINT i;
        UINT newOff;
        UINT numTables;

        SnmpMibTable * viewTables;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: mib entry 0x%08lx found (%s).\n",
            newEntry, SnmpUtilOidToA(&newEntry->mibOid)
            ));

        // retrieve table information from view
        numTables  = tfxView->mibView->viewTables.len;
        viewTables = tfxView->mibView->viewTables.list;

        // scan mib tables for an entry in table
        for (i=0; i < numTables; i++, viewTables++) {

            // columns are positioned after entry
            if (newEntry > viewTables->tableEntry) {

                // calculate the difference between pointers
                newOff = (UINT)((ULONG_PTR)newEntry - (ULONG_PTR)viewTables->tableEntry);

                // calculate table offset
                newOff /= sizeof(SnmpMibEntry);

                // determine if entry within region
                if (newOff <= viewTables->numColumns) {

                    // allocate table translation structure
                    newXlat = (SnmpTableXlat *)SnmpUtilMemAlloc(
                                    sizeof(SnmpTableXlat)
                                    );
                    
                    // Prefix bug # 445169
                    if (newXlat != NULL)
                    {
                        // save table information
                        newXlat->txInfo  = viewTables;
                        newXlat->txIndex = i;

                        // initialize index oid
                        newXlat->txOid.ids = NULL;
                        newXlat->txOid.idLength = 0;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: TFX: mib entry is in table 0x%08lx (%s).\n",
                            viewTables->tableEntry,
                            SnmpUtilOidToA(&viewTables->tableEntry->mibOid)
                            ));

                        break; // finished...
                    }
                    else
                    {
                        // report memory allocation problem
                        SNMPDBG((
                                SNMP_LOG_ERROR,
                                "SNMP: TFX: unable to allocate memory.\n"
                                ));
                        
                        *errorStatus = SNMP_ERRORSTATUS_GENERR;
                        return; // bail...
                    }
                }
            }
        }

        // pass back results
        *mibEntry  = newEntry;
        *tblXlat   = newXlat;

        // update mib action of scalar getnext
        if (!newXlat && (*mibAction == MIB_ACTION_GETNEXT)) {

            *mibAction = MIB_ACTION_GET;

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: altered mib action to MIB_ACTION_GET.\n"
                ));
        }
    }

    // pass back status
    *errorStatus = mibStatus;
}


VOID
FindAnyMibEntry(
    SnmpTfxInfo *     tfxInfo,
    RFC1157VarBind *  vb,
    SnmpMibEntry **   mibEntry,
    UINT *            mibAction,
    SnmpTableXlat **  tblXlat,
    UINT              vlIndex,
    UINT *            errorStatus
    )

/*++

Routine Description:

    Locates any mib entry associated with given varbind.

Arguments:

    tfxInfo     - context info.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    BOOL fExact;
    BOOL fBefore;

    SnmpTfxView * tfxView;

    // retrieve view information
    tfxView = &tfxInfo->tfxViews[vlIndex];

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: FindAnyMibEntry; comp(%s, ",
        SnmpUtilOidToA(&vb->name)
        ));
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "%s[, %d]).\n",
        SnmpUtilOidToA(&tfxView->mibView->viewOid),
        tfxView->mibView->viewOid.idLength
        ));

    // look for oid before view
    fBefore = (0 > SnmpUtilOidNCmp(
                         &vb->name,
                         &tfxView->mibView->viewOid,
                         tfxView->mibView->viewOid.idLength
                         ));

    // look for exact match
    fExact = !fBefore && !SnmpUtilOidCmp(
                            &vb->name,
                            &tfxView->mibView->viewOid
                            );

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: fBefore=%d fExact=%d\n",
        fBefore,
        fExact
        ));
    // check for random oid...
    if (!fBefore && !fExact) {

        AsnObjectIdentifier relOid;
        AsnObjectIdentifier * viewOid;
        SnmpMibEntry * newEntry = NULL;

        // point to the first item in the list
        newEntry = tfxView->mibView->viewScalars.list;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: linear search from first entry 0x%08lx.\n",
            newEntry
            ));

        // retrieve the view object identifier
        viewOid = &tfxView->mibView->viewOid;

        // construct new oid sans root prefix
        relOid.ids = &vb->name.ids[viewOid->idLength];
        relOid.idLength = vb->name.idLength - viewOid->idLength;

        // scan mib entries
        while ((newEntry->mibType != ASN_PRIVATE_EOM) &&
               (SnmpUtilOidCmp(&relOid, &newEntry->mibOid) > 0)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: skipping %s.\n",
                SnmpUtilOidToA(&newEntry->mibOid)
                ));

            // next
            newEntry++;
        }

        // if last entry then we stop looking
        if (newEntry->mibType == ASN_PRIVATE_EOM) {

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: encountered end of mib.\n"
                ));

            *errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
            return; // bail...
        }

        // backup to find next
        *mibEntry = --newEntry;
        *tblXlat  = NULL;

        // find next
        FindNextMibEntry(
               tfxInfo,
               vb,
               mibEntry,
               mibAction,
               tblXlat,
               vlIndex,
               errorStatus
               );

    } else {

        // initialize
        *mibEntry = NULL;
        *tblXlat  = NULL;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: searching for first entry.\n"
            ));

        // find next
        FindNextMibEntry(
               tfxInfo,
               vb,
               mibEntry,
               mibAction,
               tblXlat,
               vlIndex,
               errorStatus
               );
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: FindAnyMibEntry; error %d on %s(.",
            *errorStatus,
            SnmpUtilOidToA(&tfxInfo->tfxViews[vlIndex].mibView->viewOid)
            ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "%s).\n",
            SnmpUtilOidToA(&(*mibEntry)->mibOid)
            ));
    }
}


VOID
VarBindToMibEntry(
    SnmpTfxInfo *    tfxInfo,
    RFC1157VarBind * vb,
    SnmpMibEntry **  mibEntry,
    UINT *           mibAction,
    SnmpTableXlat ** tblXlat,
    UINT             vlIndex,
    UINT *           errorStatus
    )

/*++

Routine Description:

    Locates mib entry associated with given varbind.

Arguments:

    tfxInfo     - context information.
    vb          - variable to locate.
    mibEntry    - mib entry information.
    mibAction   - mib action (may be updated).
    tblXlat     - table translation info.
    vlIndex     - index into view list.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    BOOL fAnyOk;
    BOOL fFoundOk;
    BOOL fErrorOk;

    // determine whether we need exact match
    fAnyOk = (*mibAction == MIB_ACTION_GETNEXT);

    // find match
    FindMibEntry(
        tfxInfo,
        vb,
        mibEntry,
        mibAction,
        tblXlat,
        vlIndex,
        errorStatus
        );
    
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: VarBindToMibEntry; errorStatus=%d.\n",
        *errorStatus
        ));

    // get next?
    if (fAnyOk) {

        // search again
        if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

            // find next entry
            FindNextMibEntry(
                tfxInfo,
                vb,
                mibEntry,
                mibAction,
                tblXlat,
                vlIndex,
                errorStatus
                );

        } else if (*errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME) {

            // find any entry
            FindAnyMibEntry(
                tfxInfo,
                vb,
                mibEntry,
                mibAction,
                tblXlat,
                vlIndex,
                errorStatus
                );
        }

    } else if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

        // validate asn value against mib entry information
        ValidateAsnAny(&vb->value, *mibEntry, *mibAction, errorStatus);

        // make sure valid before passing back entry
        if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {

            // table entry?
            if (*tblXlat) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: TFX: freeing index info (%s).\n",
                    SnmpUtilOidToA(&(*tblXlat)->txOid)
                    ));

                // free index oid
                SnmpUtilOidFree(&(*tblXlat)->txOid);

                // free table info
                SnmpUtilMemFree(*tblXlat);

            }

            // nullify results
            *mibEntry = NULL;
            *tblXlat  = NULL;
        }
    }
}

BOOL
CheckUpdateIndex(
    AsnObjectIdentifier *indexOid,
    UINT                nStartFrom,
    UINT                nExpecting
    )
/*++
Routine Description:

    Checks if an index OID contains all the components expected.
    If not, the index is updated to point before the very first
    OID requested.

Arguments:
    
    indexOid  - pointer to the index to be checked.
    nStartFrom - the point from where the index is checked.
    nExpecting  - the index should have at least expectTo components from startFrom.

Return value:
    TRUE if index was valid or has been updated successfully.
    FALSE otherwise (index was shorter then expected and all filled with 0s).

--*/
{
    int i;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: CheckUpdateIndex; checking %s.\n",
        SnmpUtilOidToA(indexOid)
        ));

    if (indexOid->idLength >= nStartFrom + nExpecting)
    {
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: CheckUpdateIndex; valid, unchanged.\n"
            ));

        return TRUE;
    }

    for (i = indexOid->idLength-1; i >= (int)nStartFrom; i--)
    {
        if (indexOid->ids[i] > 0)
        {
            indexOid->ids[i]--;
            indexOid->idLength = i+1;

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: CheckUpdateIndex; valid, changed to %s.\n",
                SnmpUtilOidToA(indexOid)
                ));

            return TRUE;
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: CheckUpdateIndex; invalid, to be removed.\n"
        ));

    return FALSE;
}

VOID
ParseInstanceIdentifier(
    SnmpTableXlat * tblXlat,
    AsnAny *        objArray,
    UINT            mibAction,
    UINT *          errorStatus
    )

/*++

Routine Description:

    Converts table index oid into object array.

Arguments:

    tblXlat   - table translation information.
    objArray  - instrumentation object array.
    mibAction - action requested of subagent.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;
    UINT k;
    UINT l;
    UINT m;

    BOOL fFixed;
    BOOL fLimit;
    BOOL fIndex;
    BOOL fEmpty;
    BOOL fExceed;

    UINT numItems;

    SnmpMibEntry * mibEntry;
    AsnObjectIdentifier * indexOid;

    LPDWORD lpIpAddress;

    *errorStatus = SNMP_ERRORSTATUS_NOERROR; // init return status

    // retrieve index oid
    indexOid = &tblXlat->txOid;

    // is this valid oid
    fEmpty = (indexOid->idLength == 0);

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: converting index %s to obj array via table 0x%08lx.\n",
        fEmpty ? "<tbd>" : SnmpUtilOidToA(indexOid), tblXlat->txInfo
        ));

    // retrieve root entry and entry count
    numItems = tblXlat->txInfo->numIndices;

    // see if the table indices are specified
    fIndex = (tblXlat->txInfo->tableIndices != NULL);
    fExceed = FALSE;
    // scan mib entries of table indices
    for (i=0, j=0; (i < numItems) && (j < indexOid->idLength); i++) {

        // get mib entry from table or directly
        mibEntry = fIndex ?  tblXlat->txInfo->tableIndices[i]
                          : &tblXlat->txInfo->tableEntry[i+1]
                          ;

        // retrieve array index
        k = (mibAction == MIB_ACTION_SET)
                ? (UINT)(CHAR)mibEntry->mibSetBufOff
                : (UINT)(CHAR)mibEntry->mibGetBufOff
                ;

        // determine type
        switch (mibEntry->mibType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length; indexOid should have at least l components more
                l = mibEntry->mibMaximum;

                if (!CheckUpdateIndex(indexOid, j, l))
                {
                    // out from switch and for
                    j+=l;
                    break;
                }

            } else {
                // variable length
                l = indexOid->ids[j];

                if (!CheckUpdateIndex(indexOid, j, l+1))
                {
                    // out from switch and for
                    j+=l+1;
                    break;
                }
                j++;
            }

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // allocate object using length above
            objArray[k].asnValue.object.idLength = l;
            objArray[k].asnValue.object.ids = SnmpUtilMemAlloc(
                objArray[k].asnValue.object.idLength * sizeof(UINT)
                );

            if (objArray[k].asnValue.object.ids == NULL)
            {
                // report memory allocation problem
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: unable to allocate memory.\n"
                    ));
                objArray[k].asnValue.object.idLength = 0;
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                return; // bail...
            }
            // transfer data
            for (m=0; m < l; m++, j++) {

                // transfer oid element to buffer
                if (!fExceed && j < indexOid->idLength)
                {
                    objArray[k].asnValue.object.ids[m] = indexOid->ids[j];
                }
                else
                {
                    if (!fExceed)
                        fExceed = TRUE;
                    // this certainly is the last index from the request
                }

                if (fExceed)
                {
                    objArray[k].asnValue.object.ids[m] = (UINT)(-1);
                }
            }

            break;

        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length
                l = mibEntry->mibMaximum;

                if (!CheckUpdateIndex(indexOid, j, l))
                {
                    // out from switch and for
                    j+=l;
                    break;
                }

            } else {

                // variable length
                l = indexOid->ids[j];

                if (!CheckUpdateIndex(indexOid, j, l+1))
                {
                    j+=l+1;
                    break;
                }
                j++;
            }

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // allocate object
            objArray[k].asnValue.string.length = l;
            objArray[k].asnValue.string.dynamic = TRUE;
            objArray[k].asnValue.string.stream = SnmpUtilMemAlloc(
                objArray[k].asnValue.string.length * sizeof(CHAR)
                );

            if (objArray[k].asnValue.string.stream == NULL)
            {
                // report memory allocation problem
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: unable to allocate memory.\n"
                    ));
                objArray[k].asnValue.string.length = 0;
                objArray[k].asnValue.string.dynamic = FALSE;
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                return; // bail...
            }
            // transfer data
            for (m=0; m < l; m++, j++) {

                // convert oid element to character
                if (j < indexOid->idLength)
                {
                    if (!fExceed && indexOid->ids[j] <= (UCHAR)(-1))
                        objArray[k].asnValue.string.stream[m] = (BYTE)(indexOid->ids[j]);
                    else
                        fExceed=TRUE;
                }
                else
                {
                    if (!fExceed)
                        fExceed = TRUE;
                    // this certainly is the last index from the request
                }

                if (fExceed)
                {
                    objArray[k].asnValue.string.stream[m] = (UCHAR)(-1);
                }
            }

            break;

        // implicit fixed size
        case ASN_RFC1155_IPADDRESS:

            if (!CheckUpdateIndex(indexOid, j, 4))
            {
                // out from switch and for
                j+=4;
                break;
            }

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // allocate object
            objArray[k].asnValue.string.length = 4;
            objArray[k].asnValue.string.dynamic = TRUE;
            objArray[k].asnValue.string.stream = SnmpUtilMemAlloc(
                objArray[k].asnValue.string.length * sizeof(CHAR)
                );


            if (objArray[k].asnValue.string.stream == NULL)
            {
                // report memory allocation problem
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: TFX: unable to allocate memory.\n"
                    ));
                objArray[k].asnValue.string.length = 0;
                objArray[k].asnValue.string.dynamic = FALSE;
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                return; // bail...
            }

            // cast to dword in order to manipulate ip address
            lpIpAddress = (LPDWORD)objArray[k].asnValue.string.stream;


            // transfer data into buffer
            for (m=0; m<4; m++, j++)
            {
                *lpIpAddress <<= 8;

                if (!fExceed && j < indexOid->idLength)
                {
                    if (indexOid->ids[j] <= (UCHAR)(-1))
                        *lpIpAddress += indexOid->ids[j];
                    else
                        fExceed = TRUE;
                }
                else
                {
                    if (!fExceed)
                        fExceed = TRUE;
                    // this certainly is the last index from the request
                }
                if (fExceed)
                {
                    *lpIpAddress += (UCHAR)(-1);
                }
            }

            // ensure network byte order
            *lpIpAddress = htonl(*lpIpAddress);

            break;

        case ASN_RFC1155_COUNTER:
        case ASN_RFC1155_GAUGE:
        case ASN_RFC1155_TIMETICKS:
        case ASN_INTEGER:

            // copy the type of asn variable
            objArray[k].asnType = mibEntry->mibType;

            // transfer value as integer
            objArray[k].asnValue.number = fExceed ? (UINT)(-1) : indexOid->ids[j];
            j++;
            break;

        default:
            // invalidate
            j = INVALID_INDEX;
            break;
        }
    }
}



BOOL
IsTableIndex(
    SnmpMibEntry *  mibEntry,
    SnmpTableXlat * tblXlat
    )
{
    UINT newOff;
    BOOL fFoundOk = FALSE;
    BOOL fIndex;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: comparing mibEntry 0x%08lx to table 0x%08lx.\n",
        mibEntry,
        tblXlat->txInfo
        ));

    // see if the table indices are specified
    fIndex = (tblXlat->txInfo->tableIndices != NULL);

    if (fIndex) {

        // rummage through index list looking for match
        for (newOff = 0; (newOff < tblXlat->txInfo->numIndices) && !fFoundOk; newOff++ ) {

            // compare mib entry with the next specified index
            fFoundOk = (mibEntry == tblXlat->txInfo->tableIndices[newOff]);
        }

    } else {

        // make sure pointer greater than table entry
        if (mibEntry > tblXlat->txInfo->tableEntry) {

            // calculate the difference between pointers
            newOff = (UINT)((ULONG_PTR)mibEntry - (ULONG_PTR)tblXlat->txInfo->tableEntry);

            // calculate table offset
            newOff /= sizeof(SnmpMibEntry);

            // determine whether entry within region
            fFoundOk = (newOff <= tblXlat->txInfo->numIndices);
        }
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: mibEntry %s a component of the table's index (off=%d, len=%d).\n",
        fFoundOk ? "is" : "is not",
        newOff,
        tblXlat->txInfo->numIndices
        ));

    return fFoundOk;
}


VOID
MibEntryToQueryList(
    SnmpMibEntry *       mibEntry,
    UINT                 mibAction,
    SnmpExtQueryList *   ql,
    SnmpTableXlat *      tblXlat,
    UINT                 vlIndex,
    RFC1157VarBindList * vbl,
    UINT                 vb,
    UINT *               errorStatus
    )

/*++

Routine Description:

    Converts mib entry information into subagent query.

Arguments:

    mibEntry    - mib information.
    mibAction   - action to perform.
    ql          - list of subagent queries.
    tableXlat   - table translation info.
    vlIndex     - index into view list.
    vbl         - original varbind list.
    vb          - original varbind.
    errorStatus - used to indicate success or failure.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;
    UINT viewType;

    FARPROC extFunc;

    AsnAny * objArray;
    SnmpExtQuery * extQuery;

    SnmpExtQuery    * tmpExtQuery = NULL; // prefix Bug 445172
    SnmpVarBindXlat * tmpVblXlat  = NULL; // prefix Bug 445172
   

    BOOL fFoundOk = FALSE;

    // determine instrumentation callback
    extFunc = (mibAction == MIB_ACTION_SET)
                ? (FARPROC)mibEntry->mibSetFunc
                : (FARPROC)mibEntry->mibGetFunc
                ;

    // process existing queries
    for (i=0; (i < ql->len) && !fFoundOk; i++) {

        // retrieve query ptr
        extQuery = &ql->query[i];

        // determine if a similar query exists
        fFoundOk = ((extQuery->extFunc == extFunc) &&
                    (extQuery->mibAction == mibAction));

        // compare table indices (if any)
        if (fFoundOk && extQuery->tblXlat) {

            // make sure
            if (tblXlat) {

                // compare index oids...
                fFoundOk = !SnmpUtilOidCmp(
                                &extQuery->tblXlat->txOid,
                                &tblXlat->txOid
                                );

            } else {

                // hmmm...
                fFoundOk = FALSE;
            }

        }
    }

    // append entry
    if (!fFoundOk) {

        ql->len++; // add new query to end of list
        tmpExtQuery = (SnmpExtQuery *)SnmpUtilMemReAlloc(
                                            ql->query,
                                            ql->len * sizeof(SnmpExtQuery)
                                            );
        // Prefix bug 445172
        // check memory re-allocation
        if (tmpExtQuery == NULL)
        {
            if (tblXlat)
            {
                // free table oid
                SnmpUtilOidFree(&tblXlat->txOid);

                // free table info
                SnmpUtilMemFree(tblXlat);
            }
            ql->len--; // rollback
            // report memory allocation problem
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return; // bail...
        }
        ql->query = tmpExtQuery;

        // retrieve new query pointer
        extQuery = &ql->query[ql->len-1];

        // save common information
        extQuery->mibAction = mibAction;
        extQuery->viewType  = MIB_VIEW_NORMAL;
        extQuery->extFunc   = extFunc;

        // initialize list
        extQuery->vblNum  = 0;
        extQuery->vblXlat = NULL;

        // size the instrumentation buffer
        extQuery->extData.len = (mibAction == MIB_ACTION_SET)
                                    ? mibEntry->mibSetBufLen
                                    : mibEntry->mibGetBufLen
                                    ;
        
        // allocate the instrumentation buffer
        extQuery->extData.data = SnmpUtilMemAlloc(
                                    extQuery->extData.len
                                    );

        // check memory allocation
        if (extQuery->extData.data) {

            // table?
            if (tblXlat) {

                // retrieve object array pointer
                objArray = (AsnAny *)(extQuery->extData.data);

                // Prefix 118006
                // initialize asn array
                ParseInstanceIdentifier(tblXlat, objArray, mibAction, errorStatus);
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
                {
                    // logging...
                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: TFX: unable to ParseInstanceIdentifier with table info 0x%08lx.\n",
                        tblXlat
                        ));
                    SnmpUtilMemFree(extQuery->extData.data);
                    extQuery->extData.data = NULL; // null pointer to avoid double free or deref.
                    return; // bail
                }

                // save table info
                extQuery->tblXlat = tblXlat;
            }

        } else {

            if (tblXlat) 
            {
                // free table oid
                SnmpUtilOidFree(&tblXlat->txOid);

                // free table info
                SnmpUtilMemFree(tblXlat);
            }

            // report memory allocation problem
            *errorStatus = SNMP_ERRORSTATUS_GENERR;
            return; // bail...
        }

    } else if (tblXlat != NULL) {

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: releasing duplicate table info 0x%08lx.\n",
            tblXlat
            ));

        // free table oid
        SnmpUtilOidFree(&tblXlat->txOid);

        // free table info
        SnmpUtilMemFree(tblXlat);
    }

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: %s query 0x%08lx.\n",
        fFoundOk ? "editing" : "adding",
        extQuery
        ));

    // copy to index
    i = extQuery->vblNum;

    // allocate entry
    extQuery->vblNum++;

    tmpVblXlat = (SnmpVarBindXlat *)SnmpUtilMemReAlloc(
                            extQuery->vblXlat,
                            extQuery->vblNum * sizeof(SnmpVarBindXlat)
                            );
    if (tmpVblXlat == NULL)
    {
        // report memory allocation problem
        *errorStatus = SNMP_ERRORSTATUS_GENERR;
        extQuery->vblNum--; // rollback
        return; // bail...
    }
    extQuery->vblXlat  = tmpVblXlat;


    // copy common xlate information
    extQuery->vblXlat[i].vblIndex = vb;
    extQuery->vblXlat[i].vlIndex  = vlIndex;
    extQuery->vblXlat[i].extQuery = NULL;

    // save translation info
    extQuery->vblXlat[i].mibEntry = mibEntry;

    // determine offset used
    i = (mibAction == MIB_ACTION_SET)
          ? (UINT)(CHAR)mibEntry->mibSetBufOff
          : (UINT)(CHAR)mibEntry->mibGetBufOff
          ;

    // retrieve object array pointer
    objArray = (AsnAny *)(extQuery->extData.data);

    // fill in only asn type if get
    if (mibAction != MIB_ACTION_SET) {

        // ignore table indices
        if (extQuery->tblXlat &&
            IsTableIndex(mibEntry,extQuery->tblXlat)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: requesting index value.\n"
                ));

        } else {

            // initialize asn type to match entry
            objArray[i].asnType = mibEntry->mibType;
        }

    } else {

        // copy user-supplied value into buffer
        SnmpUtilAsnAnyCpy(&objArray[i], &vbl->list[vb].value);
    }
}


VOID
VarBindToQueryList(
    SnmpTfxInfo *        tfxInfo,
    RFC1157VarBindList * vbl,
    SnmpExtQueryList *   ql,
    UINT                 vb,
    UINT *               errorStatus,
    UINT *               errorIndex,
    UINT                 queryView
    )

/*++

Routine Description:

    Adds varbind to query list.

Arguments:

    tfxInfo     - context info.
    vbl         - list of varbinds.
    ql          - list of subagent queries.
    vb          - index of varbind to add to query.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.
    queryView   - view of query requested.

Return Values:

    None.

--*/

{
    INT i;
    INT nDiff;
    INT lastViewIndex;

    BOOL fAnyOk;
    BOOL fFoundOk = FALSE;

    UINT mibAction;

    SnmpMibView   * mibView;
    SnmpMibEntry  * mibEntry = NULL;
    SnmpTableXlat * tblXlat  = NULL;

    // copy request type
    mibAction = ql->action;

    // determine whether we need exact match
    fAnyOk = (mibAction == MIB_ACTION_GETNEXT);

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: searching subagents to resolve %s (%s).\n",
        SnmpUtilOidToA(&vbl->list[vb].name),
        fAnyOk ? "AnyOk" : "AnyNOk"
        ));

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: VarBindToQueryList; scanning views from %d to %d.\n",
        queryView,
        (INT)tfxInfo->numViews
    ));

    // init to NonView
    lastViewIndex = -1;

    // locate appropriate view (starting at queryView)
    for (i = queryView; (i < (INT)tfxInfo->numViews) && !fFoundOk; i++) {

        // retrieve the mib view information
        mibView = tfxInfo->tfxViews[i].mibView;

        // compare root oids
        nDiff = SnmpUtilOidNCmp(
                    &vbl->list[vb].name,
                    &mibView->viewOid,
                    mibView->viewOid.idLength
                    );

        // analyze results based on request type
        fFoundOk = (!nDiff || (fAnyOk && (nDiff < 0)));

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: View %d: comp(%s, ",
            i,
            SnmpUtilOidToA(&vbl->list[vb].name)
        ));
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "%s, %d) = %d '%s'\n",
            SnmpUtilOidToA(&mibView->viewOid),
            mibView->viewOid.idLength,
            nDiff,
            fFoundOk?"Found":"NotFound"
        ));


        // make sure we can obtain mib entry (if available)
        if (fFoundOk && (mibView->viewType == MIB_VIEW_NORMAL)) {

            // initialize local copy of error status
            UINT mibStatus = SNMP_ERRORSTATUS_NOERROR;

            // store index
            lastViewIndex = i;

            // load mib entry
            VarBindToMibEntry(
                   tfxInfo,
                   &vbl->list[vb],
                   &mibEntry,
                   &mibAction,
                   &tblXlat,
                   i,
                   &mibStatus
                   );

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: VarBindToMibEntry returned %d.\n",
                mibStatus
            ));

            // successfully loaded mib entry information
            fFoundOk = (mibStatus == SNMP_ERRORSTATUS_NOERROR);

            // bail if not searching...
            if (!fFoundOk && !fAnyOk) {
                // pass up error status
                *errorStatus = mibStatus;
                *errorIndex  = vb+1;
                return; // bail...
            }
        }
    }

    // reset error status and index...
    *errorStatus = SNMP_ERRORSTATUS_NOERROR;
    *errorIndex  = 0;

    // found AND had a valid mibEntry
    if (fFoundOk && mibEntry) { 
        // save query
        MibEntryToQueryList(
               mibEntry,
               mibAction,
               ql,
               tblXlat,
               i-1,
               vbl,
               vb,
               errorStatus
               );

    } else if (fAnyOk){

        if (lastViewIndex == -1)
            lastViewIndex = tfxInfo->numViews - 1;

        // not supported in any view...
        SnmpUtilOidFree(&vbl->list[vb].name);

        // copy varbind
        SnmpUtilOidCpy(
            &vbl->list[vb].name,
            &tfxInfo->tfxViews[lastViewIndex].mibView->viewOid
            );

        // increment last element of view oid
        vbl->list[vb].name.ids[(vbl->list[vb].name.idLength-1)]++;

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: changing varbind to %s.\n",
            SnmpUtilOidToA(&vbl->list[vb].name)
            ));
    }
}


VOID
VarBindListToQueryList(
    SnmpTfxInfo *        tfxInfo,
    RFC1157VarBindList * vbl,
    SnmpExtQueryList *   ql,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Convert list of varbinds from incoming pdu into a list of
    individual subagent queries.

Arguments:

    tfxInfo     - context handle.
    vbl         - list of varbinds in pdu.
    ql          - list of subagent queries.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT i; // index into varbind list

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: processing %s request containing %d variable(s).\n",
        (ql->action == MIB_ACTION_GET)
            ? "get"
            : (ql->action == MIB_ACTION_SET)
                ? "set"
                : (ql->action == MIB_ACTION_GETNEXT)
                    ? "getnext"
                    : "unknown", vbl->len));

    // initialize status return values
    *errorStatus = SNMP_ERRORSTATUS_NOERROR;
    *errorIndex  = 0;

    // process incoming variable bindings
    for (i=0; i < vbl->len; i++) 
    {
        // find varbind
        VarBindToQueryList(
            tfxInfo,
            vbl,
            ql,
            i,
            errorStatus,
            errorIndex,
            0
            );
        if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
        {
            *errorIndex = i+1; // have problem during the processing of (i+1)th varbind
            break;
        }
    }
}


UINT
MibStatusToSnmpStatus(
    UINT mibStatus
    )

/*++

Routine Description:

    Translate mib status into snmp error status.

Arguments:

    mibStatus - mib error code.

Return Values:

    Returns snmp error status.

--*/

{
    UINT errorStatus;

    switch (mibStatus) {

    case MIB_S_SUCCESS:
        errorStatus = SNMP_ERRORSTATUS_NOERROR;
        break;

    case MIB_S_INVALID_PARAMETER:
        errorStatus = SNMP_ERRORSTATUS_BADVALUE;
        break;

    case MIB_S_NOT_SUPPORTED:
    case MIB_S_NO_MORE_ENTRIES:
    case MIB_S_ENTRY_NOT_FOUND:
        errorStatus = SNMP_ERRORSTATUS_NOSUCHNAME;
        break;

    default:
        errorStatus = SNMP_ERRORSTATUS_GENERR;
        break;
    }

    return errorStatus;
}


VOID
AdjustErrorIndex(
    SnmpExtQuery * q,
    UINT *         errorIndex
    )

/*++

Routine Description:

    Ensure that indices match the original pdu.

Arguments:

    q          - subagent query.
    errorIndex - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT errorIndexOld = *errorIndex;

    // make sure within bounds
    if (errorIndexOld && (errorIndexOld <= q->vblNum)) {

        // determine proper index from xlat info
        *errorIndex = q->vblXlat[errorIndexOld-1].vblIndex+1;

    } else {

        // default to first variable
        *errorIndex = q->vblXlat[0].vblIndex+1;
    }
}


BOOL
ProcessQuery(
    SnmpExtQuery * q,
    UINT *         errorStatus,
    UINT *         errorIndex
    )

/*++

Routine Description:

    Query the subagent for requested items.

Arguments:

    q           - subagent query.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    BOOL fOk = TRUE;
    UINT extStatus = 0;

    AsnAny * objArray;

    // validate...
    if (q == NULL) {
        return TRUE;
    }

    // retrieve asn object array
    objArray = (AsnAny *)(q->extData.data);
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: ProcessQuery - objArray=%lx\n",
        objArray
        ));

    __try {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: entering subagent code ....\n"
            ));
        // query subagent
        extStatus = (UINT)(*q->extFunc)(
                            q->mibAction,
                            objArray,
                            errorIndex
                            );
        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: TFX: ... subagent code completed.\n"
            ));

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: subagent returned %s (e=0x%08lx,i=%d).\n",
            (extStatus == MIB_S_SUCCESS)
                ? "MIB_S_SUCCESS"
                : (extStatus == MIB_S_NO_MORE_ENTRIES)
                    ? "MIB_S_NO_MORE_ENTRIES"
                    : (extStatus == MIB_S_ENTRY_NOT_FOUND)
                        ? "MIB_S_ENTRY_NOT_FOUND"
                        : (extStatus == MIB_S_INVALID_PARAMETER)
                            ? "MIB_S_INVALID_PARAMETER"
                            : (extStatus == MIB_S_NOT_SUPPORTED)
                                ? "MIB_S_NOT_SUPPORTED"
                                : "error", extStatus, *errorIndex
                                ));

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        // report exception code
        extStatus = GetExceptionCode();

        // disable
        fOk = FALSE;
    }

    // save error info
    SetLastError(extStatus);

    // pass back translated version
    *errorStatus = MibStatusToSnmpStatus(extStatus);

    return fOk;
}


VOID
ProcessQueryList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Process the query list based on request type.

Arguments:

    tfxInfo     - context information.
    ql          - list of subagent queries.
    vbl         - list of incoming variable bindings.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    INT i=0; // index into query list
    INT j=0; // index into query list

    INT qlLen = ql->len; // save...

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: processing %d subagent queries.\n",
        qlLen
        ));

    // sets are processed below...
    if (ql->action != MIB_ACTION_SET) {

        // process list of individual queries
        for (i=0; (i < qlLen) && !(*errorStatus); i++ ) {

            // send query to subagent
            if (ProcessQuery(&ql->query[i], errorStatus, errorIndex)) {

                // need to validate getnext results
                if (ql->action == MIB_ACTION_GETNEXT) {
                    // exhaust all possibilities...
                    ValidateQueryList(
                        tfxInfo,
                        ql,
                        i,
                        vbl,
                        errorStatus,
                        errorIndex
                        );
                }

                // check the subagent status code returned
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {
                    // adjust index to match request pdu
                    AdjustErrorIndex(&ql->query[i], errorIndex);
                }

            } else {

                // subagent unable to process query
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                *errorIndex  = 1;
                // adjust index to match request pdu
                AdjustErrorIndex(&ql->query[i], errorIndex);
            }
        }

    } else {

        // process all of the validate queries
        for (i=0; (i < qlLen) && !(*errorStatus); i++) {

            // alter query type to validate entries
            ql->query[i].mibAction = MIB_ACTION_VALIDATE;

            // send query to subagent
            if (ProcessQuery(&ql->query[i], errorStatus, errorIndex)) {

                // check the subagent status code returned
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {
                    // adjust index to match request pdu
                    AdjustErrorIndex(&ql->query[i], errorIndex);
                }

            } else {

                // subagent unable to process query
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                *errorIndex  = 1;
                // adjust index to match request pdu
                AdjustErrorIndex(&ql->query[i], errorIndex);
            }
        }

        // process all of the set queries
        for (j=0; (j < qlLen) && !(*errorStatus); j++) {

            // alter query type to set entries
            ql->query[j].mibAction = MIB_ACTION_SET;

            // send query to subagent
            if (ProcessQuery(&ql->query[j], errorStatus, errorIndex)) {

                // check the subagent status code returned
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR) {
                    // adjust index to match request pdu
                    AdjustErrorIndex(&ql->query[j], errorIndex);
                }

            } else {

                // subagent unable to process query
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                *errorIndex  = 1;
                // adjust index to match request pdu
                AdjustErrorIndex(&ql->query[j], errorIndex);
            }
        }

        // cleanup...
        while (i-- > 0) {

            UINT ignoreStatus = 0; // dummy values
            UINT ignoreIndex  = 0; // dummy values

            // alter query type to set entries
            ql->query[i].mibAction = MIB_ACTION_CLEANUP;

            // send the cleanup request success or not
            ProcessQuery(&ql->query[i], &ignoreStatus, &ignoreIndex);
        }
    }
}


BOOL
ConstructInstanceIdentifier(
    SnmpTableXlat *       tblXlat,
    AsnAny *              objArray,
    AsnObjectIdentifier * newOid,
    UINT                  mibAction
    )
/*++

Routine Description:

    Convert asn value into index oid.

Arguments:

    tblXlat   - table translation info.
    objArray  - asn object array.
    newOid    - relative oid to return.
    mibAction - action requested of subagent.

Return Values: TRUE if successful

    None.

--*/

{
    UINT i;
    UINT j;
    UINT k;
    UINT l;
    UINT m;

    BOOL fFixed;
    BOOL fLimit;
    BOOL fIndex;

    UINT numItems;

    SnmpMibEntry * mibEntry;

    UINT * tmpIds = NULL; // prefix bug 445170

    // initialize
    newOid->ids = NULL;
    newOid->idLength = 0;


    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: converting obj array to index via table 0x%08lx.\n",
        tblXlat->txInfo
        ));

    // retrieve root entry and entry count
    numItems = tblXlat->txInfo->numIndices;

    // see if the table indices are specified
    fIndex = (tblXlat->txInfo->tableIndices != NULL);

    // scan entries of table indices
    for (i=0, j=0; i < numItems; i++) {

        // get mib entry from table or directly
        mibEntry = fIndex ?  tblXlat->txInfo->tableIndices[i]
                          : &tblXlat->txInfo->tableEntry[i+1]
                          ;

        // retrieve array index
        k = (mibAction == MIB_ACTION_SET)
                ? (UINT)(CHAR)mibEntry->mibSetBufOff
                : (UINT)(CHAR)mibEntry->mibGetBufOff
                ;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: ConstructIndexIdentifier - k=%d\n",
            k
            ));
        // determine type
        switch (mibEntry->mibType) {

        // variable length types
        case ASN_OBJECTIDENTIFIER:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length
                l = mibEntry->mibMaximum;

                // allocate space
                newOid->idLength += l;

                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

            } else {

                // determine variable length of object
                l = objArray[k].asnValue.object.idLength;

                // allocate space
                newOid->idLength += (l+1);
                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

                // save length
                newOid->ids[j++] = l;
            }

            // transfer data
            for (m=0; m < l; m++) {

                // transfer oid element from buffer
                newOid->ids[j++] = objArray[k].asnValue.object.ids[m];
            }

            break;

        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:

            // check whether this is a fixed length variable or not
            fLimit = (mibEntry->mibMinimum || mibEntry->mibMaximum);
            fFixed = (fLimit && (mibEntry->mibMinimum == mibEntry->mibMaximum));

            // validate
            if (fFixed) {

                // fixed length
                l = mibEntry->mibMaximum;

                // allocate space
                newOid->idLength += l;
                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

            } else {

                // determine variable length of object
                l = objArray[k].asnValue.string.length;

                // allocate space
                newOid->idLength += (l+1);
                tmpIds = (UINT *)SnmpUtilMemReAlloc(
                    newOid->ids,
                    newOid->idLength * sizeof(UINT)
                    );
                if (tmpIds == NULL)
                {
                    newOid->idLength = 0;
                    SnmpUtilMemFree(newOid->ids);
                    newOid->ids = NULL;
                    return FALSE;
                }
                newOid->ids = tmpIds;

                // save length
                newOid->ids[j++] = l;
            }

            // transfer data
            for (m=0; m < l; m++) {

                // convert character
                newOid->ids[j++] =
                    (UINT)(UCHAR)objArray[k].asnValue.string.stream[m];
            }

            break;

        // implicit fixed size
        case ASN_RFC1155_IPADDRESS:

            // allocate space
            newOid->idLength += 4;
            tmpIds = (UINT *)SnmpUtilMemReAlloc(
                newOid->ids,
                newOid->idLength * sizeof(UINT)
                );
            if (tmpIds == NULL)
            {
                newOid->idLength = 0;
                SnmpUtilMemFree(newOid->ids);
                newOid->ids = NULL;
                return FALSE;
            }
            newOid->ids = tmpIds;

            // transfer data into buffer
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[0];
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[1];
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[2];
            newOid->ids[j++] = (DWORD)(BYTE)objArray[k].asnValue.string.stream[3];

            break;

        case ASN_RFC1155_COUNTER:
        case ASN_RFC1155_GAUGE:
        case ASN_RFC1155_TIMETICKS:
        case ASN_INTEGER:

            // allocate space
            newOid->idLength += 1;
            tmpIds = (UINT *)SnmpUtilMemReAlloc(
                newOid->ids,
                newOid->idLength * sizeof(UINT)
                );
            if (tmpIds == NULL)
            {
                newOid->idLength = 0;
                SnmpUtilMemFree(newOid->ids);
                newOid->ids = NULL;
                return FALSE;
            }
            newOid->ids = tmpIds;

            // transfer value as integer
            newOid->ids[j++] = objArray[k].asnValue.number;
            break;

        default:
            // invalidate
            j = INVALID_INDEX;
            break;
        }
    }
    return TRUE;
}


VOID
DeleteQuery(
    SnmpExtQuery * q
    )

/*++

Routine Description:

    Deletes individual query.

Arguments:

    q - subagent query.

Return Values:

    None.

--*/

{
    UINT i; // index into xlat array
    UINT j; // index into object array

    BOOL fSet;

    AsnAny * objArray;
    SnmpMibEntry * mibEntry;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: deleting query 0x%08lx.\n", q
        ));

    // determine whether a set was requested
    fSet = (q->mibAction == MIB_ACTION_SET);

    // retrieve asn object array
    objArray = (AsnAny *)(q->extData.data);

    // free requested entries
    for (i = 0; i < q->vblNum; i++ ) 
    {
        // retrieve mib entry
        mibEntry = q->vblXlat[i].mibEntry;

        j = fSet ? (UINT)(CHAR)mibEntry->mibSetBufOff
                 : (UINT)(CHAR)mibEntry->mibGetBufOff
                 ;
        
        if (objArray)
            SnmpUtilAsnAnyFree(&objArray[j]);

        // free any followup queries
        if ((q->vblXlat[i].extQuery != NULL) &&
            (q->vblXlat[i].extQuery != INVALID_QUERY)) 
        {
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: deleting followup query 0x%08lx.\n",
                q->vblXlat[i].extQuery
                ));

            // free followup query
            DeleteQuery(q->vblXlat[i].extQuery);

            // free query structure itself
            SnmpUtilMemFree(q->vblXlat[i].extQuery);
        }
    }

    q->vblNum = 0;

    
    // free indices
    if (q->tblXlat && objArray) 
    {

        BOOL fIndex;

        // see if the table indices are specified
        fIndex = (q->tblXlat->txInfo->tableIndices != NULL);

        // free the individual indices
        for (i = 0; i < q->tblXlat->txInfo->numIndices; i++) 
        {

            // get mib entry from table or directly from entry
            mibEntry = fIndex ?  q->tblXlat->txInfo->tableIndices[i]
                              : &q->tblXlat->txInfo->tableEntry[i+1]
                              ;

            // determine the buffer offset used
            j = fSet ? (UINT)(CHAR)mibEntry->mibSetBufOff
                     : (UINT)(CHAR)mibEntry->mibGetBufOff
                     ;
            
            // free individual index
            SnmpUtilAsnAnyFree(&objArray[j]);
        }
    }
    
        
    // free buffer
    SnmpUtilMemFree(objArray);
    
    // avoid double freeing
    q->extData.data = NULL;

    // free table info
    if (q->tblXlat) {

        // free object identifier
        SnmpUtilOidFree(&q->tblXlat->txOid);

        // free the xlat structure
        SnmpUtilMemFree(q->tblXlat);

        // avoid double freeing
        q->tblXlat = NULL;
    }

    // free translation info
    SnmpUtilMemFree(q->vblXlat);

    // avoid double freeing
    q->vblXlat = NULL;
}


VOID
DeleteQueryList(
    SnmpExtQueryList * ql
    )

/*++

Routine Description:

    Deletes query list.

Arguments:

    ql - list of subagent queries.

Return Values:

    None.

--*/

{
    UINT q; // index into query list

    // process queries
    for (q=0; q < ql->len; q++) {

        // delete query
        DeleteQuery(&ql->query[q]);
    }

    // free query list
    SnmpUtilMemFree(ql->query);
}


VOID
QueryToVarBindList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQuery *       q,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )
/*++

Routine Description:

    Convert query back into varbind.

Arguments:

    tfxInfo - context info
    q       - subagent query.
    vbl     - list of varbinds in outgoing pdu.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;
    UINT k;
    UINT l;

    BOOL fSet;

    AsnAny * objArray;
    SnmpMibEntry * mibEntry;

    AsnObjectIdentifier idxOid;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: TFX: converting query 0x%08lx to varbinds.\n", q
        ));

    // determine whether a set was requested
    fSet = (q->mibAction == MIB_ACTION_SET);

    // retrieve asn object array
    objArray = (AsnAny *)(q->extData.data);

    // copy requested entries
    for (j = 0; j < q->vblNum; j++) {

        // process followup query
        if (q->vblXlat[j].extQuery != NULL) {

            if (q->vblXlat[j].extQuery != INVALID_QUERY) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: TFX: processing followup query 0x%08lx.\n",
                    q->vblXlat[j].extQuery
                    ));


                QueryToVarBindList(
                    tfxInfo,
                    q->vblXlat[j].extQuery,
                    vbl, 
                    errorStatus, 
                    errorIndex
                    );
                if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
                    return; // bail...
            }

            continue; // skip...
        }

        // retrieve index
        i = q->vblXlat[j].vblIndex;

        // retrieve mib entry for requested item
        mibEntry = q->vblXlat[j].mibEntry;

        k = fSet ? (UINT)(CHAR)mibEntry->mibSetBufOff
                 : (UINT)(CHAR)mibEntry->mibGetBufOff
                 ;

        // free original variable
        SnmpUtilVarBindFree(&vbl->list[i]);

        // copy the asn value first
        SnmpUtilAsnAnyCpy(&vbl->list[i].value, &objArray[k]);

        // copy root oid of view
        SnmpUtilOidCpy(
            &vbl->list[i].name,
            &tfxInfo->tfxViews[(q->vblXlat[j].vlIndex)].mibView->viewOid
            );

        // copy oid of variable
        SnmpUtilOidAppend(
            &vbl->list[i].name,
            &mibEntry->mibOid
            );

        // copy table index
        if (q->tblXlat) {

            // convert value to oid
            if (ConstructInstanceIdentifier(q->tblXlat, objArray, &idxOid, q->mibAction) == FALSE)
            {
                // report memory allocation problem
                *errorIndex = i+1; // failed in (i+1)th varbind
                *errorStatus = SNMP_ERRORSTATUS_GENERR;
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: TFX: ConstructInstanceIdentifier failed with %d th varbind.\n",
                    i+1
                    ));
                return; // bail...
            }

            // append oid to object name
            SnmpUtilOidAppend(&vbl->list[i].name, &idxOid);

            // free temp oid
            SnmpUtilOidFree(&idxOid);
        }

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: returning oid %s.\n",
            SnmpUtilOidToA(&vbl->list[i].name)
            ));
    }
}


VOID
QueryListToVarBindList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Convert query list back into outgoing varbinds.

Arguments:

    tfxInfo     - context information.
    ql          - list of subagent queries.
    vbl         - list of varbinds in outgoing pdu.
    errorStatus - used to indicate success or failure.
    errorIndex  - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT q;   // index into queue list
    UINT vb;  // index into queue varbind list
    UINT i;   // index into original varbind list

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: request %s, errorStatus=%s, errorIndex=%d.\n",
        (*errorStatus == SNMP_ERRORSTATUS_NOERROR)
            ? "succeeded"
            : "failed",
        (*errorStatus == SNMP_ERRORSTATUS_NOERROR)
            ? "NOERROR"
            : (*errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME)
                  ? "NOSUCHNAME"
                  : (*errorStatus == SNMP_ERRORSTATUS_BADVALUE)
                      ? "BADVALUE"
                      : (*errorStatus == SNMP_ERRORSTATUS_READONLY)
                          ? "READONLY"
                          : (*errorStatus == SNMP_ERRORSTATUS_TOOBIG)
                              ? "TOOBIG"
                              : "GENERR", *errorIndex
                              ));

    // only convert back if error not reported
    if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

        // process queries
        for (q=0; q < ql->len; q++) {

            // translate query data
            QueryToVarBindList(tfxInfo, &ql->query[q], vbl, errorStatus, errorIndex);
            if (*errorStatus != SNMP_ERRORSTATUS_NOERROR)
                break;
        }
    }

    // free
    DeleteQueryList(ql);
}


VOID
ValidateQueryList(
    SnmpTfxInfo *        tfxInfo,
    SnmpExtQueryList *   ql,
    UINT                 q,
    RFC1157VarBindList * vbl,
    UINT *               errorStatus,
    UINT *               errorIndex
    )

/*++

Routine Description:

    Validate getnext results and re-query if necessary.

Arguments:

    tfxInfo      - context information.
    ql           - list of subagent queries.
    q            - subagent query of interest.
    vbl          - list of bindings in incoming pdu.
    errorStatus  - used to indicate success or failure.
    errorIndex   - used to identify an errant varbind.

Return Values:

    None.

--*/

{
    UINT i;
    UINT j;

    SnmpExtQueryList tmpQl;

    UINT vlIndex;
    UINT vblIndex;
    UINT mibAction;
    UINT mibStatus;
    SnmpMibEntry * mibEntry;
    SnmpTableXlat * tblXlat;
    RFC1157VarBindList tmpVbl;
    BOOL fFoundOk = FALSE;

    SNMPDBG((
        SNMP_LOG_TRACE,
        "SNMP: TFX: verifying results of query 0x%08lx.\n", &ql->query[q]
        ));

    // bail on any error other than no such name
    if (*errorStatus != SNMP_ERRORSTATUS_NOSUCHNAME) {

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: returning error %d.\n",
            GetLastError()
            ));

        return; // bail...
    }

    // scan query list updating variables
    for (i=0; i < ql->query[q].vblNum; i++) {

        // initialize
        mibEntry  = ql->query[q].vblXlat[i].mibEntry;
        vlIndex   = ql->query[q].vblXlat[i].vlIndex;
        j         = ql->query[q].vblXlat[i].vlIndex;

        tblXlat   = NULL;
        mibAction = MIB_ACTION_GETNEXT;

        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: TFX: ValidateQueryList; next of %s.\n",
            SnmpUtilOidToA(&mibEntry->mibOid)
            ));

        // next...
        FindNextMibEntry(
               tfxInfo,
               NULL,
               &mibEntry,
               &mibAction,
               &tblXlat,
               vlIndex,
               errorStatus
               );

        while (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: constructing followup to query 0x%08lx:\n"
                "SNMP: TFX: \tmibEntry=0x%08lx\n"
                "SNMP: TFX: \ttblXlat =0x%08lx\n",
                &ql->query[q],
                mibEntry,
                tblXlat
                ));

            // initialize
            tmpQl.len    = 0;
            tmpQl.query  = NULL;
            tmpQl.action = MIB_ACTION_GETNEXT;

            // create query
            MibEntryToQueryList(
                   mibEntry,
                   mibAction,
                   &tmpQl,
                   tblXlat,
                   vlIndex,
                   NULL,
                   ql->query[q].vblXlat[i].vblIndex,
                   errorStatus
                   );

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: processing followup query 0x%08lx.\n",
                tmpQl.query
                ));

            // perform query with new oid
            ProcessQuery(tmpQl.query, errorStatus, errorIndex);

            // calculate results of query
            if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: TFX: saving followup 0x%08lx in query 0x%08lx.\n",
                    tmpQl.query, &ql->query[q]
                    ));

                // copy query for reassembly purposes
                ql->query[q].vblXlat[i].extQuery = tmpQl.query;

                break; // process next varbind...

            } else if (*errorStatus != SNMP_ERRORSTATUS_NOSUCHNAME) {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: TFX: could not process followup.\n"
                    ));

                // delete...
                DeleteQueryList(&tmpQl);

                return; // bail...
            }

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: re-processing followup to query 0x%08lx.\n",
                &ql->query[q]
                ));

            // delete...
            DeleteQueryList(&tmpQl);

            // re-initialize and continue...
            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
            tblXlat = NULL;
            mibAction = MIB_ACTION_GETNEXT;

            // next...
            FindNextMibEntry(
                   tfxInfo,
                   NULL,
                   &mibEntry,
                   &mibAction,
                   &tblXlat,
                   vlIndex,
                   errorStatus
                   );
        }

        // attempt to query next supported subagent view
        if (*errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME) {

/*
            // initialize
            tmpQl.len    = 0;
            tmpQl.query  = NULL;
            tmpQl.action = MIB_ACTION_GETNEXT;
*/
            // retrieve variable binding list index
            vblIndex = ql->query[q].vblXlat[i].vblIndex;

            // release old variable binding
            SnmpUtilVarBindFree(&vbl->list[vblIndex]);

            // copy varbind
            SnmpUtilOidCpy(
                &vbl->list[vblIndex].name,
                &tfxInfo->tfxViews[j].mibView->viewOid
                );

            // increment last sub-identifier of view oid
            vbl->list[vblIndex].name.ids[vbl->list[vblIndex].name.idLength-1]++;

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: query out of view. Pass up %s to service.\n",
                SnmpUtilOidToA(&vbl->list[vblIndex].name)
                ));

            // this query goes outside the MIB view.
            // varbind is set (above) to the first OID outside this view, so let the master agent
            // handle the switch between views.
            // DeleteQuery() here in order to instruct subsequent calls (QueryToVarBindList() and
            // DeleteQueryList()) that this query has already been taken care of.
            DeleteQuery(&(ql->query[q]));
            *errorStatus = SNMP_ERRORSTATUS_NOERROR;
/*
            // we need to query again with new oid
            VarBindToQueryList(
                tfxInfo,
                vbl,
                &tmpQl,
                0,
                errorStatus,
                errorIndex,
                j+1
                );

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: ValidateQueryList; VarBindToQueryList returned %d.\n",
                *errorStatus
                ));

            // make sure we successfully processed query
            if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

                // perform query with new oid
                ProcessQuery(tmpQl.query, errorStatus, errorIndex);

                // make sure we successfully processed query
                if (*errorStatus == SNMP_ERRORSTATUS_NOERROR) {

                    // validate...
                    if (tmpQl.query) {

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: TFX: saving followup 0x%08lx in query 0x%08lx.\n",
                            tmpQl.query, &ql->query[q]
                            ));

                        // copy query for reassembly purposes
                        ql->query[q].vblXlat[i].extQuery = tmpQl.query;

                    } else {

                        // copy query for reassembly purposes
                        ql->query[q].vblXlat[i].extQuery = INVALID_QUERY;
                    }

                    break; // process next varbind...
                }

                // copy query for reassembly purposes
                ql->query[q].vblXlat[i].extQuery = INVALID_QUERY;
                continue; // process next varbind...

            }

            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: TFX: could not process followup (again).\n"
                ));

            // delete...
            DeleteQueryList(&tmpQl);
*/
            return; // bail...

        }
    }
}


SnmpTfxInfo *
AllocTfxInfo(
    )
{
    // simply return results from generic memory allocation
    return (SnmpTfxInfo *)SnmpUtilMemAlloc(sizeof(SnmpTfxInfo));
}


VOID
FreeTfxInfo(
    SnmpTfxInfo * tfxInfo
    )
{
    UINT i;
    // prefix bug 445171    
    if (tfxInfo == NULL || tfxInfo->tfxViews == NULL) {
        return;
    }

    // walk through list of views
    for (i=0; (i < tfxInfo->numViews); i++) {

        // release memory for view hash tables
        FreeHashTable(tfxInfo->tfxViews[i].hashTable);
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SnmpTfxHandle
SNMP_FUNC_TYPE
SnmpTfxOpen(
    DWORD         numViews,
    SnmpMibView * supportedViews
    )
{
    UINT i,j;
    BOOL fOk;
    SnmpTfxInfo * tfxInfo = NULL;

    // validate parameters
    if ((numViews == 0) ||
        (supportedViews == NULL)) {
        return NULL;
    }

    // allocate structure
    tfxInfo = AllocTfxInfo();

    // validate pointer
    if (tfxInfo == NULL) {
        return NULL;
    }

    // copy number of views
    tfxInfo->numViews = numViews;

    // allocate individual view structures
    tfxInfo->tfxViews = SnmpUtilMemAlloc(
        tfxInfo->numViews * sizeof(SnmpTfxView)
        );

    // initialize status
    fOk = (tfxInfo->tfxViews != NULL);

    // initialize each view structure
    for (i=0; (i < tfxInfo->numViews) && fOk; i++) {

        SnmpHashNode ** tmpHashTable;

        // initialize individual view list entry
        tmpHashTable = AllocHashTable(&supportedViews[i]);

        // initialize status
        fOk = (tmpHashTable != NULL);

        // validate
        if (fOk) {

            // save a pointer into the subagent view list
            tfxInfo->tfxViews[i].mibView = &supportedViews[i];

            // save newly allocated view hash table
            tfxInfo->tfxViews[i].hashTable = tmpHashTable;
        }
    }

    // validate
    if (fOk) {

        SnmpTfxView tmpTfxView;

        // make sure views are sorted
        for (i=0; (i < tfxInfo->numViews); i++) {

            for(j=i+1; (j < tfxInfo->numViews); j++) {

                // in lexographic order?
                if (0 < SnmpUtilOidCmp(
                        &(tfxInfo->tfxViews[i].mibView->viewOid),
                        &(tfxInfo->tfxViews[j].mibView->viewOid))) {
                    // no, swap...
                    tmpTfxView = tfxInfo->tfxViews[i];
                    tfxInfo->tfxViews[i] = tfxInfo->tfxViews[j];
                    tfxInfo->tfxViews[i] = tmpTfxView;
                }
            }
            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: TFX: Adding view [%d] %s.\n",
                tfxInfo->tfxViews[i].mibView->viewOid.idLength,
                SnmpUtilOidToA(&(tfxInfo->tfxViews[i].mibView->viewOid))
                ));

        }

    } else {

        // free structure
        FreeTfxInfo(tfxInfo);

        // reinitialize
        tfxInfo = NULL;
    }

    return (LPVOID)tfxInfo;
}

SNMPAPI
SNMP_FUNC_TYPE
SnmpTfxQuery(
    SnmpTfxHandle        tfxHandle,
    BYTE                 requestType,
    RFC1157VarBindList * vbl,
    AsnInteger *         errorStatus,
    AsnInteger *         errorIndex
    )
{
    SnmpExtQueryList ql;
    SnmpTfxInfo *tfxInfo = tfxHandle;
    int i;

    // initialize
    ql.query  = NULL;
    ql.len    = 0;
    ql.action = requestType;

    // disassemble varbinds
    VarBindListToQueryList(
        (SnmpTfxInfo*)tfxHandle,
        vbl,
        &ql,
        errorStatus,
        errorIndex
        );

    // process queries
    ProcessQueryList(
        (SnmpTfxInfo*)tfxHandle,
        &ql,
        vbl,
        errorStatus,
        errorIndex
        );

    // reassemble varbinds
    QueryListToVarBindList(
        (SnmpTfxInfo*)tfxHandle,
        &ql,
        vbl,
        errorStatus,
        errorIndex
        );

    return TRUE;
}


VOID
SNMP_FUNC_TYPE
SnmpTfxClose(
    SnmpTfxHandle tfxHandle
    )
{
    // simply treat as info and release
    FreeTfxInfo((SnmpTfxInfo *)tfxHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\vb.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    vb.c

Abstract:

    Contains routines to manipulate variable bindings.

        SnmpUtilVarBindCpy
        SnmpUtilVarBindFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilVarBindCpy(
    SnmpVarBind * pVbDst,
    SnmpVarBind * pVbSrc
    )

/*++

Routine Description:

    Copies a variable binding.

Arguments:

    pVbDst - pointer to structure to receive VarBind.

    pVbSrc - pointer to VarBind to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointer
    if (pVbDst != NULL) {
        
        // initialize destination
        pVbDst->value.asnType = ASN_NULL;

        // validate pointer
        if (pVbSrc != NULL) {

            // copy the variable's name from source to destination
            nResult = SnmpUtilOidCpy(&pVbDst->name, &pVbSrc->name);

            // validate return code
            if (nResult == SNMPAPI_NOERROR) {
        
                // copy the variable's value from source to destination            
                nResult = SnmpUtilAsnAnyCpy(&pVbDst->value, &pVbSrc->value);
            }
        
        } else {

            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: copying null varbind.\n"
                ));
        
            nResult = SNMPAPI_NOERROR; // success..,
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null varbind pointer.\n"
            ));
    
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    // validate return code
    if (nResult == SNMPAPI_ERROR) {
        
        // release new variable 
        SnmpUtilVarBindFree(pVbDst);
    }

    return nResult;
} 


VOID
SNMP_FUNC_TYPE 
SnmpUtilVarBindFree(
    SnmpVarBind * pVb 
    )

/*++

Routine Description:

    Releases memory associated with variable binding.

Arguments:

    pVb - pointer to VarBind to release.

Return Values:

    None. 

--*/

{
    // validate
    if (pVb != NULL) {
        
        // release variable name    
        SnmpUtilOidFree(&pVb->name);

        // release variable value
        SnmpUtilAsnAnyFree(&pVb->value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\uniconv.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    uniconv.c

Abstract:

    Routine to convert UNICODE to ASCII.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <snmp.h>
#include <snmputil.h>

#ifndef CHICAGO
#include <ntrtl.h>
#else
#include <stdio.h>
#endif

#include <string.h>
#include <stdlib.h>


//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

//--------------------------- PRIVATE CONSTANTS -----------------------------

//--------------------------- PRIVATE STRUCTS -------------------------------

//--------------------------- PRIVATE VARIABLES -----------------------------

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//--------------------------- PUBLIC PROCEDURES -----------------------------

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilUnicodeToAnsi(
    LPSTR   *ansi_string,
    LPWSTR  uni_string,
    BOOLEAN alloc_it)

{
   int   result;
   LPSTR new_string;

   unsigned short length;
   unsigned short maxlength;

   // initialize
   if (alloc_it) {
       *((UNALIGNED LPSTR *) ansi_string) = NULL;
   }

   length    = (unsigned short)wcslen(uni_string);
   maxlength = length + 1;

   if (alloc_it) {
       new_string = SnmpUtilMemAlloc(maxlength * sizeof(CHAR));
   } else {
       new_string = *((UNALIGNED LPSTR *) ansi_string);
   }

   if (new_string == NULL) {
       return(-1);
   }

   if (length) {

       result = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    uni_string,
                    maxlength,
                    new_string,
                    maxlength,
                    NULL,
                    NULL
                    );
   } else {

      *new_string = '\0';

      result = 1; // converted terminating character
   }

   if (alloc_it) {

       if (result) {

           *((UNALIGNED LPSTR *) ansi_string) = new_string;

       } else {

           SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: API: WideCharToMultiByte returns 0x%08lx.\n",
                GetLastError()
                ));

           SnmpUtilMemFree(new_string);
       }
   }

   return (result > 0) ? 0 : -1;
}

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilUnicodeToUTF8(
    LPSTR   *pUtfString,
    LPWSTR  wcsString,
    BOOLEAN bAllocBuffer)
{
    int retCode;
    int nWcsStringLen;
    int nUtfStringLen;

    // Bug# 268748, lmmib2.dll uses this API and causes exception here on IA64 platform.
    // it is possible that pUtfString points to a pointer which is not aligned because the
    // pointer is embedded in a buffer allocated in lmmib2.dll.
    // Other functions in this file are fixed with this potential problem too.

    // make sure the parameters are valid
    if (wcsString == NULL ||                    // the unicode string should be valid
        pUtfString == NULL ||                   // the output parameter should be a valid pointer
        (!bAllocBuffer && *((UNALIGNED LPSTR *) pUtfString) == NULL)) // if we are not requested to allocate the buffer,
                                                // then the supplied one should be valid
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: LMMIB2: Invalid input to SnmpUtilUnicodeToUTF8.\n"));

        return (-1);
    }

    nWcsStringLen = wcslen(wcsString);
    nUtfStringLen = 3 * (nWcsStringLen + 1);    // initialize the lenght of the output buffer with the
                                                // greatest value possible

    // if we are requested to alloc the output buffer..
    if (bAllocBuffer)
    {
        // ...pick up first the buffer length needed for translation.
        retCode = WideCharToMultiByte(
                    CP_UTF8,
                    0,
                    wcsString,
                    nWcsStringLen + 1,  // include the null terminator in the string
                    NULL,
                    0,
                    NULL,
                    NULL);
        // at least we expect here the null terminator
        // if retCode is zero, something else went wrong.
        if (retCode == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: LMMIB2: First call to WideCharToMultiByte failed [%d].\n",
                GetLastError()));

            return -1;
        }

        // adjust the length of the utf8 string to the correct value
        // !!! it includes the null terminator !!!
        nUtfStringLen = retCode;

        // alloc here as many bytes as we need for the translation
        *((UNALIGNED LPSTR *) pUtfString) = SnmpUtilMemAlloc(nUtfStringLen);

        // at this point we should have a valid output buffer
        if (*((UNALIGNED LPSTR *) pUtfString) == NULL)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: LMMIB2: Memory allocation failed in SnmpUtilUnicodeToUTF8 [%d].\n",
                GetLastError()));

            return -1;
        }
    }
    // if bAllocBuffer is false, we assume the buffer given
    // by the caller is sufficiently large to hold all the UTF8 string

    retCode = WideCharToMultiByte(
                CP_UTF8,
                0,
                wcsString,
                nWcsStringLen + 1,
                *((UNALIGNED LPSTR *) pUtfString),
                nUtfStringLen,
                NULL,
                NULL);

    // nothing should go wrong here. However, if smth went wrong...
    if (retCode == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: LMMIB2: Second call to WideCharToMultiByte failed [%d].\n",
            GetLastError()));

        // ..we made it, we kill it
        if (bAllocBuffer)
        {
            SnmpUtilMemFree(*((UNALIGNED LPSTR *) pUtfString));
            *((UNALIGNED LPSTR *) pUtfString) = NULL;
        }
        // bail with error
        return -1;
    }

    // at this point, the call succeeded.
    return 0;
}

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilAnsiToUnicode(
    LPWSTR  *uni_string,
    LPSTR   ansi_string,
    BOOLEAN alloc_it)

{
   int   result;
   LPWSTR new_string;

   unsigned short length;
   unsigned short maxlength;

   // initialize
   if (alloc_it) {
       *((UNALIGNED LPWSTR *) uni_string) = NULL;
   }

   length    = (unsigned short) strlen(ansi_string);
   maxlength = length + 1;

   if (alloc_it) {
       new_string = SnmpUtilMemAlloc(maxlength * sizeof(WCHAR));
   } else {
       new_string = *((UNALIGNED LPWSTR *) uni_string);
   }

   if (new_string == NULL) {
       return(-1);
   }

   if (length) {

       result = MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    ansi_string,
                    length,
                    new_string,
                    maxlength
                    );

   } else {

      *new_string = L'\0';

      result = 1; // converted terminating character
   }

   if (alloc_it) {

       if (result) {

           *((UNALIGNED LPWSTR *) uni_string) = new_string;

       } else {

           SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: API: MultiByteToWideChar returns 0x%08lx.\n",
                GetLastError()
                ));

           SnmpUtilMemFree(new_string);
       }
   }

   return (result > 0) ? 0 : -1;
}

// The return code matches what Uni->Str uses
LONG
SNMP_FUNC_TYPE
SnmpUtilUTF8ToUnicode(
    LPWSTR  *pWcsString,
    LPSTR   utfString,
    BOOLEAN bAllocBuffer)

{
    int retCode;
    int nUtfStringLen;
    int nWcsStringLen;

    // check the consistency of the parameters first
    if (utfString == NULL ||                    // the input parameter must be valid
        pWcsString == NULL ||                   // the pointer to the output parameter must be valid
        (!bAllocBuffer && *((UNALIGNED LPWSTR *) pWcsString) == NULL)) // if we are not required to allocate the output parameter
                                                // then the output buffer must be valid
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: LMMIB2: Invalid input to SnmpUtilUTF8ToUnicode.\n"));

        return -1;
    }

    nUtfStringLen = strlen(utfString);  // the length of the input utf8 string
    nWcsStringLen = nUtfStringLen + 1;  // greatest value possible

    if (bAllocBuffer)
    {
        retCode = MultiByteToWideChar(
                    CP_UTF8,
                    0,
                    utfString,
                    nUtfStringLen + 1,
                    NULL,
                    0);

        // at least we expect here the null terminator
        // if retCode is zero, something else went wrong.
        if (retCode == 0)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: LMMIB2: First call to MultiByteToWideChar failed [%d].\n",
                GetLastError()));

            return -1;
        }

        // adjust the length of the utf8 string to the correct value
        nWcsStringLen = retCode;

        // alloc here as many bytes as we need for the translation
        // !!! it includes the null terminator !!!
        *((UNALIGNED LPWSTR *) pWcsString) = SnmpUtilMemAlloc(nWcsStringLen * sizeof(WCHAR));

        // at this point we should have a valid output buffer
        if (*((UNALIGNED LPWSTR *) pWcsString) == NULL)
        {
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: LMMIB2: Memory allocation failed in SnmpUtilUTF8ToUnicode [%d].\n",
                GetLastError()));

            return -1;
        }
    }

    // if bAllocBuffer is false, we assume the buffer given
    // by the caller is sufficiently large to hold all the UTF8 string

    retCode = MultiByteToWideChar(
                CP_UTF8,
                0,
                utfString,
                nUtfStringLen + 1,
                *((UNALIGNED LPWSTR *) pWcsString),
                nWcsStringLen);

    // nothing should go wrong here. However, if smth went wrong...
    if (retCode == 0)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: LMMIB2: Second call to MultiByteToWideChar failed [%d].\n",
            GetLastError()));

        // ..we made it, we kill it
        if (bAllocBuffer)
        {
            SnmpUtilMemFree(*((UNALIGNED LPWSTR *) pWcsString)); 
            *((UNALIGNED LPWSTR *) pWcsString) = NULL; 
        }
        // bail with error
        return -1;
    }

    // at this point, the call succeeded.
    return 0;
}
//-------------------------------- END --------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\sysoid.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    sysoid.c

Abstract:

    Contains enterprise oid routine.

        SnmpSvcGetEnterpriseOid

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern AsnObjectIdentifier * g_pEnterpriseOid;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

AsnObjectIdentifier *
SNMP_FUNC_TYPE
SnmpSvcGetEnterpriseOID(
    )

/*++

Routine Description:

    Retrieves enterprise oid for SNMP process.

Arguments:

    None.

Return Values:

    Returns pointer to enterprise oid.

--*/

{
    // return system oid
    return g_pEnterpriseOid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\lib\dummy.c ===
//
// The TCP/IP performance counter DLL loads INETMIB1.DLL
// directly and impersonates the SNMP master agent.  In
// order to accomplish this the DLL needs some of the
// utilities included in SNMPAPI.DLL but the Perf dudes
// do not want to load another DLL into their process.
//
// This static library hopefully will be only temporary
// until we can get the performance DLL rewritten to use
// the new MIB2UTIL.DLL.
//

#include "..\dll\any.c"
#include "..\dll\dbg.c"
#include "..\dll\mem.c"
#include "..\dll\oid.c"
#include "..\dll\octets.c"
#include "..\dll\vb.c"
#include "..\dll\vbl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\configs.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <iostream.h>
#include <fstream.h>
#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include "Configs.hpp"
#include "Debug.hpp"

Configs theConfigs;

Configs::Configs()
{
	m_pszOutputFilename = NULL;
	m_nMaxErrors = CFG_DEF_MAXERRORS;
	m_dwFlags = CFG_PRINT_LOGO;

}

Configs::~Configs()
{
	if (m_pszOutputFilename != NULL)
		delete m_pszOutputFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\configs.hpp ===
#ifndef _CONFIGS_HPP
#define _CONFIGS_HPP

#define CFG_PRINT_LOGO		0x01
#define	CFG_PRINT_TREE		0x02
#define CFG_PRINT_NODE		0x04
#define CFG_VERB_ERROR		0x08
#define CFG_VERB_WARNING	0x10

#define CFG_DEF_MAXERRORS	10

class Configs
{
public:
	LPSTR	m_pszOutputFilename;
	int		m_nMaxErrors;
	DWORD	m_dwFlags;

	Configs();
	~Configs();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\debug.hpp ===
#ifndef _DEBUG_H
#define _DEBUG_H

void _coreASSERT(const char *filename, int line, const char *errMst, void (*cleanup)());

void dumpOnBuild();

#ifdef _ASSERT
#undef _ASSERT
#endif

// DESCRIPTION:
//		macro useful for run-time debugging
//		it tels exactly which source and which line an error occured.
//		it also calls a user-supplied clean-up function, if available
//		and exits the program.
// PARAMETERS:
//		(in)b - boolean condition that has to be checked
//		(in)s - error message string to be displayed if assertion fails
//		(in)f - user-defined function to be called for cleanup before exiting
#define _ASSERT(b,s,f)											\
	{															\
		if (!(b))												\
		{														\
			_coreASSERT(__FILE__, __LINE__, (s), (f));			\
			exit(-1);											\
		}														\
	}

// DESCRIPTION
//		macro useful for parameter checking.
// PARAMETERS
//		(in)b - boolean condition that has to be checked
//		(in)v - value to be returned if condition fails
#define _VERIFY(b,v)													\
	{																	\
		if (!(b))														\
		{																\
			_coreASSERT(__FILE__, __LINE__, " _VERIFY failure ", NULL);	\
			return v;													\
		}																\
	}
															
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\common\dll\vbl.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    vbl.c

Abstract:

    Contains routines to manipulate variable binding lists.

        SnmpUtilVarBindListCpy
        SnmpUtilVarBindListFree

Environment:

    User Mode - Win32

Revision History:

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <snmp.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SNMPAPI
SNMP_FUNC_TYPE 
SnmpUtilVarBindListCpy(
    SnmpVarBindList * pVblDst, 
    SnmpVarBindList * pVblSrc  
    )

/*++

Routine Description:

    Copies a variable binding list.

Arguments:

    pVblDst - pointer to structure to receive VarBindList.

    pVblSrc - pointer to VarBindList to copy.

Return Values:

    Returns SNMPAPI_NOERROR if successful. 

--*/

{
    UINT i;
    SNMPAPI nResult = SNMPAPI_ERROR;

    // validate pointer 
    if (pVblDst != NULL) {

        // initialize
        pVblDst->list = NULL;
        pVblDst->len  = 0;

        // check for varbinds    
        if ((pVblSrc != NULL) &&
            (pVblSrc->list != NULL) &&
            (pVblSrc->len != 0)) {

            // attempt to allocate varbinds
            pVblDst->list = SnmpUtilMemAlloc(
                                pVblSrc->len * sizeof(SnmpVarBind)
                                );

            // validate pointer
            if (pVblDst->list != NULL) {

                // loop through the varbinds
                for (i = 0; i < pVblSrc->len; i++) {

                    // copy individual varbind
                    nResult = SnmpUtilVarBindCpy(   
                                    &pVblDst->list[i], 
                                    &pVblSrc->list[i]
                                    );

                    // validate return code
                    if (nResult == SNMPAPI_NOERROR) {            

                        // increment
                        pVblDst->len++; // success...
                        
                    } else {
            
                        break; // failure...    
                    }
                }
            
            } else {
            
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: API: could not allocate varbinds.\n"
                    ));

                SetLastError(SNMP_MEM_ALLOC_ERROR);
            }

        } else {

            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: API: copying null varbindlist.\n"
                ));
        
            nResult = SNMPAPI_NOERROR; // success..,
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: API: null varbindlist pointer.\n"
            ));
    
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    // make sure we cleanup    
    if (nResult == SNMPAPI_ERROR) {

        // release new varbinds
        SnmpUtilVarBindListFree(pVblDst);
    }

    return nResult;
}


VOID
SNMP_FUNC_TYPE 
SnmpUtilVarBindListFree(
    SnmpVarBindList * pVbl
    )

/*++

Routine Description:

    Frees memory associated with variable binding list.

Arguments:

    pVbl - pointer to VarBindList to free.

Return Values:

    None. 

--*/

{
    UINT i;

    // loop throught varbinds
    for (i = 0; i < pVbl->len; i++) {

        // release individual varbind
        SnmpUtilVarBindFree(&pVbl->list[i]);
    }

    // release actual list
    SnmpUtilMemFree(pVbl->list);

    // re-initialize
    pVbl->list = NULL;
    pVbl->len  = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\mibcc.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mibcc.cpp

Abstract:

    SMI compiler backend for MIB database.

Author:

    Florin Teodorescu (florint)   26-Jan-1998

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <io.h>
#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "Debug.hpp"
#include "OidToF.hpp"
#include "Configs.hpp"

// error container defined in debug.cpp
extern SIMCErrorContainer errorContainer;
extern Configs	theConfigs;

int InitTree(SIMCParseTree &theTree, int argc, char *argv[])
{
	UINT uFileCount;
	UINT uFileNameLen;
	UINT uErrLevel;
	UINT uSMIVersion;

	/* process command line options */
	--argc;
	++argv;
	while ((argc > 0) && ((argv[0][0] == '-') || (argv[0][0] == '/')))
	{
		switch (argv[0][1])
		{
		case '?':
        case 'h':
        case 'H':
			cout << "usage: mibcc [-?] [-e] [-l] [-n] [-o] [-t] -[w] [files...]\n";
			cout << "   MibCC compiles the specified SNMP MIB files.\n";
			cout << "      -?        usage.\n";
			cout << "      -eX       stop after X Errors. (default = 10)\n";
			cout << "      -l        do not print Logo.\n";
			cout << "      -n        print each Node as it is added.\n";
			cout << "      -o[file]  output file name. (no file by default)\n";
			cout << "      -t        print the mib Tree when finished.\n";
			cout << "      -wX       set Warning level.\n";
			cout << "                0=silent; 1=errors only; 2=warnings only; 3=both\n";
			cout << "                (default = 0)\n";
			exit (0);
			break;
		case 'e':
		case 'E':
			theConfigs.m_nMaxErrors = atoi(argv[0]+2);
			break;
		case 'l':
		case 'L':
			theConfigs.m_dwFlags &= ~CFG_PRINT_LOGO;
			break;
        case 'n':
		case 'N':
			theConfigs.m_dwFlags |= CFG_PRINT_NODE;
			break;
		case 'o':
		case 'O':
			uFileNameLen = strlen(argv[0]+2);
			 
			if (uFileNameLen == 0)
			{
				if (theConfigs.m_pszOutputFilename != NULL)
					delete theConfigs.m_pszOutputFilename;
				theConfigs.m_pszOutputFilename = NULL;
			}
			else
			{
				if (theConfigs.m_pszOutputFilename != NULL)
					delete (theConfigs.m_pszOutputFilename);
				theConfigs.m_pszOutputFilename = new char[uFileNameLen+1];
				_ASSERT(theConfigs.m_pszOutputFilename != NULL, "Memory Allocation error!", NULL);
				strcpy(theConfigs.m_pszOutputFilename, argv[0]+2);
			}
			break;
        case 't':
        case 'T':
            theConfigs.m_dwFlags |= CFG_PRINT_TREE;
            break;
        case 'w':
        case 'W':
			uErrLevel = atoi(argv[0]+2);
			theConfigs.m_dwFlags |= (uErrLevel == 1 || uErrLevel == 3 ? CFG_VERB_ERROR : 0) | 
									(uErrLevel == 2 || uErrLevel == 3 ? CFG_VERB_WARNING : 0);
            break;
		case 'v':
		case 'V':
			uSMIVersion = atoi(argv[0]+2);

			if (uSMIVersion > 2)
				cout << "mibcc: wrong value for -v option; ignored\n";
			else
				theTree.SetSnmpVersion(uSMIVersion);
			break;
        default:
            cout << "mibcc: unrecognized option '" << argv[0] << "'\n";
            cout << "mibcc -? for usage\n";
            exit (-1);
            break;
		}
		--argc;
		++argv;
	}

	if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
	{
		cout << "Microsoft (R) SNMP MIB Compiler Version 2.00\n";
		cout << "Copyright (c) Microsoft Corporation 1998.  All rights reserved.\n";
	}

	for(uFileCount = 0; argc>0; argc--, argv++)
	{
		struct _finddata_t findData;
                intptr_t handle;

		// check snmp syntax
		handle = _findfirst(argv[0], &findData);
		if (handle != -1)
		{
			do
			{
				if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
				{
					cout << "mibcc: parsing " << findData.name << "\n";
					cout.flush();
				}
				uFileCount++;
				_ASSERT(theTree.CheckSyntax(findData.name), "CheckSyntax() failed!", dumpOnBuild);
			}while(_findnext(handle, &findData) != -1);
		}
	}

	if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
	{
		// do not print anything further if no files processed
		if (uFileCount == 0)
			theConfigs.m_dwFlags &= ~CFG_PRINT_LOGO;

		cout << "mibcc: total files processed: " << uFileCount << "\n";
	}

    cout.flush();
	return 0;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Entry point                                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT 
__cdecl 
main(
    IN INT   argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    Program entry point. 

Arguments:

    argc - number of command line arguments.
    argv - pointer to array of command line arguments.

Return Values:

    Returns 0 if successful.

--*/

{
    SIMCParseTree		theTree(&errorContainer);
	SIMCOidTree			*pTheOidTree;
	OidToFile			oidDumpTree;

	_ASSERT(InitTree(theTree, argc, argv)==0, "InitTree() failed!", dumpOnBuild);

    // resolve symbols
    _ASSERT(theTree.Resolve(FALSE), "Resolve() failed!", dumpOnBuild);

    // check semantics
    _ASSERT(theTree.CheckSemantics(), "CheckSemantics() failed!", dumpOnBuild);

	// retrieve the Oid Tree

	pTheOidTree = (SIMCOidTree *)theTree.GetOidTree();
	_ASSERT(pTheOidTree != NULL, "Oid Tree is NULL", NULL);
	oidDumpTree.SetOidTree(pTheOidTree);

	_ASSERT(oidDumpTree.SetMibFilename(theConfigs.m_pszOutputFilename)==0, "SetMibFilename failed!", NULL);
	_ASSERT(oidDumpTree.MergeBuiltIn()==0, "MergeBuiltIn failed!", NULL);
	_ASSERT(oidDumpTree.Scan()==0, "Oid Scan() failed", NULL);

	if (theConfigs.m_dwFlags & CFG_PRINT_LOGO)
	{
		if (theConfigs.m_dwFlags & CFG_PRINT_NODE)
			cout << '\n';
		if (theConfigs.m_pszOutputFilename != NULL)
			cout << "mibcc: writing compiled file '" << theConfigs.m_pszOutputFilename << "'\n";
		else
			cout << "mibcc: no output file generated" << "\n";
	}
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\debug.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>

#include <afxwin.h>
#include <afxole.h>

#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>

#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "Debug.hpp"
#include "Configs.hpp"

SIMCErrorContainer errorContainer;
extern Configs theConfigs;

void _coreASSERT(const char *filename, int line, const char *errMsg, void (*cleanup)())
{
	const char *name;
	name = strrchr(filename, '\\');
	if (name != NULL)
		filename = name+1;
	cout << "Err [" << filename << ":" << line << "] - " << errMsg << "\n";
	if (cleanup != NULL)
		(*cleanup)();
}

void dumpOnBuild()
{
	SIMCErrorMessage errorMessage;

	if ( (theConfigs.m_dwFlags & (CFG_VERB_ERROR | CFG_VERB_WARNING)) == 0 )
		return;
	for (errorContainer.MoveToFirstMessage();
	     errorContainer.GetNextMessage(errorMessage) && theConfigs.m_nMaxErrors > 0;
		)
	{
		switch (errorMessage.GetSeverityLevel())
		{
		case 0:
			if (theConfigs.m_dwFlags & CFG_VERB_ERROR)
			{
				cout << errorMessage;
				theConfigs.m_nMaxErrors--;
			}
			break;
		case 1:
			if (theConfigs.m_dwFlags & CFG_VERB_WARNING)
			{
				cout << errorMessage;
				theConfigs.m_nMaxErrors--;
			}
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\oid.cpp ===
#include <iostream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include "debug.hpp"
#include "Oid.hpp"

// DESCRIPTION;
//     constructor, implicitly construct m_nOIDs and m_szOIDs
Oid::Oid()
{
}

// DESCRIPTION:
//     Adds a new Oid component to the END of the internal arrays!
// PARAMETERS:
//     (in) integer component of the Oid
//     (out) symbolic name of the component
// RETURN VALUE:
//      0 on success, -1 on failure
int Oid::AddComponent(int nOidComp, const char * szOidComp)
{
	char *szOidCopy = NULL;

	_VERIFY(m_nOidComp.Add((WORD)nOidComp)!=-1, -1);
	if (szOidComp != NULL)
	{
		szOidCopy = new char [strlen(szOidComp)+1];
		_VERIFY(szOidCopy != NULL, -1);
		strcpy(szOidCopy, szOidComp);
	}
	m_szOidComp.Add((CObject *)szOidCopy);
	return 0;
}

// DESCRIPTION:
//      Reverses the components of the OID from both
//		m_nOidComp and m_szOidComp
// RETURN VALUE:
//      0 on success, -1 on failure
int Oid::ReverseComponents()
{
	INT_PTR fwd, rev;

	for (fwd = 0, rev=m_nOidComp.GetSize()-1;
		 fwd < rev;
		 fwd ++, rev--)
	{
		int nOidComp;
		const char *szOidComp;

		nOidComp = m_nOidComp.GetAt(fwd);
		m_nOidComp.SetAt(fwd, m_nOidComp.GetAt(rev));
		m_nOidComp.SetAt(rev, (WORD)nOidComp);

		szOidComp = (const char *)m_szOidComp.GetAt(fwd);
		m_szOidComp.SetAt(fwd, m_szOidComp.GetAt(rev));
		m_szOidComp.SetAt(rev, (CObject *)szOidComp);
	}
	return 0;
}

// DESCRIPTION:
//      Output operator, displays the whole Oid
ostream& operator<< (ostream& outStream, const Oid& oid)
{
	INT_PTR sz = oid.m_nOidComp.GetSize();

	_ASSERT(sz == oid.m_szOidComp.GetSize(), "Size mismatch in Oid arrays", NULL);

	for (INT_PTR i=0; i<sz; i++)
	{
		unsigned int nId;
		const char *szId;

		// skip over the first component zero(0)
		if (i == 0)
			continue;

		nId = oid.m_nOidComp.GetAt(i);
		szId = (const char *)oid.m_szOidComp.GetAt(i);
		if (szId != NULL)
		{
			outStream << szId << "(";
			outStream << nId << ")";
		}
		else
			outStream << nId;
		if (i != sz-1)
			outStream << ".";
	}
	return outStream;
}

// DESCRIPTION:
//     destructor
Oid::~Oid()
{
	/*
	m_nOidComp.RemoveAll();
	for (int i=m_szOidComp.GetSize()-1; i>=0; i--)
	{
		char *szName = (char *)m_szOidComp.GetAt(i);
		if (szName != NULL)
		{
			// allocated with new in the AddComponent() member function
			delete szName;
		}
	}
	m_szOidComp.RemoveAll();
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\oidtof.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "Debug.hpp"
#include "Oid.hpp"
#include "OidToF.hpp"
#include "Configs.hpp"

extern Configs theConfigs;

OidToFile::OidToFile()
{
	m_hMibFile = NULL;
	m_pszMibFilename = NULL;
}

// DESCRIPTION:
//		wrapper for the base class Scan();
//		it find first the sizes of subtrees (subtree's root node included)
// RETURN VALUE:
//		0 on success
//		-1 on failure;
int OidToFile::Scan()
{
	SIMCOidTreeNode *pOidNode;
	SIMCNodeList recursionTrace;

	// get the root node from the oid tree,
	// return "error" if no tree or no root
	_VERIFY(m_pOidTree != NULL, -1);
	pOidNode = (SIMCOidTreeNode *)m_pOidTree->GetRoot();
	_VERIFY(pOidNode != NULL, -1);

	// node hasn't been scanned; _lParam=number of dependencies
	pOidNode->_lParam = (DWORD)pOidNode->GetListOfChildNodes()->GetCount();
	// initialize the recursionTree with the root node
	_VERIFY(recursionTrace.AddHead(pOidNode)!=NULL, -1);

	// start to scan the tree
	while (!recursionTrace.IsEmpty())
	{
		const SIMCNodeList *pLstChildren;

		// allways pick up the node in the head of the list
		pOidNode = recursionTrace.GetHead();

		// get the dependencies list
		pLstChildren = pOidNode->GetListOfChildNodes();

		// if there are no more dependencies to process
		// sum the children values and add to its own
		if (pOidNode->_lParam == 0)
		{
			SIMCOidTreeNode *pParent;
			const char * cszSymbol = NULL;

			_VERIFY(GetNodeSymbol(pOidNode, cszSymbol)==0, -1);

			pOidNode->_lParam = sizeof(T_FILE_NODE_EX) + (cszSymbol != NULL ? strlen(cszSymbol) : 0);

			// compute the cumulated size of the subtree
			for (POSITION p = pLstChildren->GetHeadPosition(); p != NULL;)
			{
				const SIMCOidTreeNode *pChild;

				pChild = pLstChildren->GetNext(p);
				_VERIFY(pChild!=NULL, -1);

				// Modify here!!!!
				pOidNode->_lParam += pChild->_lParam;
			}

			// decrease the number of dependencies from the parent node
			pParent = m_pOidTree->GetParentOf(pOidNode);
			if ( pParent != NULL)
			{
				pParent->_lParam--;
			}

			// delete the node from the list
			recursionTrace.RemoveHead();
		}
		else
		{
			// add the children list to the front of the recursionTrace
			for (POSITION p = pLstChildren->GetHeadPosition(); p != NULL;)
			{
				SIMCOidTreeNode *pChild;

				pChild = pLstChildren->GetNext(p);
				_VERIFY(pChild!=NULL, -1);

				pChild->_lParam = (DWORD)pChild->GetListOfChildNodes()->GetCount();
				_VERIFY(recursionTrace.AddHead(pChild)!=NULL, -1);
			}
		}
	}
	return OidTreeScanner::Scan();
}

// DESCRIPTION:
//		Creates the output file, containing the OID encoding
// PARAMETERS:
//		(in) pointer to the output file name
// RETURN VALUE:
//		0 on success, -1 on failure
int OidToFile::SetMibFilename(const char * pszMibFilename)
{
	if (m_pszMibFilename != NULL)
	{
		delete (void *)m_pszMibFilename;
		m_pszMibFilename = NULL;
	}

	if (pszMibFilename != NULL)
	{
		_VERIFY(strlen(pszMibFilename) != 0, -1);
		m_pszMibFilename = new char [strlen(pszMibFilename) + 1];
		_VERIFY(m_pszMibFilename != NULL, -1);
		strcpy((char *)m_pszMibFilename, pszMibFilename);
	}
	return 0;
}

// DESCRIPTION:
//		"callback" function, called each time a
//		tree node passes through the scan.
//		in pOidNode->_lParam there is the cumulated size
//		of the hole subtree, root included.
//		size = sizeof(T_FILE_NODE_EX) + strlen(node symbol)
// PARAMETERS:
//		(in) Pointer to the current node in the tree.
//			 Nodes are supplied in lexicographic order.
// RETURN VALUE:
//		0  - the scanner should continue
//		-1 - the scanner should abort.
int OidToFile::OnScanNode(const SIMCOidTreeNode *pOidNode)
{
	T_FILE_NODE_EX fileNode;
	char *nodeSymbol = NULL;

	// skip the '0' root of the OID tree
	if (m_pOidTree->GetParentOf(pOidNode) == NULL)
		return 0;

	if (theConfigs.m_dwFlags & CFG_PRINT_TREE)
	{
		Oid oid;

		_VERIFY(GetNodeOid(pOidNode, oid)==0, -1);
		cout << oid << "\n";
	}
	if (theConfigs.m_dwFlags & CFG_PRINT_NODE)
	{
		cout << "."; cout.flush();
	}

	// if no need to write output file, return success
	if (m_pszMibFilename == NULL)
		return 0;

	_VERIFY(GetNodeSymbol(pOidNode, nodeSymbol) == 0, -1);

	// build the T_FILE_NODE_EX structure
	fileNode.uNumChildren = (UINT)pOidNode->GetListOfChildNodes()->GetCount();
	fileNode.uReserved = 0;
	fileNode.uNumSubID = pOidNode->GetValue();

	if (nodeSymbol == NULL)
	{
		fileNode.lNextOffset = pOidNode->_lParam - sizeof(T_FILE_NODE_EX);
		fileNode.uStrLen = 0;
	}
	else
	{
		fileNode.uStrLen = strlen(nodeSymbol);
		fileNode.lNextOffset = pOidNode->_lParam - fileNode.uStrLen - sizeof(T_FILE_NODE_EX);
	}

	// create / write_open file if not already created
	if (m_hMibFile == NULL)
	{
		OFSTRUCT of;

		_VERIFY(m_pszMibFilename != NULL, -1);
		m_hMibFile = OpenFile(m_pszMibFilename, &of, OF_CREATE|OF_WRITE|OF_SHARE_EXCLUSIVE);
		_VERIFY(m_hMibFile != -1, -1);
	}

	// write fileNode to file
	_VERIFY(_lwrite(m_hMibFile, (LPSTR)&fileNode, sizeof(T_FILE_NODE_EX)) == sizeof(T_FILE_NODE_EX), -1);

	// write node's symbol if exists
	if (fileNode.uStrLen != 0)
	{
		_VERIFY(_lwrite(m_hMibFile, nodeSymbol, fileNode.uStrLen) == fileNode.uStrLen, -1);
	}

	return 0;
}

OidToFile::~OidToFile()
{
	if (m_pszMibFilename != NULL)
		delete (void *)m_pszMibFilename;
	if (m_hMibFile != NULL)
		_lclose(m_hMibFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\oid.hpp ===
#ifndef _OID_HPP
#define _OID_HPP

class Oid
{
	// DESCRIPTION:
	//     array containing the numeric components of the OID
	CWordArray m_nOidComp;

	// DESCRIPTION:
	//     array of pointers to strings, containing symbolic names
	//     for OID's components.
	CObArray  m_szOidComp;

public:
	// DESCRIPTION:
	//     constructor
	Oid();

	// DESCRIPTION:
	//     Adds a new Oid component to the END of the internal arrays!
	// PARAMETERS:
	//     (in) integer component of the Oid
	//     (out) symbolic name of the component
	// RETURN VALUE:
	//      0 on success, -1 on failure
	int AddComponent(int nOidComp, const char * szOidComp);

	// DESCRIPTION:
	//      Reverses the components of the OID from both
	//		m_nOidComp and m_szOidComp
	// RETURN VALUE:
	//      0 on success, -1 on failure
	int ReverseComponents();

	// DESCRIPTION:
	//      Output operator, displays the whole Oid
	friend ostream& operator<< (ostream& outStream, const Oid& oid);

	// DESCRIPTION:
	//     destructor
	~Oid();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\otscan.cpp ===
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include <iostream.h>
#include <fstream.h>

#include <afx.h>
#include <afxtempl.h>
#include <objbase.h>
#include <afxwin.h>
#include <afxole.h>
#include <afxmt.h>
#include <wchar.h>
#include <process.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <nString.hpp>
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objType.hpp>
#include <objTypV1.hpp>
#include <objTypV2.hpp>
#include <objId.hpp>
#include <trapType.hpp>
#include <notType.hpp>
#include <group.hpp>
#include <notGroup.hpp>
#include <module.hpp>
#include <sValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMsg.hpp>
#include <errorCon.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <apTree.hpp>
#include <oidTree.hpp>
#include <pTree.hpp>

#include "debug.hpp"
#include "Oid.hpp"
#include "OTScan.hpp"

typedef struct _oidBuiltIn
{
	const char * m_szSymbol;
	UINT m_nSubID;
	UINT m_nNextSibling;
} T_OID_BUILTIN;

#define BUILTIN_OID_COUNT	29
static T_OID_BUILTIN g_BuiltinOIDs[] = {
/*0 */	{"zero",           0, 29},	{"ccitt",           0,  2},	{"iso",           1, 28},
/*3 */	{"org",            3, 29},	{"dod",             6, 29},	{"internet",      1, 29},
/*6	*/	{"directory",      1,  7},	{"mgmt",            2, 12},	{"mib-2",         1, 29},
/*9	*/	{"interfaces",     2, 10},	{"ip",              4, 11},	{"transmission", 10, 29},
/*12*/	{"experimental",   3, 13},	{"private",         4, 15},	{"enterprises",   1, 29},
/*15*/	{"security",       5, 16},	{"snmpV2",          6, 29},	{"snmpDomains",   1, 24},
/*18*/	{"snmpUDPDomain",  1, 19},	{"snmpCLNSDomain",  2, 20}, {"snmpCONSDomain",3, 21},
/*21*/	{"snmpDDPDomain",  4, 22},  {"snmpIPXDomain",   5, 23}, {"rfc1157Domain", 6, 29},
/*24*/	{"snmpProxys",     2, 27},	{"rfc1157Proxy",    1, 29},	{"rfc1157Domain", 1, 29},
/*27*/	{"snmpModules",    3, 28},	{"joint-iso-ccitt", 2, 28}
};


// DESCRIPTION:
//		Adds list of nodes from lstChildren	to the tail of m_recursionTrace,
//		constructing at the same time the OID lexicographically order.
//		the list received as parameter should not be modified;
// PARAMETERS:
//		(in) list of nodes to add
void OidTreeScanner::UpdateRecursionTrace(SIMCNodeList *pLstChildren, SIMCNodeList *pLstTrace)
{
	int nChld;
	POSITION posChld;

	_ASSERT((pLstChildren != NULL) && (pLstTrace != NULL), "NULL parameter error!", NULL);

	// for each node from the children list
	for (posChld = pLstChildren->GetHeadPosition(), nChld=0;
	     posChld != NULL;
		 nChld++)
	{
		int nList;
		POSITION posList;
		SIMCOidTreeNode *nodeChld, *nodeList;
		
		nodeChld = pLstChildren->GetNext(posChld);
		nodeList = NULL;

		// if it's the first child to add, it goes at the head of the list
		if (nChld == 0)
		{
			_ASSERT(pLstTrace->AddHead(nodeChld)!=NULL,
				    "Memory Allocation error",
					NULL);
		}
		// otherwise, the head of the list should be an ordered list of
		// maximum nChld nodes. The new node is inserted in this list
		// with respect to it's value.
		else
		{
			// there are at least nChld nodes in m_recursionTrace
			for (nList=0, posList = pLstTrace->GetHeadPosition();
				 nList < nChld;
				 nList++)
			{
				POSITION posBackup = posList;

				nodeList = (SIMCOidTreeNode *)pLstTrace->GetNext(posBackup);
				_ASSERT(nodeList != NULL, "Internal OidNode List error!", NULL);

				// if the node to add has the value less then the current node, it
				// should be inserted in the list right before it.
				if (nodeChld->GetValue() < nodeList->GetValue())
					break;
				posList = posBackup;
			}
			if (posList != NULL)
			{
				_ASSERT(pLstTrace->InsertBefore(posList, nodeChld)!=NULL,
					    "Memory allocation error",
						NULL);
			}
			else
			{
				_ASSERT(pLstTrace->AddTail(nodeChld)!=NULL,
						"Memory allocation error",
						NULL);
			}
		}
	}
}

// DESCRIPTION:
//		Gets the first symbol from the symbol list of the node pOidNode
// PARAMETERS:
//		(in) pOidNode whose symbol is to be returned
//		(out) cszSymbol - pointer to the symbol (do not alter or free)
// RETURN VALUE:
//		0 on success, -1 on failure
int OidTreeScanner::GetNodeSymbol(const SIMCOidTreeNode *pOidNode, const char * & cszSymbol)
{
	const SIMCSymbolList *pSymbolList;

	_VERIFY(pOidNode != NULL, -1);
	pSymbolList = pOidNode->GetSymbolList();
	_VERIFY(pSymbolList != NULL, -1);

	if (pSymbolList->IsEmpty())
	{
		cszSymbol = (pOidNode->_pParam != NULL) ? (const char *)pOidNode->_pParam : NULL;
	}
	else
	{
		const SIMCSymbol **ppSymbol;

		ppSymbol = pSymbolList->GetHead();
		_VERIFY(ppSymbol != NULL && *ppSymbol != NULL, -1);

		cszSymbol = (*ppSymbol)->GetSymbolName();
	}
	return 0;
}

// DESCRIPTION:
//		Gets the complete OID information for the given pOidNode.
//		It supplies both the numeric value and symbolic name for each
//		component of the OID.
// PARAMETERS:
//      (in) pOidNode - the node whose OID is to be found
//      (out) oid - the Oid object who stores the data
// RETURN VALUE:
//      0 on success 
//		-1 on failure
int OidTreeScanner::GetNodeOid(const SIMCOidTreeNode *pOidNode, Oid &oid)
{
	_VERIFY(pOidNode != NULL, -1);
	_VERIFY(m_pOidTree != NULL, -1);
	do
	{
		const char * cszSymbol = NULL;

		_VERIFY(GetNodeSymbol(pOidNode, cszSymbol)==0, -1);

		_VERIFY(oid.AddComponent(pOidNode->GetValue(), cszSymbol)==0, -1);

		pOidNode = m_pOidTree->GetParentOf(pOidNode);
	} while (pOidNode != NULL);
	oid.ReverseComponents();

	return 0;
}


// initializes the OidTreeScanner
OidTreeScanner::OidTreeScanner()
{
	m_pOidTree = NULL;
}

// DESCRIPTION:
//		scans lexicographically the oid tree;
// RETURN VALUE:
//		0 on success
//		-1 on failure;
int OidTreeScanner::Scan()
{
	SIMCOidTreeNode *pOidNode;
	SIMCNodeList recursionTrace;

	// get the root node from the oid tree,
	// return "error" if no tree or no root
	_VERIFY(m_pOidTree != NULL, -1);
	pOidNode = (SIMCOidTreeNode *)m_pOidTree->GetRoot();
	_VERIFY(pOidNode != NULL, -1);

	// initialize the recursion trace list with the root node
	_VERIFY(recursionTrace.AddHead(pOidNode)!=NULL, -1);

	// start to scan the tree
	while (!recursionTrace.IsEmpty())
	{
		// list of current node's children
		SIMCNodeList *lstChildren;

		// allways pick up the node in the head of the list
		pOidNode = recursionTrace.GetHead();

		// then erase it from the list
		recursionTrace.RemoveAt(recursionTrace.GetHeadPosition());

		// check to see if the scanner should stop (with error code)
		_VERIFY(OnScanNode(pOidNode)==0, -1);

		// get the list of children
		lstChildren = (SIMCNodeList *)pOidNode->GetListOfChildNodes();

		// if there are children
		if (lstChildren != NULL)
			// add children to the head of the trace list
			UpdateRecursionTrace(lstChildren, &recursionTrace);
	}
	return 0;
}

// DESCRIPTION:
//		Fills the symbols of the built-in objects from the static table
// RETURN VALUE:
//		0 - on success, -1 on failure
int OidTreeScanner::MergeBuiltIn()
{
	SIMCNodeList lstOidStack;
	SIMCOidTreeNode	*pOid;
	CList <unsigned int, unsigned int> wlstBuiltinStack;
	unsigned int nBuiltin;
	
	// initialize the two stacks with the root nodes from 
	// the oid tree and from the builtin symbols
	pOid = (SIMCOidTreeNode *)m_pOidTree->GetRoot();
	_VERIFY(pOid != NULL, -1);
	_VERIFY(lstOidStack.AddHead(pOid)!=NULL, -1);
	_VERIFY(wlstBuiltinStack.AddHead((unsigned int)0)!=NULL, -1);

	// as long as there are items on the stack, process each item
	// item is processed only if it doesn't have a symbol associated
	while(!lstOidStack.IsEmpty())
	{
		const SIMCSymbolList *pSymbolList;

		pOid = lstOidStack.RemoveHead();
		nBuiltin = wlstBuiltinStack.RemoveHead();
		pSymbolList = pOid->GetSymbolList();
		_VERIFY(pSymbolList != NULL, -1);

		// if node already has a symbol attached, no need to dive deeper
		if (!pSymbolList->IsEmpty())
			continue;
		else
		{
			const SIMCNodeList *pChildList;

			pOid->_pParam = (void *)g_BuiltinOIDs[nBuiltin].m_szSymbol;

			// now push new nodes on the stacks
			pChildList = pOid->GetListOfChildNodes();
			_VERIFY(pChildList != NULL, -1);
			for (POSITION p = pChildList->GetHeadPosition(); p != NULL;)
			{
				unsigned int i;

				pOid = pChildList->GetNext(p);
				_VERIFY(pOid != NULL, -1);

				// the child nodes always begin at index nBuiltin+1 (if they exist)
				// and end before the parent's first sibling node.
				for (i = nBuiltin+1;
					 i < g_BuiltinOIDs[nBuiltin].m_nNextSibling;
					 i = g_BuiltinOIDs[i].m_nNextSibling)
				{
					// when the match is found, push both nodes on their stacks (in sync)
					// and go to another child
					if (g_BuiltinOIDs[i].m_nSubID == (UINT)pOid->GetValue())
					{
						_VERIFY(lstOidStack.AddHead(pOid)!=NULL, -1);
						_VERIFY(wlstBuiltinStack.AddHead(i)!=NULL, -1);
						break;
					}
				}
			}
		}
	}
	return 0;
}

// DESCRIPTION:
//		initializes the m_pOidTree.
// PARAMETERS:
//		(in) pointer to the SIMCOidTree to scan.
void OidTreeScanner::SetOidTree(SIMCOidTree *pOidTree)
{
	m_pOidTree = pOidTree;
}

OidTreeScanner::~OidTreeScanner()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\oidtof.hpp ===
#include "OTScan.hpp"

#ifndef _OIDTOFILE_HPP
#define _OIDTOFILE_HPP

class SIMCOidTreeNode;

class OidToFile : public OidTreeScanner
{
	typedef struct _FileNode
	{
		long	lNextOffset;
		UINT	uNumChildren;
		UINT	uStrLen;
		LPSTR	lpszTextSubID;
		UINT	uNumSubID;
	} T_FILE_NODE;

    // mib.bin file actually needs the following platform independent format 
    // on 32bit(x86) and 64bit(ia64) environment. The uReserved field is used
    // for backward compatibility to T_FILE_NODE on 32bit platform because
    // mib.bin file format has been around since NT 3.51 time frame.
    typedef struct _FileNodeEx 
    {
        long                 lNextOffset;  // This field must remain first
        UINT                 uNumChildren;
        UINT                 uStrLen;
        UINT                 uReserved;
        UINT                 uNumSubID;
    } T_FILE_NODE_EX;

	HFILE		m_hMibFile;
	const char	*m_pszMibFilename;
public:
	OidToFile();

	// DESCRIPTION:
	//		wrapper for the base class Scan();
	//		it find first the sizes of subtrees;
	// RETURN VALUE:
	//		0 on success
	//		-1 on failure;
	virtual int Scan();

	// DESCRIPTION:
	//		Creates the output file, containing the OID encoding
	// PARAMETERS:
	//		(in) pointer to the output file name
	// RETURN VALUE:
	//		0 on success, -1 on failure
	int SetMibFilename(const char * pszMibFilename);

	// DESCRIPTION:
	//		"callback" function, called each time a
	//		tree node passes through the scan. The user
	//		should redefine this function in the derived
	//		object to perform the action desired.
	// PARAMETERS:
	//		(in) Pointer to the current node in the tree.
	//			 Nodes are supplied in lexicographic order.
	// RETURN VALUE:
	//		0  - the scanner should continue
	//		-1 - the scanner should abort.
	int OnScanNode(const SIMCOidTreeNode *pOidNode);

	~OidToFile();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\mgmtapi\dll\mgmtapi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mgmtapi.c

Abstract:

    SNMP Management API (wrapped around WinSNMP API).

Environment:

    User Mode - Win32

Revision History:

    05-Feb-1997 DonRyan
        Rewrote functions to be wrappers around WinSNMP.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include Files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wsipx.h>
#include <winsnmp.h>
#include <mgmtapi.h>
#include <oidconv.h>
#include <snmputil.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SNMP_MGR_SESSION {

    SOCKET            UnusedSocket;     // WARNING: Previous versions of the
    struct sockaddr   UnusedDestAddr;   // MGMTAPI.H header file exposed the
    LPSTR             UnusedCommunity;  // SNMP_MGR_SESSION structure which
    INT               UnusedTimeout;    // unfortunately encouraged people to
    INT               UnusedNumRetries; // muck with it.  Since this structure
    AsnInteger        UnusedRequestId;  // has now changed we must protect it.

    CRITICAL_SECTION  SessionLock;      // multiple threads may share session

    HSNMP_SESSION     hSnmpSession;     // handle to winsnmp session
    HSNMP_ENTITY      hAgentEntity;     // handle to agent entity
    HSNMP_ENTITY      hManagerEntity;   // handle to manager entity
    HSNMP_CONTEXT     hViewContext;     // handle to view context
    HSNMP_PDU         hPdu;             // handle to snmp pdu
    HSNMP_VBL         hVbl;             // handle to snmp pdu
    HWND              hWnd;             // handle to window

    smiINT32          nPduType;         // current pdu type
    smiINT32          nRequestId;       // current request id
    smiINT32          nErrorIndex;      // error index from pdu
    smiINT32          nErrorStatus;     // error status from pdu
    smiINT32          nLastError;       // last system error
    SnmpVarBindList * pVarBindList;     // pointer to varbind list

} SNMP_MGR_SESSION, *PSNMP_MGR_SESSION;

typedef struct _TRAP_LIST_ENTRY {

    LIST_ENTRY          Link;           // linked-list link
    AsnObjectIdentifier EnterpriseOID;  // generating enterprise
    AsnNetworkAddress   AgentAddress;   // generating agent addr
    AsnNetworkAddress   SourceAddress;  // generating network addr
    AsnInteger          nGenericTrap;   // generic trap type
    AsnInteger          nSpecificTrap;  // enterprise specific type
    AsnOctetString      Community;      // generating community
    AsnTimeticks        TimeStamp;      // time stamp
    SnmpVarBindList     VarBindList;    // variable bindings

} TRAP_LIST_ENTRY, * PTRAP_LIST_ENTRY;

#define IPADDRLEN           4
#define IPXADDRLEN          10

#define MAXENTITYSTRLEN     128

#define MINVARBINDLEN       2
#define SYSUPTIMEINDEX      0
#define SNMPTRAPOIDINDEX    1

#define DEFAULT_ADDRESS_IP  "127.0.0.1"
#define DEFAULT_ADDRESS_IPX "00000000.000000000000"

#define NOTIFICATION_CLASS  "MGMTAPI Notification Class"
#define WM_WSNMP_INCOMING   (WM_USER + 1)
#define WM_WSNMP_DONE       (WM_USER + 2)

#define WSNMP_FAILED(s)     ((s) == SNMPAPI_FAILURE)
#define WSNMP_SUCCEEDED(s)  ((s) != SNMPAPI_FAILURE)

#define WSNMP_ASSERT(s)     ASSERT((s))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HINSTANCE         g_hDll;                       // module handle
HANDLE            g_hTrapEvent = NULL;          // trap event handle
HANDLE            g_hTrapThread = NULL;         // trap thread handle
HANDLE            g_hTrapRegisterdEvent = NULL; // event to sync. SnmpMgrTrapListen
BOOL              g_fIsSnmpStarted = FALSE;     // indicates winsnmp inited
BOOL              g_fIsSnmpListening = FALSE;   // indicates trap thread on
BOOL              g_fIsTrapRegistered = FALSE;  // indicates trap registered
DWORD             g_dwRequestId = 1;            // unique pdu request id
LIST_ENTRY        g_IncomingTraps;              // incoming trap queue
CRITICAL_SECTION  g_GlobalLock;                 // process resource lock
SNMP_MGR_SESSION  g_TrapSMS;                    // process trap session


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
GetRequestId(
    )

/*++

Routine Description:

    Retrieve next global request id.

Arguments:

    None.

Return Values:

    Returns request id.

--*/

{
    DWORD dwRequestId;

    // obtain exclusive access to request id
    EnterCriticalSection(&g_GlobalLock);

    // obtain copy of request id
    dwRequestId = g_dwRequestId++;

    // obtain exclusive access to request id
    LeaveCriticalSection(&g_GlobalLock);

    return dwRequestId;
}


BOOL
TransferVb(
    PSNMP_MGR_SESSION pSMS,
    SnmpVarBind *     pVarBind
    )

/*++

Routine Description:

    Transfer VarBind structure to WinSNMP structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

    pVarBind - pointer to varbind to transfer.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    smiVALUE tmpValue;
    smiOID tmpOID;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate pointers
    if ((pVarBind != NULL) &&
        (pVarBind->name.ids != NULL) &&
        (pVarBind->name.idLength != 0)) {

        // re-init
        fOk = TRUE;

        // transfer oid information
        tmpOID.len = pVarBind->name.idLength;
        tmpOID.ptr = pVarBind->name.ids;

        // only initialize value if set
        if (pSMS->nPduType == SNMP_PDU_SET) {

            // syntax values are equivalent
            tmpValue.syntax = (smiINT32)(BYTE)pVarBind->value.asnType;

            // determine type
            switch (pVarBind->value.asnType) {

            case ASN_INTEGER32:

                // transfer signed int
                tmpValue.value.sNumber = pVarBind->value.asnValue.number;
                break;

            case ASN_UNSIGNED32:
            case ASN_COUNTER32:
            case ASN_GAUGE32:
            case ASN_TIMETICKS:

                // transfer unsigned int
                tmpValue.value.uNumber = pVarBind->value.asnValue.unsigned32;
                break;

            case ASN_COUNTER64:

                // transfer 64-bit counter
                tmpValue.value.hNumber.lopart =
                    pVarBind->value.asnValue.counter64.LowPart;
                tmpValue.value.hNumber.hipart =
                    pVarBind->value.asnValue.counter64.HighPart;
                break;

            case ASN_OPAQUE:
            case ASN_IPADDRESS:
            case ASN_OCTETSTRING:
            case ASN_BITS:

                // transfer octet string
                tmpValue.value.string.len =
                    pVarBind->value.asnValue.string.length;
                tmpValue.value.string.ptr =
                    pVarBind->value.asnValue.string.stream;
                break;

            case ASN_OBJECTIDENTIFIER:

                // transfer object id
                tmpValue.value.oid.len =
                    pVarBind->value.asnValue.object.idLength;
                tmpValue.value.oid.ptr =
                    pVarBind->value.asnValue.object.ids;
                break;

            case ASN_NULL:
            case SNMP_EXCEPTION_NOSUCHOBJECT:
            case SNMP_EXCEPTION_NOSUCHINSTANCE:
            case SNMP_EXCEPTION_ENDOFMIBVIEW:

                // initialize empty byte
                tmpValue.value.empty = 0;
                break;

            default:

                // failure
                fOk = FALSE;
                break;
            }
        }

        if (fOk) {

            // register varbind
            status = SnmpSetVb(
                        pSMS->hVbl,
                        0, // index
                        &tmpOID,
                        (pSMS->nPduType == SNMP_PDU_SET)
                            ? &tmpValue
                            : NULL
                        );

            // validate return code
            if (WSNMP_FAILED(status)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpSetVb returned %d.\n",
                    SnmpGetLastError(pSMS->hSnmpSession)
                    ));

                // failure
                fOk = FALSE;
            }
        }
    }

    return fOk;
}


BOOL
AllocateVbl(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Transfer VarBindList structure to WinSNMP structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    SnmpVarBind * pVarBind;
    DWORD cVarBind;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate parameters
    WSNMP_ASSERT(pSMS->pVarBindList != NULL);
    WSNMP_ASSERT(pSMS->pVarBindList->len != 0);
    WSNMP_ASSERT(pSMS->pVarBindList->list != NULL);

    // allocate resources for variable bindings list
    pSMS->hVbl = SnmpCreateVbl(pSMS->hSnmpSession, NULL, NULL);

    // validate varbind handle
    if (WSNMP_SUCCEEDED(pSMS->hVbl)) {

        // re-init
        fOk = TRUE;

        // initialize varbind pointer
        pVarBind = pSMS->pVarBindList->list;

        // initialize varbind count
        cVarBind = pSMS->pVarBindList->len;

        // process each varbind
        while (fOk && cVarBind--) {

            // transfer variable binding
            fOk = TransferVb(pSMS, pVarBind++);
        }

        if (!fOk) {

            // release varbind list handle
            status = SnmpFreeVbl(pSMS->hVbl);

            // validate return code
            if (WSNMP_FAILED(status)) {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpFreeVbl returned %d.\n",
                    SnmpGetLastError(pSMS->hSnmpSession)
                    ));
            }

            // re-initialize
            pSMS->hVbl = (HSNMP_VBL)NULL;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpCreateVbl returned %d.\n",
            SnmpGetLastError(pSMS->hSnmpSession)
            ));
    }

    return fOk;
}


BOOL
FreeVbl(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Cleanup VarBind resources from WinSNMP structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate handle
    if (pSMS->hVbl != (HSNMP_VBL)NULL) {

        // actually release vbl handle
        status = SnmpFreeVbl(pSMS->hVbl);

        // validate return code
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreeVbl returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize handle
        pSMS->hVbl = (HSNMP_VBL)NULL;
    }

    return fOk;
}


BOOL
AllocatePdu(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Initialize session structure for sending request.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // transfer varbinds
    if (AllocateVbl(pSMS)) {

        // grab next shared request id
        pSMS->nRequestId = GetRequestId();

        // create request pdu
        pSMS->hPdu = SnmpCreatePdu(
                        pSMS->hSnmpSession,
                        pSMS->nPduType,
                        pSMS->nRequestId,
                        0, // errorStatus
                        0, // errorIndex
                        pSMS->hVbl
                        );

        // validate return status
        if (WSNMP_SUCCEEDED(pSMS->hPdu)) {

            // success
            fOk = TRUE;

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpCreatePdu returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // free resources
            FreeVbl(pSMS);
        }
    }

    return fOk;
}


BOOL
FreePdu(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Cleanup session structure after processing response.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // validate handle
    if (pSMS->hPdu != (HSNMP_PDU)NULL) {

        // free vbl
        FreeVbl(pSMS);

        // actually release pdu handle
        status = SnmpFreePdu(pSMS->hPdu);

        // validate return code
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreePdu returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize handle
        pSMS->hPdu = (HSNMP_PDU)NULL;
    }

    return fOk;
}


BOOL
CopyOid(
    AsnObjectIdentifier * pDstOID,
    smiLPOID              pSrcOID
    )

/*++

Routine Description:

    Copies object identifier from WinSNMP format to MGMTAPI format.

Arguments:

    pDstOID - points to MGMTAPI structure to receive OID.

    pSrcOID - points to WinSNMP structure to copy.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate pointers
    WSNMP_ASSERT(pDstOID != NULL);
    WSNMP_ASSERT(pSrcOID != NULL);
    WSNMP_ASSERT(pSrcOID->len != 0);
    WSNMP_ASSERT(pSrcOID->ptr != NULL);

    // store the number of subids
    pDstOID->idLength = pSrcOID->len;

    // allocate memory for subidentifiers
    pDstOID->ids = SnmpUtilMemAlloc(pDstOID->idLength * sizeof(DWORD));

    // validate pointer
    if (pDstOID->ids != NULL) {

        // transfer memory
        memcpy(pDstOID->ids,
               pSrcOID->ptr,
               pDstOID->idLength * sizeof(DWORD)
               );

        // success
        fOk = TRUE;
    }

    // now release memory for original oid
    SnmpFreeDescriptor(SNMP_SYNTAX_OID, (smiLPOPAQUE)pSrcOID);

    return fOk;
}


BOOL
CopyOctets(
    AsnOctetString * pDstOctets,
    smiLPOCTETS      pSrcOctets
    )

/*++

Routine Description:

    Copies octet string from WinSNMP format to MGMTAPI format.

Arguments:

    pDstOctets - points to MGMTAPI structure to receive octets.

    pSrcOctets - points to WinSNMP structure to copy.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;

    // validate pointers
    WSNMP_ASSERT(pDstOctets != NULL);
    WSNMP_ASSERT(pSrcOctets != NULL);

    // it is legitimate that 
    // 1. pSrcOctets->len == 0
    // 2. pSrcOctets->ptr == NULL

    if (pSrcOctets->len == 0 || pSrcOctets->ptr == NULL)
    {
        pDstOctets->dynamic = FALSE;
        pDstOctets->length = 0;
        pDstOctets->stream = NULL;
        fOk = TRUE;
    }
    else
    {
        // allocate memory for octet string
        pDstOctets->stream = SnmpUtilMemAlloc(pSrcOctets->len);

        // validate pointer
        if (pDstOctets->stream != NULL) {

            // octet string allocated
            pDstOctets->dynamic = TRUE;

            // store the number of bytes
            pDstOctets->length = pSrcOctets->len;
       
            // transfer memory
            memcpy(pDstOctets->stream,
                   pSrcOctets->ptr,
                   pDstOctets->length
                   );

            // success
            fOk = TRUE;
        }
    }

    // now release memory for original string
    SnmpFreeDescriptor(SNMP_SYNTAX_OCTETS, (smiLPOPAQUE)pSrcOctets);

    return fOk;
}


CopyVb(
    PSNMP_MGR_SESSION pSMS,
    DWORD             iVarBind,
    SnmpVarBind *     pVarBind
    )

/*++

Routine Description:

    Copy variable binding from WinSNMP structure to MGMTAPI structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

    iVarBind - index of varbind structure to copy.

    pVarBind - pointer to varbind structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    smiOID tmpOID;
    smiVALUE tmpValue;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(pVarBind != NULL);

    // attempt to retrieve varbind data from winsnmp structure
    status = SnmpGetVb(pSMS->hVbl, iVarBind, &tmpOID, &tmpValue);

    // validate return code
    if (WSNMP_SUCCEEDED(status)) {

        // transfer object identifier value
        fOk = CopyOid(&pVarBind->name, &tmpOID);

        // syntax values are equivalent
        pVarBind->value.asnType = (BYTE)(smiINT32)tmpValue.syntax;

        // determine syntax
        switch (tmpValue.syntax) {

        case SNMP_SYNTAX_INT32:

            // transfer signed int
            pVarBind->value.asnValue.number = tmpValue.value.sNumber;
            break;

        case SNMP_SYNTAX_UINT32:
        case SNMP_SYNTAX_CNTR32:
        case SNMP_SYNTAX_GAUGE32:
        case SNMP_SYNTAX_TIMETICKS:

            // transfer unsigned int
            pVarBind->value.asnValue.unsigned32 = tmpValue.value.uNumber;
            break;

        case SNMP_SYNTAX_CNTR64:

            // transfer 64-bit counter
            pVarBind->value.asnValue.counter64.LowPart =
                tmpValue.value.hNumber.lopart;
            pVarBind->value.asnValue.counter64.HighPart =
                tmpValue.value.hNumber.hipart;
            break;

        case SNMP_SYNTAX_OPAQUE:
        case SNMP_SYNTAX_IPADDR:
        case SNMP_SYNTAX_OCTETS:
        case SNMP_SYNTAX_BITS:

            // transfer octet string
            if (!CopyOctets(&pVarBind->value.asnValue.string,
                            &tmpValue.value.string)) {
              
                // re-initialize
                pVarBind->value.asnType = ASN_NULL;

                // failure
                fOk = FALSE;
            }

            break;

        case SNMP_SYNTAX_OID:

            // transfer object identifier
            if (!CopyOid(&pVarBind->value.asnValue.object,
                         &tmpValue.value.oid)) {

                // re-initialize
                pVarBind->value.asnType = ASN_NULL;

                // failure
                fOk = FALSE;
            }

            break;

        case SNMP_SYNTAX_NULL:
        case SNMP_SYNTAX_NOSUCHOBJECT:
        case SNMP_SYNTAX_NOSUCHINSTANCE:
        case SNMP_SYNTAX_ENDOFMIBVIEW:

            break; // do nothing...

        default:

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpGetVb returned invalid type.\n"
                ));

            // re-initialize
            pVarBind->value.asnType = ASN_NULL;

           // failure
            fOk = FALSE;

            break;
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpGetVb returned %d.\n",
            SnmpGetLastError(pSMS->hSnmpSession)
            ));
    }

    return fOk;
}


BOOL
CopyVbl(
    PSNMP_MGR_SESSION pSMS,
    SnmpVarBindList * pVarBindList
    )

/*++

Routine Description:

    Copy variable bindings from WinSNMP structure to MGMTAPI structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

    pVarBindList - pointer to varbind list structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(pVarBindList != NULL);

    // initialize
    pVarBindList->len  = 0;
    pVarBindList->list = NULL;

    // validate varbind list handle
    if (pSMS->hVbl != (HSNMP_VBL)NULL) {

        // determine number of varbinds
        pVarBindList->len = SnmpCountVbl(pSMS->hVbl);

        // validate number of varbinds
        if (WSNMP_SUCCEEDED(pVarBindList->len)) {

            // allocate memory for varbinds
            pVarBindList->list = SnmpUtilMemAlloc(
                                    pVarBindList->len *
                                    sizeof(SnmpVarBind)
                                    );

            // validate pointer
            if (pVarBindList->list != NULL) {

                DWORD cVarBind = 1;
                SnmpVarBind * pVarBind;

                // save pointer to varbinds
                pVarBind = pVarBindList->list;

                // process varbinds in the list
                while (fOk && (cVarBind <= pVarBindList->len)) {

                    // copy varbind from winsnmp to mgmtapi
                    fOk = CopyVb(pSMS, cVarBind++, pVarBind++);
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Could not allocate VBL.\n"
                    ));

                // re-initialize
                pVarBindList->len = 0;

                // failure
                fOk = FALSE;
            }

        } else if (pVarBindList->len != SNMPAPI_NOOP) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpCountVbl returned %s.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pVarBindList->len = 0;

            // failure
            fOk = FALSE;
        }
    }

    if (!fOk) {

        // cleanup any varbinds allocated
        SnmpUtilVarBindListFree(pVarBindList);
    }

    return fOk;
}


BOOL
ParseVbl(
    PSNMP_MGR_SESSION pSMS,
    PTRAP_LIST_ENTRY  pTLE
    )

/*++

Routine Description:

    Parse varbind list for trap-related varbinds.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

    pTLE - pointer to trap list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SnmpVarBind * pVarBind;
    AsnObjectIdentifier * pOID;
    AsnNetworkAddress   * pAgentAddress = NULL;
    AsnObjectIdentifier * pEnterpriseOID = NULL;

    // object identifiers to convert snmpv2 trap format
    static UINT _sysUpTime[]             = { 1, 3, 6, 1, 2, 1, 1, 3       };
    static UINT _snmpTrapOID[]           = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1 };
    static UINT _snmpAddress[]           = { 1, 3, 6, 1, 3, 1057, 1       };
    static UINT _snmpTrapEnterprise[]    = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 3 };
    static UINT _snmpTraps[]             = { 1, 3, 6, 1, 6, 3, 1, 1, 5    };

    static AsnObjectIdentifier sysUpTime          = DEFINE_OID(_sysUpTime);
    static AsnObjectIdentifier snmpTrapOID        = DEFINE_OID(_snmpTrapOID);
    static AsnObjectIdentifier snmpAddress        = DEFINE_OID(_snmpAddress);
    static AsnObjectIdentifier snmpTrapEnterprise = DEFINE_OID(_snmpTrapEnterprise);
    static AsnObjectIdentifier snmpTraps          = DEFINE_OID(_snmpTraps);

    // validate pointers
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(pTLE != NULL);

    // validate vbl have minimum entries
    if (pTLE->VarBindList.len >= MINVARBINDLEN) {

        // point to sysUpTime varbind structure
        pVarBind = &pTLE->VarBindList.list[SYSUPTIMEINDEX];

        // verify variable is sysUpTime
        if ((pVarBind->value.asnType == ASN_TIMETICKS) &&
            !SnmpUtilOidNCmp(&pVarBind->name,
                             &sysUpTime,
                             sysUpTime.idLength)) {

            // transfer sysUpTime value to trap entry
            pTLE->TimeStamp = pVarBind->value.asnValue.ticks;

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Could not find sysUpTime.\n"
                ));

            goto cleanup; // bail...
        }

        // see if any additional varbinds present
        if (pTLE->VarBindList.len > MINVARBINDLEN) {

            // point to snmpTrapEnterprise varbind structure (maybe)
            pVarBind = &pTLE->VarBindList.list[pTLE->VarBindList.len - 1];

            // verify variable is snmpTrapEnterprise
            if ((pVarBind->value.asnType == ASN_OBJECTIDENTIFIER) &&
                !SnmpUtilOidNCmp(&pVarBind->name,
                                 &snmpTrapEnterprise,
                                 snmpTrapEnterprise.idLength))  {

                // transfer enterprise oid to list entry
                pTLE->EnterpriseOID = pVarBind->value.asnValue.object;

                // store enterprise oid for later
                pEnterpriseOID = &pTLE->EnterpriseOID;

                // modify type to avoid deallocation
                pVarBind->value.asnType = ASN_NULL;

            } else {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "MGMTAPI: Could not find snmpTrapEnterprise.\n"
                    ));
            }
        }

        // see if the agent address is present
        if (pTLE->VarBindList.len > MINVARBINDLEN+1) {
            
            // point to snmpAddress varbind structure (maybe)
            pVarBind = &pTLE->VarBindList.list[pTLE->VarBindList.len - 2];

            // verify variable is snmpAddress
            if ((pVarBind->value.asnType == SNMP_SYNTAX_IPADDR) &&
                !SnmpUtilOidNCmp(&pVarBind->name,
                                 &snmpAddress,
                                 snmpAddress.idLength))  {

                // transfer agent address oid to list entry
                pTLE->AgentAddress = pVarBind->value.asnValue.address;

                // store agent address for later
                pAgentAddress = &pTLE->AgentAddress;

                // modify type to avoid deallocation
                pVarBind->value.asnType = ASN_NULL;

            } else {

                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "MGMTAPI: Could not find snmpAddress.\n"
                    ));
            }
        }

        // point to snmpTrapOID varbind structure
        pVarBind = &pTLE->VarBindList.list[SNMPTRAPOIDINDEX];

        // verify variable is snmpTrapOID
        if ((pVarBind->value.asnType == ASN_OBJECTIDENTIFIER) &&
            !SnmpUtilOidNCmp(&pVarBind->name,
                             &snmpTrapOID,
                             snmpTrapOID.idLength))  {

            // retrieve pointer to oid
            pOID = &pVarBind->value.asnValue.object;

            // check for generic trap
            if (!SnmpUtilOidNCmp(pOID,
                                 &snmpTraps,
                                 snmpTraps.idLength)) {

                // validate size is one greater than root
                if (pOID->idLength == (snmpTraps.idLength + 1)) {

                    // retrieve trap id
                    // --ft:10/01/98 (bug #231344): WINSNMP gives up the V2 syntax => pOID->ids[snmpTraps.idLength] = [1..6]
                    // --ft:10/01/98 (bug #231344): as MGMTAPI turns back to V1, we need to decrement this value.
                    pTLE->nGenericTrap = (pOID->ids[snmpTraps.idLength])-1;

                    // re-initialize
                    pTLE->nSpecificTrap = 0;

                } else {

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "MGMTAPI: Invalid snmpTrapOID.\n"
                        ));

                    goto cleanup; // bail...
                }

            // check for specific trap
            } else if ((pEnterpriseOID != NULL) &&
                       !SnmpUtilOidNCmp(pOID,
                                        pEnterpriseOID,
                                        pEnterpriseOID->idLength)) {

                // validate size is two greater than root
                if (pOID->idLength == (pEnterpriseOID->idLength + 2)) {

                    // validate separator sub-identifier
                    WSNMP_ASSERT(pOID->ids[pEnterpriseOID->idLength] == 0);

                    // retrieve trap id
                    pTLE->nSpecificTrap = pOID->ids[pEnterpriseOID->idLength + 1];

                    // re-initialize
                    pTLE->nGenericTrap = SNMP_GENERICTRAP_ENTERSPECIFIC;

                } else {

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "MGMTAPI: Invalid snmpTrapOID.\n"
                        ));

                    goto cleanup; // bail...
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Could not identify snmpTrapOID.\n"
                    ));

               goto cleanup; // bail...
            }

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Could not find snmpTrapOID.\n"
                ));

            goto cleanup; // bail...
        }

        // check for enterprise oid
        if (pEnterpriseOID != NULL) {

            // release snmpTrapEnterprise varbind structure
            SnmpUtilVarBindFree(&pTLE->VarBindList.list[pTLE->VarBindList.len - 1]);

            // decrement the list length as the last varbind was freed
            pTLE->VarBindList.len--;
        }

        // check for agent address
        if (pAgentAddress != NULL) {

            // release snmpAgentAddress varbind structure
            SnmpUtilVarBindFree(&pTLE->VarBindList.list[pTLE->VarBindList.len - 1]);

            // decrement the list length as the last varbind was again freed
            pTLE->VarBindList.len--;
        }

        // release sysUpTime varbind structure
        SnmpUtilVarBindFree(&pTLE->VarBindList.list[SYSUPTIMEINDEX]);

        // release snmpTrapOID varbind structure
        SnmpUtilVarBindFree(&pTLE->VarBindList.list[SNMPTRAPOIDINDEX]);

        // subtract released varbinds
        pTLE->VarBindList.len -= MINVARBINDLEN;

        // check if all varbinds freed
        if (pTLE->VarBindList.len == 0) {

            // release memory for list
            SnmpUtilMemFree(pTLE->VarBindList.list);

            // re-initialize
            pTLE->VarBindList.list = NULL;

        } else {

            // shift varbind list up two spaces
            memmove((LPBYTE)(pTLE->VarBindList.list),
                    (LPBYTE)(pTLE->VarBindList.list + MINVARBINDLEN),
                    (pTLE->VarBindList.len * sizeof(SnmpVarBind))
                    );
        }

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: Too few subidentifiers.\n"
            ));
    }

    // success
    return TRUE;

cleanup:

    // failure
    return FALSE;
}


BOOL
FreeTle(
    PTRAP_LIST_ENTRY pTLE
    )

/*++

Routine Description:

    Release memory used for trap entry.

Arguments:

    pTLE - pointer to trap list entry.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    WSNMP_ASSERT(pTLE != NULL);

    // release memory for enterprise oid
    SnmpUtilOidFree(&pTLE->EnterpriseOID);

    // release memory for community string
    SnmpUtilMemFree(pTLE->Community.stream);

    // release memory used in varbind list
    SnmpUtilVarBindListFree(&pTLE->VarBindList);

    // release list entry
    SnmpUtilMemFree(pTLE);

    return TRUE;
}


BOOL
AllocateTle(
    PSNMP_MGR_SESSION  pSMS,
    PTRAP_LIST_ENTRY * ppTLE,
    HSNMP_ENTITY       hAgentEntity,
    HSNMP_CONTEXT      hViewContext
    )

/*++

Routine Description:

    Allocate memory for trap entry.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

    ppTLE - pointer to pointer to trap list entry.

    hAgentEntity - handle to agent sending trap.

    hViewContext - handle to view context of trap.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PTRAP_LIST_ENTRY pTLE;
    SNMPAPI_STATUS status;
    smiOCTETS CommunityStr;
    CHAR SourceStrAddr[MAXENTITYSTRLEN+1];
    struct sockaddr SourceSockAddr;

    // validate pointers
    WSNMP_ASSERT(pSMS != NULL);
    WSNMP_ASSERT(ppTLE != NULL);

    // allocate memory from list entry
    pTLE = SnmpUtilMemAlloc(sizeof(TRAP_LIST_ENTRY));

    // validate pointer
    if (pTLE == NULL) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: Could not allocate trap entry.\n"
            ));

        return FALSE; // bail...
    }

    // initialize
    *ppTLE = NULL;

    // copy varbinds to trap list entry
    if (!CopyVbl(pSMS, &pTLE->VarBindList)) {
        goto cleanup; // bail...
    }

    // parse trap-related varbinds
    if (!ParseVbl(pSMS, pTLE)) {
        goto cleanup; // bail...
    }

    // check if source address is specified
    if (hAgentEntity != (HSNMP_ENTITY)NULL) {

        // convert addr to string
        status = SnmpEntityToStr(
                    hAgentEntity,
                    sizeof(SourceStrAddr),
                    SourceStrAddr
                    );

        // validate error code
        if (WSNMP_SUCCEEDED(status)) {

            DWORD  AddrLen = 0;
            LPBYTE AddrPtr = NULL;

            // convert string to socket address structure
            SnmpSvcAddrToSocket(SourceStrAddr, &SourceSockAddr);

            // validate address family
            if (SourceSockAddr.sa_family == AF_INET) {

                // assign ip values
                AddrLen = IPADDRLEN;
                AddrPtr = (LPBYTE)&(((struct sockaddr_in *)
                            (&SourceSockAddr))->sin_addr);

            } else if (SourceSockAddr.sa_family == AF_IPX) {

                // assign ipx values
                AddrLen = IPXADDRLEN;
                AddrPtr = (LPBYTE)&(((struct sockaddr_ipx *)
                            (&SourceSockAddr))->sa_netnum);

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Ignoring invalid address.\n"
                    ));

                goto cleanup; // bail...
            }

            // allocate address to return (if specified)
            pTLE->SourceAddress.stream = SnmpUtilMemAlloc(AddrLen);

            // validate pointer
            if (pTLE->SourceAddress.stream != NULL) {

                // initialize length values
                pTLE->SourceAddress.length  = AddrLen;
                pTLE->SourceAddress.dynamic = TRUE;

                // transfer agent address information
                memcpy(pTLE->SourceAddress.stream, AddrPtr, AddrLen);
            }

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpEntityToStr returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }
    }

    // check if community specified
    if (hViewContext != (HSNMP_CONTEXT)NULL) {

        // convert agent entity to string
        status = SnmpContextToStr(hViewContext, &CommunityStr);

        // validate error code
        if (WSNMP_SUCCEEDED(status)) {

            // copy octet string, memory allocated in CommunityStr is also freed
            CopyOctets(&pTLE->Community, &CommunityStr);

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpContextToStr returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            goto cleanup; // bail...
        }
    }

    // transfer
    *ppTLE = pTLE;

    // success
    return TRUE;

cleanup:

    // release
    FreeTle(pTLE);

    // failure
    return FALSE;
}


BOOL
NotificationCallback(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Callback for processing notification messages.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    Returns true if processing finished.

--*/

{
    BOOL fDone = TRUE;
    SNMPAPI_STATUS status;
    HSNMP_ENTITY   hAgentEntity   = (HSNMP_ENTITY)NULL;
    HSNMP_ENTITY   hManagerEntity = (HSNMP_ENTITY)NULL;
    HSNMP_CONTEXT  hViewContext   = (HSNMP_CONTEXT)NULL;
    smiINT32       nPduType;
    smiINT32       nRequestId;

    // validate pointer
    WSNMP_ASSERT(pSMS != NULL);

    // retrieve message
    status = SnmpRecvMsg(
                pSMS->hSnmpSession,
                &hAgentEntity,
                &hManagerEntity,
                &hViewContext,
                &pSMS->hPdu
                );

    // validate return code
    if (WSNMP_SUCCEEDED(status)) {

        // retrieve pdu data
        status = SnmpGetPduData(
                    pSMS->hPdu,
                    &nPduType,
                    &nRequestId,
                    &pSMS->nErrorStatus,
                    &pSMS->nErrorIndex,
                    &pSMS->hVbl
                    );

        // validate return code
        if (WSNMP_SUCCEEDED(status)) {

            // process reponse to request
            if (nPduType == SNMP_PDU_RESPONSE) {

                // validate context information
                if ((pSMS->nRequestId == nRequestId) &&
                    (pSMS->hViewContext == hViewContext) &&
                    (pSMS->hAgentEntity == hAgentEntity) &&
                    (pSMS->hManagerEntity == hManagerEntity)) {

                    // validate returned error status
                    if (pSMS->nErrorStatus == SNMP_ERROR_NOERROR) {

                        SnmpVarBindList VarBindList;

                        // copy variable binding list
                        if (CopyVbl(pSMS, &VarBindList)) {

                            // release existing varbind list
                            SnmpUtilVarBindListFree(pSMS->pVarBindList);

                            // manually copy new varbind list
                            *pSMS->pVarBindList = VarBindList;

                        } else {

                            // modify last error status
                            pSMS->nLastError = SNMPAPI_ALLOC_ERROR;
                        }
                    }

                } else {

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "MGMTAPI: Ignoring invalid context.\n"
                        ));

                    // continue
                    fDone = FALSE;
                }

            } else if (nPduType == SNMP_PDU_TRAP) {

                PTRAP_LIST_ENTRY pTLE;

                // allocate trap list entry (transfers varbinds etc.)
                if (AllocateTle(pSMS, &pTLE, hAgentEntity, hViewContext)) {

                    // obtain exclusive access
                    EnterCriticalSection(&g_GlobalLock);

                    // insert new trap into the incoming queue
                    InsertTailList(&g_IncomingTraps, &pTLE->Link);

                    // alert user
                    SetEvent(g_hTrapEvent);

                    // release exclusive access
                    LeaveCriticalSection(&g_GlobalLock);
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Ignoring invalid pdu type %d.\n",
                    nPduType
                    ));

                // continue
                fDone = FALSE;
            }

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpGetPduData returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // retrieve last error status from winsnmp
            pSMS->nLastError = SnmpGetLastError(pSMS->hSnmpSession);
        }

        // release temporary entity
        SnmpFreeEntity(hAgentEntity);

        // release temporary entity
        SnmpFreeEntity(hManagerEntity);

        // release temporary context
        SnmpFreeContext(hViewContext);

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpRecvMsg returned %d.\n",
            SnmpGetLastError(pSMS->hSnmpSession)
            ));

        // retrieve last error status from winsnmp
        pSMS->nLastError = SnmpGetLastError(pSMS->hSnmpSession);
    }

    // release pdu
    FreePdu(pSMS);

    return fDone;
}


LRESULT
CALLBACK
NotificationWndProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Callback that processes WinSNMP notifications.

Arguments:

    hWnd - window handle.

    uMsg - message identifier.

    wParam - first message parameter.

    lParam - second message parameter.

Return Values:

    The return value is the result of the message processing and
    depends on the message sent.

--*/

{
    // check for winsnmp notification and transport timeout
    if (uMsg == WM_WSNMP_INCOMING && wParam == SNMPAPI_TL_TIMEOUT) {
        
        PSNMP_MGR_SESSION pSMS;

        // retrieve mgmtapi session pointer from window
        pSMS = (PSNMP_MGR_SESSION)GetWindowLongPtr(hWnd, 0);

        // validate session ptr
        WSNMP_ASSERT(pSMS != NULL);

        // translate winsnmp error to mgmtapi error
        pSMS->nLastError = SNMP_MGMTAPI_TIMEOUT;

        // post message to break out of message pump
        PostMessage(pSMS->hWnd, WM_WSNMP_DONE, (WPARAM)0, (LPARAM)0);
        
        return (LRESULT)0;
    }
    // check for winsnmp notification
    else if (uMsg == WM_WSNMP_INCOMING) {

        PSNMP_MGR_SESSION pSMS;

        // retrieve mgmtapi session pointer from window
        pSMS = (PSNMP_MGR_SESSION)GetWindowLongPtr(hWnd, 0);

        // validate session ptr
        WSNMP_ASSERT(pSMS != NULL);

        // process notification message
        if (NotificationCallback(pSMS)) {

            // post message to break out of message pump
            PostMessage(pSMS->hWnd, WM_WSNMP_DONE, (WPARAM)0, (LPARAM)0);
        }

        return (LRESULT)0;

    } else {

        // forward all other messages to windows
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
}


BOOL
RegisterNotificationClass(
    )

/*++

Routine Description:

    Register notification class for sessions.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    WNDCLASS wc;

    // initialize notification window class
    wc.lpfnWndProc   = (WNDPROC)NotificationWndProc;
    wc.lpszClassName = NOTIFICATION_CLASS;
    wc.lpszMenuName  = NULL;
    wc.hInstance     = g_hDll;
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = NULL;
    wc.cbWndExtra    = sizeof(PSNMP_MGR_SESSION);
    wc.cbClsExtra    = 0;
    wc.style         = 0;

    // register class
    fOk = RegisterClass(&wc);

    if (!fOk) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: RegisterClass returned %d.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
UnregisterNotificationClass(
    )

/*++

Routine Description:

    Unregister notification class.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // unergister notification window class
    fOk = UnregisterClass(NOTIFICATION_CLASS, g_hDll);

    if (!fOk) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: UnregisterClass returned %d.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
StartSnmpIfNecessary(
    )

/*++

Routine Description:

    Initialize WinSNMP DLL if necessary.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // serialize access to startup code
    EnterCriticalSection(&g_GlobalLock);

    // see if already started
    if (g_fIsSnmpStarted != TRUE) {

        SNMPAPI_STATUS status;

        // initialize start params
        smiUINT32 nMajorVersion   = 0;
        smiUINT32 nMinorVersion   = 0;
        smiUINT32 nLevel          = 0;
        smiUINT32 nTranslateMode  = 0;
        smiUINT32 nRetransmitMode = 0;

        // start winsnmp
        status = SnmpStartup(
                    &nMajorVersion,
                    &nMinorVersion,
                    &nLevel,
                    &nTranslateMode,
                    &nRetransmitMode
                    );

        // validate return code
        if (WSNMP_SUCCEEDED(status)) {

            SNMPDBG((
                SNMP_LOG_TRACE,
                "MGMTAPI: SnmpStartup succeeded:\n"
                "MGMTAPI:\tnMajorVersion   = %d\n"
                "MGMTAPI:\tnMinorVersion   = %d\n"
                "MGMTAPI:\tnLevel          = %d\n"
                "MGMTAPI:\tnTranslateMode  = %d\n"
                "MGMTAPI:\tnRetransmitMode = %d\n",
                nMajorVersion,
                nMinorVersion,
                nLevel,
                nTranslateMode,
                nRetransmitMode
                ));

            // allocate global trap available event
            g_hTrapEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

            // allocate global event to sync. SnmpMgrTrapListen
            g_hTrapRegisterdEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

            // make sure translate mode is snmp v1
            SnmpSetTranslateMode(SNMPAPI_UNTRANSLATED_V1);

            // make sure retransmit mode is on
            SnmpSetRetransmitMode(SNMPAPI_ON);

            // register notification class
            RegisterNotificationClass();

            // save new status
            g_fIsSnmpStarted = TRUE;

            // success
            fOk = TRUE;

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStartup returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }
    }

    // serialize access to startup code
    LeaveCriticalSection(&g_GlobalLock);

    return fOk;
}


BOOL
CleanupIfNecessary(
    )

/*++

Routine Description:

    Cleanup WinSNMP DLL if necessary.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // serialize access to startup code
    EnterCriticalSection(&g_GlobalLock);

    // see if already started
    if (g_fIsSnmpStarted == TRUE) {

        SNMPAPI_STATUS status;

        // shutdown winsnmp
        status = SnmpCleanup();

        // validate return code
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpCleanup returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // unregister notification class
        UnregisterNotificationClass();

        // save new status
        g_fIsSnmpStarted = FALSE;
    }

    // check trap handle
    if (g_hTrapEvent != NULL) {

        // close trap handle
        CloseHandle(g_hTrapEvent);

        // re-initialize
        g_hTrapEvent = NULL;
    }

    // serialize access to startup code
    LeaveCriticalSection(&g_GlobalLock);

    return fOk;
}


BOOL
CreateNotificationWindow(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Create notification window for session.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // create notification window
    pSMS->hWnd = CreateWindow(
                    NOTIFICATION_CLASS,
                    NULL,       // pointer to window name
                    0,          // window style
                    0,          // horizontal position of window
                    0,          // vertical position of window
                    0,          // window width
                    0,          // window height
                    NULL,       // handle to parent or owner window
                    NULL,       // handle to menu or child-window identifier
                    g_hDll,     // handle to application instance
                    NULL        // pointer to window-creation data
                    );

    // validate window handle
    if (pSMS->hWnd != NULL) {

        // store pointer to session in window
        SetWindowLongPtr(pSMS->hWnd, 0, (LONG_PTR)pSMS);

        // success
        fOk = TRUE;

    } else {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: CreateWindow returned %d.\n",
            GetLastError()
            ));

        // failure
        fOk = FALSE;
    }

    return fOk;
}


BOOL
DestroyNotificationWindow(
    HWND hWnd
    )

/*++

Routine Description:

    Destroy notification window for session.

Arguments:

    hWnd - window handle for session.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;

    // destroy notification window
    fOk = DestroyWindow(hWnd);

    if (!fOk) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: DestroyWindow returned %d.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
CloseSession(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Close WinSNMP session associated with MGMTAPI session.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    SNMPAPI_STATUS status;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // check if window opened
    if (pSMS->hWnd != (HWND)NULL) {

        // destroy notification window
        fOk = DestroyNotificationWindow(pSMS->hWnd);
    }

    // check if agent entity allocated
    if (pSMS->hAgentEntity != (HSNMP_ENTITY)NULL) {

        // close the entity handle
        status = SnmpFreeEntity(pSMS->hAgentEntity);

        // validate status
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreeEntity returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize
        pSMS->hAgentEntity = (HSNMP_ENTITY)NULL;
    }

    // check if manager entity allocated
    if (pSMS->hManagerEntity != (HSNMP_ENTITY)NULL) {

        // close the entity handle
        status = SnmpFreeEntity(pSMS->hManagerEntity);

        // validate status
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpFreeEntity returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize
        pSMS->hManagerEntity = (HSNMP_ENTITY)NULL;
    }

    // check if session allocated
    if (pSMS->hSnmpSession != (HSNMP_SESSION)NULL) {

        // close the winsnmp session
        status = SnmpClose(pSMS->hSnmpSession);

        // validate status
        if (WSNMP_FAILED(status)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpClose returned %d.\n",
                SnmpGetLastError((HSNMP_SESSION)NULL)
                ));

            // failure
            fOk = FALSE;
        }

        // re-initialize
        pSMS->hSnmpSession = (HSNMP_SESSION)NULL;
    }

    return fOk;
}

//SNMPAPI_STATUS SNMPAPI_CALL
//   SnmpConveyAgentAddress (SNMPAPI_STATUS mode);


BOOL
OpenSession(
    PSNMP_MGR_SESSION pSMS,
    LPSTR             pAgentAddress,
    LPSTR             pAgentCommunity,
    INT               nTimeOut,
    INT               nRetries
    )

/*++

Routine Description:

    Open WinSNMP session and associate with MGMTAPI session.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

    pAgentAddress - points to a null-terminated string specifying either a
        dotted-decimal IP address or a host name that can be resolved to an
        IP address, an IPX address (in 8.12 notation), or an ethernet address.

    pAgentCommunity - points to a null-terminated string specifying the
        SNMP community name used when communicating with the agent specified
        in the lpAgentAddress parameter

    nTimeOut - specifies the communications time-out in milliseconds.

    nRetries - specifies the communications retry count.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    struct sockaddr AgentSockAddr;
    CHAR AgentStrAddr[MAXENTITYSTRLEN+1];
    smiOCTETS smiCommunity;

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // initialize notification window
    if (!CreateNotificationWindow(pSMS)) {
        return FALSE; // bail...
    }

    // open a winsnmp session which corresponds to mgmtapi session
    pSMS->hSnmpSession = SnmpOpen(pSMS->hWnd, WM_WSNMP_INCOMING);

    // --ft
    // we need to turn this on in order to have WINSNMP to pass back not
    // only the entity standing for the source Ip address but also the
    // agent address as it was sent into the V1 Trap Pdu. Without it,
    // SnmpMgrGetTrapEx() will return a NULL address for the pSourceAddress
    // paramter. However, SnmpMgrGetTrapEx() is not documented!!!
    //SnmpConveyAgentAddress(SNMPAPI_ON); // Move this into wsnmp_cf.c:SnmpStartup
    // to avoid missing entry point problem when wsnmp32.dll is from other vendors

    // validate session handle returned
    if (WSNMP_FAILED(pSMS->hSnmpSession)) {

        SNMPDBG((
            SNMP_LOG_ERROR,
            "MGMTAPI: SnmpOpen returned %d.\n",
            SnmpGetLastError((HSNMP_SESSION)NULL)
            ));

        // re-initialize
        pSMS->hSnmpSession = (HSNMP_SESSION)NULL;

        goto cleanup; // bail...
    }

    // validate pointer
    if (pAgentAddress != NULL) {

        // use snmpapi.dll to do convert to sockets structure
        if (!SnmpSvcAddrToSocket(pAgentAddress, &AgentSockAddr)) {
            goto cleanup; // bail...
        }

        // check address family of agent
        if (AgentSockAddr.sa_family == AF_INET) {

            LPSTR pAgentStrAddr;
            struct sockaddr_in * pAgentSockAddr;

            // cast generic socket address structure to inet
            pAgentSockAddr = (struct sockaddr_in *)&AgentSockAddr;

            // obtain exclusive access to api
            EnterCriticalSection(&g_GlobalLock);

            // attempt to convert address into string
            pAgentStrAddr = inet_ntoa(pAgentSockAddr->sin_addr);

            // copy to stack variable
            strcpy(AgentStrAddr, pAgentStrAddr);

            // release exclusive access to api
            LeaveCriticalSection(&g_GlobalLock);

        } else if (AgentSockAddr.sa_family == AF_IPX) {

            // simply copy original string
            strcpy(AgentStrAddr, pAgentAddress);

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Incorrect address family.\n"
                ));

            goto cleanup; // bail...
        }

        // create remote agent entity
        pSMS->hAgentEntity = SnmpStrToEntity(
                                    pSMS->hSnmpSession,
                                    AgentStrAddr
                                    );

        // validate agent entity returned
        if (WSNMP_FAILED(pSMS->hAgentEntity)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStrToEntity returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pSMS->hAgentEntity = (HSNMP_ENTITY)NULL;

            goto cleanup; // bail...
        }

        // attach timeout specified with agent
        SnmpSetTimeout(pSMS->hAgentEntity, nTimeOut / 10);

        // attach retries specified with agent
        SnmpSetRetry(pSMS->hAgentEntity, nRetries);

        // create local manager entity
        pSMS->hManagerEntity = SnmpStrToEntity(
                                        pSMS->hSnmpSession,
                                        (AgentSockAddr.sa_family == AF_INET)
                                            ? DEFAULT_ADDRESS_IP
                                            : DEFAULT_ADDRESS_IPX
                                        );

        // validate manager entity returned
        if (WSNMP_FAILED(pSMS->hManagerEntity)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStrToEntity returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pSMS->hManagerEntity = (HSNMP_ENTITY)NULL;

            goto cleanup; // bail...
        }

        // attach timeout specified with manager
        SnmpSetTimeout(pSMS->hManagerEntity, nTimeOut / 10);

        // attach retries specified with manager
        SnmpSetRetry(pSMS->hManagerEntity, nRetries);
    }

    // validate pointer
    if (pAgentCommunity != NULL) {

        // transfer community string
        smiCommunity.ptr = (smiLPBYTE)pAgentCommunity;
        smiCommunity.len = pAgentCommunity ? lstrlen(pAgentCommunity) : 0;

        // obtain context from community string
        pSMS->hViewContext = SnmpStrToContext(
                                pSMS->hSnmpSession,
                                &smiCommunity
                                );

        // validate context handle
        if (WSNMP_FAILED(pSMS->hViewContext)) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpStrToContext returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // re-initialize
            pSMS->hViewContext = (HSNMP_CONTEXT)NULL;

            goto cleanup; // bail...
        }
    }

    // success
    return TRUE;

cleanup:

    // cleanup resources
    CloseSession(pSMS);

    // failure
    return FALSE;
}


BOOL
AllocateSession(
    PSNMP_MGR_SESSION * ppSMS
    )

/*++

Routine Description:

    Allocate mgmtapi session structure.

Arguments:

    ppSMS - pointer to session pointer to return.

Return Values:

    Returns true if successful.

--*/

{
    PSNMP_MGR_SESSION pSMS = NULL;

       __try
    {
        // allocate new session table entry
        pSMS = SnmpUtilMemAlloc(sizeof(SNMP_MGR_SESSION));

        // validate pointer
        if (pSMS != NULL) {

            // initialize session level lock
            InitializeCriticalSection(&pSMS->SessionLock);

        } else {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Could not allocate session.\n"
                ));

            // notify application of error
            SetLastError(SNMP_MEM_ALLOC_ERROR);
        }

        // transfer
        *ppSMS = pSMS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        if (pSMS != NULL)
        {
            SnmpUtilMemFree(pSMS);
            pSMS = NULL;
        }
    }

    // return status
    return (pSMS != NULL);
}


VOID
FreeSession(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Frees mgmtapi session structure.

Arguments:

    pSMS - pointer to mgmtapi session structure.

Return Values:

    None.

--*/

{
    // is session valid?
    if (pSMS != NULL) {

        // destroy the session level lock
        DeleteCriticalSection(&pSMS->SessionLock);

        // free session object
        SnmpUtilMemFree(pSMS);
    }
}


BOOL
ProcessAgentResponse(
    PSNMP_MGR_SESSION pSMS
    )

/*++

Routine Description:

    Message pump for notification window.

Arguments:

    pSMS - pointer to MGMTAPI session structure.

Return Values:

    Returns true if agent responded.

--*/

{
    MSG msg;
    BOOL fOk = FALSE;
    BOOL fRet; 

    // validate session ptr
    WSNMP_ASSERT(pSMS != NULL);

    // get the next message for this session
    while ((fRet = GetMessage(&msg, pSMS->hWnd, 0, 0))) {
        
        if (fRet == -1) {
            // If there is an error, GetMessage returns -1 
           
            pSMS->nLastError = SNMPAPI_OTHER_ERROR;

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: ProcessAgentResponse: GetMessage returns -1.\n"
                ));
            
            break;
        }

        // check for private message
        if (msg.message != WM_WSNMP_DONE) {

            // translate message
            TranslateMessage(&msg);

            // dispatch message
            DispatchMessage(&msg);

        } else {

            // success
            fOk = TRUE;

            break;
        }
    }

    return fOk;
}


DWORD
WINAPI
TrapThreadProc(
    LPVOID lpParam
    )

/*++

Routine Description:

    Trap processing procedure.

Arguments:

    lpParam - unused thread parameter.

Return Values:

    Returns NOERROR if successful.

--*/

{
    SNMPAPI_STATUS status;
    PSNMP_MGR_SESSION pSMS;

    SNMPDBG((
        SNMP_LOG_TRACE,
        "MGMTAPI: Trap thread starting...\n"
        ));

    // obtain pointer
    pSMS = &g_TrapSMS;

    // re-initialize
    pSMS->nLastError = 0;

    g_fIsTrapRegistered = FALSE; // init to failure. Note that there will
                                 // be only 1 instance of this thread


    // initialize winsnmp trap session
    if (OpenSession(pSMS, NULL, NULL, 0, 0)) 
    {

        // register
        status = SnmpRegister(
                    pSMS->hSnmpSession,
                    (HSNMP_ENTITY)NULL,     // hAgentEntity
                    (HSNMP_ENTITY)NULL,     // hManagerEntity
                    (HSNMP_CONTEXT)NULL,    // hViewContext
                    (smiLPCOID)NULL,        // notification
                    SNMPAPI_ON
                    );

        // validate return code
        if (WSNMP_SUCCEEDED(status)) 
        {
            // signal main thread that Trap has been registered with WinSNMP
            g_fIsTrapRegistered = TRUE;
            SetEvent(g_hTrapRegisterdEvent);

            // loop processing responses
            while (ProcessAgentResponse(pSMS)) 
            {

                //
                // processing done in window procedure...
                //
            }

        } 
        else 
        {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: SnmpRegister returned %d.\n",
                SnmpGetLastError(pSMS->hSnmpSession)
                ));

            // transfer last error to global structure
            pSMS->nLastError = SnmpGetLastError(pSMS->hSnmpSession);

            // signal main thread that there is an error 
            // in registering Trap with WinSNMP
            
            SetEvent(g_hTrapRegisterdEvent);
        }

    } 
    else 
    {

        // transfer last error to global structure
        pSMS->nLastError = SnmpGetLastError((HSNMP_SESSION)NULL);
        
        // signal main thread that there is an error 
        // in registering Trap with WinSNMP
      
        SetEvent(g_hTrapRegisterdEvent);
    }

    // free session
    CloseSession(pSMS);

    // obtain exclusive access
    EnterCriticalSection(&g_GlobalLock);

    // signal successful start
    g_fIsSnmpListening = FALSE;

    // release exclusive access
    LeaveCriticalSection(&g_GlobalLock);

    SNMPDBG((
        SNMP_LOG_TRACE,
        "MGMTAPI: Trap thread exiting...\n"
        ));

    // success
    return NOERROR;
}


BOOL
StartTrapsIfNecessary(
    HANDLE * phTrapAvailable
    )

/*++

Routine Description:

    Initializes global structures for trap listening.

Arguments:

    phTrapAvailable - pointer to event for signalling traps.

Return Values:

    Returns true if successful (must be called only once).

--*/

{
    BOOL fOk = FALSE;
    DWORD dwTrapThreadId;
    DWORD dwWaitTrapRegisterd;

    // validate pointer
    if (phTrapAvailable != NULL) 
    {

        // obtain exclusive access
        EnterCriticalSection(&g_GlobalLock);

        // transfer trap event to app
        *phTrapAvailable = g_hTrapEvent;

        // only start listening once
        if (g_fIsSnmpListening == FALSE) 
        {

            // spawn client trap thread
            g_hTrapThread = CreateThread(
                                NULL,   // lpThreadAttributes
                                0,      // dwStackSize
                                TrapThreadProc,
                                NULL,   // lpParameter
                                0,      // dwCreationFlags
                                &dwTrapThreadId
                                );

            // signal successful start
            g_fIsSnmpListening = TRUE;

            // release exclusive access
            LeaveCriticalSection(&g_GlobalLock);

            // WinSE bug 6182
            // wait for TrapThreadProc to signal sucessful or failure
            dwWaitTrapRegisterd = WaitForSingleObject(g_hTrapRegisterdEvent, INFINITE);
            if (dwWaitTrapRegisterd == WAIT_OBJECT_0)
            {
                if (g_fIsTrapRegistered == TRUE)
                    fOk = TRUE;  // success
                else
                {
                    SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);

                    SNMPDBG((
                        SNMP_LOG_ERROR,
                        "MGMTAPI: Traps are not accessible.\n"
                        ));

                }
            }
            else
            {
                SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: Traps are not accessible.\n"
                    ));
            }
        
        } 
        else 
        {

            // whine about having called this before
            SetLastError(SNMP_MGMTAPI_TRAP_DUPINIT);

            SNMPDBG((
                SNMP_LOG_ERROR,
                "MGMTAPI: Duplicate registration detected.\n"
                ));
            // release exclusive access
            LeaveCriticalSection(&g_GlobalLock);
        }

    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Dll Entry Point                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

    hDll - module handle.

    dwReason - reason DllMain is being called.

    lpReserved - unused.

Return Values:

    None.

--*/

{
    BOOL bOk = TRUE;

    __try
    {
        // determine reason for being called
        if (dwReason == DLL_PROCESS_ATTACH)
        {

            // initialize startup critical section
            InitializeCriticalSection(&g_GlobalLock);

            // initialize list of incoming traps
            InitializeListHead(&g_IncomingTraps);

            // optimize thread startup
            DisableThreadLibraryCalls(hDll);

            // save handle
            g_hDll = hDll;
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {

            // cleanup winsnmp
            CleanupIfNecessary();

            // nuke startup critical section
            DeleteCriticalSection(&g_GlobalLock);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bOk = FALSE;
    }

    return bOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
LPSNMP_MGR_SESSION
SNMP_FUNC_TYPE
SnmpMgrOpen(
    LPSTR pAgentAddress,
    LPSTR pAgentCommunity,
    INT   nTimeOut,
    INT   nRetries
    )

/*++

Routine Description:

    Initializes resources necessary for communication with specified agent.

Arguments:

    pAgentAddress - points to a null-terminated string specifying either a
        dotted-decimal IP address or a host name that can be resolved to an
        IP address, an IPX address (in 8.12 notation), or an ethernet address.

    pAgentCommunity - points to a null-terminated string specifying the
        SNMP community name used when communicating with the agent specified
        in the lpAgentAddress parameter

    nTimeOut - specifies the communications time-out in milliseconds.

    nRetries - specifies the communications retry count.

Return Values:

    Returns session handle if successful.

--*/

{
    PSNMP_MGR_SESSION pSMS = NULL;

    // initialize winsnmp
    if (StartSnmpIfNecessary()) {

        // allocate mgmtapi session
        if (AllocateSession(&pSMS)) {

            // open session
            if (!OpenSession(
                    pSMS,
                    pAgentAddress,
                    pAgentCommunity,
                    nTimeOut,
                    nRetries)) {

                // free session
                FreeSession(pSMS);

                // reset
                pSMS = NULL;
            }
        }
    }

    // return opaque pointer
    return (LPSNMP_MGR_SESSION)pSMS;
}

BOOL
SNMP_FUNC_TYPE
SnmpMgrCtl(
    LPSNMP_MGR_SESSION session,             // pointer to the MGMTAPI session
    DWORD              dwCtlCode,           // control code for the command requested
    LPVOID             lpvInBuffer,         // buffer with the input parameters for the operation
    DWORD              cbInBuffer,          // size of lpvInBuffer in bytes
    LPVOID             lpvOUTBuffer,        // buffer for all the output parameters of the command
    DWORD              cbOUTBuffer,         // size of lpvOUTBuffer
    LPDWORD            lpcbBytesReturned    // space used from lpvOutBuffer
    )
/*++

Routine Description:

    Operates several control operations over the MGMTAPI session

Arguments:

    pSession - pointer to the session to 


Return Values:


--*/
{
    BOOL bOk = FALSE;
    PSNMP_MGR_SESSION pSMS = (PSNMP_MGR_SESSION)session;

    switch(dwCtlCode)
    {
    case MGMCTL_SETAGENTPORT:
        if (pSMS == NULL)
            SetLastError(SNMP_MGMTAPI_INVALID_SESSION);
        else if (lpvInBuffer == NULL || cbInBuffer < sizeof(UINT))
            SetLastError(SNMP_MGMTAPI_INVALID_BUFFER);
        else if (WSNMP_FAILED(SnmpSetPort(pSMS->hAgentEntity, *(UINT*)lpvInBuffer)))
            SetLastError(SnmpGetLastError(pSMS->hSnmpSession));
        else
            bOk = TRUE;
        break;

    default:
        SetLastError(SNMP_MGMTAPI_INVALID_CTL);
        break;
    }

    return bOk;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrClose(
    LPSNMP_MGR_SESSION session
    )

/*++

Routine Description:

    Cleanups resources needed for communication with specified agent.

Arguments:

    session - points to an internal structure that specifies
        which session to close.

Return Values:

    Returns true if successful.

--*/

{
    PSNMP_MGR_SESSION pSMS = (PSNMP_MGR_SESSION)session;

    // validate pointer
    if (pSMS != NULL) {

        // close session
        CloseSession(pSMS);

        // free session
        FreeSession(pSMS);
    }

    return TRUE;
}


SNMPAPI
SNMP_FUNC_TYPE
SnmpMgrRequest(
    LPSNMP_MGR_SESSION session,
    BYTE               requestType,
    SnmpVarBindList  * pVarBindList,
    AsnInteger       * pErrorStatus,
    AsnInteger       * pErrorIndex
    )

/*++

Routine Description:

    Requests the specified operation be performed with the specified agent.

Arguments:

    session - points to an internal structure that specifies the session
        that will perform the request.

    requestType - specifies the SNMP request type.

    pVarBindList - points to the variable bindings list

    pErrorStatus - points to a variable in which the error status result
        will be returned.

    pErrorIndex - points to a variable in which the error index result
        will be returned.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    SNMPAPI_STATUS status;
    PSNMP_MGR_SESSION pSMS = (PSNMP_MGR_SESSION)session;

    // validate pointers
    if ((pSMS != NULL) &&
        (pErrorIndex != NULL) &&
        (pErrorStatus != NULL) &&
        (pVarBindList != NULL) &&
        (pVarBindList->len != 0) &&
        (pVarBindList->list != NULL)) {

        // obtain exclusive access to session
        EnterCriticalSection(&pSMS->SessionLock);

        // initialize session structure
        pSMS->pVarBindList = pVarBindList;
        pSMS->nPduType = (smiINT32)(BYTE)requestType;
        pSMS->hVbl = (HSNMP_VBL)NULL;
        pSMS->hPdu = (HSNMP_PDU)NULL;
        pSMS->nErrorStatus = 0;
        pSMS->nErrorIndex = 0;
        pSMS->nLastError = 0;

        // allocate resources
        if (AllocatePdu(pSMS)) {

            // actually send
            status = SnmpSendMsg(
                        pSMS->hSnmpSession,
                        pSMS->hManagerEntity,
                        pSMS->hAgentEntity,
                        pSMS->hViewContext,
                        pSMS->hPdu
                        );

            // release now
            FreePdu(pSMS);

            // validate return code
            if (WSNMP_SUCCEEDED(status)) {

                // process agent response
                if (ProcessAgentResponse(pSMS) &&
                   (pSMS->nLastError == SNMP_ERROR_NOERROR)) {

                    // update error status and index
                    *pErrorStatus = pSMS->nErrorStatus;
                    *pErrorIndex  = pSMS->nErrorIndex;

                    // success
                    fOk = TRUE;

                } else {

                    // set error to winsnmp error
                    SetLastError(pSMS->nLastError);

                    // failure
                    fOk = FALSE;
                }

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "MGMTAPI: SnmpSendMsg returned %d.\n",
                    SnmpGetLastError(pSMS->hSnmpSession)
                    ));
            }
        }

        // release exclusive access to session
        LeaveCriticalSection(&pSMS->SessionLock);
    }

    return fOk;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrStrToOid(
    LPSTR                 pString,
    AsnObjectIdentifier * pOID
    )

/*++

Routine Description:

    Converts a string object identifier or object descriptor representation
    to an internal object identifier.

Arguments:

    pString - points to a null-terminated string to be converted.

    pOID - points to an object identifier variable that will receive the
        converted value.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer to oid and string
    if ((pOID != NULL) && (pString != NULL)) {

        // forward to mibcc code for now
        return SnmpMgrText2Oid(pString, pOID);
    }

    return FALSE;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrOidToStr(
    AsnObjectIdentifier * pOID,
    LPSTR               * ppString
    )

/*++

Routine Description:

    Converts an internal object identifier to a string object identifier or
    object descriptor representation.

Arguments:

    pOID - pointers to object identifier to be converted.

    ppString - points to string pointer to receive converted value.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer to oid and string
    if ((pOID != NULL) && (ppString != NULL)) {

        // forward to mibcc code for now
        return SnmpMgrOid2Text(pOID, ppString);
    }

    return FALSE;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrTrapListen(
    HANDLE * phTrapAvailable
    )

/*++

Routine Description:

    Registers the ability of a manager application to receive SNMP traps.

Arguments:

    phTrapAvailable - points to an event handle that will be used to indicate
        that there are traps available

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // startup winsnmp
    if (StartSnmpIfNecessary()) {

        // spawn only one trap client thread
        if (StartTrapsIfNecessary(phTrapAvailable)) {

            // success
            fOk = TRUE;
        }
    }

    return fOk;
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrGetTrap(
    AsnObjectIdentifier * pEnterpriseOID,
    AsnNetworkAddress   * pAgentAddress,
    AsnInteger          * pGenericTrap,
    AsnInteger          * pSpecificTrap,
    AsnTimeticks        * pTimeStamp,
    SnmpVarBindList     * pVarBindList
    )

/*++

Routine Description:

    Returns outstanding trap data that the caller has not received if
    trap reception is enabled.

Arguments:

    pEnterpriseOID - points to an object identifier that specifies the
        enterprise that generated the SNMP trap

    pAgentAddress - points to the address of the agent that generated the
        SNMP trap (retrieved from PDU).

    pGenericTrap - points to an indicator of the generic trap id.

    pSpecificTrap - points to an indicator of the specific trap id.

    pTimeStamp - points to a variable to receive the time stamp.

    pVarBindList - points to the associated variable bindings.

Return Values:

    Returns true if successful.

--*/

{
    // forward to new api
    return SnmpMgrGetTrapEx(
                pEnterpriseOID,
                pAgentAddress,
                NULL,
                pGenericTrap,
                pSpecificTrap,
                NULL,
                pTimeStamp,
                pVarBindList
                );
}


BOOL
SNMP_FUNC_TYPE
SnmpMgrGetTrapEx(
    AsnObjectIdentifier * pEnterpriseOID,
    AsnNetworkAddress   * pAgentAddress,
    AsnNetworkAddress   * pSourceAddress,
    AsnInteger          * pGenericTrap,
    AsnInteger          * pSpecificTrap,
    AsnOctetString      * pCommunity,
    AsnTimeticks        * pTimeStamp,
    SnmpVarBindList     * pVarBindList
    )

/*++

Routine Description:

    Returns outstanding trap data that the caller has not received if
    trap reception is enabled.

Arguments:

    pEnterpriseOID - points to an object identifier that specifies the
        enterprise that generated the SNMP trap

    pAgentAddress - points to the address of the agent that generated the
        SNMP trap (retrieved from PDU).

    pSourceAddress - points to the address of the agent that generated the
        SNMP trap (retrieved from network transport).

    pGenericTrap - points to an indicator of the generic trap id.

    pSpecificTrap - points to an indicator of the specific trap id.

    pCommunity - points to structure to receive community string.

    pTimeStamp - points to a variable to receive the time stamp.

    pVarBindList - points to the associated variable bindings.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PLIST_ENTRY pLE = NULL;
    PTRAP_LIST_ENTRY pTLE = NULL;
    smiINT32 nLastError;

    // obtain exclusive access
    EnterCriticalSection(&g_GlobalLock);

    // make sure list has entries
    if (!IsListEmpty(&g_IncomingTraps)) {

        // remove first item from list
        pLE = RemoveHeadList(&g_IncomingTraps);

    } else {

        // check for trap thread failure
        nLastError = g_TrapSMS.nLastError;
    }

    // release exclusive access
    LeaveCriticalSection(&g_GlobalLock);

    // validate pointer
    if (pLE != NULL) {

        // retrieve pointer to trap list entry
        pTLE = CONTAINING_RECORD(pLE, TRAP_LIST_ENTRY, Link);

        // validate pointer
        if (pEnterpriseOID != NULL) {

            // manually copy enterprise oid
            *pEnterpriseOID = pTLE->EnterpriseOID;

            // re-initialize list entry
            pTLE->EnterpriseOID.ids = NULL;
            pTLE->EnterpriseOID.idLength = 0;
        }

        // validate pointer
        if (pCommunity != NULL) {

            // transfer string info
            *pCommunity = pTLE->Community;

            // re-initialize list entry
            pTLE->Community.length  = 0;
            pTLE->Community.stream  = NULL;
            pTLE->Community.dynamic = FALSE;
        }

        // validate pointer
        if (pVarBindList != NULL) {

            // transfer varbindlist
            *pVarBindList = pTLE->VarBindList;

            // re-initialize list entry
            pTLE->VarBindList.len  = 0;
            pTLE->VarBindList.list = NULL;
        }

        // validate pointer
        if (pAgentAddress != NULL) {

            // copy structure
            memcpy(pAgentAddress,
                   &pTLE->AgentAddress,
                   sizeof(pTLE->AgentAddress)
                   );
        }

        // validate pointer
        if (pSourceAddress != NULL) {

            // copy structure
            memcpy(pSourceAddress,
                   &pTLE->SourceAddress,
                   sizeof(pTLE->SourceAddress)
                   );
        }

        // validate pointer
        if (pGenericTrap != NULL) {

            // transfer generic trap info
            *pGenericTrap = pTLE->nGenericTrap;
        }

        // validate pointer
        if (pSpecificTrap != NULL) {

            // transfer generic trap info
            *pSpecificTrap = pTLE->nSpecificTrap;
        }

        // validate pointer
        if (pTimeStamp != NULL) {

            // transfer time info
            *pTimeStamp = pTLE->TimeStamp;
        }

        // release
        FreeTle(pTLE);

        // success
        fOk = TRUE;

    } else if (nLastError != NOERROR) {

        // indicate there was an thread error
        SetLastError(SNMP_MGMTAPI_TRAP_ERRORS);

    } else {

        // indicate there are no traps
        SetLastError(SNMP_MGMTAPI_NOTRAPS);
    }

    return fOk;
}


VOID
serverTrapThread(
    LPVOID pUnused
    )

/*++

Routine Description:

    Old thread procedure used by the SNMP Trap Service.

Arguments:

    pUnused - unused parameter.

Return Values:

    None.

--*/

{
    //
    // do nothing here...
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\mgmtapi\dll\oidconv.c ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    oidconv.c

Abstract:

    Routines to manage conversions between OID descriptions and numerical OIDs.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- WINDOWS DEPENDENCIES --------------------------

#include <windows.h>

//--------------------------- STANDARD DEPENDENCIES -- #include<xxxxx.h> ----

#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <snmp.h>
#include <snmputil.h>

//--------------------------- MODULE DEPENDENCIES -- #include"xxxxx.h" ------

#include "mibcc.h"
#include "mibtree.h"

//--------------------------- SELF-DEPENDENCY -- ONE #include"module.h" -----

#include "oidconv.h"

//--------------------------- PUBLIC VARIABLES --(same as in module.h file)--

/* name to used when converting OID <--> TEXT */
LPSTR lpInputFileName = "mib.bin";

//--------------------------- PRIVATE CONSTANTS -----------------------------

#define FILENODE_SIZE     sizeof(T_FILE_NODE)
#define OID_PREFIX_LEN    (sizeof MIB_Prefix / sizeof(UINT))
#define STR_PREFIX_LEN    (strlen(MIB_StrPrefix))

#define SEEK_SET  0
#define SEEK_CUR  1

//--------------------------- PRIVATE STRUCTS -------------------------------

   //****************************************************************
   //
   //                     Record structure in file
   //
   //    These are the necessary fields to process a conversion request.
   //    When a request is made, the MIB file is searched sequentially
   //    matching subid's.  The field, lNextOffset, is an offset from the
   //    current file position to the current nodes next sibling.
   //
   //    The text subid for each node is stored directly after the
   //    T_FILE_NODE structure in the file.  Its length is stored in the
   //    field, uStrLen.
   //
   //    This is done because there are no limits placed on the size
   //    of a text subid.  Hence, when the T_FILE_NODE structure is
   //    read from the MIB file, the field, lpszTextSubID is not valid.
   //    The field will eventually point to the storage allocated to
   //    hold the text subid.
   //
   //    The order of the nodes in the file is the same as if the MIB
   //    tree was traversed in a "pre-order" manner.
   //
   //****************************************************************

typedef struct _FileNode {
   long                 lNextOffset;      // This field must remain first
   UINT                 uNumChildren;
   UINT                 uStrLen;
   LPSTR                lpszTextSubID;
   UINT                 uNumSubID;
} T_FILE_NODE;

// mib.bin file actually has the following platform independent format 
// on 32bit(x86) and 64bit(ia64) environment. See Bug# 125494 for detail.
typedef struct _FileNodeEx {
   long                 lNextOffset;      // This field must remain first
   UINT                 uNumChildren;
   UINT                 uStrLen;
   UINT                 uReserved;
   UINT                 uNumSubID;
} T_FILE_NODE_EX;
#define FILENODE_SIZE_EX     sizeof(T_FILE_NODE_EX)

//--------------------------- PRIVATE VARIABLES -----------------------------

LPSTR MIB_StrPrefix = "iso.org.dod.internet.mgmt.mib-2";

UINT MIB_Prefix[] = { 1, 3, 6, 1, 2, 1 };
AsnObjectIdentifier MIB_OidPrefix = { OID_PREFIX_LEN, MIB_Prefix };

//--------------------------- PRIVATE PROTOTYPES ----------------------------

//--------------------------- PRIVATE PROCEDURES ----------------------------

//
// GetNextNode
//    Reads the next record from MIB file into a FILENODE structure.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI GetNextNode(
       IN HFILE fh,
           OUT T_FILE_NODE * Node
       )

{
    SNMPAPI nResult;
    T_FILE_NODE_EX NodeEx;
    ZeroMemory(&NodeEx, FILENODE_SIZE_EX);
    Node->lpszTextSubID = NULL;

    // Read in node
    if ( FILENODE_SIZE_EX != _lread(fh, (LPSTR)(&NodeEx), FILENODE_SIZE_EX) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }
    
    // Convert node format from mib.bin to format in memory
    // The format in the file is independent of 32bit(x86)/64bit(ia64) 
    // architecture.
    Node->lNextOffset = NodeEx.lNextOffset;
    Node->uNumChildren = NodeEx.uNumChildren;
    Node->uNumSubID = NodeEx.uNumSubID;
    Node->uStrLen = NodeEx.uStrLen;

    // Alloc space for string
    if ( NULL ==
        (Node->lpszTextSubID = SnmpUtilMemAlloc((1+Node->uStrLen) * sizeof(char))) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Read in subid string
    if ( Node->uStrLen != _lread(fh, Node->lpszTextSubID, Node->uStrLen) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // NULL terminate the text sub id
    Node->lpszTextSubID[Node->uStrLen] = '\0';

    nResult = SNMPAPI_NOERROR;

Exit:
    if ( SNMPAPI_ERROR == nResult )
    {
        SnmpUtilMemFree( Node->lpszTextSubID );
    }

    return nResult;
} // GetNextNode



//
// WriteNode
//    Writes the node to the MIB file.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI WriteNode(
       IN HFILE fh,
           IN T_FILE_NODE * Node
       )

{
SNMPAPI nResult;
T_FILE_NODE LocalNodeCopy;

   // make a copy of the node so we can clean up any pointers
   LocalNodeCopy.lNextOffset = Node->lNextOffset;
   LocalNodeCopy.uNumChildren = Node->uNumChildren;
   LocalNodeCopy.uStrLen = Node->uStrLen;
   LocalNodeCopy.lpszTextSubID = NULL;  /* don't write pointers to disk */
   LocalNodeCopy.uNumSubID = Node->uNumSubID;

   // Write Node portion
   if ( FILENODE_SIZE != _lwrite(fh, (LPSTR)&LocalNodeCopy, FILENODE_SIZE) )
      {
      nResult = SNMPAPI_ERROR;
      goto Exit;
      }

   // Now write out what the pointers pointed to.
   // Save text subid
   if ( Node->uStrLen != _lwrite(fh, Node->lpszTextSubID, Node->uStrLen) )
      {
      nResult = SNMPAPI_ERROR;
      goto Exit;
      }

   nResult = SNMPAPI_NOERROR;

Exit:
   return nResult;
} // WriteNode



//
// SkipSubTree
//    Frees a FILENODE and all information contained in it.
//
// Notes:
//
// Return Codes:
//
// Error Codes:
//    None.
//
SNMPAPI SkipSubTree(
           IN HFILE fh,
           IN T_FILE_NODE *Node
       )

{
    SNMPAPI     nResult;


    // Skip entire subtree
    if ( -1 == _llseek(fh, Node->lNextOffset, SEEK_CUR) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    nResult = SNMPAPI_NOERROR;

Exit:
    return nResult;
} // SkipSubTree

//--------------------------- PUBLIC PROCEDURES -----------------------------

//
// SnmpMgrOid2Text
//    Converts an OID to its textual description.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI SnmpMgrOid2Text(
           IN AsnObjectIdentifier *Oid, // Pointer to OID to convert
       OUT LPSTR *lpszTextOid       // Resulting text OID
       )

{
T_FILE_NODE  Node;
OFSTRUCT     of;
HFILE        fh;
UINT         Siblings;
UINT         OidSubId;
UINT         uTxtOidLen;
BOOL         bFound;
BOOL         bPartial;
BOOL         bDot;
SNMPAPI      nResult;

    // OPENISSUE - this code does not generate errors if subid 0 is embeded
    // OPENISSUE - opening file every time could be a performance issue
    // OPENISSUE - optimization of file access could improve performance

    *lpszTextOid = NULL;

    // Open file and check for errors
    if ( -1 == (fh = OpenFile(lpInputFileName, &of, OF_READ|OF_SHARE_DENY_WRITE)) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Test for MIB prefix
    bDot = !( bPartial = OID_PREFIX_LEN < Oid->idLength &&
                        !SnmpUtilOidNCmp(Oid, &MIB_OidPrefix, OID_PREFIX_LEN) );

    // Loop until conversion is finished
    OidSubId          = 0;
    uTxtOidLen        = 0;
    Node.uNumChildren = 1;
    while ( OidSubId < Oid->idLength )
    {
        // Init to not found on this level
        bFound   = FALSE;
        Siblings = Node.uNumChildren;

        // While there are siblings and the sub id is not found keep looking
        while ( Siblings && !bFound )
        {
            Node.lpszTextSubID = NULL;

            // Get next node from mib.bin file
            if ( SNMPAPI_ERROR == GetNextNode(fh, &Node) )
            {
                SnmpUtilMemFree( Node.lpszTextSubID );
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }

            Siblings --;

            // Compare the numeric subid's
            if ( Oid->ids[OidSubId] == Node.uNumSubID )
            {
                bFound = TRUE;

                // If OID is a partial, then skip prefix subid's
                if ( OidSubId >= OID_PREFIX_LEN || !bPartial )
                {
                    // Realloc space for text id - add 2 for '.' and NULL terminator
                    if ( NULL == (*lpszTextOid =
                         SnmpUtilMemReAlloc(*lpszTextOid,
                          (uTxtOidLen+Node.uStrLen+2) * sizeof(char))) )
                    {
                        SnmpUtilMemFree( Node.lpszTextSubID );
                        nResult = SNMPAPI_ERROR;
                        goto Exit;
                    }

                    // Add DOT separator
                    if ( bDot )
                    {
                        (*lpszTextOid)[uTxtOidLen] = '.';

                        // Save text subid
                        memcpy( &(*lpszTextOid)[uTxtOidLen+1],
                                    Node.lpszTextSubID, Node.uStrLen+1 );

                        // Update length of text oid - add one for separator
                        uTxtOidLen += Node.uStrLen + 1;
                    }
                    else
                    {
                        bDot = TRUE;

                        // Save text subid
                        memcpy( &(*lpszTextOid)[uTxtOidLen],
                                    Node.lpszTextSubID, Node.uStrLen );

                        // Update length of text oid
                        uTxtOidLen += Node.uStrLen;
                    }
                }

                // try to convert the next OID subid
                OidSubId ++;
            }
            else
            {
                // Skip over subtree since not a match
                if ( SNMPAPI_ERROR == SkipSubTree(fh, &Node) )
                {
                    SnmpUtilMemFree( Node.lpszTextSubID );
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
               }
            }

            // Free the text sub id read
            SnmpUtilMemFree( Node.lpszTextSubID );
        } // while

        // If no sub id matches
        if ( !bFound )
        {
            break;
        }
    } // while

    // Make sure that the entire OID was converted
    while ( OidSubId < Oid->idLength )
    {
        char NumChar[100];

        _itoa( Oid->ids[OidSubId], NumChar, 10 );
        // Realloc space for text id - add 2 for '.' and NULL terminator
        if ( NULL ==
                    (*lpszTextOid = SnmpUtilMemReAlloc(*lpszTextOid,
                        (uTxtOidLen+strlen(NumChar)+4) * sizeof(char))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        // Add DOT separator
        (*lpszTextOid)[uTxtOidLen] = '.';

        // Save text subid
        memcpy( &(*lpszTextOid)[uTxtOidLen+1], NumChar, strlen(NumChar)+1 );

        // Skip to next OID subid
        OidSubId ++;

        // Update length of text oid - add one for separator
        uTxtOidLen += strlen(NumChar) + 1;
    } // while

    nResult = SNMPAPI_NOERROR;

Exit:
    if ( -1 != fh )
    {
        _lclose( fh );
    }

    if ( SNMPAPI_ERROR == nResult )
    {
        SnmpUtilMemFree( *lpszTextOid );
        *lpszTextOid = NULL;
    }

    return nResult;
} // SnmpMgrOid2Text



//
// SnmpMgrText2Oid
//    Converts an OID text description to its numerical equivalent.
//
// Notes:
//
// Return Codes:
//    SNMPAPI_NOERROR
//    SNMPAPI_ERROR
//
// Error Codes:
//    None.
//
SNMPAPI SnmpMgrText2Oid(
         IN LPSTR lpszTextOid,           // Pointer to text OID to convert
     IN OUT AsnObjectIdentifier *Oid // Resulting numeric OID
     )

{
#define DELIMETERS         ".\0"


T_FILE_NODE  Node;
OFSTRUCT     of;
HFILE        fh;
UINT         Siblings;
LPSTR        lpszSubId;
LPSTR        lpszWrkOid = NULL;
BOOL         bFound;
UINT         uSubId;
SNMPAPI      nResult;

    // OPENISSUE - this code does not generate errors if subid 0 is embeded
    // OPENISSUE - opening file every time could be a performance issue
    // OPENISSUE - optimization of file access could improve performance

    // Init. OID structure
    Oid->idLength = 0;
    Oid->ids      = NULL;

    // check for null string and empty string
    if ( NULL == lpszTextOid || '\0' == lpszTextOid[0] )
    {
        fh = -1;
        nResult = SNMPAPI_NOERROR;
        goto Exit;
    }

    // Open file and check for errors
    if ( -1 == (fh = OpenFile(lpInputFileName, &of, OF_READ|OF_SHARE_DENY_WRITE)) )
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }

    // Make working copy of string
    if ( ('.' == lpszTextOid[0]) )
    {
        if ( NULL == (lpszWrkOid = SnmpUtilMemAlloc((strlen(lpszTextOid)+1) * sizeof(char))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        strcpy( lpszWrkOid, lpszTextOid+1 );
    }
    else
    {
        if ( NULL ==
                (lpszWrkOid =
            SnmpUtilMemAlloc((strlen(lpszTextOid)+STR_PREFIX_LEN+1+1) * sizeof(char))) )
        {
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        strcpy( lpszWrkOid, MIB_StrPrefix );
        lpszWrkOid[STR_PREFIX_LEN] = '.';
        strcpy( &lpszWrkOid[STR_PREFIX_LEN+1], lpszTextOid );
    }

    Node.uNumChildren = 1;
    lpszSubId = strtok( lpszWrkOid, DELIMETERS );

    // Loop until conversion is finished
    while ( NULL != lpszSubId )
    {

        // Init to not found on this level
        bFound   = FALSE;
        Siblings = Node.uNumChildren;

        // Check for imbedded numbers
        if ( isdigit(*lpszSubId) )
        {
            UINT I;


            // Make sure this is a NUMBER without alpha's
            for ( I=0;I < strlen(lpszSubId);I++ )
            {
                if ( !isdigit(lpszSubId[I]) )
                {
                    nResult = SNMPAPI_ERROR;
                    goto Exit;
                }
            }

            uSubId = atoi( lpszSubId );
        }
        else
        {
            uSubId = 0;
        }

        // While there are siblings and the sub id is not found keep looking
        while ( Siblings && !bFound )
        {
            Node.lpszTextSubID = NULL;

            // Get next sibling
            if ( SNMPAPI_ERROR == GetNextNode(fh, &Node) )
            {
                SnmpUtilMemFree( Node.lpszTextSubID );
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }

            Siblings --;

            if ( uSubId )
            {
                // Compare the numeric subid's
                if ( Node.uNumSubID == uSubId )
                {
                    bFound = TRUE;

                    // Add space for new sub id
                    if ( NULL ==
                                (Oid->ids =
                                SnmpUtilMemReAlloc(Oid->ids, (Oid->idLength+1) * sizeof(UINT))) )
                    {
                        SnmpUtilMemFree( Node.lpszTextSubID );
                        nResult = SNMPAPI_ERROR;
                        goto Exit;
                    }

                    // Append this sub id to end of numeric OID
                    Oid->ids[Oid->idLength++] = Node.uNumSubID;
                }
            }
            else
            {
                // Compare the text subid's
                if ( !strcmp(lpszSubId, Node.lpszTextSubID) )
                {
                    bFound = TRUE;

                    // Add space for new sub id
                    if ( NULL ==
                                (Oid->ids =
                                SnmpUtilMemReAlloc(Oid->ids, (Oid->idLength+1) * sizeof(UINT))) )
                    {
                        SnmpUtilMemFree( Node.lpszTextSubID );
                        nResult = SNMPAPI_ERROR;
                        goto Exit;
                    }

                    // Append this sub id to end of numeric OID
                    Oid->ids[Oid->idLength++] = Node.uNumSubID;
                }
            }

            // Skip over subtree since not a match
            if ( !bFound && SNMPAPI_ERROR == SkipSubTree(fh, &Node) )
            {
                SnmpUtilMemFree( Node.lpszTextSubID );
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }

            // Free the text sub id read
            SnmpUtilMemFree( Node.lpszTextSubID );
        } // while

        // If no sub id matches
        if ( !bFound )
        {
            break;
        }

        // Advance to next sub id
        lpszSubId = strtok( NULL, DELIMETERS );
    } // while

    // Make sure that the entire OID was converted
    while ( NULL != lpszSubId )
    {
        UINT I;


        // Make sure this is a NUMBER without alpha's
        for ( I=0;I < strlen(lpszSubId);I++ )
        {
            if ( !isdigit(lpszSubId[I]) )
            {
                nResult = SNMPAPI_ERROR;
                goto Exit;
            }
        }

        // Add space for new sub id
        if ( NULL ==
                    (Oid->ids = SnmpUtilMemReAlloc(Oid->ids, (Oid->idLength+1) * sizeof(UINT))) )
        {
            SnmpUtilMemFree( Node.lpszTextSubID );
            nResult = SNMPAPI_ERROR;
            goto Exit;
        }

        // Append this sub id to end of numeric OID
        Oid->ids[Oid->idLength++] = atoi( lpszSubId );

        // Advance to next sub id
        lpszSubId = strtok( NULL, DELIMETERS );
    } // while


    // it is illegal for an oid to be less than two subidentifiers
    if (Oid->idLength < 2)
    {
        nResult = SNMPAPI_ERROR;
        goto Exit;
    }


    nResult = SNMPAPI_NOERROR;

Exit:
    if ( -1 != fh )
    {
        _lclose( fh );
    }

    if ( SNMPAPI_ERROR == nResult )
    {
        SnmpUtilOidFree( Oid );
    }

    if ( NULL != lpszWrkOid ) 
    {
        SnmpUtilMemFree ( lpszWrkOid );
    }

    return nResult;
} // SnmpMgrText2Oid

//------------------------------- END ---------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\mgmtapi\dll\mibtree.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibtree.h

Abstract:

    mibtree.h contains the definitions used by the MIB tree routines.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef mibtree_h
#define mibtree_h
 
//--------------------------- PUBLIC CONSTANTS ------------------------------
//--------------------------- PUBLIC STRUCTS --------------------------------

typedef struct _TreeNode {
   struct _TreeNode *   lpParent;           /* pointer to parent */
   struct _TreeNode * * lpChildArray;       /* array is alloced */
   UINT                 uNumChildren;
   LPSTR                lpszTextSubID;
   UINT                 uNumSubID;
} TreeNode, *lpTreeNode;

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern lpTreeNode lpMIBRoot;

//--------------------------- PUBLIC PROTOTYPES -----------------------------

void TreeInit (lpTreeNode *lplpRoot);
void TreeDeInit (lpTreeNode *lplpRoot);
void NodeInit (lpTreeNode lpNode);
lpTreeNode FindNodeByName (lpTreeNode lpParent, LPSTR lpszName);
lpTreeNode FindNodeByNumber (lpTreeNode lpParent, UINT uNum);
lpTreeNode FindNodeAddToTree (lpTreeNode lpParent, LPSTR lpszName, UINT uNum);
lpTreeNode FindNodeInSubTree (lpTreeNode lpRoot, LPSTR lpszName);
lpTreeNode NewChildNode (LPSTR lpszName, UINT uNum);
void InsertChildNode (lpTreeNode lpParent, lpTreeNode lpNode);
void PrintTree (lpTreeNode lpRoot, unsigned int nIndent);

//--------------------------- END -------------------------------------------

#endif /* mibtree_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\compiler\mibccv2\otscan.hpp ===
#ifndef _OIDTREESCANNER_HPP
#define _OIDTREESCANNER_HPP

class Oid;

class OidTreeScanner
{
protected:
	SIMCOidTree		*m_pOidTree;

	// DESCRIPTION:
	//		Adds list of nodes from lstChildren	to the tail of m_recursionTrace,
	//		constructing at the same time the OID lexicographically order.
	//		the list received as parameter should not be modified;
	// PARAMETERS:
	//		(in) list of nodes to add
	void UpdateRecursionTrace(SIMCNodeList *pLstChildren, SIMCNodeList *pLstTrace);

	// DESCRIPTION:
	//		Gets the first symbol from the symbol list of the node pOidNode
	// PARAMETERS:
	//		(in) pOidNode whose symbol is to be returned
	//		(out) cszSymbol - pointer to the symbol (do not alter or free)
	// RETURN VALUE:
	//		0 on success, -1 on failure
	int GetNodeSymbol(const SIMCOidTreeNode *pOidNode, const char * & cszSymbol);

	// DESCRIPTION:
	//		Gets the complete OID information for the given pOidNode.
	//		It supplies both the numeric value and symbolic name for each
	//		component of the OID.
	// PARAMETERS:
	//      (in) pOidNode - the node whose OID is to be found
	//      (out) oid - the Oid object who stores the data
	// RETURN VALUE:
	//      0 on success, -1 on failure
	int GetNodeOid(const SIMCOidTreeNode *pOidNode, Oid &oid);

public:
	// initializes the OidTreeScanner
	OidTreeScanner();

	// DESCRIPTION:
	//		scans lexicographically the oid tree;
	// RETURN VALUE:
	//		0 on success
	//		-1 on failure;
	virtual int Scan();

	// DESCRIPTION:
	//		"callback" function, called each time a
	//		tree node passes through the scan. The user
	//		should redefine this function in the derived
	//		object to perform the action desired.
	// PARAMETERS:
	//		(in) Pointer to the current node in the tree.
	// RETURN VALUE:
	//		0 - the scanner should continue
	//		1 - the scanner should abort.
	virtual int OnScanNode(const SIMCOidTreeNode *pOidNode) = 0;

	// DESCRIPTION:
	//		Fills the symbols of the built-in objects from the static table
	// RETURN VALUE:
	//		0 - on success, -1 on failure
	int MergeBuiltIn();

	// DESCRIPTION:
	//		initializes the m_pOidTree.
	// PARAMETERS:
	//		(in) pointer to the SIMCOidTree to scan.
	void SetOidTree(SIMCOidTree *pOidTree);

	~OidTreeScanner();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\mgmtapi\dll\mibcc.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    mibcc.h

Abstract:

    mibcc.h contains the definitions common to the MIB compiler.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/

//--------------------------- VERSION INFO ----------------------------------

//--------------------------- PUBLIC CONSTANTS ------------------------------

//--------------------------- PUBLIC STRUCTS --------------------------------

#define UINT unsigned int
#define LPSTR char *

#define BOOL int
#define FALSE 0
#define TRUE 1

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern int lineno;

/* command line switches */
extern BOOL fTreePrint;		/* -p : Print the tree when it is all parsed */
extern BOOL fNodePrint;		/* -n : Print each node as it is added */
extern unsigned int nWarningLevel;
extern unsigned int nStopAfterErrors;

extern LPSTR lpOutputFileName;	/* Global pointer to output file name */

extern FILE *yyin, *yyout;	/* where lex will read its input from */

//--------------------------- PUBLIC PROTOTYPES -----------------------------

extern int yyparse ();
extern void mark_flex_to_init (void);

#define error_out	stdout

//--------------------------- END -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\winsnmp.inc ===
#pragma warning (disable : 4001)
//
// winsnmp.inc
// Utility include for NetPlus WinSNMP
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
#include <stdlib.h> // for _ltoa(), strtol(), etc.
#include <string.h>
#include <memory.h>
#include <process.h> // for _beginthreadex()
#include "winsnmp.h"
#include "winsnmpn.h"
#include "wsnmpext.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\mgmtapi\dll\oidconv.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    oidconv.h

Abstract:

    Routines to manage conversions between OID descriptions and numerical OIDs.

Environment:

    User Mode - Win32

Revision History:

    10-May-1996 DonRyan
        Removed banner from Technology Dynamics, Inc.

--*/
 
#ifndef oidconv_h
#define oidconv_h

//--------------------------- PUBLIC CONSTANTS ------------------------------

#include <snmp.h>

#include "mibtree.h"

//--------------------------- PUBLIC STRUCTS --------------------------------

//--------------------------- PUBLIC VARIABLES --(same as in module.c file)--

extern LPSTR lpInputFileName; /* name to used when converting OID <--> TEXT */

//--------------------------- PUBLIC PROTOTYPES -----------------------------

SNMPAPI SnmpMgrOid2Text(
           IN AsnObjectIdentifier *Oid, // Pointer to OID to convert
	   OUT LPSTR *String            // Resulting text OID
	   );

SNMPAPI SnmpMgrText2Oid(
         IN LPSTR lpszTextOid,           // Pointer to text OID to convert
	 IN OUT AsnObjectIdentifier *Oid // Resulting numeric OID
	 );

//------------------------------- END ---------------------------------------

#endif /* oidconv_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\mgmtapi\samples\snmputil\snmputil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    snmputil.c

Abstract:

    Sample SNMP Management API usage for Windows NT.

    This file is an example of how to code management applications using
    the SNMP Management API for Windows NT.  It is similar in operation to
    the other commonly available SNMP command line utilities.

    Extensive comments have been included to describe its structure and
    operation.  See also "Microsoft Windows NT SNMP Programmer's Reference".

--*/


// General notes:
//   Microsoft's SNMP Management API for Windows NT is implemented as a DLL
// that is linked with the developer's code.  These APIs (examples follow in
// this file) allow the developer's code to generate SNMP queries and receive
// SNMP traps.  A simple MIB compiler and related APIs are also available to
// allow conversions between OBJECT IDENTIFIERS and OBJECT DESCRIPTORS.


// Necessary includes.

#include <windows.h>

#include <stdio.h>
#include <string.h>

#include <snmp.h>
#include <mgmtapi.h>


// Constants used in this example.

#define GET     1
#define GETNEXT 2
#define WALK    3
#define TRAP    4

#define TIMEOUT 6000 /* milliseconds */
#define RETRIES 0

void
SNMP_FUNC_TYPE AsnValueFree(
    IN AsnAny *asnValue
    )
    {
    // Free any data in the varbind value
    switch ( asnValue->asnType )
        {
        case ASN_OBJECTIDENTIFIER:
            SnmpUtilOidFree( &asnValue->asnValue.object );
            break;

        case ASN_RFC1155_IPADDRESS:
        case ASN_RFC1155_OPAQUE:
        case ASN_OCTETSTRING:
            if ( asnValue->asnValue.string.dynamic == TRUE )
                {
                SnmpUtilMemFree( asnValue->asnValue.string.stream );
                }
            break;

        default:
            break;
            // Purposefully do nothing, because no storage alloc'ed for others
        }

    // Set type to NULL
    asnValue->asnType = ASN_NULL;
    }

// Main program.

INT __cdecl main(
    IN int  argumentCount,
    IN char *argumentVector[])
    {
    INT                operation;
    LPSTR              agent;
    LPSTR              community;
    RFC1157VarBindList variableBindings;
    LPSNMP_MGR_SESSION session;

    INT        timeout = TIMEOUT;
    INT        retries = RETRIES;

    BYTE       requestType;
    AsnInteger requestId;
    AsnInteger errorStatus;
    AsnInteger errorIndex;
    char        *chkPtr = NULL;


    // Parse command line arguments to determine requested operation.

    // Verify number of arguments...
    if      (argumentCount < 5 && argumentCount != 2)
        {
        printf("Error:  Incorrect number of arguments specified.\n");
        printf(
"\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\n");
        printf(
  "        snmputil trap\n");

        return 1;
        }

    // Get/verify operation...
    argumentVector++;
    argumentCount--;
    if      (!strcmp(*argumentVector, "get"))
        operation = GET;
    else if (!strcmp(*argumentVector, "getnext"))
        operation = GETNEXT;
    else if (!strcmp(*argumentVector, "walk"))
        operation = WALK;
    else if (!strcmp(*argumentVector, "trap"))
        operation = TRAP;
    else
        {
        printf("Error:  Invalid operation, '%s', specified.\n",
               *argumentVector);

        return 1;
        }

    if (operation != TRAP)
        {
        if (argumentCount < 4)
            {
            printf("Error:  Incorrect number of arguments specified.\n");
            printf(
"\nusage:  snmputil [get|getnext|walk] agent community oid [oid ...]\n");
            printf(
  "        snmputil trap\n");

            return 1;
            }

        // Get agent address...
        argumentVector++;
        argumentCount--;
        agent = (LPSTR)SnmpUtilMemAlloc(strlen(*argumentVector) + 1);
        if (agent != NULL)
            strcpy(agent, *argumentVector);
        else
        {
            printf("Error: SnmpUtilMemAlloc failed to allocate memory.\n");
            return 1;
        }

        // Get agent community...
        argumentVector++;
        argumentCount--;
        community = (LPSTR)SnmpUtilMemAlloc(strlen(*argumentVector) + 1);
        if (community != NULL)
            strcpy(community, *argumentVector);
        else
        {
            printf("Error: SnmpUtilMemAlloc failed to allocate memory.\n");
            SnmpUtilMemFree(agent);
            return 1;
        }

        // Get oid's...
        variableBindings.list = NULL;
        variableBindings.len = 0;

        while(--argumentCount)
            {
            AsnObjectIdentifier reqObject;
            RFC1157VarBind * tmpVb;

            argumentVector++;

            // Convert the string representation to an internal representation.
            if (!SnmpMgrStrToOid(*argumentVector, &reqObject))
                {
                printf("Error: Invalid oid, %s, specified.\n", *argumentVector);
                SnmpUtilMemFree(agent);
                SnmpUtilMemFree(community);
                SnmpUtilVarBindListFree(&variableBindings);
                return 1;
                }
            else
                {
                // Since sucessfull, add to the variable bindings list.
                variableBindings.len++;
                if ((tmpVb = (RFC1157VarBind *)SnmpUtilMemReAlloc(
                    variableBindings.list, sizeof(RFC1157VarBind) *
                    variableBindings.len)) == NULL)
                    {
                    printf("Error: Error allocating oid, %s.\n",
                           *argumentVector);
                    SnmpUtilMemFree(agent);
                    SnmpUtilMemFree(community);
                    variableBindings.len--;
                    SnmpUtilVarBindListFree(&variableBindings);

                    return 1;
                    }
                variableBindings.list = tmpVb;

                variableBindings.list[variableBindings.len - 1].name =
                    reqObject; // NOTE!  structure copy
                variableBindings.list[variableBindings.len - 1].value.asnType =
                    ASN_NULL;
                }
            } // end while()

        // Establish a SNMP session to communicate with the remote agent.  The
        // community, communications timeout, and communications retry count
        // for the session are also required.

        if ((session = SnmpMgrOpen(agent, community, timeout, retries)) == NULL)
            {
            printf("error on SnmpMgrOpen %d\n", GetLastError());
            SnmpUtilMemFree(agent);
            SnmpUtilMemFree(community);
            SnmpUtilVarBindListFree(&variableBindings);

            return 1;
            }

        } // end if(TRAP)


    // Determine and perform the requested operation.

    if      (operation == GET || operation == GETNEXT)
        {
        // Get and GetNext are relatively simple operations to perform.
        // Simply initiate the request and process the result and/or
        // possible error conditions.


        if (operation == GET)
            requestType = ASN_RFC1157_GETREQUEST;
        else
            requestType = ASN_RFC1157_GETNEXTREQUEST;


        // Request that the API carry out the desired operation.

        if (!SnmpMgrRequest(session, requestType, &variableBindings,
                            &errorStatus, &errorIndex))
            {
            // The API is indicating an error.

            printf("error on SnmpMgrRequest %d\n", GetLastError());
            }
        else
            {
            // The API succeeded, errors may be indicated from the remote
            // agent.

            if (errorStatus > 0)
                {
                printf("Error: errorStatus=%d, errorIndex=%d\n",
                       errorStatus, errorIndex);
                }
            else
                {
                // Display the resulting variable bindings.

                UINT i;
                char *string = NULL;

                for(i=0; i < variableBindings.len; i++)
                    {
                    SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
                    printf("Variable = %s\n", string);
                    if (string) SnmpUtilMemFree(string);

                    printf("Value    = ");
                    SnmpUtilPrintAsnAny(&variableBindings.list[i].value);

                    printf("\n");
                    } // end for()
                }
            }


        // Free allocated memory.
        SnmpUtilMemFree(agent);
        SnmpUtilMemFree(community);
        SnmpUtilVarBindListFree(&variableBindings);


        }
    else if (operation == WALK)
        {
        // Walk is a common term used to indicate that all MIB variables
        // under a given OID are to be traversed and displayed.  This is
        // a more complex operation requiring tests and looping in addition
        // to the steps for get/getnext above.

        UINT i;
        UINT j;

        AsnObjectIdentifier *rootOidList;
        UINT                 rootOidLen;
        UINT                *rootOidXlat;

        rootOidLen = variableBindings.len;

        rootOidList = (AsnObjectIdentifier*)SnmpUtilMemAlloc(rootOidLen *
                      sizeof(AsnObjectIdentifier));

        rootOidXlat = (UINT *)SnmpUtilMemAlloc(rootOidLen * sizeof(UINT));

        for (i=0; i < rootOidLen; i++)
            {
            SnmpUtilOidCpy(&rootOidList[i], &variableBindings.list[i].name);
            rootOidXlat[i] = i;
            }

        requestType = ASN_RFC1157_GETNEXTREQUEST;

        while(1)
            {
            if (!SnmpMgrRequest(session, requestType, &variableBindings,
                                &errorStatus, &errorIndex))
                {
                // The API is indicating an error.

                printf("error on SnmpMgrRequest %d\n", GetLastError());

                break;
                }
            else
                {
                // The API succeeded, errors may be indicated from the remote
                // agent.

                char *string = NULL;
                UINT nBindingsLeft = variableBindings.len;
                UINT nSubTreesDone = 0;
                RFC1157VarBind *tempVarBindList;

                if (errorStatus == SNMP_ERRORSTATUS_NOERROR)
                    {
                    // Test for end of subtree or end of MIB.

                    for(i=0; i < nBindingsLeft; i++)
                        {
                        // obtain root
                        j = rootOidXlat[i];

                        if (SnmpUtilOidNCmp(&variableBindings.list[i].name,
                                &rootOidList[j], rootOidList[j].idLength))
                            {
                            nSubTreesDone++;
                            rootOidXlat[i] = 0xffffffff;
                            }
                        else
                            {
                            SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
                            printf("Variable = %s\n", string);
                            if (string) SnmpUtilMemFree(string);

                            printf("Value    = ");
                            SnmpUtilPrintAsnAny(&variableBindings.list[i].value);

                            printf("\n");
                            }

                        AsnValueFree(&variableBindings.list[i].value);
                        }

                        if (nBindingsLeft > 1)
                            {
                            printf("\n"); // separate table entries
                            }
                    }
                else if (errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME)
                    {
                    if (!(errorIndex && (errorIndex <= (INT)nBindingsLeft)))
                        {
                        errorIndex = 1; // invalidate first variable
                        }

                    nSubTreesDone++;
                    rootOidXlat[errorIndex-1] = 0xffffffff;

                    errorStatus = 0;
                    errorIndex  = 0;
                    }
                else
                    {
                    printf("Error: errorStatus=%d, errorIndex=%d \n",
                           errorStatus, errorIndex);

                    break;
                    }

                // Test to see if any or all subtrees walked

                if (nSubTreesDone == 0)
                    {
                    continue;
                    }
                else if (nSubTreesDone >= nBindingsLeft)
                    {
                    printf("End of MIB subtree.\n\n");
                    break;
                    }

                // Fixup variable list

                tempVarBindList = variableBindings.list;

                variableBindings.len = nBindingsLeft - nSubTreesDone;

                variableBindings.list = (RFC1157VarBind *)SnmpUtilMemAlloc(
                    variableBindings.len * sizeof(RFC1157VarBind));

                for(i=0, j=0; i < nBindingsLeft; i++)
                    {
                    if ((rootOidXlat[i] != 0xffffffff) &&
                        (j < variableBindings.len))
                        {
                        SnmpUtilVarBindCpy(
                            &variableBindings.list[j],
                            &tempVarBindList[i]
                            );

                        rootOidXlat[j++] = rootOidXlat[i];
                        }

                    SnmpUtilVarBindFree(
                        &tempVarBindList[i]
                        );
                    }

                SnmpUtilMemFree(tempVarBindList);

                } // end if()

            } // end while()

        // Free allocated memory.
        SnmpUtilMemFree(agent);
        SnmpUtilMemFree(community);
        SnmpUtilMemFree(rootOidXlat);

        SnmpUtilVarBindListFree(&variableBindings);

        for (i=0; i < rootOidLen; i++)
            {
            SnmpUtilOidFree(&rootOidList[i]);
            }

        SnmpUtilMemFree(rootOidList);

        }
    else if (operation == TRAP)
        {
        // Trap handling can be done two different ways: event driven or
        // polled.  The following code illustrates the steps to use event
        // driven trap reception in a management application.


        HANDLE hNewTraps = NULL;


        if (!SnmpMgrTrapListen(&hNewTraps))
            {
            printf("error on SnmpMgrTrapListen %d\n", GetLastError());
            return 1;
            }
        else
            {
            printf("snmputil: listening for traps...\n");
            }


        while(1)
            {
            DWORD dwResult;

            if ((dwResult = WaitForSingleObject(hNewTraps, 0xffffffff))
                == 0xffffffff)
                {
                printf("error on WaitForSingleObject %d\n",
                       GetLastError());
                }
            else if (!ResetEvent(hNewTraps))
                {
                printf("error on ResetEvent %d\n", GetLastError());
                }
            else
                {
                AsnObjectIdentifier enterprise;
                AsnNetworkAddress   agentAddress;
                AsnNetworkAddress   sourceAddress;
                AsnInteger          genericTrap;
                AsnInteger          specificTrap;
                AsnOctetString      community;
                AsnTimeticks        timeStamp;
                RFC1157VarBindList  variableBindings;

                UINT i;
                char *string = NULL;

                while(SnmpMgrGetTrapEx(
                        &enterprise,
                        &agentAddress,
                        &sourceAddress,
                        &genericTrap,
                        &specificTrap,
                        &community,
                        &timeStamp,
                        &variableBindings))
                    {

                    printf("Incoming Trap:\n"
                           "  generic    = %d\n"
                           "  specific   = %d\n",
                           genericTrap,
                           specificTrap);

                    SnmpMgrOidToStr(&enterprise, &string);
                        printf ("  enterprise = %s\n", string);
                    if (string) 
                        SnmpUtilMemFree(string);
                    SnmpUtilOidFree(&enterprise);

                    if (agentAddress.length == 4) {
                        printf ("  agent      = %d.%d.%d.%d\n",
                             (int)agentAddress.stream[0],
                             (int)agentAddress.stream[1],
                             (int)agentAddress.stream[2],
                             (int)agentAddress.stream[3]);
                    }
                    if (agentAddress.dynamic) {
                        SnmpUtilMemFree(agentAddress.stream);
                    }

                    if (sourceAddress.length == 4) {
                        printf ("  source IP  = %d.%d.%d.%d\n",
                             (int)sourceAddress.stream[0],
                             (int)sourceAddress.stream[1],
                             (int)sourceAddress.stream[2],
                             (int)sourceAddress.stream[3]);
                    }
                    else if (sourceAddress.length == 10) {
                        printf ("  source IPX = %.2x%.2x%.2x%.2x."
                                "%.2x%.2x%.2x%.2x%.2x%.2x\n",
                             (int)sourceAddress.stream[0],
                             (int)sourceAddress.stream[1],
                             (int)sourceAddress.stream[2],
                             (int)sourceAddress.stream[3],
                             (int)sourceAddress.stream[4],
                             (int)sourceAddress.stream[5],
                             (int)sourceAddress.stream[6],
                             (int)sourceAddress.stream[7],
                             (int)sourceAddress.stream[8],
                             (int)sourceAddress.stream[9]);
                    }
                    if (sourceAddress.dynamic) {
                        SnmpUtilMemFree(sourceAddress.stream);
                    }

                    if (community.length)
                    {
                        string = SnmpUtilMemAlloc (community.length + 1);
                        memcpy (string, community.stream, community.length);
                        string[community.length] = '\0';
                        printf ("  community  = %s\n", string);
                        SnmpUtilMemFree(string);
                    }
                    if (community.dynamic) {
                        SnmpUtilMemFree(community.stream);
                    }

                    for(i=0; i < variableBindings.len; i++)
                        {
                        SnmpMgrOidToStr(&variableBindings.list[i].name, &string);
                        printf("  variable   = %s\n", string);
                        if (string) SnmpUtilMemFree(string);

                        printf("  value      = ");
                        SnmpUtilPrintAsnAny(&variableBindings.list[i].value);
                        } // end for()
                    printf("\n");


                    SnmpUtilVarBindListFree(&variableBindings);
                    }

                dwResult = GetLastError(); // check for errors...

                if ((dwResult != NOERROR) && (dwResult != SNMP_MGMTAPI_NOTRAPS))
                    {
                    printf("error on SnmpMgrGetTrap %d\n", dwResult);
                    }
                }

            } // end while()


        } // end if(operation)

    if (operation != TRAP)
        {
        // Close SNMP session with the remote agent.

        if (!SnmpMgrClose(session))
            {
            printf("error on SnmpMgrClose %d\n", GetLastError());

            return 1;
            }
        }


    // Let the command interpreter know things went ok.

    return 0;

    } // end main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_bn.c ===
// wsnmp_bn.c
//
// WinSNMP Low-Level SNMP/ASN.1/BER Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980424 - Received msgLen may be larger than pduLen
//        - ParsePduHdr() and ParseMessage() now accommodate this.
// 980420 - Mods related to ParseCntr64() inspired by
//          MS bug ID 127357 (removal of temp64 variable)
//        - Mod to ParseOID() for MS bug ID 127353
//          (reset os_ptr->ptr to NULL on error)
//
// 970310 - Typographical changes
//
#include "winsnmp.inc"

long FindLenVarBind      (LPVARBIND vb_ptr);
long FindLenVALUE        (smiLPVALUE);
long FindLenOctetString  (smiLPOCTETS os_ptr);
long FindLenOID          (smiLPCOID oid_ptr);
long FindLenUInt         (smiUINT32 value);
long FindLenInt          (smiINT32 value);
long FindLenCntr64       (smiLPCNTR64 value);
long DoLenLen            (smiINT32 len);
void AddLen (smiLPBYTE *tmpPtr, smiINT32 lenlen, smiINT32 data_len);
long AddVarBind (smiLPBYTE *tmpPtr, LPVARBIND vb_ptr);
long AddOctetString (smiLPBYTE *tmpPtr, int type, smiLPOCTETS os_ptr);
long AddOID (smiLPBYTE *tmpPtr, smiLPOID oid_ptr);
long AddUInt (smiLPBYTE *tmpPtr, int type, smiUINT32 value);
long AddInt (smiLPBYTE *tmpPtr, smiINT32 value);
long AddCntr64 (smiLPBYTE *tmpPtr, smiLPCNTR64 value);
void AddNull (smiLPBYTE *tmpPtr, int type);
LPVARBIND ParseVarBind (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
BOOL ParseOctetString (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOCTETS os_ptr);
BOOL ParseOID (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOID oid_ptr);
BOOL ParseCntr64 (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPCNTR64 cntr64_ptr);
BOOL ParseUInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPUINT32 value);
BOOL ParseInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPINT value);
BOOL ParseNull (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
BOOL ParseSequence (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
smiINT32 ParseType (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);
smiINT32 ParseLength (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen);

void FreeOctetString (smiLPOCTETS os_ptr)
{
if (os_ptr)
   {
   if (os_ptr->ptr)
      GlobalFree (os_ptr->ptr);
   GlobalFree (os_ptr);
   }
return;
}

void FreeVarBindList (LPVARBIND vb_ptr)
{
if (vb_ptr)
   { // NULLs are handled by downstream call
   FreeVarBindList (vb_ptr->next_var);
   FreeVarBind (vb_ptr);
   }
return;
}

void FreeVarBind (LPVARBIND vb_ptr)
{
if (vb_ptr)
   {
   if (vb_ptr->name.ptr)
      GlobalFree (vb_ptr->name.ptr);
   switch (vb_ptr->value.syntax)
      {
      case SNMP_SYNTAX_OID:
      if (vb_ptr->value.value.oid.ptr)
         GlobalFree (vb_ptr->value.value.oid.ptr);
      break;

      case SNMP_SYNTAX_OCTETS:
      case SNMP_SYNTAX_IPADDR:
      case SNMP_SYNTAX_OPAQUE:
      if (vb_ptr->value.value.string.ptr)
         GlobalFree (vb_ptr->value.value.string.ptr);
      break;

      default: // Remaining types do not have 'ptr' members
      break;
      } // end_switch
   GlobalFree (vb_ptr);
   } // end_if (vb_ptr)
return;
} // end_FreeVarBind

void FreeV1Trap (LPV1TRAP v1Trap_ptr)
{
if (v1Trap_ptr)
   {
   if (v1Trap_ptr->enterprise.ptr)
      GlobalFree (v1Trap_ptr->enterprise.ptr);
   if (v1Trap_ptr->agent_addr.ptr)
      GlobalFree (v1Trap_ptr->agent_addr.ptr);
   GlobalFree (v1Trap_ptr);
   }
} // end_FreeV1Trap

void AddLen (smiLPBYTE *tmpPtr, long lenlen, long data_len)
{
long i;
if (lenlen == 1)
   *(*tmpPtr)++ = (smiBYTE)data_len;
else
   {
   *(*tmpPtr)++ = (smiBYTE)(0x80 + lenlen - 1);
   for (i = 1; i < lenlen; i++)
      {
      *(*tmpPtr)++ = (smiBYTE)((data_len >>
         (8 * (lenlen - i - 1))) & 0xFF);
      } // end_for
   } // end_else
return;
} // end_AddLen

long AddVarBind (smiLPBYTE *tmpPtr, LPVARBIND vb_ptr)
{
long lenlen;
if (vb_ptr == NULL)
   return (0);
if ((lenlen = DoLenLen(vb_ptr->data_length)) == -1)
   return (-1);
*(*tmpPtr)++ = SNMP_SYNTAX_SEQUENCE;
AddLen (tmpPtr, lenlen, vb_ptr->data_length);
if (AddOID (tmpPtr, &vb_ptr->name) == -1)
   return (-1);

switch (vb_ptr->value.syntax)
   {
   case SNMP_SYNTAX_CNTR32:
   case SNMP_SYNTAX_GAUGE32:
   case SNMP_SYNTAX_TIMETICKS:
   case SNMP_SYNTAX_UINT32:
   AddUInt (tmpPtr, (int)vb_ptr->value.syntax, vb_ptr->value.value.uNumber);
   break;

   case SNMP_SYNTAX_INT:
   AddInt (tmpPtr, vb_ptr->value.value.sNumber);
   break;

   case SNMP_SYNTAX_OID:
   if (AddOID (tmpPtr, (smiLPOID)&(vb_ptr->value.value.oid)) == -1)
      return (-1);
   break;

   case SNMP_SYNTAX_CNTR64:
   AddCntr64 (tmpPtr, (smiLPCNTR64)&(vb_ptr->value.value.hNumber));
   break;

   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_OPAQUE:
   if (AddOctetString (tmpPtr, (int)vb_ptr->value.syntax,
         (smiLPOCTETS)&(vb_ptr->value.value.string)) == -1)
      return -1;
   break;

   case SNMP_SYNTAX_NULL:
   case SNMP_SYNTAX_NOSUCHOBJECT:
   case SNMP_SYNTAX_NOSUCHINSTANCE:
   case SNMP_SYNTAX_ENDOFMIBVIEW:
   AddNull (tmpPtr, (int)vb_ptr->value.syntax);
   break;

   default:
   return (-1);
   } // end_switch
return (AddVarBind (tmpPtr, vb_ptr->next_var));
}

long AddOctetString (smiLPBYTE *tmpPtr, int type, smiLPOCTETS os_ptr)
{
UINT i;
long lenlen;
if ((lenlen = DoLenLen ((long)os_ptr->len)) == -1)
   return (-1);
*(*tmpPtr)++ = (smiBYTE)(0xFF & type);
AddLen (tmpPtr, lenlen, os_ptr->len);
for (i = 0; i < os_ptr->len; i++)
   *(*tmpPtr)++ = os_ptr->ptr[i];
return (0);
}

long AddOID (smiLPBYTE *tmpPtr, smiLPOID oid_ptr)
{
UINT i;
long lenlen = 0;
long encoded_len;
encoded_len = 1; // for first two SID's
for (i = 2; i < oid_ptr->len; i++)
   {
   if (oid_ptr->ptr[i] < 0x80)            // 0 - 0x7F
      encoded_len += 1;
   else if (oid_ptr->ptr[i] < 0x4000)     // 0x80 - 0x3FFF
      encoded_len += 2;
   else if (oid_ptr->ptr[i] < 0x200000)   // 0x4000 - 0x1FFFFF
      encoded_len += 3;
   else if (oid_ptr->ptr[i] < 0x10000000) // 0x200000 - 0xFFFFFFF
      encoded_len += 4;
   else
      encoded_len += 5;
   }
if ((lenlen = DoLenLen (encoded_len)) == -1)
   return (-1);
*(*tmpPtr)++ = (smiBYTE)(0xFF & SNMP_SYNTAX_OID);
AddLen (tmpPtr, lenlen, encoded_len);
if (oid_ptr->len < 2)
   *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[0] * 40);
else
   *(*tmpPtr)++ = (smiBYTE)((oid_ptr->ptr[0] * 40) + oid_ptr->ptr[1]);
for (i = 2; i < oid_ptr->len; i++)
   {
   if (oid_ptr->ptr[i] < 0x80)
      { // 0 - 0x7F
      *(*tmpPtr)++ = (smiBYTE)oid_ptr->ptr[i];
      }
   else if (oid_ptr->ptr[i] < 0x4000)
      { // 0x80 - 0x3FFF
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   else if (oid_ptr->ptr[i] < 0x200000)
      { // 0x4000 - 0x1FFFFF
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 14) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80);  // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   else if (oid_ptr->ptr[i] < 0x10000000)
      { // 0x200000 - 0xFFFFFFF
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 21) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 14) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80);  // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   else
      {
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 28) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 21) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 14) | 0x80); // set high bit
      *(*tmpPtr)++ = (smiBYTE)
      (((oid_ptr->ptr[i]) >> 7) | 0x80);  // set high bit
      *(*tmpPtr)++ = (smiBYTE)(oid_ptr->ptr[i] & 0x7f);
      }
   } // end_for
return (0);
} // end_AddOID

long AddUInt (smiLPBYTE *tmpPtr, int type, smiUINT32 value)
{
long i;
long datalen;
long lenlen;
// if high bit one, must use 5 octets (first with 00)
if (((value >> 24) & 0xFF) != 0)
   datalen = 4;
else if (((value >> 16) & 0xFF) != 0)
   datalen = 3;
else if (((value >> 8) & 0xFF) != 0)
   datalen = 2;
else
   datalen = 1;
if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
   datalen++;
lenlen = 1; // < 127 octets
*(*tmpPtr)++ = (smiBYTE)(0xFF & type);
AddLen(tmpPtr, lenlen, datalen);
if (datalen == 5)
   { // gotta put a 00 in first octet
   *(*tmpPtr)++ = (smiBYTE)0;
   for (i = 1; i < datalen; i++)
      {
      *(*tmpPtr)++ = (smiBYTE)(value >>
         (8 * ((datalen - 1) - i) & 0xFF));
      }
   } // end_if
else
   {
   for (i = 0; i < datalen; i++)
      {
      *(*tmpPtr)++ = (smiBYTE)(value >>
         (8 * ((datalen - 1) - i) & 0xFF));
      }
   } // end_else
return (0);
} // end_AddUInt

long AddInt (smiLPBYTE *tmpPtr, smiINT32 value)
{
long i;
long datalen;
long lenlen;
switch ((smiBYTE) ((value >> 24) & 0xFF))
   {
   case 0x00:
   if (((value >> 16) & 0xFF) != 0)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
      datalen++;
   break;

   case 0xFF:
   if (((value >> 16) & 0xFF) != 0xFF)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0xFF)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) == 0)
      datalen++;
   break;

   default:
   datalen = 4;
   } // end_switch
lenlen = 1; // < 127 octets
*(*tmpPtr)++ = (smiBYTE)(0xFF & SNMP_SYNTAX_INT);
AddLen(tmpPtr, lenlen, datalen);
for (i = 0; i < datalen; i++)
   {
   *(*tmpPtr)++  = (smiBYTE) (value >>
      (8 * ((datalen - 1) - i) & 0xFF));
   }
return (0);
} // end_AddInt()

long AddCntr64 (smiLPBYTE *tmpPtr, smiLPCNTR64 value)
{
long i;
long datalen;
long lenlen;
datalen = FindLenCntr64(value) - 2;
lenlen = 1; // < 127 octets
*(*tmpPtr)++ = (smiBYTE)(0xFF & SNMP_SYNTAX_CNTR64);
AddLen(tmpPtr, lenlen, datalen);
if (datalen == 9)
   { // gotta put a 00 in first octet
   *(*tmpPtr)++ = (smiBYTE)0;
   datalen--;
   }
for (i = datalen; i > 4; i--)
   {
   *(*tmpPtr)++ = (smiBYTE)(value->hipart >>
      (8 * (i - 5) & 0xFF));
   }
for (; i > 0; i--)
   {
   *(*tmpPtr)++ = (smiBYTE)(value->lopart >>
      (8 * (i - 1) & 0xFF));
   }
return (0);
}

long FindLenVarBind (LPVARBIND vb_ptr)
{
long lenlen;
long tot_so_far;
if (!vb_ptr) return (0);
tot_so_far = FindLenVarBind (vb_ptr->next_var);
if (tot_so_far == -1)
   return (-1);
vb_ptr->data_length = FindLenOID (&vb_ptr->name) +
                      FindLenVALUE (&vb_ptr->value);
if ((lenlen = DoLenLen (vb_ptr->data_length)) == -1)
   return (-1);
return (1 + lenlen + vb_ptr->data_length + tot_so_far);
} // end_FindLenVarBind

long FindLenVALUE (smiLPVALUE value_ptr)
{
if (value_ptr)
   {
   switch (value_ptr->syntax)
      {
      case SNMP_SYNTAX_OCTETS:
      case SNMP_SYNTAX_IPADDR:
      case SNMP_SYNTAX_OPAQUE:
      return (FindLenOctetString (&value_ptr->value.string));

      case SNMP_SYNTAX_OID:
      return (FindLenOID (&value_ptr->value.oid));

      case SNMP_SYNTAX_NULL:
      case SNMP_SYNTAX_NOSUCHOBJECT:
      case SNMP_SYNTAX_NOSUCHINSTANCE:
      case SNMP_SYNTAX_ENDOFMIBVIEW:
      return (2);

      case SNMP_SYNTAX_INT:
      return (FindLenInt (value_ptr->value.sNumber));

      case SNMP_SYNTAX_CNTR32:
      case SNMP_SYNTAX_GAUGE32:
      case SNMP_SYNTAX_TIMETICKS:
      case SNMP_SYNTAX_UINT32:
      return (FindLenUInt (value_ptr->value.uNumber));

      case SNMP_SYNTAX_CNTR64:
      return (FindLenCntr64 (&value_ptr->value.hNumber));
      } // end_switch
   } // end_if
return (-1);
} // end_FindLenVALUE

long FindLenOctetString (smiLPOCTETS os_ptr)
{
long lenlen;
if (!os_ptr) return (-1);
if ((lenlen = DoLenLen (os_ptr->len)) == -1)
   return (-1);
 return (1 + lenlen + os_ptr->len);
}

long FindLenOID (smiLPCOID oid_ptr)
{
long lenlen;
UINT i;
UINT encoded_len;
encoded_len = 1; // for first two Sub-IDs
// beware of i = 2
for (i = 2; i < oid_ptr->len; i++)
   {
   if (oid_ptr->ptr[i] < 0x80)            // 0 - 0x7F
      encoded_len += 1;
   else if (oid_ptr->ptr[i] < 0x4000)     // 0x80 - 0x3FFF
      encoded_len += 2;
   else if (oid_ptr->ptr[i] < 0x200000)   // 0x4000 - 0x1FFFFF
      encoded_len += 3;
   else if (oid_ptr->ptr[i] < 0x10000000) // 0x200000 - 0xFFFFFFF
      encoded_len += 4;
   else
      encoded_len += 5;
   } // end_for
if ((lenlen = DoLenLen (encoded_len)) == -1)
   return (-1);
return (1 + lenlen + encoded_len);
} // end_FindLenOID

long FindLenUInt (smiUINT32 value)
{
long datalen;
// if high bit one, must use 5 octets (first with 00)
if (((value >> 24) & 0xFF) != 0)
   datalen = 4;
else if (((value >> 16) & 0xFF) != 0)
   datalen = 3;
else if (((value >> 8) & 0xFF) != 0)
   datalen = 2;
else
   datalen = 1;
if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
   datalen++;
// length of length  < 127 octets
return (1 + 1 + datalen);
}

long FindLenInt (smiINT32 value)
{
long datalen;
switch ((smiBYTE) ((value >> 24) & 0xFF))
   {
   case 0x00:
   if (((value >> 16) & 0xFF) != 0)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) != 0)
      datalen++;
   break;

   case 0xFF:
   if (((value >> 16) & 0xFF) != 0xFF)
      datalen = 3;
   else if (((value >> 8) & 0xFF) != 0xFF)
      datalen = 2;
   else
      datalen = 1;
   if (((value >> (8 * (datalen - 1))) & 0x80) == 0)
      datalen++;
   break;

   default:
   datalen = 4;
   } // end_switch
return (1 + 1 + datalen);
}

long FindLenCntr64 (smiLPCNTR64 value)
{
long datalen;

// if high bit one, must use 5 octets (first with 00)
if (((value->hipart >> 24) & 0xFF) != 0)
   {
   datalen = 8;
   if (((value->hipart >> 24) & 0x80) != 0) datalen++;
   }
else if (((value->hipart >> 16) & 0xFF) != 0)
   {
   datalen = 7;
   if (((value->hipart >> 16) & 0x80) != 0) datalen++;
   }
else if (((value->hipart >> 8) & 0xFF) != 0)
   {
   datalen = 6;
   if (((value->hipart >> 8) & 0x80) != 0) datalen++;
   }
else if (((value->hipart) & 0xFF) != 0)
   {
   datalen = 5;
   if (((value->hipart) & 0x80) != 0) datalen++;
   }
else if (((value->lopart>> 24) & 0xFF) != 0)
   {
   datalen = 4;
   if (((value->lopart >> 24) & 0x80) != 0) datalen++;
   }
else if (((value->lopart >> 16) & 0xFF) != 0)
   {
   datalen = 3;
   if (((value->lopart >> 16) & 0x80) != 0) datalen++;
   }
else if (((value->lopart >> 8) & 0xFF) != 0)
   {
   datalen = 2;
   if (((value->lopart >> 8) & 0x80) != 0) datalen++;
   }
else
   {
   datalen = 1;
   if (((value->lopart) & 0x80) != 0) datalen++;
   }
// length of length  < 127 octets
return (1 + 1 + datalen);
}

long DoLenLen (long len)
{
// short form?
if (len < 128) return (1);
if (len < 0x100) return (2);
if (len < 0x10000) return (3);
if (len < 0x1000000) return (4);
return (-1);
}

void AddNull (smiLPBYTE *tmpPtr, int type)
{
*(*tmpPtr)++ = (smiBYTE)(0xFF & type);
*(*tmpPtr)++ = 0x00;
return;
}

BOOL BuildMessage (smiUINT32 version, smiLPOCTETS community,
                   LPPDUS pdu, smiINT32 requestId,
                   smiLPBYTE *msgAddr, smiLPUINT32 msgSize)
{
LPVARBIND vbList = NULL;
long nVbDataLen, nVbLenLen, nVbTotalLen;
long nPduDataLen, nPduLenLen, nPduTotalLen;
long nMsgDataLen, nMsgLenLen, nMsgTotalLen;
long nTmpDataLen;
smiLPBYTE tmpPtr = NULL;
*msgAddr = NULL;
*msgSize = 0;
if (pdu == NULL || community == NULL)
   return (FALSE);
// Determine length of VarBind list part
vbList = pdu->VBL_addr;
if (vbList == NULL && pdu->VBL != 0)
   vbList = ((LPVBLS)snmpGetTableEntry(&VBLsDescr, HandleToUlong(pdu->VBL)-1))->vbList;
// vbList == NULL is ok
if ((nVbDataLen = FindLenVarBind (vbList)) == -1)
   return (FALSE);
if ((nVbLenLen = DoLenLen (nVbDataLen)) == -1)
   return (FALSE);
nVbTotalLen = 1 + nVbLenLen + nVbDataLen;
// Determine length of PDU overhead part
switch (pdu->type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_GETBULK:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   nPduDataLen = FindLenInt (requestId)
               + FindLenInt (pdu->errStatus)
               + FindLenInt (pdu->errIndex)
               + nVbTotalLen;
   break;

   case SNMP_PDU_V1TRAP:
   if (!pdu->v1Trap)
      return (FALSE);
   nPduDataLen = FindLenInt (pdu->v1Trap->generic_trap)
               + FindLenInt (pdu->v1Trap->specific_trap)
               + FindLenUInt (pdu->v1Trap->time_ticks)
               + nVbTotalLen;
   if ((nTmpDataLen = FindLenOID (&pdu->v1Trap->enterprise)) == -1)
      return (FALSE);
   nPduDataLen += nTmpDataLen;
   if ((nTmpDataLen = FindLenOctetString (&pdu->v1Trap->agent_addr)) == -1)
      return (FALSE);
   nPduDataLen += nTmpDataLen;
   break;

   default:
   return (FALSE);
   } // end_switch
if ((nPduLenLen = DoLenLen(nPduDataLen)) == -1)
   return (FALSE);
nPduTotalLen = 1 + nPduLenLen + nPduDataLen;
nMsgDataLen = FindLenUInt (version)
            + FindLenOctetString (community)
            + nPduTotalLen;
nMsgLenLen = DoLenLen (nMsgDataLen);
nMsgTotalLen = 1 + nMsgLenLen + nMsgDataLen;
// Allocate the necessary memory for the message
tmpPtr = GlobalAlloc (GPTR, nMsgTotalLen);
if (tmpPtr == NULL)
   return (FALSE);
*msgAddr = tmpPtr;
*msgSize = nMsgTotalLen;
// Now plug in the values in the message bytes
*tmpPtr++ = SNMP_SYNTAX_SEQUENCE;
// Wrapper portion
AddLen (&tmpPtr, nMsgLenLen, nMsgDataLen);
AddInt (&tmpPtr, version);
AddOctetString (&tmpPtr, SNMP_SYNTAX_OCTETS, community);
// PDU header portion
// "Downgrade" GetBulk to GetNext if target is SNMPv1
if (pdu->type == SNMP_PDU_GETBULK && version == 0)
   *tmpPtr++ = SNMP_PDU_GETNEXT;
else
   *tmpPtr++ = (BYTE) pdu->type;
AddLen (&tmpPtr, nPduLenLen, nPduDataLen);
switch (pdu->type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   case SNMP_PDU_GETBULK:
   AddInt (&tmpPtr, requestId);
   AddInt (&tmpPtr, pdu->errStatus);
   AddInt (&tmpPtr, pdu->errIndex);
   break;

   case SNMP_PDU_V1TRAP:
   if (AddOID (&tmpPtr, &pdu->v1Trap->enterprise)== -1)
      goto error_out;
   if (AddOctetString (&tmpPtr, SNMP_SYNTAX_IPADDR, &pdu->v1Trap->agent_addr) == -1)
      goto error_out;
   AddInt (&tmpPtr, pdu->v1Trap->generic_trap);
   AddInt (&tmpPtr, pdu->v1Trap->specific_trap);
   AddUInt (&tmpPtr, SNMP_SYNTAX_TIMETICKS, pdu->v1Trap->time_ticks);
   break;

   default:
   goto error_out;
   } // end_switch
// VarBindList portion
*tmpPtr++ = SNMP_SYNTAX_SEQUENCE;
AddLen (&tmpPtr, nVbLenLen, nVbDataLen);
if (AddVarBind (&tmpPtr, vbList) == -1)
   {
error_out:
   if (*msgAddr)
      GlobalFree (*msgAddr);
   *msgAddr = NULL;
   *msgSize = 0;
   return (FALSE);
   }
// Success
return (TRUE);
} // end_BuildMessage()


BOOL SetPduType (smiLPBYTE msgPtr, smiUINT32 msgLen, int pduType)
{
smiLPBYTE tmpPtr;
smiUINT32 tmp;
if (!(tmpPtr = msgPtr))                    // Deliberate assignment
   return (FALSE);
if (!(ParseSequence (&tmpPtr, &msgLen)))   // sequence
   return (FALSE);
if (!(ParseUInt (&tmpPtr, &msgLen, &tmp))) // version
   return (FALSE);
// Jump over communityString...not needed here
if (ParseType (&tmpPtr, &msgLen) == -1)
   return (FALSE);
if ((tmp = ParseLength (&tmpPtr, &msgLen)) == -1)
   return (FALSE);
if (tmp > msgLen)
   return (FALSE);
tmpPtr += tmp; // Jump!
// Set the PDU type byte
*tmpPtr = (smiBYTE)pduType;
return (TRUE);
} // End_SetPduType()


smiUINT32 ParsePduHdr (smiLPBYTE msgPtr, smiUINT32 msgLen,
                       smiLPUINT32 version, smiLPINT32 type, smiLPUINT32 reqID)
{
// This is a private function (not exported via WinSNMP)
// It is called only once by msgNotify() (another private function)
// to "peek ahead" at certain PDU attributes to determine the next
// procesing steps.
smiUINT32 pduLen;
smiUINT32 length;
long errcode = 1;
if (msgPtr == NULL)
   goto DONE;
errcode++; // 2
// Parse initial Sequence field...
if (ParseType (&msgPtr, &msgLen) != SNMP_SYNTAX_SEQUENCE)
   goto DONE;
errcode++; // 3
// ...to get the remaining pduLen out of it
if ((pduLen = ParseLength (&msgPtr, &msgLen)) == -1)
   goto DONE;
errcode++; // 4
if (pduLen > msgLen)
   goto DONE;
errcode++; // 5
msgLen = pduLen; // Only pduLen counts now
if (!(ParseUInt (&msgPtr, &msgLen, version)))
   goto DONE;
errcode++; // 6
// Jump over communityString...not needed here
if (ParseType (&msgPtr, &msgLen) == -1)
   goto DONE;
errcode++; // 7
if ((length = ParseLength (&msgPtr, &msgLen)) == -1)
   goto DONE;
errcode++; // 8
if (length > msgLen)
   goto DONE;
errcode++; // 9
msgPtr += length; // Jump!
msgLen -= length;
// Get PDU type
if ((*type = ParseType (&msgPtr, &msgLen)) == -1)
   goto DONE;
errcode++; // 10
// Check PDU type for requestID semantics
if (*type == SNMP_PDU_V1TRAP)
   *reqID = 0; // No requestID on v1 trapPDU
else // Not a v1 trapPDU, therefore
   { // must get requestID
   if ((ParseLength (&msgPtr, &msgLen)) == -1)
      goto DONE;
   errcode++; // 11
   if (!(ParseInt (&msgPtr, &msgLen, reqID)))
      goto DONE;
   }
errcode = 0;
DONE:
return (errcode);
} // end_ParsePduHdr

smiUINT32 ParseMessage (smiLPBYTE msgPtr, smiUINT32 msgLen,
                        smiLPUINT32 version, smiLPOCTETS *community, LPPDUS pdu)
{
smiUINT32 pduLen;
smiLPOCTETS os_ptr;
LPVARBIND vb_ptr;
LPVARBIND vb_end_ptr;
long errcode = 1;
if (msgPtr == NULL)
   goto DONE;
errcode++; // 2
// Parse initial Sequence field...
if (ParseType (&msgPtr, &msgLen) != SNMP_SYNTAX_SEQUENCE)
   goto DONE;
errcode++; // 3
// ...to get the remaining pduLen out of it
if ((pduLen = ParseLength (&msgPtr, &msgLen)) == -1)
   goto DONE;
errcode++; // 4
if (pduLen > msgLen)
   goto DONE;
errcode++; // 5
msgLen = pduLen; // Only pduLen counts now
if (!(ParseUInt (&msgPtr, &msgLen, version)))
   goto DONE;
errcode++; // 5
if (*version != 0 && *version != 1) // SNMPv1 or SNMPv2c
   goto DONE;
errcode++; // 6
if (!(os_ptr = GlobalAlloc (GPTR, sizeof(smiOCTETS))))
   goto DONE;
errcode++; // 7
if (!(ParseOctetString (&msgPtr, &msgLen, os_ptr)))
   goto DONE_OS;
errcode++; // 8
if (pdu == NULL)
   goto DONE_OS;
ZeroMemory (pdu, sizeof(PDUS));
if ((pdu->type = ParseType (&msgPtr, &msgLen)) == -1)
   goto DONE_PDU;
errcode++; // 9
if ((ParseLength (&msgPtr, &msgLen)) == -1)
   goto DONE_PDU;
errcode++; // 10
switch (pdu->type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_GETBULK:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->appReqId)))
      goto DONE_PDU;
errcode++; // 11
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->errStatus)))
      goto DONE_PDU;
errcode++; // 12
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->errIndex)))
      goto DONE_PDU;
errcode++; // 13
   break;

   case SNMP_PDU_V1TRAP:
   pdu->v1Trap = GlobalAlloc (GPTR, sizeof(V1TRAP));
   if (pdu->v1Trap == NULL)
      goto DONE_PDU;
errcode++; // 11
   if (!(ParseOID (&msgPtr, &msgLen, &pdu->v1Trap->enterprise)))
      goto DONE_PDU;
errcode++; // 12
   if (!(ParseOctetString (&msgPtr, &msgLen, &pdu->v1Trap->agent_addr)))
      goto DONE_PDU;
errcode++; // 13
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->v1Trap->generic_trap)))
      goto DONE_PDU;
errcode++; // 14
   if (!(ParseInt (&msgPtr, &msgLen, &pdu->v1Trap->specific_trap)))
      goto DONE_PDU;
errcode++; // 15
   if (!(ParseUInt (&msgPtr, &msgLen, &pdu->v1Trap->time_ticks)))
      goto DONE_PDU;
errcode++; // 16
   break;

   default:
   goto DONE_PDU;
   } // end_switch
errcode = 20; // re-normalize
// Waste the SEQUENCE tag
if (!(ParseSequence (&msgPtr, &msgLen)))
      goto DONE_PDU;
errcode++; // 21
// Parse the varbind list
pdu->VBL = 0;
pdu->VBL_addr = NULL;
while (msgLen)
   {
   if (!(vb_ptr = ParseVarBind (&msgPtr, &msgLen)))
      goto DONE_PDU;
errcode++; // 22+
   if (!pdu->VBL_addr)                     // Is this the first one?
      vb_end_ptr = pdu->VBL_addr = vb_ptr; // If so, start a list
   else
      { // tack onto end of list
      vb_end_ptr->next_var = vb_ptr;
      vb_end_ptr = vb_ptr;
      }
   } // end_while
errcode = 0;
*community = os_ptr;
goto DONE;
DONE_PDU:
FreeVarBindList (pdu->VBL_addr); // Checks for NULL
FreeV1Trap (pdu->v1Trap);        // Checks for NULL
ZeroMemory (pdu, sizeof(PDUS));
DONE_OS:
FreeOctetString (os_ptr);
DONE:
return (errcode);
} // end_ParseMessage

LPVARBIND ParseVarBind (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
LPVARBIND vb_ptr;
if (!(ParseSequence (tmpPtr, tmpLen)))
   return (NULL);
if ((vb_ptr = (LPVARBIND)GlobalAlloc(GPTR, sizeof(VARBIND))) == NULL)
   return (NULL);
if (!(ParseOID(tmpPtr, tmpLen, &vb_ptr->name)))
   goto ERROROUT;
vb_ptr->value.syntax = (smiUINT32)*(*tmpPtr);
switch (vb_ptr->value.syntax)
   {
   case SNMP_SYNTAX_CNTR32:
   case SNMP_SYNTAX_GAUGE32:
   case SNMP_SYNTAX_TIMETICKS:
   case SNMP_SYNTAX_UINT32:
   if (!(ParseUInt (tmpPtr, tmpLen, &vb_ptr->value.value.uNumber)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_INT:
   if (!(ParseInt (tmpPtr, tmpLen, &vb_ptr->value.value.sNumber)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_OID:
   if (!(ParseOID (tmpPtr, tmpLen, &vb_ptr->value.value.oid)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_CNTR64:
   if (!(ParseCntr64 (tmpPtr, tmpLen, &vb_ptr->value.value.hNumber)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_OPAQUE:
   if (!(ParseOctetString (tmpPtr, tmpLen, &vb_ptr->value.value.string)))
      goto ERROROUT;
   break;

   case SNMP_SYNTAX_NULL:
   case SNMP_SYNTAX_NOSUCHOBJECT:
   case SNMP_SYNTAX_NOSUCHINSTANCE:
   case SNMP_SYNTAX_ENDOFMIBVIEW:
   if (!(ParseNull (tmpPtr, tmpLen)))
      goto ERROROUT;
   break;

   default:
   goto ERROROUT;
   } // end_switch
return (vb_ptr); // Success
//
ERROROUT:
FreeVarBind(vb_ptr);
return (NULL);   // Failure
} // end_ParseVarBind

BOOL ParseOctetString
      (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOCTETS os_ptr)
{
if (!os_ptr)
   return (FALSE);
os_ptr->ptr = NULL;
os_ptr->len = 0;
if (ParseType (tmpPtr, tmpLen) == -1)
   return (FALSE);
if ((os_ptr->len = ParseLength (tmpPtr, tmpLen)) == -1)
   return (FALSE);
if (os_ptr->len > *tmpLen)
   return (FALSE);
if (os_ptr->len)
   { // Does not allocate "string" space on "length = 0"
   if (!(os_ptr->ptr = (smiLPBYTE)GlobalAlloc (GPTR, os_ptr->len)))
      return (FALSE);
   CopyMemory (os_ptr->ptr, *tmpPtr, os_ptr->len);
   }
*tmpPtr += os_ptr->len;
*tmpLen -= os_ptr->len;
return (TRUE);
} // end_ParseOctetString

BOOL ParseOID (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPOID oid_ptr)
{
    smiINT32 length;

    if (!oid_ptr)
        return (FALSE);
    oid_ptr->ptr = NULL;
    oid_ptr->len = 0;
    if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_OID)
        return (FALSE);
    length = ParseLength (tmpPtr, tmpLen);
    // -1 is error return from ParseLength()

    // BUG# 347175 this is just the length in bytes for the BER encoded OID in the stream, 
    // this code should be the same as in %sdxroot%\net\snmp\newagent\exe\snmppdus.c!ParseOid.
    // removed the (|| length > MAXOBJIDSIZE) condition from the following test. It should be
    // moved to the while loop to test the number of sub-ids instead of bytes in stream.
    if (length <= 0)  
        return (FALSE);
    if ((smiUINT32)length > *tmpLen)
        return (FALSE);
    // the sub-id array will by 1 longer than the ASN.1/BER array
    oid_ptr->ptr = (smiLPUINT32)GlobalAlloc (GPTR, sizeof(smiUINT32) * (length+1));
    if (oid_ptr->ptr == NULL)
        return (FALSE);

    // oid_ptr structure space is pre-zero'd via GlobalAlloc()
    while (length && (oid_ptr->len < MAXOBJIDSIZE))
    {
        oid_ptr->ptr[oid_ptr->len] =
            (oid_ptr->ptr[oid_ptr->len] << 7) + (*(*tmpPtr) & 0x7F);
        if ((*(*tmpPtr)++ & 0x80) == 0)
        {   // on the last octet of this sub-id
            if (oid_ptr->len == 0)  // check for first sub-id
            {                       // ASN.1/BER packs two into it
                oid_ptr->ptr[1] = oid_ptr->ptr[0];
                oid_ptr->ptr[0] /= 40;
                if (oid_ptr->ptr[0] > 2)
                    oid_ptr->ptr[0] = 2;
                oid_ptr->ptr[1] -= (oid_ptr->ptr[0] * 40);
                oid_ptr->len++; // extra bump
            }
            oid_ptr->len++; // increment the count on sub-id
        }
        length--;
        (*tmpLen)--;
    } // end_while (length)

    // BUG 506192
    // Invalid OID BER of the form like "06 07 FF FF FF FF FF FF FF"
    // causes oid_ptr->len becomes 0. Each subidentifier should be
    // encoded as a non-negative integer using as few 7-bit blocks as possible.
    // The blocks are packed in octets with the first bit of each octet equal
    // to 1 except for the last octet of each subidentifier. The example above
    // does not have the last octet. Added the (0 == oid_ptr->len) test below.
    if (length || (0 == oid_ptr->len)) 
    {
        // the above while loop is terminated without finishing the parsing of the stream
        GlobalFree(oid_ptr->ptr);
        oid_ptr->ptr = NULL;
        oid_ptr->len = 0;
        return (FALSE);
    }

    return (TRUE);
} // end_ParseOID

BOOL ParseCntr64 (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPCNTR64 Cntr64_ptr)
{
smiINT32 i;
smiINT32 length;
if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_CNTR64)
   return (FALSE);
if ((length = ParseLength(tmpPtr, tmpLen)) == -1)
   return (FALSE);
if ((smiUINT32)length > *tmpLen || length > 9 ||
   (length == 9 && *(*tmpPtr) != 0x00))
   return (FALSE);
while (length && *(*tmpPtr) == 0x00)
   {            // leading null octet?
   (*tmpPtr)++; // if so, skip it
   length--;    // and don't count it
   (*tmpLen)--;   // Adjust remaining msg length
   }
Cntr64_ptr->hipart = Cntr64_ptr->lopart = 0;
for (i = 0; i < length; i++)
   {
   Cntr64_ptr->hipart = (Cntr64_ptr->hipart << 8) +
                        (Cntr64_ptr->lopart >> 24);
   Cntr64_ptr->lopart = (Cntr64_ptr->lopart << 8) +
                        (smiUINT32) *(*tmpPtr)++;
   }
*tmpLen -= length;
return (TRUE);
} // end_ParseCntr64

BOOL ParseUInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPUINT32 value)
{
smiINT32 length;
smiINT32 i;
if (ParseType (tmpPtr, tmpLen) == -1)
   return (FALSE);
if ((length = ParseLength(tmpPtr, tmpLen)) == -1)
   return (FALSE);
if ((smiUINT32)length > *tmpLen)
   return (FALSE);
if ((length > 5) || ((length > 4) && (*(*tmpPtr) != 0x00)))
   return (FALSE);
while (length && *(*tmpPtr) == 0x00)
   {            // leading null octet?
   (*tmpPtr)++; // if so, skip it
   length--;    // and don't count it
   (*tmpLen)--;   // Adjust remaining msg length
   }
*value = 0;
for (i = 0; i < length; i++)
   *value = (*value << 8) + (smiUINT32)*(*tmpPtr)++;
*tmpLen -= length;
return (TRUE);
} // end_ParseUInt()

BOOL ParseInt (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen, smiLPINT value)
{
smiINT32 length;
smiINT32 i;
smiINT32 sign;
if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_INT)
   return (FALSE);
if ((length = ParseLength (tmpPtr, tmpLen)) == -1)
   return (FALSE);
if ((smiUINT32)length > *tmpLen || length > 4)
   return (FALSE);
sign = ((*(*tmpPtr) & 0x80) == 0x00) ? 0x00 : 0xFF;
*value = 0;
for (i = 0; i < length; i++)
   *value = (*value << 8) + (smiUINT32) *(*tmpPtr)++;
// sign-extend upper bits
for (i = length; i < 4; i++)
   *value = *value + (sign << i * 8);
*tmpLen -= length;
return (TRUE);
} // end_ParseInt()

BOOL ParseNull (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
smiINT32 length;
if (ParseType (tmpPtr, tmpLen) == -1)
   return (FALSE);
length = ParseLength (tmpPtr, tmpLen);
if (length != 0) // NULLs have no length
   return (FALSE);
return (TRUE);
} // end_ParseNull

BOOL ParseSequence (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
if (ParseType (tmpPtr, tmpLen) != SNMP_SYNTAX_SEQUENCE)
   return (FALSE);
if (ParseLength (tmpPtr, tmpLen) == -1)
   return (FALSE);
return (TRUE);
} // end_ParseSequence

smiINT32 ParseType (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
// 980421 - BobN
//        - replaced tmpLen logic with working_len logic
//        - working_len is always checked on entry into a
//        - Parse<xxx> function
smiINT32 type;
if (*tmpLen == 0)
   return (-1);
type = *(*tmpPtr)++;
(*tmpLen)--; // Adjust remaining msg length
switch (type)
   {
   case SNMP_SYNTAX_INT:
   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_OID:
   case SNMP_SYNTAX_SEQUENCE:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_CNTR32:
   case SNMP_SYNTAX_GAUGE32:
   case SNMP_SYNTAX_TIMETICKS:
   case SNMP_SYNTAX_OPAQUE:
   case SNMP_SYNTAX_UINT32:
   case SNMP_SYNTAX_CNTR64:
   case SNMP_SYNTAX_NULL:
   case SNMP_SYNTAX_NOSUCHOBJECT:
   case SNMP_SYNTAX_NOSUCHINSTANCE:
   case SNMP_SYNTAX_ENDOFMIBVIEW:
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_V1TRAP:
   case SNMP_PDU_GETBULK:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   break;

   default:
   type = -1;
   break;
   }
return (type);
} // end_ParseType

smiINT32 ParseLength (smiLPBYTE *tmpPtr, smiLPUINT32 tmpLen)
{
// 980421 - BobN
//        - replaced end_ptr logic with tmpLen logic
//        - tmpLen is always checked on entry into a Parse<xxx>
//        - function and is decremented as used therein.
smiINT32 length;
smiINT32 lenlen;
if (*tmpLen == 0)
   return (-1);
length = (smiINT32) *(*tmpPtr)++;
(*tmpLen)--; // Adjust remaining msg length
// Check for short-form value
if (length < 0x80)
   return (length);
// Long form
lenlen = length & 0x7F;
if ((smiUINT32)lenlen > *tmpLen || lenlen > 4 || lenlen < 1)
   return (-1); // Out of bounds
*tmpLen -= lenlen; // Adjust remaining msg length
length = 0;
while (lenlen)
   {
   length = (length << 8) + *(*tmpPtr)++;
   lenlen--;
   }
return (length);
} // end_ParseLength
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_ec.c ===
// wsnmp_ec.c
//
// WinSNMP Entity/Context Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980424 - BobN
//        - Mods to SnmpStrToEntity() to support corresponding
//        - mods to SnmpStrToIpxAddress() to permit '.' char as
//        - netnum/nodenum separator
// 970310 - Typographical changes
//
#include "winsnmp.inc"
SNMPAPI_STATUS SNMPAPI_CALL SnmpStrToIpxAddress (LPCSTR, LPBYTE, LPBYTE);

// SnmpStrToEntity
HSNMP_ENTITY SNMPAPI_CALL
   SnmpStrToEntity (IN HSNMP_SESSION hSession,
                    IN LPCSTR entityString)
{
DWORD strLen;
LPCSTR tstStr;
LPSTR profilePtr;
LPSTR comma = ",";
DWORD nEntity;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
char profileBuf[256];
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
if (!entityString || (strLen = lstrlen(entityString)) == 0)
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Must go through ERROR_PRECHECK label after next statement...
EnterCriticalSection (&cs_ENTITY);
// Search for Entity table entry to use
lError = snmpAllocTableEntry(&EntsDescr, &nEntity);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);

pEntity->version = 0;
pEntity->nPolicyTimeout = DEFTIMEOUT;
pEntity->nPolicyRetry = DEFRETRY;
if (strLen > MAX_FRIEND_NAME_LEN)
   strLen = MAX_FRIEND_NAME_LEN;
switch (TaskData.nTranslateMode)
   {
   case SNMPAPI_TRANSLATED:
   // the entity is picked up from NP_WSNMP.INI, from [Entities] section:
   // [Entities]
   // EntityFriendlyName = ver#, ipaddr, timeout#, retries#, port#[,]
   // ------
   // Get the whole buffer
   if (!GetPrivateProfileString ("Entities", entityString, "",
                     profileBuf, sizeof(profileBuf), "NP_WSNMP.INI"))
      {
      snmpFreeTableEntry(&EntsDescr, nEntity);
      lError = SNMPAPI_ENTITY_UNKNOWN;
      goto ERROR_PRECHECK;
      }
   // pick up the ver# first (mandatory)
   profilePtr = strtok (profileBuf, comma);
   // if no token, is like we have a key with no value
   // bail out with SNMPAPI_NOOP
   if (profilePtr == NULL)
   {
       snmpFreeTableEntry(&EntsDescr, nEntity);
       lError = SNMPAPI_NOOP;
       goto ERROR_PRECHECK;
   }
   pEntity->version = atoi (profilePtr);

   // pick up the dotted ip address (mandatory)
   tstStr = strtok (NULL, comma); // Save real address string
   // if no address is specified, we don't have the vital info, so there's nothing to do
   // bail with SNMPAPI_NOOP
   if (tstStr == NULL)
   {
       snmpFreeTableEntry(&EntsDescr, nEntity);
	   lError = SNMPAPI_NOOP;
	   goto ERROR_PRECHECK;
   }

   // pick up the timeout# (optional)
   if (profilePtr = strtok (NULL, comma))
   {
		// The local database entry uses milliseconds for the timeout interval
		pEntity->nPolicyTimeout = atol (profilePtr);
		// Adjust for centiseconds, as used by the WinSNMP API
		pEntity->nPolicyTimeout /= 10;

		// pick up the retry# (optional)
		if (profilePtr = strtok (NULL, comma))
		{
			pEntity->nPolicyRetry = atol (profilePtr);

			// pick up the port# (optional)
			if (profilePtr = strtok (NULL, comma))
				pEntity->addr.inet.sin_port = htons ((short)atoi (profilePtr));
         }
      }
   break;

   // "version" was set to 0 above
   // if _V2, it will be incremented twice
   // if _V1, it will be incremented only once
   case SNMPAPI_UNTRANSLATED_V2:
   pEntity->version++;
   case SNMPAPI_UNTRANSLATED_V1:
   pEntity->version++;
   tstStr = entityString;           // Save real address string
   break;

   default:
   snmpFreeTableEntry(&EntsDescr, nEntity);
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_PRECHECK;
   } // end_switch
CopyMemory (pEntity->name, entityString, strLen);
if (strncmp(tstStr, "255.255.255.255", 15) && inet_addr (tstStr) == INADDR_NONE)
   { // Not AF_INET, try AF_IPX
   if (SnmpStrToIpxAddress (tstStr,
                            pEntity->addr.ipx.sa_netnum,
                            pEntity->addr.ipx.sa_nodenum) == SNMPAPI_FAILURE)
      {
      LeaveCriticalSection (&cs_ENTITY);
      return ((HSNMP_ENTITY) ULongToPtr(SaveError (hSession, SNMPAPI_ENTITY_UNKNOWN)));
      }
   pEntity->addr.ipx.sa_family = AF_IPX;
   if (pEntity->addr.ipx.sa_socket == 0)
      pEntity->addr.ipx.sa_socket = htons (IPX_SNMP_PORT);
   }
else
   { // AF_INET
   pEntity->addr.inet.sin_family = AF_INET;
   if (pEntity->addr.inet.sin_port == 0)
      pEntity->addr.inet.sin_port = htons (IP_SNMP_PORT);
   pEntity->addr.inet.sin_addr.s_addr = inet_addr (tstStr);
   }
// Record the creating session
pEntity->Session = hSession;
// Initialize refCount for SnmpFreeEntity garbage collection
pEntity->refCount = 1;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_ENTITY);
ERROR_OUT:
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_ENTITY) ULongToPtr(nEntity+1));
else // Failure cases
   return ((HSNMP_ENTITY) ULongToPtr(SaveError (lSession, lError)));
} //end_SnmpStrToEntity

// SnmpEntityToStr
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpEntityToStr (IN HSNMP_ENTITY hEntity,
                    IN smiUINT32 size,
                    OUT LPSTR string)
{
DWORD nEntity = HandleToUlong(hEntity) - 1;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPSTR str;
smiUINT32 len;
char tmpStr[24];
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_UNKNOWN;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
lSession = pEntity->Session;
if (size == 0)
   {
   lError = SNMPAPI_SIZE_INVALID;
   goto ERROR_OUT;
   }
if (IsBadWritePtr(string, size))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
len = 0;
if (TaskData.nTranslateMode == SNMPAPI_TRANSLATED)
   {
   str = pEntity->name;
   len = lstrlen (str);
   }
else
   {
   if (pEntity->addr.inet.sin_family == AF_INET)
      {
      // prefix bug 445174 
      if ((str = inet_ntoa (pEntity->addr.inet.sin_addr)) != NULL)
         len = lstrlen (str);
      else
         {
         lError = SNMPAPI_OTHER_ERROR; // error in inet_ntoa call
         goto ERROR_OUT;
         }
      }
   else if (pEntity->addr.ipx.sa_family == AF_IPX)
      {
      SnmpIpxAddressToStr (pEntity->addr.ipx.sa_netnum,
                           pEntity->addr.ipx.sa_nodenum,
                           tmpStr);
      str = tmpStr;
      len = lstrlen (str);
      }
   else
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   }
if (len >= size)
   {
   CopyMemory (string, str, size);
   string[size-1] = '\0';
   lError = SNMPAPI_OUTPUT_TRUNCATED;
   goto ERROR_OUT;
   }
else
   {
   lstrcpy (string, str);
   return (len+1);
   }
// Failure cases
ERROR_OUT:
return (SaveError (lSession, lError));
} // End_SnmpEntityToStr

// SnmpFreeEntity
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeEntity (IN HSNMP_ENTITY hEntity)
{
DWORD nEntity;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
EnterCriticalSection (&cs_ENTITY);
// Decrement refCount (unless already 0 [error])
if (pEntity->refCount)
   pEntity->refCount--;
// Now actually free it...
if (pEntity->Agent == 0 &&     // but not if it's an Agent
    pEntity->refCount == 0)   // nor if other references exist
    snmpFreeTableEntry(&EntsDescr, nEntity);

LeaveCriticalSection (&cs_ENTITY);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}

// SnmpStrToContext
// Allow for zero-length/NULL context...BN 3/12/96
HSNMP_CONTEXT  SNMPAPI_CALL
   SnmpStrToContext (IN HSNMP_SESSION hSession,
                     IN smiLPCOCTETS contextString)
{
DWORD strLen;
DWORD nContext;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
char profileBuf[256];
LPSTR profilePtr;
LPSTR comma = ",";
LPCTXT pCtxt;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // Save for possible error return
if (IsBadReadPtr (contextString, sizeof(smiOCTETS)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

if (IsBadReadPtr (contextString->ptr, contextString->len))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
// Remember to allow for 0-len contexts (as above does)
EnterCriticalSection (&cs_CONTEXT);
// Search for Entity table entry to use
lError = snmpAllocTableEntry(&CntxDescr, &nContext);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pCtxt = snmpGetTableEntry(&CntxDescr, nContext);

pCtxt->version = 0; // just to be sure
pCtxt->name[0] = pCtxt->commStr[0] = '\0';
// Following "if" test allows for zero-length/NULL community string
// (deliberate assignment in conditional...)
if (pCtxt->commLen = contextString->len)
   {
   switch (TaskData.nTranslateMode)
      {
      case SNMPAPI_TRANSLATED:
      if (!GetPrivateProfileString ("Contexts", contextString->ptr, "",
                                    profileBuf, sizeof(profileBuf), "NP_WSNMP.INI"))
         {
         snmpFreeTableEntry(&CntxDescr, nContext);
         lError = SNMPAPI_CONTEXT_UNKNOWN;
         goto ERROR_PRECHECK;
         }
      strLen = min(lstrlen (contextString->ptr), MAX_FRIEND_NAME_LEN);
      CopyMemory (pCtxt->name, contextString->ptr, strLen);

	  // pick up the version# for this context (mandatory)
      profilePtr = strtok (profileBuf, comma);
	  // if there is no such version# is like we have a INI key without its value,
	  // so bail out with SNMPAPI_NOOP
	  if (profilePtr == NULL)
	  {
          snmpFreeTableEntry(&CntxDescr, nContext);
		  lError = SNMPAPI_NOOP;
		  goto ERROR_PRECHECK;
	  }
      pCtxt->version = (DWORD) atoi (profilePtr);

	  // pick up the actual context value (mandatory)
      profilePtr = strtok (NULL, comma);
	  // if there is no such value, is like we have the friendly name but this is malformed
	  // and doesn't point to any actual context.
	  // bail out with SNMPAPI_NOOP
	  if (profilePtr == NULL)
	  {
          snmpFreeTableEntry(&CntxDescr, nContext);
		  lError = SNMPAPI_NOOP;
		  goto ERROR_PRECHECK;
	  }
      strLen = min(lstrlen (profilePtr), MAX_CONTEXT_LEN);
      pCtxt->commLen = strLen;
      CopyMemory (pCtxt->commStr, profilePtr, strLen);
      break;

      // "version" was set to 0 above
      // if _V2, it will be incremented twice
      // if _V1, it will be incremented only once
      case SNMPAPI_UNTRANSLATED_V2:
      pCtxt->version++;
      case SNMPAPI_UNTRANSLATED_V1:
      pCtxt->version++;
      strLen = min(contextString->len, MAX_CONTEXT_LEN);
      CopyMemory (pCtxt->commStr, contextString->ptr, strLen);
      break;

      default:
      snmpFreeTableEntry(&CntxDescr, nContext);
      lError = SNMPAPI_MODE_INVALID;
      goto ERROR_PRECHECK;
      } // end_switch
   // Remember that NULL community strings are allowed!
   } // end_if (on len)
// Record the creating session value
pCtxt->Session = hSession;
// Initialize refCount for SnmpFreeContext garbage collection
pCtxt->refCount = 1;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_CONTEXT);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_CONTEXT) ULongToPtr(nContext+1));
ERROR_OUT:
return ((HSNMP_CONTEXT) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpStrToContext

// SnmpContextToStr
// Revised to allow for zero-length/NULL context...BN 3/12/96
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpContextToStr (IN HSNMP_CONTEXT hContext,
                     OUT smiLPOCTETS string)
{
smiUINT32 len;
smiLPBYTE str;
DWORD nCtx;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPCTXT pCtxt;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nCtx = HandleToUlong(hContext) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

// save session for possible error return
lSession = pCtxt->Session;
if (IsBadWritePtr(string, sizeof(smiLPOCTETS)))
   {
   lError = string == NULL ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
switch (TaskData.nTranslateMode)
   {
   case SNMPAPI_TRANSLATED:
   str = pCtxt->name;
   len = lstrlen (str);
// If calling mode is TRANSLATED, and friendly value was stored,
   if (len)
// then we are done here.
      break;
// If calling mode is TRANSLATED, but no value stored,
// then fall through to UNTRANSLATED default...
   case SNMPAPI_UNTRANSLATED_V1:
   case SNMPAPI_UNTRANSLATED_V2:
   str = pCtxt->commStr;
   len = pCtxt->commLen;
   break;

   default:
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
// Setup for possible zero-length/NULL context return
string->ptr = NULL;
// (deliberate assignment in conditional...)
if (string->len = len)
   {
   // App must free following alloc via SnmpFreeDescriptor()
   if (!(string->ptr = (smiLPBYTE)GlobalAlloc (GPTR, len)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   CopyMemory (string->ptr, str, len);
   }
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpContextToStr()

// SnmpFreeContext
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeContext (IN HSNMP_CONTEXT hContext)
{
DWORD nCtx;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPCTXT pCtxt;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nCtx = HandleToUlong(hContext) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

EnterCriticalSection (&cs_CONTEXT);
// Decrement refCount (unless already 0 [error])
if (pCtxt->refCount)
   pCtxt->refCount--;
// Now test refCount again
if (pCtxt->refCount == 0)
   snmpFreeTableEntry(&CntxDescr, nCtx);

LeaveCriticalSection (&cs_CONTEXT);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}

// SnmpSetPort
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetPort (IN HSNMP_ENTITY hEntity,
                IN UINT port)
{
DWORD nEntity;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
EnterCriticalSection (&cs_ENTITY);
if (pEntity->Agent)
   { // Entity running as agent, cannot change port now
   lError = SNMPAPI_OPERATION_INVALID;
   goto ERROR_PRECHECK;
   }
pEntity->addr.inet.sin_port = htons ((WORD)port);
ERROR_PRECHECK:
LeaveCriticalSection (&cs_ENTITY);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetPort()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_ma.c ===
// wsnmp_ma.c
//
// WinSNMP Initialization Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 970310 - Free table memory on PROCESS_DETACH
//        - Refine snmpAllocTable() code
// 970417 - GetVersionEx added to check for
//        - NT vs 95 and adjust code accordingly
//
#include "winsnmp.h"
#include "winsnmpn.h"
// Memory descriptors
SNMPTD   SessDescr;
SNMPTD   PDUsDescr;
SNMPTD   VBLsDescr;
SNMPTD   EntsDescr;
SNMPTD   CntxDescr;
SNMPTD   MsgDescr;
SNMPTD   TrapDescr;
SNMPTD   AgentDescr;

TASK     TaskData;

CRITICAL_SECTION cs_TASK;
CRITICAL_SECTION cs_SESSION;
CRITICAL_SECTION cs_PDU;
CRITICAL_SECTION cs_VBL;
CRITICAL_SECTION cs_ENTITY;
CRITICAL_SECTION cs_CONTEXT;
CRITICAL_SECTION cs_MSG;
CRITICAL_SECTION cs_TRAP;
CRITICAL_SECTION cs_AGENT;
CRITICAL_SECTION cs_XMODE;

//-----------------------------------------------------------------
// snmpAllocTable - This function is used to initialize and to increase
// the size of WinSNMP internal tables. The caller must always ensure
// that this function is executed only within a critical section block
// on the target table's CRITICAL_SECTION object.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpAllocTable (LPSNMPTD pTableDescr)

{
    LPVOID ptr;
    DWORD nLen;
    SNMPAPI_STATUS lResult = SNMPAPI_FAILURE;

    LPSNMPBD pBufDescr;

    // allocate a buffer large enough for the SNMPBD header plus the space
    // needed to hold 'BlockToAdd' blocks of size 'BlockSize' each.
    // the memory is already zero-ed because of the GPTR flag.
    pBufDescr = GlobalAlloc(GPTR, sizeof(SNMPBD) + (pTableDescr->BlockSize * pTableDescr->BlocksToAdd));
    if (pBufDescr == NULL)
        return SNMPAPI_FAILURE;

    // see if other buffers are present in the table
    if (pTableDescr->Allocated == 0)
    {
        // no blocks previously allocated => pTableDescr->Buffer = NULL at this point
        // pNewBufDescr is the first buffer in the table.
        pBufDescr->next = pBufDescr->prev = pBufDescr;
        pTableDescr->HeadBuffer = pBufDescr;
    }
    else
    {
        // there is at least one other block into the table, so insert the
        // new buffer into the circular list, just before the head of the list
        pBufDescr->next = pTableDescr->HeadBuffer;
        pBufDescr->prev = pTableDescr->HeadBuffer->prev;
        pBufDescr->next->prev = pBufDescr;
        pBufDescr->prev->next = pBufDescr;
    }

    // increase 'Allocated' with the additional 'BlocksToAdd' newly allocated entries.
    pTableDescr->Allocated += pTableDescr->BlocksToAdd;
    
    return SNMPAPI_SUCCESS;
}

//-----------------------------------------------------------------
// snmpInitTableDescr - initializes the table descriptor with the 
// parameters given as arguments. Creates a first chunck of table.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpInitTableDescr(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwBlocksToAdd, /*in*/DWORD dwBlockSize)
{
	ZeroMemory (pTableDescr, sizeof(SNMPTD));
	pTableDescr->BlocksToAdd = dwBlocksToAdd;
	pTableDescr->BlockSize = dwBlockSize;

	return snmpAllocTable (pTableDescr);
}

//-----------------------------------------------------------------
// snmpFreeTableDescr - releases any memory allocated for the table.
//-----------------------------------------------------------------
VOID snmpFreeTableDescr(/*in*/LPSNMPTD pTableDescr)
{
    // do nothing if the table does not contain any entries
	if (pTableDescr->HeadBuffer == NULL)
        return;

    // break the circular list by setting the 'next' of
    // the buffer before the head to NULL
    pTableDescr->HeadBuffer->prev->next = NULL;

    while (pTableDescr->HeadBuffer != NULL)
    {
        LPSNMPBD pBufDescr;

        pBufDescr = pTableDescr->HeadBuffer;
        pTableDescr->HeadBuffer = pBufDescr->next;
        GlobalFree(pBufDescr);
    }
}

//-----------------------------------------------------------------
// snmpAllocTableEntry - finds an empty slot in the table described
// by pTableDescr, and returns its index. If none could be 
// found, table is extended in order to get some new empty slots.
// It is not an API call so it doesn't check its parameters.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpAllocTableEntry(/*in*/LPSNMPTD pTableDescr, /*out*/LPDWORD pdwIndex)
{
     // check if there are any empty entries into the table ..
    if (pTableDescr->Allocated == pTableDescr->Used)
    {
        // .. if not, enlarge the table ..
        if (!snmpAllocTable (pTableDescr))
            return SNMPAPI_ALLOC_ERROR;
        // .. and return the first empty slot
        *pdwIndex = pTableDescr->Used;

        // don't forget to update the 'Used' fields. The first one markes a new entry in use
        // in the buffer, the second one marks a new entry in use in the table as a whole
        (pTableDescr->HeadBuffer->prev->Used)++;
        pTableDescr->Used++;
    }
    else
    {
        DWORD dwBufferIndex, dwInBufferIndex;
        LPSNMPBD pBufDescr;
        LPBYTE pTblEntry; // cursor on the entries in the table

        // scan the list of buffers searching for the buffer that
        // holds at least one available entry.
        for (pBufDescr = pTableDescr->HeadBuffer, dwBufferIndex=0;
             pBufDescr->Used >= pTableDescr->BlocksToAdd;
             pBufDescr = pBufDescr->next, dwBufferIndex++)
        {
             // just a precaution: make sure we are not looping infinitely here
             // this shouldn't happen as far as 'Allocated' and 'Used' say there
             // are available entries, hence at least a buffer should match
             if (pBufDescr->next == pTableDescr->HeadBuffer)
                 return SNMPAPI_OTHER_ERROR;
        }

        // now that we have the buffer with available entries,
        // search in it for the first one available.
        for ( pTblEntry = (LPBYTE)pBufDescr + sizeof(SNMPBD), dwInBufferIndex = 0;
              dwInBufferIndex < pTableDescr->BlocksToAdd;
              dwInBufferIndex++, pTblEntry += pTableDescr->BlockSize)
        {
              // an empty slot into the table has the first field = (HSNMP_SESSION)0
              if (*(HSNMP_SESSION *)pTblEntry == 0)
                  break;
        }

        // make sure the buffer is not corrupted (it is so if 'Used' shows at
        // least an entry being available, but none seems to be so)
        if (dwInBufferIndex == pTableDescr->BlocksToAdd)
            return SNMPAPI_OTHER_ERROR;

        // don't forget to update the 'Used' fields. The first one markes a new entry in use
        // in the buffer, the second one marks a new entry in use in the table as a whole
        pBufDescr->Used++;
        pTableDescr->Used++;

        // we have the index of the buffer that contains the available entry
        // and the index of that entry inside the buffer. So just compute
        // the overall index and get out.
        (*pdwIndex) = dwBufferIndex * pTableDescr->BlocksToAdd + dwInBufferIndex;
    }

    return SNMPAPI_SUCCESS;
}

//-----------------------------------------------------------------
// snmpFreeTableEntry - releases the entry at index dwIndex from the
// table described by pTableDescr. It checks the validity of the index
// and returns SNMPAPI_INDEX_INVALID if it is not in the range of the
// allocated entries. It does not actually frees the memory, it cleares
// it up and adjusts internal counters.
//-----------------------------------------------------------------
SNMPAPI_STATUS snmpFreeTableEntry(/*in*/LPSNMPTD pTableDescr, /*out*/DWORD dwIndex)
{
    LPSNMPBD pBufDescr;
    LPBYTE pTableEntry;

    if (dwIndex >= pTableDescr->Allocated)
        return SNMPAPI_INDEX_INVALID;

    // scan for the buffer that holds the entry at index dwIndex
    for (pBufDescr = pTableDescr->HeadBuffer;
         dwIndex >= pTableDescr->BlocksToAdd;
         pBufDescr = pBufDescr->next, dwIndex -= pTableDescr->BlocksToAdd);

    // we have the buffer, get the actual pointer to the entry
    pTableEntry = (LPBYTE)pBufDescr + sizeof(SNMPBD);
    pTableEntry += dwIndex * pTableDescr->BlockSize;

    // zero the entry - having the first HSNMP_SESSION field set to 0
    // makes this entry available for further allocations
    ZeroMemory (pTableEntry, pTableDescr->BlockSize);

    // update the 'Used' fields to show that one entry less is in use
    if (pBufDescr->Used > 0)
        (pBufDescr->Used)--;
    if (pTableDescr->Used > 0)
        (pTableDescr->Used)--;

    return SNMPAPI_SUCCESS;
}

//-----------------------------------------------------------------
// snmpGetTableEntry - takes as arguments a table description (pTableDescr)
// and the zero based index (dwIndex) of the entry requested from the table
// and returns in pointer to the entry requested.
//-----------------------------------------------------------------
PVOID snmpGetTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex)
{
    LPSNMPBD pBufDescr;
    LPBYTE pTableEntry;

    // this is an internal API, we make the assumption the index is correct
    // scan for the buffer that holds the entry at index dwIndex
    for (pBufDescr = pTableDescr->HeadBuffer;
         dwIndex >= pTableDescr->BlocksToAdd;
         pBufDescr = pBufDescr->next, dwIndex -= pTableDescr->BlocksToAdd);

    // we have the buffer, get the actual pointer to the entry
    pTableEntry = (LPBYTE)pBufDescr + sizeof(SNMPBD);
    pTableEntry += dwIndex * pTableDescr->BlockSize;

    // this is it, pTableEntry can be returned to the caller
    return pTableEntry;
}

//-----------------------------------------------------------------
// snmpValidTableEntry - returns TRUE or FALSE as the entry at zero
// based index dwIndex from the table described by pTableDescr has
// valid data (is allocated) or not
//-----------------------------------------------------------------
BOOL snmpValidTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex)
{
    return (dwIndex < pTableDescr->Allocated) &&
           (*(HSNMP_SESSION *)snmpGetTableEntry(pTableDescr, dwIndex) != 0);
}

// Save error value as session/task/global error and return 0
SNMPAPI_STATUS SaveError(HSNMP_SESSION hSession, SNMPAPI_STATUS nError)
{
	TaskData.nLastError = nError;
	if (hSession)
	{
		LPSESSION pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(hSession)-1);
		pSession->nLastError = nError;
	}
	return (SNMPAPI_FAILURE);
}

SNMPAPI_STATUS CheckRange (DWORD index, LPSNMPTD block)
{
if ((!index) || (index > block->Allocated))
   return (SNMPAPI_FAILURE);
else
   return (SNMPAPI_SUCCESS);
}

int snmpInit (void)
{
// Initialize Tables
if (snmpInitTableDescr(&SessDescr,  DEFSESSIONS, sizeof(SESSION)) != SNMPAPI_SUCCESS ||
	snmpInitTableDescr(&PDUsDescr,  DEFPDUS, sizeof(PDUS)) != SNMPAPI_SUCCESS        ||
	snmpInitTableDescr(&VBLsDescr,  DEFVBLS, sizeof(VBLS)) != SNMPAPI_SUCCESS        ||
    snmpInitTableDescr(&EntsDescr,  DEFENTITIES, sizeof(ENTITY)) != SNMPAPI_SUCCESS  ||
    snmpInitTableDescr(&CntxDescr,  DEFCONTEXTS, sizeof(CTXT)) != SNMPAPI_SUCCESS    ||
    snmpInitTableDescr(&MsgDescr,   DEFMSGS, sizeof(SNMPMSG)) != SNMPAPI_SUCCESS     ||
    snmpInitTableDescr(&TrapDescr,  DEFTRAPS, sizeof(TRAPNOTICE)) != SNMPAPI_SUCCESS  ||
    snmpInitTableDescr(&AgentDescr, DEFAGENTS, sizeof(AGENT)) != SNMPAPI_SUCCESS)
    return (SNMPAPI_FAILURE);
//
return (SNMPAPI_SUCCESS);
} // end_snmpInit()

void snmpFree (void)
{
snmpFreeTableDescr(&SessDescr);
snmpFreeTableDescr(&PDUsDescr);
snmpFreeTableDescr(&VBLsDescr);
snmpFreeTableDescr(&EntsDescr);
snmpFreeTableDescr(&CntxDescr);
snmpFreeTableDescr(&MsgDescr);
snmpFreeTableDescr(&TrapDescr);
snmpFreeTableDescr(&AgentDescr);
} // end_snmpFree()

BOOL WINAPI DllMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    BOOL errCode = FALSE;
    LPCRITICAL_SECTION pCSArray[10]; // ten critical sections to initialize (cs_TASK..cs_XMODE)
    INT nCS;                         // counter in pCSArray

    pCSArray[0] = &cs_TASK;
    pCSArray[1] = &cs_SESSION;
    pCSArray[2] = &cs_PDU;
    pCSArray[3] = &cs_VBL;
    pCSArray[4] = &cs_ENTITY;
    pCSArray[5] = &cs_CONTEXT;
    pCSArray[6] = &cs_MSG;
    pCSArray[7] = &cs_TRAP;
    pCSArray[8] = &cs_AGENT;
    pCSArray[9] = &cs_XMODE;

    switch (dwReason)
    {
       case DLL_PROCESS_ATTACH:
           // Init task-specific data area
           ZeroMemory (&TaskData, sizeof(TASK));
           // Build tables
           __try
           {
               for (nCS = 0; nCS < 10; nCS++)
                    InitializeCriticalSection (pCSArray[nCS]);
           }
           __except(EXCEPTION_EXECUTE_HANDLER)
           {
               // if an exception was raised, rollback the successfully initialized CS
               while (nCS > 0)
                   DeleteCriticalSection(pCSArray[--nCS]);
               break;
           }

           if (snmpInit() == SNMPAPI_SUCCESS)
               errCode = TRUE;
           break;

       case DLL_THREAD_ATTACH:
           // A new thread is being created in the current process.
           break;

       case DLL_THREAD_DETACH:
           // A thread is exiting cleanly.
           break;

       case DLL_PROCESS_DETACH:
           // The calling process is detaching the DLL from its address space.
           for (nCS = 0; nCS < 10; nCS++)
               DeleteCriticalSection(pCSArray[nCS]);

           snmpFree();
           errCode = TRUE;
           break;

       default:
           break;
    }
    return (errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_db.c ===
// wsnmp_db.c
//
// WinSNMP Local Database Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
#include "winsnmp.inc"

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetVendorInfo (OUT smiLPVENDORINFO vendorInfo)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (vendorInfo == NULL)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
if (IsBadWritePtr(vendorInfo, sizeof(smiVENDORINFO)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Max len = 64
lstrcpy (&vendorInfo->vendorName[0], "Microsoft Corporation");
lstrcpy (&vendorInfo->vendorContact[0], "snmpinfo@microsoft.com");
// Max len = 32
lstrcpy (&vendorInfo->vendorVersionId[0], "v2.32.19980808");
lstrcpy (&vendorInfo->vendorVersionDate[0], "August 8, 1998");
vendorInfo->vendorEnterprise = 311;
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetVendorInfo()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetTranslateMode (OUT smiLPUINT32 nTranslateMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// Must have some place to write answer to...
if (IsBadWritePtr (nTranslateMode, sizeof(smiUINT32)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Ok to write value
*nTranslateMode = TaskData.nTranslateMode;
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetTranslateMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetTranslateMode (IN smiUINT32 nTranslateMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
switch (nTranslateMode)
   {
   case SNMPAPI_TRANSLATED:
   case SNMPAPI_UNTRANSLATED_V1:
   case SNMPAPI_UNTRANSLATED_V2:
   EnterCriticalSection (&cs_TASK);
   TaskData.nTranslateMode = nTranslateMode;
   LeaveCriticalSection (&cs_TASK);
   break;

   default:
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetTranslateMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetRetransmitMode (OUT smiLPUINT32 nRetransmitMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// Must have some place to write answer to...
if (IsBadWritePtr (nRetransmitMode, sizeof(smiUINT32)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Ok to write value
*nRetransmitMode = TaskData.nRetransmitMode;
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetRetransmitMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetRetransmitMode (IN smiUINT32 nRetransmitMode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (nRetransmitMode != SNMPAPI_OFF && nRetransmitMode != SNMPAPI_ON)
   {
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_TASK);
TaskData.nRetransmitMode = nRetransmitMode;
LeaveCriticalSection (&cs_TASK);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetRetransmitMode()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetTimeout (IN  HSNMP_ENTITY hEntity,
                   OUT smiLPTIMETICKS nPolicyTimeout,
                   OUT smiLPTIMETICKS nActualTimeout)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);

if (!nPolicyTimeout && !nActualTimeout)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
// Intervals are specified and stored as centiseconds
if (nPolicyTimeout)
   {
   if (IsBadWritePtr (nPolicyTimeout, sizeof(smiTIMETICKS)))
      {
      lError  = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nPolicyTimeout = pEntity->nPolicyTimeout;
   }
if (nActualTimeout)
   {
   if (IsBadWritePtr (nActualTimeout, sizeof(smiTIMETICKS)))
      {
      lError  = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nActualTimeout = pEntity->nActualTimeout;
   }
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetTimeout()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetTimeout (IN HSNMP_ENTITY hEntity,
                   IN smiTIMETICKS nPolicyTimeout)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
EnterCriticalSection (&cs_ENTITY);
// Timeout interval is specified and stored in centiseconds
pEntity->nPolicyTimeout = nPolicyTimeout;
LeaveCriticalSection (&cs_ENTITY);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetTimeout()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetRetry (IN HSNMP_ENTITY hEntity,
                 OUT smiLPUINT32 nPolicyRetry,
                 OUT smiLPUINT32 nActualRetry)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
if (!nPolicyRetry && !nActualRetry)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
if (nPolicyRetry)
   {
   if (IsBadWritePtr (nPolicyRetry, sizeof(smiUINT32)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nPolicyRetry = pEntity->nPolicyRetry;
   }
if (nActualRetry)
   {
   if (IsBadWritePtr (nActualRetry, sizeof(smiUINT32)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   *nActualRetry = pEntity->nActualRetry;
   }
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpGetRetry()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetRetry (IN HSNMP_ENTITY hEntity,
                 IN smiUINT32 nPolicyRetry)
{
DWORD nEntity;
SNMPAPI_STATUS lError;
LPENTITY pEntity;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nEntity = HandleToUlong(hEntity) - 1;
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);

EnterCriticalSection (&cs_ENTITY);
pEntity->nPolicyRetry = nPolicyRetry;
LeaveCriticalSection (&cs_ENTITY);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpSetRetry()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_cf.c ===
// wsnmp_cf.c
//
// WinSNMP Communications Functions and helpers
// Copyright 1995-1998 ACE*COMM Corp
// Rleased to Microsoft under Contract
//
// Bob Natale (bnatale@acecomm.com)
//
// 19980625 - Modified SnmpStartup() to allow for NULL
//            output args and to check for IsBadWritePtr()
//            when non-NULL
//
#include "winsnmp.inc"

#define SNMP_MAJOR_VERSION 2
#define SNMP_MINOR_VERSION 0
#define SNMP_SUPPORT_LEVEL SNMPAPI_V2_SUPPORT

#ifdef SOLARIS
BOOL DllMain (HINSTANCE, DWORD, LPVOID);
#endif // SOLARIS

LPPDUS MapV2TrapV1 (HSNMP_PDU hPdu);
THR_TYPE WINAPI thrManager (LPVOID);
THR_TYPE WINAPI thrTrap (LPVOID);
THR_TYPE WINAPI thrTimer (LPVOID);
THR_TYPE WINAPI thrAgent (LPVOID);
THR_TYPE WINAPI thrNotify (LPVOID);

void FreeRegister (DWORD nTrap)
{
LPTRAPNOTICE pTrap;
EnterCriticalSection (&cs_TRAP);
pTrap = snmpGetTableEntry(&TrapDescr, nTrap);
if (pTrap->ourEntity)
   SnmpFreeEntity (pTrap->ourEntity);
if (pTrap->agentEntity)
   SnmpFreeEntity (pTrap->agentEntity);
if (pTrap->Context)
   SnmpFreeContext (pTrap->Context);
snmpFreeTableEntry(&TrapDescr, nTrap);
LeaveCriticalSection (&cs_TRAP);
return;
} // end_FreeRegister

// Exported Functions
// SnmpStartup
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpStartup (OUT smiLPUINT32 nMajorVersion,
                OUT smiLPUINT32 nMinorVersion,
                OUT smiLPUINT32 nLevel,
                OUT smiLPUINT32 nTranslateMode,
                OUT smiLPUINT32 nRetransmitMode)
{
WSADATA wsaData;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION hTask = (HSNMP_SESSION) ULongToPtr(GetCurrentProcessId());
//
#ifdef SOLARIS
if (TaskData.hTask != hTask)
   DllMain (NULL, DLL_PROCESS_ATTACH, NULL);
#endif
//
if (nMajorVersion)
   {
   if (IsBadWritePtr (nMajorVersion, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nMajorVersion = SNMP_MAJOR_VERSION;
   }
if (nMinorVersion)
   {
   if (IsBadWritePtr (nMinorVersion, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nMinorVersion = SNMP_MINOR_VERSION;
   }
if (nLevel)
   {
   if (IsBadWritePtr (nLevel, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nLevel = SNMP_SUPPORT_LEVEL;
   }
if (nTranslateMode)
   {
   if (IsBadWritePtr (nTranslateMode, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nTranslateMode  = SNMPAPI_UNTRANSLATED_V1;
   }
if (nRetransmitMode)
   {
   if (IsBadWritePtr (nRetransmitMode, sizeof(smiUINT32)))
      goto ARG_ERROR;
   *nRetransmitMode = SNMPAPI_ON;
   }
goto ARGS_OK;
ARG_ERROR:
lError = SNMPAPI_ALLOC_ERROR;
goto ERROR_OUT;
ARGS_OK:
EnterCriticalSection (&cs_TASK);
TaskData.nRetransmitMode = SNMPAPI_ON;
TaskData.nTranslateMode  = SNMPAPI_UNTRANSLATED_V1;
// we need to turn this on in order to have WINSNMP to pass back not
// only the entity standing for the source Ip address but also the
// agent address as it was sent into the V1 Trap Pdu.
TaskData.conveyAddress = SNMPAPI_ON;
// SnmpStartup is idempotent...
if (TaskData.hTask == hTask)
   goto DONE;  // ...already called
// New task starting up...get OS info
TaskData.sEnv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
GetVersionEx (&TaskData.sEnv);
// Start WinSock connection...should return 0
if (WSAStartup ((WORD)0x0101, &wsaData))
   {
   lError = SNMPAPI_TL_NOT_INITIALIZED;
   goto ERROR_PRECHECK;
   }
// Set trapPipe (used in NT case only)
TaskData.trapPipe = INVALID_HANDLE_VALUE;
// bug# 270672
// create non-signaled event to synchronize shutdown of thrTrap
TaskData.trapEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
if (NULL == TaskData.trapEvent)
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_PRECHECK;
   }
// init the trapOl overlapped struct with manual reset non-signaled event   
ZeroMemory(&TaskData.trapOl, sizeof(TaskData.trapOl));
TaskData.trapOl.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
if (NULL == TaskData.trapOl.hEvent)    
   {
   lError = SNMPAPI_ALLOC_ERROR;
   CloseHandle(TaskData.trapEvent);
   TaskData.trapEvent = NULL;
   goto ERROR_PRECHECK;
   }

// Set trapSock (used in Win95 case only)
TaskData.trapSock = INVALID_SOCKET;
// Set "manager" sockets (used at SnmpSendMsg() time)
TaskData.ipSock = TaskData.ipxSock = INVALID_SOCKET;
// Start timer thread
#ifdef SOLARIS
thr_create (NULL, 0, thrTimer, NULL, THR_FLAGS, &TaskData.timerThread);
#else
{
DWORD thrId;
TaskData.timerThread = (HANDLE)_beginthreadex (NULL, 0, thrTimer, NULL, 0, &thrId);
}
#endif // SOLARIS
//
DONE:
TaskData.hTask = hTask;
TaskData.nLastError = SNMPAPI_SUCCESS;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_TASK);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpStartup

// SnmpCleanup
SNMPAPI_STATUS SNMPAPI_CALL SnmpCleanup (void)
{
DWORD nSession;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
// Variables for threads not associated with a specific session
DWORD nHandles = 0;
HANDLE hTemp[4] = {NULL, NULL, NULL, NULL};
CONST HANDLE *hObjects = &hTemp[0];
//--------------------------------------------------------------
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_SESSION);
// Do all Forgotten Closes
if (SessDescr.Used)
   {
   for (nSession = 0; nSession < SessDescr.Allocated; nSession++)
      if (((LPSESSION)snmpGetTableEntry(&SessDescr, nSession))->nTask)
         SnmpClose ((HSNMP_SESSION) ULongToPtr(nSession + 1));
   }
LeaveCriticalSection (&cs_SESSION);
EnterCriticalSection (&cs_TASK);
// Terminate thrTimer
if (TaskData.timerThread)
   {
   hTemp[nHandles++] = TaskData.timerThread;
   // NULL signals the timer thread to terminate itself
   TaskData.timerThread = NULL;
   }
// Close "Mgr" sockets and threads
if (TaskData.ipSock != INVALID_SOCKET)
   {// UDP channel
   // check thrManager code to understand the lines below:
   SOCKET ipSock = TaskData.ipSock;
   TaskData.ipSock = INVALID_SOCKET;
   closesocket (ipSock);
   if (TaskData.ipThread)
      hTemp[nHandles++] = TaskData.ipThread;
   }
if (TaskData.ipxSock != INVALID_SOCKET)
   {// IPX channel
   // check thrManager code to understand the lines below:
   SOCKET ipxSock = TaskData.ipxSock;
   TaskData.ipxSock = INVALID_SOCKET;
   closesocket (ipxSock);
   if (TaskData.ipxThread)
      hTemp[nHandles++] = TaskData.ipxThread;
   }
// Terminate thrTrap
if (TaskData.trapThread)
   {
   if (TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_NT)
      { // NT-specific stuff
      // set events to signal thrTrap to exit
      SetEvent(TaskData.trapEvent);
      // unblock thrTrap if necessary
      SetEvent(TaskData.trapOl.hEvent); 
      }
   if (TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
      { // Win95-specific stuff
      if (IsWindow (TaskData.trapWnd))
         PostMessage (TaskData.trapWnd, WSNMP_TRAPS_OFF, (DWORD_PTR)TaskData.hTask, 0L);
      if (TaskData.trapSock != INVALID_SOCKET)
         closesocket (TaskData.trapSock);
      }
   hTemp[nHandles++] = TaskData.trapThread;
   }
WaitForMultipleObjects (nHandles, hObjects, TRUE, 5000);
while (nHandles > 0)
   {
   nHandles--;
   CloseHandle (hTemp[nHandles]);
   }
if (TaskData.trapPipe != INVALID_HANDLE_VALUE)
   CloseHandle (TaskData.trapPipe);
if (TaskData.trapEvent != NULL)
   CloseHandle(TaskData.trapEvent);
if (TaskData.trapOl.hEvent != NULL)
   CloseHandle(TaskData.trapOl.hEvent);
   
// Do the main thing
ZeroMemory (&TaskData, sizeof(TASK));
LeaveCriticalSection (&cs_TASK);
// Close down WinSock connection
WSACleanup ();
//
#ifdef SOLARIS
DllMain (NULL, DLL_PROCESS_DETACH, NULL);
#endif // SOLARIS
//
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpCleanup

// Open a session (v1 and v2)
HSNMP_SESSION SNMPAPI_CALL SnmpOpen (IN HWND hWnd, IN UINT wMsg)
{
return (SnmpCreateSession (hWnd, wMsg, NULL, NULL));
} // end_SnmpOpen

// Open a session, w/callback option (v2)
HSNMP_SESSION SNMPAPI_CALL
   SnmpCreateSession (IN HWND hWnd, IN UINT wMsg,
                      IN SNMPAPI_CALLBACK fCallBack,
                      IN LPVOID lpClientData)
{
DWORD nSession;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPSESSION pSession;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// Check for window/message notification mode argument validity
if (fCallBack == NULL)
   if (!IsWindow(hWnd))
      {
      lError = SNMPAPI_HWND_INVALID;
      goto ERROR_OUT;
      }
//
EnterCriticalSection (&cs_SESSION);
lError = snmpAllocTableEntry(&SessDescr, &nSession);
if (lError != SNMPAPI_SUCCESS)
	goto ERROR_PRECHECK;
pSession = snmpGetTableEntry(&SessDescr, nSession);

pSession->nTask        = TaskData.hTask;
pSession->hWnd         = hWnd;
pSession->wMsg         = wMsg;
pSession->fCallBack    = fCallBack;
pSession->lpClientData = lpClientData;
if (fCallBack)
   {
   DWORD thrId;
   pSession->thrEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
   pSession->thrCount = 0;
   pSession->thrHandle = (HANDLE)_beginthreadex
      (NULL, 0, thrNotify, (LPVOID) ULongToPtr(nSession), 0, &thrId);
   }
pSession->nLastError = SNMPAPI_SUCCESS;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_SESSION);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_SESSION) ULongToPtr(nSession+1));
ERROR_OUT:
return ((HSNMP_SESSION) ULongToPtr(SaveError (0, lError)));
} // end_SnmpOpen

// SnmpClose
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpClose (IN HSNMP_SESSION hSession)
{
HANDLE thrTemp;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
DWORD nSes = HandleToUlong(hSession) - 1;
DWORD i;
LPSESSION pSession;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, nSes))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
pSession = snmpGetTableEntry(&SessDescr, nSes);

// Strategy:
// 1st:  Stop notifications to session
// 2nd:  Stop accepting new messages
//       Traps
//       Agents
// 3rd:  Clear out pending messages
// 4th:  Free up all other resources
//
// PART_1:  Stop notifications to the closing Session
// Block window/message notification (in all cases!)
pSession->hWnd = NULL;
// Block callback notification (if required)
if (pSession->fCallBack != NULL)
   {
   // Save thrHandle for WaitForSingleObject call
   EnterCriticalSection (&cs_SESSION);
   thrTemp = pSession->thrHandle;
   // If this is a callback session, must stop thrNotify instance
   pSession->thrHandle = NULL;
   // 0xFFFFFFFF signals thrNotify instance to terminate itself
   pSession->thrCount = 0xFFFFFFFF;
   // SetEvent signals thrNotify instance to run
   SetEvent (pSession->thrEvent);
   LeaveCriticalSection (&cs_SESSION);

   // Wait for termination signal from thread handle
   WaitForSingleObject (thrTemp, 30000);
   // Close thrNotify instance handle
   CloseHandle (thrTemp);
   // Close thrNotify event handle
   CloseHandle (pSession->thrEvent);
   }

// PART_2:  Stop accepting new messages for the closing Session
// Free Notifications registered by the closing Session
EnterCriticalSection (&cs_TRAP);
for (i = 0; i < TrapDescr.Allocated && TrapDescr.Used != 0; i++)
   {
   LPTRAPNOTICE pTrap = snmpGetTableEntry(&TrapDescr, i);
   if (pTrap->Session == hSession)
      FreeRegister (i);
   } // end_for (Traps)
LeaveCriticalSection (&cs_TRAP);
// Free Agents registered by the closing Session
EnterCriticalSection (&cs_AGENT);
for (i = 0; i < AgentDescr.Allocated && AgentDescr.Used != 0; i++)
   {
   LPAGENT pAgent = snmpGetTableEntry(&AgentDescr, i);
   if (pAgent->Session == hSession)
      SnmpListen (pAgent->Entity, SNMPAPI_OFF);
   }
LeaveCriticalSection (&cs_AGENT);
// PART_3:  Free all pending messages for the closing Session
EnterCriticalSection (&cs_MSG);
for (i = 0; i < MsgDescr.Allocated && MsgDescr.Used != 0; i++)
   {
   LPSNMPMSG pMsg = snmpGetTableEntry(&MsgDescr, i);
   if (pMsg->Session == hSession)
      FreeMsg (i);
   }
LeaveCriticalSection (&cs_MSG);
// PART_4:  Free all other resources
// Free Entities allocated by the closing Session
EnterCriticalSection (&cs_ENTITY);
for (i = 0; i < EntsDescr.Allocated && EntsDescr.Used != 0; i++)
   {
   LPENTITY pEntity = snmpGetTableEntry(&EntsDescr, i);
   if (pEntity->Session == hSession)
      SnmpFreeEntity ((HSNMP_ENTITY) ULongToPtr(i+1));
   }
LeaveCriticalSection (&cs_ENTITY);
// Free Contexts allocated by the closing Session
EnterCriticalSection (&cs_CONTEXT);
for (i = 0; i < CntxDescr.Allocated && CntxDescr.Used != 0; i++)
   {
   LPCTXT pCtxt = snmpGetTableEntry(&CntxDescr, i);
   if (pCtxt->Session == hSession)
      SnmpFreeContext ((HSNMP_CONTEXT) ULongToPtr(i+1));
   }
LeaveCriticalSection (&cs_CONTEXT);
// Free VBLs allocated by the closing Session
EnterCriticalSection (&cs_VBL);
for (i = 0; i < VBLsDescr.Allocated && VBLsDescr.Used != 0; i++)
   {
   LPVBLS pVbl = snmpGetTableEntry(&VBLsDescr, i);
   if (pVbl->Session == hSession)
      SnmpFreeVbl ((HSNMP_VBL) ULongToPtr(i+1));
   }
LeaveCriticalSection (&cs_VBL);
// Free PDUs allocated by the closing Session
EnterCriticalSection (&cs_PDU);

for (i = 0; i < PDUsDescr.Allocated && PDUsDescr.Used != 0; i++)
   {
   LPPDUS pPDU = snmpGetTableEntry(&PDUsDescr, i);
   if (pPDU->Session == hSession)
      SnmpFreePdu ((HSNMP_PDU) ULongToPtr(i+1));
   }

LeaveCriticalSection (&cs_PDU);
// Free the Session table entry used by the closing Session
EnterCriticalSection (&cs_SESSION);
snmpFreeTableEntry(&SessDescr, nSes);
LeaveCriticalSection (&cs_SESSION);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
// As of 19980808 there are no error cases with a valid session
return (SaveError (0, lError));
} // end_SnmpClose

// SnmpSendMsg
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSendMsg (IN HSNMP_SESSION hSession,
                IN HSNMP_ENTITY hSrc,
                IN HSNMP_ENTITY hDst,
                IN HSNMP_CONTEXT hCtx,
                IN HSNMP_PDU hPdu)
{
LPPDUS sendPdu;
BOOL fMsg;
DWORD nMsg;
DWORD pduType;
smiINT32 dllReqId;
smiOCTETS tmpContext;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
//
DWORD thrId;
SOCKET *pSock;
int tFamily;
SOCKADDR tAddr;
HANDLE *pThread;
//
DWORD nSrc;
DWORD nDst;
DWORD nCtx;
DWORD nPdu;
//
BOOL  fBroadcast;
//
LPPDUS pPdu;
LPENTITY pEntSrc, pEntDst;
LPCTXT pCtxt;
LPSNMPMSG pMsg;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }

// Save valid session for later error returns
lSession = hSession;
if (hSrc)  // Allowed to be NULL
   {
   nSrc = HandleToUlong(hSrc) - 1;
   if (!snmpValidTableEntry(&EntsDescr, nSrc))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntSrc = snmpGetTableEntry(&EntsDescr, nSrc);
   }
nDst = HandleToUlong(hDst) - 1;
if (!snmpValidTableEntry(&EntsDescr, nDst))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntDst = snmpGetTableEntry(&EntsDescr, nDst);

nCtx = HandleToUlong(hCtx) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

nPdu = HandleToUlong(hPdu) - 1;
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

if (!snmpValidTableEntry(&VBLsDescr, HandleToUlong(pPdu->VBL)-1))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
//--------------
tFamily = pEntDst->addr.inet.sin_family;

// enter the critical section for the TaskData structure to insure
// the atomicity of the Test&Set operation of the TaskData.[ip|ipx]Thread
EnterCriticalSection (&cs_TASK);

pThread = (tFamily==AF_IPX) ? &TaskData.ipxThread : &TaskData.ipThread;
pSock = (tFamily==AF_IPX) ? &TaskData.ipxSock : &TaskData.ipSock;

if (*pThread)   // ASSERT(*pSock != INVALID_SOCKET)
   {
   LeaveCriticalSection(&cs_TASK);
   goto CHANNEL_OPEN;
   }
*pSock = socket (tFamily, SOCK_DGRAM, (tFamily==AF_IPX)?NSPROTO_IPX:0);

if (*pSock == INVALID_SOCKET)
   {
   LeaveCriticalSection(&cs_TASK);
   lError = SNMPAPI_TL_NOT_SUPPORTED;
   goto ERROR_OUT;
   }

// try to set the socket for broadcasts. No matter the result
// a possible error will be caught later
fBroadcast = TRUE;
setsockopt (*pSock,
            SOL_SOCKET,
			SO_BROADCAST,
			(CHAR *) &fBroadcast,
			sizeof ( BOOL )
		   );

// Kludge for Win95 WinSock/IPX bug...have to "bind"
ZeroMemory (&tAddr, sizeof(SOCKADDR));
tAddr.sa_family = (USHORT)tFamily;
bind (*pSock, &tAddr, (tFamily==AF_IPX)?sizeof(SOCKADDR_IPX):sizeof(SOCKADDR_IN));
// Start "listener" and timer threads
#ifdef SOLARIS
thr_create (NULL, 0, thrManager, (LPVOID)tSock, THR_FLAGS, pThread);
#else
*pThread = (HANDLE)_beginthreadex (NULL, 0, thrManager, (LPVOID)pSock, 0, &thrId);
#endif // SOLARIS
if (*pThread == NULL)
   {
   LeaveCriticalSection (&cs_TASK);
   closesocket (*pSock);
   *pSock = INVALID_SOCKET;
   lError = SNMPAPI_TL_RESOURCE_ERROR;
   goto ERROR_OUT;
   }
LeaveCriticalSection (&cs_TASK);
//---------------
CHANNEL_OPEN:
pduType = pPdu->type;
sendPdu = pPdu;
if (pEntDst->version == 1)
	{ // Test for special v2 msg -> v1 dst operations
   if (pduType == SNMP_PDU_TRAP)
      { // RFC 2089 v2 to v1 trap conversion
      sendPdu =  MapV2TrapV1 (hPdu);
      if (sendPdu == NULL)
         {
         lError = SNMPAPI_OTHER_ERROR;
         goto ERROR_OUT;
         }
      pduType = SNMP_PDU_V1TRAP;
      }
   else if (pduType == SNMP_PDU_INFORM)
      {
      lError = SNMPAPI_OPERATION_INVALID;
      goto ERROR_OUT;
      }
   }
// Space check
EnterCriticalSection (&cs_MSG);
lError = snmpAllocTableEntry(&MsgDescr, &nMsg);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pMsg = snmpGetTableEntry(&MsgDescr, nMsg);

// Now Build it
if (pduType == SNMP_PDU_RESPONSE || pduType == SNMP_PDU_TRAP)
   dllReqId = pPdu->appReqId;
else
   dllReqId = ++(TaskData.nLastReqId);
tmpContext.len = pCtxt->commLen;
tmpContext.ptr = pCtxt->commStr;
// Save BuildMessage status for later check
fMsg = BuildMessage (pEntDst->version-1, &tmpContext, sendPdu,
       dllReqId, &(pMsg->Addr), &(pMsg->Size));
// If v2 to v1 trap conversion was required, then cleanup...
if (pduType == SNMP_PDU_V1TRAP)
   {
   FreeVarBindList (sendPdu->VBL_addr);   // Checks for NULL
   FreeV1Trap (sendPdu->v1Trap);          // Checks for NULL
   GlobalFree (sendPdu);
   }
// If BuildMessage failed, that's all folks!
if (!fMsg)
   {
   snmpFreeTableEntry(&MsgDescr, nMsg);
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_PRECHECK;
   }
pMsg->Session = hSession;
pMsg->Status = NP_SEND;  // "send"
pMsg->Type = pduType;
pMsg->nRetransmitMode = TaskData.nRetransmitMode;
pMsg->dllReqId = dllReqId;
pMsg->appReqId = pPdu->appReqId;
pMsg->agentEntity = hDst;
pMsg->ourEntity   = hSrc;
pMsg->Context     = hCtx;
LeaveCriticalSection (&cs_MSG);
// Update reference counts for entities and contexts,
EnterCriticalSection (&cs_ENTITY);
if (hSrc)
   pEntSrc->refCount++;
pEntDst->refCount++;
LeaveCriticalSection (&cs_ENTITY);
EnterCriticalSection (&cs_CONTEXT);
pCtxt->refCount++;
LeaveCriticalSection (&cs_CONTEXT);
// Prepare addressing info for traps
EnterCriticalSection (&cs_MSG);
CopyMemory (&(pMsg->Host), &pEntDst->addr, sizeof(SAS));
if (pduType == SNMP_PDU_V1TRAP ||
    pduType == SNMP_PDU_TRAP ||
    pduType == SNMP_PDU_INFORM)
   {
   if (tFamily == AF_IPX)
      {
      if (pMsg->Host.ipx.sa_socket == ntohs (IPX_SNMP_PORT))
         pMsg->Host.ipx.sa_socket = htons (IPX_TRAP_PORT);
      }
   else // Assume AF_INET
      {
      if (pMsg->Host.inet.sin_port == ntohs (IP_SNMP_PORT))
         pMsg->Host.inet.sin_port = htons(IP_TRAP_PORT);
      }
   }
// Send the packet
thrId = sendto (*pSock, pMsg->Addr, pMsg->Size,
                0, (LPSOCKADDR)&(pMsg->Host), sizeof(SAS));
if (thrId == SOCKET_ERROR)
   {
   FreeMsg (nMsg);
   lError = SNMPAPI_TL_OTHER;
   goto ERROR_PRECHECK;
   }
// Need to check for SOCKET_ERROR!
if (pduType == SNMP_PDU_TRAP ||
    pduType == SNMP_PDU_V1TRAP ||
    pduType == SNMP_PDU_RESPONSE)
   {
   FreeMsg (nMsg);
   }
else
   {
   pMsg->Status = NP_SENT;
   // Time entity's timeout value is stored as centiseconds in 32 bits
   pMsg->Wait   = pEntDst->nPolicyTimeout;
   // Converting to milliseconds for timer operations could overflow
   if (pMsg->Wait <= MAXCENTISECONDS)  // So check first...if ok
      pMsg->Wait *= 10;                // Convert to milliseconds
   else                                         // eles...
      pMsg->Wait = MAXMILLISECONDS;    // Set to max milliseconds
   pMsg->Tries  = pMsg->PolicyTries = pEntDst->nPolicyRetry;
   pMsg->Ticks  = GetTickCount();
   }
ERROR_PRECHECK:
LeaveCriticalSection (&cs_MSG);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpSendMsg

// SnmpRecvMsg
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpRecvMsg (IN HSNMP_SESSION hSession,
                OUT LPHSNMP_ENTITY srcEntity,
                OUT LPHSNMP_ENTITY dstEntity,
                OUT LPHSNMP_CONTEXT context,
                OUT LPHSNMP_PDU pdu)
{
DWORD nMsg;
DWORD nPdu;
int pduType;
smiLPOCTETS community;
smiUINT32 version;
smiUINT32 nMode;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
DWORD nSes = HandleToUlong(hSession) - 1;
LPPDUS pPdu;
LPENTITY pEntity;
LPSNMPMSG pMsg;
DWORD lTime; // holds the local time for updating the nActualTimeout value

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, nSes))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// Valid session...save for possible error return
lSession = hSession;
EnterCriticalSection (&cs_MSG);
// Find a message for the calling session
for (nMsg = 0; nMsg < MsgDescr.Allocated; nMsg++)
   {
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
   if (pMsg->Session == hSession &&
       pMsg->Status == NP_READY)
      break;
   }
if (nMsg == MsgDescr.Allocated)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_PRECHECK1;
   }
if (!pMsg->Addr)
   {
   lError = SNMPAPI_MESSAGE_INVALID;
   goto ERROR_PRECHECK1;
   }
ERROR_PRECHECK1:
LeaveCriticalSection (&cs_MSG);
if (lError != SNMPAPI_SUCCESS)
   goto ERROR_OUT;
// Allocate a slot in PDU table
EnterCriticalSection (&cs_PDU);

lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK2;
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

nMode = ParseMessage (pMsg->Addr, pMsg->Size,
                      &version, &community, pPdu);
if (nMode != 0) // non-zero = error code
   {
   snmpFreeTableEntry(&PDUsDescr, nPdu);
   FreeMsg (nMsg);
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_PRECHECK2;
   }
pPdu->Session  = hSession;
pPdu->appReqId = pMsg->appReqId;
ERROR_PRECHECK2:
LeaveCriticalSection (&cs_PDU);
if (lError != SNMPAPI_SUCCESS)
   goto ERROR_OUT;
pduType = pPdu->type;
EnterCriticalSection (&cs_ENTITY);

if (dstEntity)
   { // Deliberate assignment...
   if (*dstEntity = pMsg->ourEntity)
      {
      pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->ourEntity)-1);
      pEntity->refCount++;
      }
   }

// for RESPONSE messages only, update the 'ActualRetry' and 'ActualTimeout' parameters
// for all the other messages, these params are meaningless
if (pduType == SNMP_PDU_RESPONSE)
{
    // locate the agent (source) entity here
    pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);

    // update the nActualTimeout param of the agent (source) entity.
    lTime = GetTickCount();
    if (pMsg->Ticks > lTime)
        // handle the time wrap case
        // (~pMsg->Ticks + 1) is 2's complement of pMsg->Ticks
        pEntity->nActualTimeout = (lTime + ~pMsg->Ticks + 1)/10;
    else
        pEntity->nActualTimeout = (lTime - pMsg->Ticks)/10;

    // update the nActualRetry param of the agent (source) entity
    pEntity->nActualRetry = pMsg->PolicyTries - pMsg->Tries;
}

if (srcEntity)
   {
    if (pduType == SNMP_PDU_TRAP ||
       pduType == SNMP_PDU_INFORM ||
       pduType != SNMP_PDU_RESPONSE)
      {
      int afType = pMsg->Host.ipx.sa_family;
      char afHost[24];
      EnterCriticalSection (&cs_XMODE);
      SnmpGetTranslateMode (&nMode);
      SnmpSetTranslateMode (SNMPAPI_UNTRANSLATED_V1);
      if (afType == AF_IPX)
         SnmpIpxAddressToStr (pMsg->Host.ipx.sa_netnum,
                              pMsg->Host.ipx.sa_nodenum,
                              afHost);
      else // AF_INET
         lstrcpy (afHost, inet_ntoa (pMsg->Host.inet.sin_addr));
      pMsg->agentEntity = SnmpStrToEntity (hSession, afHost);
      pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);
      if (afType == AF_IPX)
         pEntity->addr.ipx.sa_socket = pMsg->Host.ipx.sa_socket;
      else // AF_INET
         pEntity->addr.inet.sin_port = pMsg->Host.inet.sin_port;
      SnmpSetTranslateMode (nMode);
      LeaveCriticalSection (&cs_XMODE);
      }
   // Deliberate assignment...
   if (*srcEntity = pMsg->agentEntity)
      {
      pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);
      pEntity->refCount++;
      }
   }
LeaveCriticalSection (&cs_ENTITY);
EnterCriticalSection (&cs_CONTEXT);
if (context)
   {
   if (pduType == SNMP_PDU_TRAP ||
       pduType == SNMP_PDU_INFORM ||
       pduType != SNMP_PDU_RESPONSE)
      {
      EnterCriticalSection (&cs_XMODE);
      SnmpGetTranslateMode (&nMode);
      SnmpSetTranslateMode (SNMPAPI_UNTRANSLATED_V1);
      pMsg->Context = SnmpStrToContext (hSession, community);
      SnmpSetTranslateMode (nMode);
      LeaveCriticalSection (&cs_XMODE);
      }
   // Deliberate assignment...
   if (*context = pMsg->Context)
      ((LPCTXT)snmpGetTableEntry(&CntxDescr, HandleToUlong(pMsg->Context)-1))->refCount++;
   }
LeaveCriticalSection (&cs_CONTEXT);
FreeOctetString (community);
if (pdu)
   *pdu = (HSNMP_PDU) ULongToPtr(nPdu+1);
else
   SnmpFreePdu ((HSNMP_PDU) ULongToPtr(nPdu+1));
// Mark SendRecv slot as free
FreeMsg (nMsg);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpRecvMsg

// Allocates a generic ACL to be used for the security descriptor of the SNMPTRAP service
PACL AllocGenericACL()
{
    PACL                        pAcl;
    PSID                        pSidAdmins, pSidUsers;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;
    DWORD                       dwAclLength;

    pSidAdmins = pSidUsers = NULL;

    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ) ||
         !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidUsers ))
    {
        return NULL;
    }

    dwAclLength = sizeof(ACL) + 
                  sizeof(ACCESS_ALLOWED_ACE) -
                  sizeof(ULONG) +
                  GetLengthSid(pSidAdmins) +
                  sizeof(ACCESS_ALLOWED_ACE) - 
                  sizeof(ULONG) +
                  GetLengthSid(pSidUsers);

    pAcl = GlobalAlloc (GPTR, dwAclLength);
    if (pAcl != NULL)
    {
        if (!InitializeAcl( pAcl, dwAclLength, ACL_REVISION) ||
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_ALL,
                                   pSidAdmins ) || 
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_READ | GENERIC_EXECUTE,
                                   pSidUsers ))
        {
            GlobalFree(pAcl);
            pAcl = NULL;
        }
    }

    FreeSid(pSidAdmins);
    FreeSid(pSidUsers);

    return pAcl;
}

// frees a generic ACL
void FreeGenericACL( PACL pAcl)
{
    if (pAcl != NULL)
        GlobalFree(pAcl);
}

// SnmpRegister
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpRegister (IN HSNMP_SESSION hSession,
                 IN HSNMP_ENTITY hSrc,
                 IN HSNMP_ENTITY hDst,
                 IN HSNMP_CONTEXT hCtx,
                 IN smiLPCOID notification,
                 IN smiUINT32 status)
{
DWORD nNotice, nFound;
smiINT32 nCmp;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
DWORD nSes = HandleToUlong(hSession) - 1;
DWORD nSrc;
DWORD nDst;
DWORD nCtx;
LPENTITY pEntSrc, pEntDst;
LPCTXT pCtxt;
LPTRAPNOTICE pTrap;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (status != SNMPAPI_OFF) status = SNMPAPI_ON;
if (status == SNMPAPI_ON)
   {
   if (!snmpValidTableEntry(&SessDescr, nSes))
      {
      lError = SNMPAPI_SESSION_INVALID;
      goto ERROR_OUT;
      }
   else // Got a valid session...save for possible error return
      lSession = hSession;
   }
if (hSrc)
   {
   nSrc = HandleToUlong(hSrc) - 1;
   if (!snmpValidTableEntry(&EntsDescr, nSrc))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntSrc = snmpGetTableEntry(&EntsDescr, nSrc);
   }
if (hDst)
   {
   nDst = HandleToUlong(hDst) - 1;
   if (!snmpValidTableEntry(&EntsDescr, nDst))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntDst = snmpGetTableEntry(&EntsDescr, nDst);
   }
if (hCtx)
   {
   nCtx = HandleToUlong(hCtx) - 1;
   if (!snmpValidTableEntry(&CntxDescr, nCtx))
      {
      lError = SNMPAPI_CONTEXT_INVALID;
      goto ERROR_OUT;
      }
   pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);
   }
if (notification)
   {
   if ((!notification->len) || notification->len > MAXOBJIDSIZE)
      {
      lError = SNMPAPI_SIZE_INVALID;
      goto ERROR_OUT;
      }
   if (!notification->ptr)
      {
      lError = SNMPAPI_OID_INVALID;
      goto ERROR_OUT;
      }
   }
EnterCriticalSection (&cs_TRAP);
for (nNotice = 0, nFound = 0; nNotice < TrapDescr.Allocated,
                              nFound < TrapDescr.Used; nNotice++)
   { // First, count now many we've tested
   pTrap = snmpGetTableEntry(&TrapDescr, nNotice);
   if (pTrap->Session) nFound++;
   // then search for a parameter matches
   if ((pTrap->Session == hSession) &&
       (pTrap->ourEntity == hSrc) &&
       (pTrap->agentEntity == hDst) &&
       (pTrap->Context == hCtx))
      { // Ok, we found one
      if (!notification)
         // if the notification parameter is null, then we
         // want to either turn on or turn off all notifications
         // from this match...so clear any entries already in
         // the table and we'll add this wildcard entry if the
         // operation is SNMPAPI_ON at the end.
         {
         FreeRegister (nNotice);
         continue;
         }
      else // notification specified
         {
         if (!pTrap->notification.len)
            {
            // Redundant request (already wildcarded)
            // Skip it and return!
            goto ERROR_PRECHECK;
            }
         else // pTrap->notification
            {
            // compare OIDs
            SnmpOidCompare (notification, &(pTrap->notification),
                            0, &nCmp);
            if (nCmp)      // no match
               continue;   // ...try the next one
            else // !nCcmp
               { // got a match...
               // if SNMPAPI_ON, redundant request...skip it and return
               // if SNMPAPI_OFF, free the entry first
               if (status != SNMPAPI_ON)
                  FreeRegister (nNotice); // SNMPAPI_OFF
               goto ERROR_PRECHECK;
               } // end_else_!nCmp
            } // end_else_TrapTable[nNotice].notificatin
         } // end_else_notification_specified
      } // end_if_we_found_one
   } // end_for
if (status == SNMPAPI_OFF)
   { // Found nothing to turn off...that's ok.
   goto ERROR_PRECHECK;
   }
//
#ifndef SOLARIS
// Special check for NT...is SNMPTRAP service running?
if (TaskData.trapThread == NULL &&
    TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_NT)
   {
   DWORD   dwReturn  = SNMPAPI_TL_NOT_INITIALIZED;
   DWORD   pMode     = PIPE_WAIT | PIPE_READMODE_MESSAGE;
   LPCTSTR svcName   = "SNMPTRAP";
   LPCTSTR svcDesc   = "SNMP Trap Service";
   LPCTSTR svcPath   = "%SystemRoot%\\system32\\snmptrap.exe";
   SC_HANDLE scmHandle = NULL;
   SC_HANDLE svcHandle = NULL;
   SERVICE_STATUS svcStatus;
   BOOL fStatus;
   // Minimal SCM connection, for case when SNMPTRAP is running
   scmHandle = OpenSCManager (NULL, NULL, SC_MANAGER_CONNECT);
   if (scmHandle == NULL)
      goto DONE_SC;
   svcHandle = OpenService (scmHandle, svcName, SERVICE_QUERY_STATUS);
   if (svcHandle == NULL)
      {
      if (GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST)
         goto DONE_SC;
      else
         { // Must attempt to create service
         PACL pAcl;
         SECURITY_DESCRIPTOR S_Desc;
         // Need new scmHandle with admin priv
         CloseServiceHandle (scmHandle);
         scmHandle = OpenSCManager (NULL, NULL, SC_MANAGER_CREATE_SERVICE);
         if (scmHandle == NULL)
            goto DONE_SC; // Could not open SCM with admin priv
         // Bug# 179644 The SNMP trap service should not run in the LocalSystem account
         // We create the service with LocalService account instead of LocalSystem.
         svcHandle = CreateService (scmHandle, svcName, svcDesc,
                                    WRITE_DAC|SERVICE_QUERY_STATUS,
                                    SERVICE_WIN32_OWN_PROCESS,
                                    SERVICE_DEMAND_START,
                                    SERVICE_ERROR_NORMAL,
                                    svcPath,
                                    NULL, NULL,
                                    "TCPIP\0EventLog\0\0",
                                    "NT AUTHORITY\\LocalService", NULL);
         if (svcHandle == NULL)
            goto DONE_SC; // Could not create service
         InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION);
         if ((pAcl = AllocGenericACL()) == NULL ||
             !SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
         {
             FreeGenericACL(pAcl);
             goto DONE_SC;
         }
         SetServiceObjectSecurity (svcHandle, DACL_SECURITY_INFORMATION, &S_Desc);
         FreeGenericACL(pAcl);
         }
      }
   fStatus = QueryServiceStatus (svcHandle, &svcStatus);
   while (fStatus)
      {
      switch (svcStatus.dwCurrentState)
         {
         case SERVICE_RUNNING:
         dwReturn = SNMPAPI_SUCCESS;
         goto DONE_SC;

         case SERVICE_STOPPED:
         // Start SNMPTRAP service if necessary
         CloseServiceHandle (svcHandle);
         svcHandle = OpenService (scmHandle, svcName, SERVICE_START|SERVICE_QUERY_STATUS);
         if (svcHandle == NULL)
            goto DONE_SC; // Could not start service
         svcStatus.dwCurrentState = SERVICE_START_PENDING;
         fStatus = StartService (svcHandle, 0, NULL);
         break;

         case SERVICE_STOP_PENDING:
         case SERVICE_START_PENDING:
         Sleep (MAX_PENDING_WAIT);
         fStatus = QueryServiceStatus (svcHandle, &svcStatus);
         break;

         case SERVICE_PAUSED:
         case SERVICE_PAUSE_PENDING:
         case SERVICE_CONTINUE_PENDING:
         default:
         fStatus = FALSE;  // Nothing to do about these
         break;
         }
      }
DONE_SC:
   if (scmHandle)
      CloseServiceHandle (scmHandle);
   if (svcHandle)
      CloseServiceHandle (svcHandle);
   if (dwReturn != SNMPAPI_SUCCESS)
      {
ERROR_PRECHECK1:
      lError = dwReturn;
      goto ERROR_PRECHECK;
      }
   // Setup for pipe-oriented operations
   dwReturn = SNMPAPI_TL_RESOURCE_ERROR;
   // block on instance of server pipe becoming available
   if (!WaitNamedPipe (SNMPTRAPPIPE, TRAPSERVERTIMEOUT))
      goto ERROR_PRECHECK1;
   TaskData.trapPipe =
      // Bug# 270672 Change FILE_ATTRIBUTE_NORMAL to FILE_FLAG_OVERLAPPED
      CreateFile (SNMPTRAPPIPE, GENERIC_READ|GENERIC_WRITE,
                  FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                  OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL); 
   if (TaskData.trapPipe == INVALID_HANDLE_VALUE)
      goto ERROR_PRECHECK1;
   if (!SetNamedPipeHandleState (TaskData.trapPipe, &pMode, NULL, NULL))
      {
      CloseHandle (TaskData.trapPipe);
      TaskData.trapPipe = INVALID_HANDLE_VALUE;
      goto ERROR_PRECHECK1;
      }
   } // end_NT check for SNMPTRAP service
#endif // !SOLARIS
//If we got this far, add it
lError = snmpAllocTableEntry(&TrapDescr, &nNotice);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pTrap = snmpGetTableEntry(&TrapDescr, nNotice);

// add it
pTrap->Session = hSession;
// Deliberate assignments in next three if statements
if (pTrap->ourEntity = hSrc)
   //EntityTable[nSrc-1].refCount++; -- was this a bug??? nSrc is already 0 based
    pEntSrc->refCount++;
if (pTrap->agentEntity = hDst)
   //EntityTable[nDst-1].refCount++; -- was this a bug??? nDst is already 0 based
    pEntDst->refCount++;
if (pTrap->Context = hCtx)
   //ContextTable[nCtx-1].refCount++; -- was this a bug?? nCtx is already 0 based
   pCtxt->refCount++;
if (notification)
   { // Reproduce the OID
   pTrap->notification.ptr = NULL;
   // Deliberate assignment in next statement
   if (pTrap->notification.len = notification->len)
      {
      if (pTrap->notification.len > MAXTRAPIDS)
         pTrap->notification.len = MAXTRAPIDS;
      if (notification->ptr)
         {
         // Deliberate assignment in next statement
         pTrap->notification.ptr = &(pTrap->notificationValue[0]);
         CopyMemory (pTrap->notification.ptr, notification->ptr,
                     pTrap->notification.len * sizeof(smiUINT32));
         }
      }
   }
if (TaskData.trapThread == NULL)
   {
// Leave # lines at margin (for Solaris cc compiler)
#ifdef SOLARIS
   thr_create (NULL, 0, thrTrap, NULL, THR_FLAGS, &TaskData.trapThread);
#else // Win32
   DWORD thrId;
   TaskData.trapThread = (HANDLE)_beginthreadex (NULL, 0, thrTrap, NULL, 0, &thrId);
#endif
   }
ERROR_PRECHECK:
LeaveCriticalSection (&cs_TRAP);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpRegister

void FreeMsg (DWORD nMsg)
{
LPSNMPMSG pMsg;
EnterCriticalSection (&cs_MSG);
// Decrement reference counts
pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
SnmpFreeEntity (pMsg->agentEntity);
SnmpFreeEntity (pMsg->ourEntity);
SnmpFreeContext (pMsg->Context);
if (pMsg->Addr)
   GlobalFree (pMsg->Addr);
snmpFreeTableEntry(&MsgDescr, nMsg);
LeaveCriticalSection (&cs_MSG);
return;
} // end_FreeMsg

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpListen (IN HSNMP_ENTITY hEntity,
               IN smiUINT32 status)
{
smiUINT32 nAgent = 0;
DWORD thrId;
DWORD nEntity = HandleToUlong(hEntity) - 1;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPENTITY pEntity;
LPAGENT pAgent;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&EntsDescr, nEntity))
   {
   lError = SNMPAPI_ENTITY_INVALID;
   goto ERROR_OUT;
   }
pEntity = snmpGetTableEntry(&EntsDescr, nEntity);
lSession = pEntity->Session;
if (status != SNMPAPI_ON && status != SNMPAPI_OFF)
   {
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_ENTITY);
EnterCriticalSection (&cs_AGENT);
if (status)
   { // status == SNMPAPI_ON
   int nProto = IPPROTO_UDP;
   int nSize = sizeof(SOCKADDR_IN);
   int nFamily = pEntity->addr.inet.sin_family;
   if (pEntity->Agent)
      { // Entity already running as agent
      lError = SNMPAPI_NOOP;
      goto ERROR_PRECHECK;
      }
   // Allocate a slot in AGENT table
   lError = snmpAllocTableEntry(&AgentDescr, &nAgent);
   if (lError != SNMPAPI_SUCCESS)
       goto ERROR_PRECHECK;
   pAgent = snmpGetTableEntry(&AgentDescr, nAgent);

// Agent table entry allocated...setup for agent thread
   if (nFamily == AF_IPX)
      {
      nProto = NSPROTO_IPX;
      nSize = sizeof(SOCKADDR_IPX);
      }
   pAgent->Socket = socket (nFamily, SOCK_DGRAM, nProto);
   if (pAgent->Socket == INVALID_SOCKET)
      {
      snmpFreeTableEntry(&AgentDescr, nAgent);
      lError = SNMPAPI_TL_RESOURCE_ERROR;
      goto ERROR_PRECHECK;
      }
   if (bind (pAgent->Socket,
            (LPSOCKADDR)&pEntity->addr, nSize)
      == SOCKET_ERROR)
      {
      snmpFreeTableEntry(&AgentDescr, nAgent);
      closesocket (pAgent->Socket);
      lError = SNMPAPI_TL_OTHER;
      goto ERROR_PRECHECK;
      }
   // Make Entity and Agent point to each other
   pEntity->Agent = nAgent + 1;
   pAgent->Entity = hEntity;
   pAgent->Session = lSession;
   // Create agent thread...needs error checking
#ifdef SOLARIS // Leave at left margin for Solaris compiler
   thr_create (NULL, 0, thrAgent, (LPVOID)nAgent, THR_FLAGS, &(pAgent->Thread));
#else  // Win32
   pAgent->Thread = (HANDLE)_beginthreadex (NULL, 0, thrAgent, (LPVOID) ULongToPtr(nAgent), 0, &thrId);
#endif // SOLARIS
   } // end_if status == SNMPAPI_ON
else
   { // status == SNMPAPI_OFF
   if (!pEntity->Agent)
      { // Entity not running as agent
      lError = SNMPAPI_NOOP;
      goto ERROR_PRECHECK;
      }
   // Entity is running as agent
   nAgent = pEntity->Agent - 1;
   pAgent = snmpGetTableEntry(&AgentDescr, nAgent);
   closesocket (pAgent->Socket);
   WaitForSingleObject (pAgent->Thread, INFINITE);
   CloseHandle (pAgent->Thread);
   snmpFreeTableEntry(&AgentDescr, nAgent);
   // Must terminate entity's agent status
   pEntity->Agent = 0;
   // Must terminate entity if nothing else was using it
   if (pEntity->refCount == 0)
      SnmpFreeEntity (hEntity);
   } // end_else status == SNMPAPI_OFF
ERROR_PRECHECK:
LeaveCriticalSection (&cs_AGENT);
LeaveCriticalSection (&cs_ENTITY);
ERROR_OUT:
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
else
   return (SaveError (lSession, lError));
} // end_SnmpListen()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpCancelMsg (HSNMP_SESSION hSession, smiINT32 nReqID)
{
DWORD nMsg = 0;
DWORD nFound = 0;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPSNMPMSG pMsg;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession;
EnterCriticalSection (&cs_MSG);

while (nFound < MsgDescr.Used && nMsg < MsgDescr.Allocated)
   {
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
   // Deliberate assignement in next conditional
   if (pMsg->Session)
      {
      nFound++;
      if (pMsg->Session == hSession)
         {
         if (pMsg->Status == NP_SENT &&
             pMsg->appReqId == (smiUINT32)nReqID)
            {
            FreeMsg (nMsg);
            goto ERROR_PRECHECK;
            }
         }
      }
   nMsg++;
   }
// Falied to find a MSG that matched the request
lError = SNMPAPI_PDU_INVALID;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_MSG);
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
// else...failure case
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpCancelMsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_no.c ===
// wsnmp_no.c
//
// WinSNMP Notification Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 970310 - Added callback session support
//        - Added v2 to v1 trap mapping
//        - Refined v1 to v2 trap mapping
//
#include "winsnmp.inc"
//
BOOL DispatchTrap (LPSAS host, smiLPOCTETS community, LPPDUS pdu);
BOOL MapV1TrapV2 (LPPDUS pdu);
smiUINT32 ParsePduHdr (smiLPBYTE msgPtr, smiUINT32 msgLen, smiLPUINT32 version, smiLPINT type, smiLPUINT32 reqID);
BOOL SetPduType (smiLPBYTE msgPtr, smiUINT32 msgLen, int pduType);
THR_TYPE WINAPI thrNotify (LPVOID);

smiUINT32 sysUpTimeValue[9]    = {1,3,6,1,2,1,1,3,0};
smiOID sysUpTimeName   = {9, sysUpTimeValue};
smiUINT32 snmpTrapOidValue[11] = {1,3,6,1,6,3,1,1,4,1,0};
smiOID snmpTrapOidName = {11, snmpTrapOidValue};
smiUINT32 snmpTrapsValue[10]   = {1,3,6,1,6,3,1,1,5,999};
smiOID snmpTrapsName   = {10, snmpTrapsValue};
smiUINT32 snmpTrapEntValue[11] = {1,3,6,1,6,3,1,1,4,3,0};
smiOID snmpTrapEntName = {11, snmpTrapEntValue};
smiUINT32 snmpTrapAddrValue[7] = {1,3,6,1,3,1057,1};
smiOID snmpTrapAddrName = {7, snmpTrapAddrValue};

void MsgNotify (smiUINT32 msgType, smiLPBYTE msgAddr, smiUINT32 msgLen, smiUINT32 nAgent, LPSAS host)
{
DWORD nFound;
DWORD nMsg;
smiUINT32 version;
smiINT pduType;
smiUINT32 reqID;
LPSESSION pSession;
LPSNMPMSG pMsg;

nMsg = ParsePduHdr (msgAddr, msgLen, &version, &pduType, &reqID);
if (nMsg != 0) // ParsePduHdr returns 0 == no_error
   {
   if (msgAddr)
   GlobalFree (msgAddr);
   return;
   }
switch (msgType)
   {
   case NP_TRAP:
   if (TrapDescr.Used && // Discard traps if no registrations
         (pduType == SNMP_PDU_INFORM ||
          pduType == SNMP_PDU_TRAP ||
          pduType == SNMP_PDU_V1TRAP))
      {
      smiLPOCTETS community;
      LPPDUS pdu;
      BOOL bConvert;
      pdu = GlobalAlloc (GPTR, sizeof(PDUS));
      if (pdu == NULL)
         goto DONE_TRAP;
      nMsg = ParseMessage (msgAddr, msgLen, &version, &community, pdu);
      if (nMsg != 0) // ParseMessage returns 0 == no_error
         goto DONE_PDU;
      if (pduType == SNMP_PDU_INFORM)
         { // Send the Inform acknowledgment response
         SOCKET s;
         SetPduType (msgAddr, msgLen, SNMP_PDU_RESPONSE);
         if (host->ipx.sa_family == AF_IPX)
            s = TaskData.ipxSock;
         else
            s = TaskData.ipSock;
         sendto (s, msgAddr, msgLen, 0, (LPSOCKADDR)host, sizeof(SOCKADDR));
         SetPduType (msgAddr, msgLen, SNMP_PDU_INFORM);
         }
      bConvert = TRUE;
      if (pduType == SNMP_PDU_V1TRAP)           // If v1 trap...
         bConvert = MapV1TrapV2 (pdu);          // convert to v2 trap
      if (bConvert)
         DispatchTrap (host, community, pdu);   // always v2 here
      // Cleanup is the same regardless of success or failure
      FreeVarBindList (pdu->VBL_addr);  // Checks for NULL
      FreeV1Trap (pdu->v1Trap);         // ditto
      FreeOctetString (community);      // ditto
      DONE_PDU:
      GlobalFree (pdu);
      } // end_if Trap_or_Inform PDU
   DONE_TRAP:
   GlobalFree (msgAddr);
   return; // end_case NP_TRAP

   case NP_RESPONSE:
   if (pduType != SNMP_PDU_RESPONSE)
      {
      GlobalFree (msgAddr);
      return;
      }
   EnterCriticalSection (&cs_MSG);

   for (nFound=0, nMsg=0; nFound<MsgDescr.Used && nMsg<MsgDescr.Allocated; nMsg++)
      {
      pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
      if (!pMsg->Session)
         continue;
      nFound++;
      if ((pMsg->Status == NP_SENT) && // Must have been sent!
          (pMsg->dllReqId == reqID))   // Must match up!
         {
         pMsg->Status = NP_RCVD;       // ResponsePDU!
         // Release sent packet message
         if (pMsg->Addr)
            GlobalFree (pMsg->Addr);
         // Point to received packet message
         pMsg->Addr = msgAddr;
         pMsg->Size = msgLen;
         LeaveCriticalSection (&cs_MSG);
         pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
         if (pSession->fCallBack)
            { // callback session notification mode
            EnterCriticalSection (&cs_SESSION);
            if (pSession->thrHandle)
               {
               if (pSession->thrCount != 0xFFFFFFFF)
                  pSession->thrCount++;
               SetEvent (pSession->thrEvent);
               }
            else
               FreeMsg (nMsg);
            LeaveCriticalSection (&cs_SESSION);
            }
         else
            { // window/message session notification mode
            if (IsWindow(pSession->hWnd))
               {
               pMsg->Status = NP_READY;
               PostMessage (pSession->hWnd,
                            pSession->wMsg,
                            0, pMsg->appReqId);
               }
            else
               FreeMsg (nMsg);
            }
         return;  // Matched response with request
         } // end_if
      } // end_for
   // If we fall through the for loop without finding a match,
   //  this must be a spurious message from agent...discard
   GlobalFree (msgAddr);
   LeaveCriticalSection (&cs_MSG);
   return; // end_case NP_RESPONSE

   case NP_REQUEST:
   // To allow for AgentX Master Agents and Mid-Level-Managers
   // any type of PDU may be accepted on this channel - BobN 4/8/97
   // Get a msg slot
   EnterCriticalSection (&cs_MSG);
   if (snmpAllocTableEntry(&MsgDescr, &nMsg) != SNMPAPI_SUCCESS)
   {
       LeaveCriticalSection(&cs_MSG);
       return;
   }
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);

   pMsg->Session = ((LPAGENT)snmpGetTableEntry(&AgentDescr, nAgent))->Session;
   pMsg->Status = NP_RCVD;       // In-bound request
   pMsg->Type = pduType;
   pMsg->Addr = msgAddr;
   pMsg->Size = msgLen;
   pMsg->appReqId = pMsg->dllReqId = reqID;
   CopyMemory (&(pMsg->Host), host, sizeof(SAS));
   LeaveCriticalSection (&cs_MSG);
   pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
   if (pSession->fCallBack)
      { // callback session notification mode
     EnterCriticalSection (&cs_SESSION);
      if (pSession->thrHandle)
         {
         if (pSession->thrCount != 0xFFFFFFFF)
            pSession->thrCount++;
         SetEvent (pSession->thrEvent);
         }
      else
         {
         FreeMsg (nMsg);
         }
      LeaveCriticalSection (&cs_SESSION);
      }
   else
      {
      if (IsWindow(pSession->hWnd))
         {
         pMsg->Status = NP_READY;
         PostMessage (pSession->hWnd,
                      pSession->wMsg,
                      0, pMsg->appReqId);
         }
      else
         FreeMsg (nMsg);
      }
   break;

   default:
   GlobalFree (msgAddr);
   break;
   } // end_switch msgType
return;
} // end_MsgNotify

THR_TYPE WINAPI thrNotify (LPVOID cbSessionSlot)
{
    DWORD           nSes = (DWORD)((DWORD_PTR)cbSessionSlot);
    HSNMP_SESSION   hSession = (HSNMP_SESSION) ULongToPtr(nSes + 1);
    DWORD           nUsed, nMsg;
    WPARAM          wParam;
    LPARAM          lParam;
    BOOL            bFound, bWillBlock;
    LPSESSION       pSession;
    LPSNMPMSG       pMsg;

    // pSession->thrCount counts the number of requests. External threads increment it
    // each time they know something has changed in the message table (message expired or received)
    // thrNotify decrements it each time it scans the message table.
    do
    {
        EnterCriticalSection (&cs_SESSION);
        pSession = snmpGetTableEntry(&SessDescr, nSes);
        if (pSession->thrCount != 0xFFFFFFFF &&
            pSession->thrCount != 0)
            pSession->thrCount-- ;
        bWillBlock = pSession->thrCount == 0;
        LeaveCriticalSection (&cs_SESSION);

        // The thread will block only if the pSession->thrCount was 0 (tested in critical
        // section). It will be unblocked by external threads, from inside the same critical section.
        if (bWillBlock)
            WaitForSingleObject (pSession->thrEvent, INFINITE);

        // termination is requested, just break the loop
        if (pSession->thrCount == 0xFFFFFFFF)
            break;

        bFound = FALSE;
        // Find a waiting Msg for this session to process
        EnterCriticalSection (&cs_MSG);
        for (nUsed=0, nMsg=0;
             nUsed<MsgDescr.Used && nMsg<MsgDescr.Allocated;
             nMsg++)
        {
            pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
            if (pMsg->Session == hSession &&
                (pMsg->Status == NP_RCVD || pMsg->Status == NP_EXPIRED))
            {
                // the message was found. It might be already received, or it might
                // be timed out. Either case, the notification function has to be called.
                wParam = pMsg->Status == NP_RCVD ? 0 : SNMPAPI_TL_TIMEOUT ;
                lParam = pMsg->appReqId;

                if (wParam == SNMPAPI_TL_TIMEOUT)
                    FreeMsg(nMsg); // no more need for this expired bugger
                else
                    pMsg->Status = NP_READY; // mark it for SnmpRecvMsg()

                bFound = TRUE;
                // as the message was found, no reason to loop further
                break;
            }

            // update nFound to avoid searching more than the messages available
            nUsed += (pMsg->Session != 0);
        }
        LeaveCriticalSection (&cs_MSG);

        if (bFound)
        {
            //if a message was found for this session, call the notification function
            (*(pSession->fCallBack)) (hSession,
                                      pSession->hWnd,
                                      pSession->wMsg,
                                      wParam,
                                      lParam,
                                      pSession->lpClientData);
        }

    } while (TRUE);

    _endthreadex(0);

    return (0);
} // end_thrNotify

THR_TYPE WINAPI thrManager (LPVOID xSock)
{
DWORD  iBytes;
int    nSock;
fd_set readFDS;
SOCKET *pSock = (SOCKET*)xSock;
SOCKET tSock = *pSock;
SAS    host;
smiLPBYTE rMsgPtr;
int    fLen;
while (TRUE)
   {
   FD_ZERO (&readFDS);
   // Note:  strategy used in this block to assign a value
   // to "fLen" is important for Solaris and benign for Win32
   FD_SET (tSock, &readFDS);
   fLen = (int)tSock;
   fLen++;
   // Must preserve value of fLen across loops
   nSock = select (fLen, &readFDS, NULL, NULL, NULL);
   if (nSock == SOCKET_ERROR || *pSock == INVALID_SOCKET)
      goto DONE;
   // Only one socket monitored per thread, hence
   // FD_ISSET can be safely assumed at this point
   nSock = ioctlsocket (tSock, FIONREAD, &iBytes);
   if (nSock == SOCKET_ERROR || *pSock == INVALID_SOCKET)
      goto DONE;
   // Find the message buffer address...
   rMsgPtr = GlobalAlloc (GPTR, iBytes);
   if (rMsgPtr == NULL)
      { // No space error...throw away the message...
      recvfrom (tSock, (LPSTR)&nSock, 1, 0, NULL, NULL);
      if (*pSock == INVALID_SOCKET)
          goto DONE;
      // ...and call it quits.
      continue;
      }
   nSock = sizeof(SAS);
   // get the datagram and the address of the host that sent it
   iBytes = recvfrom (tSock, rMsgPtr, iBytes, 0, (LPSOCKADDR)&host, &nSock);
   if (iBytes != SOCKET_ERROR && *pSock != INVALID_SOCKET)
      MsgNotify (NP_RESPONSE, rMsgPtr, iBytes, 0, &host);
   } // end_while
DONE:
return (0);
} // end_thrManager

THR_TYPE WINAPI thrTimer (LPVOID nTask)
{ // Clean-up any timed-out messages
BOOL bFree;
DWORD lTicks, nMsg;
DWORD nFound;
SOCKET tSock;
LPSNMPMSG pMsg;

// This thread won't be needed immediately upon creation.
// It sleeps/suspends itself as appropriate.
// SnmpSendMsg() resumes it for each message sent
// SnmpCleanup() resumes it to signal termination.
while (TRUE)
   {// Once per second granularity
#ifdef SOLARIS
   sleep (1);
#else
   Sleep (1000);
#endif // SOLARIS
   // Check for termination request
   if (TaskData.timerThread == NULL)
      goto DONE;
   // If no msgs, go back to sleep
   if (MsgDescr.Used == 0)
      continue;
   EnterCriticalSection (&cs_MSG);
   for (nMsg=0, nFound=0; nFound<MsgDescr.Used && nMsg<MsgDescr.Allocated; nMsg++)
      {
      pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
      if (!pMsg->Session)           // Skip unused slots
         continue;
      nFound++; // Signal break when last used slot is processed
      if (pMsg->Status != NP_SENT)  // Skip pending and
         continue;                           // received messages
      lTicks = GetTickCount();               // update current time
      // Following test revised on 10/18/96 by BobN
      // Message "tick-time" rather than "TTL" now stored in MSG
      // to enable test for Windows timer wrap (49.7 days)

      // pMsg->PolicyTries - pMsg->Tries is the number of retries so far
      if ((pMsg->PolicyTries - pMsg->Tries+1)*pMsg->Wait + pMsg->Ticks > lTicks  &&  // MSG TTL test
          pMsg->Ticks <= lTicks)                 // Timer wrap test
         continue;                            // Retain the message
      
      bFree = TRUE; // Prepare to free the message slot
      if (pMsg->nRetransmitMode)
         {
         if (pMsg->Tries)
            {
             LPENTITY pEntity;

            //WriteSocket (nMsg);
            // Determine which socket to use
            if (pMsg->Host.ipx.sa_family == AF_IPX)
               tSock = TaskData.ipxSock;
            else
               tSock = TaskData.ipSock;
            // Send the data
            sendto (tSock, pMsg->Addr, pMsg->Size,
                    0, (LPSOCKADDR)&(pMsg->Host), sizeof(SAS));
            // Need to check for SOCKET_ERROR!
            // end_WriteSocket
            //pMsg->Ticks is the time for the first SnmpSendMessage
            pMsg->Tries--;    // Record the attempt
                     
            // update the destination entity's nActualRetry
            EnterCriticalSection (&cs_ENTITY);         
            // locate the agent (source) entity here
            pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pMsg->agentEntity)-1);

            // update the nActualRetry param of the agent (source) entity
            pEntity->nActualRetry = pMsg->PolicyTries - pMsg->Tries;
            LeaveCriticalSection (&cs_ENTITY);
            
            if (!pMsg->Tries) // No further retries?
               {                       // Release buffer space
               GlobalFree (pMsg->Addr);
               pMsg->Addr = NULL;
               pMsg->Size = 0;
               }
            bFree = FALSE;             // Retain the message slot
            }
         else
            {
            LPSESSION pSession;

            pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
            if (pSession->fCallBack)
               { // callback session notification mode
               EnterCriticalSection (&cs_SESSION);
               if (pSession->thrHandle)
                  {
                  bFree = FALSE; // thrNotify will free it
                  pMsg->Status = NP_EXPIRED;
                  if (pSession->thrCount != 0xFFFFFFFF)
                     pSession->thrCount++;
                  SetEvent (pSession->thrEvent);
                  }
               LeaveCriticalSection (&cs_SESSION);
               }
            else
               { // windows/message session notification mode
               if (IsWindow(pSession->hWnd))
                  {
                  PostMessage (pSession->hWnd,
                               pSession->wMsg,
                               SNMPAPI_TL_TIMEOUT,
                               pMsg->appReqId);
                  }
               }
            } // end_else (no retry left)
         } // end_if (retransmitMode)
      if (bFree) FreeMsg (nMsg);
      } // end_for
   LeaveCriticalSection (&cs_MSG);
   } // end_while
DONE:
return (0);
} // end_thrTimer

#ifndef SOLARIS
// Client side trap processing for Win32
THR_TYPE WINAPI thrTrap (LPVOID lpTask)
{
#define TRAPBUFSIZE 4096
typedef struct
   {
   SOCKADDR Addr;
   int      AddrLen;
   UINT     TrapBufSz;
   char     TrapBuf[TRAPBUFSIZE];
   } SNMP_TRAP, *PSNMP_TRAP;
SNMP_TRAP recvTrap;
DWORD iBytes;
smiLPBYTE rMsgPtr;
BOOL bSuccess;
//
// Approach differs for NT (SNMPTRAP) vs '95
//
if (TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_NT)
{
    // IMPORTANT NOTE FOR NT:
    // This code must be consistent with the SNMPTRAP code
    // wrt TRAPBUFSIZE, SNMPTRAPPIPE, and the SNMP_TRAP struct

    while (TRUE)
    {
        // check if thread termination required, Bug# 270672
        if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.trapEvent, 0))
        {
            break;
        }

        if (ReadFile(
                TaskData.trapPipe,
                (LPBYTE)&recvTrap,
                sizeof(SNMP_TRAP) - sizeof(recvTrap.TrapBuf), // message header size 
                &iBytes,
                &TaskData.trapOl))
        {
            // It is impossible for ReadFile to succeed because
            // the specified number of bytes to read is less than 
            // the size of the next message.

            break;
        }
        else
        {
            if (ERROR_IO_PENDING == GetLastError())
            {    
                // block to wait until the reading of pipe message header completes
                // or we need to exit this thread
                bSuccess = GetOverlappedResult(
                                TaskData.trapPipe,
                                &TaskData.trapOl,
                                &iBytes,
                                TRUE); // Block

                // check if thread termination required
                if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.trapEvent, 0))
                {
                    break;
                }

                // reset event to non-signaled state for next I/O
                ResetEvent(TaskData.trapOl.hEvent);

                
                if (!bSuccess)
                {
                    if (ERROR_MORE_DATA != GetLastError())
                    {
                        break;
                    }
                    // we are here because the last overlapped read completes but we supplied
                    // a smaller buffer than the pipe message, we'll read the rest of the message
                    // below.
                }
            }
            else if (ERROR_MORE_DATA != GetLastError())
            {
                break;
            }
        }


        // Find the message buffer address...
        rMsgPtr = GlobalAlloc (GPTR, 2*recvTrap.TrapBufSz);
        if (rMsgPtr == NULL)
        {
            // No space error: E_OUTOFMEMORY
            break;
        }

        // read the rest of the pipe message
        if (
            !ReadFile(
                TaskData.trapPipe,
                (LPBYTE)rMsgPtr,
                2*recvTrap.TrapBufSz,
                &iBytes,
                &TaskData.trapOl))
        {
            if (ERROR_IO_PENDING == GetLastError())
            {
                // block to wait until the reading of pipe message body completes
                // or we need to exit this thread
                bSuccess = GetOverlappedResult(
                                TaskData.trapPipe,
                                &TaskData.trapOl,
                                &iBytes,
                                TRUE); // Block

                // check if thread termination required
                if (WAIT_OBJECT_0 == WaitForSingleObject (TaskData.trapEvent, 0))
                {
                    GlobalFree(rMsgPtr);
                    break;
                }

                // reset event to non-signaled state for next I/O
                ResetEvent(TaskData.trapOl.hEvent);

                if (!bSuccess)
                {
                    GlobalFree(rMsgPtr);
                    break;  
                }
            }
            else
            {
                GlobalFree(rMsgPtr);
                break;
            }
        }

        // get the datagram and the address of the host that sent it
        MsgNotify (NP_TRAP, rMsgPtr, iBytes, 0, (LPSAS)&recvTrap.Addr);
    } // end while()

    goto DONE;
} // end_NT_thrTrap
//
// Handle Win95 traps
//
else if (TaskData.sEnv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
{
#define BASE_PORT 26025
#define MAX_PORTS 10
SOCKADDR_IN trapAddr;
int trapPort;
int nSock;
fd_set readFDS;
int i, j;
DWORD iHeader = sizeof(SOCKADDR) + sizeof(int);
TaskData.trapWnd = FindWindow (NP_WSX95, NP_WSX95);
if (TaskData.trapWnd == NULL)
   {
   STARTUPINFO su;
   PROCESS_INFORMATION pi;
   ZeroMemory (&su, sizeof(STARTUPINFO));
   su.cb = sizeof(STARTUPINFO);
   if (CreateProcess (NULL, NP_WSX95_EXE, NULL, NULL, FALSE,
                      0, NULL, NULL, &su, &pi))
      {
      WaitForInputIdle (pi.hProcess, TRAPSERVERTIMEOUT);
      TaskData.trapWnd = FindWindow (NP_WSX95, NP_WSX95);
      }
   if (TaskData.trapWnd == NULL)
      return (0); // ERROR: Cannot connect to NP_WSX95
   }
// create UDP socket to receive traps from NP_WSX95
TaskData.trapSock = socket (AF_INET, SOCK_DGRAM, 0);
if (TaskData.trapSock == INVALID_SOCKET)
   return (0); // ERROR: Cannot create socket
ZeroMemory (&trapAddr, sizeof(trapAddr));
trapAddr.sin_family = AF_INET;
trapAddr.sin_addr.s_addr = inet_addr (LOOPBACK_ADDR);
trapPort = BASE_PORT;
for (i = 0; i < MAX_PORTS; i++)
   {
   trapPort++;
   trapAddr.sin_port = htons ((WORD)trapPort);
   j = bind (TaskData.trapSock, (LPSOCKADDR)&trapAddr, sizeof(trapAddr));
   if (j == 0)
      break; // 0 = bind success
   }
if (j == SOCKET_ERROR)
   {
   closesocket (TaskData.trapSock);
   TaskData.trapSock = INVALID_SOCKET;
   goto DONE; // ERROR: Cannot bind a port
   }
// Notify NP_WSX95 to forward traps
PostMessage (TaskData.trapWnd, WSNMP_TRAPS_ON, (DWORD_PTR)TaskData.hTask, trapPort);
//
while (TRUE)
   {
   FD_ZERO (&readFDS);
   FD_SET (TaskData.trapSock, &readFDS);
   nSock = select (0, &readFDS, NULL, NULL, NULL);
   if (nSock == SOCKET_ERROR)
      goto DONE;
   // Thread is listening on only one socket, so
   // FD_ISSET can be safely assumed here
   // get the datagram and the address of the host that sent it
   iBytes = recv (TaskData.trapSock, (LPBYTE)&recvTrap, sizeof(SNMP_TRAP), 0);
   if (iBytes != SOCKET_ERROR && iBytes > iHeader)
      {
      iBytes -= iHeader;
      // Find the message buffer address...
      rMsgPtr = GlobalAlloc (GPTR, iBytes);
      if (rMsgPtr == NULL) // No space error!
         continue;
      CopyMemory (rMsgPtr, &recvTrap.TrapBuf, iBytes);
      MsgNotify (NP_TRAP, rMsgPtr, iBytes, 0, (LPSAS)&recvTrap.Addr);
      } // end_if
   } // end_while
} // end_95_thrTrap
DONE:
return (0);
} // end_Win32_thrTrap
#endif // ! SOLARIS

#ifdef SOLARIS
THR_TYPE WINAPI thrTrap (LPVOID lpTask)
// This thread sets up a trap listen socket,
// receives traps from the socket,
// then notifies the DLL for processing.
{
SOCKADDR localAddress;
SOCKADDR_IN localAddress_in;
SOCKADDR_IPX localAddress_ipx;
struct servent *serv;
struct fd_set readfds;
int    fdSockMax = 0;
int    fLen = 0;
int    nSock;
SOCKET fd;
SOCKET fdSock[2];
BOOL   fSuccess = FALSE;
SAS    host;
smiLPBYTE rMsgPtr;
DWORD  iBytes;
int    i;
//
fd = socket (AF_INET, SOCK_DGRAM, 0);
if (fd != INVALID_SOCKET)
   {
   ZeroMemory (&localAddress_in, sizeof(localAddress_in));
   localAddress_in.sin_family = AF_INET;
   if ((serv = getservbyname ("snmp-trap", "udp")) == NULL)
      localAddress_in.sin_port = htons (IP_TRAP_PORT);
   else
      localAddress_in.sin_port = (short)serv->s_port;
   localAddress_in.sin_addr.s_addr = htonl (INADDR_ANY);
   CopyMemory (&localAddress, &localAddress_in, sizeof(localAddress_in));
   if (bind (fd, &localAddress, sizeof(localAddress)) != SOCKET_ERROR)
      {
      fLen = fd;
      fdSock[fdSockMax++] = fd;
      fSuccess = TRUE;
      }
   }
fd = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
if (fd != INVALID_SOCKET)
   {
   ZeroMemory (&localAddress_ipx, sizeof(localAddress_ipx));
   localAddress_ipx.sa_family = AF_IPX;
   localAddress_ipx.sa_socket = htons (IPX_TRAP_PORT);
   CopyMemory (&localAddress, &localAddress_ipx, sizeof(localAddress_ipx));
   if (bind (fd, &localAddress, sizeof(localAddress)) != SOCKET_ERROR)
      {
      if (fd > fLen) fLen = fd;
      fdSock[fdSockMax++] = fd;
      fSuccess = TRUE;
      }
   }
if (!fSuccess)
   return (0); // can't open either socket
fLen++;  // increment select counter
while (TRUE)
   {
   FD_ZERO(&readfds);
   // construct readfds which gets destroyed by select()
   for (i=0; i < fdSockMax; i++)
      FD_SET(fdSock[i], &readfds);
   // Must preserve value of fLen across loops
   nSock = select (fLen, &readfds, NULL, NULL, NULL);
   if (nSock == SOCKET_ERROR)
      goto DONE;
   for (i=0; i<fdSockMax; i++)
      {
      if (FD_ISSET(fdSock[i], &readfds))
         {
         ioctlsocket (fdSock[i], FIONREAD, &iBytes);
         rMsgPtr = GlobalAlloc (GPTR, iBytes);
         if (rMsgPtr == NULL)
            {
            recvfrom (fdSock[i], (LPSTR)&nSock, 1, 0, NULL, NULL);
            continue;
            }
         nSock = sizeof(SAS);
         iBytes = recvfrom (fdSock[i], rMsgPtr, iBytes, 0, (LPSOCKADDR)&host, &nSock);
         if (iBytes != SOCKET_ERROR)
            MsgNotify (NP_TRAP, rMsgPtr, iBytes, 0, &host);
         } // end_if FD_ISSET
      } // end_for
   } // end while TRUE
DONE:
return (NULL);
} // end_thrTrap (SOLARIS)
#endif // SOLARIS

THR_TYPE WINAPI thrAgent (LPVOID newAgent)
{
DWORD  iBytes;
int    iLen;
fd_set readFDS;
SAS    host;
smiLPBYTE rMsgPtr;
DWORD  nAgent = (DWORD)((DWORD_PTR)newAgent);
SOCKET sAgent = ((LPAGENT)snmpGetTableEntry(&AgentDescr, nAgent))->Socket;
// fLen logic needed for Solaris; ignored in Win32
int    fLen = (int)sAgent + 1;
while (TRUE)
   {
   FD_ZERO (&readFDS);
   FD_SET (sAgent, &readFDS);
   // Must preserve value of fLen acroos loops
   iLen = select (fLen, &readFDS, NULL, NULL, NULL);
   if (iLen == SOCKET_ERROR)
      goto DONE;
   // Only one socket per thread, therefore
   // we can safely assume FD_ISSET here
   iLen = ioctlsocket (sAgent, FIONREAD, &iBytes);
   if (iLen == SOCKET_ERROR)
      goto DONE;
   if (iBytes == 0)
      continue;
   // Find the message buffer address...
   rMsgPtr = GlobalAlloc (GPTR, iBytes);
   if (rMsgPtr == NULL)
      { // No space error...throw away the message...
      recvfrom (sAgent, (LPSTR)&iLen, 1, 0, NULL, NULL);
      // ...and call it quits.
      continue;
      }
   iLen = sizeof(SAS);
   // get the datagram and the address of the host that sent it
   iBytes = recvfrom (sAgent, rMsgPtr, iBytes, 0, (LPSOCKADDR)&host, &iLen);
   if (iBytes != SOCKET_ERROR)
      MsgNotify (NP_REQUEST, rMsgPtr, iBytes, nAgent, &host);
   } // end_while
DONE:
return (0);
} // end_thrAgent

BOOL MapV1TrapV2 (LPPDUS pdu)
{
LPVARBIND VbTicks = NULL;
LPVARBIND VbTrap = NULL;
LPVARBIND VbAddress = NULL;
LPVARBIND VbEnterprise = NULL;
LPVARBIND endPtr;
smiLPUINT32 ptrTrap;
smiUINT32 lenTrap;
if (!pdu)
   return (FALSE);
// Adjust "generic" for v2 values
pdu->v1Trap->generic_trap++;        // as oid in v2 is v1 # +1
if (pdu->v1Trap->generic_trap == 7) // specific?
   pdu->v1Trap->generic_trap = 0;   // v2
// rfc1908:(2)  If a Trap-PDU is received, then it is mapped into a
// SNMPv2-Trap-PDU.  This is done by prepending onto the variable-bindings
// field two new bindings: sysUpTime.0 [12], which takes its value from the
// timestamp field of the Trap-PDU; and.......
if (!(VbTicks = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   return (FALSE);
if (SnmpOidCopy (&sysUpTimeName, &VbTicks->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbTicks->value.syntax = SNMP_SYNTAX_TIMETICKS;
VbTicks->value.value.uNumber = pdu->v1Trap->time_ticks;
// ..... snmpTrapOID.0 [13], which is calculated thusly: if the value of
// generic-trap field is `enterpriseSpecific', then the value used is the
// concatenation of the enterprise field from the Trap-PDU with two additional
// sub-identifiers, `0', and the value of the specific-trap field; otherwise,
// the value of the corresponding trap defined in [13] is used.  (For example,
// if the value of the generic-trap field is `coldStart', then the coldStart
// trap [13] is used.)
if (!(VbTrap = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   goto ERROROUT;
if (SnmpOidCopy (&snmpTrapOidName, &VbTrap->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbTrap->value.syntax = SNMP_SYNTAX_OID;
if (snmpTrapsValue[9] = pdu->v1Trap->generic_trap) // Deliberate assignment
   { // SNMP_TRAP_GENERIC
   lenTrap = sizeof(snmpTrapsValue);
   VbTrap->value.value.oid.len = lenTrap / sizeof(smiUINT32);
   ptrTrap = snmpTrapsValue;
   }
else
   { // SNMP_TRAP_ENTERPRISE
   lenTrap = pdu->v1Trap->enterprise.len * sizeof(smiUINT32);
   VbTrap->value.value.oid.len = pdu->v1Trap->enterprise.len + 2;
   ptrTrap = pdu->v1Trap->enterprise.ptr;
   }
if (!(VbTrap->value.value.oid.ptr = (smiLPUINT32)GlobalAlloc
      (GPTR, VbTrap->value.value.oid.len * sizeof(smiUINT32))))
   goto ERROROUT;
CopyMemory (VbTrap->value.value.oid.ptr, ptrTrap, lenTrap);
if (!pdu->v1Trap->generic_trap)
   { // SNMP_TRAP_ENTERPRISE
   VbTrap->value.value.oid.ptr[pdu->v1Trap->enterprise.len+1] =
      pdu->v1Trap->specific_trap;
   }
// Special code to retain v1Trap AgentAddress info in an experimental object
// This is *not* part of the WinSNMP v2.0 standard at this time (6/25/98)
if (TaskData.conveyAddress != SNMPAPI_ON)
   goto DO_ENTERPRISE;
if (!(VbAddress = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   goto ERROROUT;
if (SnmpOidCopy (&snmpTrapAddrName, &VbAddress->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbAddress->value.syntax = SNMP_SYNTAX_IPADDR;
// *Re-use* this OID parsed in WSNMP_BN code
VbAddress->value.value.string.len = pdu->v1Trap->agent_addr.len;
VbAddress->value.value.string.ptr = pdu->v1Trap->agent_addr.ptr;
pdu->v1Trap->agent_addr.len = 0;    // Setting .ptr to NULL required
pdu->v1Trap->agent_addr.ptr = NULL; // for later call to FreeV1Trap()
DO_ENTERPRISE:
// Then,......one new binding is appended onto the variable-bindings field:
// snmpTrapEnterpriseOID.0 [13], which takes its value from the enterprise field
// of the Trap-PDU.
//
// WINSNMP specs in SnmpRecvMsg specifies this append for both the generic and
// specific traps and not only for specific as RFC 1452 does.
if (!(VbEnterprise = (LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   goto ERROROUT;
if (SnmpOidCopy (&snmpTrapEntName, &VbEnterprise->name) == SNMPAPI_FAILURE)
   goto ERROROUT;
VbEnterprise->value.syntax = SNMP_SYNTAX_OID;
// *Re-use* this OID parsed in WSNMP_BN code
VbEnterprise->value.value.oid.len = pdu->v1Trap->enterprise.len;
VbEnterprise->value.value.oid.ptr = pdu->v1Trap->enterprise.ptr;
pdu->v1Trap->enterprise.len = 0;    // Setting .ptr to NULL required
pdu->v1Trap->enterprise.ptr = NULL; // for later call to FreeV1Trap()

//We have all the variables set, just need to link them together
//backup the head of the original vbs
endPtr = pdu->VBL_addr;
// setup the new head of the list
pdu->VBL_addr = VbTicks;
VbTicks->next_var = VbTrap;
VbTrap->next_var = endPtr;
// position endPtr on the last varbind from the list
if (endPtr != NULL)
{
    // set it on the last varbind from the original V1 trap
    while (endPtr->next_var != NULL)
        endPtr = endPtr->next_var;
}
else
{
    // set it on VbTrap if no varbinds were passed in the V1 trap
    endPtr = VbTrap;
}
// append VbAddress if any and set endPtr on the new ending
if (VbAddress != NULL)
{
    endPtr->next_var = VbAddress;
    endPtr = VbAddress;
}
// append VbEnterprise
endPtr->next_var = VbEnterprise;
VbEnterprise->next_var = NULL;
//
// make it say it's an SNMPv2 Trap PDU
pdu->type = SNMP_PDU_TRAP;
// Assign a RequestID (not in SNMPv1 Trap PDUs (no need to lock)
pdu->appReqId = ++(TaskData.nLastReqId);
return (TRUE);
//
ERROROUT:
// Free only those resources created in this function
// FreeVarBind is a noop on NULLs, so no need to check first
FreeVarBind (VbEnterprise);
FreeVarBind (VbAddress);
FreeVarBind (VbTrap);
FreeVarBind (VbTicks);
return (FALSE);
} // end_MapV1TrapV2

BOOL DispatchTrap (LPSAS host, smiLPOCTETS community, LPPDUS pdu)
{
#define MAXSLOTS 10 // maximum active trap receivers
DWORD nCmp;
DWORD nFound = 0;
DWORD nTrap = 0;
DWORD nTraps[MAXSLOTS];
DWORD nMsg = 0;
LPSNMPMSG pMsg;
LPTRAPNOTICE pTrap;

EnterCriticalSection (&cs_TRAP);
for (nTrap = 0; nTrap < TrapDescr.Allocated; nTrap++)
   {
   pTrap = snmpGetTableEntry(&TrapDescr, nTrap);
   if (!pTrap->Session) continue;  // Active trap registration and
   if (pTrap->notification.len)    // all Traps?
      {                            // Nope, specific test

      SNMPAPI_STATUS lError;
      // Next line is critical...do not remove...BN 3/8/96
      pTrap->notification.ptr = &(pTrap->notificationValue[0]);
      // 2nd param below assumes well-formed trap/inform...BN 1/21/97
      lError = SnmpOidCompare (&(pTrap->notification),
         &pdu->VBL_addr->next_var->value.value.oid,
         pTrap->notification.len, &nCmp);
      if (lError != SNMPAPI_SUCCESS || nCmp) continue;  // not equal...
      }
   if (pTrap->agentEntity)         // Specific agent?
      {
      int nResult;
      LPENTITY pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pTrap->agentEntity) - 1);
      if (host->ipx.sa_family == AF_IPX)
         nResult = memcmp (&host->ipx.sa_netnum,
                   &(pEntity->addr.ipx.sa_netnum), AF_IPX_ADDR_SIZE);
      else // AF_IPX
         nResult = memcmp (&host->inet.sin_addr,
                   &(pEntity->addr.inet.sin_addr), AF_INET_ADDR_SIZE);
      if (nResult)
         continue;                           // not equal...
      }
   if (pTrap->Context)             // Specific context?
      {
      LPCTXT pCtxt = snmpGetTableEntry(&CntxDescr, HandleToUlong(pTrap->Context) - 1);
      if (community->len != pCtxt->commLen)
         continue;                           // not equal...lengths
      if (memcmp (community->ptr, pCtxt->commStr,
                  (size_t)community->len))
         continue;                           // not equal...values
      }
   nTraps[nFound] = nTrap;                   // Got a match!
   nFound++; // Count the number found and check it against maximums
   if ((nFound == (MAXSLOTS)) || (nFound == TrapDescr.Used))
      break;
   } // end_for
LeaveCriticalSection (&cs_TRAP);
if (nFound == 0)  // Nothing to do
   return (SNMPAPI_FAILURE);
//
nCmp = nFound;    // Save count for later user
EnterCriticalSection (&cs_MSG);
while (nFound)
   {
   DWORD lError;

   lError = snmpAllocTableEntry(&MsgDescr, &nMsg);
   if (lError != SNMPAPI_SUCCESS)
   {
       LeaveCriticalSection(&cs_MSG);
       return lError;
   }
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);

   --nFound;
   nTrap = nTraps[nFound];
   nTraps[nFound] = nMsg;   // Need for later use
   pTrap = snmpGetTableEntry(&TrapDescr, nTrap);

   pMsg->Session = pTrap->Session;
   pMsg->Status = NP_RCVD;
   pMsg->Type = pdu->type;
   // 960522 - BN...
   // Need to increment the eventual "dstEntity" if
   // one was specified on the SnmpRegister() filter (unusual).
   // Deliberate assignment...
   if (pMsg->ourEntity = pTrap->ourEntity)
      {
      LPENTITY pEntity = snmpGetTableEntry(&EntsDescr, HandleToUlong(pTrap->ourEntity)-1);
      pEntity->refCount++;
      }

   // end_960522 - BN
   pMsg->dllReqId = pMsg->appReqId = pdu->appReqId;
   pMsg->Ticks = pMsg->Tries = pMsg->PolicyTries = 0;
   CopyMemory (&(pMsg->Host), host, sizeof(SAS));
   if (!(BuildMessage (1, community, pdu, pdu->appReqId,
         &(pMsg->Addr), &(pMsg->Size))))
      {
      snmpFreeTableEntry(&MsgDescr, nMsg);
      LeaveCriticalSection (&cs_MSG);
      return (SNMPAPI_PDU_INVALID);
      }
   } // end_while (nFound)
LeaveCriticalSection (&cs_MSG);
//
// The next while loop actually sends the one or more trap messages
// to the application(s)...
// This is due to the fact that we "clone" the incoming trap msg
// if there are multiple registrations for it.  BobN 2/20/95
while (nCmp) // Saved message count
   { // Now actually send the message(s)
   LPSESSION pSession;

   nMsg = nTraps[--nCmp];
   pMsg = snmpGetTableEntry(&MsgDescr, nMsg);
   pSession = snmpGetTableEntry(&SessDescr, HandleToUlong(pMsg->Session) - 1);
   if (pSession->fCallBack)
      { // callback session notification mode
      EnterCriticalSection (&cs_SESSION);
      if (pSession->thrHandle)
         {
         if (pSession->thrCount != 0xFFFFFFFF)
            pSession->thrCount++;
         SetEvent (pSession->thrEvent);
         }
      else
         FreeMsg (nMsg);
      LeaveCriticalSection (&cs_SESSION);
      }
   else
      { // window/message session notification mode
      if (IsWindow(pSession->hWnd))
         {
         pMsg->Status = NP_READY;
         PostMessage (pSession->hWnd,
                      pSession->wMsg, 0, 0L);
         }
      else
         FreeMsg (nMsg);
      }
   } // end_while (nCmp)
return (SNMPAPI_SUCCESS);
} // end_DispatchTrap

LPPDUS MapV2TrapV1 (HSNMP_PDU hPdu)
{
// Convert SNMPv2 trap to SNMPv1 trap, for sending only
HSNMP_VBL hNewVbl = NULL;
LPPDUS oldPdu = NULL;
LPPDUS newPdu = NULL;
smiUINT32 lCount;
smiUINT32 lCmp;
smiUINT32 i;
smiLPBYTE tmpPtr = NULL;
smiOID sName;
smiVALUE sValue;
//
if (hPdu == NULL)
   return (NULL);
oldPdu = snmpGetTableEntry(&PDUsDescr, HandleToUlong(hPdu)-1);
if (oldPdu->type != SNMP_PDU_TRAP)
   return (NULL);
SnmpGetPduData (hPdu, NULL, NULL, NULL, NULL, &hNewVbl);
if (hNewVbl == NULL)
   return (NULL);
newPdu = GlobalAlloc (GPTR, sizeof(PDUS));
if (newPdu == NULL)
   goto ERR_OUT;
// From RFC 2089
// 3.3  Processing an outgoing SNMPv2 TRAP
//
// If SNMPv2 compliant instrumentation presents an SNMPv2 trap to the
// SNMP engine and such a trap passes all regular checking and then is
// to be sent to an SNMPv1 destination, then the following steps must be
// followed to convert such a trap to an SNMPv1 trap.  This is basically
// the reverse of the SNMPv1 to SNMPv2 mapping as described in RFC1908
// [3].
newPdu->type = SNMP_PDU_V1TRAP;
newPdu->v1Trap = GlobalAlloc (GPTR, sizeof(V1TRAP));
if (newPdu->v1Trap == NULL)
   goto ERR_OUT;
//
//   1.  If any of the varBinds in the varBindList has an SNMPv2 syntax
//       of Counter64, then such varBinds are implicitly considered to
//       be not in view, and so they are removed from the varBindList to
//       be sent with the SNMPv1 trap.
//
// We will do that step later, but check the VB count for now:
lCount = SnmpCountVbl (hNewVbl);
// Need at least 2 for sysUptime and snmpTrapOID!
if (lCount < 2)
   goto ERR_OUT;
//
//   2.  The 3 special varBinds in the varBindList of an SNMPv2 trap
//       (sysUpTime.0 (TimeTicks), snmpTrapOID.0 (OBJECT IDENTIFIER) and
//       optionally snmpTrapEnterprise.0 (OBJECT IDENTIFIER)) are
//       removed from the varBindList to be sent with the SNMPv1 trap.
//       These 2 (or 3) varBinds are used to decide how to set other
//       fields in the SNMPv1 trap PDU as follows:
//
//       a.  The value of sysUpTime.0 is copied into the timestamp field
//           of the SNMPv1 trap.
//
SnmpGetVb (hNewVbl, 1, &sName, &sValue);
SnmpOidCompare (&sysUpTimeName, &sName, 0, &lCmp);
SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   if (lCmp != 0)
      goto ERR_OUT;
newPdu->v1Trap->time_ticks = sValue.value.uNumber;
SnmpDeleteVb (hNewVbl, 1);
lCount--;
//
//       b.  If the snmpTrapOID.0 value is one of the standard traps
//           the specific-trap field is set to zero and the generic
//           trap field is set according to this mapping:
//
//              value of snmpTrapOID.0                generic-trap
//              ===============================       ============
//              1.3.6.1.6.3.1.1.5.1 (coldStart)                  0
//              1.3.6.1.6.3.1.1.5.2 (warmStart)                  1
//              1.3.6.1.6.3.1.1.5.3 (linkDown)                   2
//              1.3.6.1.6.3.1.1.5.4 (linkUp)                     3
//              1.3.6.1.6.3.1.1.5.5 (authenticationFailure)      4
//              1.3.6.1.6.3.1.1.5.6 (egpNeighborLoss)            5
//
SnmpGetVb (hNewVbl, 1, &sName, &sValue);
SnmpOidCompare (&snmpTrapOidName, &sName, 0, &lCmp);
SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   if (lCmp != 0)
      goto ERR_OUT;
SnmpOidCompare (&snmpTrapsName, &sValue.value.oid, 9, &lCmp);
if (!lCmp)
   {
   newPdu->v1Trap->generic_trap = sValue.value.oid.ptr[9] - 1;
   newPdu->v1Trap->specific_trap = 0;
//           The enterprise field is set to the value of
//           snmpTrapEnterprise.0 if this varBind is present, otherwise
//           it is set to the value snmpTraps as defined in RFC1907 [4].
   i = snmpTrapsName.len - 1;
   tmpPtr = (smiLPBYTE)snmpTrapsValue;
   }
//
//       c.  If the snmpTrapOID.0 value is not one of the standard
//           traps, then the generic-trap field is set to 6 and the
//           specific-trap field is set to the last subid of the
//           snmpTrapOID.0 value.
else
   {
   newPdu->v1Trap->generic_trap = 6;
   i = sValue.value.oid.len;
   newPdu->v1Trap->specific_trap = sValue.value.oid.ptr[i-1];
   tmpPtr = (smiLPBYTE)sValue.value.oid.ptr;
//
//           o   If the next to last subid of snmpTrapOID.0 is zero,
//               then the enterprise field is set to snmpTrapOID.0 value
//               and the last 2 subids are truncated from that value.
   if (sValue.value.oid.ptr[i-2] == 0)
      i -= 2;
//           o   If the next to last subid of snmpTrapOID.0 is not zero,
//               then the enterprise field is set to snmpTrapOID.0 value
//               and the last 1 subid is truncated from that value.
   else
      i -= 1;
//           In any event, the snmpTrapEnterprise.0 varBind (if present)
//           is ignored in this case.
   }
//
newPdu->v1Trap->enterprise.len = i;
i *= sizeof(smiUINT32);
// This allocation might have to be freed later,
// if generic trap and SnmpTrapEnterprise.0 is present in the varbindlist.
newPdu->v1Trap->enterprise.ptr = GlobalAlloc (GPTR, i);
if (newPdu->v1Trap->enterprise.ptr == NULL)
   {
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid);
   goto ERR_OUT;
   }
CopyMemory (newPdu->v1Trap->enterprise.ptr, tmpPtr, i);
SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sValue.value.oid);
SnmpDeleteVb (hNewVbl, 1);
lCount--;
//
i = 1;
while (i <= lCount)
   {
   SnmpGetVb (hNewVbl, i, &sName, &sValue);
   if (sValue.syntax == SNMP_SYNTAX_CNTR64)
      {
      SnmpDeleteVb (hNewVbl, i);
      lCount--;
      goto LOOP;
      }
   SnmpOidCompare (&snmpTrapEntName, &sName, 0, &lCmp);
   if (lCmp == 0)
      {
      if (newPdu->v1Trap->specific_trap == 0)
         {
         if  (newPdu->v1Trap->enterprise.ptr)
            GlobalFree (newPdu->v1Trap->enterprise.ptr);
         lCmp = sValue.value.oid.len * sizeof(smiUINT32);
         newPdu->v1Trap->enterprise.ptr = GlobalAlloc (GPTR, lCmp);
         if (newPdu->v1Trap->enterprise.ptr == NULL)
            goto ERR_OUT;
         newPdu->v1Trap->enterprise.len = sValue.value.oid.len;
         CopyMemory (newPdu->v1Trap->enterprise.ptr,
                     sValue.value.oid.ptr, lCmp);
         }
      SnmpDeleteVb (hNewVbl, i);
      lCount--;
      goto LOOP;
      }
   i++;
LOOP:
   SnmpFreeDescriptor (SNMP_SYNTAX_OID, (smiLPOPAQUE)&sName);
   SnmpFreeDescriptor (sValue.syntax, (smiLPOPAQUE)&sValue.value.oid);
   }
if (lCount > 0)
   {
   LPVBLS pVbl = snmpGetTableEntry(&VBLsDescr, HandleToUlong(hNewVbl)-1);
   // Retain existing varbindlist remainder
   newPdu->VBL_addr = pVbl->vbList;
   // Flag it as gone for subsequent call to SnmpFreeVbl
   pVbl->vbList = NULL;
   }
SnmpFreeVbl (hNewVbl);
//
//   3.  The agent-addr field is set with the appropriate address of the
//       the sending SNMP entity, which is the IP address of the sending
//       entity of the trap goes out over UDP; otherwise the agent-addr
//       field is set to address 0.0.0.0.
newPdu->v1Trap->agent_addr.len = sizeof(DWORD);
newPdu->v1Trap->agent_addr.ptr = GlobalAlloc (GPTR, sizeof(DWORD));
if (newPdu->v1Trap->agent_addr.ptr == NULL)
   goto ERR_OUT;
if (TaskData.localAddress == 0)
   { // Get the local machine address (for outgoing v1 traps)
   char szLclHost [MAX_HOSTNAME];
   LPHOSTENT lpstHostent;
   if (gethostname (szLclHost, MAX_HOSTNAME) != SOCKET_ERROR)
      {
      lpstHostent = gethostbyname ((LPSTR)szLclHost);
      if (lpstHostent)
         TaskData.localAddress = *((LPDWORD)(lpstHostent->h_addr));
      }
   }
*(LPDWORD)newPdu->v1Trap->agent_addr.ptr = TaskData.localAddress;
// end_RFC2089
return (newPdu);
//
ERR_OUT:
SnmpFreeVbl (hNewVbl);
if (newPdu)
   {
   FreeVarBindList (newPdu->VBL_addr); // Checks for NULL
   FreeV1Trap (newPdu->v1Trap);        // Checks for NULL
   GlobalFree (newPdu);
   }
return (NULL);
} // end_MapV2TrapV1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_pd.c ===
// wsnmp_pd.c
//
// WinSNMP PDU Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// Removed extraneous functions
//
#include "winsnmp.inc"
LPVARBIND SnmpCopyVbl (LPVARBIND);
// PDU Functions
// SnmpCreatePdu
HSNMP_PDU SNMPAPI_CALL
   SnmpCreatePdu  (IN HSNMP_SESSION hSession,
                   IN smiINT PDU_type,
                   IN smiINT32 request_id,
                   IN smiINT error_status,
                   IN smiINT error_index,
                   IN HSNMP_VBL hVbl)
{
DWORD nPdu;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
if (hVbl)
	{
	if (!snmpValidTableEntry(&VBLsDescr, HandleToUlong(hVbl)-1))
		{
		lError = SNMPAPI_VBL_INVALID;
		goto ERROR_OUT;
		}
	}

if (!PDU_type)  // NULL is allowed and defaults to SNMP_PDU_GETNEXT
   PDU_type = SNMP_PDU_GETNEXT;
switch (PDU_type)
   {
   case SNMP_PDU_GET:
   case SNMP_PDU_GETNEXT:
   case SNMP_PDU_RESPONSE:
   case SNMP_PDU_SET:
   case SNMP_PDU_INFORM:
   case SNMP_PDU_TRAP:
   case SNMP_PDU_GETBULK:
   break;

   case SNMP_PDU_V1TRAP:
   default:
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }

EnterCriticalSection (&cs_PDU);
lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

// Initialize new PDU components
pPdu->Session  = hSession;
pPdu->type = PDU_type;
pPdu->errStatus = error_status;
pPdu->errIndex  = error_index;
// If RequestID=0 at this point, assign one (which may be 0)
pPdu->appReqId = (request_id) ? request_id : ++(TaskData.nLastReqId);
pPdu->VBL_addr = NULL;
pPdu->VBL = (hVbl) ? hVbl : 0;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);

if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_PDU) ULongToPtr(nPdu+1));
else
ERROR_OUT:
   return ((HSNMP_PDU) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpCreatePdu

// SnmpGetPduData
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetPduData (IN HSNMP_PDU hPdu,
                   OUT smiLPINT PDU_type,
                   OUT smiLPINT32 request_id,
                   OUT smiLPINT error_status,
                   OUT smiLPINT error_index,
                   OUT LPHSNMP_VBL hVbl)
{
DWORD nPdu = HandleToUlong(hPdu) - 1;
DWORD done = 0;
HSNMP_SESSION hSession;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

// Use PDU's session for (possibly) creating hVbl later
hSession = pPdu->Session;
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // Save for possible error return
if (PDU_type)
   {
   *PDU_type = pPdu->type;
   done++;
   }
if (request_id)
   {
   *request_id = pPdu->appReqId;
   done++;
   }
if (error_status)
   {
   *error_status = pPdu->errStatus;
   done++;
   }
if (error_index)
   {
   *error_index = pPdu->errIndex;
   done++;
   }
if (hVbl)
   {
   DWORD nVbl; // Important control variable
   *hVbl = 0;
   EnterCriticalSection (&cs_VBL);
   // First case is on a created (not received) PDU
   // which has not yet been assigned a VBL
   if ((!pPdu->VBL) && (!pPdu->VBL_addr))
      goto DONE_VBL;
   // If there is a VBL already assinged to the PDU,
   // then duplicate it
   if (pPdu->VBL)
      { // Per policy, create a new hVbl resource for the calling app
      if (!(*hVbl = SnmpDuplicateVbl (hSession, pPdu->VBL)))
         {
         lError = SNMPAPI_VBL_INVALID;
         goto ERROR_PRECHECK;
         }
      goto DONE_VBL;
      }
   // This must be a received PDU and
   // the first call to extract the VBL
   lError = snmpAllocTableEntry(&VBLsDescr, &nVbl);
   if (lError != SNMPAPI_SUCCESS)
	   goto ERROR_PRECHECK;
   pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

   pVbl->Session = hSession;
   pVbl->vbList = pPdu->VBL_addr;
   // Clear received vbList address...IMPORTANT!
   pPdu->VBL_addr = NULL;
   *hVbl = pPdu->VBL = (HSNMP_VBL) ULongToPtr(nVbl+1);
DONE_VBL:
   done++;
ERROR_PRECHECK:
   LeaveCriticalSection (&cs_VBL);
   } // end_if vbl
if (done == 0)
   lError = SNMPAPI_NOOP;
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpGetPduData

// SnmpSetPduData
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetPduData (IN HSNMP_PDU hPdu,
                   IN const smiINT FAR *PDU_type,
                   IN const smiINT32 FAR *request_id,
                   IN const smiINT FAR *non_repeaters,
                   IN const smiINT FAR *max_repetitions,
                   IN const HSNMP_VBL FAR *hVbl)
{
DWORD nPdu = HandleToUlong(hPdu) - 1;
DWORD done = 0;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }

if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

lSession = pPdu->Session; // Save for possible error return
EnterCriticalSection (&cs_PDU);
if (!IsBadReadPtr((LPVOID)PDU_type, sizeof(smiINT)))
   {
   if (*PDU_type == SNMP_PDU_V1TRAP)
       {
           lError = SNMPAPI_PDU_INVALID;
           goto ERROR_OUT;
       }
   pPdu->type = *PDU_type;
   done++;
   }
if (!IsBadReadPtr((LPVOID)request_id, sizeof(smiINT32)))
   {
   pPdu->appReqId = *request_id;
   done++;
   }
if (!IsBadReadPtr((LPVOID)non_repeaters, sizeof(smiINT)))
   {
   pPdu->errStatus = *non_repeaters;
   done++;
   }
if (!IsBadReadPtr((LPVOID)max_repetitions, sizeof(smiINT)))
   {
   pPdu->errIndex = *max_repetitions;
   done++;
   }
if (!IsBadReadPtr((LPVOID)hVbl, sizeof(HSNMP_VBL)))
   { // Assign new vbl
   HSNMP_VBL tVbl = *hVbl;
   // Check for validity
   if (!snmpValidTableEntry(&VBLsDescr, HandleToUlong(tVbl)-1))
      { // If not, disallow operation
      lError = SNMPAPI_VBL_INVALID;
      goto ERROR_PRECHECK;
      }
   pPdu->VBL = tVbl;
   // Following case can happen if a a vbl is assigned to a
   // response pdu which never had its vbl dereferenced...
   if (pPdu->VBL_addr) //...then is must be freed
      FreeVarBindList (pPdu->VBL_addr);
   pPdu->VBL_addr = NULL;
   done++;
   } // end_if vbl
ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);
if (done == 0)
   lError = ((PDU_type == NULL) && 
            (request_id == NULL) &&
            (non_repeaters == NULL) &&
            (max_repetitions == NULL) &&
            (hVbl == NULL)) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
if (lError == SNMPAPI_SUCCESS)
   return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpSetPduData

// SnmpDuplicatePdu
HSNMP_PDU SNMPAPI_CALL
   SnmpDuplicatePdu  (IN HSNMP_SESSION hSession,
                      IN HSNMP_PDU hPdu)
{
DWORD lPdu = HandleToUlong(hPdu) - 1;
DWORD nPdu;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pOldPdu, pNewPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // save for possible error return
if (!snmpValidTableEntry(&PDUsDescr, lPdu) ||
    (pOldPdu = snmpGetTableEntry(&PDUsDescr, lPdu))->type == SNMP_PDU_V1TRAP)
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }

EnterCriticalSection (&cs_PDU);

lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pNewPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

CopyMemory (pNewPdu, pOldPdu, sizeof(PDUS));
pNewPdu->Session = hSession; // Can be different
// Setting the VBL value in the duplicated PDU is "tricky"...
// If there is a VBL value, just replicate it and that's that.
// If VBL = 0 and there is no VBL_addr attached to the pdu_ptr,
// then the VBL value is 0 and is already set from the original PDU.
// Otherwise, this is a received PDU from which the varbindlist has
// not yet been extracted and must, therefore, be re-produced.
// This third case is covered in the next *2* lines.
if ((!pOldPdu->VBL) && pOldPdu->VBL_addr)
   pNewPdu->VBL_addr = SnmpCopyVbl (pOldPdu->VBL_addr);
ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_PDU) ULongToPtr(nPdu+1));
ERROR_OUT:
return ((HSNMP_PDU) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpDuplicatePdu

// SnmpFreePdu
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreePdu (IN HSNMP_PDU hPdu)
{
DWORD nPdu = HandleToUlong(hPdu) - 1;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

EnterCriticalSection (&cs_PDU);
if (pPdu->VBL_addr)
   FreeVarBindList (pPdu->VBL_addr);
snmpFreeTableEntry(&PDUsDescr, nPdu);
LeaveCriticalSection (&cs_PDU);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpfreePdu
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_sp.c ===
// wsnmp_sp.c
//
// Special functions for the WinSNMP library
// Copyright 1998 ACE*COMM Corp
//
// Bob Natale (bnatale@acecomm.com)
//
#include "winsnmp.inc"

__declspec(dllexport)
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetAgentAddress (LPSTR agentAddress)
{
DWORD tmpAddress = 0;
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// A null arg resets the localAddress trigger value
if (agentAddress == NULL)
   goto DONE;
// Otherwise, convert to IP address
tmpAddress = inet_addr (agentAddress);
if (tmpAddress == INADDR_NONE)
   { // Invalid IP addresses cannot be accepted
   lError = SNMPAPI_MODE_INVALID;
   goto ERROR_OUT;
   }
DONE:
// Plug new agent_address value into localAddress
// for future v1 trap sends
EnterCriticalSection (&cs_TASK);
TaskData.localAddress = tmpAddress;
LeaveCriticalSection (&cs_TASK);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}

__declspec(dllexport)
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpConveyAgentAddress (SNMPAPI_STATUS mode)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
// mode can only be on or off...
if (mode != SNMPAPI_ON)
   mode = SNMPAPI_OFF;  // ...force off if not on
EnterCriticalSection (&cs_TASK);
TaskData.conveyAddress = mode;
LeaveCriticalSection (&cs_TASK);
return (SNMPAPI_SUCCESS);
ERROR_OUT:
return (SaveError (0, lError));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_vb.c ===
// wsnmp_vb.c
//
// WinSNMP VarBind Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980705 - Changed test on return from SnmpMakeVB()
//          in SnmpCreateVbl() to "!= SNMPAPI_SUCCESS".
//
#include "winsnmp.inc"

BOOL IsBadReadSMIValue(smiLPCVALUE value)
{
    if (IsBadReadPtr((LPVOID)value, sizeof(smiLPCVALUE)))
        return TRUE;

    switch(value->syntax)
    {
    case SNMP_SYNTAX_OCTETS:
    case SNMP_SYNTAX_BITS:
    case SNMP_SYNTAX_OPAQUE:
    case SNMP_SYNTAX_IPADDR:
    case SNMP_SYNTAX_NSAPADDR:
        return IsBadReadPtr((LPVOID)(value->value.string.ptr),
                            value->value.string.len);

    case SNMP_SYNTAX_OID:
        return IsBadReadPtr((LPVOID)(value->value.oid.ptr),
                            value->value.oid.len);
    }
    return FALSE;
}

SNMPAPI_STATUS SnmpMakeVB (smiLPCOID name,
                           smiLPCVALUE value,
                           LPVARBIND FAR *pvb)
{
LPVARBIND vb;
if (!(vb =(LPVARBIND)GlobalAlloc (GPTR, sizeof(VARBIND))))
   return (SNMPAPI_ALLOC_ERROR);
vb->next_var = NULL;
vb->name.ptr = NULL;
if (vb->name.len = name->len) // Deliberate assignment in conditional
   {
   if (name->ptr)
      {
      smiUINT32 len = vb->name.len * sizeof(smiUINT32);
      if (vb->name.ptr = (smiLPUINT32)GlobalAlloc (GPTR, len))
         CopyMemory (vb->name.ptr, name->ptr, len);
      }
   }
if (!vb->name.ptr)
   {
   FreeVarBind (vb);
   return (SNMPAPI_OID_INVALID);
   }
//
if (value)
   {
   switch (value->syntax)
      {
      case SNMP_SYNTAX_OCTETS:
//      case SNMP_SYNTAX_BITS:  -- removed per Bob Natale mail from 10/09/98
      case SNMP_SYNTAX_OPAQUE:
      case SNMP_SYNTAX_IPADDR:
      case SNMP_SYNTAX_NSAPADDR:
      vb->value.value.string.ptr = NULL;
      if (vb->value.value.string.len = value->value.string.len)
         { // Deliberate assignment, above and below
         if (!(vb->value.value.string.ptr =
            (smiLPBYTE)GlobalAlloc (GPTR, value->value.string.len)))
            {
            FreeVarBind (vb);
            return (SNMPAPI_ALLOC_ERROR);
            }
         CopyMemory (vb->value.value.string.ptr, value->value.string.ptr,
                      value->value.string.len);
         }
      break;

      case SNMP_SYNTAX_OID:
      vb->value.value.oid.ptr = NULL;
      if (vb->value.value.oid.len = value->value.oid.len)
         { // Deliberate assignment, above and below
         smiUINT32 len = value->value.oid.len * sizeof(smiUINT32);
         if (!(vb->value.value.oid.ptr = (smiLPUINT32)GlobalAlloc (GPTR, len)))
            {
            FreeVarBind (vb);
            return (SNMPAPI_ALLOC_ERROR);
            }
         CopyMemory (vb->value.value.oid.ptr, value->value.oid.ptr, len);
         }
      break;

      case SNMP_SYNTAX_NULL:
      case SNMP_SYNTAX_NOSUCHOBJECT:
      case SNMP_SYNTAX_NOSUCHINSTANCE:
      case SNMP_SYNTAX_ENDOFMIBVIEW:
      break;

      case SNMP_SYNTAX_INT:
      //case SNMP_SYNTAX_INT32: -- it have the same value as above
      vb->value.value.sNumber = value->value.sNumber;
      break;

      case SNMP_SYNTAX_CNTR32:
      case SNMP_SYNTAX_GAUGE32:
      case SNMP_SYNTAX_TIMETICKS:
      case SNMP_SYNTAX_UINT32:
      vb->value.value.uNumber = value->value.uNumber;
      break;

      case SNMP_SYNTAX_CNTR64:
      vb->value.value.hNumber = value->value.hNumber;
      break;

      default:
      // Clean up the allocated VarBind structure
      FreeVarBind (vb);
      return (SNMPAPI_SYNTAX_INVALID);
      } // end_switch
   vb->value.syntax = value->syntax;
   } // end_if
else
   vb->value.syntax = SNMP_SYNTAX_NULL;
//
*pvb = vb;
return (SNMPAPI_SUCCESS);
} //end_SnmpMakeVB

LPVARBIND SnmpCopyVbl (LPVARBIND VarBindFrom)
{
SNMPAPI_STATUS status;
LPVARBIND VarBindTo;
LPVARBIND VarBindToPrev;
LPVARBIND VarBindNewFrom = NULL; // base VB address
DWORD count = 0;
while (VarBindFrom)
   {
   status = SnmpMakeVB (&VarBindFrom->name, &VarBindFrom->value, &VarBindTo);
   if (status != SNMPAPI_SUCCESS)
      { // Next two lines preserve case where count > 0 at this error
      SaveError (0, status);
      break;
      }
   if (!count)
      VarBindNewFrom = VarBindTo;
   else
      VarBindToPrev->next_var = VarBindTo;
   VarBindToPrev = VarBindTo;
   VarBindFrom = VarBindFrom->next_var;
   count++;
   }
return (VarBindNewFrom);
} // end_SnmpCopyVBL

HSNMP_VBL SNMPAPI_CALL
   SnmpCreateVbl  (IN HSNMP_SESSION hSession,
                   IN smiLPCOID name,
                   IN smiLPCVALUE value)
{
DWORD nVbl;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPVARBIND VarBindPtr = NULL;  // must initialize to NULL
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }

lSession = hSession; // save it for possible error return

if (name != NULL)
   {
   if (IsBadReadPtr((LPVOID)name, sizeof(smiOID)))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
       
   if (name->len != 0 &&
       name->ptr != NULL &&
       IsBadReadPtr((LPVOID)name->ptr, name->len))
      {
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_OUT;
      }
   }
if (value != NULL &&
    IsBadReadSMIValue(value))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

// We have a valid session at this point...
if (name != NULL && name->ptr != NULL)
   {
   lError = SnmpMakeVB (name, value, &VarBindPtr);
   if (lError != SNMPAPI_SUCCESS)
      goto ERROR_OUT;
   else
      VarBindPtr->next_var = NULL;
   }
EnterCriticalSection (&cs_VBL);
lError = snmpAllocTableEntry(&VBLsDescr, &nVbl);
if (lError != SNMPAPI_SUCCESS)
	goto ERROR_PRECHECK;
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

pVbl->Session = hSession;
pVbl->vbList = VarBindPtr;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_VBL);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_VBL) ULongToPtr(nVbl+1));
ERROR_OUT:
FreeVarBind (VarBindPtr); // Hnadles NULL case
return ((HSNMP_VBL) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpCreateVbl

// SnmpSetVb
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpSetVb(IN HSNMP_VBL hVbl,
             IN smiUINT32 index,
             IN smiLPCOID name,
             IN smiLPCVALUE value)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
LPVARBIND VarBindList = NULL;
LPVARBIND VarBindPtr  = NULL;
LPVARBIND VarBindPrev = NULL;
SNMPAPI_STATUS lError = 0;
HSNMP_SESSION lSession = 0;
smiUINT32 i;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

// We have a valid session at this point...
lSession = pVbl->Session; // save it for possible error return

i = SnmpCountVbl (hVbl);

// make sure the index has a valid value
if ( index > i) // index is unsigned long => no need to test for (index < 0)
{
    lError = SNMPAPI_INDEX_INVALID;
    goto ERROR_OUT;
}

// check for valid data in 'name' parameter
if (IsBadReadPtr((LPVOID)name, sizeof(smiOID)))
{
   // if index points to an existent varbind and the
   // name parameter was not provided, take it from the
   // original varbind.
   if (index != 0 && name == NULL)
   {
       smiUINT32 iVar;

       // look for the original varbind
       for (iVar = 1, VarBindPtr = pVbl->vbList;
            iVar < index;
            iVar++, VarBindPtr = VarBindPtr->next_var);

       // make name to point to that varbind name
       name = &(VarBindPtr->name);
   }
   else
   {
       // either adding a value with NULL OID or specifying an
       // invalid value for 'name' is an SNMPAPI_ALLOC_ERROR
       lError = SNMPAPI_ALLOC_ERROR;
       goto ERROR_OUT;
   }
}

// If the index is 0 then a new varbind is to be added to the list.
// If it is non-zero it references a varbind in the list.
// Except we are currently allow index = count+1 to signal add to
// accommodate FTP Software's faulty implementation as used by HP OpenView
if (!index)      // Allow 0 for FTP/HP OpenView mistake
   index = i+1;  // But make it look like the right thing!
       
if (name->len != 0 &&
   name->ptr != NULL &&
   IsBadReadPtr((LPVOID)name->ptr, name->len))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }

if (value != NULL &&
    IsBadReadSMIValue(value))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

lError = SnmpMakeVB (name, value, &VarBindPtr);
if (lError != SNMPAPI_SUCCESS)
   goto ERROR_OUT;
VarBindPrev = VarBindList = pVbl->vbList;
if (index == i+1)
   { // Adding a VarBind
   if (VarBindList)
      {
      while (VarBindList->next_var != NULL)
         VarBindList = VarBindList->next_var;
      VarBindList->next_var = VarBindPtr;
      }
   else
      {
      VarBindList = VarBindPtr;
      pVbl->vbList = VarBindPtr;
      }
   }
else
   { // Updating a VarBind
   for (i = 1; i < index; i++)
      { // Position and prepare
      VarBindPrev = VarBindList;
      VarBindList = VarBindList->next_var;
      } // end_for
   // Replace
   VarBindPtr->next_var = VarBindList->next_var;
   VarBindPrev->next_var = VarBindPtr;
   if (index == 1)
      pVbl->vbList = VarBindPtr;
   FreeVarBind (VarBindList);
  } // end_else
return (index);
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpSetVb

HSNMP_VBL SNMPAPI_CALL
   SnmpDuplicateVbl  (IN HSNMP_SESSION hSession, IN HSNMP_VBL hVbl)
{
DWORD lVbl;
DWORD nVbl;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPVBLS pVblOld, pVblNew;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
lVbl = HandleToUlong(hVbl) - 1;
if (!snmpValidTableEntry(&VBLsDescr, lVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVblOld = snmpGetTableEntry(&VBLsDescr, lVbl);

EnterCriticalSection (&cs_VBL);
lError = snmpAllocTableEntry(&VBLsDescr, &nVbl);
if (lError != SNMPAPI_SUCCESS)
	goto ERROR_PRECHECK;
pVblNew = snmpGetTableEntry(&VBLsDescr, nVbl);

if (pVblOld->vbList)
   { // Deliberate assignment follows
   if (!(pVblNew->vbList = SnmpCopyVbl (pVblOld->vbList)))
      { // Inherit error code from SnmpCopy Vbl
      snmpFreeTableEntry(&VBLsDescr, nVbl);
      lError = SNMPAPI_ALLOC_ERROR;
      goto ERROR_PRECHECK;
      }
   }
pVblNew->Session = hSession;
ERROR_PRECHECK:
LeaveCriticalSection (&cs_VBL);
if (lError == SNMPAPI_SUCCESS)
   return ((HSNMP_VBL) ULongToPtr(nVbl+1));
ERROR_OUT:
return ((HSNMP_VBL) ULongToPtr(SaveError(lSession, lError)));
} // end_SnmpDuplicateVbl

// SnmpFreeVbl
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeVbl (IN HSNMP_VBL hVbl)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
SNMPAPI_STATUS lError = 0;
DWORD i;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

EnterCriticalSection (&cs_PDU);
if (PDUsDescr.Used)
   {
   for (i = 0; i < PDUsDescr.Allocated; i++)
      {
      LPPDUS pPdu = snmpGetTableEntry(&PDUsDescr, i);
      if (pPdu->VBL == hVbl)
         pPdu->VBL = 0;
      }
   }
LeaveCriticalSection (&cs_PDU);
EnterCriticalSection (&cs_VBL);
// Free all substructures
FreeVarBindList (pVbl->vbList);
// Clean VBL List
snmpFreeTableEntry(&VBLsDescr, nVbl);
LeaveCriticalSection (&cs_VBL);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpFreeVbl

// SnmpCountVbl
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpCountVbl (IN HSNMP_VBL hVbl)
{
DWORD nVbl;
smiUINT32 count;
SNMPAPI_STATUS lError;
LPVARBIND VarBindPtr;
HSNMP_SESSION lSession = 0;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
nVbl = HandleToUlong(hVbl) - 1;
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

count = 0;
VarBindPtr = pVbl->vbList;
lSession = pVbl->Session;
while (VarBindPtr)
   {
   VarBindPtr = VarBindPtr->next_var;
   count++;
   }
if (!count)  // No varbinds
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }
return (count);
//
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpCountVbl

// SnmpDeleteVb
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpDeleteVb (IN HSNMP_VBL hVbl, IN smiUINT32 index)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
HSNMP_SESSION hSession;
smiUINT32 status;
smiUINT32 lError = 0;
HSNMP_SESSION lSession = 0;
UINT i= 0;
LPVARBIND VarBindList;
LPVARBIND VarBindPtr;
LPVARBIND VarBindPrev;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);

hSession =  pVbl->Session;
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
lSession = hSession; // Load for SaveError() return
status = SnmpCountVbl (hVbl);
if ((!index) || (index > status))
   {
   lError = SNMPAPI_INDEX_INVALID;
   goto ERROR_OUT;
   }
EnterCriticalSection (&cs_VBL);
// Following cannot be NULL due to passing above test
VarBindPtr = VarBindList = pVbl->vbList;
// Deleting a VarBind
for (i = 1; i <= index; i++)
   { // Position
   VarBindPrev = VarBindPtr;
   VarBindPtr  = VarBindList;
   VarBindList = VarBindList->next_var;
   } // end_for
if (index == 1)
   { // Replace
   pVbl->vbList = VarBindList;
   }
else
   { // Skip
   VarBindPrev->next_var = VarBindList;
   } // end_else
FreeVarBind (VarBindPtr);
LeaveCriticalSection (&cs_VBL);
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpDeleteVb

// SnmpGetVb
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetVb (IN HSNMP_VBL hVbl,
              IN smiUINT32 index,
              OUT smiLPOID name,
              OUT smiLPVALUE value)
{
DWORD nVbl = HandleToUlong(hVbl) - 1;
LPVARBIND VarBindPtr;
SNMPAPI_STATUS lError = 0;
HSNMP_SESSION lSession = 0;
smiUINT32 nLength;
LPVBLS pVbl;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&VBLsDescr, nVbl))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
pVbl = snmpGetTableEntry(&VBLsDescr, nVbl);
lSession = pVbl->Session;

if (!name && !value)
   {
   lError = SNMPAPI_NOOP;
   goto ERROR_OUT;
   }

// Test for output descriptor address validity
if ((name && IsBadWritePtr (name, sizeof(smiOID))) ||
    (value && IsBadWritePtr (value, sizeof(smiVALUE))))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

nLength = SnmpCountVbl (hVbl);
if ((!index) || (index > nLength))
   {
   lError = SNMPAPI_INDEX_INVALID;
   goto ERROR_OUT;
   }
if (!(VarBindPtr = pVbl->vbList))
   {
   lError = SNMPAPI_VBL_INVALID;
   goto ERROR_OUT;
   }
// SnmpFillOidValue
for (nLength = 1; nLength < index; nLength++)
      VarBindPtr = VarBindPtr->next_var;

if (name != NULL)
{
    ZeroMemory (name, sizeof(smiOID));

    // Copy the name OID
    if ((VarBindPtr->name.len == 0) || (VarBindPtr->name.len > MAXOBJIDSIZE))
       {
       lError = SNMPAPI_OID_INVALID;
       goto ERROR_OUT;
       }
    nLength = VarBindPtr->name.len * sizeof(smiUINT32);
    // App must free following alloc via SnmpFreeDescriptor()
    if (!(name->ptr = (smiLPUINT32)GlobalAlloc (GPTR, nLength)))
       {
       lError = SNMPAPI_ALLOC_ERROR;
       goto ERROR_OUT;
       }
    CopyMemory (name->ptr, VarBindPtr->name.ptr, nLength);
    name->len = VarBindPtr->name.len;
}

if (value != NULL)
{
    // Initialize output structure
    ZeroMemory (value, sizeof(smiVALUE));
    // Copy the VALUE structure
    switch (VarBindPtr->value.syntax)
       {
       case SNMP_SYNTAX_OCTETS:
       case SNMP_SYNTAX_IPADDR:
       case SNMP_SYNTAX_OPAQUE:
       case SNMP_SYNTAX_NSAPADDR:
       // Do copy only if nLength is non-zero
       if (nLength = VarBindPtr->value.value.string.len) // Deliberate assignment
          { // App must free following alloc via SnmpFreeDescriptor()
          if (!(value->value.string.ptr = (smiLPBYTE)GlobalAlloc (GPTR, nLength)))
             {
             lError = SNMPAPI_ALLOC_ERROR;
             goto ERROR_PRECHECK;
             }
          CopyMemory (value->value.string.ptr, VarBindPtr->value.value.string.ptr, nLength);
          value->value.string.len = nLength;
          }
       break;

       case SNMP_SYNTAX_OID:
       nLength = VarBindPtr->value.value.oid.len;
       if (nLength > MAXOBJIDSIZE)
          {
          lError = SNMPAPI_OID_INVALID;
          goto ERROR_PRECHECK;
          }
       if (nLength)
          { // Do copy only if nLength is non-zero
          nLength *= sizeof(smiUINT32);
          // App must free following alloc via SnmpFreeDescriptor()
          if (!(value->value.oid.ptr = (smiLPUINT32)GlobalAlloc (GPTR, nLength)))
             {
             lError = SNMPAPI_ALLOC_ERROR;
             goto ERROR_PRECHECK;
             }
          CopyMemory (value->value.oid.ptr,
                       VarBindPtr->value.value.oid.ptr, nLength);
          value->value.oid.len = VarBindPtr->value.value.oid.len;
          }
       break;

       case SNMP_SYNTAX_NULL:
       case SNMP_SYNTAX_NOSUCHOBJECT:
       case SNMP_SYNTAX_NOSUCHINSTANCE:
       case SNMP_SYNTAX_ENDOFMIBVIEW:
       // Use initialized (NULL) smiVALUE
       break;

       case SNMP_SYNTAX_INT:
       value->value.sNumber = VarBindPtr->value.value.sNumber;
       break;

       case SNMP_SYNTAX_CNTR32:
       case SNMP_SYNTAX_GAUGE32:
       case SNMP_SYNTAX_TIMETICKS:
       case SNMP_SYNTAX_UINT32:
       value->value.uNumber = VarBindPtr->value.value.uNumber;
       break;

       case SNMP_SYNTAX_CNTR64:
       value->value.hNumber = VarBindPtr->value.value.hNumber;
       break;

       default:
       lError = SNMPAPI_SYNTAX_INVALID;
       goto ERROR_PRECHECK;
       } // end_switch
    value->syntax = VarBindPtr->value.syntax;
}
return (SNMPAPI_SUCCESS);
// Post-name allocation failure modes
ERROR_PRECHECK:
if (name && name->ptr)
   {
   GlobalFree (name->ptr);
   ZeroMemory (name, sizeof(smiOID));
   }
if (value && value->value.string.ptr)
   {
   GlobalFree (value->value.string.ptr);
   ZeroMemory (value, sizeof(smiVALUE));
   }
ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpGetVb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\dll\wsnmp_ut.c ===
// wsnmp_ut.c
//
// WinSNMP Utility Functions and helpers
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 980424 - BobN
//        - Mods to SnmpStrToIpxAddress() to permit '.' char
//        - as netnum/nodenum separator
// 970310 - Removed extraneous functions
//
#include "winsnmp.inc"

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpGetLastError (IN HSNMP_SESSION hSession)
{
	DWORD nSes;

	if (TaskData.hTask == 0)
	   return (SNMPAPI_NOT_INITIALIZED);
	nSes = HandleToUlong(hSession) - 1;
	if (snmpValidTableEntry(&SessDescr, nSes))
	{
		LPSESSION pSession = snmpGetTableEntry(&SessDescr, nSes);
		return pSession->nLastError;
	}
	else
	   return (TaskData.nLastError);
} // end_SnmpGetLastError

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpStrToOid (IN LPCSTR string,
                 OUT smiLPOID dstOID)
{
smiUINT32 i;
smiUINT32 compIdx;
SNMPAPI_STATUS lError;
CHAR c;
LPSTR pSep;

// Must be initialized
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }

// use __try, __except to figure out if 'string' is a
// valid pointer. We cannot use IsBadReadPtr() here, as far as
// we have no idea for how many octets we should look.
__try
{
    smiUINT32 sLen;

    sLen = strlen(string);
    if (sLen == 0 || sLen >= MAXOBJIDSTRSIZE)
    {
        lError = SNMPAPI_OID_INVALID;
        goto ERROR_OUT;
    }
}
__except(EXCEPTION_EXECUTE_HANDLER)
{
    lError = SNMPAPI_ALLOC_ERROR;
        goto ERROR_OUT;
}

// see if the dstOID pointer provided by the caller points to 
// a valid memory range. If null is provided, there is nothing
// the API was requested to do!
if (IsBadWritePtr (dstOID, sizeof(smiOID)))
{
   lError = (dstOID == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
}

// Ignore initial '.' in string (UNIX-ism)
if (string[0] == '.')
    string++;

// figure out how many components this OID has
// count the number of '.' in the string. The OID should 
// contain this count + 1 components
dstOID->len = 0;
pSep = (LPSTR)string;
while((pSep = strchr(pSep, '.')) != NULL)
{
    pSep++;
    dstOID->len++;
}
dstOID->len++;

// don't allow less than 2 components
if (dstOID->len < 2)
{
    lError = SNMPAPI_OID_INVALID;
    goto ERROR_OUT;
}

// allocate memory for holding the numeric OID components
// this should be released by the caller, through 'SnmpFreeDescriptor()'
dstOID->ptr = (smiLPUINT32)GlobalAlloc(GPTR, dstOID->len * sizeof(smiUINT32));
if (dstOID->ptr == NULL)
{
    lError = SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
}

SetLastError(ERROR_SUCCESS);
compIdx = 0;
// when entering the loop, 'string' doesn't have a heading '.'
// NOTE: 123. will be accepted as 123.0
//       (123..  a12.3.4  1234....5.6) are considered as invalid OIDs instead
//        of truncated to (123.0   0   1234.0).
while (*string != '\0')
{
    dstOID->ptr[compIdx++] = strtoul(string, &pSep, 10);

    // if one of the components was overflowing, release the memory and bail out.
    if (GetLastError() != ERROR_SUCCESS)
    {
        lError = SNMPAPI_OID_INVALID;
        GlobalFree(dstOID->ptr);
        dstOID->ptr = NULL;
        goto ERROR_OUT;
    }

    // if strtoul did not make any progress on the string (two successive dots)
    // or it was blocked on something else than a separator or null-termination, then
    // there was an error. The OID is invalid. API return failure
    if (pSep == string ||
        (*pSep != '.' && *pSep != '\0'))
    {
        lError =  SNMPAPI_OID_INVALID; // invalid char in sequence
        if (GlobalFree (dstOID->ptr))  // returns not-NULL on error
        {
            lError = SNMPAPI_OTHER_ERROR;
            goto ERROR_OUT;
        }
        dstOID->ptr = NULL;
        dstOID->len = 0;
        goto ERROR_OUT;                                                                
    }

    // pSep can point only to '.' or '\0'
    if (*pSep == '.')
        pSep++;

    // restart with string from this point
    string = pSep;
}

if (dstOID->len < 2)
{
    GlobalFree(dstOID->ptr);
    dstOID->ptr = NULL;
    lError = SNMPAPI_OID_INVALID;
    goto ERROR_OUT;
}

return dstOID->len;

ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpStrToOid()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpOidToStr (IN smiLPCOID srcOID,
                 IN smiUINT32 strLen,
                 OUT LPSTR strPtr)
{
SNMPAPI_STATUS lError;
smiUINT32 retLen = 0;      // used for successful return
smiUINT32 oidIdx = 0;      // max subids is 128
smiUINT32 tmpLen;          // used for size of decoded string (with '.')
LPSTR tmpPtr = strPtr;     // used for advancing strPtr
char tmpBuf[16];           // room for 1 32-bit decode and '.'
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }

if (!strLen)
   {
   lError = SNMPAPI_SIZE_INVALID;
   goto ERROR_OUT;
   }

if (IsBadReadPtr(srcOID, sizeof(smiOID)) ||
    IsBadWritePtr(strPtr, strLen))
   {
    lError = (strPtr == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
   }

if (srcOID->len == 0 || srcOID->len > 128 ||
    IsBadReadPtr (srcOID->ptr, srcOID->len * sizeof(smiUINT32)))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }

while (oidIdx < srcOID->len)
   {
   _ultoa (srcOID->ptr[oidIdx++], tmpBuf, 10);
   lstrcat (tmpBuf, ".");
   tmpLen = lstrlen (tmpBuf);
   if (strLen < (tmpLen + 1))
      {
      tmpBuf[strLen] = '\0';
      lstrcpy (tmpPtr, tmpBuf);
      lError = SNMPAPI_OUTPUT_TRUNCATED;
      goto ERROR_OUT;
      }
   lstrcpy (tmpPtr, tmpBuf);
   strLen -= tmpLen;
   tmpPtr += tmpLen;
   retLen += tmpLen;
   }  // end_while
*(--tmpPtr) = '\0';
return (retLen);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpOidToStr

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpOidCopy (IN smiLPCOID srcOID,
                OUT smiLPOID dstOID)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (IsBadReadPtr (srcOID, sizeof(smiOID)) ||
    IsBadReadPtr (srcOID->ptr, srcOID->len) ||
    IsBadWritePtr (dstOID, sizeof(smiOID)))
   {
   lError = (dstOID == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// Check input OID size
if ((srcOID->len == 0) ||(srcOID->len > MAXOBJIDSIZE))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }
// Using dstOID-> temporarily for byte count
dstOID->len = srcOID->len * sizeof(smiUINT32);
// App must free following alloc via SnmpFreeDescriptor()
if (!(dstOID->ptr = (smiLPUINT32)GlobalAlloc (GPTR, dstOID->len)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
CopyMemory (dstOID->ptr, srcOID->ptr, dstOID->len);
// Now make dstOID->len mean the right thing
dstOID->len = srcOID->len;
return (dstOID->len);
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpOidCopy()

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpFreeDescriptor (IN smiUINT32 syntax,
                       IN smiLPOPAQUE ptr)
{
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!syntax || !ptr || !ptr->ptr)
   {
   lError = SNMPAPI_OPERATION_INVALID;
   goto ERROR_OUT;
   }
switch (syntax)
   {
   case SNMP_SYNTAX_OCTETS:
   case SNMP_SYNTAX_IPADDR:
   case SNMP_SYNTAX_OPAQUE:
   case SNMP_SYNTAX_OID:
   if (GlobalFree (ptr->ptr)) // returns not-NULL on error
      {
      lError = SNMPAPI_OTHER_ERROR;
      goto ERROR_OUT;
      }
   ptr->ptr = NULL;
   ptr->len = 0;
   break;

   default:
   lError = SNMPAPI_SYNTAX_INVALID;
   goto ERROR_OUT;
   } // end_switch
return (SNMPAPI_SUCCESS);
//
ERROR_OUT:
return (SaveError (0, lError));
}  // end_SnmpFreeDescriptor

// SnmpOidCompare
//
// Re-worked by 3/17/95 BobN
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpOidCompare (IN smiLPCOID xOID,
                   IN smiLPCOID yOID,
                   IN smiUINT32 maxlen,
                   OUT smiLPINT result)
{
smiUINT32 i = 0;
smiUINT32 j = 0;
SNMPAPI_STATUS lError;
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (maxlen > MAXOBJIDSIZE)
   {
   lError = SNMPAPI_SIZE_INVALID;
   goto ERROR_OUT;
   }

if (IsBadReadPtr (xOID, sizeof(smiOID)) ||
    IsBadReadPtr (yOID, sizeof(smiOID)))
   {
   lError = SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }

if (IsBadReadPtr (xOID->ptr, xOID->len * sizeof(UINT)) ||
    IsBadReadPtr (yOID->ptr, yOID->len * sizeof(UINT)))
   {
   lError = SNMPAPI_OID_INVALID;
   goto ERROR_OUT;
   }

// Test input pointers for readability
if (IsBadWritePtr (result, sizeof(smiINT)))
    {
    lError = (result == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
    }

j = min(xOID->len, yOID->len);
if (maxlen) j = min(j, maxlen);
while (i < j)
   {
   if (*result = xOID->ptr[i] - yOID->ptr[i]) // deliberate assignment
      return (SNMPAPI_SUCCESS);               // not equal...got a winner!
   i++;
   }
if (j == maxlen)                              // asked for a limit
   return (SNMPAPI_SUCCESS);                  // and...got a draw!
*result = xOID->len - yOID->len;              // size matters!
return SNMPAPI_SUCCESS;
//
ERROR_OUT:
return (SaveError (0, lError));
} // end_SnmpOidCompare

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpEncodeMsg (IN HSNMP_SESSION hSession,
                  IN HSNMP_ENTITY hSrc,
                  IN HSNMP_ENTITY hDst,
                  IN HSNMP_CONTEXT hCtx,
                  IN HSNMP_PDU hPdu,
                  IN OUT smiLPOCTETS msgBufDesc)
{
smiUINT32 version = 0;
DWORD nCtx;
DWORD nPdu;
DWORD nVbl;
smiOCTETS tmpContext;
smiLPBYTE msgAddr = NULL;
smiUINT32 lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;
LPENTITY pEntSrc, pEntDst;
LPCTXT pCtxt;

// Basic error checks
if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// We have a valid session at this point...
lSession = hSession; // save it for possible error return
// Check for writable output buffer
if (IsBadWritePtr (msgBufDesc, sizeof(smiOCTETS)))
   {
   lError = (msgBufDesc == NULL) ? SNMPAPI_NOOP : SNMPAPI_ALLOC_ERROR;
   goto ERROR_OUT;
   }
// srcEntity not currently used
if (hSrc)
   {
    if (!snmpValidTableEntry(&EntsDescr, HandleToUlong(hSrc)-1))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
    pEntSrc = snmpGetTableEntry(&EntsDescr, HandleToUlong(hSrc)-1);
   }
// dstEntity is required for *accurate* msg version info
if (hDst)
   {
   if (!snmpValidTableEntry(&EntsDescr, HandleToUlong(hDst)-1))
      {
      lError = SNMPAPI_ENTITY_INVALID;
      goto ERROR_OUT;
      }
   pEntDst = snmpGetTableEntry(&EntsDescr, HandleToUlong(hDst)-1);
   version = pEntDst->version-1;
   }
nCtx = HandleToUlong(hCtx) - 1;
if (!snmpValidTableEntry(&CntxDescr, nCtx))
   {
   lError = SNMPAPI_CONTEXT_INVALID;
   goto ERROR_OUT;
   }
pCtxt = snmpGetTableEntry(&CntxDescr, nCtx);

nPdu = HandleToUlong(hPdu) - 1;
if (!snmpValidTableEntry(&PDUsDescr, nPdu))
   {
ERROR_PDU:
   lError = SNMPAPI_PDU_INVALID;
   goto ERROR_OUT;
   }
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

// Necessary PDU data checks
nVbl = HandleToUlong(pPdu->VBL);
if (!snmpValidTableEntry(&VBLsDescr, nVbl-1))
   goto ERROR_PDU;
// Check out for SNMPv1 Trap PDU type...uses different PDU structure!
// ???
// Check for SNMPv2c PDU types
if (pPdu->type == SNMP_PDU_TRAP ||
    pPdu->type == SNMP_PDU_INFORM)
   version = 1;
// Now Build it
tmpContext.len = pCtxt->commLen;
tmpContext.ptr = pCtxt->commStr;
if (!(BuildMessage (version, &tmpContext,
                    pPdu, pPdu->appReqId,
                    &msgAddr, &msgBufDesc->len)))
   goto ERROR_PDU;
// Copy Snmp message to caller's buffer...
// App must free following alloc via SnmpFreeDescriptor()
if (!(msgBufDesc->ptr = (smiLPBYTE)GlobalAlloc (GPTR, msgBufDesc->len)))
   lError = SNMPAPI_ALLOC_ERROR;
else // SUCCESS
   CopyMemory (msgBufDesc->ptr, msgAddr, msgBufDesc->len);
ERROR_OUT:
// Clean up
if (msgAddr)
   GlobalFree (msgAddr);
if (lError == SNMPAPI_SUCCESS)
   return (msgBufDesc->len);
else // Failure cases
   return (SaveError (lSession, lError));
}

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpDecodeMsg (IN HSNMP_SESSION hSession,
                  OUT LPHSNMP_ENTITY hSrc,
                  OUT LPHSNMP_ENTITY hDst,
                  OUT LPHSNMP_CONTEXT hCtx,
                  OUT LPHSNMP_PDU hPdu,
                  IN smiLPCOCTETS msgPtr)
{
DWORD nPdu;
smiLPOCTETS community;
smiUINT32 version;
SNMPAPI_STATUS lError = SNMPAPI_SUCCESS;
HSNMP_SESSION lSession = 0;
LPPDUS pPdu;

if (TaskData.hTask == 0)
   {
   lError = SNMPAPI_NOT_INITIALIZED;
   goto ERROR_OUT;
   }
if (!snmpValidTableEntry(&SessDescr, HandleToUlong(hSession)-1))
   {
   lError = SNMPAPI_SESSION_INVALID;
   goto ERROR_OUT;
   }
// Valid session...save for possible error return
lSession = hSession;

if (IsBadReadPtr(msgPtr, sizeof(smiOCTETS)) ||
    IsBadReadPtr(msgPtr->ptr, msgPtr->len))
{
    lError = SNMPAPI_ALLOC_ERROR;
    goto ERROR_OUT;
}

if (hSrc == NULL && hDst == NULL && hCtx == NULL && hPdu == NULL)
{
    lError = SNMPAPI_NOOP;
    goto ERROR_OUT;
}

if ((hDst != NULL && IsBadWritePtr(hDst, sizeof(HSNMP_ENTITY))) ||
    (hSrc != NULL && IsBadWritePtr(hSrc, sizeof(HSNMP_ENTITY))))
{
    lError = SNMPAPI_ENTITY_INVALID;
    goto ERROR_OUT;
}

if (hCtx != NULL && IsBadWritePtr(hCtx, sizeof(HSNMP_CONTEXT)))
{
    lError = SNMPAPI_CONTEXT_INVALID;
    goto ERROR_OUT;
}

if (IsBadWritePtr(hPdu, sizeof(HSNMP_PDU)))
{
    lError = SNMPAPI_PDU_INVALID;
    goto ERROR_OUT;
}

EnterCriticalSection (&cs_PDU);
lError = snmpAllocTableEntry(&PDUsDescr, &nPdu);
if (lError != SNMPAPI_SUCCESS)
    goto ERROR_PRECHECK;
pPdu = snmpGetTableEntry(&PDUsDescr, nPdu);

if (ParseMessage (msgPtr->ptr, msgPtr->len, &version, &community, pPdu))
   { // non-zero = some error code
   lError = SNMPAPI_MESSAGE_INVALID;
   SnmpFreePdu((HSNMP_PDU) ULongToPtr(nPdu+1));
   goto ERROR_PRECHECK;
   }
if (hDst != NULL) *hDst = 0;
if (hSrc != NULL) *hSrc = 0;
if (hCtx != NULL)
   {
   smiUINT32 nMode;
   EnterCriticalSection (&cs_XMODE);
   SnmpGetTranslateMode (&nMode);
   SnmpSetTranslateMode (SNMPAPI_UNTRANSLATED_V1);
   *hCtx = SnmpStrToContext (hSession, community);
   SnmpSetTranslateMode (nMode);
   LeaveCriticalSection (&cs_XMODE);
   }
FreeOctetString (community);
pPdu->Session  = hSession;
if (hPdu != NULL)
    *hPdu = (HSNMP_PDU) ULongToPtr(nPdu+1);
else
    SnmpFreePdu((HSNMP_PDU) ULongToPtr(nPdu+1));

ERROR_PRECHECK:
LeaveCriticalSection (&cs_PDU);
if (lError == SNMPAPI_SUCCESS)
{
   SaveError(lSession, lError);
   return (msgPtr->len);
}

ERROR_OUT:
return (SaveError (lSession, lError));
} // end_SnmpDecodeMsg()

#define NETLEN  4
#define NODELEN 6
char *cHexDigits = "0123456789ABCDEF";
SNMPAPI_STATUS SNMPAPI_CALL
   SnmpStrToIpxAddress (LPCSTR str, LPBYTE netnum, LPBYTE nodenum)
{
LPSTR netPtr, nodePtr, pStr;
DWORD i, j;
char tmpStr[24];
BYTE c1, c2;
if (!str || !netnum || !nodenum)
   return (SNMPAPI_FAILURE);
lstrcpy (tmpStr, str);
netPtr = strtok (tmpStr, "-:.");
if (netPtr == NULL)
   return (SNMPAPI_FAILURE);
if (lstrlen (netPtr) != NETLEN*2)
   return (SNMPAPI_FAILURE);
nodePtr = netPtr + (NETLEN*2) + 1;
if (lstrlen (nodePtr) != NODELEN*2)
   return (SNMPAPI_FAILURE);
_strupr (netPtr);
for (i = 0, j = 0; j < NETLEN; j++)
   {
   pStr = strchr (cHexDigits, netPtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c1 = (BYTE)(pStr - cHexDigits);
   pStr = strchr (cHexDigits, netPtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c2 = (BYTE)(pStr - cHexDigits);
   netnum[j] = c2 | c1 << 4;
   }
_strupr (nodePtr);
for (i = 0, j = 0; j < NODELEN; j++)
   {
   pStr = strchr (cHexDigits, nodePtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c1 = (BYTE)(pStr - cHexDigits);
   pStr = strchr (cHexDigits, nodePtr[i++]);
   if (pStr == NULL)
       return (SNMPAPI_FAILURE);
   c2 = (BYTE)(pStr - cHexDigits);
   nodenum[j] = c2 | c1 << 4;
   }
return (SNMPAPI_SUCCESS);
}

SNMPAPI_STATUS SNMPAPI_CALL
   SnmpIpxAddressToStr (LPBYTE netnum, LPBYTE nodenum, LPSTR str)
{
DWORD i, j;
for (i = 0, j = 0; i < NETLEN; i++)
   {
   str[j++] = cHexDigits[(netnum[i] & 0xF0) >> 4];
   str[j++] = cHexDigits[netnum[i] & 0x0F];
   }
str[j++] = ':';
for (i = 0; i < NODELEN; i++)
   {
   str[j++] = cHexDigits[(nodenum[i] & 0xF0) >> 4];
   str[j++] = cHexDigits[nodenum[i] & 0x0F];
   }
str[j] = '\0';
return (SNMPAPI_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\mibs\makefile.inc ===
MIBCC=mibcc.exe

# wins.mib must come before dhcp.mib
#
MIB_COMPONENTS=\
    accserv.mib \
    acs.mib	\
    authserv.mib \
    wins.mib \
    dhcp.mib \
    ftp.mib \
    gopherd.mib \
    hostmib.mib \
    http.mib \
    igmpv2.mib \
    inetsrv.mib \
    ipforwd.mib \
    lmmib2.mib \
    mcastmib.mib \
    mib_ii.mib \
    mipx.mib \
    mripsap.mib \
    msft.mib \
    printmib.mib \

$(O)\mib.bin: $(MIB_COMPONENTS)
    $(MIBCC) -o$(O)\mib.bin $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\mibs\dummy.c ===
/**
    This is just a dummy C file for the compiler to have
**/

void dummy_main(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\inc\winsnmpn.h ===
#ifndef _INC_WINSNMPN
#define _INC_WINSNMPN
//
// winsnmpn.h
//
// Private include file for ACE*COMM's
// NetPlus Win32 WinSNMP implementation
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
// 970310 - Removed NPWSNMPSTATUSREPORT structure
//        - Added localAddress to TaskData
//        - Removed unused #defines
//
// 970417 - Added OSVERSIONINFO to TaskData
//
#include <winsock.h>
#include <wsipx.h>
//
#ifdef SOLARIS
#define THR_FLAGS THR_BOUND|THR_DETACHED
#define THR_TYPE LPVOID
#else // Win32
#define THR_TYPE DWORD
#endif // SOLARIS
//
#define DEFSESSIONS           10 // just for testing -- should be rolled back to 10
#define DEFVBLS               100 // just for testing -- should be rolled back to 100
#define DEFPDUS               100 // just for testing -- should be rolled back to 100
#define DEFENTITIES           100 // just for testing -- should be rolled back to 100
#define DEFCONTEXTS           100 // just for testing -- should be rolled back to 100
#define DEFMSGS               100 // just for testing -- should be rolled back to 100
#define DEFTRAPS              10 // just for testing -- should be rolled back to 10
#define DEFAGENTS             5 // just for testing -- should be rolled back to 5

#define MAXCENTISECONDS       429496729U
#define MAXMILLISECONDS       4294967295U
#define DEFTIMEOUT            300      // centisecs = 3 seconds
#define DEFRETRY              3
#define IP_SNMP_PORT          161
#define IP_TRAP_PORT          162
#define IPX_SNMP_PORT         36879
#define IPX_TRAP_PORT         36880
#define SNMPTRAPPIPE          "\\\\.\\PIPE\\MGMTAPI"
#define TRAPSERVERTIMEOUT     30000     // millisecs = 30 seconds
#define NP_WSX95              "NP_WSX95"
#define NP_WSX95_EXE          "NP_WSX95.EXE"
#define WSNMP_TRAPS_ON        WM_USER + 12
#define WSNMP_TRAPS_OFF       WM_USER + 13
#define LOOPBACK_ADDR         "127.0.0.1"
#define MAXTRAPIDS            20    // Max sub-ids in trap matches
#define MAX_FRIEND_NAME_LEN   31
#define MAX_CONTEXT_LEN       256
#define MAX_HOSTNAME          64
#define AF_INET_ADDR_SIZE     4
#define AF_IPX_ADDR_SIZE      10
#define NP_SEND               1 // "To send" msg status
#define NP_SENT               2 // "Sent" msg status
#define NP_RCVD               3 // "Received" msg status
#define NP_READY              4 // "Ready" for pickup by app
#define NP_EXPIRED            5 // "Timed out" for thrNotify
#define NP_REQUEST            1 // Agent request/response msg type
#define NP_RESPONSE           2 // Mgr request/response msg type
#define NP_TRAP               3 // Trap msg type
#define MAX_PENDING_WAIT      1000 // Trap service status period

typedef union
   {
   SOCKADDR_IN  inet;
   SOCKADDR_IPX ipx;
   } SAS, *LPSAS;

typedef struct _VB
   {
   smiOID      name;
   smiVALUE    value;
   smiINT32    data_length;
   struct _VB  *next_var;
   } VARBIND, *LPVARBIND;

typedef struct
   {
   smiOID         enterprise;
   smiIPADDR      agent_addr;
   smiINT32       generic_trap;
   smiINT32       specific_trap;
   smiTIMETICKS   time_ticks;
   } V1TRAP, *LPV1TRAP;

typedef struct _tdBuffer       // SNMP Buffer Descriptor
   {
   struct _tdBuffer *next;     // Link to the next buffer of the table
   struct _tdBuffer *prev;     // Link to the previous buffer of the table
   DWORD  Used;                // Number of entries in use in this buffer
   } SNMPBD, FAR *LPSNMPBD;

typedef struct                 // SNMP Table Descriptor
{
   DWORD    Used;              // Number currently ulilized
   DWORD    Allocated;         // Number currently allocated
   DWORD    BlocksToAdd;       // Incremented in chunks of this many records
   DWORD    BlockSize;         // Record size (bytes)
   LPSNMPBD HeadBuffer;        // circular list to the buffers of the table
                               // 'HeadBuffer' points to a SNMPBD structure suffixed with
                               // 'BlocksToAdd' blocks of size 'BlockSize' each
   } SNMPTD, FAR *LPSNMPTD;

typedef struct
   {
   HSNMP_SESSION  hTask;
   smiUINT32      nTranslateMode;
   smiUINT32      nRetransmitMode;
   DWORD          localAddress;
   SNMPAPI_STATUS conveyAddress; // SNMPAPI_ON/OFF
   HANDLE         timerThread;
   SOCKET         ipSock;
   HANDLE         ipThread;
   SOCKET         ipxSock;
   HANDLE         ipxThread;
   SOCKET         trapSock;   // Win95-only
   HANDLE         trapThread;
   HWND           trapWnd;    // Win95-only
   HANDLE         trapPipe;   // NT-only
   OVERLAPPED     trapOl;     // for overlapped pipe I/O, bug# 270672
   HANDLE         trapEvent;  // for termination of thrTrap
   smiUINT32      nLastReqId;
   SNMPAPI_STATUS nLastError;
   OSVERSIONINFO  sEnv;       // Operating System
   } TASK, FAR *LPTASK;

typedef struct
   {
   HSNMP_SESSION    nTask;
   HWND             hWnd;
   DWORD            wMsg;
   SNMPAPI_CALLBACK fCallBack;
   LPVOID           lpClientData;
   HANDLE           thrEvent;
   HANDLE           thrHandle;
   DWORD            thrCount;
   SNMPAPI_STATUS   nLastError;
   } SESSION, FAR *LPSESSION;                      
typedef struct
   {
   HSNMP_SESSION  Session;
   smiINT32       type;
   smiINT32       appReqId;
   smiINT32       errStatus;
   smiINT32       errIndex;
   HSNMP_VBL      VBL;
   LPVARBIND      VBL_addr;
   LPV1TRAP       v1Trap;
   } PDUS, FAR *LPPDUS;
typedef struct
   {
   HSNMP_SESSION  Session;
   LPVARBIND      vbList;
   } VBLS, FAR *LPVBLS;
typedef struct
   {
   HSNMP_SESSION  Session;
   smiUINT32      refCount;
   smiUINT32      version;
   smiBYTE        name[MAX_FRIEND_NAME_LEN+1];  // friendly name
   smiTIMETICKS   nPolicyTimeout;               // centiseconds
   smiTIMETICKS   nActualTimeout;               // centiseconds
   smiUINT32      nPolicyRetry;
   smiUINT32      nActualRetry;
   smiUINT32      Agent;
   SAS            addr;
   } ENTITY, FAR *LPENTITY;
typedef struct
   {
   HSNMP_SESSION  Session;
   smiUINT32      refCount;
   smiUINT32      version;
   smiBYTE        name[MAX_FRIEND_NAME_LEN+1];  // friendly name
   smiUINT32      commLen;                      // len of commStr
   smiBYTE        commStr[MAX_CONTEXT_LEN];     // raw value
   } CTXT, FAR *LPCTXT;
typedef struct
   {
   HSNMP_SESSION  Session;
   DWORD          Status;        // NP_SEND|SENT|RCVD|READY
   DWORD          Type;          // PDU type
   HSNMP_ENTITY   agentEntity;
   HSNMP_ENTITY   ourEntity;
   HSNMP_CONTEXT  Context;
   smiUINT32      dllReqId;
   smiUINT32      appReqId;
   smiUINT32      nRetransmitMode;
   smiUINT32      Ticks;   // Msg sent time
   smiUINT32      Wait;    // Msg timeout interval (millisecs)
   smiUINT32      Tries;   // Msg retry count
   smiLPBYTE      Addr;
   smiUINT32      Size;
   SAS            Host;
   smiUINT32      PolicyTries; // the Tries counter started from here
   } SNMPMSG, FAR *LPSNMPMSG;
typedef struct
   {
   HSNMP_SESSION  Session;
   HSNMP_ENTITY   ourEntity;
   HSNMP_ENTITY   agentEntity;
   HSNMP_CONTEXT  Context;
   smiOID         notification;
   smiUINT32      notificationValue[MAXTRAPIDS];
   } TRAPNOTICE, FAR *LPTRAPNOTICE;
typedef struct
   {
   HSNMP_SESSION  Session;
   HSNMP_ENTITY   Entity;
   SOCKET         Socket;
   HANDLE         Thread;
   } AGENT, FAR *LPAGENT;

#endif // _INC_WINSNMPN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\inc\pragmas.h ===
#ifndef _PRAGMAS_H_
#define _PRAGMAS_H_
#pragma warning (disable : 4001) // single  line comments
//
// pragma.h
//
// Utility include for NetPlus WinSNMP
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
#define __export
#define WAKRELVER "Release 3.MS"
#define WAKRELDATE "19970221" 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\exe\snmptrap.c ===
// snmptrap.c
//
// Original Microsoft code modified by ACE*COMM
// for use with WSNMP32.DLL and other trap receiving
// clients, per contract.
//
// Bob Natale, ACE*COMM (bnatale@acecomm.com)
// For NT v5 Beta, v970228
// Additional enhancements planned.
//
// This version of SNMPTRAP has no dependencies
// on either MGMTAPI.DLL or WSNMP32.DLL.
//
// WinSNMP clients use the SnmpRegister() function.
//
// Other clients will need to match the following
// values and structures:
//
//    SNMP_TRAP structure
//    SNMPTRAPPIPE name
//    TRAPBUFSIZE value
//
// Change log:
// ------------------------------------------------
// 4.0.1381.3  Apr 8, 1998 Bob Natale
//
// 1.  Re-worked the trap port monitoring thread into
//     two threads...one for IP and one for IPX, to
//     comply with WinSock v2's restrictions against
//     multi-protocol select().
//
// 2.  General clean-up/streamlining wrt "legacy" code
//     from original MS version...more to do here, esp.
//     wrt error handling code that does not do anything.
// ------------------------------------------------
// 4.0.1381.4  Apr. 10, 1998 Bob Natale
//
// 1.  Replaced mutex calls with critical_sectin calls.
//
// 2.  Cleaned out some dead code (removed commented out code)
// ------------------------------------------------
// Jan. 2, 2001 Frank Li
// 1. remove TerminateThread
// 2. add debug build loggings
// ------------------------------------------------
#include <windows.h>
#include <winsock.h>
#include <wsipx.h>
#include <process.h>

#ifdef DBG // include files for debug trace only
#include <stdio.h>
#include <time.h>
#endif

//--------------------------- PRIVATE VARIABLES -----------------------------
#define SNMPMGRTRAPPIPE "\\\\.\\PIPE\\MGMTAPI"
#define MAX_OUT_BUFS    16
#define TRAPBUFSIZE     4096
#define IP_TRAP_PORT    162
#define IPX_TRAP_PORT   36880

//
// constants added to allocate trap buffer for fixing trap data of length 
// > 8192 bytes. Here is the buffer allocation scheme based on the common
// cases that trap data sizes are less than 4-KBytes:
// 1. LargeTrap 
//    if (trap data size >= 8192 bytes), allocate MAX_UDP_SIZE sized buffer
// 2. MediumTrap
//    if (trap data size <= 4096 bytes), allocate FOUR_K_BUF_SIZE sized buffer
// 3. SmallTrap
//    if (4096 < trap data size < 8192), allocate just enough buffer size.
// Note:
// - when LargeTrap is received, the allocated buffer will stay for a time of
//   MAXUDPLEN_BUFFER_TIME from the last LargeTrap received.
// - Once MediumTrap is received, subsequent SmallTrap will reuse the
//   last MediumTrap allocated buffer. 
//
#define MAX_UDP_SIZE    (65535-8)  // max udp len - 8bytes udp header
#define MAX_FIONREAD_UDP_SIZE 8192 // max winsock FIONREAD reported size (8kB)
#define FOUR_K_BUF_SIZE   4096       // buffer of 4-KBytes in size
#define MAXUDPLEN_BUFFER_TIME (2*60*1000)  // max. 2 mins to keep the
                                           // last allocated large buffer.   
// ******** INITIALIZE A LIST HEAD ********
#define ll_init(head) (head)->next = (head)->prev = (head);
// ******** TEST A LIST FOR EMPTY ********
#define ll_empt(head) ( ((head)->next) == (head) )
// ******** Get ptr to next entry ********
#define ll_next(item,head)\
( (ll_node *)(item)->next == (head) ? 0 : \
(ll_node *)(item)->next )
// ******** Get ptr to prev entry ********
#define ll_prev(item)\
( (ll_node *)(item)->prev )
// ******** ADD AN ITEM TO THE END OF A LIST ********
#define ll_adde(item,head)\
   {\
   ll_node *pred = (head)->prev;\
   ((ll_node *)(item))->next = (head);\
   ((ll_node *)(item))->prev = pred;\
   (pred)->next = ((ll_node *)(item));\
   (head)->prev = ((ll_node *)(item));\
   }
// ******** REMOVE AN ITEM FROM A LIST ********
#define ll_rmv(item)\
   {\
   ll_node *pred = ((ll_node *)(item))->prev;\
   ll_node *succ = ((ll_node *)(item))->next;\
   pred->next = succ;\
   succ->prev = pred;\
   }
// ******** List head/node ********
typedef struct ll_s
   { // linked list structure
   struct  ll_s *next;  // next node
   struct  ll_s *prev;  // prev. node
   } ll_node;           // linked list node
typedef struct
   {// shared by server trap thread and pipe thread
   ll_node  links;
   HANDLE   hPipe;
   } svrPipeListEntry;
typedef struct
   {
   SOCKADDR Addr;              
   int      AddrLen;           
   UINT     TrapBufSz;
   char     TrapBuf[TRAPBUFSIZE];   // the size of this array should match the size of the structure
                                    // defined in wsnmp_no.c!!!
   }        SNMP_TRAP, *PSNMP_TRAP;
typedef struct
{
    SOCKET s;
    OVERLAPPED ol;
} TRAP_THRD_CONTEXT, *PTRAP_THRD_CONTEXT;

HANDLE hExitEvent = NULL;
LPCTSTR svcName = "SNMPTRAP";
SERVICE_STATUS_HANDLE hService = 0;
SERVICE_STATUS status =
  {SERVICE_WIN32, SERVICE_STOPPED, SERVICE_ACCEPT_STOP, NO_ERROR, 0, 0, 0};
SOCKET ipSock = INVALID_SOCKET;
SOCKET ipxSock = INVALID_SOCKET;
HANDLE ipThread = NULL;
HANDLE ipxThread = NULL;
CRITICAL_SECTION cs_PIPELIST;
ll_node *pSvrPipeListHead = NULL;

// global variables added to remove the TerminateThread call
OVERLAPPED g_ol; // overlapped struct for svrPipeThread
TRAP_THRD_CONTEXT g_ipThreadContext;  // context for ip svrTrapThread
TRAP_THRD_CONTEXT g_ipxThreadContext; // context for ipx svrTrapThread

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// SNMPTRAP Debugging Prototypes                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#if DBG
VOID
WINAPI
SnmpTrapDbgPrint(
    IN LPSTR szFormat,
    IN ...
    );
#define SNMPTRAPDBG(_x_)                    SnmpTrapDbgPrint _x_
#else
#define SNMPTRAPDBG(_x_)
#endif

//--------------------------- PRIVATE PROTOTYPES ----------------------------
DWORD WINAPI svrTrapThread (IN OUT LPVOID threadParam);
DWORD WINAPI svrPipeThread (IN LPVOID threadParam);
VOID WINAPI svcHandlerFunction (IN DWORD dwControl);
VOID WINAPI svcMainFunction (IN DWORD dwNumServicesArgs,
                             IN LPSTR *lpServiceArgVectors);
void FreeSvrPipeEntryList(IN ll_node* head);

//--------------------------- PRIVATE PROCEDURES ----------------------------
VOID WINAPI svcHandlerFunction (IN DWORD dwControl)
{
    if (dwControl == SERVICE_CONTROL_STOP)
    {
        status.dwCurrentState = SERVICE_STOP_PENDING;
        status.dwCheckPoint++;
        status.dwWaitHint = 45000;
        if (!SetServiceStatus(hService, &status))
            exit(1);
        // set event causing trap thread to terminate
        if (!SetEvent(hExitEvent))
        {
            status.dwCurrentState = SERVICE_STOPPED;
            status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
            status.dwServiceSpecificExitCode = 1; // OPENISSUE - svc err code
            status.dwCheckPoint = 0;
            status.dwWaitHint = 0;
            // We are exiting in any case, so ignore any error...
            SetServiceStatus (hService, &status);
            exit(1);
        }
    }
    else
    //   dwControl == SERVICE_CONTROL_INTERROGATE
    //   dwControl == SERVICE_CONTROL_PAUSE
    //   dwControl == SERVICE_CONTROL_CONTINUE
    //   dwControl == <anything else>
    {
        if (status.dwCurrentState == SERVICE_STOP_PENDING ||
            status.dwCurrentState == SERVICE_START_PENDING)
            status.dwCheckPoint++;
        if (!SetServiceStatus (hService, &status))
            exit(1);
    }
} // end_svcHandlerFunction()

VOID WINAPI svcMainFunction (IN DWORD dwNumServicesArgs,
                             IN LPSTR *lpServiceArgVectors)
{
    WSADATA WinSockData;
    HANDLE  hPipeThread = NULL;
    DWORD   dwThreadId;
    //---------------------------------------------------------------------
    hService = RegisterServiceCtrlHandler (svcName, svcHandlerFunction);
    if (hService == 0)
    {
        status.dwCurrentState = SERVICE_STOPPED;
        status.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        status.dwServiceSpecificExitCode = 2; // OPENISSUE - svc err code
        status.dwCheckPoint = 0;
        status.dwWaitHint = 0;
        // We are exiting in any case, so ignore any error...
        SetServiceStatus (hService, &status);
        exit(1);
    }
    status.dwCurrentState = SERVICE_START_PENDING;
    status.dwWaitHint = 20000;

    if (!SetServiceStatus(hService, &status))
        exit(1);

    __try
    {
        InitializeCriticalSection (&cs_PIPELIST);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        exit(1);
    }

    memset(&g_ipThreadContext.ol, 0, sizeof(g_ipThreadContext.ol));
    memset(&g_ipxThreadContext.ol, 0, sizeof(g_ipxThreadContext.ol));

    if (WSAStartup ((WORD)0x0101, &WinSockData))
        goto CLOSE_OUT; // WinSock startup failure


    // allocate linked-list header for client received traps
    if ((pSvrPipeListHead = (ll_node *)GlobalAlloc (GPTR, sizeof(ll_node))) == NULL)
        goto CLOSE_OUT;
    ll_init(pSvrPipeListHead);
    if ((hPipeThread = (HANDLE)_beginthreadex
                    (NULL, 0, svrPipeThread, NULL, 0, &dwThreadId)) == 0)
        goto CLOSE_OUT;
    
    //-----------------------------------------------------------------------------------
    //CHECK_IP:
    ipSock = socket (AF_INET, SOCK_DGRAM, 0);
    if (ipSock != INVALID_SOCKET)
    {
        struct sockaddr_in localAddress_in;
        struct servent *serv;
        ZeroMemory (&localAddress_in, sizeof(localAddress_in));
        localAddress_in.sin_family = AF_INET;
        if ((serv = getservbyname ("snmp-trap", "udp")) == NULL)
            localAddress_in.sin_port = htons (IP_TRAP_PORT);
        else
            localAddress_in.sin_port = (SHORT)serv->s_port;
        localAddress_in.sin_addr.s_addr = htonl (INADDR_ANY);
        if (bind (ipSock, (LPSOCKADDR)&localAddress_in, sizeof(localAddress_in)) != SOCKET_ERROR)
        {
            g_ipThreadContext.s = ipSock;
            // init the overlapped struct with manual reset non-signaled event
            g_ipThreadContext.ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == g_ipThreadContext.ol.hEvent)    
                goto CLOSE_OUT;    
            
            ipThread = (HANDLE)_beginthreadex
                    (NULL, 0, svrTrapThread, (LPVOID)&g_ipThreadContext, 0, &dwThreadId);
        }
    }
    //-----------------------------------------------------------------------------------
    //CHECK_IPX:
    ipxSock = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
    if (ipxSock != INVALID_SOCKET)
    {
        struct sockaddr_ipx localAddress_ipx;
        ZeroMemory (&localAddress_ipx, sizeof(localAddress_ipx));
        localAddress_ipx.sa_family = AF_IPX;
        localAddress_ipx.sa_socket = htons (IPX_TRAP_PORT);
        if (bind (ipxSock, (LPSOCKADDR)&localAddress_ipx, sizeof(localAddress_ipx)) != SOCKET_ERROR)
        {
            g_ipxThreadContext.s = ipxSock;
            // init the overlapped struct with manual reset non-signaled event
            g_ipxThreadContext.ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == g_ipxThreadContext.ol.hEvent)
                goto CLOSE_OUT;    
             
            ipxThread = (HANDLE)_beginthreadex
                    (NULL, 0, svrTrapThread, (LPVOID)&g_ipxThreadContext, 0, &dwThreadId);
        }
    }
    //-----------------------------------------------------------------------------------
    // We are ready to listen for traps...
    status.dwCurrentState = SERVICE_RUNNING;
    status.dwCheckPoint   = 0;
    status.dwWaitHint     = 0;
    if (!SetServiceStatus(hService, &status))
        goto CLOSE_OUT;
    WaitForSingleObject (hExitEvent, INFINITE);
    //-----------------------------------------------------------------------------------
CLOSE_OUT:
    // make sure we can bail out if we are here because of goto statements above
    SetEvent(hExitEvent); 
    
    if (hPipeThread != NULL)
    {
        SNMPTRAPDBG(("svcMainFunction: enter SetEvent g_ol.hEvent.\n"));
        SetEvent(g_ol.hEvent); // signal to terminate the svrPipeThread thread
        WaitForSingleObject (hPipeThread, INFINITE);
        SNMPTRAPDBG(("svcMainFunction: WaitForSingleObject hPipeThread INFINITE done.\n"));
        CloseHandle (hPipeThread);
    }
    if (ipSock != INVALID_SOCKET)
        closesocket (ipSock); // unblock any socket call
    if (ipThread != NULL)
    {
        SNMPTRAPDBG(("svcMainFunction: enter SetEvent g_ipThreadContext.ol.hEvent.\n"));
        SetEvent(g_ipThreadContext.ol.hEvent); // signal to terminate thread
        WaitForSingleObject (ipThread, INFINITE);
        CloseHandle (ipThread);
    }
    if (g_ipThreadContext.ol.hEvent)
        CloseHandle(g_ipThreadContext.ol.hEvent);

    if (ipxSock != INVALID_SOCKET)
        closesocket (ipxSock); // unblock any socket call
    if (ipxThread != NULL)
    {
        SNMPTRAPDBG(("svcMainFunction: enter SetEvent g_ipxThreadContext.ol.hEvent.\n"));
        SetEvent(g_ipxThreadContext.ol.hEvent); // signal to terminate thread
        WaitForSingleObject (ipxThread, INFINITE);
        CloseHandle (ipxThread);
    }
    if (g_ipxThreadContext.ol.hEvent)
        CloseHandle(g_ipxThreadContext.ol.hEvent);

    EnterCriticalSection (&cs_PIPELIST);
    if (pSvrPipeListHead != NULL)
    {
        FreeSvrPipeEntryList(pSvrPipeListHead);
        pSvrPipeListHead = NULL;
    }
    LeaveCriticalSection (&cs_PIPELIST);
    
    DeleteCriticalSection (&cs_PIPELIST);
    WSACleanup();
    
    status.dwCurrentState = SERVICE_STOPPED;
    status.dwCheckPoint = 0;
    status.dwWaitHint = 0;
    if (!SetServiceStatus(hService, &status))
        exit(1);
} // end_svcMainFunction()

//--------------------------- PUBLIC PROCEDURES -----------------------------
int __cdecl main ()
{
    BOOL fOk;
    OSVERSIONINFO osInfo;
    SERVICE_TABLE_ENTRY svcStartTable[2] =
    {
        {(LPTSTR)svcName, svcMainFunction},
        {NULL, NULL}
    };
    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    fOk = GetVersionEx (&osInfo);
    if (fOk && (osInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
    {   // create event to synchronize trap server shutdown
        hExitEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (NULL == hExitEvent)
        {
            exit(1);
        }
        // init the overlapped struct used by svrTrapThread
        // with manual reset non-signaled event
        memset(&g_ol, 0, sizeof(g_ol));
        g_ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (NULL == g_ol.hEvent)
        {
            CloseHandle(hExitEvent);
            exit(1);
        }
        // this call will not return until service stopped
        fOk = StartServiceCtrlDispatcher (svcStartTable);
        CloseHandle (hExitEvent);
        CloseHandle(g_ol.hEvent);
    }
    return fOk; 
} // end_main()

//
DWORD WINAPI svrTrapThread (LPVOID threadParam)
// This thread takes a SOCKET from the TRAP_THRD_CONTEXT parameter, 
// loops on select()
// for data in-coming over that socket, writing it back
// out to clients over all pipes currently on the list of
// trap notification pipes shared by this thread and the
// pipe thread
{
    PSNMP_TRAP pRecvTrap = NULL;
    struct fd_set readfds;
    PTRAP_THRD_CONTEXT pThreadContext = (PTRAP_THRD_CONTEXT) threadParam;
    SOCKET fd = INVALID_SOCKET;
    int len;
    DWORD dwLastAllocatedUdpDataLen = 0;  // the last allocated UDP data buffer size
    DWORD dwLastBigBufferRequestTime = 0; // the tick count that the last  
                                          // LargeTrap received
    BOOL fTimeoutForMaxUdpLenBuffer = FALSE; // need to deallocate the big buffer
    //
    if (NULL == pThreadContext)
        return 0;
    fd = pThreadContext->s;
    dwLastBigBufferRequestTime = GetTickCount();
    while (TRUE)
    {

        ULONG ulTrapSize = 0;
        DWORD dwError = 0;

        if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
        {
            SNMPTRAPDBG(("svrTrapThread: exit 0.\n"));
            break;
        }

        // construct readfds which gets destroyed by select()
        FD_ZERO(&readfds);
        FD_SET(fd, &readfds);
        if (select (0, &readfds, NULL, NULL, NULL) == SOCKET_ERROR)
        {
            SNMPTRAPDBG(("svrTrapThread: select failed %d.\n", WSAGetLastError()));
            break; // terminate thread
        }
        if (!(FD_ISSET(fd, &readfds)))
            continue;

        if (ioctlsocket(
                    fd,              // socket to query
                    FIONREAD,        // query for the size of the incoming datagram
                    &ulTrapSize      // unsigned long to store the size of the datagram
                    ) != 0)
        {
            dwError = WSAGetLastError();
            SNMPTRAPDBG((
                "ioctlsocket FIONREAD failed: lasterror: 0x%08lx\n", 
                dwError));

            continue;              // continue if we could not determine the size of the
                                   // incoming datagram
        }
        
        if (ulTrapSize >= MAX_FIONREAD_UDP_SIZE)
        {
            dwLastBigBufferRequestTime = GetTickCount(); // update tickcount
            
            // the ulTrapSize is not accurat on reporting the size of the 
            // next UDP datagram message. KB Q192599 and KB Q140263
            if ( NULL == pRecvTrap ||
                 dwLastAllocatedUdpDataLen < MAX_UDP_SIZE )
            {
                if (pRecvTrap)
                {
                    GlobalFree(pRecvTrap);
                    pRecvTrap = NULL;
                    dwLastAllocatedUdpDataLen = 0;
                }
                SNMPTRAPDBG((
                    "allocate LargeTrap of size : %d\n", 
                    sizeof(SNMP_TRAP) - TRAPBUFSIZE + MAX_UDP_SIZE));
                // allocate for the trap header + max udp size
                pRecvTrap = (PSNMP_TRAP)GlobalAlloc(GPTR, (sizeof(SNMP_TRAP) - 
                                                TRAPBUFSIZE + MAX_UDP_SIZE));
                if (NULL == pRecvTrap)
                {
                    SNMPTRAPDBG(("svrTrapThread: GlobalAlloc failed.\n"));
                    dwLastAllocatedUdpDataLen = 0;
                    break;       
                }      
                dwLastAllocatedUdpDataLen = MAX_UDP_SIZE;
            }
        }
        else
        {
            // winsock has reported the exact amount of UDP datagram 
            // size to be recieved as long as the next datagram is less than
            // 8-kbyte

            //
            // if we've allocated a big buffer before, check to see if we need
            // to deallocate it to save the usage of resource.
            //
            fTimeoutForMaxUdpLenBuffer = FALSE; // reset timeout flag
            if (MAX_UDP_SIZE == dwLastAllocatedUdpDataLen)
            {
                // we've allocated a big buffer before
                DWORD dwCurrTime = GetTickCount();
                if (dwCurrTime < dwLastBigBufferRequestTime)
                {
                    // wrap around occured. we just simply assume it is time to 
                    // release the big buffer.
                    fTimeoutForMaxUdpLenBuffer = TRUE;
                    SNMPTRAPDBG((
                        "Timeout to free LargeTrap buffer of size %d bytes.\n",
                                dwLastAllocatedUdpDataLen));
                }
                else
                {
                    if ( (dwCurrTime-dwLastBigBufferRequestTime) > 
                         MAXUDPLEN_BUFFER_TIME )
                    {
                        // after quite a long time, we don't have a large UDP
                        // datagram received.
                        fTimeoutForMaxUdpLenBuffer = TRUE;
                        SNMPTRAPDBG((
                            "Timeout to free LargeTrap buffer size of %d bytes.\n",
                            dwLastAllocatedUdpDataLen));
                    }
                }
            }

            if (pRecvTrap == NULL ||
                fTimeoutForMaxUdpLenBuffer ||
                dwLastAllocatedUdpDataLen < ulTrapSize)
            {
                // allocate/reallocate buffer
                if (pRecvTrap != NULL)
                {
                    GlobalFree(pRecvTrap);
                    pRecvTrap = NULL;
                    dwLastAllocatedUdpDataLen = 0;
                }
                
                if (FOUR_K_BUF_SIZE >= ulTrapSize)
                {
                    // allocate at least 4 KBytes buffer to avoid 
                    // re-allocations on different sizes of small trap received
                    pRecvTrap = (PSNMP_TRAP)GlobalAlloc(GPTR, (sizeof(SNMP_TRAP) - 
                                                TRAPBUFSIZE + FOUR_K_BUF_SIZE));
                    dwLastAllocatedUdpDataLen = FOUR_K_BUF_SIZE; 
                    SNMPTRAPDBG((
                        "allocate SmallTrap of size : %d\n", 
                        sizeof(SNMP_TRAP) - TRAPBUFSIZE + FOUR_K_BUF_SIZE));
                }
                else
                {
                    // allocate what is necessary
                    pRecvTrap = (PSNMP_TRAP)GlobalAlloc(GPTR, (sizeof(SNMP_TRAP) - 
                                                TRAPBUFSIZE + ulTrapSize));
                    dwLastAllocatedUdpDataLen = ulTrapSize;
                    SNMPTRAPDBG((
                        "allocate MediumTrap of size : %d\n", 
                        sizeof(SNMP_TRAP) - TRAPBUFSIZE + ulTrapSize));
                }
                if (NULL == pRecvTrap) // if there is so few memory that we can't allocate a bit ..
                {                      // bail out and stop the SNMPTRAP service (bug? - other option => 100% CPU which is worst)
                    SNMPTRAPDBG(("svrTrapThread: GlobalAlloc failed.\n"));
                    dwLastAllocatedUdpDataLen = 0;
                    break;       
                }       
            }
        }

        pRecvTrap->TrapBufSz = dwLastAllocatedUdpDataLen; // actual buffer size
        pRecvTrap->AddrLen = sizeof(pRecvTrap->Addr);

        len = recvfrom (
                fd,
                pRecvTrap->TrapBuf,
                pRecvTrap->TrapBufSz,
                0, 
                &(pRecvTrap->Addr),
                &(pRecvTrap->AddrLen));
        
        if (len == SOCKET_ERROR)
        {
            dwError = WSAGetLastError();
            SNMPTRAPDBG((
                "recvfrom failed: ulTrapSize: %d bytes, TrapBufSz: %d bytes, lasterror: 0x%08lx\n", 
                ulTrapSize, pRecvTrap->TrapBufSz, dwError));
            continue;
        }

        EnterCriticalSection (&cs_PIPELIST);
        pRecvTrap->TrapBufSz = len; // the acutal trap data len received
        // add header to length
        len += sizeof(SNMP_TRAP) - sizeof(pRecvTrap->TrapBuf); // - TRAPBUFSIZE
        if (!ll_empt(pSvrPipeListHead))
        {
            DWORD written;
            ll_node *item = pSvrPipeListHead;
            while (item = ll_next(item, pSvrPipeListHead))
            {
                if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
                {
                    SNMPTRAPDBG(("svrTrapThread: exit 1.\n"));
                    LeaveCriticalSection (&cs_PIPELIST);
                    break;
                }
                if (!WriteFile(
                        ((svrPipeListEntry *)item)->hPipe,
                        (LPBYTE)pRecvTrap,
                        len,
                        &written,
                        &pThreadContext->ol))
                {
                    if (ERROR_IO_PENDING == GetLastError())
                    {
                        SNMPTRAPDBG(("svrTrapThread: before GetOverlappedResult.\n"));
                        GetOverlappedResult(
                            ((svrPipeListEntry *)item)->hPipe,
                            &pThreadContext->ol,
                            &written,
                            TRUE // Block
                            );
                        SNMPTRAPDBG(("svrTrapThread: after GetOverlappedResult.\n"));
                        if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
                        {
                            SNMPTRAPDBG(("svrTrapThread: exit 2.\n"));
                            LeaveCriticalSection (&cs_PIPELIST);
                            break;
                        }
                        // reset event to non-signaled state for next I/O
                        ResetEvent(pThreadContext->ol.hEvent);
                    }
                    else
                    {
                        ll_node *hold;

                        if (!DisconnectNamedPipe(((svrPipeListEntry *)item)->hPipe))
                        {
                            ; // Placeholder for error handling
                        }
                        if (!CloseHandle(((svrPipeListEntry *)item)->hPipe))
                        {
                            ; // Placeholder for error handling
                        }
                        hold = ll_prev(item);
                        ll_rmv(item);
                        GlobalFree(item); // check for errors?
                        item = hold;
                    }
                } // end_if !WriteFile
                else if (written != (DWORD)len)
                {
                    SNMPTRAPDBG(("svrTrapThread: written != len\n"));
                    ; // Placeholder for error handling
                }
            } // end_while item = ll_next
        } // end_if !ll_empt
        LeaveCriticalSection (&cs_PIPELIST);
    } // end while TRUE

   if (pRecvTrap != NULL)
       GlobalFree(pRecvTrap);

   return 0;
} // end svrTrapThread()

PACL AllocGenericACL()
{
    PACL                        pAcl;
    PSID                        pSidAdmins, pSidUsers, pSidLocalService;
    SID_IDENTIFIER_AUTHORITY    Authority = SECURITY_NT_AUTHORITY;
    DWORD                       dwAclLength;

    pSidAdmins = pSidUsers = pSidLocalService = NULL;

    // Bug# 179644 The SNMP trap service should not run in the LocalSystem account
    if ( !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidAdmins ) ||
         !AllocateAndInitializeSid( &Authority,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_USERS,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidUsers ) ||
         !AllocateAndInitializeSid( &Authority,
                                    1,
                                    SECURITY_LOCAL_SERVICE_RID,
                                    0,
                                    0, 0, 0, 0, 0, 0,
                                    &pSidLocalService ))
    {
        if (pSidAdmins)
        {
            FreeSid(pSidAdmins);
        }
        if (pSidUsers)
        {
            FreeSid(pSidUsers);
        }
        return NULL;
    }

    dwAclLength = sizeof(ACL) + 
                  sizeof(ACCESS_ALLOWED_ACE) -
                  sizeof(ULONG) +
                  GetLengthSid(pSidAdmins) +
                  sizeof(ACCESS_ALLOWED_ACE) - 
                  sizeof(ULONG) +
                  GetLengthSid(pSidUsers) +
                  sizeof(ACCESS_ALLOWED_ACE) - 
                  sizeof(ULONG) +
                  GetLengthSid(pSidLocalService);

    pAcl = GlobalAlloc (GPTR, dwAclLength);
    if (pAcl != NULL)
    {
        if (!InitializeAcl( pAcl, dwAclLength, ACL_REVISION) ||
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_READ | GENERIC_WRITE,
                                   pSidLocalService ) || 
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   GENERIC_READ | GENERIC_WRITE,
                                   pSidAdmins ) || 
            !AddAccessAllowedAce ( pAcl,
                                   ACL_REVISION,
                                   (GENERIC_READ | (FILE_GENERIC_WRITE & ~FILE_CREATE_PIPE_INSTANCE)),
                                   pSidUsers ))
        {
            GlobalFree(pAcl);
            pAcl = NULL;
        }
    }

    FreeSid(pSidAdmins);
    FreeSid(pSidUsers);
    FreeSid(pSidLocalService);

    return pAcl;
}

void FreeGenericACL( PACL pAcl)
{
    if (pAcl != NULL)
        GlobalFree(pAcl);
}

DWORD WINAPI svrPipeThread (LPVOID threadParam)
{
    // This thread creates a named pipe instance and
    // blocks waiting for a client connection.  When
    // client connects, the pipe handle is added to the
    // list of trap notification pipes.
    // It then waits for another connection.
    DWORD  nInBufLen = sizeof(SNMP_TRAP);
    DWORD  nOutBufLen = sizeof(SNMP_TRAP) * MAX_OUT_BUFS;
    SECURITY_ATTRIBUTES S_Attrib;
    SECURITY_DESCRIPTOR S_Desc;
    PACL   pAcl;
    DWORD dwRead;
    // construct security decsriptor
    InitializeSecurityDescriptor (&S_Desc, SECURITY_DESCRIPTOR_REVISION);

    if ((pAcl = AllocGenericACL()) == NULL ||
        !SetSecurityDescriptorDacl (&S_Desc, TRUE, pAcl, FALSE))
    {
        FreeGenericACL(pAcl);
        return (0);
    }

    S_Attrib.nLength = sizeof(SECURITY_ATTRIBUTES);
    S_Attrib.lpSecurityDescriptor = &S_Desc;
    S_Attrib.bInheritHandle = TRUE;

    while (TRUE)
    {
        HANDLE hPipe;
        svrPipeListEntry *item;
        BOOL bSuccess;

        // eliminate the TerminateThread call in CLOSE_OUT of svcMainFunction
        if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
        {
            SNMPTRAPDBG(("svrPipeThread: exit 0.\n"));
            break;
        }
        hPipe = CreateNamedPipe (SNMPMGRTRAPPIPE,
                    PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                    (PIPE_WAIT | PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE),
                    PIPE_UNLIMITED_INSTANCES,
                    nOutBufLen, nInBufLen, 0, &S_Attrib);

        if (hPipe == INVALID_HANDLE_VALUE)
        {
            SNMPTRAPDBG(("svrPipeThread: CreateNamedPipe failed 0x%08lx.\n", GetLastError()));
            break;
        }
        else 
        {
            bSuccess = ConnectNamedPipe(hPipe, &g_ol);
            if (!bSuccess && GetLastError() == ERROR_IO_PENDING)  
            {
                // blocking wait until g_ol.hEvent signaled by system for a new client
                // connection request or by our own termination.
                SNMPTRAPDBG(("svrPipeThread: before GetOverlappedResult.\n"));
                bSuccess = GetOverlappedResult(hPipe, &g_ol, &dwRead, TRUE);
                SNMPTRAPDBG(("svrPipeThread: after GetOverlappedResult.\n"));
                if (WAIT_OBJECT_0 == WaitForSingleObject (hExitEvent, 0))
                {
                    SNMPTRAPDBG(("svrPipeThread: exit 1.\n"));
                    CloseHandle(hPipe);
                    break;
                }
                // reset event to non-signaled state for next I/O
                ResetEvent(g_ol.hEvent);
            }
            // check return from either ConnectNamedPipe or GetOverlappedResult.
            // If a client managed to connect between the CreateNamedPipe and
            // ConnectNamedPipe calls, ERROR_PIPE_CONNECTED will result
            if (!bSuccess && GetLastError() != ERROR_PIPE_CONNECTED)
            {
                // something went wrong, close instance and try again
                SNMPTRAPDBG(("svrPipeThread: ConnectNamedPipe 0x%08lx.\n", GetLastError()));
                CloseHandle(hPipe);
                continue;
            }
        }
        
        if (!(item = (svrPipeListEntry *)
                 GlobalAlloc (GPTR, sizeof(svrPipeListEntry))))
        {
            SNMPTRAPDBG(("svrPipeThread: E_OUTOFMEMORY\n"));
            DisconnectNamedPipe(hPipe);
            CloseHandle(hPipe);
            break;
        }
        else
        {
            ll_node *crt;
            item->hPipe = hPipe;

            SNMPTRAPDBG(("svrPipeThread: add connected client to pipe list\n"));

            EnterCriticalSection (&cs_PIPELIST);
            ll_adde(item, pSvrPipeListHead);
            crt = pSvrPipeListHead;

            // scan all the pipe instances to detect the ones that are disconnected
            while (crt = ll_next(crt, pSvrPipeListHead))
            {
                DWORD dwError;

                // subsequent ConnectNamePipe() on a handle already connected return:
                // - ERROR_PIPE_CONNECTED if the client is still there
                // - ERROR_NO_DATA if the client has disconnected
                ConnectNamedPipe(
                            ((svrPipeListEntry *)crt)->hPipe,
                            NULL);

                dwError = GetLastError();

                // For anything else but ERROR_PIPE_CONNECTED, conclude there has been
                // something wrong with the client/pipe so disconect and close the handle
                // and release the memory
                if (dwError != ERROR_PIPE_CONNECTED)
                {
                    ll_node *hold;

                    SNMPTRAPDBG(("svrPipeThread: disconnect client pipe handle 0x%08lx.\n", ((svrPipeListEntry *)crt)->hPipe));
                    if (!DisconnectNamedPipe(((svrPipeListEntry *)crt)->hPipe))
                    {
                        ; // Placeholder for error handling
                    }
                    if (!CloseHandle(((svrPipeListEntry *)crt)->hPipe))
                    {
                        ; // Placeholder for error handling
                    }

                    hold = ll_prev(crt);
                    ll_rmv(crt);
                    GlobalFree(crt); // check for errors?
                    crt = hold;
                } // end_if
            }

            LeaveCriticalSection (&cs_PIPELIST);
        } // end_else
   } // end_while TRUE

    FreeGenericACL(pAcl);
    return(0);

} // end_svrPipeThread()


void FreeSvrPipeEntryList(ll_node* head)
{
    if (head)
    {
        ll_node* current;
        current = head;
        while (current = ll_next(current, head))
        {
            ll_node *hold;
            if (!DisconnectNamedPipe(((svrPipeListEntry *)current)->hPipe))
            {
                ; // Placeholder for error handling
            }
            if (!CloseHandle(((svrPipeListEntry *)current)->hPipe))
            {
                ; // Placeholder for error handling
            }

            hold = ll_prev(current);
            ll_rmv(current);
            GlobalFree(current); // check for errors?
            current = hold;
        }
        GlobalFree(head);
    }
}


#if DBG
// modified from snmp\common\dll\dbg.c
#define MAX_LOG_ENTRY_LEN 512
VOID 
WINAPI 
SnmpTrapDbgPrint(
    LPSTR szFormat, 
    ...
    )

/*++

Routine Description:

    Prints debug message.

Arguments:


    szFormat - formatting string (see printf).

Return Values:

    None. 

--*/

{
    va_list arglist;

    // 640 octets should be enough to encode oid's of 128 sub-ids.
    // (one subid can be encoded on at most 5 octets; there can be at
    // 128 sub-ids per oid. MAX_LOG_ENTRY_LEN = 512
    char szLogEntry[4*MAX_LOG_ENTRY_LEN];

    time_t now;

    // initialize variable args
    va_start(arglist, szFormat);

    time(&now);
    strftime(szLogEntry, MAX_LOG_ENTRY_LEN, "%H:%M:%S :", localtime(&now));

    // transfer variable args to buffer
    vsprintf(szLogEntry + strlen(szLogEntry), szFormat, arglist);

    // output entry to debugger
    OutputDebugStringA(szLogEntry);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\manager\winsnmp\inc\wsnmpext.h ===
#ifndef _INC_WSNMPEXT
#define _INC_WSNMPEXT
//
// wsnmpext.h
//
// Externals include for NetPlus WinSNMP
// Copyright 1995-1997 ACE*COMM Corp
// Rleased to Microsoft under Contract
// Beta 1 version, 970228
// Bob Natale (bnatale@acecomm.com)
//
//
#ifdef __cplusplus
extern "C" {
#endif
extern TASK          TaskData;
extern SNMPTD        SessDescr;
extern SNMPTD        PDUsDescr;
extern SNMPTD        VBLsDescr;
extern SNMPTD        EntsDescr;
extern SNMPTD        CntxDescr;
extern SNMPTD        MsgDescr;       
extern SNMPTD        TrapDescr;
extern SNMPTD        AgentDescr;
extern CRITICAL_SECTION cs_TASK;
extern CRITICAL_SECTION cs_SESSION;
extern CRITICAL_SECTION cs_PDU;
extern CRITICAL_SECTION cs_VBL;
extern CRITICAL_SECTION cs_ENTITY;
extern CRITICAL_SECTION cs_CONTEXT;
extern CRITICAL_SECTION cs_MSG;
extern CRITICAL_SECTION cs_TRAP;
extern CRITICAL_SECTION cs_AGENT;
extern CRITICAL_SECTION cs_XMODE;

extern SNMPAPI_STATUS SaveError(HSNMP_SESSION hSession, SNMPAPI_STATUS nError);

extern SNMPAPI_STATUS snmpAllocTable(LPSNMPTD table);
extern SNMPAPI_STATUS SNMPAPI_CALL SnmpIpxAddressToStr (LPBYTE, LPBYTE, LPSTR);
extern BOOL BuildMessage (smiUINT32 version, smiLPOCTETS community,
            LPPDUS pdu, smiINT32 dllReqId, smiLPBYTE *msgAddr, smiLPUINT32 msgSize);
extern smiUINT32 ParseMessage (smiLPBYTE msgPtr, smiUINT32 msgLen, smiLPUINT32 version, smiLPOCTETS *community, LPPDUS pdu);
extern void FreeMsg (DWORD nMsg);
extern void FreeOctetString (smiLPOCTETS os_ptr);
extern void FreeVarBind (LPVARBIND vb_ptr);
extern void FreeVarBindList (LPVARBIND vb_ptr);
extern void FreeV1Trap (LPV1TRAP v1Trap_ptr);
extern SNMPAPI_STATUS CheckRange (DWORD index, LPSNMPTD block);

//-----------------------------------------------------------------
// snmpInitTableDescr - initializes the table descriptor with the 
// parameters given as arguments. Creates and zeroes a first chunck of table.
extern SNMPAPI_STATUS snmpInitTableDescr(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwBlocksToAdd, /*in*/DWORD dwBlockSize);
//-----------------------------------------------------------------
// snmpFreeTableDescr - releases any memory allocated for the table
extern VOID snmpFreeTableDescr(/*in*/LPSNMPTD pTableDescr);
//-----------------------------------------------------------------
// snmpAllocTableEntry - finds an empty entry into the table. If none
// already exists, table is enlarged.
extern SNMPAPI_STATUS snmpAllocTableEntry(/*in*/LPSNMPTD pTableDescr, /*out*/LPDWORD pIndex);
//-----------------------------------------------------------------
// snmpFreeTableEntry - free the location at index dwIndex from the
// table described by pTableDescr. 
extern SNMPAPI_STATUS snmpFreeTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex);
//-----------------------------------------------------------------
// snmpGetTableEntry - returns the entry at zero-based index dwIndex
// from the table described by pTableDescr
extern PVOID snmpGetTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex);
//-----------------------------------------------------------------
// snmpValidTableEntry - returns TRUE or FALSE as an entry in the table
// has valid data (is allocated) or not
extern BOOL snmpValidTableEntry(/*in*/LPSNMPTD pTableDescr, /*in*/DWORD dwIndex);


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\makefile.inc ===
snmpevts.h : snmpevts.mc
    mc -h ..\inc -v snmpevts.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\mem.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    mem.c

Abstract:

    Contains memory allocation routines for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "mem.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define AGENT_HEAP_FLAGS            0
#define AGENT_HEAP_INITIAL_SIZE     0xffff
#define AGENT_HEAP_MAXIMUM_SIZE     0


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE g_hAgentHeap = NULL;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procudures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AgentHeapCreate(
    )

/*++

Routine Description:

    Creates private heap for master agent private structures.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // create master agent heap
    g_hAgentHeap = HeapCreate(
                        AGENT_HEAP_FLAGS, 
                        AGENT_HEAP_INITIAL_SIZE, 
                        AGENT_HEAP_MAXIMUM_SIZE
                        );

    // validate heap handle
    if (g_hAgentHeap == NULL) {
            
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: error %d creating agent heap.\n",
            GetLastError()
            ));
    }

    // return success if created
    return (g_hAgentHeap != NULL);
}


BOOL
AgentHeapDestroy(
    )

/*++

Routine Description:

    Destroys private heap for master agent private structures.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // validate handle
    if (g_hAgentHeap != NULL) {

        // release heap handle
        HeapDestroy(g_hAgentHeap);

        // re-initialize
        g_hAgentHeap = NULL;
    }

    return TRUE;
}


LPVOID
AgentMemAlloc(
    UINT nBytes
    )

/*++

Routine Description:

    Allocates memory from master agent's private heap.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // allocate memory from private heap (and initialize)
    return HeapAlloc(g_hAgentHeap, HEAP_ZERO_MEMORY, nBytes);
}


VOID
AgentMemFree(
    LPVOID pMem
    )

/*++

Routine Description:

    Frees memory from master agent's private heap.

Arguments:

    pMem - pointer to memory block to release.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pMem != NULL) {

        // release agent memory
        HeapFree(g_hAgentHeap, 0, pMem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\network.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    network.c

Abstract:

    Contains routines for manipulating transport structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "network.h"
#include "varbinds.h"
#include "snmppdus.h"
#include "query.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
IsValidSockAddr(
    struct sockaddr *pAddress
    )
/*++

Routine Description:

    Verifies if an IP or IPX address is valid.
    An IP address is valid if it is AF_INET and it is not 0.0.0.0
    An IPX address is valid if is AF_IPX and the node-number is not null: xxxxxx.000000000000

Arguments:

    pAddress - pointer to a generic network address to be tested

Return Values:

    Returns true if the address is valid.

--*/
{
    if (pAddress == NULL)
        return FALSE;

    if (pAddress->sa_family == AF_INET)
    {
        return (((struct sockaddr_in *)pAddress)->sin_addr.s_addr != 0);
    }
    else if (pAddress->sa_family == AF_IPX)
    {
        char zeroBuff[6] = {0, 0, 0, 0, 0, 0};

        return memcmp(((struct sockaddr_ipx *)pAddress)->sa_nodenum,
                       zeroBuff,
                       sizeof(zeroBuff)) != 0;
    }

    // the address is neither IP nor IPX hence it is definitely an invalid address
    return FALSE;
}

BOOL
AllocNLE(
    PNETWORK_LIST_ENTRY * ppNLE
    )

/*++

Routine Description:

    Allocates transport structure and initializes.

Arguments:

    ppNLE - pointer to receive pointer to list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PNETWORK_LIST_ENTRY pNLE;
    
    // attempt to allocate structure
    pNLE = AgentMemAlloc(sizeof(NETWORK_LIST_ENTRY));

    // validate pointer
    if (pNLE != NULL) {

        // allocate buffer to be used for io
        pNLE->Buffer.buf = AgentMemAlloc(NLEBUFLEN);

        // validate pointer
        if (pNLE->Buffer.buf != NULL) {

            // initialize socket to socket
            pNLE->Socket = INVALID_SOCKET;

            // initialize buffer length
            pNLE->Buffer.len = NLEBUFLEN;

            // initialize subagent query list
            InitializeListHead(&pNLE->Queries);

            // initialize variable bindings list
            InitializeListHead(&pNLE->Bindings);

            // success
            fOk = TRUE;

        } else {
                
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not allocate network io buffer.\n"
                ));
            
            // release
            FreeNLE(pNLE);

            // re-init
            pNLE = NULL;
        }
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate network entry.\n"
            ));
    }

    // transfer
    *ppNLE = pNLE;

    return fOk;
}


BOOL 
FreeNLE(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Releases transport structure.

Arguments:

    pNLE - pointer to transport structure.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pNLE != NULL) {

        // check to see if socket valid
        if (pNLE->Socket != INVALID_SOCKET) {

            // release socket
            closesocket(pNLE->Socket);
        }

        // release pdu
        UnloadPdu(pNLE);

        // release query list
        UnloadQueries(pNLE);

        // release bindings list
        UnloadVarBinds(pNLE);

        // release network buffer
        AgentMemFree(pNLE->Buffer.buf);

        // release memory
        AgentMemFree(pNLE);
    }

    return TRUE;
}


BOOL
LoadIncomingTransports(
    )

/*++

Routine Description:

    Creates entries for each incoming interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fUdpOk = FALSE;
    BOOL fIpxOk = FALSE;
    PNETWORK_LIST_ENTRY pNLE = NULL;
    INT nStatus;

    // allocate tcpip
    if (AllocNLE(&pNLE)) {

        struct servent * pServEnt;
        struct sockaddr_in * pSockAddr;

        // initialize sockaddr structure size
        pNLE->SockAddrLen = sizeof(struct sockaddr_in);

        // obtain pointer to sockaddr structure
        pSockAddr = (struct sockaddr_in *)&pNLE->SockAddr;

        // attempt to get server information
        pServEnt = getservbyname("snmp","udp");

        // initialize address structure
        pSockAddr->sin_family = AF_INET;
        pSockAddr->sin_addr.s_addr = INADDR_ANY;
        pSockAddr->sin_port = (pServEnt != NULL)
                                ? (SHORT)pServEnt->s_port
                                : htons(DEFAULT_SNMP_PORT_UDP)
                                ;
        
        // allocate tpcip socket 
        pNLE->Socket = WSASocket(
                            AF_INET,
                            SOCK_DGRAM,
                            0,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            // attempt to bind 
            nStatus = bind(pNLE->Socket, 
                          &pNLE->SockAddr, 
                          pNLE->SockAddrLen
                          );

            // validate return code
            if (nStatus != SOCKET_ERROR) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: successfully bound to udp port %d.\n",
                    ntohs(pSockAddr->sin_port)
                    ));

                // insert transport into list of incoming
                InsertTailList(&g_IncomingTransports, &pNLE->Link);

                // success
                fUdpOk = TRUE;
            
            } else {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: error %d binding to udp port %d.\n",
                    WSAGetLastError(),
                    ntohs(pSockAddr->sin_port)
                    ));
            }

        } else { 
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating udp socket.\n",
                WSAGetLastError()
                ));
        }    

        if (!fUdpOk) {
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // allocate ipx
    if (AllocNLE(&pNLE)) {

        struct sockaddr_ipx * pSockAddr;

        // initialize sockaddr structure size
        pNLE->SockAddrLen = sizeof(struct sockaddr_ipx);

        // obtain pointer to sockaddr structure
        pSockAddr = (struct sockaddr_ipx *)&pNLE->SockAddr;

        // initialize address structure
        pSockAddr->sa_family = AF_IPX;
        pSockAddr->sa_socket = htons(DEFAULT_SNMP_PORT_IPX);
        
        // allocate ipx socket 
        pNLE->Socket = WSASocket(
                            AF_IPX,
                            SOCK_DGRAM,
                            NSPROTO_IPX,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            // attempt to bind 
            nStatus = bind(pNLE->Socket, 
                          &pNLE->SockAddr, 
                          pNLE->SockAddrLen
                          );

            // validate return code
            if (nStatus != SOCKET_ERROR) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: successfully bound to ipx port %d.\n",
                    ntohs(pSockAddr->sa_socket)
                    ));

                // insert transport into list of incoming
                InsertTailList(&g_IncomingTransports, &pNLE->Link);

                // success
                fIpxOk = TRUE;

            } else {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: error %d binding to ipx port %d.\n",
                    WSAGetLastError(),
                    ntohs(pSockAddr->sa_socket)
                    ));
            }

        } else { 
                
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating ipx socket.\n",
                WSAGetLastError()
                ));
        }    

        if (!fIpxOk) {
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // need one transport min
    return (fUdpOk || fIpxOk);
}


BOOL
UnloadTransport(
    PNETWORK_LIST_ENTRY pNLE
    )
{

    // make sure the parameter is valid, otherwise the macro below AVs
    if (pNLE == NULL)
        return FALSE;

    // remove the entry from the list
    RemoveEntryList(&(pNLE->Link));

    // close the socket
    closesocket(pNLE->Socket);

    // release the memory
    FreeNLE(pNLE);

    return TRUE;
}


BOOL
UnloadIncomingTransports(
    )

/*++

Routine Description:

    Destroys entries for each outgoing interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PNETWORK_LIST_ENTRY pNLE;

    // process entries until empty
    while (!IsListEmpty(&g_IncomingTransports)) {

        // extract next entry from head 
        pLE = RemoveHeadList(&g_IncomingTransports);

        // retrieve pointer to mib region structure 
        pNLE = CONTAINING_RECORD(pLE, NETWORK_LIST_ENTRY, Link);

        // release
        FreeNLE(pNLE);
    }

    return TRUE; 
}


BOOL
LoadOutgoingTransports(
    )

/*++

Routine Description:

    Creates entries for each outgoing interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fUdpOk = FALSE;
    BOOL fIpxOk = FALSE;
    PNETWORK_LIST_ENTRY pNLE = NULL;

    // allocate tcpip
    if (AllocNLE(&pNLE)) {

        // allocate tpcip socket 
        pNLE->Socket = WSASocket(
                            AF_INET,
                            SOCK_DGRAM,
                            0,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            pNLE->SockAddr.sa_family = AF_INET;

            // insert transport into list of incoming
            InsertTailList(&g_OutgoingTransports, &pNLE->Link);

            // success
            fUdpOk = TRUE;

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating udp socket.\n",
                WSAGetLastError()
                ));
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // allocate ipx
    if (AllocNLE(&pNLE)) {

        // allocate ipx socket 
        pNLE->Socket = WSASocket(
                            AF_IPX,
                            SOCK_DGRAM,
                            NSPROTO_IPX,
                            NULL,
                            0,
                            WSA_FLAG_OVERLAPPED 
                            );

        // validate socket
        if (pNLE->Socket != INVALID_SOCKET) {

            pNLE->SockAddr.sa_family = AF_IPX;

            // insert transport into list of incoming
            InsertTailList(&g_OutgoingTransports, &pNLE->Link);

            // success
            fIpxOk = TRUE;

        } else {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: error %d creating ipx socket.\n",
                WSAGetLastError()
                ));
        
            // release
            FreeNLE(pNLE);
        }    
    }

    // need one transport min
    return (fUdpOk || fIpxOk);
}


BOOL
UnloadOutgoingTransports(
    )

/*++

Routine Description:

    Destroys entries for each outgoing interface.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PNETWORK_LIST_ENTRY pNLE;

    // process entries until empty
    while (!IsListEmpty(&g_OutgoingTransports)) {

        // extract next entry from head 
        pLE = RemoveHeadList(&g_OutgoingTransports);

        // retrieve pointer to mib region structure 
        pNLE = CONTAINING_RECORD(pLE, NETWORK_LIST_ENTRY, Link);

        // release
        FreeNLE(pNLE);
    }

    return TRUE; 
}


BOOL
UnloadPdu(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Releases resources allocated in pdu structure.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    // release community string
    SnmpUtilOctetsFree(&pNLE->Community);

    // release varbinds in pdu
    SnmpUtilVarBindListFree(&pNLE->Pdu.Vbl);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\query.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    query.c

Abstract:

    Contains routines for querying subagents.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "varbinds.h"
#include "network.h"
#include "query.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
FindQueryBySLE(
    PQUERY_LIST_ENTRY * ppQLE,
    PNETWORK_LIST_ENTRY pNLE,
    PSUBAGENT_LIST_ENTRY pSLE
    )

/*++

Routine Description:

    Allocates query list entry.

Arguments:

    ppQLE - pointer to receive query entry pointer.

    pNLE - pointer to network list entry.

    pSLE - pointer to subagent list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE = NULL;

    // point to first query
    pLE = pNLE->Queries.Flink;

    // process each query
    while (pLE != &pNLE->Queries) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // compare subagents
        if (pQLE->pSLE == pSLE) {

            // transfer
            *ppQLE = pQLE;

            // success
            return TRUE;
        }
            
        // next entry
        pLE = pLE->Flink;        
    }

    // initialize
    *ppQLE = NULL;

    // failure
    return FALSE;
}


BOOL
LoadSubagentData(
    PNETWORK_LIST_ENTRY pNLE,
    PQUERY_LIST_ENTRY   pQLE
    )

/*++

Routine Description:

    Loads data to be passed to the subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    pQLE - pointer to current query.

Return Values:

    Returns true if successful.

--*/

{   
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
        
    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: query 0x%08lx loading.\n", pQLE
        ));    

    // attempt to allocate varbind list    
    pQLE->SubagentVbl.list = SnmpUtilMemAlloc(
                                pQLE->nSubagentVbs * sizeof(SnmpVarBind)
                                );

    // validate varbind list pointer
    if (pQLE->SubagentVbl.list != NULL) {

        // point to first varbind
        pLE = pQLE->SubagentVbs.Flink;

        // process each outgoing varbind
        while (pLE != &pQLE->SubagentVbs) {

            // retrieve pointer to varbind entry from query link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, QueryLink);

            // transfer varbind
            SnmpUtilVarBindCpy(
                &pQLE->SubagentVbl.list[pQLE->SubagentVbl.len++],
                &pVLE->ResolvedVb
                );                    

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: variable %d copied to query 0x%08lx.\n",
                pVLE->nErrorIndex,
                pQLE
                ));    

            // next entry
            pLE = pLE->Flink;        
        }

        // create copy of context in case subagent mucks with it
        SnmpUtilOctetsCpy(&pQLE->ContextInfo, &pNLE->Community);
    
    } else {
     
        SNMPDBG((   
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate varbind list.\n"
            ));
        
        // failure    
        return FALSE;
    }

    // success
    return TRUE;    
}


BOOL
UnloadSubagentData(
    PQUERY_LIST_ENTRY pQLE 
    )

/*++

Routine Description:

    Unloads data passed to the subagent DLL.

Arguments:

    pQLE - pointer to current query.

Return Values:

    Returns true if successful.

--*/

{   
    __try {
    
        // release subagent varbind list
        SnmpUtilVarBindListFree(&pQLE->SubagentVbl);

        // release subagent context information        
        SnmpUtilOctetsFree(&pQLE->ContextInfo);
    
    } __except (EXCEPTION_EXECUTE_HANDLER) {
                
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx processing structure from %s.\n",
            GetExceptionCode(),
            (pQLE->pSLE != NULL)
                ? pQLE->pSLE->pPathname 
                : "<unknown>"
            ));

        // failure
        return FALSE;    
    }

    // success
    return TRUE;
}


BOOL
UpdateResolvedVarBind(
    PQUERY_LIST_ENTRY   pQLE,
    PVARBIND_LIST_ENTRY pVLE,
    UINT                iVb
    )

/*++

Routine Description:

    Updates resolved varbind with data from subagent DLL.

Arguments:

    pQLE - pointer to current query.

    pVLE - pointer to varbind.

    iVb - index of varbind.

Return Values:

    Returns true if successful.

--*/

{
    // see if this is non-repeater
    if (pVLE->nMaxRepetitions == 1) {

        // flag varbind as resolved
        pVLE->nState = VARBIND_RESOLVED;

        // release memory for current varbind
        SnmpUtilVarBindFree(&pVLE->ResolvedVb);

        // transfer varbind from subagent
        SnmpUtilVarBindCpy(&pVLE->ResolvedVb, 
                           &pQLE->SubagentVbl.list[iVb]
                           );

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: variable %d name %s.\n",
            pVLE->nErrorIndex,
            SnmpUtilOidToA(&pVLE->ResolvedVb.name)
            ));    

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: variable %d state '%s'.\n",
            pVLE->nErrorIndex,
            VARBINDSTATESTRING(pVLE->nState)
            ));    

        // success
        return TRUE;
    } 
    
    // see if varbind list allocated
    if ((pVLE->ResolvedVbl.len == 0) &&
        (pVLE->ResolvedVbl.list == NULL)) {

        // allocate varbind list to fill in
        pVLE->ResolvedVbl.list = SnmpUtilMemAlloc(
                                    pVLE->nMaxRepetitions *
                                    sizeof(SnmpVarBind)
                                    );    
        // validate pointer before continuing
        if (pVLE->ResolvedVbl.list == NULL) {

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not allocate new varbinds.\n"
                ));
    
            // failure
            return FALSE;
        }
    }

    // release working varbind name
    SnmpUtilOidFree(&pVLE->ResolvedVb.name);

    // transfer name for next iteration
    SnmpUtilOidCpy(&pVLE->ResolvedVb.name,
                   &pQLE->SubagentVbl.list[iVb].name 
                   ); 

    // transfer varbind
    SnmpUtilVarBindCpy( 
        &pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len],
        &pQLE->SubagentVbl.list[iVb]
        );

    // increment count
    pVLE->ResolvedVbl.len++;
                
    // see if this is the last varbind to retrieve
    pVLE->nState = (pVLE->nMaxRepetitions > pVLE->ResolvedVbl.len)
                        ? VARBIND_PARTIALLY_RESOLVED
                        : VARBIND_RESOLVED
                        ;            

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: variable %d name %s.\n",
        pVLE->nErrorIndex,
        SnmpUtilOidToA(&pVLE->ResolvedVb.name)
        ));    

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: variable %d state '%s'.\n",
        pVLE->nErrorIndex,
        VARBINDSTATESTRING(pVLE->nState)
        ));    

    // success
    return TRUE;
}


BOOL
UpdateVarBind(
    PNETWORK_LIST_ENTRY pNLE,
    PQUERY_LIST_ENTRY   pQLE,
    PVARBIND_LIST_ENTRY pVLE,
    UINT                iVb
    )

/*++

Routine Description:

    Updates varbind with data from subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    pQLE - pointer to current query.

    pVLE - pointer to varbind.

    iVb - index of varbind.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    INT nDiff1;
    INT nDiff2;

    __try {
                        
        // determine order of returned varbind
        nDiff1 = SnmpUtilOidCmp(&pQLE->SubagentVbl.list[iVb].name,
                                &pVLE->ResolvedVb.name
                                );

        // see if this is getnext or getbulk 
        if ((pNLE->Pdu.nType == SNMP_PDU_GETNEXT) ||
            (pNLE->Pdu.nType == SNMP_PDU_GETBULK)) {
            
            // determine whether returned varbind in range
            nDiff2 = SnmpUtilOidCmp(&pQLE->SubagentVbl.list[iVb].name,
                                    &pVLE->pCurrentRLE->LimitOid
                                    );

            // make sure returned oid in range
            if ((nDiff1 > 0) && (nDiff2 < 0)) {

                // update resolved variable binding
                return UpdateResolvedVarBind(pQLE, pVLE, iVb);

            } else if (nDiff2 >= 0) {

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: %s received getnext request for %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: %s returned out-of-range oid %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                    ));
                
                // retrieve pointer to next region
                pLE = pVLE->pCurrentRLE->Link.Flink;

                // see if we exhausted regions
                if (pLE != &g_SupportedRegions) {

                    PMIB_REGION_LIST_ENTRY pNextRLE;

                    // retrieve pointer to mib region 
                    pNextRLE = CONTAINING_RECORD(pLE, 
                                                 MIB_REGION_LIST_ENTRY, 
                                                 Link
                                                 );
                                            
                    // see if next region supported by same subagent
                    if (pVLE->pCurrentRLE->pSLE == pNextRLE->pSLE) {

                        BOOL retCode;

                        SNMPDBG((
                            SNMP_LOG_TRACE,
                            "SNMP: SVC: next region also supported by %s.\n",
                            pVLE->pCurrentRLE->pSLE->pPathname
                            ));    

                        // update resolved variable binding
                        retCode = UpdateResolvedVarBind(pQLE, pVLE, iVb);
                        if (pQLE->SubagentVbl.list[iVb].value.asnType != ASN_NULL)
                        {
                            return retCode;
                        }
                    }

                    // point to next region 
                    pVLE->pCurrentRLE = pNextRLE;
                    
                    // change state to partially resolved
                    pVLE->nState = VARBIND_PARTIALLY_RESOLVED;

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: SVC: variable %d re-assigned to %s.\n",
                        pVLE->nErrorIndex,
                        pVLE->pCurrentRLE->pSLE->pPathname
                        ));    
                } 
                
                else if ((pVLE->ResolvedVbl.len == 0) &&
                    (pVLE->ResolvedVbl.list == NULL)) {

                    // flag varbind as resolved
                    pVLE->nState = VARBIND_RESOLVED;

                    // set default varbind to eomv
                    pVLE->ResolvedVb.value.asnType = 
                        SNMP_EXCEPTION_ENDOFMIBVIEW;
                        
                    // update error status counter for the operation
                    mgmtCTick(CsnmpOutNoSuchNames);

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    

                } else {                
                
                    // flag varbind as resolved
                    pVLE->nState = VARBIND_RESOLVED;

                    // transfer name 
                    SnmpUtilOidCpy(
                        &pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len].name,
                        &pVLE->ResolvedVb.name
                        );

                    // set current varbind to eomv
                    pVLE->ResolvedVbl.list[pVLE->ResolvedVbl.len].value.asnType =
                        SNMP_EXCEPTION_ENDOFMIBVIEW;

                    // increment count
                    pVLE->ResolvedVbl.len++;

                    // update error status counter for the operation
                    mgmtCTick(CsnmpOutNoSuchNames);

                    SNMPDBG((
                        SNMP_LOG_VERBOSE,
                        "SNMP: SVC: variable %d state '%s'.\n",
                        pVLE->nErrorIndex,
                        VARBINDSTATESTRING(pVLE->nState)
                        ));    
                }                                                

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s received getnext request for %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s returned invalid oid %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                    ));

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: Ban %s subagent, forward the request to a different one.\n",
                    pQLE->pSLE->pPathname
                    ));

                // trying to forward this getnext request to the next region but only if not handled
                // by the same subagent!
                pLE = pVLE->pCurrentRLE->Link.Flink;
                while( pLE != &g_SupportedRegions)
                {
                    PMIB_REGION_LIST_ENTRY pNextRLE;

                   // retrieve pointer to mib region 
                    pNextRLE = CONTAINING_RECORD(pLE, 
                                                 MIB_REGION_LIST_ENTRY, 
                                                 Link
                                                 );

                    // if this 'next' region is handled by the same subagent, skip to the next!
                    if (pVLE->pCurrentRLE->pSLE == pNextRLE->pSLE)
                    {
                        pLE = pNextRLE->Link.Flink;
                        continue;
                    }

                    // ok, we have one, forward the original GetNext request to it
                    pVLE->pCurrentRLE = pNextRLE;
                    pVLE->nState = VARBIND_PARTIALLY_RESOLVED;

                    SNMPDBG((
                        SNMP_LOG_TRACE,
                        "SNMP: SVC: variable %d re-assigned to %s.\n",
                        pVLE->nErrorIndex,
                        pVLE->pCurrentRLE->pSLE->pPathname
                        ));
                    
                    return TRUE;
                }

                // failure
                // here I should emulate a (NO_SUCH_NAME) EndOfMibView, resolve the variable and return TRUE.
                pVLE->nState = VARBIND_RESOLVED;
                pVLE->ResolvedVb.value.asnType = SNMP_EXCEPTION_ENDOFMIBVIEW;
                pVLE->pCurrentRLE = NULL;

                // update error status counter
                mgmtCTick(CsnmpOutNoSuchNames);

                return TRUE;
            }

        } else if (pNLE->Pdu.nType == SNMP_PDU_GET) {

            // must match
            if (nDiff1 == 0) {

                // flag varbind as resolved
                pVLE->nState = VARBIND_RESOLVED;

                // release memory for current varbind
                SnmpUtilVarBindFree(&pVLE->ResolvedVb);

                // transfer varbind from subagent
                SnmpUtilVarBindCpy(&pVLE->ResolvedVb, 
                                   &pQLE->SubagentVbl.list[iVb]
                                   );

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d name %s.\n",
                    pVLE->nErrorIndex,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

            } else {

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s received get request for %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                    ));

                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: %s returned invalid oid %s.\n",
                    pQLE->pSLE->pPathname,
                    SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                    ));
                
                // failure
                return FALSE;
            }

        } else if (nDiff1 != 0) { 
			// set request failed -> invalid oid            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: %s received set request for %s.\n",
                pQLE->pSLE->pPathname,
                SnmpUtilOidToA(&pVLE->ResolvedVb.name)
                ));

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: %s returned invalid oid %s.\n",
                pQLE->pSLE->pPathname,
                SnmpUtilOidToA(&pQLE->SubagentVbl.list[iVb].name)
                ));
            
            // failure
            return FALSE;
        } else {

            // set request, oids match
			// WARNING!! - state might be set prematurely on SET_TEST / SET_CLEANUP
            pVLE->nState = VARBIND_RESOLVED;
			return TRUE;
		}

    } __except (EXCEPTION_EXECUTE_HANDLER) {
                
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx processing structure from %s.\n",
            GetExceptionCode(),
            pQLE->pSLE->pPathname
            ));

        // failure
        return FALSE;        
    }

    // success
    return TRUE;   
}


BOOL
UpdateVarBinds(
    PNETWORK_LIST_ENTRY pNLE,
    PQUERY_LIST_ENTRY   pQLE 
    )

/*++

Routine Description:

    Updates varbind list entries with data from subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    pQLE - pointer to current query.

Return Values:

    Returns true if successful.

--*/

{   
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
    BOOL fOk = TRUE;
    UINT iVb = 0;
            
    // point to first varbind
    pLE = pQLE->SubagentVbs.Flink;

    // see if error encountered during callback
    if (pQLE->nErrorStatus == SNMP_ERRORSTATUS_NOERROR) {
    
        // process each outgoing varbind
        while (pLE != &pQLE->SubagentVbs) {

            // retrieve pointer to varbind entry from query link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, QueryLink);
            
            // update individual varbind
            if (!UpdateVarBind(pNLE, pQLE, pVLE, iVb++)) {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: variable %d could not be updated.\n", 
                    pQLE->nErrorIndex
                    ));    

                // update pdu with the proper varbind error index    
                pNLE->Pdu.Pdu.NormPdu.nErrorStatus = SNMP_ERRORSTATUS_GENERR;
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex  = pVLE->nErrorIndex;

                // failure
                return FALSE;
            }

            // next entry
            pLE = pLE->Flink; 
        }
    
    } else {

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: searching for errant variable.\n" 
            ));    

        // update pdu with status returned from subagent
        pNLE->Pdu.Pdu.NormPdu.nErrorStatus = pQLE->nErrorStatus;

        // process each outgoing varbind
        while (pLE != &pQLE->SubagentVbs) {

            // retrieve pointer to varbind entry from query link
            pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, QueryLink);
            
            // see if errant varbind nErrorIndex is starts from 1 !!
            if (pQLE->nErrorIndex == ++iVb) {
                
                SNMPDBG((
                    SNMP_LOG_TRACE,
                    "SNMP: SVC: variable %d involved in failure.\n",
                    pVLE->nErrorIndex
                    ));    

                // update pdu with the proper varbind error index    
                pNLE->Pdu.Pdu.NormPdu.nErrorIndex = pVLE->nErrorIndex;

                // the error code was successfully identified
                return	TRUE;
            }

            // next entry
            pLE = pLE->Flink; 
        }
        
        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: no variable involved in failure.\n"
            ));    

        // failure
        return FALSE;
    }

    // success
    return TRUE;
}


BOOL
CallSubagent(
    PQUERY_LIST_ENTRY pQLE,
    UINT              nRequestType,
    UINT              nTransactionId
    )

/*++

Routine Description:
    Invokes method from subagent DLL.

Arguments:

    pNLE - pointer to network list entry.

    nRequestType - type of request to post to subagent.

    nTransactionId - identifies snmp pdu sent from manager.

Return Values:

    Returns true if successful.

--*/

{   
    BOOL fOk = FALSE;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: --- query %s begin ---\n", 
        pQLE->pSLE->pPathname
        ));    

    __try {
        
        // determine which version of query supported
        if (pQLE->pSLE->pfnSnmpExtensionQueryEx != NULL) {

            // process query using new interface
            fOk = (*pQLE->pSLE->pfnSnmpExtensionQueryEx)(
                        nRequestType,
                        nTransactionId,
                        &pQLE->SubagentVbl,
                        &pQLE->ContextInfo,
                        &pQLE->nErrorStatus,
                        &pQLE->nErrorIndex
                        );
                                                
        // see if query is actually valid for downlevel call
        } else if ((pQLE->pSLE->pfnSnmpExtensionQuery != NULL) &&
                  ((nRequestType == SNMP_EXTENSION_GET) ||
                   (nRequestType == SNMP_EXTENSION_GET_NEXT) ||
                   (nRequestType == SNMP_EXTENSION_SET_COMMIT))) {
            
            // process query using old interface
            fOk = (*pQLE->pSLE->pfnSnmpExtensionQuery)(
                        (BYTE)(UINT)nRequestType,
                        &pQLE->SubagentVbl,
                        &pQLE->nErrorStatus,
                        &pQLE->nErrorIndex
                        );

        // see if query can be completed successfully anyway
        } else if ((nRequestType == SNMP_EXTENSION_SET_TEST) ||
                   (nRequestType == SNMP_EXTENSION_SET_CLEANUP)) { 

            // fake it
            fOk = TRUE;    
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: exception 0x%08lx calling %s.\n",
            GetExceptionCode(),
            pQLE->pSLE->pPathname
            ));
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: --- query %s end ---\n", 
        pQLE->pSLE->pPathname
        ));    

    // validate
    if (!fOk) {
    
        // identify failing subagent
        pQLE->nErrorStatus = SNMP_ERRORSTATUS_GENERR;
        pQLE->nErrorIndex  = 1; 

    } else if (pQLE->nErrorStatus != SNMP_ERRORSTATUS_NOERROR) {

        // see if error index needs to be adjusted
        if ((pQLE->nErrorIndex > pQLE->nSubagentVbs) ||
            (pQLE->nErrorIndex == 0)) {

            // set to first varbind
            pQLE->nErrorIndex = 1; 
        }
    
    } else {

        // re-initialize
        pQLE->nErrorIndex = 0; 
    }

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: query 0x%08lx %s, errorStatus=%s, errorIndex=%d.\n", 
        pQLE,
        (pQLE->nErrorStatus == SNMP_ERRORSTATUS_NOERROR)
            ? "succeeded"
            : "failed"
            ,
        SNMPERRORSTRING(pQLE->nErrorStatus),
        pQLE->nErrorIndex
        ));    

    return TRUE;
}


BOOL
ProcessSet(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Processes SNMP_PDU_SET requests.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE = NULL;
    PQUERY_LIST_ENTRY pQLE;
    BOOL fOk = TRUE;

    // load subagent queries
    if (!LoadQueries(pNLE)) {

        // unload immediately
        UnloadQueries(pNLE);

        // failure
        return FALSE;
    }
    
    // point to first query
    pLE = pNLE->Queries.Flink;

    // process each subagent query 
    while (fOk && (pLE != &pNLE->Queries)) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // load outgoing varbinds
        fOk = LoadSubagentData(pNLE, pQLE);

        // validate
        if (fOk) {

            // dispatch 
            CallSubagent(
                pQLE, 
                SNMP_EXTENSION_SET_TEST,
                pNLE->nTransactionId
                );

            // process results returned
            fOk = UpdateVarBinds(pNLE, pQLE);
        }

        // next entry (or reverse direction)
        pLE = fOk ? pLE->Flink : pLE->Blink;
    }
    
    // validate
    if (fOk) {

		// if this line is missing => GenErr on UpdatePdu()
		pLE = pNLE->Queries.Flink;

        // process each subagent query 
        while (fOk && (pLE != &pNLE->Queries)) {

            // retrieve pointer to query entry from link
            pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

            // dispatch 
            CallSubagent(
                pQLE, 
                SNMP_EXTENSION_SET_COMMIT,
                pNLE->nTransactionId
                );

            // process results returned
            fOk = UpdateVarBinds(pNLE, pQLE);

            // next entry (or reverse direction)
            pLE = fOk ? pLE->Flink : pLE->Blink;
        }

        // validate
        if (!fOk) {

            // process each subagent query 
            while (pLE != &pNLE->Queries) {

                // retrieve pointer to query entry from link
                pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

                // dispatch 
                CallSubagent(
                    pQLE, 
                    SNMP_EXTENSION_SET_UNDO,
                    pNLE->nTransactionId
                    );

                // process results returned
                UpdateVarBinds(pNLE, pQLE);

                // previous entry 
                pLE = pLE->Blink;
            }
        }

        // point to last query
        pLE = pNLE->Queries.Blink;
    }
        
    // process each subagent query 
    while (pLE != &pNLE->Queries) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // dispatch 
        CallSubagent(
            pQLE, 
            SNMP_EXTENSION_SET_CLEANUP,
            pNLE->nTransactionId
            );

        // process results returned
        UpdateVarBinds(pNLE, pQLE);

        // previous entry 
        pLE = pLE->Blink;
    }

    // cleanup queries
    UnloadQueries(pNLE);

    return TRUE;
}


BOOL
ProcessGet(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Queries subagents to resolve varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE = NULL;
    BOOL fOk = TRUE;

    // load subagent queries
    if (!LoadQueries(pNLE)) {

        // unload immediately
        UnloadQueries(pNLE);

        // failure
        return FALSE;
    }
        
    // point to first query
    pLE = pNLE->Queries.Flink;

    // process each subagent query 
    while (fOk && (pLE != &pNLE->Queries)) {

        // retrieve pointer to query entry from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // load outgoing varbinds
        fOk = LoadSubagentData(pNLE, pQLE);

        // validate
        if (fOk) {

            // dispatch 
            CallSubagent(
                pQLE, 
                SNMP_EXTENSION_GET,
                pNLE->nTransactionId
                );

            // process results returned
            fOk = UpdateVarBinds(pNLE, pQLE);
        }

        // next entry
        pLE = pLE->Flink;        
    }
    
    // cleanup queries
    UnloadQueries(pNLE);

    return fOk;
}


BOOL
ProcessGetBulk(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Queries subagents to resolve varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE = NULL;
    BOOL fOk = TRUE;

    SNMPDBG((
        SNMP_LOG_VERBOSE,
        "SNMP: SVC: getbulk request, non-repeaters %d, max-repetitions %d.\n",
        pNLE->Pdu.Pdu.BulkPdu.nNonRepeaters,
        pNLE->Pdu.Pdu.BulkPdu.nMaxRepetitions
        ));

    // loop
    while (fOk) {

        // load subagent queries
        fOk = LoadQueries(pNLE);

        // validate
        if (fOk && !IsListEmpty(&pNLE->Queries)) {

            // point to first query
            pLE = pNLE->Queries.Flink;

            // process each subagent query 
            while (fOk && (pLE != &pNLE->Queries)) {

                // retrieve pointer to query entry from link
                pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

                // load outgoing varbinds
                fOk = LoadSubagentData(pNLE, pQLE);

                // validate
                if (fOk) {

                    // dispatch 
                    CallSubagent(
                        pQLE, 
                        SNMP_EXTENSION_GET_NEXT,
                        pNLE->nTransactionId
                        );

                    // process results returned
                    fOk = UpdateVarBinds(pNLE, pQLE);
                }

                // next entry
                pLE = pLE->Flink;        
            }

        } else if (IsListEmpty(&pNLE->Queries)) {

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: no more queries to process.\n"
                ));

            break; // finished...
        }

        // cleanup queries
        UnloadQueries(pNLE);
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocQLE(
    PQUERY_LIST_ENTRY * ppQLE
    )

/*++

Routine Description:

    Allocates query list entry.

Arguments:

    ppQLE - pointer to receive list entry pointer.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PQUERY_LIST_ENTRY pQLE = NULL;

    // attempt to allocate structure
    pQLE = AgentMemAlloc(sizeof(QUERY_LIST_ENTRY));

    // validate
    if (pQLE != NULL) {

        // initialize outgoing varbind list
        InitializeListHead(&pQLE->SubagentVbs);        

        // success
        fOk = TRUE;
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate query.\n"
            ));
    }    

    // transfer
    *ppQLE = pQLE;

    return fOk;
}


BOOL
FreeQLE(
    PQUERY_LIST_ENTRY pQLE
    )

/*++

Routine Description:

    Creates queries from varbind list entries.

Arguments:

    pNLE - pointer to network list entry with SNMP message.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pQLE != NULL) {

        // release subagent info
        UnloadSubagentData(pQLE);

        // release structure
        AgentMemFree(pQLE);
    }

    return TRUE;
}


BOOL
LoadQueries(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Creates queries from varbind list entries.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PVARBIND_LIST_ENTRY pVLE;
    PQUERY_LIST_ENTRY pQLE = NULL;

    // point to first varbind
    pLE = pNLE->Bindings.Flink;

    // process each binding
    while (pLE != &pNLE->Bindings) {

        // retrieve pointer to varbind entry from link
        pVLE = CONTAINING_RECORD(pLE, VARBIND_LIST_ENTRY, Link);

        // analyze current state of varbind        
        if ((pVLE->nState == VARBIND_INITIALIZED) ||
            (pVLE->nState == VARBIND_PARTIALLY_RESOLVED)) {

            // attempt to locate existing query
            if (FindQueryBySLE(&pQLE, pNLE, pVLE->pCurrentRLE->pSLE)) {

                // attach varbind entry to query via query link
                InsertTailList(&pQLE->SubagentVbs, &pVLE->QueryLink);

                // change varbind state
                pVLE->nState = VARBIND_RESOLVING;

                // increment total
                pQLE->nSubagentVbs++;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d added to existing query 0x%08lx.\n",
                    pVLE->nErrorIndex,
                    pQLE
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

            // attempt to allocate entry
            } else if (AllocQLE(&pQLE)) {
                
                // obtain subagent pointer
                pQLE->pSLE = pVLE->pCurrentRLE->pSLE;

                // insert into query list 
                InsertTailList(&pNLE->Queries, &pQLE->Link);

                // attach varbind entry to query via query link
                InsertTailList(&pQLE->SubagentVbs, &pVLE->QueryLink);

                // change varbind state
                pVLE->nState = VARBIND_RESOLVING;

                // increment total
                pQLE->nSubagentVbs++;

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d added to new query 0x%08lx.\n",
                    pVLE->nErrorIndex,
                    pQLE
                    ));    

                SNMPDBG((
                    SNMP_LOG_VERBOSE,
                    "SNMP: SVC: variable %d state '%s'.\n",
                    pVLE->nErrorIndex,
                    VARBINDSTATESTRING(pVLE->nState)
                    ));    

            } else {
                
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: could not contruct query.\n"
                    ));

                // failure
                return FALSE;
            }
        }

        // next entry
        pLE = pLE->Flink;
    }
    
    // success    
    return TRUE;
}


BOOL
UnloadQueries(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Destroys queries from varbind list entries.

Arguments:

    pNLE - pointer to network list entry with SNMP message.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PQUERY_LIST_ENTRY pQLE;
    
    // process each query entry
    while (!IsListEmpty(&pNLE->Queries)) {

        // point to first query
        pLE = RemoveHeadList(&pNLE->Queries);

        // retrieve pointer to query from link
        pQLE = CONTAINING_RECORD(pLE, QUERY_LIST_ENTRY, Link);

        // release
        FreeQLE(pQLE);
    }

    return TRUE;
}


BOOL
ProcessQueries(
    PNETWORK_LIST_ENTRY pNLE
    )

/*++

Routine Description:

    Queries subagents to resolve varbinds.

Arguments:

    pNLE - pointer to network list entry.

Return Values:

    Returns true if successful.

--*/

{
    // determine pdu
    switch (pNLE->Pdu.nType) {

    case SNMP_PDU_GETNEXT:
    case SNMP_PDU_GETBULK:
        
        // multiple non-exact reads
        return ProcessGetBulk(pNLE);

    case SNMP_PDU_GET:
    
        // single exact read
        return ProcessGet(pNLE);

    case SNMP_PDU_SET:

        // single exact write
        return ProcessSet(pNLE);
    }                

    // failure
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\args.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    args.c

Abstract:

    Contains routines for processing command line arguments.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "args.h"
#include "stdlib.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
ProcessArguments(
    DWORD  NumberOfArgs,
    LPSTR ArgumentPtrs[]
    )

/*++

Routine Description:

    Processes command line arguments.

Arguments:

    NumberOfArgs - number of command line arguments.
    ArgumentPtrs - array of pointers to arguments.

Return Values:

    Returns true if successful.

--*/

{
    DWORD  dwArgument;
    LPSTR pCurrentArg;

    // initialize logging arguments
    g_CmdLineArguments.nLogLevel = INVALID_ARGUMENT;
    g_CmdLineArguments.nLogType  = INVALID_ARGUMENT;

    // initialize service controller argument
    g_CmdLineArguments.fBypassCtrlDispatcher = FALSE;

    // process arguments
    while (NumberOfArgs--) {

        // retrieve argument pointer
        pCurrentArg = ArgumentPtrs[NumberOfArgs];

        // make sure valid argument passed
        if (IS_ARGUMENT(pCurrentArg, LOGLEVEL)) {

            // convert string into dword argument
            dwArgument = DWORD_ARGUMENT(pCurrentArg, LOGLEVEL);

            // store in global argument structure
            g_CmdLineArguments.nLogLevel = dwArgument;

            // modify the level at which logging occurs
            SnmpSvcSetLogLevel(g_CmdLineArguments.nLogLevel);

        } else if (IS_ARGUMENT(pCurrentArg, LOGTYPE)) {

            // convert string into dword argument
            dwArgument = DWORD_ARGUMENT(pCurrentArg, LOGTYPE);

            // store in global argument structure
            g_CmdLineArguments.nLogType = dwArgument;

            // modify the log type used during logging 
            SnmpSvcSetLogType(g_CmdLineArguments.nLogType);

        } else if (IS_ARGUMENT(pCurrentArg, DEBUG)) {

            // disable service controller when debugging
            g_CmdLineArguments.fBypassCtrlDispatcher = TRUE;

        } else if (NumberOfArgs) {
            
            SNMPDBG((
                SNMP_LOG_WARNING,
                "SNMP: SVC: Ignoring argument %s.\n",
                pCurrentArg
                ));
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\globals.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    Contains global data for SNMP master agent.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD  g_dwUpTimeReference = 0;
HANDLE g_hTerminationEvent = NULL;
HANDLE g_hRegistryEvent = NULL;

// notification event for changes in the default parameters registry tree
HANDLE g_hDefaultRegNotifier;
HKEY   g_hDefaultKey;
// notification event for changes in the policy parameters registry tree
HANDLE g_hPolicyRegNotifier;
HKEY   g_hPolicyKey;

LIST_ENTRY g_Subagents          = { NULL };
LIST_ENTRY g_SupportedRegions   = { NULL };
LIST_ENTRY g_ValidCommunities   = { NULL };
LIST_ENTRY g_TrapDestinations   = { NULL };
LIST_ENTRY g_PermittedManagers  = { NULL };
LIST_ENTRY g_IncomingTransports = { NULL };
LIST_ENTRY g_OutgoingTransports = { NULL };

CMD_LINE_ARGUMENTS g_CmdLineArguments;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\contexts.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    contexts.c

Abstract:

    Contains routines for manipulating SNMP community structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "contexts.h"
#include "snmpthrd.h"

#define DYN_REGISTRY_UPDATE 1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AddValidCommunity(
    LPWSTR pCommunity,
    DWORD dwAccess
    )

/*++

Routine Description:

    Adds valid community to list.

Arguments:

    pCommunity - pointer to community to add.

    dwAccess - access rights for community.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PCOMMUNITY_LIST_ENTRY pCLE = NULL;
    AsnOctetString CommunityOctets;
    
    // initialize octet string info
    CommunityOctets.length  = wcslen(pCommunity) * sizeof(WCHAR);
    CommunityOctets.stream  = (LPBYTE)pCommunity;
    CommunityOctets.dynamic = FALSE;

    // attempt to locate in list    
    if (FindValidCommunity(&pCLE, &CommunityOctets)) {
                    
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: updating community %s.\n",
            StaticUnicodeToString((LPWSTR)pCommunity)
            ));

        // update access rights
        pCLE->dwAccess = dwAccess;

        // success
        fOk = TRUE;

    } else {

        // allocate community structure
        if (AllocCLE(&pCLE, pCommunity)) {
                            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: adding community %s.\n",
                CommunityOctetsToString(&(pCLE->Community), TRUE)
                ));

            // insert into valid communities list
            InsertTailList(&g_ValidCommunities, &pCLE->Link);

            // update access rights
            pCLE->dwAccess = dwAccess;

            // success
            fOk = TRUE;
        }
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocCLE(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    LPWSTR                  pCommunity
    )

/*++

Routine Description:

    Allocates community structure and initializes.

Arguments:

    ppCLE - pointer to receive pointer to entry.

    pCommunity - pointer to community string.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PCOMMUNITY_LIST_ENTRY pCLE = NULL;

    // attempt to allocate structure
    pCLE = AgentMemAlloc(sizeof(COMMUNITY_LIST_ENTRY));

    // validate
    if (pCLE != NULL) {
        
        // determine string length
        DWORD nBytes = wcslen(pCommunity) * sizeof(WCHAR);

        // allocate memory for string (include terminator)
        pCLE->Community.stream = SnmpUtilMemAlloc(nBytes + sizeof(WCHAR));

        // validate community string stream
        if (pCLE->Community.stream != NULL) {

            // set length of manager string
            pCLE->Community.length = nBytes;
    
            // set memory allocation flag 
            pCLE->Community.dynamic = TRUE;

            // transfer community string into octets
            wcscpy((LPWSTR)(pCLE->Community.stream), pCommunity);

            // success
            fOk = TRUE;

        } else {
            
            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: could not copy community string %s.\n",
                StaticUnicodeToString(pCommunity)
                ));

            // release 
            FreeCLE(pCLE);

            // re-init
            pCLE = NULL;            
        }

    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate context entry for %s.\n",
            StaticUnicodeToString(pCommunity)
            ));
    }

    // transfer
    *ppCLE = pCLE;

    return fOk;
}


BOOL 
FreeCLE(
    PCOMMUNITY_LIST_ENTRY pCLE
    )

/*++

Routine Description:

    Releases community structure.

Arguments:

    pCLE - pointer to community list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pCLE != NULL) {

        // release octet string contents
        SnmpUtilOctetsFree(&pCLE->Community);

        // release structure
        AgentMemFree(pCLE);
    }

    return TRUE;
}


BOOL
FindValidCommunity(
    PCOMMUNITY_LIST_ENTRY * ppCLE,
    AsnOctetString *        pCommunity
    )

/*++

Routine Description:

    Locates valid community in list.

Arguments:

    ppCLE - pointer to receive pointer to entry.

    pCommunity - pointer to community to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PCOMMUNITY_LIST_ENTRY pCLE;

    // initialize
    *ppCLE = NULL;

    // obtain pointer to list head
    pLE = g_ValidCommunities.Flink;

    // process all entries in list
    while (pLE != &g_ValidCommunities) {

        // retrieve pointer to community structure
        pCLE = CONTAINING_RECORD(pLE, COMMUNITY_LIST_ENTRY, Link);

        // compare community string with entry
        if (!SnmpUtilOctetsCmp(&pCLE->Community, pCommunity)) {

            // transfer
            *ppCLE = pCLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


DWORD
ParsePermissionMask(
    DWORD bitMask
    )
/*++

Routine Description:

    Translates the permission mask from the bit-mask format (registry)
    into the internal constant value (constants from public\sdk\inc\snmp.h).
    The function works no longer if:
    - more than sizeof(DWORD)*8 permission values are defined
    - constant values (access policy) changes

Arguments:

    bit-mask.

Return Values:

    permission's constant value.

--*/
{
    DWORD dwPermission;

    for(dwPermission = 0; (bitMask & ((DWORD)(-1)^1)) != 0; bitMask>>=1, dwPermission++);

    return dwPermission;
}

#ifdef DYN_REGISTRY_UPDATE
LONG UpdateRegistry(
    HKEY hKey,
    LPWSTR wszBogus,
    LPWSTR wszCommunity
    )
/*++

Routine Description:

    Updates the registry configuration in order to be able to associate
    permission masks to each community:
                name            type        data
    old format: <whatever>      REG_SZ      community_name
    new format: community_name  REG_DWORD   permission_mask
Arguments:

    hKey - open handle to the key that contains the value
    szBogus - old format value name; useless data
    szCommunity - pointer to community name, as it was specified in the old format.

Return Values:

    Returns ERROR_SUCCESS if successful.

--*/
{
    LONG lStatus;
    DWORD dwDataSize = MAX_PATH;
    DWORD dwDataType;

    // make sure the update was not tried (and breaked) before
    dwDataSize = sizeof(DWORD);
    lStatus = RegQueryValueExW(
                hKey,
                wszCommunity,
                0,
                &dwDataType,
                NULL,
                &dwDataSize);

    // if no previous (breaked) update, convert community to the new format
    if (lStatus != ERROR_SUCCESS || dwDataType != REG_DWORD)
    {
        // permissions to be assigned to community
        DWORD dwPermissionMask;
        
        // all communities that are converted to new format at this point,
        // are converted to READ-CREATE permissions to ensure same functionality as
        // the permisionless communities.
        dwPermissionMask = 1 << SNMP_ACCESS_READ_CREATE;

        // set the new format value
        lStatus = RegSetValueExW(
                    hKey,
                    wszCommunity,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&dwPermissionMask,
                    sizeof(DWORD));

        if (lStatus != ERROR_SUCCESS)
            return lStatus;
    }

    // delete the old format value
    lStatus = RegDeleteValueW(
                hKey,
                wszBogus);

    return lStatus;
}
#endif


BOOL
LoadValidCommunities(
    BOOL bFirstCall
    )

/*++

Routine Description:

    Constructs list of valid communities.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    WCHAR wszName[MAX_PATH];  // get the UNICODE encoding for szName
    CHAR  szName[3*MAX_PATH]; // buffer for holding the translation UNICODE->UTF8
    DWORD dwNameSize;
    DWORD dwDataType;
    WCHAR wszData[MAX_PATH];  // get the UNICODE encoding for szData
    DWORD dwDataSize;
    BOOL fPolicy;
    LPTSTR pszKey;
    BOOL fOk = FALSE;
    
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading valid communities.\n"
        ));

#ifdef _POLICY
    // we need to provide precedence to the parameters set through the policy
    fPolicy = TRUE;
#else
    fPolicy = FALSE;
#endif

    do
    {
        // if the policy is to be enforced, check the policy registry location first
        pszKey = fPolicy ? REG_POLICY_VALID_COMMUNITIES : REG_KEY_VALID_COMMUNITIES;

        // open registry subkey    
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    pszKey,
                    0,
#ifdef DYN_REGISTRY_UPDATE
                    bFirstCall ? KEY_READ | KEY_SET_VALUE : KEY_READ,
#else
                    KEY_READ,
#endif
                    &hKey
                    );

        // if the call succeeded or we were not checking the policy, break the loop
        if (lStatus == ERROR_SUCCESS || !fPolicy)
            break;

        // being at this point, this means we were checking for the policy parameters.
        // If and only if the policy is not defined (registry key is missing) we
        // reset the error, mark 'fPolicy already tried' and go back into the loop
        if (lStatus == ERROR_FILE_NOT_FOUND)
        {
            lStatus = ERROR_SUCCESS;
            fPolicy = FALSE;
        }
    } while (lStatus == ERROR_SUCCESS);


    // validate return code
    if (lStatus == ERROR_SUCCESS) {

        // initialize
        dwIndex = 0;

        // loop until error or end of list
        for (dwIndex = 0;
             lStatus == ERROR_SUCCESS; 
             dwIndex++)

        {
            // initialize buffer sizes
            dwNameSize = sizeof(wszName) / sizeof(wszName[0]); // size in number of WCHARs, not the size in bytes
            dwDataSize = sizeof(wszData); // size in number of bytes

            // read next value
            lStatus = RegEnumValueW(
                        hKey, 
                        dwIndex, 
                        wszName, 
                        &dwNameSize,
                        NULL, 
                        &dwDataType, 
                        (LPBYTE)wszData, 
                        &dwDataSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS) {

                // dynamically update values that are not of DWORD type
                if (dwDataType != REG_DWORD)
                {
#ifdef DYN_REGISTRY_UPDATE
                    if (dwDataType == REG_SZ)
                    {
                        if (bFirstCall)
                        {
                            if(UpdateRegistry(hKey, wszName, wszData) == ERROR_SUCCESS)
                            {
                                SNMPDBG((
                                    SNMP_LOG_WARNING, 
                                    "SNMP: SVC: updated community registration\n"
                                ));

                                // current value has been deleted, need to keep the index
                                dwIndex--;
                                continue;
                            }
                        }
                        else
                        {
                            SNMPDBG((
                                SNMP_LOG_WARNING,
                                "SNMP: SVC: old format community to be considered with full rights"));

                            wcscpy(wszName, wszData);
                            *(DWORD *)wszData = (1 << SNMP_ACCESS_READ_CREATE);
                        }
                    }
                    else
#endif
                    {
                        SNMPDBG((
                            SNMP_LOG_WARNING, 
                            "SNMP: SVC: wrong format in ValidCommunities[%d] registry entry\n",
                            dwIndex
                        ));
                        continue;
                    }
                }

                // convert the UNICODE representation to UTF8 representation
                //dwNameSize = WideCharToMultiByte(
                //        CP_UTF8,
                //        0,
                //        wszName,
                //        wcslen(wszName),
                //        szName,
                //        sizeof(szName),
                //        NULL,
                //        NULL);

                // if error, just skip this community
                //if (dwNameSize == 0)
                //{
                //    SNMPDBG((
                //        SNMP_LOG_WARNING,
                //        "SNMP: SVC: community conversion to UTF8 failed with error %d.\n", GetLastError()));
                //    continue;
                //}

                // put the '\0' terminator to the string
                //szName[dwNameSize] = '\0';

                // add valid community to list with related permissions
                //if (AddValidCommunity(szName, ParsePermissionMask(*(DWORD *)wszData)))
                if (AddValidCommunity(wszName, ParsePermissionMask(*(DWORD *)wszData)))
                {

                    SNMPDBG((
                        SNMP_LOG_WARNING, 
                        "SNMP: SVC: rights set to %d for community '%s'\n",
                        *(DWORD *)wszData,
                        StaticUnicodeToString(wszName)
                    ));

                }
                else
                {
                    // reset status to reflect failure
                    lStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            
            }
            else if (lStatus == ERROR_NO_MORE_ITEMS)
            {
                // success
                fOk = TRUE; 
            }
        }
    } 
    else
        // it doesn't matter how the values are, the key has to exist,
        // so mark as bFirstCall in order to log an event if this is not true.
        bFirstCall = TRUE;  
    
    if (!fOk) {
            
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error %d processing ValidCommunities subkey.\n",
            lStatus
            ));

        // report an event only for the first call (initialization of the service).
        // otherwise subsequent registry ops through regedit might flood the event log with
        // unsignificant records
        if (bFirstCall)
            // report event
            ReportSnmpEvent(
                SNMP_EVENT_INVALID_REGISTRY_KEY, 
                1, 
                &pszKey, 
                lStatus
                );
    }
    return fOk;
}


BOOL
UnloadValidCommunities(
    )

/*++

Routine Description:

    Destroys list of valid communities.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PCOMMUNITY_LIST_ENTRY pCLE;

    // process entries until list is empty
    while (!IsListEmpty(&g_ValidCommunities)) {

        // extract next entry from head of list
        pLE = RemoveHeadList(&g_ValidCommunities);

        // retrieve pointer to community structure
        pCLE = CONTAINING_RECORD(pLE, COMMUNITY_LIST_ENTRY, Link);
 
        // release
        FreeCLE(pCLE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\regthrd.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    regthrd.c

Abstract:

    Contains routines for thread listening to registry changes.

Environment:

    User Mode - Win32

Revision History:

    Rajat Goel -- 24 Feb 1999
        - Creation

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "contexts.h"
#include "regions.h"
#include "snmpmgrs.h"
#include "trapmgrs.h"
#include "trapthrd.h"
#include "network.h"
#include "varbinds.h"
#include "snmpmgmt.h"
#include "registry.h"
#include <stdio.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
ProcessSubagentChanges(
    )

/*++

Routine Description:

    Procedure for checking for any changes in the Extension Agents parameter in
    the registry

Arguments:

Return Values:

    Returns true if successful.

--*/

{
    DWORD retval;
    DWORD cnt;
    HKEY hExAgentsKey = NULL;

    // Open the ..SNMP\Parameters\ExtensionAgents key
    retval = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_EXTENSION_AGENTS,
                0,
                KEY_READ,
                &hExAgentsKey
             );

    cnt = 0;

    if (retval != ERROR_SUCCESS)
    {
        LPTSTR pszKey = REG_KEY_EXTENSION_AGENTS;

        ReportSnmpEvent(
            SNMP_EVENT_INVALID_REGISTRY_KEY,
            1,
            &pszKey,
            retval);
    }

    while (retval == ERROR_SUCCESS)
    {
        DWORD dwNameSize;
        DWORD dwValueSize;
        DWORD dwValueType;
        DWORD dwPathSize;
        HKEY  hAgentKey = NULL;
        TCHAR szName[MAX_PATH];
        TCHAR szValue[MAX_PATH];
        CHAR szPath[MAX_PATH];
        CHAR szExpPath[MAX_PATH];
        PSUBAGENT_LIST_ENTRY pSLE = NULL;

        dwNameSize = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
        dwValueSize = sizeof(szValue); // size in number of bytes
        dwPathSize = sizeof(szPath);

        // Retrieve the registry path for the Extension Agent DLL key
        retval = RegEnumValue(
                    hExAgentsKey,
                    cnt, 
                    szName, 
                    &dwNameSize, 
                    NULL, 
                    &dwValueType, 
                    (LPBYTE)szValue, 
                    &dwValueSize
                    );

        // if failed to Enum the registry value, this is serious enough to break the loop
        if (retval != ERROR_SUCCESS)
            break;

        // Open the registry key for the current extension agent
        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szValue,
                    0,
                    KEY_READ,
                    &hAgentKey) == ERROR_SUCCESS)
        {
            // get the full pathname of the extension agent DLL
            if (RegQueryValueExA(
                            hAgentKey,
                            REG_VALUE_SUBAGENT_PATH, 
                            NULL,
                            &dwValueType, 
                            szPath, 
                            &dwPathSize
                            ) == ERROR_SUCCESS)
            {

                // Expand path
                ExpandEnvironmentStringsA(
                            szPath,
                            szExpPath,
                            sizeof(szExpPath));

                // Check if the DLL has already been loaded. If it has,
                // mark it. If not load it.
                if (FindSubagent(&pSLE, szExpPath))
                {
                    // If this extension agent already exists in the list,
                    // mark it such that it is not removed further
                    pSLE->uchFlags |= FLG_SLE_KEEP;
                }
                else
                {
                    // This is a new DLL, add it to the list and mark it to be kept
                    // while looking for the extension agents to be removed
                    if (!AddSubagentByDll(szExpPath, FLG_SLE_KEEP))
                    {
                        SNMPDBG((
                            SNMP_LOG_ERROR,
                            "SNMP: SVC: unable to load extension agent '%s'.\n", 
                            szExpPath
                            ));
                    }
             
                }

            }
            else
            {
                // we couldn't open the registry key which provides the full path to the DLL.
                // report the error but don't break the loop as there might be more subagents to handle
                SNMPDBG((
                    SNMP_LOG_ERROR,
                    "SNMP: SVC: unable to retrieve extension agent '%s' value.\n", 
                    REG_VALUE_SUBAGENT_PATH
                    ));
            }

            RegCloseKey(hAgentKey);

        }
        else
        {
            LPTSTR pSzValue = szValue;

            SNMPDBG((
                SNMP_LOG_ERROR,
                "SNMP: SVC: unable to open extension agent %s key.\n", szValue
                ));

            ReportSnmpEvent(
                SNMP_EVENT_INVALID_EXTENSION_AGENT_KEY,
                1,
                &pSzValue,
                retval);
        }

        cnt++;
    }

    // Go through the list of subagents. Unload any DLL's that were not marked
    // in the previous loop
    {
        PLIST_ENTRY pLE;
        PSUBAGENT_LIST_ENTRY pSLE;

        pLE = g_Subagents.Flink;

        while (pLE != &g_Subagents)
        {

            pSLE = CONTAINING_RECORD(pLE, SUBAGENT_LIST_ENTRY, Link);


            if (!(pSLE->uchFlags & FLG_SLE_KEEP))
            {

                RemoveEntryList(&(pSLE->Link));
                pLE = pLE->Flink;
                FreeSLE(pSLE);
                continue;

            }
            else
            {
                // reset the flag for next updates
                pSLE->uchFlags ^= FLG_SLE_KEEP;
            }

            pLE = pLE->Flink;
        }
    }
    
    if (retval == ERROR_NO_MORE_ITEMS)
        retval = ERROR_SUCCESS;

    if (hExAgentsKey != NULL)
        RegCloseKey(hExAgentsKey);

    return retval;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD
ProcessRegistryMessage(
    PVOID pParam
    )

/*++

Routine Description:

    Thread procedure for processing Registry Changes

Arguments:

    pParam - unused.

Return Values:

    Returns true if successful.

--*/

{
    DWORD retval = ERROR_SUCCESS;

    do
    {
        DWORD evntIndex;
        BOOL  bEvntSetOk;

        // Wait for registry change or Main thread termination
        evntIndex = WaitOnRegNotification();
        // for one change into the registry several notifications occur (key renaming, value addition,
        // value change, etc). In order to avoid useless (and counterproductive) notifications, wait
        // here for half of SHUTDOWN_WAIT_HINT.
        Sleep(SHUTDOWN_WAIT_HINT/2);
        // first thing to do is to re initialize the registry notifiers
        // otherwise we might miss some changes
        InitRegistryNotifiers();

        if (evntIndex == WAIT_FAILED)
        {
            retval = GetLastError();
            break;
        }

        if (evntIndex == WAIT_OBJECT_0)
        {
            // termination was signaled
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: shutting down the registry listener thread.\n"
            ));
            
            break;
        }

        //
        // unload and reload the registry parameters
        //

        // Used in ProcessSnmpMessages->RecvCompletionRoutine
        EnterCriticalSection(&g_RegCriticalSectionA);

        // Used in ProcessSubagentEvents
        EnterCriticalSection(&g_RegCriticalSectionB);

        // Used in GenerateTrap
        EnterCriticalSection(&g_RegCriticalSectionC);

        UnloadPermittedManagers();
        UnloadTrapDestinations();
        UnloadValidCommunities();
        UnloadSupportedRegions();

        // start reloading the registry with scalar parameters first
        // this is needed in order to know how to perform the name resolution
        // when loading PermittedManagers and TrapDestinations.
        LoadScalarParameters();

        // Check for subagent changes (extension agent dll's)
        if (ProcessSubagentChanges() != ERROR_SUCCESS)
            SNMPDBG((
                SNMP_LOG_TRACE,
                "SNMP: SVC: an error occured while trying to track registry subagent changes.\n"
            ));

        LoadSupportedRegions();

        LoadPermittedManagers(FALSE);
        LoadTrapDestinations(FALSE);
        // don't direct dynamic update for the ValidCommunities at this point!
        // if a REG_SZ entry occurs at this time, then it should be left as it is.
        LoadValidCommunities(FALSE);

        SetEvent(g_hRegistryEvent);

        LeaveCriticalSection(&g_RegCriticalSectionC);

        LeaveCriticalSection(&g_RegCriticalSectionB);

        LeaveCriticalSection(&g_RegCriticalSectionA);


        SNMPDBG((
            SNMP_LOG_TRACE,
            "SNMP: SVC: a registry change was detected.\n"
            ));

        ReportSnmpEvent(
            SNMP_EVENT_CONFIGURATION_UPDATED,
            0,
            NULL,
            0);

    } while(retval == ERROR_SUCCESS);

    if (retval != ERROR_SUCCESS)
    {
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: ** Failed in listening for registry changes **.\n"
            ));

        // log an event to system log file - SNMP service is going on but will not update on registry changes
        ReportSnmpEvent(
            SNMP_EVENT_REGNOTIFY_THREAD_FAILED, 
            0, 
            NULL, 
            retval);
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\registry.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Contains routines for manipulating registry parameters.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "registry.h"
#include "contexts.h"
#include "regions.h"
#include "trapmgrs.h"
#include "snmpmgrs.h"
#include "snmpmgmt.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT
InitRegistryNotifiers(
    )
/*++

Routine Description:

    Setup registry notifiers

Arguments:

    None.

Return Values:

    Returns the number of events that have been registered successfully

--*/
{
    DWORD  nEvents = 0;

    // on first call only create the default notifier
    if (g_hDefaultRegNotifier == NULL)
        g_hDefaultRegNotifier = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hDefaultKey == NULL)
    {
        RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_SNMP_PARAMETERS,
                0,
                KEY_READ,
                &g_hDefaultKey
                );
    }

    // setup the default registry notifier
    if (g_hDefaultRegNotifier &&
        g_hDefaultKey &&
        RegNotifyChangeKeyValue(
            g_hDefaultKey,
            TRUE,
            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
            g_hDefaultRegNotifier,
            TRUE
            ) == ERROR_SUCCESS)
    {
        SNMPDBG((SNMP_LOG_TRACE,
                 "SNMP: REG: Default reg notifier initialized successfully.\n"));
        nEvents++;
    }

#ifdef _POLICY
    // on first call only create the policy notifier
    if (g_hPolicyRegNotifier == NULL)
        g_hPolicyRegNotifier = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hPolicyKey == NULL)
    {
        RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REG_POLICY_ROOT,
            0,
            KEY_READ,
            &g_hPolicyKey
            );
    }

    // setup the policy registry notifier
    if (g_hPolicyRegNotifier &&
        g_hPolicyKey &&
        RegNotifyChangeKeyValue(
            g_hPolicyKey,
            TRUE,
            REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
            g_hPolicyRegNotifier,
            TRUE
            ) == ERROR_SUCCESS)
    {
        SNMPDBG((SNMP_LOG_TRACE,
                "SNMP: REG: Policy reg notifier initialized successfully.\n"));
        nEvents++;
    }

    SNMPDBG((SNMP_LOG_TRACE,
            "SNMP: REG: Initialized notifiers ... %d.\n", nEvents));
#endif

    return nEvents;
}

BOOL UnloadRegistryNotifiers();

INT
WaitOnRegNotification(
    )
/*++

Routine Description:

    Blocking call - waits for a notification that one of the registry parameters has change

Arguments:

    None.

Return Values:

    Returns the notifyer index (0 for the termination event, !=0 for parameter change)

--*/
{
    HANDLE hNotifiers[3]; // hack - we now (hardcoded) that we are not going to wait for more than three events.
    DWORD  dwNotifiers = 0;
    DWORD  retCode;

    hNotifiers[dwNotifiers++] = g_hTerminationEvent;
    
    if (g_hDefaultRegNotifier != NULL)
        hNotifiers[dwNotifiers++] = g_hDefaultRegNotifier;

#ifdef _POLICY
    if (g_hPolicyRegNotifier != NULL)
        hNotifiers[dwNotifiers++] = g_hPolicyRegNotifier;
#endif

    SNMPDBG((SNMP_LOG_WARNING,
            "SNMP: REG: Will listen for params changes on %d notifiers.\n",
            dwNotifiers));

    retCode = WaitForMultipleObjects(
                dwNotifiers,
                hNotifiers,
                FALSE,
                INFINITE);

    UnloadRegistryNotifiers();

    return retCode;
}
                       
/*++
    Inplace parser for the string formatted OID.
    It is done in O(n) where n is the length of the string formatted OID (two passes)
--*/
BOOL
ConvStringToOid(
    LPTSTR  pStr,
    AsnObjectIdentifier *pOid)
{
    LPTSTR pDup;
    int    iComp;
    DWORD  dwCompValue;
    enum
    {   DOT,
        DIGIT
    }  state = DIGIT;

    // no need to check for parameters consistency (internal call->correct call :o)

    // check the consistency and determine the number of components
    pOid->idLength = 0;

    if (*pStr == _T('.'))   // skip a possible leading '.'
        pStr++;

    for (pDup = pStr; *pDup != _T('\0'); pDup++)
    {
        switch(state)
        {
        case DOT:
            // note: a trailing dot results in a trailing 0
            if (*pDup == _T('.'))
            {
                pOid->idLength++;
                state = DIGIT;
                break;
            }
            // intentionally missing 'break'
        case DIGIT:
            if (*pDup < _T('0') || *pDup > _T('9'))
                return FALSE;
            state = DOT;
            break;
        }
    }
    // add one to the id length as a trailing dot might not be present
    pOid->idLength++;

    // accept oids with two components at least;
    // alloc memory and check for success;
    if (pOid->idLength < 2 ||
        (pOid->ids = SnmpUtilMemAlloc(pOid->idLength * sizeof(UINT))) == NULL)
        return FALSE;

    // we have now enough buffer and a correct input string. Just convert it to OID
    iComp = 0;
    dwCompValue = 0;
    for (pDup = pStr; *pDup != _T('\0'); pDup++)
    {
        if (*pDup == _T('.'))
        {
            pOid->ids[iComp++] = dwCompValue;
            dwCompValue = 0;
        }
        else
        {
            dwCompValue = dwCompValue * 10 + (*pDup - _T('0'));
        }
    }
    pOid->ids[iComp] = dwCompValue;

    return TRUE;
}

BOOL
LoadScalarParameters(
    )

/*++

Routine Description:

    Reads authentication trap flags key and manager timeout value.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    TCHAR szName[MAX_PATH];
    TCHAR szValue[MAX_PATH];
    LPTSTR pszKey = REG_KEY_SNMP_PARAMETERS;
    BOOL  bChangedSysID = FALSE;

    // default value for the IsnmpNameResolutionRetries counter
    // an address will resist to no more than MGRADDR_DYING (16 by default) 
    // consecutive name resolution failures.
    snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number = MGRADDR_DYING;

    // open registry subkey    
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS) 
    {
        // initialize
        dwIndex = 0;

        // loop until error or end of list
        while (lStatus == ERROR_SUCCESS) 
        {

            // initialize buffer sizes
            dwNameSize  = sizeof(szName) / sizeof(szName[0]); // size in number of TCHARs
            dwValueSize = sizeof(szValue); // size in number of bytes

            // read next value
            lStatus = RegEnumValue(
                        hKey, 
                        dwIndex, 
                        szName, 
                        &dwNameSize,
                        NULL, 
                        &dwValueType, 
                        (LPBYTE)szValue, 
                        &dwValueSize
                        );

            // validate return code
            if (lStatus == ERROR_SUCCESS)
            {

                // validate name of value
                if (!lstrcmpi(szName, REG_VALUE_AUTH_TRAPS))
                {
                    // set the 'EnableAuthenTraps' in the internal management structure
                    mgmtISet(IsnmpEnableAuthenTraps, *((PDWORD)&szValue));
                }
                else if (!lstrcmpi(szName, REG_VALUE_MGRRES_COUNTER))
                {
                    // set the 'NameResolutionRetries' in the internal management structure
                    mgmtISet(IsnmpNameResolutionRetries, *((PDWORD)&szValue));
                }
                            
                // next
                dwIndex++;

            }
        }

        RegCloseKey(hKey);
    } 

    // look into MIB2 subtree ..SNMP\Parameters\RFC1156Agent for sysObjectID parameter
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REG_KEY_MIB2,
                0,
                KEY_READ,
                &hKey
                );

    // validate return code
    if (lStatus == ERROR_SUCCESS)
    {
        LPTSTR  pszOid = szValue;

        dwValueSize = sizeof(szValue); // size in number of bytes

        // first, get the size of the buffer required for the sysObjectID parameter
        lStatus = RegQueryValueEx(
                    hKey,
                    REG_VALUE_SYS_OBJECTID,
                    0,
                    &dwValueType,
                    (LPBYTE)pszOid,
                    &dwValueSize);

        // the ERROR_MORE_DATA is the only error code we expect at this point
        if (lStatus == ERROR_MORE_DATA)
        {
            pszOid = SnmpUtilMemAlloc(dwValueSize);

            // if a buffer was set up correctly, go an read the oid value
            if (pszOid != NULL)
            {
                lStatus = RegQueryValueEx(
                            hKey,
                            REG_VALUE_SYS_OBJECTID,
                            0,
                            &dwValueType,
                            (LPBYTE)pszOid,
                            &dwValueSize);
            }
        }

        // at this point we should succeed
        if (lStatus == ERROR_SUCCESS)
        {
            AsnObjectIdentifier sysObjectID;
            // we have the string representation of the oid, convert it now to an AsnObjectIdentifier

            // implement the convertion here, as I don't want to make this a public function in SNMPAPI.DLL
            // otherwise I'll be forced to handle a lot of useless limit cases..
            if (dwValueType == REG_SZ &&
                ConvStringToOid(pszOid, &sysObjectID))
            {
                // don't free what has been alocated in ConvStringToOid as the buffer will be passed
                // to the management variable below.
                bChangedSysID = (mgmtOSet(OsnmpSysObjectID, &sysObjectID, FALSE) == ERROR_SUCCESS);
            }
            else
            {
                SNMPDBG((SNMP_LOG_WARNING,
                         "SNMP: SVC: LoadScalarParameters() - invalid type or value for sysObjectID param.\n"));

                ReportSnmpEvent(
                    SNMP_EVENT_INVALID_ENTERPRISEOID,
                    0,
                    NULL,
                    0);
            }
        }

        // cleanup the buffer if it was dynamically allocated
        if (pszOid != szValue)
            SnmpUtilMemFree(pszOid);

        // cleanup the registry key
        RegCloseKey(hKey);
    }

    if (!bChangedSysID)
    {
        mgmtOSet(OsnmpSysObjectID, SnmpSvcGetEnterpriseOID(), TRUE);
    }
    // all parameters here have default values, so there is no reason for this function to fail
    // if a parameter could not be found into the registry, its default value will be considered.
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
LoadRegistryParameters(
    )

/*++

Routine Description:

    Loads registry parameters.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // first thing to do is to setup the registry notifiers. If we don't do this before reading
    // the registry values we might not sense an initial change of the registry.
    InitRegistryNotifiers();

    // need to load first the scalar parameters especially to know how
    // to handle further the name resolution
    LoadScalarParameters();

    // load managers
    LoadPermittedManagers(TRUE);

    // load trap destinations
    LoadTrapDestinations(TRUE);

    // load communities with dynamic update
    LoadValidCommunities(TRUE);

    // load subagents
    LoadSubagents();

    // determine regions
    LoadSupportedRegions();

    return TRUE;
}

BOOL
UnloadRegistryNotifiers(
    )
/*++

Routine Description:

    Unloads registry notifiers

Arguments:

    None.

Return Values:

    Returns TRUE

--*/
{
    if (g_hDefaultRegNotifier != NULL)
    {
        CloseHandle(g_hDefaultRegNotifier);
        g_hDefaultRegNotifier = NULL;
    }
#ifdef _POLICY
    if (g_hPolicyRegNotifier != NULL)
    {
        CloseHandle(g_hPolicyRegNotifier);
        g_hPolicyRegNotifier = NULL;
    }
#endif

    if (g_hDefaultKey != NULL)
    {
        RegCloseKey(g_hDefaultKey);
        g_hDefaultKey = NULL;
    }
#ifdef _POLICY
    if (g_hPolicyKey != NULL)
    {
        RegCloseKey(g_hPolicyKey);
        g_hPolicyKey = NULL;
    }
#endif

    return TRUE;
}


BOOL
UnloadRegistryParameters(
    )

/*++

Routine Description:

    Unloads registry parameters.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // unload the registry notifiers as the first thing to do
    UnloadRegistryNotifiers();

    // unload managers
    UnloadPermittedManagers();

    // unload trap destinations
    UnloadTrapDestinations();

    // unload communities
    UnloadValidCommunities();

    // unload subagents
    UnloadSubagents();

    // unload mib regions
    UnloadSupportedRegions();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\service.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    service.c

Abstract:

    Contains service controller code for SNMP service.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "service.h"
#include "startup.h"
#include "trapthrd.h"
#include "registry.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SERVICE_STATUS_HANDLE g_SnmpSvcHandle = 0;
SERVICE_STATUS g_SnmpSvcStatus = {
    SERVICE_WIN32,      // dwServiceType                
    SERVICE_STOPPED,    // dwCurrentState    
    0,                  // dwControlsAccepted    
    NO_ERROR,           // dwWin32ExitCode    
    0,                  // dwServiceSpecificExitCode    
    0,                  // dwCheckPoint    
    0                   // dwWaitHint    
    };     


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
TerminateService(
    )

/*++

Routine Description:

    Shutdown SNMP service.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // signal io thread to terminate
    BOOL fOk = SetEvent(g_hTerminationEvent);
    
    if (!fOk) {
                
        SNMPDBG((
            SNMP_LOG_ERROR, 
            "SNMP: SVC: error 0x%08lx setting termination event.\n",
            GetLastError()
            ));
    }

    return fOk;
}


BOOL
UpdateController(
    DWORD dwCurrentState,
    DWORD dwWaitHint
    )

/*++

Routine Description:

    Notify service controller of SNMP service status.

Arguments:

    dwCurrentState - state of the service.

    dwWaitHint - worst case estimate to next checkpoint.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;

    // validate handle
    if (g_SnmpSvcHandle != 0) {

        static DWORD dwCheckPoint = 1;

        // check to see if the service is starting    
        if (dwCurrentState == SERVICE_START_PENDING) {

            // do not accept controls during startup
            g_SnmpSvcStatus.dwControlsAccepted = 0;

        } else {

            // only accept stop command during operation
            g_SnmpSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        }

        // if checkpoint needs incrementing
        if ((dwCurrentState == SERVICE_RUNNING) ||
            (dwCurrentState == SERVICE_STOPPED)) {

            // re-initialize checkpint    
            g_SnmpSvcStatus.dwCheckPoint = 0;
    
        } else {
            
            // increment checkpoint to denote processing
            g_SnmpSvcStatus.dwCheckPoint = dwCheckPoint++;
        }

        // update global status structure
        g_SnmpSvcStatus.dwCurrentState = dwCurrentState;
        g_SnmpSvcStatus.dwWaitHint     = dwWaitHint;
            
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: setting service status to %s (0x%08lx).\n",
            SERVICE_STATUS_STRING(g_SnmpSvcStatus.dwCurrentState),
            g_SnmpSvcStatus.dwCheckPoint
            ));
    
        // register current state with service controller
        fOk = SetServiceStatus(g_SnmpSvcHandle, &g_SnmpSvcStatus);

        if (!fOk) {
            
            SNMPDBG((
                SNMP_LOG_WARNING, 
                "SNMP: SVC: error 0x%08lx setting service status.\n",
                GetLastError()
                ));
        }
    }

    return fOk;
}


VOID
ProcessControllerRequests(
    DWORD dwOpCode
    )

/*++

Routine Description:

    Control handling function of SNMP service.

Arguments:

    dwOpCode - requested control code.

Return Values:

    None.

--*/

{
    DWORD dwCurrentState = SERVICE_RUNNING;
    DWORD dwWaitHint     = 0;
        
    SNMPDBG((
        SNMP_LOG_VERBOSE, 
        "SNMP: SVC: processing request to %s service.\n",
        SERVICE_CONTROL_STRING(dwOpCode)
        ));

    // handle command
    switch (dwOpCode) {

    case SERVICE_CONTROL_STOP:

        // change service status to stopping
        dwCurrentState = SERVICE_STOP_PENDING;    
        dwWaitHint     = SNMP_WAIT_HINT;

        break; 

    case SERVICE_CONTROL_INTERROGATE:

        //
        // update controller below...
        //

        break;

    default:

        // check for parameters 
        if (IS_LOGLEVEL(dwOpCode)) {

            UINT nLogLevel;

            // derive the new log level from the opcode            
            nLogLevel = dwOpCode - SNMP_SERVICE_LOGLEVEL_BASE;
            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: changing log level to %s.\n",
                SNMP_LOGLEVEL_STRING(nLogLevel)
                ));

            // store the new log level                     
            SnmpSvcSetLogLevel(nLogLevel);

        } else if (IS_LOGTYPE(dwOpCode)) {

            UINT nLogType;

            // derive the new log type from opcode
            nLogType = dwOpCode - SNMP_SERVICE_LOGTYPE_BASE;
            
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: changing log type to %s.\n",
                SNMP_LOGTYPE_STRING(nLogType)
                ));

            // store the new log type
            SnmpSvcSetLogType(nLogType);

        } else {
                                           
            SNMPDBG((
                SNMP_LOG_WARNING, 
                "SNMP: SVC: unhandled control code %d.\n",
                dwOpCode
                ));
        }

        break;        
    }

    // report status to controller
    UpdateController(dwCurrentState, dwWaitHint);

    // make sure to set shutdown event    
    if (dwCurrentState == SERVICE_STOP_PENDING) {

        // terminate
        TerminateService();
    }
}


BOOL 
WINAPI
ProcessConsoleRequests(
    DWORD dwOpCode
    )

/*++

Routine Description:

    Handle console control events.

Arguments:

    dwOpCode - requested control code.

Return Values:

    Returns true if request processed.

--*/

{
    BOOL fOk = FALSE;

    // check if user wants to exit
    if ((dwOpCode == CTRL_C_EVENT) ||
        (dwOpCode == CTRL_BREAK_EVENT)) {
                
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: processing ctrl-c request.\n"
            ));

        // stop service
        fOk = TerminateService();
    }
    
    return fOk;
} 


VOID
ServiceMain(
    IN DWORD  NumberOfArgs,
    IN LPTSTR  ArgumentPtrs[]
    )

/*++

Routine Description:

    Entry point of SNMP service.

Arguments:

    NumberOfArgs - number of command line arguments.
    ArgumentPtrs - array of pointers to arguments.

Return Values:

    None.

--*/

{
    // check if we need to bypass dispatcher
    if (!g_CmdLineArguments.fBypassCtrlDispatcher) {

        // register snmp with service controller
        g_SnmpSvcHandle = RegisterServiceCtrlHandler(
                                SNMP_SERVICE,
                                ProcessControllerRequests
                                );

        // validate handle
        if (g_SnmpSvcHandle == 0) { 

            // save error code in service status structure
            g_SnmpSvcStatus.dwWin32ExitCode = GetLastError();    
            
            SNMPDBG((
                SNMP_LOG_ERROR, 
                "SNMP: SVC: error 0x%08lx registering service.\n",
                g_SnmpSvcStatus.dwWin32ExitCode
                ));

            return; // bail...
        }
    }
    
    // report status to service controller
    UpdateController(SERVICE_START_PENDING, SNMP_WAIT_HINT);

    // startup agent
    if (StartupAgent()) {

        // report status to service controller
        UpdateController(SERVICE_RUNNING, NO_WAIT_HINT);

        // load registry
        // this is done after notifying the service controller that SNMP is up and running
        // because of the potential delay taken to load each subagent apart.
        // it is done here and not in the thread resumed below, because this call has to complete
        // before ProcessSubagentEvents() (data structures used in ProcessSubagentEvents() are initialized in
        // LoadRegistryParameters())
        // bugs: #259509 & #274055.
        LoadRegistryParameters();

        if (ResumeThread(g_hAgentThread) != 0xFFFFFFFF)
        {
            if (ResumeThread(g_hRegistryThread) == 0xFFFFFFFF) 
            {
                DWORD errCode = GetLastError();

                SNMPDBG((
                    SNMP_LOG_ERROR, 
                    "SNMP: SVC: error 0x%08lx starting the ProcessRegistryMessages thread.\n",
                    errCode
                    ));
                // log an event to system log file - SNMP service is going on but will not update on registry changes
                ReportSnmpEvent(
                    SNMP_EVENT_REGNOTIFY_THREAD_FAILED, 
                    0, 
                    NULL, 
                    errCode
                    );
            }
            // service subagents 
            ProcessSubagentEvents(); 
        }
        else
        {
            SNMPDBG((
                SNMP_LOG_ERROR, 
                "SNMP: SVC: error 0x%08lx starting the ProcessMessages thread.\n",
                GetLastError()
                ));
        }
    }

    // report status to service controller
    UpdateController(SERVICE_STOP_PENDING, SNMP_WAIT_HINT);

    // stop agent
    ShutdownAgent();
    
    // report status to service controller
    UpdateController(SERVICE_STOPPED, NO_WAIT_HINT);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

INT 
__cdecl 
main(
    DWORD  NumberOfArgs,
    LPSTR ArgumentPtrs[]
    )

/*++

Routine Description:

    Entry point of program.

Arguments:

    NumberOfArgs - number of command line arguments.
    ArgumentPtrs - array of pointers to arguments.

Return Values:

    None.

--*/

{
    BOOL fOk;
    DWORD dwLastError;

    static SERVICE_TABLE_ENTRY SnmpServiceTable[] =
        {{SNMP_SERVICE, ServiceMain}, {NULL, NULL}};

    // process command line arguments before starting
    if (ProcessArguments(NumberOfArgs, ArgumentPtrs)) {

        // create manual reset termination event for service
        g_hTerminationEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        // check if we need to bypass dispatcher
        if (g_CmdLineArguments.fBypassCtrlDispatcher) {
            
            SNMPDBG((    
                SNMP_LOG_TRACE,     
                "SNMP: SVC: bypassing service controller...\n"
                ));    
             
        
            // install console command handler
            SetConsoleCtrlHandler(ProcessConsoleRequests, TRUE);

            // dispatch snmp service manually
            ServiceMain(NumberOfArgs, (LPTSTR*)ArgumentPtrs);

        } else {
                            
            SNMPDBG((    
                SNMP_LOG_TRACE,     
                "SNMP: SVC: connecting to service controller...\n"
                ));    
             

            // attempt to connect to service controller
            fOk = StartServiceCtrlDispatcher(SnmpServiceTable);

            if (!fOk) {
        
                // retrieve controller failure
                dwLastError = GetLastError();

                // check to see whether or not the error was unexpected
                if (dwLastError == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT) {
                        
                    SNMPDBG((    
                        SNMP_LOG_TRACE,     
                        "SNMP: SVC: unable to connect so manually starting...\n"
                        ));    
                     

                    // make note that service is not connected
                    g_CmdLineArguments.fBypassCtrlDispatcher = TRUE;
                    
                    // install console command handler
                    SetConsoleCtrlHandler(ProcessConsoleRequests, TRUE);

                    // attempt to dispatch service manually
                    ServiceMain(NumberOfArgs, (LPTSTR*)ArgumentPtrs);

                } else {
                    
                    SNMPDBG((    
                        SNMP_LOG_ERROR,     
                        "SNMP: SVC: error 0x%08lx connecting to controller.\n", 
                        dwLastError
                        ));    
                }
            }
        }

        // close termination event
        CloseHandle(g_hTerminationEvent);
    }
    
    SNMPDBG((    
        SNMP_LOG_TRACE,     
        "SNMP: SVC: service exiting 0x%08lx.\n",    
        g_SnmpSvcStatus.dwWin32ExitCode
        ));    

    // return service status code
    return g_SnmpSvcStatus.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\regions.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    regions.c

Abstract:

    Contains routines for manipulating MIB region structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "subagnts.h"
#include "regions.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
UpdateSupportedRegion(
    PMIB_REGION_LIST_ENTRY pExistingRLE,
    PMIB_REGION_LIST_ENTRY pRLE
    )

/*++

Routine Description:

    Updates MIB region properties based on supporting subagent.

Arguments:

    pExisingRLE - pointer to existing MIB region to be updated.

    pRLE - pointer to subagent MIB region to be analyzed and saved.

Return Values:

    Returns true if successful.

--*/

{
    INT nDiff;
    PMIB_REGION_LIST_ENTRY pSubagentRLE;

    // see if source is subagent
    if (pRLE->pSubagentRLE == NULL) {
    
        // save pointer
        pSubagentRLE = pRLE;

    } else {

        // save pointer
        pSubagentRLE = pRLE->pSubagentRLE;
    }    

    // see if target uninitialized    
    if (pExistingRLE->pSubagentRLE == NULL) {

        // save pointer to subagent region
        pExistingRLE->pSubagentRLE = pSubagentRLE;

        // save pointer to supporting subagent
        pExistingRLE->pSLE = pSubagentRLE->pSLE;        

    } else {

        UINT nSubIds1;
        UINT nSubIds2;

        // determine length of existing subagent's original prefix
        nSubIds1 = pExistingRLE->pSubagentRLE->PrefixOid.idLength;

        // determine length of new subagent's prefix
        nSubIds2 = pSubagentRLE->PrefixOid.idLength;

        // update if more specific
        if (nSubIds1 <= nSubIds2) {
        
            // save pointer to subagent region
            pExistingRLE->pSubagentRLE = pSubagentRLE;

            // save pointer to supporting subagent
            pExistingRLE->pSLE = pSubagentRLE->pSLE;        
        }             
    }

    return TRUE;
}


BOOL
SplitSupportedRegion(
    PMIB_REGION_LIST_ENTRY   pRLE1,
    PMIB_REGION_LIST_ENTRY   pRLE2,
    PMIB_REGION_LIST_ENTRY * ppLastSplitRLE
    )

/*++

Routine Description:

    Splits existing MIB region in order to insert new region.

Arguments:

    pRLE1 - pointer to first MIB region to be split.

    pRLE2 - pointer to second MIB region to be split (not released).

    ppLastSplitRLE - pointer to receiver pointer to last split MIB region.

Return Values:

    Returns true if successful.

--*/

{
    INT nLimitDiff;
    INT nPrefixDiff;
    PMIB_REGION_LIST_ENTRY pRLE3 = NULL;
    PMIB_REGION_LIST_ENTRY pRLE4 = NULL;
    PMIB_REGION_LIST_ENTRY pRLE5 = NULL;
    BOOL fOk = TRUE;

    // allocate regions
    if (!AllocRLE(&pRLE3) ||
        !AllocRLE(&pRLE4) ||
        !AllocRLE(&pRLE5)) {

        // release
        FreeRLE(pRLE3);
        FreeRLE(pRLE4);
        FreeRLE(pRLE5);
    
        // failure
        return FALSE;
    }

    // initialize pointer
    *ppLastSplitRLE = pRLE5;

    // calculate difference betweeen mib region limits
    nLimitDiff = SnmpUtilOidCmp(&pRLE1->LimitOid, &pRLE2->LimitOid);
        
    // calculate difference betweeen mib region prefixes
    nPrefixDiff = SnmpUtilOidCmp(&pRLE1->PrefixOid, &pRLE2->PrefixOid);
        
    // check for same prefix        
    if (nPrefixDiff != 0) {

        // first prefix less 
        if (nPrefixDiff < 0) {

            // r3.prefix equals min(rl.prefix,r2.prefix)
            SnmpUtilOidCpy(&pRLE3->PrefixOid, &pRLE1->PrefixOid);

            // r3.limit equals max(rl.prefix,r2.prefix)
            SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE2->PrefixOid);

            // r3 is supported by r1 subagent 
            UpdateSupportedRegion(pRLE3, pRLE1);

        } else {

            // r3.prefix equals min(rl.prefix,r2.prefix)
            SnmpUtilOidCpy(&pRLE3->PrefixOid, &pRLE2->PrefixOid);

            // r3.limit equals max(rl.prefix,r2.prefix)
            SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE1->PrefixOid);

            // r3 is supported by r2 subagent 
            UpdateSupportedRegion(pRLE3, pRLE2);
        }

        // r4.prefix equals r3.limit
        SnmpUtilOidCpy(&pRLE4->PrefixOid, &pRLE3->LimitOid);

        // r4 is supported by both subagents
        UpdateSupportedRegion(pRLE4, pRLE1);
        UpdateSupportedRegion(pRLE4, pRLE2);

        // first limit less 
        if (nLimitDiff < 0) {

            // r4.limit equals min(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE1->LimitOid);

            // r5.prefix equals r4.limit
            SnmpUtilOidCpy(&pRLE5->PrefixOid, &pRLE4->LimitOid);

            // r5.limit equals max(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE5->LimitOid, &pRLE2->LimitOid);

            // r5 is supported by r2 subagent 
            UpdateSupportedRegion(pRLE5, pRLE2);

            // insert third mib region into list first
            InsertHeadList(&pRLE1->Link, &pRLE5->Link);

        } else if (nLimitDiff > 0) {

            // r4.limit equals min(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE2->LimitOid);

            // r5.prefix equals r4.limit
            SnmpUtilOidCpy(&pRLE5->PrefixOid, &pRLE4->LimitOid);

            // r5.limit equals max(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE5->LimitOid, &pRLE1->LimitOid);

            // r5 is supported by r1 subagent 
            UpdateSupportedRegion(pRLE5, pRLE1);

            // insert third mib region into list first
            InsertHeadList(&pRLE1->Link, &pRLE5->Link);

        } else {

            // r4.limit equals min(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE2->LimitOid);

            // return r4 as last
            *ppLastSplitRLE = pRLE4;

            // release
            FreeRLE(pRLE5);
        }

        // insert remaining mib regions into list
        InsertHeadList(&pRLE1->Link, &pRLE4->Link);
        InsertHeadList(&pRLE1->Link, &pRLE3->Link);

        // remove existing
        RemoveEntryList(&pRLE1->Link);

        // release
        FreeRLE(pRLE1);

    } else if (nLimitDiff != 0) {

        // r3.prefix equals same prefix for r1 and r2
        SnmpUtilOidCpy(&pRLE3->PrefixOid, &pRLE1->PrefixOid);

        // r3 is supported by both subagents
        UpdateSupportedRegion(pRLE3, pRLE1);
        UpdateSupportedRegion(pRLE3, pRLE2);

        // first limit less 
        if (nLimitDiff < 0) {

            // r3.limit equals min(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE1->LimitOid);

            // r4.prefix equals r3.limit
            SnmpUtilOidCpy(&pRLE4->PrefixOid, &pRLE3->LimitOid);

            // r4.limit equals max(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE2->LimitOid);

            // r4 is supported by r2 subagent
            UpdateSupportedRegion(pRLE4, pRLE2);

        } else {

            // r3.limit equals min(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE3->LimitOid, &pRLE2->LimitOid);

            // r4.prefix equals r3.limit
            SnmpUtilOidCpy(&pRLE4->PrefixOid, &pRLE3->LimitOid);

            // r4.limit equals max(rl.limit,r2.limit)
            SnmpUtilOidCpy(&pRLE4->LimitOid, &pRLE1->LimitOid);

            // r4 is supported by r1 subagent
            UpdateSupportedRegion(pRLE4, pRLE1);
        } 

        // return r4 as last
        *ppLastSplitRLE = pRLE4;

        // insert mib regions into list
        InsertHeadList(&pRLE1->Link, &pRLE4->Link);
        InsertHeadList(&pRLE1->Link, &pRLE3->Link);

        // remove existing
        RemoveEntryList(&pRLE1->Link);

        // release
        FreeRLE(pRLE1);
        FreeRLE(pRLE5);

    } else {

        // region supported existing subagent
        UpdateSupportedRegion(pRLE1, pRLE2);

        // return r1 as last
        *ppLastSplitRLE = pRLE1;

        // release
        FreeRLE(pRLE3);
        FreeRLE(pRLE4);
        FreeRLE(pRLE5);
    }

    // success
    return TRUE;
}


BOOL
InsertSupportedRegion(
    PMIB_REGION_LIST_ENTRY pExistingRLE,
    PMIB_REGION_LIST_ENTRY pRLE
    )

/*++

Routine Description:

    Splits existing MIB region in order to insert new region.

Arguments:

    pExisingRLE - pointer to existing MIB region to be split.

    pRLE - pointer to MIB region to be inserted.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk;
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pLastSplitRLE = NULL;
    INT nDiff;
    
    // attempt to split mib regions into pieces parts
    fOk = SplitSupportedRegion(pExistingRLE, pRLE, &pLastSplitRLE);

    // process remaining entries
    while (pLastSplitRLE != NULL) {

        // re-use stack pointer
        pExistingRLE = pLastSplitRLE;    

        // re-initialize 
        pLastSplitRLE = NULL;

        // obtain pointer to next entry        
        pLE = pExistingRLE->Link.Flink;

        // make sure entries remaining
        if (pLE != &g_SupportedRegions) {

            // retrieve pointer to mib region that follows last split one
            pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

            // compare mib regions
            nDiff = SnmpUtilOidCmp(
                        &pExistingRLE->LimitOid,
                        &pRLE->PrefixOid
                        );

            // overlapped?
            if (nDiff > 0) {

                // remove from list
                RemoveEntryList(&pRLE->Link);

                // split the two new overlapped mib regions
                SplitSupportedRegion(pExistingRLE, pRLE, &pLastSplitRLE);

                // release
                FreeRLE(pRLE);
            }
        }
    }                

    return fOk;
}
/*---debug purpose only----
void PrintSupportedRegion()
{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // obtain pointer to list head
    pLE = g_SupportedRegions.Flink;

    // process all entries in list
    while (pLE != &g_SupportedRegions) {

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);
        SNMPDBG((SNMP_LOG_VERBOSE,"\t[%s\n", SnmpUtilOidToA(&(pRLE->PrefixOid))));
        SNMPDBG((SNMP_LOG_VERBOSE,"\t\t%s]\n", SnmpUtilOidToA(&(pRLE->LimitOid))));

        // next entry
        pLE = pLE->Flink;
    }
    SNMPDBG((SNMP_LOG_VERBOSE,"----\n"));
}
*/

BOOL
AddSupportedRegion(
    PMIB_REGION_LIST_ENTRY pRLE
    )

/*++

Routine Description:

    Add subagent's MIB region into master agent's list.

Arguments:

    pRLE - pointer to MIB region to add to supported list.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE2;
    PMIB_REGION_LIST_ENTRY pExistingRLE;
    BOOL fFoundOk = FALSE;
    BOOL fOk = FALSE;
    INT nDiff;

//    PrintSupportedRegion();

    // attempt to locate prefix in existing mib regions
    if (FindFirstOverlappingRegion(&pExistingRLE, pRLE)) {
            
        // split existing region into bits
        fOk = InsertSupportedRegion(pExistingRLE, pRLE);

    } else {

        // obtain pointer to list head
        pLE = g_SupportedRegions.Flink;

        // process all entries in list
        while (pLE != &g_SupportedRegions) {

            // retrieve pointer to mib region 
            pExistingRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

            // compare region prefix
            nDiff = SnmpUtilOidCmp(&pRLE->PrefixOid, &pExistingRLE->PrefixOid);

            // found match?
            if (nDiff < 0) {

                // success
                fFoundOk = TRUE;

                break; // bail...
            } 

            // next entry
            pLE = pLE->Flink;
        }

        // validate pointer
        if (AllocRLE(&pRLE2)) {

            // transfer prefix oid from subagent region
            SnmpUtilOidCpy(&pRLE2->PrefixOid, &pRLE->PrefixOid);
        
            // transfer limit oid from subagent region
            SnmpUtilOidCpy(&pRLE2->LimitOid, &pRLE->LimitOid);

            // save region pointer
            pRLE2->pSubagentRLE = pRLE;

            // save subagent pointer
            pRLE2->pSLE = pRLE->pSLE;

            // validate
            if (fFoundOk) {

                // add new mib range into supported list 
                InsertTailList(&pExistingRLE->Link, &pRLE2->Link);

            } else {

                // add new mib range into global supported list
                InsertTailList(&g_SupportedRegions, &pRLE2->Link);
            }

            // success
            fOk = TRUE;
        }
    }

    return fOk;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocRLE(
    PMIB_REGION_LIST_ENTRY * ppRLE    
    )

/*++

Routine Description:

    Allocates MIB region structure and initializes.

Arguments:

    ppRLE - pointer to receive pointer to list entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMIB_REGION_LIST_ENTRY pRLE;
    
    // attempt to allocate structure
    pRLE = AgentMemAlloc(sizeof(MIB_REGION_LIST_ENTRY));

    // validate pointer
    if (pRLE != NULL) {

        // initialize links
        InitializeListHead(&pRLE->Link);

        // success
        fOk = TRUE;
    
    } else {
        
        SNMPDBG((
            SNMP_LOG_ERROR,
            "SNMP: SVC: could not allocate region entry.\n"
            ));
    }    

    // transfer
    *ppRLE = pRLE;

    return fOk;
}


BOOL 
FreeRLE(
    PMIB_REGION_LIST_ENTRY pRLE    
    )

/*++

Routine Description:

    Releases MIB region structure.

Arguments:

    ppRLE - pointer to MIB region to be freed.

Return Values:

    Returns true if successful.

--*/

{
    // validate pointer
    if (pRLE != NULL) {

        // release memory for prefix oid
        SnmpUtilOidFree(&pRLE->PrefixOid);

        // release memory for limit oid
        SnmpUtilOidFree(&pRLE->LimitOid);

        // release memory
        AgentMemFree(pRLE);
    }

    return TRUE;
}

BOOL    
UnloadRegions(
    PLIST_ENTRY pListHead
    )

/*++

Routine Description:

    Destroys list of MIB regions.

Arguments:

    pListHead - pointer to list of regions.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // process entries until empty
    while (!IsListEmpty(pListHead)) {

        // extract next entry from head 
        pLE = RemoveHeadList(pListHead);

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

        // release
        FreeRLE(pRLE);
    }

    return TRUE;
}

BOOL
FindFirstOverlappingRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    PMIB_REGION_LIST_ENTRY pNewRLE
    )
/*++

Routine Description:

    Detects if any existent region overlapps with the new one to be added.

Arguments:

    ppRLE - pointer to receive pointer to list entry.

    pNewRLE - pointer to new region to be tested
    
Return Values:

    Returns true if match found.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // initialize
    *ppRLE = NULL;

    // obtain pointer to list head
    pLE = g_SupportedRegions.Flink;

    // process all entries in list
    while (pLE != &g_SupportedRegions) {

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

        if (SnmpUtilOidCmp(&pNewRLE->PrefixOid, &pRLE->LimitOid) < 0 &&
            SnmpUtilOidCmp(&pNewRLE->LimitOid, &pRLE->PrefixOid) > 0)
        {
            *ppRLE = pRLE;
            return TRUE;
        } 

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
FindSupportedRegion(
    PMIB_REGION_LIST_ENTRY * ppRLE,
    AsnObjectIdentifier *    pPrefixOid,
    BOOL                     fAnyOk
    )

/*++

Routine Description:

    Locates MIB region in list.

Arguments:

    ppRLE - pointer to receive pointer to list entry.

    pPrefixOid - pointer to OID to locate within MIB region.
    
    fAnyOk - true if exact match not necessary.

Return Values:

    Returns true if match found.

--*/

{
    PLIST_ENTRY pLE;
    PMIB_REGION_LIST_ENTRY pRLE;
    INT nDiff;

    // initialize
    *ppRLE = NULL;

    // obtain pointer to list head
    pLE = g_SupportedRegions.Flink;

    // process all entries in list
    while (pLE != &g_SupportedRegions) {

        // retrieve pointer to mib region structure 
        pRLE = CONTAINING_RECORD(pLE, MIB_REGION_LIST_ENTRY, Link);

        // region prefix should be also the prefix for the given OID
        nDiff = SnmpUtilOidNCmp(pPrefixOid, &pRLE->PrefixOid, pRLE->PrefixOid.idLength);

        // found match?
        if ((nDiff < 0 && fAnyOk) ||
            (nDiff == 0 && SnmpUtilOidCmp(pPrefixOid, &pRLE->LimitOid) < 0))
        {
            *ppRLE = pRLE;
            return TRUE;
        } 

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
LoadSupportedRegions(
    )

/*++

Routine Description:

    Creates global list of supported MIB regions from subagent MIB regions.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE1;
    PLIST_ENTRY pLE2;
    PSUBAGENT_LIST_ENTRY pSLE;
    PMIB_REGION_LIST_ENTRY pRLE;

    // get subagent list head
    pLE1 = g_Subagents.Flink;

    // process all entries in list
    while (pLE1 != &g_Subagents) {

        // retrieve pointer to subagent structure 
        pSLE = CONTAINING_RECORD(pLE1, SUBAGENT_LIST_ENTRY, Link);

        SNMPDBG((
            SNMP_LOG_VERBOSE,
            "SNMP: SVC: Scan views supported by %s.\n",
            pSLE->pPathname
            ));

        // get supported regions list head
        pLE2 = pSLE->SupportedRegions.Flink;
        
        // process all entries in list
        while (pLE2 != &pSLE->SupportedRegions) {

            // retrieve pointer to mib region structure
            pRLE = CONTAINING_RECORD(pLE2, MIB_REGION_LIST_ENTRY, Link);

            SNMPDBG((
                SNMP_LOG_VERBOSE,
                "SNMP: SVC: view %s\n",
                SnmpUtilOidToA(&pRLE->PrefixOid)
                ));

            // attempt to add mib region    
            if (!AddSupportedRegion(pRLE)) {

                // failure
                return FALSE;
            }

            // next mib region
            pLE2 = pLE2->Flink;
        }

        // next subagent
        pLE1 = pLE1->Flink;
    }

    // success
    return TRUE;
}


BOOL
UnloadSupportedRegions(
    )

/*++

Routine Description:

    Destroys list of MIB regions.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    // unload global supported regions
    return UnloadRegions(&g_SupportedRegions);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\snmpevts.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpevts.c

Abstract:

    Eventlog message routines for the SNMP Service.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SNMP_FUNC_TYPE
ReportSnmpEvent(
    DWORD   nMsgId, 
    DWORD   nSubStrings, 
    LPTSTR *ppSubStrings,
    DWORD   nErrorCode
    )

/*++

Routine Description:

    Reports event with EventLog service.

Arguments:

    nMsgId - message identifier.

    nSubStrings - number of message strings.
    
    ppSubStrings - pointer to array of message strings.
    
    nErrorCode - error code to be attached to event.            

Return Values:

    Returns true if successful.

--*/

{
    HANDLE lh;
    WORD   wEventType;
    LPVOID lpData;
    WORD   cbData;

    //    
    // determine type of event from message id.  note that
    // all debug messages regardless of their severity are
    // listed under SNMP_EVENT_DEBUG_TRACE (informational).
    // see snmpevts.h for the entire list of event messages.
    //

    switch ( nMsgId >> 30 ) {

    case STATUS_SEVERITY_INFORMATIONAL:
    case STATUS_SEVERITY_SUCCESS:
        wEventType = EVENTLOG_INFORMATION_TYPE;
        break;

    case STATUS_SEVERITY_WARNING:
        wEventType = EVENTLOG_WARNING_TYPE;
        break;

    case STATUS_SEVERITY_ERROR:
    default:
        wEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    // determine size of data by whether error present
    cbData = (nErrorCode == NO_ERROR) ? 0 : sizeof(DWORD);
    lpData = (nErrorCode == NO_ERROR) ? NULL : &nErrorCode;

    // attempt to register event sources
    if (lh = RegisterEventSource(NULL, TEXT("SNMP"))) {

        // report
        ReportEvent(
           lh,
           wEventType,
           0,                  // event category
           nMsgId,
           NULL,               // user sids
           (WORD)nSubStrings,
           cbData,
           ppSubStrings,
           lpData
           );

        // deregister event source
        DeregisterEventSource(lh);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\snmp\newagent\exe\snmpmgrs.c ===
/*++

Copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    snmpmgrs.c

Abstract:

    Contains routines for manipulating manager structures.

Environment:

    User Mode - Win32

Revision History:

    10-Feb-1997 DonRyan
        Rewrote to implement SNMPv2 support.

--*/
 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Header files                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "globals.h"
#include "snmpmgrs.h"
#include "network.h"



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
AllocMLE(
    PMANAGER_LIST_ENTRY * ppMLE,
    LPSTR                 pManager
    )

/*++

Routine Description:

    Allocates manager structure and initializes.

Arguments:

    pManager - pointer to manager string.

    ppMLE - pointer to receive pointer to entry.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMANAGER_LIST_ENTRY pMLE = NULL;
    DWORD dwIpAddr;
    LPSTR pszManager;

    // attempt to allocate structure
    pMLE = AgentMemAlloc(sizeof(MANAGER_LIST_ENTRY));

    // validate
    if (pMLE != NULL) {

        // allocate memory for manager string
        pMLE->pManager = AgentMemAlloc(strlen(pManager)+1);

        // validate
        if (pMLE->pManager != NULL) {

            // transfer manager string
            strcpy(pMLE->pManager, pManager);

            // Attempt to resolve manager network address 
            // For IPX addresses, this call always succeeds
            // When SnmpSvcAddrToSocket fails, this means we deal with a dynamic IP Address
            // for which the gethostbyname() failed.
            if (SnmpSvcAddrToSocket(pMLE->pManager, &pMLE->SockAddr)) {

                // see if tcpip address
                if (pMLE->SockAddr.sa_family == AF_INET) {

                    // save structure size for later use
                    pMLE->SockAddrLen = sizeof(struct sockaddr_in);

                    pszManager = pMLE->pManager;

                    // attempt to convert address directly
                    dwIpAddr = inet_addr(pMLE->pManager);

                    // assume address is dynamic if error occurs
                    pMLE->fDynamicName = (dwIpAddr == SOCKET_ERROR);

                    // note time manager addr updated
                    pMLE->dwLastUpdate = GetCurrentTime();

                    // success
                    fOk = TRUE;

                } else if (pMLE->SockAddr.sa_family == AF_IPX) {

                    // save structure size for later use
                    pMLE->SockAddrLen = sizeof(struct sockaddr_ipx);

                    // no name lookup for ipx
                    pMLE->fDynamicName = FALSE;

                    // success
                    fOk = TRUE;
                }

                pMLE->dwAge = MGRADDR_ALIVE;

            } else {
                LPTSTR tcsManager;

#ifdef UNICODE
                SnmpUtilUTF8ToUnicode(&tcsManager, pMLE->pManager, TRUE);
#else
                tcsManager=pMLE->pManager;
#endif
                // at this point the address can be only an IP address!
                // so we know pMLE->SockAddrLen as the size of the struct sockaddr_in!
                pMLE->SockAddrLen = sizeof(struct sockaddr_in);

                // since SnmpSvcAddrToSocket failed, that means inet_addr() failed hence
                // we deal with a dynamic IP address
                pMLE->fDynamicName = TRUE;

                // set 'age' to dying
                pMLE->dwAge = snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number;

                // if the registry parameter is -1 this stands for 'keep retrying forever'
                // in this case set the dwAge to the default MGRADDR_DYING(16) and never decrement it
                if (pMLE->dwAge == (DWORD)-1)
                    pMLE->dwAge = MGRADDR_DYING;

                // report a warning to the system log
                ReportSnmpEvent(
                    SNMP_EVENT_NAME_RESOLUTION_FAILURE,
                    1,
                    &tcsManager,
                    0);

#ifdef UNICODE
                SnmpUtilMemFree(tcsManager);
#endif

                // success
                fOk = TRUE;
            }
        }
    
        // cleanup
        if (!fOk) {
    
            // release
            FreeMLE(pMLE);                

            // re-init
            pMLE = NULL;            
        }
    }

    // transfer
    *ppMLE = pMLE;

    return fOk;
}


BOOL
FreeMLE(
    PMANAGER_LIST_ENTRY pMLE
    )

/*++

Routine Description:

    Releases manager structure.

Arguments:

    pMLE - pointer to manager list entry to be freed.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;

    // validate pointer
    if (pMLE != NULL) {

        // release string
        AgentMemFree(pMLE->pManager);

        // release structure
        AgentMemFree(pMLE);
    }

    return TRUE;
}


BOOL
UpdateMLE(
    PMANAGER_LIST_ENTRY pMLE
    )

/*++

Routine Description:

    Updates manager structure.
	An address will be resolved only if it is not marked as being 'DEAD'. A 'DEAD' address failed to be resolved for
	more than MGRADDR_DYING times. A 'DEAD' address will no longer be used as a trap destination, but it will still
	be validating the incoming SNMP requests if it could be resolve at least once since the service started up.

Arguments:

    pMLE - pointer to manager list entry to be updated.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = TRUE;
    DWORD dwElaspedTime;
    struct sockaddr SockAddr;

    SNMPDBG((SNMP_LOG_TRACE,
             "SNMP: SVC: Update manager '%s' with age %d.\n",
             pMLE->pManager,
             pMLE->dwAge));

    // don't try to resolve this address if it is already dead
	if (pMLE->dwAge == MGRADDR_DEAD)
		return FALSE;

    // see if name dynamic
    if (pMLE->fDynamicName) {

        // determine elasped time since last update
        dwElaspedTime = GetCurrentTime() - pMLE->dwLastUpdate;

        // resolve the address only if it failed to be resolved on last update 
        // or its update time expired.
        if (pMLE->dwAge != MGRADDR_ALIVE || dwElaspedTime > DEFAULT_NAME_TIMEOUT) {
        
            // attempt to resolve manager network address
            // for IPX addresses, this call always succeeds
            fOk = SnmpSvcAddrToSocket(pMLE->pManager, &SockAddr);

            // validate
            if (fOk) {

                // update entry with new address
                memcpy(&pMLE->SockAddr, &SockAddr, sizeof(SockAddr));

                // note time dynamic name resolved
                pMLE->dwLastUpdate = GetCurrentTime();

                // make sure manager age is 'ALIVE'
                pMLE->dwAge = MGRADDR_ALIVE;

            } else if (pMLE->dwAge == MGRADDR_ALIVE) {

                // Previously 'ALIVE' address cannot be resolved anymore
				// set its age to the one specified by 'NameResolutionRetries' parameter in
				// order to give some more chances.
                pMLE->dwAge = snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number;

                // if the registry parameter is -1 this stands for 'keep retrying forever'
                // in this case set the dwAge to the default MGRADDR_DYING(16) which will never be decremented
                if (pMLE->dwAge == (DWORD)-1)
                    pMLE->dwAge = MGRADDR_DYING;

            } else if (pMLE->dwAge != MGRADDR_DEAD) {

				// the address could not be resolved before and it still cannot be resolved
				// decrement its retry counter only if the 'NameResolutionRetries' parameter says so
                if (snmpMgmtBase.AsnIntegerPool[IsnmpNameResolutionRetries].asnValue.number != -1)
                    pMLE->dwAge--;
            }
        }        
    }

    return fOk;
}


BOOL
FindManagerByName(
    PMANAGER_LIST_ENTRY * ppMLE,
    PLIST_ENTRY           pListHead,
    LPSTR                 pManager
    )

/*++

Routine Description:

    Locates manager in list.

Arguments:

    ppMLE - pointer to receive pointer to entry.

    pListHead - pointer to head of manager list.

    pManager - pointer to manager to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMANAGER_LIST_ENTRY pMLE;

    // initialize
    *ppMLE = NULL;

    // obtain pointer to list head
    pLE = pListHead->Flink;

    // process all entries in list
    while (pLE != pListHead) {

        // retrieve pointer to community structure
        pMLE = CONTAINING_RECORD(pLE, MANAGER_LIST_ENTRY, Link);

        // compare community string with entry
        if (!strcmp(pMLE->pManager, pManager)) {

            // transfer
            *ppMLE = pMLE;

            // success
            return TRUE;
        }

        // next entry
        pLE = pLE->Flink;
    }

    // failure
    return FALSE;
}


BOOL
IsManagerAddrLegal(
    struct sockaddr_in *  pAddr
    )
{
    DWORD dwHostMask;
    DWORD dwAddress = ntohl(pAddr->sin_addr.S_un.S_addr);

    // check address legality only for Ip addresses
    if (pAddr->sin_family != AF_INET)
        return TRUE;

    // disallow multicast (or future use) source addresses
    // local broadcast will be filtered out here as well
    if ((dwAddress & 0xe0000000) == 0xe0000000)
        return FALSE;

    // get hostmask for class 'C' addresses
    if ((dwAddress & 0xc0000000) == 0xc0000000)
        dwHostMask = 0x000000ff;

    // get hostmask for class 'B' addresses
    else if ((dwAddress & 0x80000000) == 0x80000000)
        dwHostMask = 0x0000ffff;

    // get hostidmask for class 'A' addresses
    else
        dwHostMask = 0x00ffffff;

    SNMPDBG((SNMP_LOG_TRACE,"SNMP: dwAddress=%08x, dwHostMask=%08x, port=%d\n",
             dwAddress, dwHostMask, ntohs(pAddr->sin_port)));

    return ((dwAddress & dwHostMask) != 0                              // check against net address
            && ((dwAddress & dwHostMask) != (0x00ffffff & dwHostMask)) // check against broadcast address
//          && ntohs(pAddr->sin_port) >= 1024                          // check against reserved port 
           );
}


BOOL
FindManagerByAddr(
    PMANAGER_LIST_ENTRY * ppMLE,
    struct sockaddr *     pSockAddr
    )

/*++

Routine Description:

    Locates permitted manager in list.

Arguments:

    ppMLE - pointer to receive pointer to entry.

    pSockAddr - pointer to socket address to find.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMANAGER_LIST_ENTRY pMLE;
    DWORD dwSockAddrLen;
    enum
    {
        SRCH_ALIVE,
        SRCH_DYING,
        SRCH_DONE
    } state;

    // initialize
    *ppMLE = NULL;

    // loop twice through the list of permitted managers
    // in the first loop look only through 'ALIVE' managers
    // in the second loop look through the 'DYING' or 'DEAD' managers.
    // ... this logic minimizes the response time for regular SNMP requests,
    // as far as there is a bigger chance to have the request comming from an 'ALIVE' manager.
    // otherwise, gethostbyname() called in UpdateMLE() lasts about 1/2 sec!!!
    for (state = SRCH_ALIVE, pLE = g_PermittedManagers.Flink;
         state != SRCH_DONE;
         pLE=pLE->Flink)
    {
        // retrieve pointer to manager structure
        pMLE = CONTAINING_RECORD(pLE, MANAGER_LIST_ENTRY, Link);

        // if we are in the first loop ..
        if (state == SRCH_ALIVE)
        {
            // .. but reached its end ..
            if (pLE == &g_PermittedManagers)
            {
                // .. go further with the second loop
                state = SRCH_DYING;
                continue;
            }

            // .. pass over the managers that are not 'ALIVE'
            if (pMLE->dwAge != MGRADDR_ALIVE)
                continue;
        }

        // if we are in the second loop ..
        if (state == SRCH_DYING)
        {
            // .. but reached its end ..
            if (pLE == &g_PermittedManagers)
            {
                // .. mark the end of scanning
                state = SRCH_DONE;
                continue;
            }

            // .. pass over the managers that are 'ALIVE'
            if (pMLE->dwAge == MGRADDR_ALIVE || pMLE->dwAge == MGRADDR_DEAD)
                continue;
        }

		// update name:
		// 'DEAD' addresses will no longer be resolved,
		// 'DYING' addresses will be given another chance to resolve until they become 'DEAD'
		// 'ALIVE' addresses that fail to resolve will become 'DYING'
		// next, all managers with a valid address will participate to validation (see below)
		UpdateMLE(pMLE);

        // compare address families
        if (IsValidSockAddr(&pMLE->SockAddr) &&
            pMLE->SockAddr.sa_family == pSockAddr->sa_family) 
        {
        
            // determine address family
            if (pMLE->SockAddr.sa_family == AF_INET) 
            {
        
                struct sockaddr_in * pSockAddrIn1; 
                struct sockaddr_in * pSockAddrIn2; 

                // obtain pointer to protocol specific structure
                pSockAddrIn1= (struct sockaddr_in *)pSockAddr;
                pSockAddrIn2= (struct sockaddr_in *)&pMLE->SockAddr;

				// acknowledge this manager only if its address matches
				// a permitted manager with a valid (not NULL) IP address.
				// This is tested regardless the 'dwAge' of the permitted manager.
                if (!memcmp(&pSockAddrIn1->sin_addr,
                            &pSockAddrIn2->sin_addr,
                            sizeof(pSockAddrIn2->sin_addr))) 
                {

                    // transfer
                    *ppMLE = pMLE;

                    // success
                    return TRUE;
                }
        
            }
            else if (pMLE->SockAddr.sa_family == AF_IPX) 
            {

                struct sockaddr_ipx * pSockAddrIpx1; 
                struct sockaddr_ipx * pSockAddrIpx2; 

                // obtain pointer to protocol specific structure
                pSockAddrIpx1= (struct sockaddr_ipx *)pSockAddr;
                pSockAddrIpx2= (struct sockaddr_ipx *)&pMLE->SockAddr;

                // acknowledge this manager only if its ipx address matches a 
				// permitted manager with a valid (nodenum != 0) IPX address.
				// This is tested regardless the 'dwAge' of the permitted manager.
                if (!memcmp(pSockAddrIpx1->sa_netnum,
                            pSockAddrIpx2->sa_netnum,
                            sizeof(pSockAddrIpx2->sa_netnum)) &&
                    !memcmp(pSockAddrIpx1->sa_nodenum,
                            pSockAddrIpx2->sa_nodenum,
                            sizeof(pSockAddrIpx2->sa_nodenum))) 
                {

                    // transfer
                    *ppMLE = pMLE;

                    // success
                    return TRUE;
                }
            }
        }
    }

    // failure
    return FALSE;
}


BOOL
AddManager(
    PLIST_ENTRY pListHead,
    LPSTR       pManager
    )

/*++

Routine Description:

    Adds manager structure to list.

Arguments:

    pListHead - pointer to head of list.

    pManager - pointer to manager to add.

Return Values:

    Returns true if successful.

--*/

{
    BOOL fOk = FALSE;
    PMANAGER_LIST_ENTRY pMLE = NULL;

    // attempt to locate in list    
    if (FindManagerByName(&pMLE, pListHead, pManager)) {
                    
        SNMPDBG((
            SNMP_LOG_TRACE, 
            "SNMP: SVC: updating manager %s.\n",
            pManager
            ));

        // success
        fOk = TRUE;

    } else {

        // allocate manager structure
        if (AllocMLE(&pMLE, pManager)) {
                        
            SNMPDBG((
                SNMP_LOG_TRACE, 
                "SNMP: SVC: adding manager %s.\n",
                pManager
                ));

            // insert into managers list
            InsertTailList(pListHead, &pMLE->Link);

            // success
            fOk = TRUE;
        }
    }

    return fOk;
}


BOOL
LoadManagers(
    HKEY        hKey,
    PLIST_ENTRY pListHead
    )

/*++

Routine Description:

    Constructs list of permitted managers.

Arguments:

    hKey - registry key containing manager values.

    pListHead - pointer to head of list.

Return Values:

    Returns true if successful.

--*/

{
    LONG lStatus;
    DWORD dwIndex;
    DWORD dwNameSize;
    DWORD dwValueSize;
    DWORD dwValueType;
    CHAR  szName[MAX_PATH];
    CHAR  szValue[MAX_PATH]; // buffer for holding the translation UNICODE->UTF8
    BOOL fOk = FALSE;
    
    // initialize
    dwIndex = 0;
    lStatus = ERROR_SUCCESS;

    // loop until error or end of list
    while (lStatus == ERROR_SUCCESS)
    {
        // initialize buffer sizes
        dwNameSize  = sizeof(szName);
        dwValueSize = sizeof(szValue);

        szValue[0] = '\0';

        // read next value
        lStatus = RegEnumValueA(
                    hKey, 
                    dwIndex, 
                    szName, 
                    &dwNameSize,
                    NULL, 
                    &dwValueType, 
                    szValue, 
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            szValue[dwValueSize]='\0';

            if (AddManager(pListHead, szValue)) // add valid manager to manager list
                dwIndex++;  //next
            else
                lStatus = ERROR_NOT_ENOUGH_MEMORY;   // reset status to reflect failure
        }
        else if (lStatus == ERROR_NO_MORE_ITEMS)
            fOk = TRUE;     // success
    }
    
    return fOk;
}


BOOL
UnloadManagers(
    PLIST_ENTRY pListHead
    )

/*++

Routine Description:

    Destroys list of permitted managers.

Arguments:

    pListHead - pointer to head of list.

Return Values:

    Returns true if successful.

--*/

{
    PLIST_ENTRY pLE;
    PMANAGER_LIST_ENTRY pMLE;

    // process entries until empty
    while (!IsListEmpty(pListHead)) {

        // extract next entry 
        pLE = RemoveHeadList(pListHead);

        // retrieve pointer to manager structure
        pMLE = CONTAINING_RECORD(pLE, MANAGER_LIST_ENTRY, Link);
 
        // release
        FreeMLE(pMLE);
    }

    return TRUE;
}


BOOL
LoadPermittedManagers(
    BOOL bFirstCall
    )

/*++

Routine Description:

    Constructs list of permitted managers.

Arguments:

    None.

Return Values:

    Returns true if successful.

--*/

{
    HKEY hKey;
    LONG lStatus;
    BOOL  fPolicy;
    LPTSTR pszKey;
    BOOL fOk = FALSE;
    
    SNMPDBG((
        SNMP_LOG_TRACE, 
        "SNMP: SVC: loading permitted managers.\n"
        ));

#ifdef _POLICY
    // we need to provide precedence to the parameters set through the policy
    fPolicy = TRUE;
#else
    fPolicy = FALSE;
#endif

    do
    {
        // if the policy is to be enforced, check the policy registry location first
        pszKey = fPolicy ? REG_POLICY_PERMITTED_MANAGERS : REG_KEY_PERMITTED_MANAGERS;

        // open registry subkey    
        lStatus = RegOpe